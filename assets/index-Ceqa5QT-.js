var t = Object.defineProperty,
  e = (e, n) => t(e, 'name', { value: n, configurable: !0 })
import {
  bj as n,
  bk as i,
  bl as s,
  a as r,
  c as a,
  aw as o,
  bm as l,
  aH as c,
  bn as h,
  a8 as u,
  bo as d,
  ap as p,
  u as m,
  L as f,
  bp as g,
  k as v,
  f as y,
  b as _,
  bq as x,
  br as b,
  bs as w,
  bb as M
} from './index-CXhECVBD.js'
import {
  mergeIfValid as S,
  getWidgetConfig as T,
  setWidgetConfig as E
} from './widgetInputs-rxCYoFG8.js'
class A extends n {
  static {
    e(this, 'ClipspaceDialog')
  }
  static items = []
  static instance = null
  static registerButton(t, e, n) {
    const s = i('button', {
      type: 'button',
      textContent: t,
      contextPredicate: e,
      onclick: n
    })
    A.items.push(s)
  }
  static invalidatePreview() {
    if (s.clipspace && s.clipspace.imgs && s.clipspace.imgs.length > 0) {
      const t = document.getElementById('clipspace_preview')
      t &&
        ((t.src = s.clipspace.imgs[s.clipspace.selectedIndex].src),
        (t.style.maxHeight = '100%'),
        (t.style.maxWidth = '100%'))
    }
  }
  static invalidate() {
    if (A.instance) {
      const t = A.instance,
        e = i('div.comfy-modal-content', [
          t.createImgSettings(),
          ...t.createButtons()
        ])
      t.element
        ? (t.element.firstChild && t.element.removeChild(t.element.firstChild),
          t.element.appendChild(e))
        : (t.element = i('div.comfy-modal', { parent: document.body }, [e])),
        t.element.children[0].children.length <= 1 &&
          t.element.children[0].appendChild(
            i('p', {}, [
              'Unable to find the features to edit content of a format stored in the current Clipspace.'
            ])
          ),
        A.invalidatePreview()
    }
  }
  constructor() {
    super()
  }
  createButtons() {
    const t = []
    for (let e in A.items) {
      const n = A.items[e]
      ;(n.contextPredicate && !n.contextPredicate()) || t.push(A.items[e])
    }
    return (
      t.push(
        i('button', {
          type: 'button',
          textContent: 'Close',
          onclick: e(() => {
            this.close()
          }, 'onclick')
        })
      ),
      t
    )
  }
  createImgSettings() {
    if (s.clipspace?.imgs) {
      const t = [],
        n = s.clipspace.imgs
      for (let e = 0; e < n.length; e++)
        t.push(i('option', { value: e }, [`${e}`]))
      const r = i(
          'select',
          {
            id: 'clipspace_img_selector',
            onchange: e((t) => {
              t.target &&
                s.clipspace &&
                ((s.clipspace.selectedIndex = t.target.selectedIndex),
                A.invalidatePreview())
            }, 'onchange')
          },
          t
        ),
        a = i('tr', {}, [
          i('td', {}, [i('font', { color: 'white' }, ['Select Image'])]),
          i('td', {}, [r])
        ]),
        o = i(
          'select',
          {
            id: 'clipspace_img_paste_mode',
            onchange: e((t) => {
              t.target &&
                s.clipspace &&
                (s.clipspace.img_paste_mode = t.target.value)
            }, 'onchange')
          },
          [
            i('option', { value: 'selected' }, 'selected'),
            i('option', { value: 'all' }, 'all')
          ]
        )
      o.value = s.clipspace.img_paste_mode
      const l = i('tr', {}, [
          i('td', {}, [i('font', { color: 'white' }, ['Paste Mode'])]),
          i('td', {}, [o])
        ]),
        c = i(
          'td',
          { align: 'center', width: '100px', height: '100px', colSpan: '2' },
          [
            i(
              'img',
              {
                id: 'clipspace_preview',
                ondragstart: e(() => !1, 'ondragstart')
              },
              []
            )
          ]
        ),
        h = i('tr', {}, [c])
      return i('table', {}, [a, l, h])
    }
    return []
  }
  createImgPreview() {
    return s.clipspace?.imgs
      ? i('img', {
          id: 'clipspace_preview',
          ondragstart: e(() => !1, 'ondragstart')
        })
      : []
  }
  show() {
    document.getElementById('clipspace_preview')
    A.invalidate(), (this.element.style.display = 'block')
  }
}
r.registerExtension({
  name: 'Comfy.Clipspace',
  init(t) {
    t.openClipspace = function () {
      A.instance ||
        ((A.instance = new A()),
        (s.clipspace_invalidate_handler = A.invalidate)),
        s.clipspace
          ? A.instance.show()
          : t.ui.dialog.show('Clipspace is Empty!')
    }
  }
}),
  (window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.clipspace = window.comfyAPI.clipspace || {}),
  (window.comfyAPI.clipspace.ClipspaceDialog = A)
const C = {
  name: 'Comfy.ContextMenuFilter',
  init() {
    const t = a.ContextMenu
    ;(a.ContextMenu = function (n, i) {
      const s = new t(n, i)
      if ('dark' === i?.className && n?.length > 4) {
        const t = document.createElement('input')
        t.classList.add('comfy-context-menu-filter'),
          (t.placeholder = 'Filter list'),
          s.root.prepend(t)
        const r = Array.from(s.root.querySelectorAll('.litemenu-entry'))
        let a = [...r],
          l = a.length
        requestAnimationFrame(() => {
          const c = o.active_canvas.current_node,
            h = c?.widgets
              ?.filter(
                (t) =>
                  'combo' === t.type && t.options.values?.length === n.length
              )
              .find((t) => t.options.values?.every((t, e) => t === n[e]))?.value
          let u = h ? n.findIndex((t) => t === h) : 0
          u < 0 && (u = 0)
          let d = a[u]
          function p() {
            d?.style.setProperty('background-color', ''),
              d?.style.setProperty('color', ''),
              (d = a[u]),
              d?.style.setProperty('background-color', '#ccc', 'important'),
              d?.style.setProperty('color', '#000', 'important')
          }
          p(), e(p, 'updateSelected')
          const m = e(() => {
            if (s.root.getBoundingClientRect().top < 0) {
              const t =
                  1 -
                  s.root.getBoundingClientRect().height / s.root.clientHeight,
                e = (s.root.clientHeight * t) / 2
              s.root.style.top = -e + 'px'
            }
          }, 'positionList')
          t.addEventListener('keydown', (t) => {
            switch (t.key) {
              case 'ArrowUp':
                t.preventDefault(), 0 === u ? (u = l - 1) : u--, p()
                break
              case 'ArrowRight':
                t.preventDefault(), (u = l - 1), p()
                break
              case 'ArrowDown':
                t.preventDefault(), u === l - 1 ? (u = 0) : u++, p()
                break
              case 'ArrowLeft':
                t.preventDefault(), (u = 0), p()
                break
              case 'Enter':
                d?.click()
                break
              case 'Escape':
                s.close()
            }
          }),
            t.addEventListener('input', () => {
              const e = t.value.toLocaleLowerCase()
              if (
                ((a = r.filter((t) => {
                  const n = !e || t.textContent?.toLocaleLowerCase().includes(e)
                  return (t.style.display = n ? 'block' : 'none'), n
                })),
                (u = 0),
                a.includes(d) && (u = a.findIndex((t) => t === d)),
                (l = a.length),
                p(),
                i.event)
              ) {
                let t = i.event.clientY - 10
                const e = document.body.getBoundingClientRect(),
                  n = s.root.getBoundingClientRect()
                e.height &&
                  t > e.height - n.height - 10 &&
                  (t = Math.max(0, e.height - n.height - 10)),
                  (s.root.style.top = t + 'px'),
                  m()
              }
            }),
            requestAnimationFrame(() => {
              t.focus(), m()
            })
        })
      }
      return s
    }),
      (a.ContextMenu.prototype = t.prototype)
  }
}
function R(t) {
  return t.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, '')
}
r.registerExtension(C),
  e(R, 'stripComments'),
  r.registerExtension({
    name: 'Comfy.DynamicPrompts',
    nodeCreated(t) {
      if (t.widgets) {
        const e = t.widgets.filter((t) => t.dynamicPrompts)
        for (const t of e)
          t.serializeValue = (e, n) => {
            let i = R(t.value)
            for (
              ;
              i.replace('\\{', '').includes('{') &&
              i.replace('\\}', '').includes('}');

            ) {
              const t = i.replace('\\{', '00').indexOf('{'),
                e = i.replace('\\}', '00').indexOf('}'),
                n = i.substring(t + 1, e).split('|'),
                s = n[Math.floor(Math.random() * n.length)]
              i = i.substring(0, t) + s + i.substring(e + 1)
            }
            return e?.widgets_values && (e.widgets_values[n] = i), i
          }
      }
    }
  }),
  r.registerExtension({
    name: 'Comfy.EditAttention',
    init() {
      const t = r.ui.settings.addSetting({
        id: 'Comfy.EditAttention.Delta',
        name: 'Ctrl+up/down precision',
        type: 'slider',
        attrs: { min: 0.01, max: 0.5, step: 0.01 },
        defaultValue: 0.05
      })
      function n(t, e) {
        const n = parseFloat(t)
        if (isNaN(n)) return t
        return String(Number((n + e).toFixed(10)))
      }
      function i(t, e) {
        let n = e,
          i = e,
          s = 0,
          r = 0
        for (; n >= 0 && (n--, '(' !== t[n] || s !== r); )
          '(' === t[n] && s++, ')' === t[n] && r++
        if (n < 0) return null
        for (s = 0, r = 0; i < t.length && (')' !== t[i] || s !== r); )
          '(' === t[i] && s++, ')' === t[i] && r++, i++
        return i === t.length ? null : { start: n + 1, end: i }
      }
      function s(t) {
        const e = t.match(/^\((.*)\)$/),
          n = t.match(/:([+-]?(\d*\.)?\d+([eE][+-]?\d+)?)/)
        return e && !n ? `(${e[1]}:1.0)` : t
      }
      function a(e) {
        const r = e.composedPath()[0],
          a = parseFloat(t.value)
        if ('TEXTAREA' !== r.tagName) return
        if ('ArrowUp' !== e.key && 'ArrowDown' !== e.key) return
        if (!e.ctrlKey && !e.metaKey) return
        e.preventDefault()
        let o = r.selectionStart,
          l = r.selectionEnd,
          c = r.value.substring(o, l)
        if (!c) {
          const t = i(r.value, o)
          if (t) (o = t.start), (l = t.end), (c = r.value.substring(o, l))
          else {
            const t = ' .,\\/!?%^*;:{}=-_`~()\r\n\t'
            for (; !t.includes(r.value[o - 1]) && o > 0; ) o--
            for (; !t.includes(r.value[l]) && l < r.value.length; ) l++
            if (((c = r.value.substring(o, l)), !c)) return
          }
        }
        ' ' === c[c.length - 1] &&
          ((c = c.substring(0, c.length - 1)), (l -= 1)),
          '(' === r.value[o - 1] &&
            ')' === r.value[l] &&
            ((o -= 1), (l += 1), (c = r.value.substring(o, l))),
          ('(' === c[0] && ')' === c[c.length - 1]) || (c = `(${c})`),
          (c = s(c))
        const h = 'ArrowUp' === e.key ? a : -a,
          u = c.replace(/\((.*):([+-]?\d+(?:\.\d+)?)\)/, (t, e, i) =>
            1 == (i = n(i, h)) ? e : `(${e}:${i})`
          )
        r.setSelectionRange(o, l),
          document.execCommand('insertText', !1, u),
          r.setSelectionRange(o, o + u.length)
      }
      e(n, 'incrementWeight'),
        e(i, 'findNearestEnclosure'),
        e(s, 'addWeightToParentheses'),
        e(a, 'editAttention'),
        window.addEventListener('keydown', a)
    }
  })
const P = Symbol(),
  I = 'workflow',
  L = '>'
function D(t, e) {
  if ('object' == typeof t && 'object' == typeof e)
    for (const n in e) {
      const i = e[n]
      if ('object' == typeof i) {
        let i = t[n]
        i || (i = t[n] = {}), D(i, e[n])
      } else t[n] = i
    }
  return t
}
e(D, 'merge')
class k extends n {
  static {
    e(this, 'ManageGroupDialog')
  }
  tabs
  selectedNodeIndex
  selectedTab = 'Inputs'
  selectedGroup
  modifications = {}
  nodeItems
  app
  groupNodeType
  groupNodeDef
  groupData
  innerNodesList
  widgetsPage
  inputsPage
  outputsPage
  draggable
  get selectedNodeInnerIndex() {
    return +this.nodeItems[this.selectedNodeIndex].dataset.nodeindex
  }
  constructor(t) {
    super(),
      (this.app = t),
      (this.element = i('dialog.comfy-group-manage', { parent: document.body }))
  }
  changeTab(t) {
    this.tabs[this.selectedTab].tab.classList.remove('active'),
      this.tabs[this.selectedTab].page.classList.remove('active'),
      this.tabs[t].tab.classList.add('active'),
      this.tabs[t].page.classList.add('active'),
      (this.selectedTab = t)
  }
  changeNode(t, e) {
    ;(e || this.selectedNodeIndex !== t) &&
      (null != this.selectedNodeIndex &&
        this.nodeItems[this.selectedNodeIndex].classList.remove('selected'),
      this.nodeItems[t].classList.add('selected'),
      (this.selectedNodeIndex = t),
      this.buildInputsPage() ||
        'Inputs' !== this.selectedTab ||
        this.changeTab('Widgets'),
      this.buildWidgetsPage() ||
        'Widgets' !== this.selectedTab ||
        this.changeTab('Outputs'),
      this.buildOutputsPage() ||
        'Outputs' !== this.selectedTab ||
        this.changeTab('Inputs'),
      this.changeTab(this.selectedTab))
  }
  getGroupData() {
    ;(this.groupNodeType =
      a.registered_node_types[`${I}${L}` + this.selectedGroup]),
      (this.groupNodeDef = this.groupNodeType.nodeData),
      (this.groupData = V.getGroupData(this.groupNodeType))
  }
  changeGroup(t, n = !0) {
    ;(this.selectedGroup = t), this.getGroupData()
    const s = this.groupData.nodeData.nodes
    if (
      ((this.nodeItems = s.map((t, n) =>
        i(
          'li.draggable-item',
          {
            dataset: { nodeindex: t.index + '' },
            onclick: e(() => {
              this.changeNode(n)
            }, 'onclick')
          },
          [
            i('span.drag-handle'),
            i(
              'div',
              { textContent: t.title ?? t.type },
              t.title ? i('span', { textContent: t.type }) : []
            )
          ]
        )
      )),
      this.innerNodesList.replaceChildren(...this.nodeItems),
      n)
    )
      (this.selectedNodeIndex = null), this.changeNode(0)
    else {
      let t = this.draggable
        .getAllItems()
        .findIndex((t) => t.classList.contains('selected'))
      ;-1 === t && (t = this.selectedNodeIndex), this.changeNode(t, !0)
    }
    const r = [...s]
    this.draggable?.dispose(),
      (this.draggable = new l(this.innerNodesList, 'li')),
      this.draggable.addEventListener(
        'dragend',
        ({ detail: { oldPosition: t, newPosition: e } }) => {
          if (t !== e) {
            r.splice(e, 0, r.splice(t, 1)[0])
            for (let t = 0; t < r.length; t++)
              this.storeModification({
                nodeIndex: r[t].index,
                section: P,
                prop: 'order',
                value: t
              })
          }
        }
      )
  }
  storeModification(t) {
    const { nodeIndex: e, section: n, prop: i, value: s } = t,
      r = (this.modifications[this.selectedGroup] ??= {}),
      a = (r.nodes ??= {}),
      o = (a[e ?? this.selectedNodeInnerIndex] ??= {}),
      l = (o[n] ??= {})
    if ('object' == typeof s) {
      const t = (l[i] ??= {})
      Object.assign(t, s)
    } else l[i] = s
  }
  getEditElement(t, n, s, r, a, o = !0) {
    s === r && (s = '')
    const l =
      this.modifications[this.selectedGroup]?.nodes?.[
        this.selectedNodeInnerIndex
      ]?.[t]?.[n]
    return (
      l &&
        (null != l.name && (s = l.name), null != l.visible && (a = l.visible)),
      i('div', [
        i('input', {
          value: s,
          placeholder: r,
          type: 'text',
          onchange: e((e) => {
            this.storeModification({
              section: t,
              prop: n,
              value: { name: e.target.value }
            })
          }, 'onchange')
        }),
        i('label', { textContent: 'Visible' }, [
          i('input', {
            type: 'checkbox',
            checked: a,
            disabled: !o,
            onchange: e((e) => {
              this.storeModification({
                section: t,
                prop: n,
                value: { visible: !!e.target.checked }
              })
            }, 'onchange')
          })
        ])
      ])
    )
  }
  buildWidgetsPage() {
    const t = this.groupData.oldToNewWidgetMap[this.selectedNodeInnerIndex],
      e = Object.keys(t ?? {}),
      n = r.graph.extra.groupNodes[this.selectedGroup],
      i = n.config?.[this.selectedNodeInnerIndex]?.input
    return (
      this.widgetsPage.replaceChildren(
        ...e.map((e) =>
          this.getEditElement('input', e, t[e], e, !1 !== i?.[e]?.visible)
        )
      ),
      !!e.length
    )
  }
  buildInputsPage() {
    const t = this.groupData.nodeInputs[this.selectedNodeInnerIndex],
      e = Object.keys(t ?? {}),
      n = r.graph.extra.groupNodes[this.selectedGroup],
      i = n.config?.[this.selectedNodeInnerIndex]?.input
    return (
      this.inputsPage.replaceChildren(
        ...e
          .map((e) => {
            let n = t[e]
            if (n)
              return this.getEditElement(
                'input',
                e,
                n,
                e,
                !1 !== i?.[e]?.visible
              )
          })
          .filter(Boolean)
      ),
      !!e.length
    )
  }
  buildOutputsPage() {
    const t = this.groupData.nodeData.nodes,
      e = this.groupData.getNodeDef(t[this.selectedNodeInnerIndex]),
      n = e?.output ?? [],
      i = this.groupData.oldToNewOutputMap[this.selectedNodeInnerIndex],
      s = r.graph.extra.groupNodes[this.selectedGroup],
      a = s.config?.[this.selectedNodeInnerIndex]?.output,
      o =
        'PrimitiveNode' !==
        this.groupData.nodeData.nodes[this.selectedNodeInnerIndex].type
    return (
      this.outputsPage.replaceChildren(
        ...n
          .map((t, n) => {
            const s = i?.[n],
              r = e.output_name?.[n] ?? t
            let l = a?.[n]?.name
            const c = a?.[n]?.visible || null != s
            return (
              (l && l !== r) || (l = ''),
              this.getEditElement('output', n, l, r, c, o)
            )
          })
          .filter(Boolean)
      ),
      !!n.length
    )
  }
  show(t) {
    const n = Object.keys(r.graph.extra?.groupNodes ?? {}).sort((t, e) =>
      t.localeCompare(e)
    )
    ;(this.innerNodesList = i('ul.comfy-group-manage-list-items')),
      (this.widgetsPage = i('section.comfy-group-manage-node-page')),
      (this.inputsPage = i('section.comfy-group-manage-node-page')),
      (this.outputsPage = i('section.comfy-group-manage-node-page'))
    const s = i('div', [this.widgetsPage, this.inputsPage, this.outputsPage])
    this.tabs = [
      ['Inputs', this.inputsPage],
      ['Widgets', this.widgetsPage],
      ['Outputs', this.outputsPage]
    ].reduce(
      (t, [n, s]) => (
        (t[n] = {
          tab: i('a', {
            onclick: e(() => {
              this.changeTab(n)
            }, 'onclick'),
            textContent: n
          }),
          page: s
        }),
        t
      ),
      {}
    )
    const o = i('div.comfy-group-manage-outer', [
      i('header', [
        i('h2', 'Group Nodes'),
        i(
          'select',
          {
            onchange: e((t) => {
              this.changeGroup(t.target.value)
            }, 'onchange')
          },
          n.map((e) =>
            i('option', {
              textContent: e,
              selected: `${I}${L}` + e === t,
              value: e
            })
          )
        )
      ]),
      i('main', [
        i('section.comfy-group-manage-list', this.innerNodesList),
        i('section.comfy-group-manage-node', [
          i(
            'header',
            Object.values(this.tabs).map((t) => t.tab)
          ),
          s
        ])
      ]),
      i('footer', [
        i(
          'button.comfy-btn',
          {
            onclick: e((t) => {
              r.graph.nodes.find(
                (t) => t.type === `${I}${L}` + this.selectedGroup
              )
                ? c().addAlert(
                    'This group node is in use in the current workflow, please first remove these.'
                  )
                : (confirm(
                    `Are you sure you want to remove the node: "${this.selectedGroup}"`
                  ) &&
                    (delete r.graph.extra.groupNodes[this.selectedGroup],
                    a.unregisterNodeType(`${I}${L}` + this.selectedGroup)),
                  this.show())
            }, 'onclick')
          },
          'Delete Group Node'
        ),
        i(
          'button.comfy-btn',
          {
            onclick: e(async () => {
              let t,
                e = []
              const n = {}
              for (const i in this.modifications) {
                const s = r.graph.extra.groupNodes[i]
                let a = (s.config ??= {}),
                  o = this.modifications[i]?.nodes
                if (o) {
                  const t = Object.keys(o)
                  if (o[t[0]][P]) {
                    const e = [],
                      n = {},
                      i = {}
                    for (const r of t) {
                      const t = o[r][P].order
                      ;(e[t] = s.nodes[+r]), (n[t] = o[r]), (e[t].index = t)
                    }
                    for (const t of s.links)
                      null != t[0] && (t[0] = s.nodes[t[0]].index),
                        null != t[2] && (t[2] = s.nodes[t[2]].index)
                    if (s.external)
                      for (const t of s.external) t[0] = s.nodes[t[0]]
                    for (const r of t)
                      a[r] && (i[s.nodes[r].index] = a[r]), delete a[r]
                    ;(s.nodes = e), (o = n), (s.config = a = i)
                  }
                  D(a, o)
                }
                ;(n[i] = s),
                  t ||
                    (t = r.graph.nodes.reduce(
                      (t, e) => ((t[e.type] ??= []), t[e.type].push(e), t),
                      {}
                    ))
                const l = t[`${I}${L}` + i]
                l && e.push(...l)
              }
              await z.registerFromWorkflow(n, {})
              for (const i of e) i.recreate()
              ;(this.modifications = {}),
                this.app.graph.setDirtyCanvas(!0, !0),
                this.changeGroup(this.selectedGroup, !1)
            }, 'onclick')
          },
          'Save'
        ),
        i(
          'button.comfy-btn',
          { onclick: e(() => this.element.close(), 'onclick') },
          'Close'
        )
      ])
    ])
    this.element.replaceChildren(o),
      this.changeGroup(t ? n.find((e) => `${I}${L}` + e === t) : n[0]),
      this.element.showModal(),
      this.element.addEventListener('close', () => {
        this.draggable?.dispose(), this.element.remove()
      })
  }
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.groupNodeManage = window.comfyAPI.groupNodeManage || {}),
  (window.comfyAPI.groupNodeManage.ManageGroupDialog = k)
const N = Symbol(),
  U = 'workflow',
  B = '>',
  O = {
    InUse: { Free: 0, Registered: 1, InWorkflow: 2 },
    isInUseGroupNode(t) {
      const e = `${U}${B}${t}`
      return r.graph.extra?.groupNodes?.[t]
        ? r.graph.nodes.find((t) => t.type === e)
          ? O.InUse.InWorkflow
          : O.InUse.Registered
        : O.InUse.Free
    },
    storeGroupNode(t, e) {
      let n = r.graph.extra
      n || (r.graph.extra = n = {})
      let i = n.groupNodes
      i || (n.groupNodes = i = {}), (i[t] = e)
    }
  }
class F {
  static {
    e(this, 'GroupNodeBuilder')
  }
  nodes
  nodeData
  constructor(t) {
    this.nodes = t
  }
  build() {
    const t = this.getName()
    if (t)
      return (
        this.sortNodes(),
        (this.nodeData = this.getNodeData()),
        O.storeGroupNode(t, this.nodeData),
        { name: t, nodeData: this.nodeData }
      )
  }
  getName() {
    const t = prompt('Enter group name')
    if (!t) return
    switch (O.isInUseGroupNode(t)) {
      case O.InUse.InWorkflow:
        return void c().addAlert(
          'An in use group node with this name already exists embedded in this workflow, please remove any instances or use a new name.'
        )
      case O.InUse.Registered:
        if (
          !confirm(
            'A group node with this name already exists embedded in this workflow, are you sure you want to overwrite it?'
          )
        )
          return
    }
    return t
  }
  sortNodes() {
    const t = r.graph.computeExecutionOrder(!1)
    this.nodes = this.nodes
      .map((e) => ({ index: t.indexOf(e), node: e }))
      .sort((t, e) => t.index - e.index || t.node.id - e.node.id)
      .map(({ node: t }) => t)
  }
  getNodeData() {
    const t = e((t) => {
        for (const e of t.links) {
          const t = r.graph.getNodeById(e[4]).outputs[e[1]].type
          e.push(t)
        }
      }, 'storeLinkTypes'),
      n = e((t) => {
        t.external = []
        for (let e = 0; e < this.nodes.length; e++) {
          const n = this.nodes[e]
          if (n.outputs?.length)
            for (let i = 0; i < n.outputs.length; i++) {
              let s = !1
              const a = n.outputs[i]
              let o = a.type
              if (a.links?.length) {
                for (const t of a.links) {
                  const e = r.graph.links[t]
                  if (
                    e &&
                    ('*' === o && (o = e.type),
                    !r.canvas.selected_nodes[e.target_id])
                  ) {
                    s = !0
                    break
                  }
                }
                s && t.external.push([e, i, o])
              }
            }
        }
      }, 'storeExternalLinks')
    try {
      const e = h(this.nodes, r.canvas.graph),
        i = JSON.parse(e)
      return t(i), n(i), i
    } finally {
    }
  }
}
class z {
  static {
    e(this, 'GroupNodeConfig')
  }
  name
  nodeData
  inputCount
  oldToNewOutputMap
  newToOldOutputMap
  oldToNewInputMap
  oldToNewWidgetMap
  newToOldWidgetMap
  primitiveDefs
  widgetToPrimitive
  primitiveToWidget
  nodeInputs
  outputVisibility
  nodeDef
  inputs
  linksFrom
  linksTo
  externalFrom
  constructor(t, e) {
    ;(this.name = t),
      (this.nodeData = e),
      this.getLinks(),
      (this.inputCount = 0),
      (this.oldToNewOutputMap = {}),
      (this.newToOldOutputMap = {}),
      (this.oldToNewInputMap = {}),
      (this.oldToNewWidgetMap = {}),
      (this.newToOldWidgetMap = {}),
      (this.primitiveDefs = {}),
      (this.widgetToPrimitive = {}),
      (this.primitiveToWidget = {}),
      (this.nodeInputs = {}),
      (this.outputVisibility = [])
  }
  async registerType(t = U) {
    ;(this.nodeDef = {
      output: [],
      output_name: [],
      output_is_list: [],
      output_is_hidden: [],
      name: t + B + this.name,
      display_name: this.name,
      category: 'group nodes' + (B + t),
      input: { required: {} },
      description: `Group node combining ${this.nodeData.nodes.map((t) => t.type).join(', ')}`,
      python_module: 'custom_nodes.' + this.name,
      [N]: this
    }),
      (this.inputs = [])
    const e = {},
      n = {}
    for (let i = 0; i < this.nodeData.nodes.length; i++) {
      const t = this.nodeData.nodes[i]
      ;(t.index = i), this.processNode(t, e, n)
    }
    for (const i of this.#t) i()
    ;(this.#t = null),
      await r.registerNodeDef(`${U}${B}` + this.name, this.nodeDef),
      u().addNodeDef(this.nodeDef)
  }
  getLinks() {
    ;(this.linksFrom = {}), (this.linksTo = {}), (this.externalFrom = {})
    for (const t of this.nodeData.links) {
      const [e, n, i, s] = t
      null != e &&
        (this.linksFrom[e] || (this.linksFrom[e] = {}),
        this.linksFrom[e][n] || (this.linksFrom[e][n] = []),
        this.linksFrom[e][n].push(t),
        this.linksTo[i] || (this.linksTo[i] = {}),
        (this.linksTo[i][s] = t))
    }
    if (this.nodeData.external)
      for (const t of this.nodeData.external)
        this.externalFrom[t[0]]
          ? (this.externalFrom[t[0]][t[1]] = t[2])
          : (this.externalFrom[t[0]] = { [t[1]]: t[2] })
  }
  processNode(t, e, n) {
    const i = this.getNodeDef(t)
    if (!i) return
    const s = { ...i.input?.required, ...i.input?.optional }
    this.inputs.push(this.processNodeInputs(t, e, s)),
      i.output?.length && this.processNodeOutputs(t, n, i)
  }
  getNodeDef(t) {
    const e = q[t.type]
    if (e) return e
    const n = this.linksFrom[t.index]
    if ('PrimitiveNode' === t.type) {
      if (!n) return
      let e = n[0][0][5]
      if ('COMBO' === e) {
        const i = t.outputs[0].widget.name,
          s = this.nodeData.nodes[n[0][0][2]].type,
          r = q[s]
        e = (r.input.required[i] ?? r.input.optional[i])[0]
      }
      return (this.primitiveDefs[t.index] = {
        input: { required: { value: [e, {}] } },
        output: [e],
        output_name: [],
        output_is_list: []
      })
    }
    if ('Reroute' === t.type) {
      const e = this.linksTo[t.index]
      if (e && n && !this.externalFrom[t.index]?.[0]) return null
      let i = {},
        s = '*'
      if (n)
        for (const [, , t, r] of n[0]) {
          const e = this.nodeData.nodes[t],
            n = e.inputs[r]
          if (('*' === s && (s = n.type), n.widget)) {
            const t = q[e.type],
              s =
                t.input.required[n.widget.name] ??
                t.input.optional[n.widget.name],
              r = [s[0], i],
              a = S({ widget: r }, s, !1, null, r)
            i = a?.customConfig ?? i
          }
        }
      else if (e) {
        const [t, n] = e[0]
        s = this.nodeData.nodes[t].outputs[n].type
      } else {
        for (const e of this.nodeData.links)
          if (e[2] === t.index) {
            s = e[5]
            break
          }
        if ('*' === s) {
          const e = this.externalFrom[t.index]?.[0]
          e && (s = e)
        }
      }
      return (
        (i.forceInput = !0),
        {
          input: { required: { [s]: [s, i] } },
          output: [s],
          output_name: [],
          output_is_list: []
        }
      )
    }
    console.warn(
      'Skipping virtual node ' +
        t.type +
        ' when building group node ' +
        this.name
    )
  }
  getInputConfig(t, e, n, i, s) {
    const r = this.nodeData.config?.[t.index]?.input?.[e]
    let a = r?.name ?? t.inputs?.find((t) => t.name === e)?.label ?? e,
      o = a,
      l = ''
    return (
      (('PrimitiveNode' === t.type && t.title) || a in n) &&
        ((l = `${t.title ?? t.type} `),
        (o = a = `${l}${e}`),
        a in n && (a = `${l}${n[a]} ${e}`)),
      (n[o] = (n[o] ?? 1) + 1),
      ('seed' !== e && 'noise_seed' !== e) ||
        (s || (s = {}),
        (s.control_after_generate = `${l}control_after_generate`)),
      'IMAGEUPLOAD' === i[0] &&
        (s || (s = {}),
        (s.widget =
          this.oldToNewWidgetMap[t.index]?.[i[1]?.widget ?? 'image'] ??
          'image')),
      s && (i = [i[0], { ...i[1], ...s }]),
      { name: a, config: i, customConfig: r }
    )
  }
  processWidgetInputs(t, e, n, i) {
    const s = [],
      a = new Map(),
      o = (this.oldToNewWidgetMap[e.index] = {})
    for (const l of n) {
      if (r.getWidgetType(t[l], l)) {
        const n = e.inputs?.findIndex(
          (t) => t.name === l && t.widget?.name === l
        )
        if (n > -1) a.set(n, l), (o[l] = null)
        else {
          const { name: n, config: s } = this.getInputConfig(e, l, i, t[l])
          ;(this.nodeDef.input.required[n] = s),
            (o[l] = n),
            (this.newToOldWidgetMap[n] = { node: e, inputName: l })
        }
      } else s.push(l)
    }
    return { converted: a, slots: s }
  }
  checkPrimitiveConnection(t, e, n) {
    if ('PrimitiveNode' === this.nodeData.nodes[t[0]].type) {
      const [i, s, r, a] = t,
        o = this.primitiveDefs[i],
        l = n[e],
        c = o.input.required.value,
        h = S({ widget: c }, l, !1, null, c)
      c[1] = (h?.customConfig ?? n[e][1]) ? { ...n[e][1] } : {}
      let u = this.oldToNewWidgetMap[i].value
      ;(u = u.substr(0, u.length - 6)),
        (c[1].control_after_generate = !0),
        (c[1].control_prefix = u)
      let d = this.widgetToPrimitive[r]
      d || (d = this.widgetToPrimitive[r] = {}),
        d[e] && d[e].push(i),
        (d[e] = i)
      let p = this.primitiveToWidget[i]
      p || (p = this.primitiveToWidget[i] = []),
        p.push({ nodeId: r, inputName: e })
    }
  }
  processInputSlots(t, e, n, i, s, r) {
    this.nodeInputs[e.index] = {}
    for (let a = 0; a < n.length; a++) {
      const o = n[a]
      if (i[a]) {
        this.checkPrimitiveConnection(i[a], o, t)
        continue
      }
      const {
        name: l,
        config: c,
        customConfig: h
      } = this.getInputConfig(e, o, r, t[o])
      ;(this.nodeInputs[e.index][o] = l),
        !1 !== h?.visible &&
          ((this.nodeDef.input.required[l] = c), (s[a] = this.inputCount++))
    }
  }
  processConvertedWidgets(t, e, n, i, s, r, a) {
    const o = [...i.keys()].sort().map((t) => i.get(t))
    for (let l = 0; l < o.length; l++) {
      const i = o[l]
      if (s[n.length + l]) {
        this.checkPrimitiveConnection(s[n.length + l], i, t)
        continue
      }
      const { name: c, config: h } = this.getInputConfig(e, i, a, t[i], {
        defaultInput: !0
      })
      ;(this.nodeDef.input.required[c] = h),
        (this.newToOldWidgetMap[c] = { node: e, inputName: i }),
        this.oldToNewWidgetMap[e.index] ||
          (this.oldToNewWidgetMap[e.index] = {}),
        (this.oldToNewWidgetMap[e.index][i] = c),
        (r[n.length + l] = this.inputCount++)
    }
  }
  #t = []
  processNodeInputs(t, e, n) {
    const i = Object.keys(n)
    if (!i.length) return
    const { converted: s, slots: r } = this.processWidgetInputs(n, t, i, e),
      a = this.linksTo[t.index] ?? {},
      o = (this.oldToNewInputMap[t.index] = {})
    return (
      this.processInputSlots(n, t, r, a, o, e),
      this.#t.push(() => this.processConvertedWidgets(n, t, r, s, a, o, e)),
      []
    )
  }
  processNodeOutputs(t, e, n) {
    const i = (this.oldToNewOutputMap[t.index] = {})
    for (let s = 0; s < n.output.length; s++) {
      const r = this.linksFrom[t.index],
        a = r?.[s] && !this.externalFrom[t.index]?.[s],
        o = this.nodeData.config?.[t.index]?.output?.[s],
        l = o?.visible ?? !a
      if ((this.outputVisibility.push(l), !l)) continue
      ;(i[s] = this.nodeDef.output.length),
        (this.newToOldOutputMap[this.nodeDef.output.length] = {
          node: t,
          slot: s
        }),
        this.nodeDef.output.push(n.output[s]),
        this.nodeDef.output_is_list.push(n.output_is_list[s])
      let c = o?.name
      if (!c) {
        c = n.output_name?.[s] ?? n.output[s]
        const e = t.outputs.find((t) => t.name === c)
        e?.label && (c = e.label)
      }
      let h = c
      if (h in e) {
        const n = `${t.title ?? t.type} `
        ;(h = `${n}${c}`), h in e && (h = `${n}${t.index} ${c}`)
      }
      ;(e[h] = 1), this.nodeDef.output_name.push(h)
    }
  }
  static async registerFromWorkflow(t, n) {
    for (const i in t) {
      const s = t[i]
      let r = !1
      for (const l of s.nodes)
        l.type in a.registered_node_types ||
          (n.push({ type: l.type, hint: ` (In group node '${U}${B}${i}')` }),
          n.push({
            type: `${U}${B}` + i,
            action: {
              text: 'Remove from workflow',
              callback: e((e) => {
                delete t[i],
                  (e.target.textContent = 'Removed'),
                  (e.target.style.pointerEvents = 'none'),
                  (e.target.style.opacity = 0.7)
              }, 'callback')
            }
          }),
          (r = !0))
      if (r) continue
      const o = new z(i, s)
      await o.registerType()
    }
  }
}
class V {
  static {
    e(this, 'GroupNodeHandler')
  }
  node
  groupData
  innerNodes
  constructor(t) {
    ;(this.node = t),
      (this.groupData = t.constructor?.nodeData?.[N]),
      (this.node.setInnerNodes = (t) => {
        this.innerNodes = t
        for (let e = 0; e < this.innerNodes.length; e++) {
          const n = this.innerNodes[e]
          for (const t of n.widgets ?? [])
            'converted-widget' === t.type &&
              (t.serializeValue = t.origSerializeValue)
          ;(n.index = e),
            (n.getInputNode = (e) => {
              const i = this.groupData.oldToNewInputMap[n.index]?.[e]
              if (null != i) return this.node.getInputNode(i)
              const s = this.groupData.linksTo[n.index]?.[e]
              if (!s) return null
              const r = t[s[0]]
              return 'PrimitiveNode' === r.type ? null : r
            }),
            (n.getInputLink = (e) => {
              const i = this.groupData.oldToNewInputMap[n.index]?.[e]
              if (null != i) {
                const t = this.node.inputs[i].link
                let s = r.graph.links[t]
                return (s = { ...s, target_id: n.id, target_slot: +e }), s
              }
              let s = this.groupData.linksTo[n.index]?.[e]
              return s
                ? ((s = {
                    origin_id: t[s[0]].id,
                    origin_slot: s[1],
                    target_id: n.id,
                    target_slot: +e
                  }),
                  s)
                : null
            })
        }
      }),
      (this.node.updateLink = (t) => {
        t = { ...t }
        const e = this.groupData.newToOldOutputMap[t.origin_slot]
        let n,
          i = this.innerNodes[e.node.index]
        for (; 'Reroute' === i?.type; )
          (n = i.getInputLink(0)), (i = i.getInputNode(0))
        return i
          ? n && V.isGroupNode(i)
            ? i.updateLink(n)
            : ((t.origin_id = i.id),
              (t.origin_slot = n?.origin_slot ?? e.slot),
              t)
          : null
      }),
      (this.node.getInnerNodes = () => (
        this.innerNodes ||
          this.node.setInnerNodes(
            this.groupData.nodeData.nodes.map((t, e) => {
              const n = a.createNode(t.type)
              return n.configure(t), (n.id = `${this.node.id}:${e}`), n
            })
          ),
        this.updateInnerWidgets(),
        this.innerNodes
      )),
      (this.node.recreate = async () => {
        const t = this.node.id,
          e = this.node.size,
          n = this.node.convertToNodes(),
          i = a.createNode(this.node.type)
        ;(i.id = t),
          i.setInnerNodes(n),
          i[N].populateWidgets(),
          r.graph.add(i),
          (i.size = [Math.max(i.size[0], e[0]), Math.max(i.size[1], e[1])])
        const s = new F(n).getNodeData()
        return (
          (i[N].groupData.nodeData.links = s.links), i[N].replaceNodes(n), i
        )
      }),
      (this.node.convertToNodes = () => {
        const n = e(() => {
            const t = { ...this.groupData.nodeData }
            t.nodes = [...t.nodes]
            const e = this.node.getInnerNodes()
            let n = []
            for (let r = 0; r < t.nodes.length; r++) {
              let i = e?.[r]?.id
              null == i || isNaN(i) ? (i = void 0) : n.push(i),
                (t.nodes[r] = { ...t.nodes[r], id: i })
            }
            d(JSON.stringify(t), r.canvas)
            const [i, s] = this.node.pos
            let a, o
            const l = n.length ? n : Object.keys(r.canvas.selected_nodes),
              c = []
            for (let h = 0; h < l.length; h++) {
              const t = l[h],
                n = r.graph.getNodeById(t),
                i = e[h]
              if (
                (c.push(n),
                (null == o || n.pos[0] < o) && (o = n.pos[0]),
                (null == a || n.pos[1] < a) && (a = n.pos[1]),
                !n.widgets)
              )
                continue
              const s = this.groupData.oldToNewWidgetMap[i.index]
              if (s) {
                const t = Object.keys(s)
                for (const e of t) {
                  const t = s[e]
                  if (!t) continue
                  const r = this.node.widgets.findIndex((e) => e.name === t)
                  if (-1 !== r)
                    if ('PrimitiveNode' === i.type)
                      for (let e = 0; e < n.widgets.length; e++)
                        n.widgets[e].value = this.node.widgets[r + e].value
                    else {
                      const t = this.node.widgets[r],
                        i = n.widgets.find((t) => t.name === e)
                      if (!i) continue
                      i.value = t.value
                      for (let e = 0; e < t.linkedWidgets?.length; e++)
                        i.linkedWidgets[e].value = t.linkedWidgets[e].value
                    }
                }
              }
            }
            for (const r of c) (r.pos[0] -= o - i), (r.pos[1] -= a - s)
            return { newNodes: c, selectedIds: l }
          }, 'addInnerNodes'),
          i = e((e) => {
            for (const n in this.groupData.oldToNewInputMap) {
              const i = e[n],
                s = r.graph.getNodeById(i),
                a = this.groupData.oldToNewInputMap[n]
              for (const e in a) {
                const n = a[e]
                if (null == n) continue
                const i = t.inputs[n]
                if (null == i.link) continue
                const o = r.graph.links[i.link]
                if (!o) continue
                r.graph.getNodeById(o.origin_id).connect(o.origin_slot, s, +e)
              }
            }
          }, 'reconnectInputs'),
          s = e((e) => {
            for (let n = 0; n < t.outputs?.length; n++) {
              const i = t.outputs[n]
              if (!i.links) continue
              const s = [...i.links]
              for (const t of s) {
                const i = this.groupData.newToOldOutputMap[n],
                  s = r.graph.links[t],
                  a = r.graph.getNodeById(s.target_id)
                r.graph
                  .getNodeById(e[i.node.index])
                  .connect(i.slot, a, s.target_slot)
              }
            }
          }, 'reconnectOutputs')
        r.canvas.emitBeforeChange()
        try {
          const { newNodes: t, selectedIds: e } = n()
          return i(e), s(e), r.graph.remove(this.node), t
        } finally {
          r.canvas.emitAfterChange()
        }
      })
    const n = this.node.getExtraMenuOptions
    this.node.getExtraMenuOptions = function (t, i) {
      n?.apply(this, arguments)
      let s = i.findIndex((t) => 'Outputs' === t.content)
      ;-1 === s ? (s = i.length) : s++,
        i.splice(
          s,
          0,
          null,
          {
            content: 'Convert to nodes',
            callback: e(() => this.convertToNodes(), 'callback')
          },
          {
            content: 'Manage Group Node',
            callback: e(() => X(this.type), 'callback')
          }
        )
    }
    const i = this.node.onDrawTitleBox
    this.node.onDrawTitleBox = function (t, e, n, s) {
      i?.apply(this, arguments)
      const r = t.fillStyle
      t.beginPath(),
        t.rect(11, 11 - e, 2, 2),
        t.rect(14, 11 - e, 2, 2),
        t.rect(17, 11 - e, 2, 2),
        t.rect(11, 14 - e, 2, 2),
        t.rect(14, 14 - e, 2, 2),
        t.rect(17, 14 - e, 2, 2),
        t.rect(11, 17 - e, 2, 2),
        t.rect(14, 17 - e, 2, 2),
        t.rect(17, 17 - e, 2, 2),
        (t.fillStyle = this.boxcolor || a.NODE_DEFAULT_BOXCOLOR),
        t.fill(),
        (t.fillStyle = r)
    }
    const s = t.onDrawForeground,
      o = this.groupData.nodeData
    t.onDrawForeground = function (e) {
      s?.apply?.(this, arguments)
      if (+r.runningNodeId === this.id && null !== this.runningInternalNodeId) {
        const n = o.nodes[this.runningInternalNodeId]
        if (!n) return
        const i = `Running ${n.title || n.type} (${this.runningInternalNodeId}/${o.nodes.length})`
        e.save(), (e.font = '12px sans-serif')
        const s = e.measureText(i)
        ;(e.fillStyle = t.boxcolor || a.NODE_DEFAULT_BOXCOLOR),
          e.beginPath(),
          e.roundRect(0, -a.NODE_TITLE_HEIGHT - 20, s.width + 12, 20, 5),
          e.fill(),
          (e.fillStyle = '#fff'),
          e.fillText(i, 6, -a.NODE_TITLE_HEIGHT - 6),
          e.restore()
      }
    }
    const l = this.node.onExecutionStart
    this.node.onExecutionStart = function () {
      return (this.resetExecution = !0), l?.apply(this, arguments)
    }
    const c = this,
      h = this.node.onNodeCreated
    function u(t, n, i) {
      const s = e(({ detail: e }) => {
        const s = n(e)
        if (!s) return
        if (r.graph.getNodeById(s)) return
        const a = this.innerNodes?.findIndex((t) => t.id == s)
        a > -1 &&
          ((this.node.runningInternalNodeId = a),
          p.dispatchCustomEvent(t, i(e, `${this.node.id}`, this.node)))
      }, 'handler')
      return p.addEventListener(t, s), s
    }
    ;(this.node.onNodeCreated = function () {
      if (!this.widgets) return
      const t = c.groupData.nodeData.config
      if (t)
        for (const e in t) {
          const n = t[e]?.input
          for (const t in n) {
            if (!1 !== n[t].visible) continue
            const i = c.groupData.oldToNewWidgetMap[e][t],
              s = this.widgets.find((t) => t.name === i)
            s && ((s.type = 'hidden'), (s.computeSize = () => [0, -4]))
          }
        }
      return h?.apply(this, arguments)
    }),
      e(u, 'handleEvent')
    const m = u.call(
        this,
        'executing',
        (t) => t,
        (t, e, n) => e
      ),
      f = u.call(
        this,
        'executed',
        (t) => t?.display_node || t?.node,
        (t, e, n) => ({
          ...t,
          node: e,
          display_node: e,
          merge: !n.resetExecution
        })
      ),
      g = t.onRemoved
    ;(this.node.onRemoved = function () {
      g?.apply(this, arguments),
        p.removeEventListener('executing', m),
        p.removeEventListener('executed', f)
    }),
      (this.node.refreshComboInNode = (t) => {
        for (const e in this.groupData.newToOldWidgetMap) {
          const n = this.node.widgets.find((t) => t.name === e)
          if ('combo' === n?.type) {
            const i = this.groupData.newToOldWidgetMap[e],
              s = t[i.node.type],
              r =
                s?.input?.required?.[i.inputName] ??
                s?.input?.optional?.[i.inputName]
            if (!r) continue
            ;(n.options.values = r[0]),
              'image' === i.inputName ||
                n.options.values.includes(n.value) ||
                ((n.value = n.options.values[0]), n.callback(n.value))
          }
        }
      })
  }
  updateInnerWidgets() {
    for (const t in this.groupData.newToOldWidgetMap) {
      const e = this.node.widgets.find((e) => e.name === t)
      if (!e) continue
      const n = e.value,
        i = this.groupData.newToOldWidgetMap[t]
      let s = this.innerNodes[i.node.index]
      if ('PrimitiveNode' === s.type) {
        s.primitiveValue = n
        const t = this.groupData.primitiveToWidget[i.node.index]
        for (const e of t ?? []) {
          const t = this.innerNodes[e.nodeId].widgets.find(
            (t) => t.name === e.inputName
          )
          t && (t.value = n)
        }
        continue
      }
      if ('Reroute' === s.type) {
        const t = this.groupData.linksFrom[i.node.index]
        if (t)
          for (const [e, , i, s] of t[0]) {
            const t = this.innerNodes[i],
              e = t.inputs[s]
            if (e.widget) {
              const i = t.widgets?.find((t) => t.name === e.widget.name)
              i && (i.value = n)
            }
          }
      }
      const r = s.widgets?.find((t) => t.name === i.inputName)
      r && (r.value = n)
    }
  }
  populatePrimitive(t, e, n, i, s) {
    const r = this.groupData.widgetToPrimitive[e]?.[n]
    if (null == r) return
    const a = this.groupData.oldToNewWidgetMap[r].value,
      o = this.node.widgets.findIndex((t) => t.name === a)
    if (o > -1) {
      const t = this.innerNodes[r]
      let e = t.widgets.length
      e - 1 !== this.node.widgets[o].linkedWidgets?.length && (e = 1)
      for (let n = 0; n < e; n++)
        this.node.widgets[o + n].value = t.widgets[n].value
    }
    return !0
  }
  populateReroute(t, e, n) {
    if ('Reroute' !== t.type) return
    const i = this.groupData.linksFrom[e]?.[0]?.[0]
    if (!i) return
    const [, , s, r] = i,
      a = this.groupData.nodeData.nodes[s],
      o = a.inputs,
      l = o?.[r]?.widget
    if (!l) return
    const c = o.length - (a.widgets_values?.length ?? 0),
      h = a.widgets_values?.[r - c]
    if (null == h) return
    const u = Object.values(n)[0],
      d = this.node.widgets.find((t) => t.name === u)
    d && (d.value = h)
  }
  populateWidgets() {
    if (this.node.widgets)
      for (let t = 0; t < this.groupData.nodeData.nodes.length; t++) {
        const e = this.groupData.nodeData.nodes[t],
          n = this.groupData.oldToNewWidgetMap[t] ?? {},
          i = Object.keys(n)
        if (!e.widgets_values?.length) {
          this.populateReroute(e, t, n)
          continue
        }
        let s = 0
        for (let r = 0; r < i.length; r++) {
          const a = i[r],
            o = n[a],
            l = this.node.widgets.findIndex((t) => t.name === o),
            c = this.node.widgets[l]
          if (this.populatePrimitive(e, t, a, r, s) || -1 === l) {
            const e = this.innerNodes[t].widgets?.find((t) => t.name === a)
            s += e?.linkedWidgets?.length ?? 0
          }
          if (-1 !== l) {
            c.value = e.widgets_values[r + s]
            for (let t = 0; t < c.linkedWidgets?.length; t++)
              this.node.widgets[l + t + 1].value = e.widgets_values[r + ++s]
          }
        }
      }
  }
  replaceNodes(t) {
    let e, n
    for (let i = 0; i < t.length; i++) {
      const s = t[i]
      ;(null == n || s.pos[0] < n) && (n = s.pos[0]),
        (null == e || s.pos[1] < e) && (e = s.pos[1]),
        this.linkOutputs(s, i),
        r.graph.remove(s)
    }
    this.linkInputs(), (this.node.pos = [n, e])
  }
  linkOutputs(t, e) {
    if (t.outputs)
      for (const n of t.outputs) {
        if (!n.links) continue
        const t = [...n.links]
        for (const n of t) {
          const t = r.graph.links[n]
          if (!t) continue
          const i = r.graph.getNodeById(t.target_id),
            s = this.groupData.oldToNewOutputMap[e]?.[t.origin_slot]
          null != s && this.node.connect(s, i, t.target_slot)
        }
      }
  }
  linkInputs() {
    for (const t of this.groupData.nodeData.links ?? []) {
      const [, e, n, i, s] = t,
        a = r.graph.getNodeById(s)
      a && a.connect(e, this.node.id, this.groupData.oldToNewInputMap[n][i])
    }
  }
  static getGroupData(t) {
    return (t.nodeData ?? t.constructor?.nodeData)?.[N]
  }
  static isGroupNode(t) {
    return !!t.constructor?.nodeData?.[N]
  }
  static async fromNodes(t) {
    const e = new F(t),
      n = e.build()
    if (!n) return
    const { name: i, nodeData: s } = n,
      o = new z(i, s)
    await o.registerType()
    const l = a.createNode(`${U}${B}${i}`)
    return (
      l.setInnerNodes(e.nodes),
      l[N].populateWidgets(),
      r.graph.add(l),
      l[N].replaceNodes(e.nodes),
      l
    )
  }
}
function H() {
  function t(t, e) {
    const n = Object.values(r.canvas.selected_nodes ?? {}),
      i = n.length < 2 || n.find((t) => V.isGroupNode(t))
    t.splice(e + 1, null, {
      content: 'Convert to Group Node',
      disabled: i,
      callback: W
    })
  }
  function n(t, e) {
    const n = r.graph.extra?.groupNodes,
      i = !n || !Object.keys(n).length
    t.splice(e + 1, null, {
      content: 'Manage Group Nodes',
      disabled: i,
      callback: X
    })
  }
  e(t, 'addConvertOption'), e(n, 'addManageOption')
  const i = o.prototype.getCanvasMenuOptions
  o.prototype.getCanvasMenuOptions = function () {
    const e = i.apply(this, arguments),
      s = e.findIndex((t) => 'Add Group' === t?.content) + 1 || e.length
    return t(e, s), n(e, s + 1), e
  }
  const s = o.prototype.getNodeMenuOptions
  o.prototype.getNodeMenuOptions = function (e) {
    const n = s.apply(this, arguments)
    if (!V.isGroupNode(e)) {
      const e = n.findIndex((t) => 'Outputs' === t?.content) + 1 || n.length - 1
      t(n, e)
    }
    return n
  }
}
e(H, 'addConvertToGroupOptions')
const G = e((t) => {
  for (const e of t)
    'string' == typeof e.type &&
      e.type.startsWith('workflow/') &&
      (e.type = e.type.replace(/^workflow\//, `${U}${B}`))
}, 'replaceLegacySeparators')
async function W() {
  const t = Object.values(r.canvas.selected_nodes ?? {})
  if (0 === t.length) throw new Error('No nodes selected')
  if (1 === t.length)
    throw new Error('Please select multiple nodes to convert to group node')
  if (t.some((t) => V.isGroupNode(t)))
    throw new Error('Selected nodes contain a group node')
  return await V.fromNodes(t)
}
function j() {
  const t = Object.values(r.canvas.selected_nodes ?? {})
  for (const e of t) V.isGroupNode(e) && e.convertToNodes?.()
}
function X(t) {
  new k(r).show(t)
}
e(W, 'convertSelectedNodesToGroupNode'),
  e(j, 'ungroupSelectedGroupNodes'),
  e(X, 'manageGroupNodes')
let q
const Y = {
  name: 'Comfy.GroupNode',
  commands: [
    {
      id: 'Comfy.GroupNode.ConvertSelectedNodesToGroupNode',
      label: 'Convert selected nodes to group node',
      icon: 'pi pi-sitemap',
      versionAdded: '1.3.17',
      function: W
    },
    {
      id: 'Comfy.GroupNode.UngroupSelectedGroupNodes',
      label: 'Ungroup selected group nodes',
      icon: 'pi pi-sitemap',
      versionAdded: '1.3.17',
      function: j
    },
    {
      id: 'Comfy.GroupNode.ManageGroupNodes',
      label: 'Manage group nodes',
      icon: 'pi pi-cog',
      versionAdded: '1.3.17',
      function: X
    }
  ],
  keybindings: [
    {
      commandId: 'Comfy.GroupNode.ConvertSelectedNodesToGroupNode',
      combo: { alt: !0, key: 'g' }
    },
    {
      commandId: 'Comfy.GroupNode.UngroupSelectedGroupNodes',
      combo: { alt: !0, shift: !0, key: 'G' }
    }
  ],
  setup() {
    H()
  },
  async beforeConfigureGraph(t, e) {
    const n = t?.extra?.groupNodes
    n && (G(t.nodes), await z.registerFromWorkflow(n, e))
  },
  addCustomNodeDefs(t) {
    q = t
  },
  nodeCreated(t) {
    V.isGroupNode(t) &&
      ((t[N] = new V(t)),
      t.title &&
        t[N]?.groupData?.nodeData &&
        O.storeGroupNode(t.title, t[N].groupData.nodeData))
  },
  async refreshComboInNodes(t) {
    Object.assign(q, t)
    const e = r.graph.extra?.groupNodes
    e && (await z.registerFromWorkflow(e, {}))
  }
}
function Z(t, e) {
  ;(t.mode = e), t.graph?.change()
}
function K(t, e) {
  const n = m().get('Comfy.GroupSelectedNodes.Padding')
  t.resizeTo([...t.children, ...e], n)
}
r.registerExtension(Y),
  (window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.groupNode = window.comfyAPI.groupNode || {}),
  (window.comfyAPI.groupNode.GroupNodeConfig = z),
  (window.comfyAPI.groupNode.GroupNodeHandler = V),
  e(Z, 'setNodeMode'),
  e(K, 'addNodesToGroup'),
  r.registerExtension({
    name: 'Comfy.GroupOptions',
    setup() {
      const t = o.prototype.getCanvasMenuOptions
      o.prototype.getCanvasMenuOptions = function () {
        const n = t.apply(this, arguments),
          i = this.graph.getGroupOnPos(this.graph_mouse[0], this.graph_mouse[1])
        if (!i)
          return (
            n.push({
              content: 'Add Group For Selected Nodes',
              disabled: !this.selectedItems?.size,
              callback: e(() => {
                const t = new f()
                K(t, this.selectedItems), this.graph.add(t), this.graph.change()
              }, 'callback')
            }),
            n
          )
        i.recomputeInsideNodes()
        const s = i.nodes
        if (
          (n.push({
            content: 'Add Selected Nodes To Group',
            disabled: !this.selectedItems?.size,
            callback: e(() => {
              K(i, this.selectedItems), this.graph.change()
            }, 'callback')
          }),
          0 === s.length)
        )
          return n
        n.push(null)
        let r = !0
        for (let t = 1; t < s.length; t++)
          if (s[t].mode !== s[0].mode) {
            r = !1
            break
          }
        if (
          (n.push({
            content: 'Fit Group To Nodes',
            callback: e(() => {
              i.recomputeInsideNodes()
              const t = m().get('Comfy.GroupSelectedNodes.Padding')
              i.resizeTo(i.children, t), this.graph.change()
            }, 'callback')
          }),
          n.push({
            content: 'Select Nodes',
            callback: e(() => {
              this.selectNodes(s), this.graph.change(), this.canvas.focus()
            }, 'callback')
          }),
          r)
        ) {
          switch (s[0].mode) {
            case 0:
              n.push({
                content: 'Set Group Nodes to Never',
                callback: e(() => {
                  for (const t of s) Z(t, 2)
                }, 'callback')
              }),
                n.push({
                  content: 'Bypass Group Nodes',
                  callback: e(() => {
                    for (const t of s) Z(t, 4)
                  }, 'callback')
                })
              break
            case 2:
              n.push({
                content: 'Set Group Nodes to Always',
                callback: e(() => {
                  for (const t of s) Z(t, 0)
                }, 'callback')
              }),
                n.push({
                  content: 'Bypass Group Nodes',
                  callback: e(() => {
                    for (const t of s) Z(t, 4)
                  }, 'callback')
                })
              break
            case 4:
              n.push({
                content: 'Set Group Nodes to Always',
                callback: e(() => {
                  for (const t of s) Z(t, 0)
                }, 'callback')
              }),
                n.push({
                  content: 'Set Group Nodes to Never',
                  callback: e(() => {
                    for (const t of s) Z(t, 2)
                  }, 'callback')
                })
              break
            default:
              n.push({
                content: 'Set Group Nodes to Always',
                callback: e(() => {
                  for (const t of s) Z(t, 0)
                }, 'callback')
              }),
                n.push({
                  content: 'Set Group Nodes to Never',
                  callback: e(() => {
                    for (const t of s) Z(t, 2)
                  }, 'callback')
                }),
                n.push({
                  content: 'Bypass Group Nodes',
                  callback: e(() => {
                    for (const t of s) Z(t, 4)
                  }, 'callback')
                })
          }
        } else
          n.push({
            content: 'Set Group Nodes to Always',
            callback: e(() => {
              for (const t of s) Z(t, 0)
            }, 'callback')
          }),
            n.push({
              content: 'Set Group Nodes to Never',
              callback: e(() => {
                for (const t of s) Z(t, 2)
              }, 'callback')
            }),
            n.push({
              content: 'Bypass Group Nodes',
              callback: e(() => {
                for (const t of s) Z(t, 4)
              }, 'callback')
            })
        return n
      }
    }
  })
const $ = 'Comfy.InvertMenuScrolling'
function J(t) {
  const e = t.split(';base64,'),
    n = e[0].split(':')[1],
    i = atob(e[1]),
    s = new ArrayBuffer(i.length),
    r = new Uint8Array(s)
  for (let a = 0; a < i.length; a++) r[a] = i.charCodeAt(a)
  return new Blob([s], { type: n })
}
function Q(t) {
  return new Promise((e, n) => {
    const i = new Image()
    ;(i.onload = function () {
      e(i)
    }),
      (i.src = t)
  })
}
async function tt(t, e) {
  await p
    .fetchApi('/upload/mask', { method: 'POST', body: e })
    .then((t) => {})
    .catch((t) => {
      console.error('Error:', t)
    }),
    (s.clipspace.imgs[s.clipspace.selectedIndex] = new Image()),
    (s.clipspace.imgs[s.clipspace.selectedIndex].src = p.apiURL(
      '/view?' +
        new URLSearchParams(t).toString() +
        r.getPreviewFormatParam() +
        r.getRandParam()
    )),
    s.clipspace.images && (s.clipspace.images[s.clipspace.selectedIndex] = t),
    A.invalidatePreview()
}
function et(t, e, n, i) {
  n.drawImage(t, 0, 0, e.width, e.height)
  const s = n.getImageData(0, 0, e.width, e.height)
  for (let r = 0; r < s.data.length; r += 4)
    255 == s.data[r + 3] ? (s.data[r + 3] = 0) : (s.data[r + 3] = 255),
      (s.data[r] = i.r),
      (s.data[r + 1] = i.g),
      (s.data[r + 2] = i.b)
  ;(n.globalCompositeOperation = 'source-over'), n.putImageData(s, 0, 0)
}
r.registerExtension({
  name: $,
  init() {
    const t = a.ContextMenu,
      n = e(() => {
        ;(a.ContextMenu = function (e, n) {
          return (
            (n = n || {}).scroll_speed
              ? (n.scroll_speed *= -1)
              : (n.scroll_speed = -0.1),
            t.call(this, e, n)
          )
        }),
          (a.ContextMenu.prototype = t.prototype)
      }, 'replace')
    r.ui.settings.addSetting({
      id: $,
      category: ['LiteGraph', 'Menu', 'InvertMenuScrolling'],
      name: 'Invert Context Menu Scrolling',
      type: 'boolean',
      defaultValue: !1,
      onChange(e) {
        e ? n() : (a.ContextMenu = t)
      }
    })
  }
}),
  r.registerExtension({
    name: 'Comfy.Keybinds',
    init() {
      const t = e(async function (t) {
        if (!r.vueAppReady) return
        const e = g.fromEvent(t)
        if (e.isModifier) return
        const n = t.composedPath()[0]
        if (
          !e.hasModifier &&
          ('TEXTAREA' === n.tagName ||
            'INPUT' === n.tagName ||
            ('SPAN' === n.tagName && n.classList.contains('property_value')))
        )
          return
        const i = v(),
          s = y(),
          a = i.getKeybinding(e)
        if (a && '#graph-canvas' !== a.targetSelector)
          return t.preventDefault(), void (await s.execute(a.commandId))
        if (!(t.ctrlKey || t.altKey || t.metaKey) && 'Escape' === t.key) {
          const t = document.querySelectorAll('.comfy-modal')
          for (const e of t) {
            if (
              'none' !== window.getComputedStyle(e).getPropertyValue('display')
            ) {
              e.style.display = 'none'
              break
            }
          }
          for (const e of document.querySelectorAll('dialog')) e.close()
        }
      }, 'keybindListener')
      window.addEventListener('keydown', t)
    }
  }),
  e(J, 'dataURLToBlob'),
  e(function (t) {
    const e = document.createElement('canvas')
    return (
      (e.width = t.width),
      (e.height = t.height),
      e.getContext('2d').drawImage(t, 0, 0),
      J(e.toDataURL('image/png', 1))
    )
  }, 'loadedImageToBlob'),
  e(Q, 'loadImage'),
  e(tt, 'uploadMask'),
  e(et, 'prepare_mask')
class nt extends n {
  static {
    e(this, 'MaskEditorDialogOld')
  }
  static instance = null
  static mousedown_x = null
  static mousedown_y = null
  brush
  maskCtx
  maskCanvas
  brush_size_slider
  brush_opacity_slider
  colorButton
  saveButton
  zoom_ratio
  pan_x
  pan_y
  imgCanvas
  last_display_style
  is_visible
  image
  handler_registered
  brush_slider_input
  cursorX
  cursorY
  mousedown_pan_x
  mousedown_pan_y
  last_pressure
  pointer_type
  brush_pointer_type_select
  static getInstance() {
    return nt.instance || (nt.instance = new nt()), nt.instance
  }
  is_layout_created = !1
  constructor() {
    super(),
      (this.element = i('div.comfy-modal', { parent: document.body }, [
        i('div.comfy-modal-content', [...this.createButtons()])
      ]))
  }
  createButtons() {
    return []
  }
  createButton(t, e) {
    var n = document.createElement('button')
    return (
      (n.style.pointerEvents = 'auto'),
      (n.innerText = t),
      n.addEventListener('click', e),
      n
    )
  }
  createLeftButton(t, e) {
    var n = this.createButton(t, e)
    return (n.style.cssFloat = 'left'), (n.style.marginRight = '4px'), n
  }
  createRightButton(t, e) {
    var n = this.createButton(t, e)
    return (n.style.cssFloat = 'right'), (n.style.marginLeft = '4px'), n
  }
  createLeftSlider(t, e, n) {
    const i = document.createElement('div')
    ;(i.id = 'maskeditor-slider'),
      (i.style.cssFloat = 'left'),
      (i.style.fontFamily = 'sans-serif'),
      (i.style.marginRight = '4px'),
      (i.style.color = 'var(--input-text)'),
      (i.style.backgroundColor = 'var(--comfy-input-bg)'),
      (i.style.borderRadius = '8px'),
      (i.style.borderColor = 'var(--border-color)'),
      (i.style.borderStyle = 'solid'),
      (i.style.fontSize = '15px'),
      (i.style.height = '25px'),
      (i.style.padding = '1px 6px'),
      (i.style.display = 'flex'),
      (i.style.position = 'relative'),
      (i.style.top = '2px'),
      (i.style.pointerEvents = 'auto'),
      (t.brush_slider_input = document.createElement('input')),
      t.brush_slider_input.setAttribute('type', 'range'),
      t.brush_slider_input.setAttribute('min', '1'),
      t.brush_slider_input.setAttribute('max', '100'),
      t.brush_slider_input.setAttribute('value', '10')
    const s = document.createElement('label')
    return (
      (s.textContent = e),
      i.appendChild(s),
      i.appendChild(t.brush_slider_input),
      t.brush_slider_input.addEventListener('change', n),
      i
    )
  }
  createOpacitySlider(t, e, n) {
    const i = document.createElement('div')
    ;(i.id = 'maskeditor-opacity-slider'),
      (i.style.cssFloat = 'left'),
      (i.style.fontFamily = 'sans-serif'),
      (i.style.marginRight = '4px'),
      (i.style.color = 'var(--input-text)'),
      (i.style.backgroundColor = 'var(--comfy-input-bg)'),
      (i.style.borderRadius = '8px'),
      (i.style.borderColor = 'var(--border-color)'),
      (i.style.borderStyle = 'solid'),
      (i.style.fontSize = '15px'),
      (i.style.height = '25px'),
      (i.style.padding = '1px 6px'),
      (i.style.display = 'flex'),
      (i.style.position = 'relative'),
      (i.style.top = '2px'),
      (i.style.pointerEvents = 'auto'),
      (t.opacity_slider_input = document.createElement('input')),
      t.opacity_slider_input.setAttribute('type', 'range'),
      t.opacity_slider_input.setAttribute('min', '0.1'),
      t.opacity_slider_input.setAttribute('max', '1.0'),
      t.opacity_slider_input.setAttribute('step', '0.01'),
      t.opacity_slider_input.setAttribute('value', '0.7')
    const s = document.createElement('label')
    return (
      (s.textContent = e),
      i.appendChild(s),
      i.appendChild(t.opacity_slider_input),
      t.opacity_slider_input.addEventListener('input', n),
      i
    )
  }
  createPointerTypeSelect(t) {
    const e = document.createElement('div')
    ;(e.id = 'maskeditor-pointer-type'),
      (e.style.cssFloat = 'left'),
      (e.style.fontFamily = 'sans-serif'),
      (e.style.marginRight = '4px'),
      (e.style.color = 'var(--input-text)'),
      (e.style.backgroundColor = 'var(--comfy-input-bg)'),
      (e.style.borderRadius = '8px'),
      (e.style.borderColor = 'var(--border-color)'),
      (e.style.borderStyle = 'solid'),
      (e.style.fontSize = '15px'),
      (e.style.height = '25px'),
      (e.style.padding = '1px 6px'),
      (e.style.display = 'flex'),
      (e.style.position = 'relative'),
      (e.style.top = '2px'),
      (e.style.pointerEvents = 'auto')
    const n = document.createElement('label')
    n.textContent = 'Pointer Type:'
    const i = document.createElement('select')
    ;(i.style.borderRadius = '0'),
      (i.style.borderColor = 'transparent'),
      (i.style.borderStyle = 'unset'),
      (i.style.fontSize = '0.9em')
    const s = document.createElement('option')
    ;(s.value = 'arc'), (s.text = 'Circle'), (s.selected = !0)
    const r = document.createElement('option')
    return (
      (r.value = 'rect'),
      (r.text = 'Square'),
      i.appendChild(s),
      i.appendChild(r),
      i.addEventListener('change', (e) => {
        const n = e.target
        ;(t.pointer_type = n.value), this.setBrushBorderRadius(t)
      }),
      e.appendChild(n),
      e.appendChild(i),
      e
    )
  }
  setBrushBorderRadius(t) {
    'rect' === t.pointer_type
      ? ((this.brush.style.borderRadius = '0%'),
        (this.brush.style.MozBorderRadius = '0%'),
        (this.brush.style.WebkitBorderRadius = '0%'))
      : ((this.brush.style.borderRadius = '50%'),
        (this.brush.style.MozBorderRadius = '50%'),
        (this.brush.style.WebkitBorderRadius = '50%'))
  }
  setlayout(t, e) {
    const n = this
    n.pointer_type = 'arc'
    var i = document.createElement('div')
    ;(i.style.position = 'absolute'),
      (i.style.bottom = '0px'),
      (i.style.left = '20px'),
      (i.style.right = '20px'),
      (i.style.height = '50px'),
      (i.style.pointerEvents = 'none')
    var s = document.createElement('div')
    ;(s.id = 'brush'),
      (s.style.backgroundColor = 'transparent'),
      (s.style.outline = '1px dashed black'),
      (s.style.boxShadow = '0 0 0 1px white'),
      (s.style.position = 'absolute'),
      (s.style.zIndex = '8889'),
      (s.style.pointerEvents = 'none'),
      (this.brush = s),
      this.setBrushBorderRadius(n),
      this.element.appendChild(t),
      this.element.appendChild(e),
      this.element.appendChild(i),
      document.body.appendChild(s)
    var r = this.createLeftButton('Clear', () => {
      n.maskCtx.clearRect(0, 0, n.maskCanvas.width, n.maskCanvas.height)
    })
    ;(this.brush_size_slider = this.createLeftSlider(n, 'Thickness', (t) => {
      ;(n.brush_size = t.target.value), n.updateBrushPreview(n)
    })),
      (this.brush_opacity_slider = this.createOpacitySlider(
        n,
        'Opacity',
        (t) => {
          ;(n.brush_opacity = t.target.value),
            'negative' !== n.brush_color_mode &&
              (n.maskCanvas.style.opacity = n.brush_opacity.toString())
        }
      )),
      (this.brush_pointer_type_select = this.createPointerTypeSelect(n)),
      (this.colorButton = this.createLeftButton(
        this.getColorButtonText(),
        () => {
          'black' === n.brush_color_mode
            ? (n.brush_color_mode = 'white')
            : 'white' === n.brush_color_mode
              ? (n.brush_color_mode = 'negative')
              : (n.brush_color_mode = 'black'),
            n.updateWhenBrushColorModeChanged()
        }
      ))
    var a = this.createRightButton('Cancel', () => {
      document.removeEventListener('keydown', nt.handleKeyDown), n.close()
    })
    ;(this.saveButton = this.createRightButton('Save', () => {
      document.removeEventListener('keydown', nt.handleKeyDown), n.save()
    })),
      this.element.appendChild(t),
      this.element.appendChild(e),
      this.element.appendChild(i),
      i.appendChild(r),
      i.appendChild(this.saveButton),
      i.appendChild(a),
      i.appendChild(this.brush_size_slider),
      i.appendChild(this.brush_opacity_slider),
      i.appendChild(this.brush_pointer_type_select),
      i.appendChild(this.colorButton),
      (t.style.position = 'absolute'),
      (e.style.position = 'absolute'),
      (t.style.top = '200'),
      (t.style.left = '0'),
      (e.style.top = t.style.top),
      (e.style.left = t.style.left)
    const o = this.getMaskCanvasStyle()
    ;(e.style.mixBlendMode = o.mixBlendMode),
      (e.style.opacity = o.opacity.toString())
  }
  async show() {
    if (
      ((this.zoom_ratio = 1),
      (this.pan_x = 0),
      (this.pan_y = 0),
      !this.is_layout_created)
    ) {
      const t = document.createElement('canvas'),
        e = document.createElement('canvas')
      ;(t.id = 'imageCanvas'),
        (e.id = 'maskCanvas'),
        this.setlayout(t, e),
        (this.imgCanvas = t),
        (this.maskCanvas = e),
        (this.maskCtx = e.getContext('2d', { willReadFrequently: !0 })),
        this.setEventHandler(e),
        (this.is_layout_created = !0)
      const n = this,
        i = { attributes: !0 }
      new MutationObserver(function (t) {
        t.forEach(function (t) {
          'attributes' === t.type &&
            'style' === t.attributeName &&
            (n.last_display_style &&
              'none' != n.last_display_style &&
              'none' == n.element.style.display &&
              ((n.brush.style.display = 'none'), s.onClipspaceEditorClosed()),
            (n.last_display_style = n.element.style.display))
        })
      }).observe(this.element, i)
    }
    document.addEventListener('keydown', nt.handleKeyDown),
      s.clipspace_return_node
        ? (this.saveButton.innerText = 'Save to node')
        : (this.saveButton.innerText = 'Save'),
      (this.saveButton.disabled = !1),
      (this.element.style.display = 'block'),
      (this.element.style.width = '85%'),
      (this.element.style.margin = '0 7.5%'),
      (this.element.style.height = '100vh'),
      (this.element.style.top = '50%'),
      (this.element.style.left = '42%'),
      (this.element.style.zIndex = '8888'),
      await this.setImages(this.imgCanvas),
      (this.is_visible = !0)
  }
  isOpened() {
    return 'block' == this.element.style.display
  }
  invalidateCanvas(t, e) {
    ;(this.imgCanvas.width = t.width),
      (this.imgCanvas.height = t.height),
      (this.maskCanvas.width = t.width),
      (this.maskCanvas.height = t.height)
    let n = this.imgCanvas.getContext('2d', { willReadFrequently: !0 }),
      i = this.maskCanvas.getContext('2d', { willReadFrequently: !0 })
    n.drawImage(t, 0, 0, t.width, t.height),
      et(e, this.maskCanvas, i, this.getMaskColor())
  }
  async setImages(t) {
    let e = this
    const n = t.getContext('2d', { willReadFrequently: !0 }),
      i = this.maskCtx,
      r = this.maskCanvas
    n.clearRect(0, 0, this.imgCanvas.width, this.imgCanvas.height),
      i.clearRect(0, 0, this.maskCanvas.width, this.maskCanvas.height)
    s.clipspace.images
    const a = new URL(s.clipspace.imgs[s.clipspace.selectedIndex].src)
    a.searchParams.delete('channel'),
      a.searchParams.delete('preview'),
      a.searchParams.set('channel', 'a')
    let o = await Q(a)
    const l = new URL(s.clipspace.imgs[s.clipspace.selectedIndex].src)
    l.searchParams.delete('channel'),
      l.searchParams.set('channel', 'rgb'),
      (this.image = new Image()),
      (this.image.onload = function () {
        ;(r.width = e.image.width),
          (r.height = e.image.height),
          e.invalidateCanvas(e.image, o),
          e.initializeCanvasPanZoom()
      }),
      (this.image.src = l.toString())
  }
  initializeCanvasPanZoom() {
    let t = this.image.width,
      e = this.image.height,
      n = this.element.clientWidth,
      i = this.element.clientHeight
    this.image.width > n &&
      ((t = n), (e = (t / this.image.width) * this.image.height)),
      e > i && ((e = i), (t = (e / this.image.height) * this.image.width)),
      (this.zoom_ratio = t / this.image.width)
    const s = (n - t) / 2,
      r = (i - e) / 2
    ;(this.pan_x = s), (this.pan_y = r), this.invalidatePanZoom()
  }
  invalidatePanZoom() {
    let t = this.image.width * this.zoom_ratio,
      e = this.image.height * this.zoom_ratio
    this.pan_x + t < 10 && (this.pan_x = 10 - t),
      this.pan_y + e < 10 && (this.pan_y = 10 - e)
    let n = `${t}px`,
      i = `${e}px`,
      s = `${this.pan_x}px`,
      r = `${this.pan_y}px`
    ;(this.maskCanvas.style.width = n),
      (this.maskCanvas.style.height = i),
      (this.maskCanvas.style.left = s),
      (this.maskCanvas.style.top = r),
      (this.imgCanvas.style.width = n),
      (this.imgCanvas.style.height = i),
      (this.imgCanvas.style.left = s),
      (this.imgCanvas.style.top = r)
  }
  setEventHandler(t) {
    const e = this
    this.handler_registered ||
      (t.addEventListener('contextmenu', (t) => {
        t.preventDefault()
      }),
      this.element.addEventListener('wheel', (t) =>
        this.handleWheelEvent(e, t)
      ),
      this.element.addEventListener('pointermove', (t) =>
        this.pointMoveEvent(e, t)
      ),
      this.element.addEventListener('touchmove', (t) =>
        this.pointMoveEvent(e, t)
      ),
      this.element.addEventListener('dragstart', (t) => {
        t.ctrlKey && t.preventDefault()
      }),
      t.addEventListener('pointerdown', (t) => this.handlePointerDown(e, t)),
      t.addEventListener('pointermove', (t) => this.draw_move(e, t)),
      t.addEventListener('touchmove', (t) => this.draw_move(e, t)),
      t.addEventListener('pointerover', (t) => {
        this.brush.style.display = 'block'
      }),
      t.addEventListener('pointerleave', (t) => {
        this.brush.style.display = 'none'
      }),
      document.addEventListener('pointerup', nt.handlePointerUp),
      (this.handler_registered = !0))
  }
  getMaskCanvasStyle() {
    return 'negative' === this.brush_color_mode
      ? { mixBlendMode: 'difference', opacity: '1' }
      : { mixBlendMode: 'initial', opacity: this.brush_opacity }
  }
  getMaskColor() {
    return 'black' === this.brush_color_mode
      ? { r: 0, g: 0, b: 0 }
      : 'white' === this.brush_color_mode ||
          'negative' === this.brush_color_mode
        ? { r: 255, g: 255, b: 255 }
        : { r: 0, g: 0, b: 0 }
  }
  getMaskFillStyle() {
    const t = this.getMaskColor()
    return 'rgb(' + t.r + ',' + t.g + ',' + t.b + ')'
  }
  getColorButtonText() {
    let t = 'unknown'
    return (
      'black' === this.brush_color_mode
        ? (t = 'black')
        : 'white' === this.brush_color_mode
          ? (t = 'white')
          : 'negative' === this.brush_color_mode && (t = 'negative'),
      'Color: ' + t
    )
  }
  updateWhenBrushColorModeChanged() {
    this.colorButton.innerText = this.getColorButtonText()
    const t = this.getMaskCanvasStyle()
    ;(this.maskCanvas.style.mixBlendMode = t.mixBlendMode),
      (this.maskCanvas.style.opacity = t.opacity.toString())
    const e = this.getMaskColor(),
      n = this.maskCtx.getImageData(
        0,
        0,
        this.maskCanvas.width,
        this.maskCanvas.height
      )
    for (let i = 0; i < n.data.length; i += 4)
      (n.data[i] = e.r), (n.data[i + 1] = e.g), (n.data[i + 2] = e.b)
    this.maskCtx.putImageData(n, 0, 0)
  }
  brush_opacity = 0.7
  brush_size = 10
  brush_color_mode = 'black'
  drawing_mode = !1
  lastx = -1
  lasty = -1
  lasttime = 0
  static handleKeyDown(t) {
    const e = nt.instance
    ']' === t.key
      ? ((e.brush_size = Math.min(e.brush_size + 2, 100)),
        (e.brush_slider_input.value = e.brush_size))
      : '[' === t.key
        ? ((e.brush_size = Math.max(e.brush_size - 2, 1)),
          (e.brush_slider_input.value = e.brush_size))
        : 'Enter' === t.key && e.save(),
      e.updateBrushPreview(e)
  }
  static handlePointerUp(t) {
    t.preventDefault(),
      (this.mousedown_x = null),
      (this.mousedown_y = null),
      (nt.instance.drawing_mode = !1)
  }
  updateBrushPreview(t) {
    const e = t.brush
    var n = t.cursorX,
      i = t.cursorY
    ;(e.style.width = 2 * t.brush_size * this.zoom_ratio + 'px'),
      (e.style.height = 2 * t.brush_size * this.zoom_ratio + 'px'),
      (e.style.left = n - t.brush_size * this.zoom_ratio + 'px'),
      (e.style.top = i - t.brush_size * this.zoom_ratio + 'px')
  }
  handleWheelEvent(t, e) {
    e.preventDefault(),
      e.ctrlKey
        ? (e.deltaY < 0
            ? (this.zoom_ratio = Math.min(10, this.zoom_ratio + 0.2))
            : (this.zoom_ratio = Math.max(0.2, this.zoom_ratio - 0.2)),
          this.invalidatePanZoom())
        : (e.deltaY < 0
            ? (this.brush_size = Math.min(this.brush_size + 2, 100))
            : (this.brush_size = Math.max(this.brush_size - 2, 1)),
          (this.brush_slider_input.value = this.brush_size.toString()),
          this.updateBrushPreview(this))
  }
  pointMoveEvent(t, e) {
    ;(this.cursorX = e.pageX),
      (this.cursorY = e.pageY),
      t.updateBrushPreview(t),
      e.ctrlKey && (e.preventDefault(), t.pan_move(t, e))
    let n = (window.TouchEvent && e instanceof TouchEvent) || 1 == e.buttons
    if (e.shiftKey && n) {
      t.drawing_mode = !1
      const n = e.clientY
      let i = 0.005 * (t.zoom_lasty - n)
      return (
        (t.zoom_ratio = Math.max(Math.min(10, t.last_zoom_ratio - i), 0.2)),
        void this.invalidatePanZoom()
      )
    }
  }
  pan_move(t, e) {
    if (1 == e.buttons && nt.mousedown_x) {
      let n = nt.mousedown_x - e.clientX,
        i = nt.mousedown_y - e.clientY
      ;(t.pan_x = this.mousedown_pan_x - n),
        (t.pan_y = this.mousedown_pan_y - i),
        t.invalidatePanZoom()
    }
  }
  draw_move(t, e) {
    if (e.ctrlKey || e.shiftKey) return
    e.preventDefault(),
      (this.cursorX = e.pageX),
      (this.cursorY = e.pageY),
      t.updateBrushPreview(t)
    let n = (window.TouchEvent && e instanceof TouchEvent) || 1 == e.buttons,
      i = [2, 5, 32].includes(e.buttons)
    if (!e.altKey && n) {
      var s = performance.now() - t.lasttime
      const n = t.maskCanvas.getBoundingClientRect()
      var r = e.offsetX,
        a = e.offsetY
      null == e.offsetX && (r = e.targetTouches[0].clientX - n.left),
        null == e.offsetY && (a = e.targetTouches[0].clientY - n.top),
        (r /= t.zoom_ratio),
        (a /= t.zoom_ratio)
      var o = this.brush_size
      e instanceof PointerEvent && 'pen' == e.pointerType
        ? ((o *= e.pressure), (this.last_pressure = e.pressure))
        : window.TouchEvent && e instanceof TouchEvent && s < 20
          ? (o *= this.last_pressure)
          : (o = this.brush_size),
        s > 20 && !this.drawing_mode
          ? requestAnimationFrame(() => {
              t.init_shape(t, 'source-over'),
                t.draw_shape(t, r, a, o),
                (t.lastx = r),
                (t.lasty = a)
            })
          : requestAnimationFrame(() => {
              t.init_shape(t, 'source-over')
              for (
                var e = r - t.lastx,
                  n = a - t.lasty,
                  i = Math.sqrt(e * e + n * n),
                  s = e / i,
                  l = n / i,
                  c = 0;
                c < i;
                c += 5
              ) {
                var h = t.lastx + s * c,
                  u = t.lasty + l * c
                t.draw_shape(t, h, u, o)
              }
              ;(t.lastx = r), (t.lasty = a)
            }),
        (t.lasttime = performance.now())
    } else if ((e.altKey && n) || i) {
      const n = t.maskCanvas.getBoundingClientRect(),
        i = (e.offsetX || e.targetTouches[0].clientX - n.left) / t.zoom_ratio,
        r = (e.offsetY || e.targetTouches[0].clientY - n.top) / t.zoom_ratio
      o = this.brush_size
      e instanceof PointerEvent && 'pen' == e.pointerType
        ? ((o *= e.pressure), (this.last_pressure = e.pressure))
        : window.TouchEvent && e instanceof TouchEvent && s < 20
          ? (o *= this.last_pressure)
          : (o = this.brush_size),
        s > 20 && !this.drawing_mode
          ? requestAnimationFrame(() => {
              t.init_shape(t, 'destination-out'),
                t.draw_shape(t, i, r, o),
                (t.lastx = i),
                (t.lasty = r)
            })
          : requestAnimationFrame(() => {
              t.init_shape(t, 'destination-out')
              for (
                var e = i - t.lastx,
                  n = r - t.lasty,
                  s = Math.sqrt(e * e + n * n),
                  a = e / s,
                  l = n / s,
                  c = 0;
                c < s;
                c += 5
              ) {
                var h = t.lastx + a * c,
                  u = t.lasty + l * c
                t.draw_shape(t, h, u, o)
              }
              ;(t.lastx = i), (t.lasty = r)
            }),
        (t.lasttime = performance.now())
    }
  }
  handlePointerDown(t, e) {
    if (e.ctrlKey)
      1 == e.buttons &&
        ((nt.mousedown_x = e.clientX),
        (nt.mousedown_y = e.clientY),
        (this.mousedown_pan_x = this.pan_x),
        (this.mousedown_pan_y = this.pan_y))
    else {
      var n = this.brush_size
      if (
        (e instanceof PointerEvent &&
          'pen' == e.pointerType &&
          ((n *= e.pressure), (this.last_pressure = e.pressure)),
        [0, 2, 5].includes(e.button))
      ) {
        if (((t.drawing_mode = !0), e.preventDefault(), e.shiftKey))
          return (
            (t.zoom_lasty = e.clientY), void (t.last_zoom_ratio = t.zoom_ratio)
          )
        const i = t.maskCanvas.getBoundingClientRect(),
          s = (e.offsetX || e.targetTouches[0].clientX - i.left) / t.zoom_ratio,
          r = (e.offsetY || e.targetTouches[0].clientY - i.top) / t.zoom_ratio
        e.altKey || 0 != e.button
          ? t.init_shape(t, 'destination-out')
          : t.init_shape(t, 'source-over'),
          t.draw_shape(t, s, r, n),
          (t.lastx = s),
          (t.lasty = r),
          (t.lasttime = performance.now())
      }
    }
  }
  init_shape(t, e) {
    t.maskCtx.beginPath(),
      'source-over' == e
        ? ((t.maskCtx.fillStyle = this.getMaskFillStyle()),
          (t.maskCtx.globalCompositeOperation = 'source-over'))
        : 'destination-out' == e &&
          (t.maskCtx.globalCompositeOperation = 'destination-out')
  }
  draw_shape(t, e, n, i) {
    'rect' === t.pointer_type
      ? t.maskCtx.rect(e - i, n - i, 2 * i, 2 * i)
      : t.maskCtx.arc(e, n, i, 0, 2 * Math.PI, !1),
      t.maskCtx.fill()
  }
  async save() {
    const t = document.createElement('canvas'),
      e = t.getContext('2d', { willReadFrequently: !0 })
    ;(t.width = this.image.width),
      (t.height = this.image.height),
      e.clearRect(0, 0, t.width, t.height),
      e.drawImage(
        this.maskCanvas,
        0,
        0,
        this.maskCanvas.width,
        this.maskCanvas.height,
        0,
        0,
        t.width,
        t.height
      )
    const n = e.getImageData(0, 0, t.width, t.height)
    for (let s = 0; s < n.data.length; s += 4)
      255 == n.data[s + 3] ? (n.data[s + 3] = 0) : (n.data[s + 3] = 255),
        (n.data[s] = 0),
        (n.data[s + 1] = 0),
        (n.data[s + 2] = 0)
    ;(e.globalCompositeOperation = 'source-over'), e.putImageData(n, 0, 0)
    const i = new FormData(),
      r = 'clipspace-mask-' + performance.now() + '.png',
      a = { filename: r, subfolder: 'clipspace', type: 'input' }
    if (
      (s.clipspace.images && (s.clipspace.images[0] = a), s.clipspace.widgets)
    ) {
      const t = s.clipspace.widgets.findIndex((t) => 'image' === t.name)
      t >= 0 && (s.clipspace.widgets[t].value = a)
    }
    const o = J(t.toDataURL())
    let l = new URL(this.image.src)
    const c = { filename: l.searchParams.get('filename') }
    let h = l.searchParams.get('subfolder')
    h && (c.subfolder = h)
    let u = l.searchParams.get('type')
    u && (c.type = u),
      i.append('image', o, r),
      i.append('original_ref', JSON.stringify(c)),
      i.append('type', 'input'),
      i.append('subfolder', 'clipspace'),
      (this.saveButton.innerText = 'Saving...'),
      (this.saveButton.disabled = !0),
      await tt(a, i),
      s.onClipspaceEditorSave(),
      this.close()
  }
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.maskEditorOld = window.comfyAPI.maskEditorOld || {}),
  (window.comfyAPI.maskEditorOld.MaskEditorDialogOld = nt)
var it = document.createElement('style')
;(it.type = 'text/css'),
  (it.innerText =
    '\n  #maskEditorContainer {\n    display: fixed;\n  }\n  #maskEditor_brush {\n    position: absolute;\n    backgroundColor: transparent;\n    z-index: 8889;\n    pointer-events: none;\n    border-radius: 50%;\n    overflow: visible;\n    outline: 1px dashed black;\n    box-shadow: 0 0 0 1px white;\n  }\n  #maskEditor_brushPreviewGradient {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    display: none;\n  }\n  #maskEditor {\n    display: block;\n    width: 100%;\n    height: 100vh;\n    left: 0;\n    z-index: 8888;\n    position: fixed;\n    background: rgba(50,50,50,0.75);\n    backdrop-filter: blur(10px);\n    overflow: hidden;\n    user-select: none;\n  }\n  #maskEditor_sidePanelContainer {\n    height: 100%;\n    width: 220px;\n    z-index: 8888;\n    display: flex;\n    flex-direction: column;\n  }\n  #maskEditor_sidePanel {\n    background: var(--comfy-menu-bg);\n    height: 100%;\n    display: flex;\n    align-items: center;\n    overflow-y: hidden;\n    width: 220px;\n  }\n  #maskEditor_sidePanelShortcuts {\n    display: flex;\n    flex-direction: row;\n    width: 200px;\n    margin-top: 10px;\n    gap: 10px;\n    justify-content: center;\n  }\n  .maskEditor_sidePanelIconButton {\n    width: 40px;\n    height: 40px;\n    pointer-events: auto;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    transition: background-color 0.1s;\n  }\n  .maskEditor_sidePanelIconButton:hover {\n    background-color: rgba(0, 0, 0, 0.2);\n  }\n  #maskEditor_sidePanelBrushSettings {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    width: 200px;\n    padding: 10px;\n  }\n  .maskEditor_sidePanelTitle {\n    text-align: center;\n    font-size: 15px;\n    font-family: sans-serif;\n    color: var(--descrip-text);\n    margin-top: 10px;\n  }\n  #maskEditor_sidePanelBrushShapeContainer {\n    display: flex;\n    width: 180px;\n    height: 50px;\n    border: 1px solid var(--border-color);\n    pointer-events: auto;\n    background: rgba(0, 0, 0, 0.2);\n  }\n  #maskEditor_sidePanelBrushShapeCircle {\n    width: 35px;\n    height: 35px;\n    border-radius: 50%;\n    border: 1px solid var(--border-color);\n    pointer-events: auto;\n    transition: background 0.1s;\n    margin-left: 7.5px;\n  }\n  .maskEditor_sidePanelBrushRange {\n    width: 180px;\n    -webkit-appearance: none;\n    appearance: none;\n    background: transparent;\n    cursor: pointer;\n  }\n  .maskEditor_sidePanelBrushRange::-webkit-slider-thumb {\n    height: 20px;\n    width: 20px;\n    border-radius: 50%;\n    cursor: grab;\n    margin-top: -8px;\n    background: var(--p-surface-700);\n    border: 1px solid var(--border-color);\n  }\n  .maskEditor_sidePanelBrushRange::-moz-range-thumb {\n    height: 20px;\n    width: 20px;\n    border-radius: 50%;\n    cursor: grab;\n    background: var(--p-surface-800);\n    border: 1px solid var(--border-color);\n  }\n  .maskEditor_sidePanelBrushRange::-webkit-slider-runnable-track {\n    background: var(--p-surface-700);\n    height: 3px;\n  }\n  .maskEditor_sidePanelBrushRange::-moz-range-track {\n    background: var(--p-surface-700);\n    height: 3px;\n  }\n\n  #maskEditor_sidePanelBrushShapeSquare {\n    width: 35px;\n    height: 35px;\n    margin: 5px;\n    border: 1px solid var(--border-color);\n    pointer-events: auto;\n    transition: background 0.1s;\n  }\n\n  .maskEditor_brushShape_dark {\n    background: transparent;\n  }\n\n  .maskEditor_brushShape_dark:hover {\n    background: var(--p-surface-900);\n  }\n\n  .maskEditor_brushShape_light {\n    background: transparent;\n  }\n\n  .maskEditor_brushShape_light:hover {\n    background: var(--comfy-menu-bg);\n  }\n\n  #maskEditor_sidePanelImageLayerSettings {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    width: 200px;\n    align-items: center;\n  }\n  .maskEditor_sidePanelLayer {\n    display: flex;\n    width: 200px;\n    height: 50px;\n  }\n  .maskEditor_sidePanelLayerVisibilityContainer {\n    width: 50px;\n    height: 50px;\n    border-radius: 8px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  .maskEditor_sidePanelVisibilityToggle {\n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    pointer-events: auto;\n  }\n  .maskEditor_sidePanelLayerIconContainer {\n    width: 60px;\n    height: 50px;\n    border-radius: 8px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    fill: var(--input-text);\n  }\n  .maskEditor_sidePanelLayerIconContainer svg {\n    width: 30px;\n    height: 30px;\n  }\n  #maskEditor_sidePanelMaskLayerBlendingContainer {\n    width: 80px;\n    height: 50px;\n    border-radius: 8px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  #maskEditor_sidePanelMaskLayerBlendingSelect {\n    width: 80px;\n    height: 30px;\n    border: 1px solid var(--border-color);\n    background-color: rgba(0, 0, 0, 0.2);\n    color: var(--input-text);\n    font-family: sans-serif;\n    font-size: 15px;\n    pointer-events: auto;\n    transition: background-color border 0.1s;\n  }\n  #maskEditor_sidePanelClearCanvasButton:hover {\n    background-color: var(--p-overlaybadge-outline-color);\n    border: none;\n  }\n  #maskEditor_sidePanelClearCanvasButton {\n    width: 180px;\n    height: 30px;\n    border: none;\n    background: rgba(0, 0, 0, 0.2);\n    border: 1px solid var(--border-color);\n    color: var(--input-text);\n    font-family: sans-serif;\n    font-size: 15px;\n    pointer-events: auto;\n    transition: background-color 0.1s;\n  }\n  #maskEditor_sidePanelClearCanvasButton:hover {\n    background-color: var(--p-overlaybadge-outline-color);\n  }\n  #maskEditor_sidePanelHorizontalButtonContainer {\n    display: flex;\n    gap: 10px;\n    height: 40px;\n  }\n  .maskEditor_sidePanelBigButton {\n    width: 85px;\n    height: 30px;\n    border: none;\n    background: rgba(0, 0, 0, 0.2);\n    border: 1px solid var(--border-color);\n    color: var(--input-text);\n    font-family: sans-serif;\n    font-size: 15px;\n    pointer-events: auto;\n    transition: background-color border 0.1s;\n  }\n  .maskEditor_sidePanelBigButton:hover {\n    background-color: var(--p-overlaybadge-outline-color);\n    border: none;\n  }\n  #maskEditor_toolPanel {\n    height: 100%;\n    width: var(--sidebar-width);\n    z-index: 8888;\n    background: var(--comfy-menu-bg);\n    display: flex;\n    flex-direction: column;\n  }\n  .maskEditor_toolPanelContainer {\n    width: var(--sidebar-width);\n    height: var(--sidebar-width);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    position: relative;\n    transition: background-color 0.2s;\n  }\n  .maskEditor_toolPanelContainerSelected svg {\n    fill: var(--p-button-text-primary-color) !important;\n  }\n  .maskEditor_toolPanelContainerSelected .maskEditor_toolPanelIndicator {\n    display: block;\n  }\n  .maskEditor_toolPanelContainer svg {\n    width: 75%;\n    aspect-ratio: 1/1;\n    fill: var(--p-button-text-secondary-color);\n  }\n\n  .maskEditor_toolPanelContainerDark:hover {\n    background-color: var(--p-surface-800);\n  }\n\n  .maskEditor_toolPanelContainerLight:hover {\n    background-color: var(--p-surface-300);\n  }\n\n  .maskEditor_toolPanelIndicator {\n    display: none;\n    height: 100%;\n    width: 4px;\n    position: absolute;\n    left: 0;\n    background: var(--p-button-text-primary-color);\n  }\n  #maskEditor_sidePanelPaintBucketSettings {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    width: 200px;\n    padding: 10px;\n  }\n  #canvasBackground {\n    background: white;\n    width: 100%;\n    height: 100%;\n  }\n  #maskEditor_sidePanelButtonsContainer {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    margin-top: 10px;\n  }\n  .maskEditor_sidePanelSeparator {\n    width: 200px;\n    height: 2px;\n    background: var(--border-color);\n    margin-top: 5px;\n    margin-bottom: 5px;\n  }\n  #maskEditor_pointerZone {\n    width: calc(100% - var(--sidebar-width) - 220px);\n    height: 100%;\n  }\n  #maskEditor_uiContainer {\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    z-index: 8888;\n    display: flex;\n    flex-direction: column;\n  }\n  #maskEditorCanvasContainer {\n    position: absolute;\n    width: 1000px;\n    height: 667px;\n    left: 359px;\n    top: 280px;\n  }\n  #imageCanvas {\n    width: 100%;\n    height: 100%;\n  }\n  #maskCanvas {\n    width: 100%;\n    height: 100%;\n  }\n  #maskEditor_uiHorizontalContainer {\n    width: 100%;\n    height: 100%;\n    display: flex;\n  }\n  #maskEditor_topBar {\n    display: flex;\n    height: 44px;\n    align-items: center;\n    background: var(--comfy-menu-bg);\n  }\n  #maskEditor_topBarTitle {\n    margin: 0;\n    margin-left: 0.5rem;\n    margin-right: 0.5rem;\n    font-size: 1.2em;\n  }\n  #maskEditor_topBarButtonContainer {\n    display: flex;\n    gap: 10px;\n    margin-right: 0.5rem;\n    position: absolute;\n    right: 0;\n    width: 200px;\n  }\n  #maskEditor_topBarShortcutsContainer {\n    display: flex;\n    gap: 10px;\n    margin-left: 5px;\n  }\n\n  .maskEditor_topPanelIconButton_dark {\n    width: 50px;\n    height: 30px;\n    pointer-events: auto;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    transition: background-color 0.1s;\n    background: var(--p-surface-800);\n    border: 1px solid var(--p-form-field-border-color);\n    border-radius: 10px;\n  }\n\n  .maskEditor_topPanelIconButton_dark:hover {\n      background-color: var(--p-surface-900);\n  }\n\n  .maskEditor_topPanelIconButton_dark svg {\n    width: 25px;\n    height: 25px;\n    pointer-events: none;\n    fill: var(--input-text);\n  }\n\n  .maskEditor_topPanelIconButton_light {\n    width: 50px;\n    height: 30px;\n    pointer-events: auto;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    transition: background-color 0.1s;\n    background: var(--comfy-menu-bg);\n    border: 1px solid var(--p-form-field-border-color);\n    border-radius: 10px;\n  }\n\n  .maskEditor_topPanelIconButton_light:hover {\n      background-color: var(--p-surface-300);\n  }\n\n  .maskEditor_topPanelIconButton_light svg {\n    width: 25px;\n    height: 25px;\n    pointer-events: none;\n    fill: var(--input-text);\n  }\n\n  .maskEditor_topPanelButton_dark {\n    height: 30px;\n    background: var(--p-surface-800);\n    border: 1px solid var(--p-form-field-border-color);\n    border-radius: 10px;\n    color: var(--input-text);\n    font-family: sans-serif;\n    pointer-events: auto;\n    transition: 0.1s;\n    width: 60px;\n  }\n\n  .maskEditor_topPanelButton_dark:hover {\n    background-color: var(--p-surface-900);\n  }\n\n  .maskEditor_topPanelButton_light {\n    height: 30px;\n    background: var(--comfy-menu-bg);\n    border: 1px solid var(--p-form-field-border-color);\n    border-radius: 10px;\n    color: var(--input-text);\n    font-family: sans-serif;\n    pointer-events: auto;\n    transition: 0.1s;\n    width: 60px;\n  }\n\n  .maskEditor_topPanelButton_light:hover {\n    background-color: var(--p-surface-300);\n  }\n\n\n  #maskEditor_sidePanelColorSelectSettings {\n    flex-direction: column;\n  }\n  \n  .maskEditor_sidePanel_paintBucket_Container {\n    width: 180px;\n    display: flex;\n    flex-direction: column;\n    position: relative;\n  }\n\n  .maskEditor_sidePanel_colorSelect_Container {\n    display: flex;\n    width: 180px;\n    align-items: center;\n    gap: 5px;\n    height: 30px;\n  }\n  \n  #maskEditor_sidePanelVisibilityToggle {\n    position: absolute;\n    right: 0;\n  }\n\n  #maskEditor_sidePanelColorSelectMethodSelect {\n    position: absolute;\n    right: 0;\n    height: 30px;\n    border-radius: 0;\n    border: 1px solid var(--border-color);\n    background: rgba(0,0,0,0.2);\n  }\n\n  #maskEditor_sidePanelVisibilityToggle {\n    position: absolute;\n    right: 0;\n  }\n\n  .maskEditor_sidePanel_colorSelect_tolerance_container {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    margin-bottom: 10px;\n  }\n\n  .maskEditor_sidePanelContainerColumn {\n    display: flex;\n    flex-direction: column;\n    gap: 12px;\n  }\n\n  .maskEditor_sidePanelContainerRow {\n    display: flex;\n    flex-direction: row;\n    gap: 10px;\n    align-items: center;\n    min-height: 24px;\n    position: relative;\n  }\n\n  .maskEditor_accent_bg_dark {\n    background: var(--p-surface-800);\n  }\n\n  .maskEditor_accent_bg_very_dark {\n    background: var(--p-surface-900);\n  }\n\n  .maskEditor_accent_bg_light {\n    background: var(--p-surface-300);\n  }\n\n  .maskEditor_accent_bg_very_light {\n    background: var(--comfy-menu-bg);\n  }\n\n  #maskEditor_paintBucketSettings {\n    display: none;\n  }\n\n  #maskEditor_colorSelectSettings {\n    display: none;\n  }\n\n  .maskEditor_sidePanelToggleContainer {\n    cursor: pointer;\n    display: inline-block;\n    position: absolute;\n    right: 0;\n  }\n\n  .maskEditor_toggle_bg_dark {\n    background: var(--p-surface-700);\n  }\n\n  .maskEditor_toggle_bg_light {\n    background: var(--p-surface-300);\n  }\n\n  .maskEditor_sidePanelToggleSwitch {\n    display: inline-block;\n    border-radius: 16px;\n    width: 40px;\n    height: 24px;\n    position: relative;\n    vertical-align: middle;\n    transition: background 0.25s;\n  }\n  .maskEditor_sidePanelToggleSwitch:before, .maskEditor_sidePanelToggleSwitch:after {\n    content: "";\n  }\n  .maskEditor_sidePanelToggleSwitch:before {\n    display: block;\n    background: linear-gradient(to bottom, #fff 0%, #eee 100%);\n    border-radius: 50%;\n    width: 16px;\n    height: 16px;\n    position: absolute;\n    top: 4px;\n    left: 4px;\n    transition: ease 0.2s;\n  }\n  .maskEditor_sidePanelToggleContainer:hover .maskEditor_sidePanelToggleSwitch:before {\n    background: linear-gradient(to bottom, #fff 0%, #fff 100%);\n  }\n  .maskEditor_sidePanelToggleCheckbox:checked + .maskEditor_sidePanelToggleSwitch {\n    background: var(--p-button-text-primary-color);\n  }\n  .maskEditor_sidePanelToggleCheckbox:checked + .maskEditor_toggle_bg_dark:before {\n    background: var(--p-surface-900);\n  }\n  .maskEditor_sidePanelToggleCheckbox:checked + .maskEditor_toggle_bg_light:before {\n    background: var(--comfy-menu-bg);\n  }\n  .maskEditor_sidePanelToggleCheckbox:checked + .maskEditor_sidePanelToggleSwitch:before {\n    left: 20px;\n  }\n\n  .maskEditor_sidePanelToggleCheckbox {\n    position: absolute;\n    visibility: hidden;\n  }\n\n  .maskEditor_sidePanelDropdown_dark {\n    border: 1px solid var(--p-form-field-border-color);\n    background: var(--p-surface-900);\n    height: 24px;\n    padding-left: 5px;\n    padding-right: 5px;\n    border-radius: 6px;\n    transition: background 0.1s;\n  }\n\n  .maskEditor_sidePanelDropdown_dark option {\n    background: var(--p-surface-900);\n  }\n\n  .maskEditor_sidePanelDropdown_dark:focus {\n    outline: 1px solid var(--p-button-text-primary-color);\n  }\n\n  .maskEditor_sidePanelDropdown_dark option:hover {\n    background: white;\n  }\n  .maskEditor_sidePanelDropdown_dark option:active {\n    background: var(--p-highlight-background);\n  }\n\n  .maskEditor_sidePanelDropdown_light {\n    border: 1px solid var(--p-form-field-border-color);\n    background: var(--comfy-menu-bg);\n    height: 24px;\n    padding-left: 5px;\n    padding-right: 5px;\n    border-radius: 6px;\n    transition: background 0.1s;\n  }\n\n  .maskEditor_sidePanelDropdown_light option {\n    background: var(--comfy-menu-bg);\n  }\n\n  .maskEditor_sidePanelDropdown_light:focus {\n    outline: 1px solid var(--p-surface-300);\n  }\n\n  .maskEditor_sidePanelDropdown_light option:hover {\n    background: white;\n  }\n  .maskEditor_sidePanelDropdown_light option:active {\n    background: var(--p-surface-300);\n  }\n\n  .maskEditor_layerRow {\n    height: 50px;\n    width: 200px;\n    border-radius: 10px;\n  }\n\n  .maskEditor_sidePanelLayerPreviewContainer {\n    width: 40px;\n    height: 30px;\n  }\n\n  .maskEditor_sidePanelLayerPreviewContainer > svg{\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n    fill: var(--p-surface-100);\n  }\n\n  #maskEditor_sidePanelImageLayerImage {\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n  }\n\n  .maskEditor_sidePanelSubTitle {\n    text-align: left;\n    font-size: 12px;\n    font-family: sans-serif;\n    color: var(--descrip-text);\n  }\n\n  .maskEditor_containerDropdown {\n    position: absolute;\n    right: 0;\n  }\n\n  .maskEditor_sidePanelLayerCheckbox {\n    margin-left: 15px;\n  }\n\n  .maskEditor_toolPanelZoomIndicator {\n    width: var(--sidebar-width);\n    height: var(--sidebar-width);\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    gap: 5px;\n    color: var(--p-button-text-secondary-color);\n    position: absolute;\n    bottom: 0;\n    transition: background-color 0.2s;\n  }\n\n  #maskEditor_toolPanelDimensionsText {\n    font-size: 12px;\n  }\n\n  #maskEditor_topBarSaveButton {\n    background: var(--p-primary-color) !important;\n    color: var(--p-button-primary-color) !important;\n  }\n\n  #maskEditor_topBarSaveButton:hover {\n    background: var(--p-primary-hover-color) !important;\n  }\n\n'),
  document.head.appendChild(it)
var st = ((t) => ((t.Simple = 'simple'), (t.HSL = 'hsl'), (t.LAB = 'lab'), t))(
  st || {}
)
class rt extends n {
  static {
    e(this, 'MaskEditorDialog')
  }
  static instance = null
  uiManager
  toolManager
  panAndZoomManager
  brushTool
  paintBucketTool
  colorSelectTool
  canvasHistory
  messageBroker
  keyboardManager
  rootElement
  imageURL
  isLayoutCreated = !1
  isOpen = !1
  last_display_style = null
  constructor() {
    super(),
      (this.rootElement = i(
        'div.maskEditor_hidden',
        { parent: document.body },
        []
      )),
      (this.element = this.rootElement)
  }
  static getInstance() {
    if (!s.clipspace || !s.clipspace.imgs)
      throw new Error('No clipspace images found')
    const t = s.clipspace.imgs[s.clipspace.selectedIndex].src
    return (
      (rt.instance && t === rt.instance.imageURL) || (rt.instance = new rt()),
      rt.instance
    )
  }
  async show() {
    if ((this.cleanup(), !this.isLayoutCreated)) {
      ;(this.messageBroker = new pt()),
        (this.canvasHistory = new at(this, 20)),
        (this.paintBucketTool = new ot(this)),
        (this.brushTool = new ct(this)),
        (this.panAndZoomManager = new dt(this)),
        (this.toolManager = new ut(this)),
        (this.keyboardManager = new mt(this)),
        (this.uiManager = new ht(this.rootElement, this)),
        (this.colorSelectTool = new lt(this))
      const t = this,
        e = { attributes: !0 }
      new MutationObserver(function (e) {
        e.forEach(function (e) {
          'attributes' === e.type &&
            'style' === e.attributeName &&
            (t.last_display_style &&
              'none' != t.last_display_style &&
              'none' == t.element.style.display &&
              s.onClipspaceEditorClosed(),
            (t.last_display_style = t.element.style.display))
        })
      }).observe(this.rootElement, e),
        (this.isLayoutCreated = !0),
        await this.uiManager.setlayout()
    }
    ;(this.rootElement.id = 'maskEditor'),
      (this.rootElement.style.display = 'flex'),
      (this.element.style.display = 'flex'),
      await this.uiManager.initUI(),
      this.paintBucketTool.initPaintBucketTool(),
      this.colorSelectTool.initColorSelectTool(),
      await this.canvasHistory.saveInitialState(),
      (this.isOpen = !0),
      s.clipspace && s.clipspace.imgs && this.uiManager.setSidebarImage(),
      this.keyboardManager.addListeners()
  }
  cleanup() {
    document.querySelectorAll('[id^="maskEditor"]').forEach((t) => t.remove())
    document.querySelectorAll('#maskEditor_brush').forEach((t) => t.remove())
  }
  isOpened() {
    return this.isOpen
  }
  async save() {
    const t = document.createElement('canvas'),
      e = this.uiManager.getImgCanvas(),
      n = this.uiManager.getMaskCanvas(),
      i = this.uiManager.getImage(),
      r = t.getContext('2d', { willReadFrequently: !0 })
    if (((t.width = e.width), (t.height = e.height), !r)) return
    const a = new Promise((t, e) => {
      const i = new Image()
      ;(i.src = n.toDataURL()),
        (i.onload = () => {
          t()
        }),
        (i.onerror = (t) => {
          e(t)
        })
    })
    try {
      await a
    } catch (M) {
      return void console.error('Error loading mask image:', M)
    }
    r.clearRect(0, 0, t.width, t.height),
      r.drawImage(n, 0, 0, n.width, n.height, 0, 0, t.width, t.height)
    let o = !1
    const l = r.getImageData(0, 0, t.width, t.height)
    for (let s = 0; s < l.data.length; s += 4)
      if (0 !== l.data[s + 3]) {
        o = !0
        break
      }
    const c = r.getImageData(0, 0, t.width, t.height)
    let h = !1
    for (let s = 0; s < c.data.length; s += 4)
      if (0 !== c.data[s + 3]) {
        h = !0
        break
      }
    if (o && !h)
      return (
        console.error('Mask appears to be empty'),
        void alert('Cannot save empty mask')
      )
    for (let s = 0; s < c.data.length; s += 4) {
      const t = c.data[s + 3]
      ;(c.data[s] = 0),
        (c.data[s + 1] = 0),
        (c.data[s + 2] = 0),
        (c.data[s + 3] = 255 - t)
    }
    ;(r.globalCompositeOperation = 'source-over'), r.putImageData(c, 0, 0)
    const u = new FormData(),
      d = 'clipspace-mask-' + performance.now() + '.png',
      p = { filename: d, subfolder: 'clipspace', type: 'input' }
    if (s?.clipspace?.widgets?.length) {
      const t = s.clipspace.widgets.findIndex((t) => 'image' === t?.name)
      if (t >= 0 && void 0 !== p)
        try {
          s.clipspace.widgets[t].value = p
        } catch (S) {
          console.warn('Failed to set widget value:', S)
        }
    }
    const m = t.toDataURL(),
      f = this.dataURLToBlob(m)
    let g = new URL(i.src)
    this.uiManager.setBrushOpacity(0)
    const v = g.searchParams.get('filename')
    if (!v) throw new Error('filename parameter is required')
    const y = { filename: v }
    let _ = g.searchParams.get('subfolder')
    _ && (y.subfolder = _)
    let x = g.searchParams.get('type')
    x && (y.type = x),
      u.append('image', f, d),
      u.append('original_ref', JSON.stringify(y)),
      u.append('type', 'input'),
      u.append('subfolder', 'clipspace'),
      this.uiManager.setSaveButtonText('Saving'),
      this.uiManager.setSaveButtonEnabled(!1),
      this.keyboardManager.removeListeners()
    let b = 0,
      w = !1
    for (; b < 3 && !w; )
      try {
        await this.uploadMask(p, u), (w = !0)
      } catch (M) {
        console.error(`Upload attempt ${b + 1} failed:`, M),
          b++,
          b < 3
            ? console.log('Retrying upload...')
            : console.log('Max retries reached. Upload failed.')
      }
    w
      ? (s.onClipspaceEditorSave(), this.close(), (this.isOpen = !1))
      : (this.uiManager.setSaveButtonText('Save'),
        this.uiManager.setSaveButtonEnabled(!0),
        this.keyboardManager.addListeners())
  }
  getMessageBroker() {
    return this.messageBroker
  }
  dataURLToBlob(t) {
    const e = t.split(';base64,'),
      n = e[0].split(':')[1],
      i = atob(e[1]),
      s = new ArrayBuffer(i.length),
      r = new Uint8Array(s)
    for (let a = 0; a < i.length; a++) r[a] = i.charCodeAt(a)
    return new Blob([s], { type: n })
  }
  async uploadMask(t, e, n = 3) {
    if (n <= 0) throw new Error('Max retries reached')
    await p
      .fetchApi('/upload/mask', { method: 'POST', body: e })
      .then((n) => {
        n.ok ||
          (console.log('Failed to upload mask:', n), this.uploadMask(t, e, 2))
      })
      .catch((t) => {
        console.error('Error:', t)
      })
    try {
      const e = s.clipspace?.selectedIndex
      if (s.clipspace?.imgs && void 0 !== e) {
        const n = new Image()
        ;(n.src = p.apiURL(
          '/view?' +
            new URLSearchParams(t).toString() +
            r.getPreviewFormatParam() +
            r.getRandParam()
        )),
          (s.clipspace.imgs[e] = n),
          s.clipspace.images && (s.clipspace.images[e] = t)
      }
    } catch (i) {
      console.warn('Failed to update clipspace image:', i)
    }
    A.invalidatePreview()
  }
}
class at {
  static {
    e(this, 'CanvasHistory')
  }
  maskEditor
  messageBroker
  canvas
  ctx
  states = []
  currentStateIndex = -1
  maxStates = 20
  initialized = !1
  constructor(t, e = 20) {
    ;(this.maskEditor = t),
      (this.messageBroker = t.getMessageBroker()),
      (this.maxStates = e),
      this.createListeners()
  }
  async pullCanvas() {
    ;(this.canvas = await this.messageBroker.pull('maskCanvas')),
      (this.ctx = await this.messageBroker.pull('maskCtx'))
  }
  createListeners() {
    this.messageBroker.subscribe('saveState', () => this.saveState()),
      this.messageBroker.subscribe('undo', () => this.undo()),
      this.messageBroker.subscribe('redo', () => this.redo())
  }
  clearStates() {
    ;(this.states = []), (this.currentStateIndex = -1), (this.initialized = !1)
  }
  async saveInitialState() {
    if ((await this.pullCanvas(), !this.canvas.width || !this.canvas.height))
      return void requestAnimationFrame(() => this.saveInitialState())
    this.clearStates()
    const t = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height)
    this.states.push(t), (this.currentStateIndex = 0), (this.initialized = !0)
  }
  saveState() {
    if (!this.initialized || -1 === this.currentStateIndex)
      return void this.saveInitialState()
    this.states = this.states.slice(0, this.currentStateIndex + 1)
    const t = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height)
    this.states.push(t),
      this.currentStateIndex++,
      this.states.length > this.maxStates &&
        (this.states.shift(), this.currentStateIndex--)
  }
  undo() {
    this.states.length > 1 && this.currentStateIndex > 0
      ? (this.currentStateIndex--,
        this.restoreState(this.states[this.currentStateIndex]))
      : alert('No more undo states available')
  }
  redo() {
    this.states.length > 1 && this.currentStateIndex < this.states.length - 1
      ? (this.currentStateIndex++,
        this.restoreState(this.states[this.currentStateIndex]))
      : alert('No more redo states available')
  }
  restoreState(t) {
    t && this.initialized && this.ctx.putImageData(t, 0, 0)
  }
}
class ot {
  static {
    e(this, 'PaintBucketTool')
  }
  maskEditor
  messageBroker
  canvas
  ctx
  width = null
  height = null
  imageData = null
  data = null
  tolerance = 5
  constructor(t) {
    ;(this.maskEditor = t),
      (this.messageBroker = t.getMessageBroker()),
      this.createListeners(),
      this.addPullTopics()
  }
  initPaintBucketTool() {
    this.pullCanvas()
  }
  async pullCanvas() {
    ;(this.canvas = await this.messageBroker.pull('maskCanvas')),
      (this.ctx = await this.messageBroker.pull('maskCtx'))
  }
  createListeners() {
    this.messageBroker.subscribe('setPaintBucketTolerance', (t) =>
      this.setTolerance(t)
    ),
      this.messageBroker.subscribe('paintBucketFill', (t) => this.floodFill(t)),
      this.messageBroker.subscribe('invert', () => this.invertMask())
  }
  addPullTopics() {
    this.messageBroker.createPullTopic(
      'getTolerance',
      async () => this.tolerance
    )
  }
  getPixel(t, e) {
    return this.data[4 * (e * this.width + t) + 3]
  }
  setPixel(t, e, n, i) {
    const s = 4 * (e * this.width + t)
    ;(this.data[s] = i.r),
      (this.data[s + 1] = i.g),
      (this.data[s + 2] = i.b),
      (this.data[s + 3] = n)
  }
  shouldProcessPixel(t, e, n, i) {
    return (
      -1 !== t &&
      (i
        ? 255 !== t && Math.abs(t - e) <= n
        : 255 === t || Math.abs(t - e) <= n)
    )
  }
  async floodFill(t) {
    let n = Math.floor(t.x),
      i = Math.floor(t.y)
    if (
      ((this.width = this.canvas.width),
      (this.height = this.canvas.height),
      n < 0 || n >= this.width || i < 0 || i >= this.height)
    )
      return
    ;(this.imageData = this.ctx.getImageData(0, 0, this.width, this.height)),
      (this.data = this.imageData.data)
    const s = this.getPixel(n, i),
      r = 255 !== s
    if (-1 === s) return
    const a = await this.messageBroker.pull('getMaskColor'),
      o = [],
      l = new Uint8Array(this.width * this.height)
    for (
      this.shouldProcessPixel(s, s, this.tolerance, r) && o.push([n, i]);
      o.length > 0;

    ) {
      const [t, n] = o.pop(),
        i = n * this.width + t
      if (l[i]) continue
      const c = this.getPixel(t, n)
      if (!this.shouldProcessPixel(c, s, this.tolerance, r)) continue
      ;(l[i] = 1), this.setPixel(t, n, r ? 255 : 0, a)
      const h = e((t, e) => {
        if (
          !(
            t < 0 ||
            t >= this.width ||
            e < 0 ||
            e >= this.height ||
            l[e * this.width + t]
          )
        ) {
          const n = this.getPixel(t, e)
          this.shouldProcessPixel(n, s, this.tolerance, r) && o.push([t, e])
        }
      }, 'checkNeighbor')
      h(t - 1, n), h(t + 1, n), h(t, n - 1), h(t, n + 1)
    }
    this.ctx.putImageData(this.imageData, 0, 0),
      (this.imageData = null),
      (this.data = null)
  }
  setTolerance(t) {
    this.tolerance = t
  }
  getTolerance() {
    return this.tolerance
  }
  invertMask() {
    const t = this.ctx.getImageData(
        0,
        0,
        this.canvas.width,
        this.canvas.height
      ),
      e = t.data
    let n = 0,
      i = 0,
      s = 0
    for (let r = 0; r < e.length; r += 4)
      if (e[r + 3] > 0) {
        ;(n = e[r]), (i = e[r + 1]), (s = e[r + 2])
        break
      }
    for (let r = 0; r < e.length; r += 4) {
      const t = e[r + 3]
      ;(e[r + 3] = 255 - t),
        0 === t && ((e[r] = n), (e[r + 1] = i), (e[r + 2] = s))
    }
    this.ctx.putImageData(t, 0, 0), this.messageBroker.publish('saveState')
  }
}
class lt {
  static {
    e(this, 'ColorSelectTool')
  }
  maskEditor
  messageBroker
  width = null
  height = null
  canvas
  maskCTX
  imageCTX
  maskData = null
  imageData = null
  tolerance = 20
  livePreview = !1
  lastPoint = null
  colorComparisonMethod = 'simple'
  applyWholeImage = !1
  maskBoundry = !1
  maskTolerance = 0
  constructor(t) {
    ;(this.maskEditor = t),
      (this.messageBroker = t.getMessageBroker()),
      this.createListeners(),
      this.addPullTopics()
  }
  async initColorSelectTool() {
    await this.pullCanvas()
  }
  async pullCanvas() {
    ;(this.canvas = await this.messageBroker.pull('imgCanvas')),
      (this.maskCTX = await this.messageBroker.pull('maskCtx')),
      (this.imageCTX = await this.messageBroker.pull('imageCtx'))
  }
  createListeners() {
    this.messageBroker.subscribe('colorSelectFill', (t) =>
      this.fillColorSelection(t)
    ),
      this.messageBroker.subscribe('setColorSelectTolerance', (t) =>
        this.setTolerance(t)
      ),
      this.messageBroker.subscribe('setLivePreview', (t) =>
        this.setLivePreview(t)
      ),
      this.messageBroker.subscribe('setColorComparisonMethod', (t) =>
        this.setComparisonMethod(t)
      ),
      this.messageBroker.subscribe('clearLastPoint', () =>
        this.clearLastPoint()
      ),
      this.messageBroker.subscribe('setWholeImage', (t) =>
        this.setApplyWholeImage(t)
      ),
      this.messageBroker.subscribe('setMaskBoundary', (t) =>
        this.setMaskBoundary(t)
      ),
      this.messageBroker.subscribe('setMaskTolerance', (t) =>
        this.setMaskTolerance(t)
      )
  }
  async addPullTopics() {
    this.messageBroker.createPullTopic(
      'getLivePreview',
      async () => this.livePreview
    )
  }
  getPixel(t, e) {
    const n = 4 * (e * this.width + t)
    return {
      r: this.imageData[n],
      g: this.imageData[n + 1],
      b: this.imageData[n + 2]
    }
  }
  getMaskAlpha(t, e) {
    return this.maskData[4 * (e * this.width + t) + 3]
  }
  isPixelInRange(t, e) {
    switch (this.colorComparisonMethod) {
      case 'simple':
      default:
        return this.isPixelInRangeSimple(t, e)
      case 'hsl':
        return this.isPixelInRangeHSL(t, e)
      case 'lab':
        return this.isPixelInRangeLab(t, e)
    }
  }
  isPixelInRangeSimple(t, e) {
    return (
      Math.sqrt(
        Math.pow(t.r - e.r, 2) + Math.pow(t.g - e.g, 2) + Math.pow(t.b - e.b, 2)
      ) <= this.tolerance
    )
  }
  isPixelInRangeHSL(t, e) {
    const n = this.rgbToHSL(t.r, t.g, t.b),
      i = this.rgbToHSL(e.r, e.g, e.b),
      s = Math.abs(n.h - i.h),
      r = Math.abs(n.s - i.s),
      a = Math.abs(n.l - i.l)
    return (
      Math.sqrt(
        Math.pow((s / 360) * 255, 2) +
          Math.pow((r / 100) * 255, 2) +
          Math.pow((a / 100) * 255, 2)
      ) <= this.tolerance
    )
  }
  rgbToHSL(t, e, n) {
    ;(t /= 255), (e /= 255), (n /= 255)
    const i = Math.max(t, e, n),
      s = Math.min(t, e, n)
    let r = 0,
      a = 0,
      o = (i + s) / 2
    if (i !== s) {
      const l = i - s
      switch (((a = o > 0.5 ? l / (2 - i - s) : l / (i + s)), i)) {
        case t:
          r = (e - n) / l + (e < n ? 6 : 0)
          break
        case e:
          r = (n - t) / l + 2
          break
        case n:
          r = (t - e) / l + 4
      }
      r /= 6
    }
    return { h: 360 * r, s: 100 * a, l: 100 * o }
  }
  isPixelInRangeLab(t, e) {
    const n = this.rgbToLab(t),
      i = this.rgbToLab(e)
    return (
      (Math.sqrt(
        Math.pow(n.l - i.l, 2) + Math.pow(n.a - i.a, 2) + Math.pow(n.b - i.b, 2)
      ) /
        100) *
        255 <=
      this.tolerance
    )
  }
  rgbToLab(t) {
    let e = t.r / 255,
      n = t.g / 255,
      i = t.b / 255
    ;(e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92),
      (n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92),
      (i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92),
      (e *= 100),
      (n *= 100),
      (i *= 100)
    const s = [
      (0.4124 * e + 0.3576 * n + 0.1805 * i) / 95.047,
      (0.2126 * e + 0.7152 * n + 0.0722 * i) / 100,
      (0.0193 * e + 0.1192 * n + 0.9505 * i) / 108.883
    ]
    for (let r = 0; r < s.length; r++)
      s[r] = s[r] > 0.008856 ? Math.pow(s[r], 1 / 3) : 7.787 * s[r] + 16 / 116
    return {
      l: 116 * s[1] - 16,
      a: 500 * (s[0] - s[1]),
      b: 200 * (s[1] - s[2])
    }
  }
  setPixel(t, e, n, i) {
    const s = 4 * (e * this.width + t)
    ;(this.maskData[s] = i.r),
      (this.maskData[s + 1] = i.g),
      (this.maskData[s + 2] = i.b),
      (this.maskData[s + 3] = n)
  }
  async fillColorSelection(t) {
    ;(this.width = this.canvas.width),
      (this.height = this.canvas.height),
      (this.lastPoint = t)
    const e = this.maskCTX.getImageData(0, 0, this.width, this.height)
    if (
      ((this.maskData = e.data),
      (this.imageData = this.imageCTX.getImageData(
        0,
        0,
        this.width,
        this.height
      ).data),
      this.applyWholeImage)
    ) {
      const e = this.getPixel(Math.floor(t.x), Math.floor(t.y)),
        n = await this.messageBroker.pull('getMaskColor'),
        i = this.width,
        s = this.height,
        r = 1e4
      for (let t = 0; t < i * s; t += r) {
        const a = Math.min(t + r, i * s)
        for (let s = t; s < a; s++) {
          const t = s % i,
            r = Math.floor(s / i)
          this.isPixelInRange(this.getPixel(t, r), e) &&
            this.setPixel(t, r, 255, n)
        }
        await new Promise((t) => setTimeout(t, 0))
      }
    } else {
      let e = Math.floor(t.x),
        n = Math.floor(t.y)
      if (e < 0 || e >= this.width || n < 0 || n >= this.height) return
      const i = this.getPixel(e, n),
        s = [],
        r = new Uint8Array(this.width * this.height)
      s.push([e, n])
      const a = await this.messageBroker.pull('getMaskColor')
      for (; s.length > 0; ) {
        const [t, e] = s.pop(),
          n = e * this.width + t
        !r[n] &&
          this.isPixelInRange(this.getPixel(t, e), i) &&
          ((r[n] = 1),
          this.setPixel(t, e, 255, a),
          t > 0 &&
            !r[e * this.width + (t - 1)] &&
            this.isPixelInRange(this.getPixel(t - 1, e), i) &&
            (!this.maskBoundry ||
              255 - this.getMaskAlpha(t - 1, e) > this.maskTolerance) &&
            s.push([t - 1, e]),
          t < this.width - 1 &&
            !r[e * this.width + (t + 1)] &&
            this.isPixelInRange(this.getPixel(t + 1, e), i) &&
            (!this.maskBoundry ||
              255 - this.getMaskAlpha(t + 1, e) > this.maskTolerance) &&
            s.push([t + 1, e]),
          e > 0 &&
            !r[(e - 1) * this.width + t] &&
            this.isPixelInRange(this.getPixel(t, e - 1), i) &&
            (!this.maskBoundry ||
              255 - this.getMaskAlpha(t, e - 1) > this.maskTolerance) &&
            s.push([t, e - 1]),
          e < this.height - 1 &&
            !r[(e + 1) * this.width + t] &&
            this.isPixelInRange(this.getPixel(t, e + 1), i) &&
            (!this.maskBoundry ||
              255 - this.getMaskAlpha(t, e + 1) > this.maskTolerance) &&
            s.push([t, e + 1]))
      }
    }
    this.maskCTX.putImageData(e, 0, 0),
      this.messageBroker.publish('saveState'),
      (this.maskData = null),
      (this.imageData = null)
  }
  setTolerance(t) {
    ;(this.tolerance = t),
      this.lastPoint &&
        this.livePreview &&
        (this.messageBroker.publish('undo'),
        this.fillColorSelection(this.lastPoint))
  }
  setLivePreview(t) {
    this.livePreview = t
  }
  setComparisonMethod(t) {
    ;(this.colorComparisonMethod = t),
      this.lastPoint &&
        this.livePreview &&
        (this.messageBroker.publish('undo'),
        this.fillColorSelection(this.lastPoint))
  }
  clearLastPoint() {
    this.lastPoint = null
  }
  setApplyWholeImage(t) {
    this.applyWholeImage = t
  }
  setMaskBoundary(t) {
    this.maskBoundry = t
  }
  setMaskTolerance(t) {
    this.maskTolerance = t
  }
}
class ct {
  static {
    e(this, 'BrushTool')
  }
  brushSettings
  maskBlendMode
  isDrawing = !1
  isDrawingLine = !1
  lineStartPoint = null
  smoothingPrecision = 10
  smoothingCordsArray = []
  smoothingLastDrawTime
  maskCtx = null
  initialDraw = !0
  brushStrokeCanvas = null
  brushStrokeCtx = null
  isBrushAdjusting = !1
  brushPreviewGradient = null
  initialPoint = null
  useDominantAxis = !1
  brushAdjustmentSpeed = 1
  maskEditor
  messageBroker
  constructor(t) {
    ;(this.maskEditor = t),
      (this.messageBroker = t.getMessageBroker()),
      this.createListeners(),
      this.addPullTopics(),
      (this.useDominantAxis = r.extensionManager.setting.get(
        'Comfy.MaskEditor.UseDominantAxis'
      )),
      (this.brushAdjustmentSpeed = r.extensionManager.setting.get(
        'Comfy.MaskEditor.BrushAdjustmentSpeed'
      )),
      (this.brushSettings = {
        size: 10,
        opacity: 100,
        hardness: 1,
        type: 'arc'
      }),
      (this.maskBlendMode = 'black')
  }
  createListeners() {
    this.messageBroker.subscribe('setBrushSize', (t) => this.setBrushSize(t)),
      this.messageBroker.subscribe('setBrushOpacity', (t) =>
        this.setBrushOpacity(t)
      ),
      this.messageBroker.subscribe('setBrushHardness', (t) =>
        this.setBrushHardness(t)
      ),
      this.messageBroker.subscribe('setBrushShape', (t) =>
        this.setBrushType(t)
      ),
      this.messageBroker.subscribe('setBrushSmoothingPrecision', (t) =>
        this.setBrushSmoothingPrecision(t)
      ),
      this.messageBroker.subscribe('brushAdjustmentStart', (t) =>
        this.startBrushAdjustment(t)
      ),
      this.messageBroker.subscribe('brushAdjustment', (t) =>
        this.handleBrushAdjustment(t)
      ),
      this.messageBroker.subscribe('drawStart', (t) => this.startDrawing(t)),
      this.messageBroker.subscribe('draw', (t) => this.handleDrawing(t)),
      this.messageBroker.subscribe('drawEnd', (t) => this.drawEnd(t))
  }
  addPullTopics() {
    this.messageBroker.createPullTopic(
      'brushSize',
      async () => this.brushSettings.size
    ),
      this.messageBroker.createPullTopic(
        'brushOpacity',
        async () => this.brushSettings.opacity
      ),
      this.messageBroker.createPullTopic(
        'brushHardness',
        async () => this.brushSettings.hardness
      ),
      this.messageBroker.createPullTopic(
        'brushType',
        async () => this.brushSettings.type
      ),
      this.messageBroker.createPullTopic(
        'maskBlendMode',
        async () => this.maskBlendMode
      ),
      this.messageBroker.createPullTopic(
        'brushSettings',
        async () => this.brushSettings
      )
  }
  async createBrushStrokeCanvas() {
    if (null !== this.brushStrokeCanvas) return
    const t = await this.messageBroker.pull('maskCanvas'),
      e = document.createElement('canvas')
    ;(e.width = t.width),
      (e.height = t.height),
      (this.brushStrokeCanvas = e),
      (this.brushStrokeCtx = e.getContext('2d'))
  }
  async startDrawing(t) {
    let e
    this.isDrawing = !0
    let n = await this.messageBroker.pull('currentTool'),
      i = { x: t.offsetX, y: t.offsetY },
      s = await this.messageBroker.pull('screenToCanvas', i)
    await this.createBrushStrokeCanvas(),
      (e =
        'eraser' === n || 2 == t.buttons ? 'destination-out' : 'source-over'),
      t.shiftKey && this.lineStartPoint
        ? ((this.isDrawingLine = !0), this.drawLine(this.lineStartPoint, s, e))
        : ((this.isDrawingLine = !1), this.init_shape(e), this.draw_shape(s)),
      (this.lineStartPoint = s),
      (this.smoothingCordsArray = [s]),
      (this.smoothingLastDrawTime = new Date())
  }
  async handleDrawing(t) {
    var e = performance.now() - this.smoothingLastDrawTime.getTime()
    let n = { x: t.offsetX, y: t.offsetY },
      i = await this.messageBroker.pull('screenToCanvas', n),
      s = await this.messageBroker.pull('currentTool')
    e > 20 && !this.isDrawing
      ? requestAnimationFrame(() => {
          this.init_shape('source-over'),
            this.draw_shape(i),
            this.smoothingCordsArray.push(i)
        })
      : requestAnimationFrame(() => {
          'eraser' === s || 2 == t.buttons
            ? this.init_shape('destination-out')
            : this.init_shape('source-over'),
            this.drawWithBetterSmoothing(i)
        }),
      (this.smoothingLastDrawTime = new Date())
  }
  async drawEnd(t) {
    const e = { x: t.offsetX, y: t.offsetY },
      n = await this.messageBroker.pull('screenToCanvas', e)
    this.isDrawing &&
      ((this.isDrawing = !1),
      this.messageBroker.publish('saveState'),
      (this.lineStartPoint = n),
      (this.initialDraw = !0))
  }
  drawWithBetterSmoothing(t) {
    this.smoothingCordsArray || (this.smoothingCordsArray = [])
    const e = 1 / (1 + Math.exp(3)),
      n = 1 / (1 + Math.exp(-6 * (this.brushSettings.opacity - 0.5))) - e
    this.smoothingCordsArray.push(t)
    if (this.smoothingCordsArray.length < 5) return
    let i = 0
    const s = this.smoothingCordsArray,
      r = s.length - 1
    let a, o
    for (let h = 0; h < r; h++)
      (a = s[h + 1].x - s[h].x),
        (o = s[h + 1].y - s[h].y),
        (i += Math.sqrt(a * a + o * o))
    const l = (this.brushSettings.size / this.smoothingPrecision) * 6
    let c = s
    if (
      (Math.ceil(i / l) > 0 &&
        (c = this.generateEquidistantPoints(this.smoothingCordsArray, l)),
      !this.initialDraw)
    ) {
      const t = c.findIndex(
        (t) =>
          t.x === this.smoothingCordsArray[2].x &&
          t.y === this.smoothingCordsArray[2].y
      )
      ;-1 !== t && (c = c.slice(t + 1))
    }
    for (const h of c) this.draw_shape(h, n)
    this.initialDraw
      ? (this.initialDraw = !1)
      : (this.smoothingCordsArray = this.smoothingCordsArray.slice(2))
  }
  async drawLine(t, e, n) {
    const i = await this.messageBroker.pull('brushSize'),
      s = Math.sqrt((e.x - t.x) ** 2 + (e.y - t.y) ** 2),
      r = Math.ceil(s / ((i / this.smoothingPrecision) * 4)),
      a =
        1 / (1 + Math.exp(-6 * (this.brushSettings.opacity - 0.5))) -
        1 / (1 + Math.exp(3))
    this.init_shape(n)
    for (let o = 0; o <= r; o++) {
      const n = o / r,
        i = { x: t.x + (e.x - t.x) * n, y: t.y + (e.y - t.y) * n }
      this.draw_shape(i, a)
    }
  }
  async startBrushAdjustment(t) {
    t.preventDefault()
    const e = { x: t.offsetX, y: t.offsetY }
    let n = await this.messageBroker.pull('screenToCanvas', e)
    this.messageBroker.publish('setBrushPreviewGradientVisibility', !0),
      (this.initialPoint = n),
      (this.isBrushAdjusting = !0)
  }
  async handleBrushAdjustment(t) {
    const e = { x: t.offsetX, y: t.offsetY }
    let n = await this.messageBroker.pull('screenToCanvas', e)
    const i = n.x - this.initialPoint.x,
      s = n.y - this.initialPoint.y,
      r = Math.abs(i) < 5 ? 0 : i,
      a = Math.abs(s) < 5 ? 0 : s
    let o = r,
      l = a
    if ((console.log(this.useDominantAxis), this.useDominantAxis)) {
      const t = Math.abs(r) / Math.abs(a),
        e = 2
      t > e ? (l = 0) : t < 1 / e && (o = 0)
    }
    const c = Math.max(-100, Math.min(100, o)),
      h = Math.max(-100, Math.min(100, l)),
      u = Math.max(
        1,
        Math.min(
          100,
          this.brushSettings.size + (c / 35) * this.brushAdjustmentSpeed
        )
      ),
      d = Math.max(
        0,
        Math.min(
          1,
          this.brushSettings.hardness - (h / 4e3) * this.brushAdjustmentSpeed
        )
      )
    ;(this.brushSettings.size = u),
      (this.brushSettings.hardness = d),
      this.messageBroker.publish('updateBrushPreview')
  }
  async draw_shape(t, e) {
    const n = this.brushSettings,
      i = this.maskCtx || (await this.messageBroker.pull('maskCtx')),
      s = await this.messageBroker.pull('brushType'),
      r = await this.messageBroker.pull('getMaskColor'),
      a = n.size,
      o = n.opacity,
      l = null == e ? o : e,
      c = n.hardness,
      h = t.x,
      u = t.y,
      d = a * (2 - c)
    let p = i.createRadialGradient(h, u, 0, h, u, d)
    const m = 'destination-out' === i.globalCompositeOperation
    if (1 === c)
      console.log(o, l),
        p.addColorStop(
          0,
          m ? `rgba(255, 255, 255, ${l})` : `rgba(${r.r}, ${r.g}, ${r.b}, ${l})`
        ),
        p.addColorStop(
          1,
          m ? `rgba(255, 255, 255, ${l})` : `rgba(${r.r}, ${r.g}, ${r.b}, ${l})`
        )
    else {
      let t = 1 - c,
        e = Math.max(0, c - t),
        n = a / d
      m
        ? (p.addColorStop(0, `rgba(255, 255, 255, ${l})`),
          p.addColorStop(e, `rgba(255, 255, 255, ${l})`),
          p.addColorStop(n, `rgba(255, 255, 255, ${l / 2})`),
          p.addColorStop(1, 'rgba(255, 255, 255, 0)'))
        : (p.addColorStop(0, `rgba(${r.r}, ${r.g}, ${r.b}, ${l})`),
          p.addColorStop(e, `rgba(${r.r}, ${r.g}, ${r.b}, ${l})`),
          p.addColorStop(n, `rgba(${r.r}, ${r.g}, ${r.b}, ${l / 2})`),
          p.addColorStop(1, `rgba(${r.r}, ${r.g}, ${r.b}, 0)`))
    }
    ;(i.fillStyle = p),
      i.beginPath(),
      'rect' === s
        ? i.rect(h - d, u - d, 2 * d, 2 * d)
        : i.arc(h, u, d, 0, 2 * Math.PI, !1),
      i.fill()
  }
  async init_shape(t) {
    const e = await this.messageBroker.pull('maskBlendMode'),
      n = this.maskCtx || (await this.messageBroker.pull('maskCtx'))
    n.beginPath(),
      'source-over' == t
        ? ((n.fillStyle = e), (n.globalCompositeOperation = 'source-over'))
        : 'destination-out' == t &&
          (n.globalCompositeOperation = 'destination-out')
  }
  calculateCubicSplinePoints(t, e = 10) {
    const n = [],
      i = t.map((t) => t.x),
      s = t.map((t) => t.y),
      r = this.calculateSplineCoefficients(i),
      a = this.calculateSplineCoefficients(s)
    for (let o = 0; o < t.length - 1; o++) {
      const i = t[o],
        s = t[o + 1],
        l = r[o],
        c = r[o + 1],
        h = a[o],
        u = a[o + 1]
      for (let t = 0; t <= e; t++) {
        const r = t / e,
          a = 2 * r ** 3 - 3 * r ** 2 + 1,
          o = r ** 3 - 2 * r ** 2 + r,
          d = -2 * r ** 3 + 3 * r ** 2,
          p = r ** 3 - r ** 2,
          m = a * i.x + o * l + d * s.x + p * c,
          f = a * i.y + o * h + d * s.y + p * u
        n.push({ x: m, y: f })
      }
    }
    return n
  }
  generateEvenlyDistributedPoints(t, e) {
    const n = [0]
    for (let a = 1; a < t.length; a++) {
      const e = t[a].x - t[a - 1].x,
        i = t[a].y - t[a - 1].y,
        s = Math.hypot(e, i)
      n.push(n[a - 1] + s)
    }
    const i = n[n.length - 1] / (e - 1),
      s = []
    let r = 0
    for (let a = 0; a < e; a++) {
      const e = a * i
      for (; r < n.length - 1 && n[r + 1] < e; ) r++
      const o = (e - n[r]) / (n[r + 1] - n[r]),
        l = t[r].x + o * (t[r + 1].x - t[r].x),
        c = t[r].y + o * (t[r + 1].y - t[r].y)
      s.push({ x: l, y: c })
    }
    return s
  }
  generateEquidistantPoints(t, e) {
    const n = [],
      i = [0]
    for (let a = 1; a < t.length; a++) {
      const e = t[a].x - t[a - 1].x,
        n = t[a].y - t[a - 1].y,
        s = Math.hypot(e, n)
      i[a] = i[a - 1] + s
    }
    const s = i[i.length - 1],
      r = Math.floor(s / e)
    for (let a = 0; a <= r; a++) {
      const s = a * e
      let r = 0
      for (; r < i.length - 1 && i[r + 1] < s; ) r++
      if (r >= t.length - 1) {
        n.push(t[t.length - 1])
        continue
      }
      const o = i[r],
        l = (s - o) / (i[r + 1] - o),
        c = t[r].x + l * (t[r + 1].x - t[r].x),
        h = t[r].y + l * (t[r + 1].y - t[r].y)
      n.push({ x: c, y: h })
    }
    return n
  }
  calculateSplineCoefficients(t) {
    const e = t.length - 1,
      n = new Array(e + 1).fill(0).map(() => new Array(e + 1).fill(0)),
      i = new Array(e + 1).fill(0)
    for (let r = 1; r < e; r++)
      (n[r][r - 1] = 1),
        (n[r][r] = 4),
        (n[r][r + 1] = 1),
        (i[r] = 3 * (t[r + 1] - t[r - 1]))
    ;(n[0][0] = 2),
      (n[0][1] = 1),
      (n[e][e - 1] = 1),
      (n[e][e] = 2),
      (i[0] = 3 * (t[1] - t[0])),
      (i[e] = 3 * (t[e] - t[e - 1]))
    for (let r = 1; r <= e; r++) {
      const t = n[r][r - 1] / n[r - 1][r - 1]
      ;(n[r][r] -= t * n[r - 1][r]), (i[r] -= t * i[r - 1])
    }
    const s = new Array(e + 1)
    s[e] = i[e] / n[e][e]
    for (let r = e - 1; r >= 0; r--)
      s[r] = (i[r] - n[r][r + 1] * s[r + 1]) / n[r][r]
    return s
  }
  setBrushSize(t) {
    this.brushSettings.size = t
  }
  setBrushOpacity(t) {
    this.brushSettings.opacity = t
  }
  setBrushHardness(t) {
    this.brushSettings.hardness = t
  }
  setBrushType(t) {
    this.brushSettings.type = t
  }
  setBrushSmoothingPrecision(t) {
    this.smoothingPrecision = t
  }
}
class ht {
  static {
    e(this, 'UIManager')
  }
  rootElement
  brush
  brushPreviewGradient
  maskCtx
  imageCtx
  maskCanvas
  imgCanvas
  brushSettingsHTML
  paintBucketSettingsHTML
  colorSelectSettingsHTML
  maskOpacitySlider
  brushHardnessSlider
  brushSizeSlider
  brushOpacitySlider
  sidebarImage
  saveButton
  toolPanel
  sidePanel
  pointerZone
  canvasBackground
  canvasContainer
  image
  imageURL
  darkMode = !0
  maskEditor
  messageBroker
  mask_opacity = 1
  maskBlendMode = 'black'
  zoomTextHTML
  dimensionsTextHTML
  constructor(t, e) {
    ;(this.rootElement = t),
      (this.maskEditor = e),
      (this.messageBroker = e.getMessageBroker()),
      this.addListeners(),
      this.addPullTopics()
  }
  addListeners() {
    this.messageBroker.subscribe('updateBrushPreview', async () =>
      this.updateBrushPreview()
    ),
      this.messageBroker.subscribe('paintBucketCursor', (t) =>
        this.handlePaintBucketCursor(t)
      ),
      this.messageBroker.subscribe('panCursor', (t) => this.handlePanCursor(t)),
      this.messageBroker.subscribe('setBrushVisibility', (t) =>
        this.setBrushVisibility(t)
      ),
      this.messageBroker.subscribe('setBrushPreviewGradientVisibility', (t) =>
        this.setBrushPreviewGradientVisibility(t)
      ),
      this.messageBroker.subscribe('updateCursor', () => this.updateCursor()),
      this.messageBroker.subscribe('setZoomText', (t) => this.setZoomText(t))
  }
  addPullTopics() {
    this.messageBroker.createPullTopic(
      'maskCanvas',
      async () => this.maskCanvas
    ),
      this.messageBroker.createPullTopic('maskCtx', async () => this.maskCtx),
      this.messageBroker.createPullTopic('imageCtx', async () => this.imageCtx),
      this.messageBroker.createPullTopic(
        'imgCanvas',
        async () => this.imgCanvas
      ),
      this.messageBroker.createPullTopic('screenToCanvas', async (t) =>
        this.screenToCanvas(t)
      ),
      this.messageBroker.createPullTopic(
        'getCanvasContainer',
        async () => this.canvasContainer
      ),
      this.messageBroker.createPullTopic('getMaskColor', async () =>
        this.getMaskColor()
      )
  }
  async setlayout() {
    this.detectLightMode()
    var t = await this.createUI(),
      e = this.createBackgroundUI(),
      n = await this.createBrush()
    await this.setBrushBorderRadius(),
      this.setBrushOpacity(1),
      this.rootElement.appendChild(e),
      this.rootElement.appendChild(t),
      document.body.appendChild(n)
  }
  async createUI() {
    var t = document.createElement('div')
    t.id = 'maskEditor_uiContainer'
    var e = await this.createTopBar(),
      n = document.createElement('div')
    n.id = 'maskEditor_uiHorizontalContainer'
    var i = await this.createSidePanel(),
      s = this.createPointerZone(),
      r = this.createToolPanel()
    return (
      n.appendChild(r),
      n.appendChild(s),
      n.appendChild(i),
      t.appendChild(e),
      t.appendChild(n),
      t
    )
  }
  createBackgroundUI() {
    const t = document.createElement('div')
    t.id = 'maskEditorCanvasContainer'
    const e = document.createElement('canvas')
    e.id = 'imageCanvas'
    const n = document.createElement('canvas')
    n.id = 'maskCanvas'
    const i = document.createElement('div')
    ;(i.id = 'canvasBackground'),
      t.appendChild(e),
      t.appendChild(n),
      t.appendChild(i),
      (this.imgCanvas = e),
      (this.maskCanvas = n),
      (this.canvasContainer = t),
      (this.canvasBackground = i)
    let s = n.getContext('2d', { willReadFrequently: !0 })
    s && (this.maskCtx = s)
    let r = e.getContext('2d', { willReadFrequently: !0 })
    r && (this.imageCtx = r),
      this.setEventHandler(),
      (this.imgCanvas.style.position = 'absolute'),
      (this.maskCanvas.style.position = 'absolute'),
      (this.imgCanvas.style.top = '200'),
      (this.imgCanvas.style.left = '0'),
      (this.maskCanvas.style.top = this.imgCanvas.style.top),
      (this.maskCanvas.style.left = this.imgCanvas.style.left)
    const a = this.getMaskCanvasStyle()
    return (
      (this.maskCanvas.style.mixBlendMode = a.mixBlendMode),
      (this.maskCanvas.style.opacity = a.opacity.toString()),
      t
    )
  }
  async setBrushBorderRadius() {
    'rect' === (await this.messageBroker.pull('brushSettings')).type
      ? ((this.brush.style.borderRadius = '0%'),
        (this.brush.style.MozBorderRadius = '0%'),
        (this.brush.style.WebkitBorderRadius = '0%'))
      : ((this.brush.style.borderRadius = '50%'),
        (this.brush.style.MozBorderRadius = '50%'),
        (this.brush.style.WebkitBorderRadius = '50%'))
  }
  async initUI() {
    ;(this.saveButton.innerText = 'Save'),
      (this.saveButton.disabled = !1),
      await this.setImages(this.imgCanvas)
  }
  async createSidePanel() {
    const t = this.createContainer(!0)
    t.id = 'maskEditor_sidePanel'
    const e = await this.createBrushSettings()
    ;(e.id = 'maskEditor_brushSettings'), (this.brushSettingsHTML = e)
    const n = await this.createPaintBucketSettings()
    ;(n.id = 'maskEditor_paintBucketSettings'),
      (this.paintBucketSettingsHTML = n)
    const i = await this.createColorSelectSettings()
    ;(i.id = 'maskEditor_colorSelectSettings'),
      (this.colorSelectSettingsHTML = i)
    const s = await this.createImageLayerSettings(),
      r = this.createSeparator()
    return (
      t.appendChild(e),
      t.appendChild(n),
      t.appendChild(i),
      t.appendChild(r),
      t.appendChild(s),
      t
    )
  }
  async createBrushSettings() {
    const t = this.darkMode
        ? 'maskEditor_brushShape_dark'
        : 'maskEditor_brushShape_light',
      e = this.createContainer(!0),
      n = this.createHeadline('Brush Settings'),
      i = this.createContainer(!0),
      s = this.createContainerTitle('Brush Shape'),
      r = this.createContainer(!1),
      a = this.darkMode
        ? 'maskEditor_accent_bg_dark'
        : 'maskEditor_accent_bg_light'
    r.classList.add(a), r.classList.add('maskEditor_layerRow')
    const o = document.createElement('div')
    ;(o.id = 'maskEditor_sidePanelBrushShapeCircle'),
      o.classList.add(t),
      (o.style.background = 'var(--p-button-text-primary-color)'),
      o.addEventListener('click', () => {
        this.messageBroker.publish('setBrushShape', 'arc'),
          this.setBrushBorderRadius(),
          (o.style.background = 'var(--p-button-text-primary-color)'),
          (l.style.background = '')
      })
    const l = document.createElement('div')
    ;(l.id = 'maskEditor_sidePanelBrushShapeSquare'),
      l.classList.add(t),
      (l.style.background = ''),
      l.addEventListener('click', () => {
        this.messageBroker.publish('setBrushShape', 'rect'),
          this.setBrushBorderRadius(),
          (l.style.background = 'var(--p-button-text-primary-color)'),
          (o.style.background = '')
      }),
      r.appendChild(o),
      r.appendChild(l),
      i.appendChild(s),
      i.appendChild(r)
    const c = this.createSlider('Thickness', 1, 100, 1, 10, (t, e) => {
      this.messageBroker.publish('setBrushSize', parseInt(e)),
        this.updateBrushPreview()
    })
    this.brushSizeSlider = c.slider
    const h = this.createSlider('Opacity', 0, 1, 0.01, 0.7, (t, e) => {
      this.messageBroker.publish('setBrushOpacity', parseFloat(e)),
        this.updateBrushPreview()
    })
    this.brushOpacitySlider = h.slider
    const u = this.createSlider('Hardness', 0, 1, 0.01, 1, (t, e) => {
      this.messageBroker.publish('setBrushHardness', parseFloat(e)),
        this.updateBrushPreview()
    })
    this.brushHardnessSlider = u.slider
    const d = this.createSlider(
      'Smoothing Precision',
      1,
      100,
      1,
      10,
      (t, e) => {
        this.messageBroker.publish('setBrushSmoothingPrecision', parseInt(e))
      }
    )
    return (
      e.appendChild(n),
      e.appendChild(i),
      e.appendChild(c.container),
      e.appendChild(h.container),
      e.appendChild(u.container),
      e.appendChild(d.container),
      e
    )
  }
  async createPaintBucketSettings() {
    const t = this.createContainer(!0),
      e = this.createHeadline('Paint Bucket Settings'),
      n = await this.messageBroker.pull('getTolerance'),
      i = this.createSlider('Tolerance', 0, 255, 1, n, (t, e) => {
        this.messageBroker.publish('setPaintBucketTolerance', parseInt(e))
      })
    return t.appendChild(e), t.appendChild(i.container), t
  }
  async createColorSelectSettings() {
    const t = this.createContainer(!0),
      e = this.createHeadline('Color Select Settings')
    var n = await this.messageBroker.pull('getTolerance')
    const i = this.createSlider('Tolerance', 0, 255, 1, n, (t, e) => {
        this.messageBroker.publish('setColorSelectTolerance', parseInt(e))
      }),
      s = this.createToggle('Live Preview', (t, e) => {
        this.messageBroker.publish('setLivePreview', e)
      }),
      r = this.createToggle('Apply to Whole Image', (t, e) => {
        this.messageBroker.publish('setWholeImage', e)
      }),
      a = Object.values(st),
      o = this.createDropdown('Method', a, (t, e) => {
        this.messageBroker.publish('setColorComparisonMethod', e)
      }),
      l = this.createToggle('Stop at mask', (t, e) => {
        this.messageBroker.publish('setMaskBoundary', e)
      }),
      c = this.createSlider('Mask Tolerance', 0, 255, 1, 0, (t, e) => {
        this.messageBroker.publish('setMaskTolerance', parseInt(e))
      })
    return (
      t.appendChild(e),
      t.appendChild(i.container),
      t.appendChild(s),
      t.appendChild(r),
      t.appendChild(o),
      t.appendChild(l),
      t.appendChild(c.container),
      t
    )
  }
  async createImageLayerSettings() {
    const t = this.darkMode
        ? 'maskEditor_accent_bg_dark'
        : 'maskEditor_accent_bg_light',
      e = this.createContainer(!0),
      n = this.createHeadline('Layers'),
      i = this.createContainerTitle('Mask Layer'),
      r = this.createContainer(!1)
    r.classList.add(t), r.classList.add('maskEditor_layerRow')
    const a = document.createElement('input')
    a.setAttribute('type', 'checkbox'),
      (a.checked = !0),
      a.classList.add('maskEditor_sidePanelLayerCheckbox'),
      a.addEventListener('change', (t) => {
        t.target.checked
          ? (this.maskCanvas.style.opacity = String(this.mask_opacity))
          : (this.maskCanvas.style.opacity = '0')
      })
    var o = document.createElement('div')
    o.classList.add('maskEditor_sidePanelLayerPreviewContainer'),
      (o.innerHTML =
        '<svg viewBox="0 0 20 20" style="">   <path class="cls-1" d="M1.31,5.32v9.36c0,.55.45,1,1,1h15.38c.55,0,1-.45,1-1V5.32c0-.55-.45-1-1-1H2.31c-.55,0-1,.45-1,1ZM11.19,13.44c-2.91.94-5.57-1.72-4.63-4.63.34-1.05,1.19-1.9,2.24-2.24,2.91-.94,5.57,1.72,4.63,4.63-.34,1.05-1.19,1.9-2.24,2.24Z"/> </svg>')
    const l = this.darkMode
      ? 'maskEditor_sidePanelDropdown_dark'
      : 'maskEditor_sidePanelDropdown_light'
    var c = document.createElement('select')
    c.classList.add(l),
      c.classList.add(l),
      ['black', 'white', 'negative'].forEach((t) => {
        var e = document.createElement('option')
        ;(e.value = t),
          (e.innerText = t),
          c.appendChild(e),
          t == this.maskBlendMode && (e.selected = !0)
      }),
      c.addEventListener('change', (t) => {
        const e = t.target.value
        ;(this.maskBlendMode = e), this.updateMaskColor()
      }),
      r.appendChild(a),
      r.appendChild(o),
      r.appendChild(c)
    const h = this.createSlider(
      'Mask Opacity',
      0,
      1,
      0.01,
      this.mask_opacity,
      (t, e) => {
        ;(this.mask_opacity = parseFloat(e)),
          (this.maskCanvas.style.opacity = String(this.mask_opacity)),
          0 == this.mask_opacity ? (a.checked = !1) : (a.checked = !0)
      }
    )
    this.maskOpacitySlider = h.slider
    const u = this.createContainerTitle('Image Layer'),
      d = this.createContainer(!1)
    d.classList.add(t), d.classList.add('maskEditor_layerRow')
    const p = document.createElement('input')
    p.setAttribute('type', 'checkbox'),
      p.classList.add('maskEditor_sidePanelLayerCheckbox'),
      (p.checked = !0),
      p.addEventListener('change', (t) => {
        t.target.checked
          ? (this.imgCanvas.style.opacity = '1')
          : (this.imgCanvas.style.opacity = '0')
      })
    const m = document.createElement('div')
    m.classList.add('maskEditor_sidePanelLayerPreviewContainer')
    const f = document.createElement('img')
    return (
      (f.id = 'maskEditor_sidePanelImageLayerImage'),
      (f.src = s.clipspace?.imgs?.[s.clipspace?.selectedIndex ?? 0]?.src ?? ''),
      (this.sidebarImage = f),
      m.appendChild(f),
      d.appendChild(p),
      d.appendChild(m),
      e.appendChild(n),
      e.appendChild(i),
      e.appendChild(r),
      e.appendChild(h.container),
      e.appendChild(u),
      e.appendChild(d),
      e
    )
  }
  createHeadline(t) {
    var e = document.createElement('h3')
    return e.classList.add('maskEditor_sidePanelTitle'), (e.innerText = t), e
  }
  createContainer(t) {
    var e = document.createElement('div')
    return (
      t
        ? e.classList.add('maskEditor_sidePanelContainerColumn')
        : e.classList.add('maskEditor_sidePanelContainerRow'),
      e
    )
  }
  createContainerTitle(t) {
    var e = document.createElement('span')
    return e.classList.add('maskEditor_sidePanelSubTitle'), (e.innerText = t), e
  }
  createSlider(t, e, n, i, s, r) {
    var a = this.createContainer(!0),
      o = this.createContainerTitle(t),
      l = document.createElement('input')
    return (
      l.classList.add('maskEditor_sidePanelBrushRange'),
      l.setAttribute('type', 'range'),
      l.setAttribute('min', String(e)),
      l.setAttribute('max', String(n)),
      l.setAttribute('step', String(i)),
      l.setAttribute('value', String(s)),
      l.addEventListener('input', (t) => {
        r(t, t.target.value)
      }),
      a.appendChild(o),
      a.appendChild(l),
      { container: a, slider: l }
    )
  }
  createToggle(t, e) {
    var n = this.createContainer(!1),
      i = this.createContainerTitle(t),
      s = document.createElement('label')
    s.classList.add('maskEditor_sidePanelToggleContainer')
    var r = document.createElement('input')
    r.setAttribute('type', 'checkbox'),
      r.classList.add('maskEditor_sidePanelToggleCheckbox'),
      r.addEventListener('change', (t) => {
        e(t, t.target.checked)
      })
    var a = this.darkMode
        ? 'maskEditor_toggle_bg_dark'
        : 'maskEditor_toggle_bg_light',
      o = document.createElement('div')
    return (
      o.classList.add('maskEditor_sidePanelToggleSwitch'),
      o.classList.add(a),
      s.appendChild(r),
      s.appendChild(o),
      n.appendChild(i),
      n.appendChild(s),
      n
    )
  }
  createDropdown(t, e, n) {
    const i = this.darkMode
      ? 'maskEditor_sidePanelDropdown_dark'
      : 'maskEditor_sidePanelDropdown_light'
    var s = this.createContainer(!1),
      r = this.createContainerTitle(t),
      a = document.createElement('select')
    return (
      a.classList.add(i),
      a.classList.add('maskEditor_containerDropdown'),
      e.forEach((t) => {
        var e = document.createElement('option')
        ;(e.value = t), (e.innerText = t), a.appendChild(e)
      }),
      a.addEventListener('change', (t) => {
        n(t, t.target.value)
      }),
      s.appendChild(r),
      s.appendChild(a),
      s
    )
  }
  createSeparator() {
    var t = document.createElement('div')
    return t.classList.add('maskEditor_sidePanelSeparator'), t
  }
  async createTopBar() {
    const t = this.darkMode
        ? 'maskEditor_topPanelButton_dark'
        : 'maskEditor_topPanelButton_light',
      e = this.darkMode
        ? 'maskEditor_topPanelIconButton_dark'
        : 'maskEditor_topPanelIconButton_light'
    var n = document.createElement('div')
    n.id = 'maskEditor_topBar'
    var i = document.createElement('div')
    i.id = 'maskEditor_topBarTitleContainer'
    var s = document.createElement('h1')
    ;(s.id = 'maskEditor_topBarTitle'),
      (s.innerText = 'ComfyUI'),
      i.appendChild(s)
    var r = document.createElement('div')
    r.id = 'maskEditor_topBarShortcutsContainer'
    var a = document.createElement('div')
    ;(a.id = 'maskEditor_topBarUndoButton'),
      a.classList.add(e),
      (a.innerHTML =
        '<svg viewBox="0 0 15 15"><path d="M8.77,12.18c-.25,0-.46-.2-.46-.46s.2-.46.46-.46c1.47,0,2.67-1.2,2.67-2.67,0-1.57-1.34-2.67-3.26-2.67h-3.98l1.43,1.43c.18.18.18.47,0,.64-.18.18-.47.18-.64,0l-2.21-2.21c-.18-.18-.18-.47,0-.64l2.21-2.21c.18-.18.47-.18.64,0,.18.18.18.47,0,.64l-1.43,1.43h3.98c2.45,0,4.17,1.47,4.17,3.58,0,1.97-1.61,3.58-3.58,3.58Z"></path> </svg>'),
      a.addEventListener('click', () => {
        this.messageBroker.publish('undo')
      })
    var o = document.createElement('div')
    ;(o.id = 'maskEditor_topBarRedoButton'),
      o.classList.add(e),
      (o.innerHTML =
        '<svg viewBox="0 0 15 15"> <path class="cls-1" d="M6.23,12.18c-1.97,0-3.58-1.61-3.58-3.58,0-2.11,1.71-3.58,4.17-3.58h3.98l-1.43-1.43c-.18-.18-.18-.47,0-.64.18-.18.46-.18.64,0l2.21,2.21c.09.09.13.2.13.32s-.05.24-.13.32l-2.21,2.21c-.18.18-.47.18-.64,0-.18-.18-.18-.47,0-.64l1.43-1.43h-3.98c-1.92,0-3.26,1.1-3.26,2.67,0,1.47,1.2,2.67,2.67,2.67.25,0,.46.2.46.46s-.2.46-.46.46Z"/></svg>'),
      o.addEventListener('click', () => {
        this.messageBroker.publish('redo')
      })
    var l = document.createElement('button')
    ;(l.id = 'maskEditor_topBarInvertButton'),
      l.classList.add(t),
      (l.innerText = 'Invert'),
      l.addEventListener('click', () => {
        this.messageBroker.publish('invert')
      })
    var c = document.createElement('button')
    ;(c.id = 'maskEditor_topBarClearButton'),
      c.classList.add(t),
      (c.innerText = 'Clear'),
      c.addEventListener('click', () => {
        this.maskCtx.clearRect(
          0,
          0,
          this.maskCanvas.width,
          this.maskCanvas.height
        ),
          this.messageBroker.publish('saveState')
      })
    var h = document.createElement('button')
    ;(h.id = 'maskEditor_topBarSaveButton'),
      h.classList.add(t),
      (h.innerText = 'Save'),
      (this.saveButton = h),
      h.addEventListener('click', () => {
        this.maskEditor.save()
      })
    var u = document.createElement('button')
    return (
      (u.id = 'maskEditor_topBarCancelButton'),
      u.classList.add(t),
      (u.innerText = 'Cancel'),
      u.addEventListener('click', () => {
        this.maskEditor.close()
      }),
      r.appendChild(a),
      r.appendChild(o),
      r.appendChild(l),
      r.appendChild(c),
      r.appendChild(h),
      r.appendChild(u),
      n.appendChild(i),
      n.appendChild(r),
      n
    )
  }
  createToolPanel() {
    var t = document.createElement('div')
    ;(t.id = 'maskEditor_toolPanel'), (this.toolPanel = t)
    var e = this.darkMode
        ? 'maskEditor_toolPanelContainerDark'
        : 'maskEditor_toolPanelContainerLight',
      n = [],
      i = document.createElement('div')
    i.classList.add('maskEditor_toolPanelContainer'),
      i.classList.add('maskEditor_toolPanelContainerSelected'),
      i.classList.add(e),
      (i.innerHTML =
        '\n    <svg viewBox="0 0 44 44">\n      <path class="cls-1" d="M34,13.93c0,.47-.19.94-.55,1.31l-13.02,13.04c-.09.07-.18.15-.27.22-.07-1.39-1.21-2.48-2.61-2.49.07-.12.16-.24.27-.34l13.04-13.04c.72-.72,1.89-.72,2.6,0,.35.35.55.83.55,1.3Z"/>\n      <path class="cls-1" d="M19.64,29.03c0,4.46-6.46,3.18-9.64,0,3.3-.47,4.75-2.58,7.06-2.58,1.43,0,2.58,1.16,2.58,2.58Z"/>\n    </svg>\n    '),
      n.push(i),
      i.addEventListener('click', () => {
        this.messageBroker.publish('setTool', 'pen')
        for (let t of n)
          t != i
            ? t.classList.remove('maskEditor_toolPanelContainerSelected')
            : (t.classList.add('maskEditor_toolPanelContainerSelected'),
              (this.brushSettingsHTML.style.display = 'flex'),
              (this.colorSelectSettingsHTML.style.display = 'none'),
              (this.paintBucketSettingsHTML.style.display = 'none'))
        this.messageBroker.publish('setTool', 'pen'),
          (this.pointerZone.style.cursor = 'none')
      })
    var s = document.createElement('div')
    s.classList.add('maskEditor_toolPanelIndicator'), i.appendChild(s)
    var r = document.createElement('div')
    r.classList.add('maskEditor_toolPanelContainer'),
      r.classList.add(e),
      (r.innerHTML =
        '\n      <svg viewBox="0 0 44 44">\n        <g>\n          <rect class="cls-2" x="16.68" y="10" width="10.63" height="24" rx="1.16" ry="1.16" transform="translate(22 -9.11) rotate(45)"/>\n          <path class="cls-1" d="M17.27,34.27c-.42,0-.85-.16-1.17-.48l-5.88-5.88c-.31-.31-.48-.73-.48-1.17s.17-.86.48-1.17l15.34-15.34c.62-.62,1.72-.62,2.34,0l5.88,5.88c.65.65.65,1.7,0,2.34l-15.34,15.34c-.32.32-.75.48-1.17.48ZM26.73,10.73c-.18,0-.34.07-.46.19l-15.34,15.34c-.12.12-.19.29-.19.46s.07.34.19.46l5.88,5.88c.26.26.67.26.93,0l15.34-15.34c.26-.26.26-.67,0-.93l-5.88-5.88c-.12-.12-.29-.19-.46-.19Z"/>\n        </g>\n        <path class="cls-3" d="M20.33,11.03h8.32c.64,0,1.16.52,1.16,1.16v15.79h-10.63v-15.79c0-.64.52-1.16,1.16-1.16Z" transform="translate(20.97 -11.61) rotate(45)"/>\n      </svg>\n    '),
      n.push(r),
      r.addEventListener('click', () => {
        this.messageBroker.publish('setTool', 'eraser')
        for (let t of n)
          t != r
            ? t.classList.remove('maskEditor_toolPanelContainerSelected')
            : (t.classList.add('maskEditor_toolPanelContainerSelected'),
              (this.brushSettingsHTML.style.display = 'flex'),
              (this.colorSelectSettingsHTML.style.display = 'none'),
              (this.paintBucketSettingsHTML.style.display = 'none'))
        this.messageBroker.publish('setTool', 'eraser'),
          (this.pointerZone.style.cursor = 'none')
      })
    var a = document.createElement('div')
    a.classList.add('maskEditor_toolPanelIndicator'), r.appendChild(a)
    var o = document.createElement('div')
    o.classList.add('maskEditor_toolPanelContainer'),
      o.classList.add(e),
      (o.innerHTML =
        '\n    <svg viewBox="0 0 44 44">\n      <path class="cls-1" d="M33.4,21.76l-11.42,11.41-.04.05c-.61.61-1.6.61-2.21,0l-8.91-8.91c-.61-.61-.61-1.6,0-2.21l.04-.05.3-.29h22.24Z"/>\n      <path class="cls-1" d="M20.83,34.17c-.55,0-1.07-.21-1.46-.6l-8.91-8.91c-.8-.8-.8-2.11,0-2.92l11.31-11.31c.8-.8,2.11-.8,2.92,0l8.91,8.91c.39.39.6.91.6,1.46s-.21,1.07-.6,1.46l-11.31,11.31c-.39.39-.91.6-1.46.6ZM23.24,10.83c-.27,0-.54.1-.75.31l-11.31,11.31c-.41.41-.41,1.09,0,1.5l8.91,8.91c.4.4,1.1.4,1.5,0l11.31-11.31c.2-.2.31-.47.31-.75s-.11-.55-.31-.75l-8.91-8.91c-.21-.21-.48-.31-.75-.31Z"/>\n      <path class="cls-1" d="M34.28,26.85c0,.84-.68,1.52-1.52,1.52s-1.52-.68-1.52-1.52,1.52-2.86,1.52-2.86c0,0,1.52,2.02,1.52,2.86Z"/>\n    </svg>\n    '),
      n.push(o),
      o.addEventListener('click', () => {
        this.messageBroker.publish('setTool', 'paintBucket')
        for (let t of n)
          t != o
            ? t.classList.remove('maskEditor_toolPanelContainerSelected')
            : (t.classList.add('maskEditor_toolPanelContainerSelected'),
              (this.brushSettingsHTML.style.display = 'none'),
              (this.colorSelectSettingsHTML.style.display = 'none'),
              (this.paintBucketSettingsHTML.style.display = 'flex'))
        this.messageBroker.publish('setTool', 'paintBucket'),
          (this.pointerZone.style.cursor =
            "url('/cursor/paintBucket.png') 30 25, auto"),
          (this.brush.style.opacity = '0')
      })
    var l = document.createElement('div')
    l.classList.add('maskEditor_toolPanelIndicator'), o.appendChild(l)
    var c = document.createElement('div')
    c.classList.add('maskEditor_toolPanelContainer'),
      c.classList.add(e),
      (c.innerHTML =
        '\n    <svg viewBox="0 0 44 44">\n      <path class="cls-1" d="M30.29,13.72c-1.09-1.1-2.85-1.09-3.94,0l-2.88,2.88-.75-.75c-.2-.19-.51-.19-.71,0-.19.2-.19.51,0,.71l1.4,1.4-9.59,9.59c-.35.36-.54.82-.54,1.32,0,.14,0,.28.05.41-.05.04-.1.08-.15.13-.39.39-.39,1.01,0,1.4.38.39,1.01.39,1.4,0,.04-.04.08-.09.11-.13.14.04.3.06.45.06.5,0,.97-.19,1.32-.55l9.59-9.59,1.38,1.38c.1.09.22.14.35.14s.26-.05.35-.14c.2-.2.2-.52,0-.71l-.71-.72,2.88-2.89c1.08-1.08,1.08-2.85-.01-3.94ZM19.43,25.82h-2.46l7.15-7.15,1.23,1.23-5.92,5.92Z"/>\n    </svg>\n    '),
      n.push(c),
      c.addEventListener('click', () => {
        this.messageBroker.publish('setTool', 'colorSelect')
        for (let t of n)
          t != c
            ? t.classList.remove('maskEditor_toolPanelContainerSelected')
            : (t.classList.add('maskEditor_toolPanelContainerSelected'),
              (this.brushSettingsHTML.style.display = 'none'),
              (this.paintBucketSettingsHTML.style.display = 'none'),
              (this.colorSelectSettingsHTML.style.display = 'flex'))
        this.messageBroker.publish('setTool', 'colorSelect'),
          (this.pointerZone.style.cursor =
            "url('/cursor/colorSelect.png') 15 25, auto"),
          (this.brush.style.opacity = '0')
      })
    var h = document.createElement('div')
    h.classList.add('maskEditor_toolPanelIndicator'), c.appendChild(h)
    var u = document.createElement('div')
    u.classList.add('maskEditor_toolPanelZoomIndicator'), u.classList.add(e)
    var d = document.createElement('span')
    ;(d.id = 'maskEditor_toolPanelZoomText'),
      (d.innerText = '100%'),
      (this.zoomTextHTML = d)
    var p = document.createElement('span')
    return (
      (p.id = 'maskEditor_toolPanelDimensionsText'),
      (p.innerText = ' '),
      (this.dimensionsTextHTML = p),
      u.appendChild(d),
      u.appendChild(p),
      u.addEventListener('click', () => {
        this.messageBroker.publish('resetZoom')
      }),
      t.appendChild(i),
      t.appendChild(r),
      t.appendChild(o),
      t.appendChild(c),
      t.appendChild(u),
      t
    )
  }
  createPointerZone() {
    const t = document.createElement('div')
    return (
      (t.id = 'maskEditor_pointerZone'),
      (this.pointerZone = t),
      t.addEventListener('pointerdown', (t) => {
        this.messageBroker.publish('pointerDown', t)
      }),
      t.addEventListener('pointermove', (t) => {
        this.messageBroker.publish('pointerMove', t)
      }),
      t.addEventListener('pointerup', (t) => {
        this.messageBroker.publish('pointerUp', t)
      }),
      t.addEventListener('pointerleave', (t) => {
        ;(this.brush.style.opacity = '0'), (this.pointerZone.style.cursor = '')
      }),
      t.addEventListener('touchstart', (t) => {
        this.messageBroker.publish('handleTouchStart', t)
      }),
      t.addEventListener('touchmove', (t) => {
        this.messageBroker.publish('handleTouchMove', t)
      }),
      t.addEventListener('touchend', (t) => {
        this.messageBroker.publish('handleTouchEnd', t)
      }),
      t.addEventListener('wheel', (t) =>
        this.messageBroker.publish('wheel', t)
      ),
      t.addEventListener('pointerenter', async (t) => {
        this.updateCursor()
      }),
      t
    )
  }
  async screenToCanvas(t) {
    const e = await this.messageBroker.pull('zoomRatio'),
      n = this.maskCanvas.getBoundingClientRect()
    return {
      x: (t.x - n.left + this.toolPanel.clientWidth) / e,
      y: (t.y - n.top + 44) / e
    }
  }
  setEventHandler() {
    this.maskCanvas.addEventListener('contextmenu', (t) => {
      t.preventDefault()
    }),
      this.rootElement.addEventListener('contextmenu', (t) => {
        t.preventDefault()
      }),
      this.rootElement.addEventListener('dragstart', (t) => {
        t.ctrlKey && t.preventDefault()
      })
  }
  async createBrush() {
    var t = document.createElement('div')
    await this.messageBroker.pull('brushSettings')
    t.id = 'maskEditor_brush'
    var e = document.createElement('div')
    return (
      (e.id = 'maskEditor_brushPreviewGradient'),
      t.appendChild(e),
      (this.brush = t),
      (this.brushPreviewGradient = e),
      t
    )
  }
  async setImages(t) {
    const e = t.getContext('2d', { willReadFrequently: !0 }),
      n = this.maskCtx,
      i = this.maskCanvas
    e.clearRect(0, 0, this.imgCanvas.width, this.imgCanvas.height),
      n.clearRect(0, 0, this.maskCanvas.width, this.maskCanvas.height)
    const r = new URL(
      s.clipspace?.imgs?.[s.clipspace?.selectedIndex ?? 0]?.src ?? ''
    )
    r.searchParams.delete('channel'),
      r.searchParams.delete('preview'),
      r.searchParams.set('channel', 'a')
    let a = await this.loadImage(r)
    if (!s.clipspace?.imgs?.[s.clipspace?.selectedIndex ?? 0]?.src)
      throw new Error(
        'Unable to access image source - clipspace or image is null'
      )
    const o = new URL(s.clipspace.imgs[s.clipspace.selectedIndex].src)
    ;(this.imageURL = o),
      console.log(o),
      o.searchParams.delete('channel'),
      o.searchParams.set('channel', 'rgb'),
      (this.image = new Image()),
      (this.image = await new Promise((t, e) => {
        const n = new Image()
        ;(n.onload = () => t(n)), (n.onerror = e), (n.src = o.toString())
      })),
      (i.width = this.image.width),
      (i.height = this.image.height),
      (this.dimensionsTextHTML.innerText = `${this.image.width}x${this.image.height}`),
      await this.invalidateCanvas(this.image, a),
      this.messageBroker.publish('initZoomPan', [this.image, this.rootElement])
  }
  async invalidateCanvas(t, e) {
    ;(this.imgCanvas.width = t.width),
      (this.imgCanvas.height = t.height),
      (this.maskCanvas.width = t.width),
      (this.maskCanvas.height = t.height)
    let n = this.imgCanvas.getContext('2d', { willReadFrequently: !0 }),
      i = this.maskCanvas.getContext('2d', { willReadFrequently: !0 })
    n.drawImage(t, 0, 0, t.width, t.height),
      await this.prepare_mask(e, this.maskCanvas, i, await this.getMaskColor())
  }
  async prepare_mask(t, e, n, i) {
    n.drawImage(t, 0, 0, e.width, e.height)
    const s = n.getImageData(0, 0, e.width, e.height)
    for (let r = 0; r < s.data.length; r += 4) {
      const t = s.data[r + 3]
      ;(s.data[r] = i.r),
        (s.data[r + 1] = i.g),
        (s.data[r + 2] = i.b),
        (s.data[r + 3] = 255 - t)
    }
    ;(n.globalCompositeOperation = 'source-over'), n.putImageData(s, 0, 0)
  }
  async updateMaskColor() {
    const t = this.getMaskCanvasStyle()
    ;(this.maskCanvas.style.mixBlendMode = t.mixBlendMode),
      (this.maskCanvas.style.opacity = t.opacity.toString())
    const e = await this.getMaskColor()
    ;(this.maskCtx.fillStyle = `rgb(${e.r}, ${e.g}, ${e.b})`),
      this.setCanvasBackground()
    const n = this.maskCtx.getImageData(
      0,
      0,
      this.maskCanvas.width,
      this.maskCanvas.height
    )
    for (let i = 0; i < n.data.length; i += 4)
      (n.data[i] = e.r), (n.data[i + 1] = e.g), (n.data[i + 2] = e.b)
    this.maskCtx.putImageData(n, 0, 0)
  }
  getMaskCanvasStyle() {
    return 'negative' === this.maskBlendMode
      ? { mixBlendMode: 'difference', opacity: '1' }
      : { mixBlendMode: 'initial', opacity: this.mask_opacity }
  }
  detectLightMode() {
    this.darkMode = document.body.classList.contains('dark-theme')
  }
  loadImage(t) {
    return new Promise((e, n) => {
      const i = new Image()
      ;(i.onload = function () {
        e(i)
      }),
        (i.onerror = function (t) {
          n(t)
        }),
        (i.src = t.href)
    })
  }
  async updateBrushPreview() {
    const t = await this.messageBroker.pull('cursorPoint'),
      e = await this.messageBroker.pull('panOffset'),
      n = await this.messageBroker.pull('brushSettings'),
      i = await this.messageBroker.pull('zoomRatio'),
      s = t.x + e.x,
      r = t.y + e.y,
      a = this.brush,
      o = n.hardness,
      l = n.size * (2 - o) * 2 * i
    if (
      ((this.brushSizeSlider.value = String(n.size)),
      (this.brushHardnessSlider.value = String(o)),
      (a.style.width = l + 'px'),
      (a.style.height = l + 'px'),
      (a.style.left = s - l / 2 + 'px'),
      (a.style.top = r - l / 2 + 'px'),
      1 === o)
    )
      return void (this.brushPreviewGradient.style.background =
        'rgba(255, 0, 0, 0.5)')
    const c = o / 4 + 0.25
    this.brushPreviewGradient.style.background = `\n        radial-gradient(\n            circle,\n            rgba(255, 0, 0, 0.5) 0%,\n            rgba(255, 0, 0, ${c}) ${100 * o}%,\n            rgba(255, 0, 0, 0) 100%\n        )\n    `
  }
  getMaskBlendMode() {
    return this.maskBlendMode
  }
  setSidebarImage() {
    this.sidebarImage.src = this.imageURL.href
  }
  async getMaskColor() {
    return 'black' === this.maskBlendMode
      ? { r: 0, g: 0, b: 0 }
      : 'white' === this.maskBlendMode || 'negative' === this.maskBlendMode
        ? { r: 255, g: 255, b: 255 }
        : { r: 0, g: 0, b: 0 }
  }
  async getMaskFillStyle() {
    const t = await this.getMaskColor()
    return 'rgb(' + t.r + ',' + t.g + ',' + t.b + ')'
  }
  async setCanvasBackground() {
    'white' === this.maskBlendMode
      ? (this.canvasBackground.style.background = 'black')
      : (this.canvasBackground.style.background = 'white')
  }
  getMaskCanvas() {
    return this.maskCanvas
  }
  getImgCanvas() {
    return this.imgCanvas
  }
  getImage() {
    return this.image
  }
  setBrushOpacity(t) {
    this.brush.style.opacity = String(t)
  }
  setSaveButtonEnabled(t) {
    this.saveButton.disabled = !t
  }
  setSaveButtonText(t) {
    this.saveButton.innerText = t
  }
  handlePaintBucketCursor(t) {
    this.pointerZone.style.cursor = t
      ? "url('/cursor/paintBucket.png') 30 25, auto"
      : 'none'
  }
  handlePanCursor(t) {
    this.pointerZone.style.cursor = t ? 'grabbing' : 'none'
  }
  setBrushVisibility(t) {
    this.brush.style.opacity = t ? '1' : '0'
  }
  setBrushPreviewGradientVisibility(t) {
    this.brushPreviewGradient.style.display = t ? 'block' : 'none'
  }
  async updateCursor() {
    const t = await this.messageBroker.pull('currentTool')
    'paintBucket' === t
      ? ((this.pointerZone.style.cursor =
          "url('/cursor/paintBucket.png') 30 25, auto"),
        this.setBrushOpacity(0))
      : 'colorSelect' === t
        ? ((this.pointerZone.style.cursor =
            "url('/cursor/colorSelect.png') 15 25, auto"),
          this.setBrushOpacity(0))
        : ((this.pointerZone.style.cursor = 'none'), this.setBrushOpacity(1)),
      this.updateBrushPreview(),
      this.setBrushPreviewGradientVisibility(!1)
  }
  setZoomText(t) {
    this.zoomTextHTML.innerText = t
  }
  setDimensionsText(t) {
    this.dimensionsTextHTML.innerText = t
  }
}
class ut {
  static {
    e(this, 'ToolManager')
  }
  maskEditor
  messageBroker
  mouseDownPoint = null
  currentTool = 'pen'
  isAdjustingBrush = !1
  constructor(t) {
    ;(this.maskEditor = t),
      (this.messageBroker = t.getMessageBroker()),
      this.addListeners(),
      this.addPullTopics()
  }
  addListeners() {
    this.messageBroker.subscribe('setTool', async (t) => {
      this.setTool(t)
    }),
      this.messageBroker.subscribe('pointerDown', async (t) => {
        this.handlePointerDown(t)
      }),
      this.messageBroker.subscribe('pointerMove', async (t) => {
        this.handlePointerMove(t)
      }),
      this.messageBroker.subscribe('pointerUp', async (t) => {
        this.handlePointerUp(t)
      }),
      this.messageBroker.subscribe('wheel', async (t) => {
        this.handleWheelEvent(t)
      })
  }
  async addPullTopics() {
    this.messageBroker.createPullTopic('currentTool', async () =>
      this.getCurrentTool()
    )
  }
  setTool(t) {
    ;(this.currentTool = t),
      'colorSelect' != t && this.messageBroker.publish('clearLastPoint')
  }
  getCurrentTool() {
    return this.currentTool
  }
  async handlePointerDown(t) {
    if ((t.preventDefault(), 'touch' != t.pointerType)) {
      var e = await this.messageBroker.pull('isKeyPressed', ' ')
      if (4 === t.buttons || (1 === t.buttons && e))
        return (
          this.messageBroker.publish('panStart', t),
          void this.messageBroker.publish('setBrushVisibility', !1)
        )
      if ('paintBucket' === this.currentTool && 0 === t.button) {
        const e = { x: t.offsetX, y: t.offsetY },
          n = await this.messageBroker.pull('screenToCanvas', e)
        return (
          this.messageBroker.publish('paintBucketFill', n),
          void this.messageBroker.publish('saveState')
        )
      }
      if ('colorSelect' !== this.currentTool || 0 !== t.button) {
        if (t.altKey && 2 === t.button)
          return (
            (this.isAdjustingBrush = !0),
            void this.messageBroker.publish('brushAdjustmentStart', t)
          )
        var n = ['pen', 'eraser'].includes(this.currentTool)
        ;[0, 2].includes(t.button) &&
          n &&
          this.messageBroker.publish('drawStart', t)
      } else {
        const e = { x: t.offsetX, y: t.offsetY },
          n = await this.messageBroker.pull('screenToCanvas', e)
        this.messageBroker.publish('colorSelectFill', n)
      }
    }
  }
  async handlePointerMove(t) {
    if ((t.preventDefault(), 'touch' == t.pointerType)) return
    const e = { x: t.clientX, y: t.clientY }
    this.messageBroker.publish('cursorPoint', e)
    var n = await this.messageBroker.pull('isKeyPressed', ' ')
    ;(this.messageBroker.publish('updateBrushPreview'),
    4 === t.buttons || (1 === t.buttons && n))
      ? this.messageBroker.publish('panMove', t)
      : ['pen', 'eraser'].includes(this.currentTool) &&
        (!this.isAdjustingBrush ||
        ('pen' !== this.currentTool && 'eraser' !== this.currentTool) ||
        !t.altKey ||
        2 !== t.buttons
          ? (1 != t.buttons && 2 != t.buttons) ||
            this.messageBroker.publish('draw', t)
          : this.messageBroker.publish('brushAdjustment', t))
  }
  handlePointerUp(t) {
    this.messageBroker.publish('panCursor', !1),
      'touch' !== t.pointerType &&
        (this.messageBroker.publish('updateCursor'),
        (this.isAdjustingBrush = !1),
        this.messageBroker.publish('drawEnd', t),
        (this.mouseDownPoint = null))
  }
  handleWheelEvent(t) {
    this.messageBroker.publish('zoom', t)
    const e = { x: t.clientX, y: t.clientY }
    this.messageBroker.publish('cursorPoint', e)
  }
}
class dt {
  static {
    e(this, 'PanAndZoomManager')
  }
  maskEditor
  messageBroker
  DOUBLE_TAP_DELAY = 300
  lastTwoFingerTap = 0
  isTouchZooming = !1
  lastTouchZoomDistance = 0
  lastTouchMidPoint = { x: 0, y: 0 }
  lastTouchPoint = { x: 0, y: 0 }
  zoom_ratio = 1
  interpolatedZoomRatio = 1
  pan_offset = { x: 0, y: 0 }
  mouseDownPoint = null
  initialPan = { x: 0, y: 0 }
  canvasContainer = null
  maskCanvas = null
  rootElement = null
  image = null
  imageRootWidth = 0
  imageRootHeight = 0
  cursorPoint = { x: 0, y: 0 }
  constructor(t) {
    ;(this.maskEditor = t),
      (this.messageBroker = t.getMessageBroker()),
      this.addListeners(),
      this.addPullTopics()
  }
  addListeners() {
    this.messageBroker.subscribe('initZoomPan', async (t) => {
      await this.initializeCanvasPanZoom(t[0], t[1])
    }),
      this.messageBroker.subscribe('panStart', async (t) => {
        this.handlePanStart(t)
      }),
      this.messageBroker.subscribe('panMove', async (t) => {
        this.handlePanMove(t)
      }),
      this.messageBroker.subscribe('zoom', async (t) => {
        this.zoom(t)
      }),
      this.messageBroker.subscribe('cursorPoint', async (t) => {
        this.updateCursorPosition(t)
      }),
      this.messageBroker.subscribe('handleTouchStart', async (t) => {
        this.handleTouchStart(t)
      }),
      this.messageBroker.subscribe('handleTouchMove', async (t) => {
        this.handleTouchMove(t)
      }),
      this.messageBroker.subscribe('handleTouchEnd', async (t) => {
        this.handleTouchEnd(t)
      }),
      this.messageBroker.subscribe('resetZoom', async () => {
        1 !== this.interpolatedZoomRatio && (await this.smoothResetView())
      })
  }
  addPullTopics() {
    this.messageBroker.createPullTopic(
      'cursorPoint',
      async () => this.cursorPoint
    ),
      this.messageBroker.createPullTopic(
        'zoomRatio',
        async () => this.zoom_ratio
      ),
      this.messageBroker.createPullTopic(
        'panOffset',
        async () => this.pan_offset
      )
  }
  handleTouchStart(t) {
    if ((t.preventDefault(), 'stylus' !== t.touches[0].touchType))
      if (
        (this.messageBroker.publish('setBrushVisibility', !1),
        2 === t.touches.length)
      ) {
        const e = new Date().getTime()
        if (e - this.lastTwoFingerTap < this.DOUBLE_TAP_DELAY)
          this.handleDoubleTap(), (this.lastTwoFingerTap = 0)
        else {
          ;(this.lastTwoFingerTap = e),
            (this.isTouchZooming = !0),
            (this.lastTouchZoomDistance = this.getTouchDistance(t.touches))
          const n = this.getTouchMidpoint(t.touches)
          this.lastTouchMidPoint = n
        }
      } else
        1 === t.touches.length &&
          (this.lastTouchPoint = {
            x: t.touches[0].clientX,
            y: t.touches[0].clientY
          })
  }
  async handleTouchMove(t) {
    if ((t.preventDefault(), 'stylus' !== t.touches[0].touchType))
      if (
        ((this.lastTwoFingerTap = 0),
        this.isTouchZooming && 2 === t.touches.length)
      ) {
        const e = this.getTouchDistance(t.touches),
          n = e / this.lastTouchZoomDistance,
          i = this.zoom_ratio
        this.zoom_ratio = Math.max(0.2, Math.min(10, this.zoom_ratio * n))
        const s = this.zoom_ratio,
          r = this.getTouchMidpoint(t.touches)
        if (this.lastTouchMidPoint) {
          const t = r.x - this.lastTouchMidPoint.x,
            e = r.y - this.lastTouchMidPoint.y
          ;(this.pan_offset.x += t), (this.pan_offset.y += e)
        }
        null === this.maskCanvas &&
          (this.maskCanvas = await this.messageBroker.pull('maskCanvas'))
        const a = this.maskCanvas.getBoundingClientRect(),
          o = r.x - a.left,
          l = r.y - a.top,
          c = s / i
        ;(this.pan_offset.x += o - o * c),
          (this.pan_offset.y += l - l * c),
          this.invalidatePanZoom(),
          (this.lastTouchZoomDistance = e),
          (this.lastTouchMidPoint = r)
      } else 1 === t.touches.length && this.handleSingleTouchPan(t.touches[0])
  }
  handleTouchEnd(t) {
    t.preventDefault(),
      (0 === t.touches.length && 'stylus' === t.touches[0].touchType) ||
        ((this.isTouchZooming = !1),
        (this.lastTouchMidPoint = { x: 0, y: 0 }),
        0 === t.touches.length
          ? (this.lastTouchPoint = { x: 0, y: 0 })
          : 1 === t.touches.length &&
            (this.lastTouchPoint = {
              x: t.touches[0].clientX,
              y: t.touches[0].clientY
            }))
  }
  getTouchDistance(t) {
    const e = t[0].clientX - t[1].clientX,
      n = t[0].clientY - t[1].clientY
    return Math.sqrt(e * e + n * n)
  }
  getTouchMidpoint(t) {
    return {
      x: (t[0].clientX + t[1].clientX) / 2,
      y: (t[0].clientY + t[1].clientY) / 2
    }
  }
  async handleSingleTouchPan(t) {
    if (null === this.lastTouchPoint)
      return void (this.lastTouchPoint = { x: t.clientX, y: t.clientY })
    const e = t.clientX - this.lastTouchPoint.x,
      n = t.clientY - this.lastTouchPoint.y
    ;(this.pan_offset.x += e),
      (this.pan_offset.y += n),
      await this.invalidatePanZoom(),
      (this.lastTouchPoint = { x: t.clientX, y: t.clientY })
  }
  updateCursorPosition(t) {
    var e = t.x - this.pan_offset.x,
      n = t.y - this.pan_offset.y
    this.cursorPoint = { x: e, y: n }
  }
  handleDoubleTap() {
    this.messageBroker.publish('undo')
  }
  async zoom(t) {
    const e = { x: t.clientX, y: t.clientY },
      n = this.zoom_ratio,
      i = t.deltaY < 0 ? 1.1 : 0.9
    this.zoom_ratio = Math.max(0.2, Math.min(10, this.zoom_ratio * i))
    const s = this.zoom_ratio,
      r = await this.messageBroker.pull('maskCanvas'),
      a = r.getBoundingClientRect(),
      o = e.x - a.left,
      l = e.y - a.top
    console.log(n, s)
    const c = s / n
    ;(this.pan_offset.x += o - o * c),
      (this.pan_offset.y += l - l * c),
      await this.invalidatePanZoom()
    const h = r.clientWidth / this.imageRootWidth
    ;(this.interpolatedZoomRatio = h),
      this.messageBroker.publish('setZoomText', `${Math.round(100 * h)}%`),
      this.updateCursorPosition(e),
      requestAnimationFrame(() => {
        this.messageBroker.publish('updateBrushPreview')
      })
  }
  async smoothResetView(t = 500) {
    const n = this.zoom_ratio,
      i = { ...this.pan_offset },
      s = this.rootElement.clientWidth - 220 - 64,
      r = this.rootElement.clientHeight - 44,
      a = s / this.image.width,
      o = r / this.image.height,
      l = Math.min(a, o),
      c = this.image.width / this.image.height
    let h = 0,
      u = 0
    const d = { x: 64, y: 44 }
    o > a
      ? ((h = s), (u = h / c), (d.y = (r - u) / 2 + 44))
      : ((u = r), (h = u * c), (d.x = (s - h) / 2 + 64))
    const p = performance.now(),
      m = e((e) => {
        const s = e - p,
          r = Math.min(s / t, 1),
          a = 1 - Math.pow(1 - r, 3),
          o = n + (l - n) * a
        ;(this.zoom_ratio = o),
          (this.pan_offset.x = i.x + (d.x - i.x) * a),
          (this.pan_offset.y = i.y + (d.y - i.y) * a),
          this.invalidatePanZoom()
        const c = n + (1 - n) * a
        this.messageBroker.publish('setZoomText', `${Math.round(100 * c)}%`),
          r < 1 && requestAnimationFrame(m)
      }, 'animate')
    requestAnimationFrame(m), (this.interpolatedZoomRatio = 1)
  }
  async initializeCanvasPanZoom(t, e) {
    this.rootElement = e
    let n = e.clientWidth - 220 - 64,
      i = e.clientHeight - 44,
      s = n / t.width,
      r = i / t.height,
      a = t.width / t.height,
      o = 0,
      l = 0,
      c = { x: 64, y: 44 }
    r > s
      ? ((o = n), (l = o / a), (c.y = (i - l) / 2 + 44))
      : ((l = i), (o = l * a), (c.x = (n - o) / 2 + 64)),
      null === this.image && (this.image = t),
      (this.imageRootWidth = o),
      (this.imageRootHeight = l),
      (this.zoom_ratio = Math.min(s, r)),
      (this.pan_offset = c),
      await this.invalidatePanZoom()
  }
  async invalidatePanZoom() {
    if (
      !(
        this.image?.width &&
        this.image?.height &&
        this.pan_offset &&
        this.zoom_ratio
      )
    )
      return void console.warn('Missing required properties for pan/zoom')
    const t = this.image.width * this.zoom_ratio,
      e = this.image.height * this.zoom_ratio
    ;(this.canvasContainer ??=
      await this.messageBroker?.pull('getCanvasContainer')),
      this.canvasContainer &&
        Object.assign(this.canvasContainer.style, {
          width: `${t}px`,
          height: `${e}px`,
          left: `${this.pan_offset.x}px`,
          top: `${this.pan_offset.y}px`
        })
  }
  handlePanStart(t) {
    this.messageBroker.pull('screenToCanvas', { x: t.offsetX, y: t.offsetY })
    ;(this.mouseDownPoint = { x: t.clientX, y: t.clientY }),
      this.messageBroker.publish('panCursor', !0),
      (this.initialPan = this.pan_offset)
  }
  handlePanMove(t) {
    if (null === this.mouseDownPoint) throw new Error('mouseDownPoint is null')
    let e = this.mouseDownPoint.x - t.clientX,
      n = this.mouseDownPoint.y - t.clientY,
      i = this.initialPan.x - e,
      s = this.initialPan.y - n
    ;(this.pan_offset = { x: i, y: s }), this.invalidatePanZoom()
  }
}
class pt {
  static {
    e(this, 'MessageBroker')
  }
  pushTopics = {}
  pullTopics = {}
  constructor() {
    this.registerListeners()
  }
  registerListeners() {
    this.createPushTopic('panStart'),
      this.createPushTopic('paintBucketFill'),
      this.createPushTopic('saveState'),
      this.createPushTopic('brushAdjustmentStart'),
      this.createPushTopic('drawStart'),
      this.createPushTopic('panMove'),
      this.createPushTopic('updateBrushPreview'),
      this.createPushTopic('brushAdjustment'),
      this.createPushTopic('draw'),
      this.createPushTopic('paintBucketCursor'),
      this.createPushTopic('panCursor'),
      this.createPushTopic('drawEnd'),
      this.createPushTopic('zoom'),
      this.createPushTopic('undo'),
      this.createPushTopic('redo'),
      this.createPushTopic('cursorPoint'),
      this.createPushTopic('panOffset'),
      this.createPushTopic('zoomRatio'),
      this.createPushTopic('getMaskCanvas'),
      this.createPushTopic('getCanvasContainer'),
      this.createPushTopic('screenToCanvas'),
      this.createPushTopic('isKeyPressed'),
      this.createPushTopic('isCombinationPressed'),
      this.createPushTopic('setPaintBucketTolerance'),
      this.createPushTopic('setBrushSize'),
      this.createPushTopic('setBrushHardness'),
      this.createPushTopic('setBrushOpacity'),
      this.createPushTopic('setBrushShape'),
      this.createPushTopic('initZoomPan'),
      this.createPushTopic('setTool'),
      this.createPushTopic('pointerDown'),
      this.createPushTopic('pointerMove'),
      this.createPushTopic('pointerUp'),
      this.createPushTopic('wheel'),
      this.createPushTopic('initPaintBucketTool'),
      this.createPushTopic('setBrushVisibility'),
      this.createPushTopic('setBrushPreviewGradientVisibility'),
      this.createPushTopic('handleTouchStart'),
      this.createPushTopic('handleTouchMove'),
      this.createPushTopic('handleTouchEnd'),
      this.createPushTopic('colorSelectFill'),
      this.createPushTopic('setColorSelectTolerance'),
      this.createPushTopic('setLivePreview'),
      this.createPushTopic('updateCursor'),
      this.createPushTopic('setColorComparisonMethod'),
      this.createPushTopic('clearLastPoint'),
      this.createPushTopic('setWholeImage'),
      this.createPushTopic('setMaskBoundary'),
      this.createPushTopic('setMaskTolerance'),
      this.createPushTopic('setBrushSmoothingPrecision'),
      this.createPushTopic('setZoomText'),
      this.createPushTopic('resetZoom'),
      this.createPushTopic('invert')
  }
  createPushTopic(t) {
    if (this.topicExists(this.pushTopics, t))
      throw new Error('Topic already exists')
    this.pushTopics[t] = []
  }
  subscribe(t, e) {
    if (!this.topicExists(this.pushTopics, t))
      throw new Error(`Topic "${t}" does not exist!`)
    this.pushTopics[t].push(e)
  }
  unsubscribe(t, e) {
    if (!this.topicExists(this.pushTopics, t))
      throw new Error('Topic does not exist')
    const n = this.pushTopics[t].indexOf(e)
    n > -1 && this.pushTopics[t].splice(n, 1)
  }
  publish(t, ...e) {
    if (!this.topicExists(this.pushTopics, t))
      throw new Error(`Topic "${t}" does not exist!`)
    this.pushTopics[t].forEach((t) => {
      t(...e)
    })
  }
  createPullTopic(t, e) {
    if (this.topicExists(this.pullTopics, t))
      throw new Error('Topic already exists')
    this.pullTopics[t] = e
  }
  async pull(t, e) {
    if (!this.topicExists(this.pullTopics, t))
      throw new Error('Topic does not exist')
    const n = this.pullTopics[t]
    try {
      return await n(e)
    } catch (i) {
      throw (console.error(`Error pulling data from topic "${t}":`, i), i)
    }
  }
  topicExists(t, e) {
    return t.hasOwnProperty(e)
  }
}
class mt {
  static {
    e(this, 'KeyboardManager')
  }
  keysDown = []
  maskEditor
  messageBroker
  constructor(t) {
    ;(this.maskEditor = t),
      (this.messageBroker = t.getMessageBroker()),
      this.addPullTopics()
  }
  addPullTopics() {
    this.messageBroker.createPullTopic('isKeyPressed', (t) =>
      Promise.resolve(this.isKeyDown(t))
    )
  }
  addListeners() {
    document.addEventListener('keydown', (t) => this.handleKeyDown(t)),
      document.addEventListener('keyup', (t) => this.handleKeyUp(t)),
      window.addEventListener('blur', () => this.clearKeys())
  }
  removeListeners() {
    document.removeEventListener('keydown', (t) => this.handleKeyDown(t)),
      document.removeEventListener('keyup', (t) => this.handleKeyUp(t))
  }
  clearKeys() {
    this.keysDown = []
  }
  handleKeyDown(t) {
    this.keysDown.includes(t.key) || this.keysDown.push(t.key)
  }
  handleKeyUp(t) {
    this.keysDown = this.keysDown.filter((e) => e !== t.key)
  }
  isKeyDown(t) {
    return this.keysDown.includes(t)
  }
  undoCombinationPressed() {
    const t = this.keysDown.map((t) => t.toLowerCase()),
      e = ['ctrl', 'z'].every((e) => t.includes(e))
    return e && this.messageBroker.publish('undo'), e
  }
  redoCombinationPressed() {
    const t = this.keysDown.map((t) => t.toLowerCase()),
      e = ['ctrl', 'shift', 'z'].every((e) => t.includes(e))
    return e && this.messageBroker.publish('redo'), e
  }
}
r.registerExtension({
  name: 'Comfy.MaskEditor',
  settings: [
    {
      id: 'Comfy.MaskEditor.UseNewEditor',
      category: ['Mask Editor', 'NewEditor'],
      name: 'Use new mask editor',
      tooltip: 'Switch to the new mask editor interface',
      type: 'boolean',
      defaultValue: !0,
      experimental: !0
    },
    {
      id: 'Comfy.MaskEditor.BrushAdjustmentSpeed',
      category: ['Mask Editor', 'BrushAdjustment', 'Sensitivity'],
      name: 'Brush adjustment speed multiplier',
      tooltip:
        'Controls how quickly the brush size and hardness change when adjusting. Higher values mean faster changes.',
      experimental: !0,
      type: 'slider',
      attrs: { min: 0.1, max: 2, step: 0.1 },
      defaultValue: 1,
      versionAdded: '1.0.0'
    },
    {
      id: 'Comfy.MaskEditor.UseDominantAxis',
      category: ['Mask Editor', 'BrushAdjustment', 'UseDominantAxis'],
      name: 'Lock brush adjustment to dominant axis',
      tooltip:
        'When enabled, brush adjustments will only affect size OR hardness based on which direction you move more',
      type: 'boolean',
      defaultValue: !0,
      experimental: !0
    }
  ],
  init(t) {
    function n() {
      if (t.extensionManager.setting.get('Comfy.MaskEditor.UseNewEditor')) {
        const t = rt.getInstance()
        t?.isOpened && !t.isOpened() && t.show()
      } else {
        const t = nt.getInstance()
        t?.isOpened && !t.isOpened() && t.show()
      }
    }
    e(n, 'openMaskEditor'), (s.open_maskeditor = n)
    const i = e(
      () => !!(s.clipspace && s.clipspace.imgs && s.clipspace.imgs.length > 0),
      'context_predicate'
    )
    A.registerButton('MaskEditor', i, n)
  }
})
const ft = 'comfy.templates.json'
class gt extends n {
  static {
    e(this, 'ManageTemplates')
  }
  templates
  draggedEl
  saveVisualCue
  emptyImg
  importInput
  constructor() {
    super(),
      this.load().then((t) => {
        this.templates = t
      }),
      this.element.classList.add('comfy-manage-templates'),
      (this.draggedEl = null),
      (this.saveVisualCue = null),
      (this.emptyImg = new Image()),
      (this.emptyImg.src =
        'data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs='),
      (this.importInput = i('input', {
        type: 'file',
        accept: '.json',
        multiple: !0,
        style: { display: 'none' },
        parent: document.body,
        onchange: e(() => this.importAll(), 'onchange')
      }))
  }
  createButtons() {
    const t = super.createButtons()
    return (
      (t[0].textContent = 'Close'),
      (t[0].onclick = (t) => {
        clearTimeout(this.saveVisualCue), this.close()
      }),
      t.unshift(
        i('button', {
          type: 'button',
          textContent: 'Export',
          onclick: e(() => this.exportAll(), 'onclick')
        })
      ),
      t.unshift(
        i('button', {
          type: 'button',
          textContent: 'Import',
          onclick: e(() => {
            this.importInput.click()
          }, 'onclick')
        })
      ),
      t
    )
  }
  async load() {
    let t = []
    const e = await p.getUserData(ft)
    if (200 === e.status)
      try {
        t = await e.json()
      } catch (n) {}
    else 404 !== e.status && console.error(e.status + ' ' + e.statusText)
    return t ?? []
  }
  async store() {
    const t = JSON.stringify(this.templates, void 0, 4)
    try {
      await p.storeUserData(ft, t, { stringify: !1 })
    } catch (e) {
      console.error(e), c().addAlert(e.message)
    }
  }
  async importAll() {
    for (const t of this.importInput.files)
      if ('application/json' === t.type || t.name.endsWith('.json')) {
        const e = new FileReader()
        ;(e.onload = async () => {
          const t = JSON.parse(e.result)
          if (t?.templates) {
            for (const e of t.templates)
              e?.name && e?.data && this.templates.push(e)
            await this.store()
          }
        }),
          await e.readAsText(t)
      }
    ;(this.importInput.value = null), this.close()
  }
  exportAll() {
    if (0 == this.templates.length)
      return void c().addAlert('No templates to export.')
    const t = JSON.stringify({ templates: this.templates }, null, 2),
      e = new Blob([t], { type: 'application/json' }),
      n = URL.createObjectURL(e),
      s = i('a', {
        href: n,
        download: 'node_templates.json',
        style: { display: 'none' },
        parent: document.body
      })
    s.click(),
      setTimeout(function () {
        s.remove(), window.URL.revokeObjectURL(n)
      }, 0)
  }
  show() {
    super.show(
      i(
        'div',
        {},
        this.templates.flatMap((t, n) => {
          let s
          return [
            i(
              'div',
              {
                dataset: { id: n.toString() },
                className: 'templateManagerRow',
                style: {
                  display: 'grid',
                  gridTemplateColumns: '1fr auto',
                  border: '1px dashed transparent',
                  gap: '5px',
                  backgroundColor: 'var(--comfy-menu-bg)'
                },
                ondragstart: e((t) => {
                  ;(this.draggedEl = t.currentTarget),
                    (t.currentTarget.style.opacity = '0.6'),
                    (t.currentTarget.style.border = '1px dashed yellow'),
                    (t.dataTransfer.effectAllowed = 'move'),
                    t.dataTransfer.setDragImage(this.emptyImg, 0, 0)
                }, 'ondragstart'),
                ondragend: e((t) => {
                  ;(t.target.style.opacity = '1'),
                    (t.currentTarget.style.border = '1px dashed transparent'),
                    t.currentTarget.removeAttribute('draggable'),
                    this.element
                      .querySelectorAll('.templateManagerRow')
                      .forEach((t, e) => {
                        var n = Number.parseInt(t.dataset.id)
                        t == this.draggedEl &&
                          n != e &&
                          this.templates.splice(
                            e,
                            0,
                            this.templates.splice(n, 1)[0]
                          ),
                          (t.dataset.id = e.toString())
                      }),
                    this.store()
                }, 'ondragend'),
                ondragover: e((t) => {
                  if ((t.preventDefault(), t.currentTarget == this.draggedEl))
                    return
                  let e = t.currentTarget.getBoundingClientRect()
                  t.clientY > e.top + e.height / 2
                    ? t.currentTarget.parentNode.insertBefore(
                        this.draggedEl,
                        t.currentTarget.nextSibling
                      )
                    : t.currentTarget.parentNode.insertBefore(
                        this.draggedEl,
                        t.currentTarget
                      )
                }, 'ondragover')
              },
              [
                i(
                  'label',
                  {
                    textContent: 'Name: ',
                    style: { cursor: 'grab' },
                    onmousedown: e((t) => {
                      'label' == t.target.localName &&
                        (t.currentTarget.parentNode.draggable = 'true')
                    }, 'onmousedown')
                  },
                  [
                    i('input', {
                      value: t.name,
                      dataset: { name: t.name },
                      style: {
                        transitionProperty: 'background-color',
                        transitionDuration: '0s'
                      },
                      onchange: e((t) => {
                        clearTimeout(this.saveVisualCue)
                        var e = t.target,
                          n = e.parentNode.parentNode
                        ;(this.templates[n.dataset.id].name =
                          e.value.trim() || 'untitled'),
                          this.store(),
                          (e.style.backgroundColor = 'rgb(40, 95, 40)'),
                          (e.style.transitionDuration = '0s'),
                          (this.saveVisualCue = setTimeout(function () {
                            ;(e.style.transitionDuration = '.7s'),
                              (e.style.backgroundColor =
                                'var(--comfy-input-bg)')
                          }, 15))
                      }, 'onchange'),
                      onkeypress: e((t) => {
                        var e = t.target
                        clearTimeout(this.saveVisualCue),
                          (e.style.transitionDuration = '0s'),
                          (e.style.backgroundColor = 'var(--comfy-input-bg)')
                      }, 'onkeypress'),
                      $: e((t) => (s = t), '$')
                    })
                  ]
                ),
                i('div', {}, [
                  i('button', {
                    textContent: 'Export',
                    style: { fontSize: '12px', fontWeight: 'normal' },
                    onclick: e((e) => {
                      const n = JSON.stringify({ templates: [t] }, null, 2),
                        r = new Blob([n], { type: 'application/json' }),
                        a = URL.createObjectURL(r),
                        o = i('a', {
                          href: a,
                          download: (s.value || t.name) + '.json',
                          style: { display: 'none' },
                          parent: document.body
                        })
                      o.click(),
                        setTimeout(function () {
                          o.remove(), window.URL.revokeObjectURL(a)
                        }, 0)
                    }, 'onclick')
                  }),
                  i('button', {
                    textContent: 'Delete',
                    style: {
                      fontSize: '12px',
                      color: 'red',
                      fontWeight: 'normal'
                    },
                    onclick: e((t) => {
                      const e = t.target.parentNode.parentNode
                      e.parentNode.removeChild(e),
                        this.templates.splice(1 * e.dataset.id, 1),
                        this.store()
                      var n = this
                      setTimeout(function () {
                        n.element
                          .querySelectorAll('.templateManagerRow')
                          .forEach((t, e) => {
                            t.dataset.id = e.toString()
                          })
                      }, 0)
                    }, 'onclick')
                  })
                ])
              ]
            )
          ]
        })
      )
    )
  }
}
let vt
r.registerExtension({
  name: 'Comfy.NodeTemplates',
  setup() {
    const t = new gt(),
      n = e(async (t) => {
        const e = localStorage.getItem('litegrapheditor_clipboard')
        await t(), localStorage.setItem('litegrapheditor_clipboard', e)
      }, 'clipboardAction'),
      i = o.prototype.getCanvasMenuOptions
    o.prototype.getCanvasMenuOptions = function () {
      const s = i.apply(this, arguments)
      s.push(null),
        s.push({
          content: 'Save Selected as Template',
          disabled: !Object.keys(r.canvas.selected_nodes || {}).length,
          callback: e(() => {
            const e = prompt('Enter name')
            e?.trim() &&
              n(() => {
                r.canvas.copyToClipboard()
                let n = localStorage.getItem('litegrapheditor_clipboard')
                n = JSON.parse(n)
                const i = Object.keys(r.canvas.selected_nodes)
                for (let t = 0; t < i.length; t++) {
                  const e = r.graph.getNodeById(i[t]),
                    s = e?.constructor.nodeData
                  let a = V.getGroupData(e)
                  a &&
                    ((a = a.nodeData),
                    n.groupNodes || (n.groupNodes = {}),
                    (n.groupNodes[s.name] = a),
                    (n.nodes[t].type = s.name))
                }
                t.templates.push({ name: e, data: JSON.stringify(n) }),
                  t.store()
              })
          }, 'callback')
        })
      const a = t.templates.map((t) => ({
        content: t.name,
        callback: e(() => {
          n(async () => {
            const e = JSON.parse(t.data)
            await z.registerFromWorkflow(e.groupNodes, {}),
              e.reroutes
                ? (localStorage.setItem('litegrapheditor_clipboard', t.data),
                  r.canvas.pasteFromClipboard())
                : d(t.data, r.canvas)
          })
        }, 'callback')
      }))
      return (
        a.push(null, {
          content: 'Manage',
          callback: e(() => t.show(), 'callback')
        }),
        s.push({ content: 'Node Templates', submenu: { options: a } }),
        s
      )
    }
  }
}),
  r.registerExtension({
    name: 'Comfy.NoteNode',
    registerCustomNodes() {
      class t extends _ {
        static {
          e(this, 'NoteNode')
        }
        static category
        color = o.node_colors.yellow.color
        bgcolor = o.node_colors.yellow.bgcolor
        groupcolor = o.node_colors.yellow.groupcolor
        isVirtualNode
        collapsable
        title_mode
        constructor(t) {
          super(t),
            this.properties || (this.properties = { text: '' }),
            x.STRING(
              this,
              '',
              ['', { default: this.properties.text, multiline: !0 }],
              r
            ),
            (this.serialize_widgets = !0),
            (this.isVirtualNode = !0)
        }
      }
      a.registerNodeType(
        'Note',
        Object.assign(t, {
          title_mode: a.NORMAL_TITLE,
          title: 'Note',
          collapsable: !0
        })
      ),
        (t.category = 'utils')
    }
  }),
  r.registerExtension({
    name: 'Comfy.RerouteNode',
    registerCustomNodes(t) {
      class n extends _ {
        static {
          e(this, 'RerouteNode')
        }
        static category
        static defaultVisibility = !1
        constructor(e) {
          super(e),
            this.properties || (this.properties = {}),
            (this.properties.showOutputText = n.defaultVisibility),
            (this.properties.horizontal = !1),
            this.addInput('', '*'),
            this.addOutput(this.properties.showOutputText ? '*' : '', '*'),
            (this.onAfterGraphConfigured = function () {
              requestAnimationFrame(() => {
                this.onConnectionsChange(a.INPUT, null, !0, null)
              })
            }),
            (this.onConnectionsChange = (e, n, i, s) => {
              if ((this.applyOrientation(), i && e === a.OUTPUT)) {
                if (
                  new Set(
                    this.outputs[0].links
                      .map((e) => t.graph.links[e].type)
                      .filter((t) => '*' !== t)
                  ).size > 1
                ) {
                  const e = []
                  for (let n = 0; n < this.outputs[0].links.length - 1; n++) {
                    const i = this.outputs[0].links[n],
                      s = t.graph.links[i]
                    e.push(s)
                  }
                  for (const n of e) {
                    t.graph
                      .getNodeById(n.target_id)
                      .disconnectInput(n.target_slot)
                  }
                }
              }
              let r = this,
                l = [],
                c = null,
                h = null
              for (; r; ) {
                l.unshift(r)
                const e = r.inputs[0].link
                if (null === e) {
                  r = null
                  break
                }
                {
                  const n = t.graph.links[e]
                  if (!n) return
                  const i = t.graph.getNodeById(n.origin_id)
                  if ('Reroute' !== i.constructor.type) {
                    ;(h = r), (c = i.outputs[n.origin_slot]?.type ?? null)
                    break
                  }
                  i === this
                    ? (r.disconnectInput(n.target_slot), (r = null))
                    : (r = i)
                }
              }
              const u = [this]
              let d = null
              for (; u.length; ) {
                r = u.pop()
                const e = (r.outputs ? r.outputs[0].links : []) || []
                if (e.length)
                  for (const n of e) {
                    const e = t.graph.links[n]
                    if (!e) continue
                    const i = t.graph.getNodeById(e.target_id)
                    if ('Reroute' === i.constructor.type) u.push(i), l.push(i)
                    else {
                      const t =
                        i.inputs &&
                        i.inputs[e?.target_slot] &&
                        i.inputs[e.target_slot].type
                          ? i.inputs[e.target_slot].type
                          : null
                      c && !a.isValidConnection(c, t)
                        ? i.disconnectInput(e.target_slot)
                        : (d = t)
                    }
                  }
              }
              const p = c || d || '*',
                m = o.link_type_colors[p]
              let f, g, v
              for (const a of l) {
                ;(a.outputs[0].type = c || '*'),
                  (a.__outputType = p),
                  (a.outputs[0].name = a.properties.showOutputText ? p : ''),
                  (a.size = a.computeSize()),
                  a.applyOrientation()
                for (const e of a.outputs[0].links || []) {
                  const n = t.graph.links[e]
                  if (n) {
                    if (((n.color = m), t.configuringGraph)) continue
                    const e = t.graph.getNodeById(n.target_id),
                      i = e.inputs?.[n.target_slot]
                    if (i?.widget) {
                      const t = T(i)
                      f || ((f = t[1] ?? {}), (v = t[0])),
                        g ||
                          (g = e.widgets?.find((t) => t.name === i.widget.name))
                      const n = S(i, [t[0], f])
                      n.customConfig && (f = n.customConfig)
                    }
                  }
                }
              }
              for (const t of l)
                f && d
                  ? ((t.inputs[0].widget = { name: 'value' }),
                    E(t.inputs[0], [v ?? p, f], g))
                  : E(t.inputs[0], null)
              if (h) {
                const e = t.graph.links[h.inputs[0].link]
                e && (e.color = m)
              }
            }),
            (this.clone = function () {
              const t = n.prototype.clone.apply(this)
              return (
                t.removeOutput(0),
                t.addOutput(this.properties.showOutputText ? '*' : '', '*'),
                (t.size = t.computeSize()),
                t
              )
            }),
            (this.isVirtualNode = !0)
        }
        getExtraMenuOptions(i, s) {
          return (
            s.unshift(
              {
                content:
                  (this.properties.showOutputText ? 'Hide' : 'Show') + ' Type',
                callback: e(() => {
                  ;(this.properties.showOutputText =
                    !this.properties.showOutputText),
                    this.properties.showOutputText
                      ? (this.outputs[0].name =
                          this.__outputType || this.outputs[0].type)
                      : (this.outputs[0].name = ''),
                    (this.size = this.computeSize()),
                    this.applyOrientation(),
                    t.graph.setDirtyCanvas(!0, !0)
                }, 'callback')
              },
              {
                content:
                  (n.defaultVisibility ? 'Hide' : 'Show') + ' Type By Default',
                callback: e(() => {
                  n.setDefaultTextVisibility(!n.defaultVisibility)
                }, 'callback')
              },
              {
                content:
                  'Set ' +
                  (this.properties.horizontal ? 'Horizontal' : 'Vertical'),
                callback: e(() => {
                  ;(this.properties.horizontal = !this.properties.horizontal),
                    this.applyOrientation()
                }, 'callback')
              }
            ),
            []
          )
        }
        applyOrientation() {
          ;(this.horizontal = this.properties.horizontal),
            this.horizontal
              ? (this.inputs[0].pos = [this.size[0] / 2, 0])
              : delete this.inputs[0].pos,
            t.graph.setDirtyCanvas(!0, !0)
        }
        computeSize() {
          return [
            this.properties.showOutputText &&
            this.outputs &&
            this.outputs.length
              ? Math.max(
                  75,
                  a.NODE_TEXT_SIZE * this.outputs[0].name.length * 0.6 + 40
                )
              : 75,
            26
          ]
        }
        static setDefaultTextVisibility(t) {
          ;(n.defaultVisibility = t),
            t
              ? (localStorage['Comfy.RerouteNode.DefaultVisibility'] = 'true')
              : delete localStorage['Comfy.RerouteNode.DefaultVisibility']
        }
      }
      n.setDefaultTextVisibility(
        !!localStorage['Comfy.RerouteNode.DefaultVisibility']
      ),
        a.registerNodeType(
          'Reroute',
          Object.assign(n, {
            title_mode: a.NO_TITLE,
            title: 'Reroute',
            collapsable: !1
          })
        ),
        (n.category = 'utils')
    }
  }),
  r.registerExtension({
    name: 'Comfy.SaveImageExtraOutput',
    async beforeRegisterNodeDef(t, e, n) {
      if ('SaveImage' === e.name || 'SaveAnimatedWEBP' === e.name) {
        const e = t.prototype.onNodeCreated
        t.prototype.onNodeCreated = function () {
          const t = e ? e.apply(this, arguments) : void 0,
            i = this.widgets.find((t) => 'filename_prefix' === t.name)
          return (i.serializeValue = () => b(n, i.value)), t
        }
      } else {
        const e = t.prototype.onNodeCreated
        t.prototype.onNodeCreated = function () {
          const t = e ? e.apply(this, arguments) : void 0
          return (
            (this.properties && 'Node name for S&R' in this.properties) ||
              this.addProperty(
                'Node name for S&R',
                this.constructor.type,
                'string'
              ),
            t
          )
        }
      }
    }
  })
let yt = 0
r.registerExtension({
  name: 'Comfy.SimpleTouchSupport',
  setup() {
    let t, n, i, s
    function o(t) {
      return Math.hypot(
        t.touches[0].clientX - t.touches[1].clientX,
        t.touches[0].clientY - t.touches[1].clientY
      )
    }
    function l(t) {
      return {
        clientX: (t.touches[0].clientX + t.touches[1].clientX) / 2,
        clientY: (t.touches[0].clientY + t.touches[1].clientY) / 2
      }
    }
    e(o, 'getMultiTouchPos'),
      e(l, 'getMultiTouchCenter'),
      r.canvasEl.parentElement.addEventListener(
        'touchstart',
        (e) => {
          yt++,
            (i = null),
            (s = null),
            1 === e.touches?.length
              ? ((n = new Date()), (i = e.touches[0]))
              : ((n = null),
                2 === e.touches?.length &&
                  ((s = r.canvas.ds.scale),
                  (i = l(e)),
                  (t = o(e)),
                  (r.canvas.pointer.isDown = !1)))
        },
        !0
      ),
      r.canvasEl.parentElement.addEventListener('touchend', (t) => {
        yt--,
          1 !== t.touches?.length && (vt = !1),
          n &&
            !t.touches?.length &&
            (new Date().getTime() - n > 600 &&
              t.target === r.canvasEl &&
              (r.canvasEl.dispatchEvent(
                new PointerEvent('pointerdown', {
                  button: 2,
                  clientX: t.changedTouches[0].clientX,
                  clientY: t.changedTouches[0].clientY
                })
              ),
              t.preventDefault()),
            (n = null))
      }),
      r.canvasEl.parentElement.addEventListener(
        'touchmove',
        (c) => {
          if (
            ((n = null),
            2 === c.touches?.length && i && !c.ctrlKey && !c.shiftKey)
          ) {
            c.preventDefault(),
              (r.canvas.pointer.isDown = !1),
              (vt = !0),
              a.closeAllContextMenus(window),
              r.canvas.search_box?.close()
            const n = o(c),
              d = l(c)
            let p = (s * n) / t
            const m = (d.clientX - i.clientX) / p,
              f = (d.clientY - i.clientY) / p
            p < r.canvas.ds.min_scale
              ? (p = r.canvas.ds.min_scale)
              : p > r.canvas.ds.max_scale && (p = r.canvas.ds.max_scale)
            const g = r.canvas.ds.scale
            ;(r.canvas.ds.scale = p),
              Math.abs(r.canvas.ds.scale - 1) < 0.01 && (r.canvas.ds.scale = 1)
            const v = r.canvas.ds.scale,
              y = e(
                (t) => [
                  d.clientX / t - r.canvas.ds.offset[0],
                  d.clientY / t - r.canvas.ds.offset[1]
                ],
                'convertScaleToOffset'
              )
            var h = y(g),
              u = y(v)
            ;(r.canvas.ds.offset[0] += m + u[0] - h[0]),
              (r.canvas.ds.offset[1] += f + u[1] - h[1]),
              (i.clientX = d.clientX),
              (i.clientY = d.clientY),
              r.canvas.setDirty(!0, !0)
          }
        },
        !0
      )
  }
})
const _t = o.prototype.processMouseDown
o.prototype.processMouseDown = function (t) {
  if (!vt && !yt)
    return (r.canvas.pointer.isDown = !1), _t.apply(this, arguments)
}
const xt = o.prototype.processMouseMove
;(o.prototype.processMouseMove = function (t) {
  if (!(vt || yt > 1)) return xt.apply(this, arguments)
}),
  r.registerExtension({
    name: 'Comfy.SlotDefaults',
    suggestionsNumber: null,
    init() {
      ;(a.search_filter_enabled = !0),
        (a.middle_click_slot_add_default_node = !0),
        (this.suggestionsNumber = r.ui.settings.addSetting({
          id: 'Comfy.NodeSuggestions.number',
          category: ['Comfy', 'Node Search Box', 'NodeSuggestions'],
          name: 'Number of nodes suggestions',
          tooltip: 'Only for litegraph searchbox/context menu',
          type: 'slider',
          attrs: { min: 1, max: 100, step: 1 },
          defaultValue: 5,
          onChange: e((t, e) => {
            this.setDefaults(t)
          }, 'onChange')
        }))
    },
    slot_types_default_out: {},
    slot_types_default_in: {},
    async beforeRegisterNodeDef(t, e, n) {
      var i = e.name
      const s = e.input?.required
      for (const u in s) {
        var r = s[u]
        if ('string' != typeof r[0]) continue
        var o = r[0]
        if (o in x) {
          var l = r[1]
          if (!l?.forceInput) continue
        }
        if (
          (o in this.slot_types_default_out ||
            (this.slot_types_default_out[o] = ['Reroute']),
          this.slot_types_default_out[o].includes(i))
        )
          continue
        this.slot_types_default_out[o].push(i)
        const e = o.toLocaleLowerCase()
        e in a.registered_slot_in_types ||
          (a.registered_slot_in_types[e] = { nodes: [] }),
          a.registered_slot_in_types[e].nodes.push(t.comfyClass)
      }
      var c = e.output ?? []
      for (const u of c) {
        const e = u
        e in this.slot_types_default_in ||
          (this.slot_types_default_in[e] = ['Reroute']),
          this.slot_types_default_in[e].push(i),
          e in a.registered_slot_out_types ||
            (a.registered_slot_out_types[e] = { nodes: [] }),
          a.registered_slot_out_types[e].nodes.push(t.comfyClass),
          a.slot_types_out.includes(e) || a.slot_types_out.push(e)
      }
      var h = this.suggestionsNumber.value
      this.setDefaults(h)
    },
    setDefaults(t) {
      ;(a.slot_types_default_out = {}), (a.slot_types_default_in = {})
      for (const e in this.slot_types_default_out)
        a.slot_types_default_out[e] = this.slot_types_default_out[e].slice(0, t)
      for (const e in this.slot_types_default_in)
        a.slot_types_default_in[e] = this.slot_types_default_in[e].slice(0, t)
    }
  }),
  r.registerExtension({
    name: 'Comfy.UploadImage',
    beforeRegisterNodeDef(t, e) {
      !0 === e?.input?.required?.image?.[1]?.image_upload &&
        (e.input.required.upload = ['IMAGEUPLOAD'])
    }
  })
const bt = Symbol()
function wt(t) {
  const e = t.lastIndexOf('/')
  return -1 === e ? ['', t] : [t.substring(0, e), t.substring(e + 1)]
}
function Mt(t, e, n = 'input') {
  return `/view?${['filename=' + encodeURIComponent(e), 'type=' + n, 'subfolder=' + t, r.getRandParam().substring(1)].join('&')}`
}
async function St(t, e, n, i, s = !1) {
  try {
    const r = new FormData()
    r.append('image', n), s && r.append('subfolder', 'pasted')
    const a = await p.fetchApi('/upload/image', { method: 'POST', body: r })
    if (200 === a.status) {
      const n = await a.json()
      let s = n.name
      n.subfolder && (s = n.subfolder + '/' + s),
        t.options.values.includes(s) || t.options.values.push(s),
        i && ((e.element.src = p.apiURL(Mt(...wt(s)))), (t.value = s))
    } else c().addAlert(a.status + ' - ' + a.statusText)
  } catch (r) {
    c().addAlert(r)
  }
}
r.registerExtension({
  name: 'Comfy.WebcamCapture',
  getCustomWidgets: (t) => ({
    WEBCAM(t, n) {
      let i
      t[bt] = new Promise((t) => (i = t))
      const s = document.createElement('div')
      ;(s.style.background = 'rgba(0,0,0,0.25)'), (s.style.textAlign = 'center')
      const r = document.createElement('video')
      r.style.height = r.style.width = '100%'
      return (
        e(async () => {
          try {
            const t = await navigator.mediaDevices.getUserMedia({
              video: !0,
              audio: !1
            })
            s.replaceChildren(r),
              setTimeout(() => i(r), 500),
              r.addEventListener('loadedmetadata', () => i(r), !1),
              (r.srcObject = t),
              r.play()
          } catch (t) {
            const e = document.createElement('div')
            ;(e.style.color = 'red'),
              (e.style.overflow = 'auto'),
              (e.style.maxHeight = '100%'),
              (e.style.whiteSpace = 'pre-wrap'),
              window.isSecureContext
                ? (e.textContent =
                    'Unable to load webcam, please ensure access is granted:\n' +
                    t.message)
                : (e.textContent =
                    'Unable to load webcam. A secure context is required, if you are not accessing ComfyUI on localhost (127.0.0.1) you will have to enable TLS (https)\n\n' +
                    t.message),
              s.replaceChildren(e)
          }
        }, 'loadVideo')(),
        { widget: t.addDOMWidget(n, 'WEBCAM', s) }
      )
    }
  }),
  nodeCreated(t) {
    if ((t.type, 'WebcamCapture' !== t.constructor.comfyClass)) return
    let n
    const i = t.widgets.find((t) => 'image' === t.name),
      s = t.widgets.find((t) => 'width' === t.name),
      a = t.widgets.find((t) => 'height' === t.name),
      o = t.widgets.find((t) => 'capture_on_queue' === t.name),
      l = document.createElement('canvas'),
      h = e(() => {
        ;(l.width = s.value), (l.height = a.value)
        l.getContext('2d').drawImage(n, 0, 0, s.value, a.value)
        const e = l.toDataURL('image/png'),
          i = new Image()
        ;(i.onload = () => {
          ;(t.imgs = [i]),
            r.graph.setDirtyCanvas(!0),
            requestAnimationFrame(() => {
              t.setSizeForImage?.()
            })
        }),
          (i.src = e)
      }, 'capture'),
      u = t.addWidget('button', 'waiting for camera...', 'capture', h)
    ;(u.disabled = !0),
      (u.serializeValue = () => {}),
      (i.serializeValue = async () => {
        if (o.value) h()
        else if (!t.imgs?.length) {
          const t = 'No webcam image captured'
          throw (c().addAlert(t), new Error(t))
        }
        const e = await new Promise((t) => l.toBlob(t)),
          n = +new Date() + '.png',
          i = new File([e], n),
          s = new FormData()
        s.append('image', i),
          s.append('subfolder', 'webcam'),
          s.append('type', 'temp')
        const r = await p.fetchApi('/upload/image', { method: 'POST', body: s })
        if (200 !== r.status) {
          const t = `Error uploading camera image: ${r.status} - ${r.statusText}`
          throw (c().addAlert(t), new Error(t))
        }
        return `webcam/${n} [temp]`
      }),
      t[bt].then((t) => {
        ;(n = t),
          s.value ||
            ((s.value = n.videoWidth || 640), (a.value = n.videoHeight || 480)),
          (u.disabled = !1),
          (u.label = 'capture')
      })
  }
}),
  e(wt, 'splitFilePath$1'),
  e(Mt, 'getResourceURL$1'),
  e(St, 'uploadFile$1'),
  r.registerExtension({
    name: 'Comfy.AudioWidget',
    async beforeRegisterNodeDef(t, e) {
      ;['LoadAudio', 'SaveAudio', 'PreviewAudio'].includes(t.comfyClass) &&
        (e.input.required.audioUI = ['AUDIO_UI'])
    },
    getCustomWidgets: () => ({
      AUDIO_UI(t, e) {
        const n = document.createElement('audio')
        ;(n.controls = !0),
          n.classList.add('comfy-audio'),
          n.setAttribute('name', 'media')
        const i = t.addDOMWidget(e, 'audioUI', n, { serialize: !1 })
        if (t.constructor.nodeData.output_node) {
          i.element.classList.add('empty-audio-widget')
          const e = t.onExecuted
          t.onExecuted = function (t) {
            e?.apply(this, arguments)
            const n = t.audio
            if (!n) return
            const s = n[0]
            ;(i.element.src = p.apiURL(Mt(s.subfolder, s.filename, s.type))),
              i.element.classList.remove('empty-audio-widget')
          }
        }
        return { widget: i }
      }
    }),
    onNodeOutputsUpdated(t) {
      for (const [e, n] of Object.entries(t)) {
        const t = r.graph.getNodeById(e)
        if ('audio' in n) {
          const e = t.widgets.find((t) => 'audioUI' === t.name),
            i = n.audio[0]
          ;(e.element.src = p.apiURL(Mt(i.subfolder, i.filename, i.type))),
            e.element.classList.remove('empty-audio-widget')
        }
      }
    }
  }),
  r.registerExtension({
    name: 'Comfy.UploadAudio',
    async beforeRegisterNodeDef(t, e) {
      !0 === e?.input?.required?.audio?.[1]?.audio_upload &&
        (e.input.required.upload = ['AUDIOUPLOAD'])
    },
    getCustomWidgets: () => ({
      AUDIOUPLOAD(t, n) {
        const i = t.widgets.find((t) => 'audio' === t.name),
          s = t.widgets.find((t) => 'audioUI' === t.name),
          r = e(() => {
            s.element.src = p.apiURL(Mt(...wt(i.value)))
          }, 'onAudioWidgetUpdate')
        i.value && r(), (i.callback = r)
        const a = t.onGraphConfigured
        t.onGraphConfigured = function () {
          a?.apply(this, arguments), i.value && r()
        }
        const o = document.createElement('input')
        ;(o.type = 'file'),
          (o.accept = 'audio/*'),
          (o.style.display = 'none'),
          (o.onchange = () => {
            o.files.length && St(i, s, o.files[0], !0)
          })
        const l = t.addWidget(
          'button',
          n,
          '',
          () => {
            o.click()
          },
          { serialize: !1 }
        )
        return (l.label = 'choose file to upload'), { widget: l }
      }
    })
  }),
  (async () => {
    if (!w()) return
    const t = M(),
      n = await t.getElectronVersion(),
      i = e((e, n) => {
        void 0 !== n &&
          e !== n &&
          t.restartApp('Restart ComfyUI to apply changes.', 1500)
      }, 'onChangeRestartApp')
    r.registerExtension({
      name: 'Comfy.ElectronAdapter',
      settings: [
        {
          id: 'Comfy-Desktop.AutoUpdate',
          category: ['Comfy-Desktop', 'General', 'AutoUpdate'],
          name: 'Automatically check for updates',
          type: 'boolean',
          defaultValue: !0,
          onChange: i
        },
        {
          id: 'Comfy-Desktop.SendStatistics',
          category: ['Comfy-Desktop', 'General', 'Send Statistics'],
          name: 'Send anonymous crash reports',
          type: 'boolean',
          defaultValue: !0,
          onChange: i
        }
      ],
      commands: [
        {
          id: 'Comfy-Desktop.Folders.OpenLogsFolder',
          label: 'Open Logs Folder',
          icon: 'pi pi-folder-open',
          function() {
            t.openLogsFolder()
          }
        },
        {
          id: 'Comfy-Desktop.Folders.OpenModelsFolder',
          label: 'Open Models Folder',
          icon: 'pi pi-folder-open',
          function() {
            t.openModelsFolder()
          }
        },
        {
          id: 'Comfy-Desktop.Folders.OpenOutputsFolder',
          label: 'Open Outputs Folder',
          icon: 'pi pi-folder-open',
          function() {
            t.openOutputsFolder()
          }
        },
        {
          id: 'Comfy-Desktop.Folders.OpenInputsFolder',
          label: 'Open Inputs Folder',
          icon: 'pi pi-folder-open',
          function() {
            t.openInputsFolder()
          }
        },
        {
          id: 'Comfy-Desktop.Folders.OpenCustomNodesFolder',
          label: 'Open Custom Nodes Folder',
          icon: 'pi pi-folder-open',
          function() {
            t.openCustomNodesFolder()
          }
        },
        {
          id: 'Comfy-Desktop.Folders.OpenModelConfig',
          label: 'Open extra_model_paths.yaml',
          icon: 'pi pi-file',
          function() {
            t.openModelConfig()
          }
        },
        {
          id: 'Comfy-Desktop.OpenDevTools',
          label: 'Open DevTools',
          icon: 'pi pi-code',
          function() {
            t.openDevTools()
          }
        },
        {
          id: 'Comfy-Desktop.OpenFeedbackPage',
          label: 'Feedback',
          icon: 'pi pi-envelope',
          function() {
            window.open('https://forum.comfy.org/c/v1-feedback/', '_blank')
          }
        },
        {
          id: 'Comfy-Desktop.Reinstall',
          label: 'Reinstall',
          icon: 'pi pi-refresh',
          function() {
            t.reinstall()
          }
        },
        {
          id: 'Comfy-Desktop.Restart',
          label: 'Restart',
          icon: 'pi pi-refresh',
          function() {
            t.restartApp()
          }
        }
      ],
      menuCommands: [
        { path: ['Help'], commands: ['Comfy-Desktop.OpenFeedbackPage'] },
        { path: ['Help'], commands: ['Comfy-Desktop.OpenDevTools'] },
        {
          path: ['Help', 'Open Folder'],
          commands: [
            'Comfy-Desktop.Folders.OpenLogsFolder',
            'Comfy-Desktop.Folders.OpenModelsFolder',
            'Comfy-Desktop.Folders.OpenOutputsFolder',
            'Comfy-Desktop.Folders.OpenInputsFolder',
            'Comfy-Desktop.Folders.OpenCustomNodesFolder',
            'Comfy-Desktop.Folders.OpenModelConfig'
          ]
        },
        { path: ['Help'], commands: ['Comfy-Desktop.Reinstall'] }
      ],
      aboutPageBadges: [
        {
          label: 'ComfyUI_desktop v' + n,
          url: 'https://github.com/Comfy-Org/electron',
          icon: 'pi pi-github'
        }
      ]
    })
  })()
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Tt = '170',
  Et = 0,
  At = 1,
  Ct = 2,
  Rt = 0,
  Pt = 1,
  It = 2,
  Lt = 3,
  Dt = 0,
  kt = 1,
  Nt = 2,
  Ut = 100,
  Bt = 101,
  Ot = 102,
  Ft = 200,
  zt = 201,
  Vt = 202,
  Ht = 203,
  Gt = 204,
  Wt = 205,
  jt = 206,
  Xt = 207,
  qt = 208,
  Yt = 209,
  Zt = 210,
  Kt = 211,
  $t = 212,
  Jt = 213,
  Qt = 214,
  te = 0,
  ee = 1,
  ne = 2,
  ie = 3,
  se = 4,
  re = 5,
  ae = 6,
  oe = 7,
  le = 'attached',
  ce = 301,
  he = 302,
  ue = 303,
  de = 304,
  pe = 306,
  me = 1e3,
  fe = 1001,
  ge = 1002,
  ve = 1003,
  ye = 1004,
  _e = 1005,
  xe = 1006,
  be = 1007,
  we = 1008,
  Me = 1009,
  Se = 1012,
  Te = 1013,
  Ee = 1014,
  Ae = 1015,
  Ce = 1016,
  Re = 1017,
  Pe = 1018,
  Ie = 1020,
  Le = 1023,
  De = 1026,
  ke = 1027,
  Ne = 1028,
  Ue = 1029,
  Be = 1031,
  Oe = 1033,
  Fe = 33776,
  ze = 33777,
  Ve = 33778,
  He = 33779,
  Ge = 35840,
  We = 35841,
  je = 35842,
  Xe = 35843,
  qe = 36196,
  Ye = 37492,
  Ze = 37496,
  Ke = 37808,
  $e = 37809,
  Je = 37810,
  Qe = 37811,
  tn = 37812,
  en = 37813,
  nn = 37814,
  sn = 37815,
  rn = 37816,
  an = 37817,
  on = 37818,
  ln = 37819,
  cn = 37820,
  hn = 37821,
  un = 36492,
  dn = 36494,
  pn = 36495,
  mn = 36284,
  fn = 36285,
  gn = 36286,
  vn = 2300,
  yn = 2301,
  _n = 2302,
  xn = 2400,
  bn = 2401,
  wn = 2402,
  Mn = 2500,
  Sn = 3200,
  Tn = '',
  En = 'srgb',
  An = 'srgb-linear',
  Cn = 'linear',
  Rn = 'srgb',
  Pn = 7680,
  In = 512,
  Ln = 513,
  Dn = 514,
  kn = 515,
  Nn = 516,
  Un = 517,
  Bn = 518,
  On = 519,
  Fn = 35044,
  zn = '300 es',
  Vn = 2e3,
  Hn = 2001
class Gn {
  static {
    e(this, 'EventDispatcher')
  }
  addEventListener(t, e) {
    void 0 === this._listeners && (this._listeners = {})
    const n = this._listeners
    void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
  }
  hasEventListener(t, e) {
    if (void 0 === this._listeners) return !1
    const n = this._listeners
    return void 0 !== n[t] && -1 !== n[t].indexOf(e)
  }
  removeEventListener(t, e) {
    if (void 0 === this._listeners) return
    const n = this._listeners[t]
    if (void 0 !== n) {
      const t = n.indexOf(e)
      ;-1 !== t && n.splice(t, 1)
    }
  }
  dispatchEvent(t) {
    if (void 0 === this._listeners) return
    const e = this._listeners[t.type]
    if (void 0 !== e) {
      t.target = this
      const n = e.slice(0)
      for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t)
      t.target = null
    }
  }
}
const Wn = [
  '00',
  '01',
  '02',
  '03',
  '04',
  '05',
  '06',
  '07',
  '08',
  '09',
  '0a',
  '0b',
  '0c',
  '0d',
  '0e',
  '0f',
  '10',
  '11',
  '12',
  '13',
  '14',
  '15',
  '16',
  '17',
  '18',
  '19',
  '1a',
  '1b',
  '1c',
  '1d',
  '1e',
  '1f',
  '20',
  '21',
  '22',
  '23',
  '24',
  '25',
  '26',
  '27',
  '28',
  '29',
  '2a',
  '2b',
  '2c',
  '2d',
  '2e',
  '2f',
  '30',
  '31',
  '32',
  '33',
  '34',
  '35',
  '36',
  '37',
  '38',
  '39',
  '3a',
  '3b',
  '3c',
  '3d',
  '3e',
  '3f',
  '40',
  '41',
  '42',
  '43',
  '44',
  '45',
  '46',
  '47',
  '48',
  '49',
  '4a',
  '4b',
  '4c',
  '4d',
  '4e',
  '4f',
  '50',
  '51',
  '52',
  '53',
  '54',
  '55',
  '56',
  '57',
  '58',
  '59',
  '5a',
  '5b',
  '5c',
  '5d',
  '5e',
  '5f',
  '60',
  '61',
  '62',
  '63',
  '64',
  '65',
  '66',
  '67',
  '68',
  '69',
  '6a',
  '6b',
  '6c',
  '6d',
  '6e',
  '6f',
  '70',
  '71',
  '72',
  '73',
  '74',
  '75',
  '76',
  '77',
  '78',
  '79',
  '7a',
  '7b',
  '7c',
  '7d',
  '7e',
  '7f',
  '80',
  '81',
  '82',
  '83',
  '84',
  '85',
  '86',
  '87',
  '88',
  '89',
  '8a',
  '8b',
  '8c',
  '8d',
  '8e',
  '8f',
  '90',
  '91',
  '92',
  '93',
  '94',
  '95',
  '96',
  '97',
  '98',
  '99',
  '9a',
  '9b',
  '9c',
  '9d',
  '9e',
  '9f',
  'a0',
  'a1',
  'a2',
  'a3',
  'a4',
  'a5',
  'a6',
  'a7',
  'a8',
  'a9',
  'aa',
  'ab',
  'ac',
  'ad',
  'ae',
  'af',
  'b0',
  'b1',
  'b2',
  'b3',
  'b4',
  'b5',
  'b6',
  'b7',
  'b8',
  'b9',
  'ba',
  'bb',
  'bc',
  'bd',
  'be',
  'bf',
  'c0',
  'c1',
  'c2',
  'c3',
  'c4',
  'c5',
  'c6',
  'c7',
  'c8',
  'c9',
  'ca',
  'cb',
  'cc',
  'cd',
  'ce',
  'cf',
  'd0',
  'd1',
  'd2',
  'd3',
  'd4',
  'd5',
  'd6',
  'd7',
  'd8',
  'd9',
  'da',
  'db',
  'dc',
  'dd',
  'de',
  'df',
  'e0',
  'e1',
  'e2',
  'e3',
  'e4',
  'e5',
  'e6',
  'e7',
  'e8',
  'e9',
  'ea',
  'eb',
  'ec',
  'ed',
  'ee',
  'ef',
  'f0',
  'f1',
  'f2',
  'f3',
  'f4',
  'f5',
  'f6',
  'f7',
  'f8',
  'f9',
  'fa',
  'fb',
  'fc',
  'fd',
  'fe',
  'ff'
]
let jn = 1234567
const Xn = Math.PI / 180,
  qn = 180 / Math.PI
function Yn() {
  const t = (4294967295 * Math.random()) | 0,
    e = (4294967295 * Math.random()) | 0,
    n = (4294967295 * Math.random()) | 0,
    i = (4294967295 * Math.random()) | 0
  return (
    Wn[255 & t] +
    Wn[(t >> 8) & 255] +
    Wn[(t >> 16) & 255] +
    Wn[(t >> 24) & 255] +
    '-' +
    Wn[255 & e] +
    Wn[(e >> 8) & 255] +
    '-' +
    Wn[((e >> 16) & 15) | 64] +
    Wn[(e >> 24) & 255] +
    '-' +
    Wn[(63 & n) | 128] +
    Wn[(n >> 8) & 255] +
    '-' +
    Wn[(n >> 16) & 255] +
    Wn[(n >> 24) & 255] +
    Wn[255 & i] +
    Wn[(i >> 8) & 255] +
    Wn[(i >> 16) & 255] +
    Wn[(i >> 24) & 255]
  ).toLowerCase()
}
function Zn(t, e, n) {
  return Math.max(e, Math.min(n, t))
}
function Kn(t, e) {
  return ((t % e) + e) % e
}
function $n(t, e, n, i, s) {
  return i + ((t - e) * (s - i)) / (n - e)
}
function Jn(t, e, n) {
  return t !== e ? (n - t) / (e - t) : 0
}
function Qn(t, e, n) {
  return (1 - n) * t + n * e
}
function ti(t, e, n, i) {
  return Qn(t, e, 1 - Math.exp(-n * i))
}
function ei(t, e = 1) {
  return e - Math.abs(Kn(t, 2 * e) - e)
}
function ni(t, e, n) {
  return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
}
function ii(t, e, n) {
  return t <= e
    ? 0
    : t >= n
      ? 1
      : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
}
function si(t, e) {
  return t + Math.floor(Math.random() * (e - t + 1))
}
function ri(t, e) {
  return t + Math.random() * (e - t)
}
function ai(t) {
  return t * (0.5 - Math.random())
}
function oi(t) {
  void 0 !== t && (jn = t)
  let e = (jn += 1831565813)
  return (
    (e = Math.imul(e ^ (e >>> 15), 1 | e)),
    (e ^= e + Math.imul(e ^ (e >>> 7), 61 | e)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  )
}
function li(t) {
  return t * Xn
}
function ci(t) {
  return t * qn
}
function hi(t) {
  return !(t & (t - 1)) && 0 !== t
}
function ui(t) {
  return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
}
function di(t) {
  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
}
function pi(t, e, n, i, s) {
  const r = Math.cos,
    a = Math.sin,
    o = r(n / 2),
    l = a(n / 2),
    c = r((e + i) / 2),
    h = a((e + i) / 2),
    u = r((e - i) / 2),
    d = a((e - i) / 2),
    p = r((i - e) / 2),
    m = a((i - e) / 2)
  switch (s) {
    case 'XYX':
      t.set(o * h, l * u, l * d, o * c)
      break
    case 'YZY':
      t.set(l * d, o * h, l * u, o * c)
      break
    case 'ZXZ':
      t.set(l * u, l * d, o * h, o * c)
      break
    case 'XZX':
      t.set(o * h, l * m, l * p, o * c)
      break
    case 'YXY':
      t.set(l * p, o * h, l * m, o * c)
      break
    case 'ZYZ':
      t.set(l * m, l * p, o * h, o * c)
      break
    default:
      console.warn(
        'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
          s
      )
  }
}
function mi(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t
    case Uint32Array:
      return t / 4294967295
    case Uint16Array:
      return t / 65535
    case Uint8Array:
      return t / 255
    case Int32Array:
      return Math.max(t / 2147483647, -1)
    case Int16Array:
      return Math.max(t / 32767, -1)
    case Int8Array:
      return Math.max(t / 127, -1)
    default:
      throw new Error('Invalid component type.')
  }
}
function fi(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t
    case Uint32Array:
      return Math.round(4294967295 * t)
    case Uint16Array:
      return Math.round(65535 * t)
    case Uint8Array:
      return Math.round(255 * t)
    case Int32Array:
      return Math.round(2147483647 * t)
    case Int16Array:
      return Math.round(32767 * t)
    case Int8Array:
      return Math.round(127 * t)
    default:
      throw new Error('Invalid component type.')
  }
}
e(Yn, 'generateUUID'),
  e(Zn, 'clamp'),
  e(Kn, 'euclideanModulo'),
  e($n, 'mapLinear'),
  e(Jn, 'inverseLerp'),
  e(Qn, 'lerp'),
  e(ti, 'damp'),
  e(ei, 'pingpong'),
  e(ni, 'smoothstep'),
  e(ii, 'smootherstep'),
  e(si, 'randInt'),
  e(ri, 'randFloat'),
  e(ai, 'randFloatSpread'),
  e(oi, 'seededRandom'),
  e(li, 'degToRad'),
  e(ci, 'radToDeg'),
  e(hi, 'isPowerOfTwo'),
  e(ui, 'ceilPowerOfTwo'),
  e(di, 'floorPowerOfTwo'),
  e(pi, 'setQuaternionFromProperEuler'),
  e(mi, 'denormalize'),
  e(fi, 'normalize')
const gi = {
  DEG2RAD: Xn,
  RAD2DEG: qn,
  generateUUID: Yn,
  clamp: Zn,
  euclideanModulo: Kn,
  mapLinear: $n,
  inverseLerp: Jn,
  lerp: Qn,
  damp: ti,
  pingpong: ei,
  smoothstep: ni,
  smootherstep: ii,
  randInt: si,
  randFloat: ri,
  randFloatSpread: ai,
  seededRandom: oi,
  degToRad: li,
  radToDeg: ci,
  isPowerOfTwo: hi,
  ceilPowerOfTwo: ui,
  floorPowerOfTwo: di,
  setQuaternionFromProperEuler: pi,
  normalize: fi,
  denormalize: mi
}
class vi {
  static {
    e(this, 'Vector2')
  }
  constructor(t = 0, e = 0) {
    ;(vi.prototype.isVector2 = !0), (this.x = t), (this.y = e)
  }
  get width() {
    return this.x
  }
  set width(t) {
    this.x = t
  }
  get height() {
    return this.y
  }
  set height(t) {
    this.y = t
  }
  set(t, e) {
    return (this.x = t), (this.y = e), this
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), this
  }
  setX(t) {
    return (this.x = t), this
  }
  setY(t) {
    return (this.y = t), this
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e
        break
      case 1:
        this.y = e
        break
      default:
        throw new Error('index is out of range: ' + t)
    }
    return this
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x
      case 1:
        return this.y
      default:
        throw new Error('index is out of range: ' + t)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y)
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), this
  }
  add(t) {
    return (this.x += t.x), (this.y += t.y), this
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), this
  }
  addVectors(t, e) {
    return (this.x = t.x + e.x), (this.y = t.y + e.y), this
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), this
  }
  sub(t) {
    return (this.x -= t.x), (this.y -= t.y), this
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), this
  }
  subVectors(t, e) {
    return (this.x = t.x - e.x), (this.y = t.y - e.y), this
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), this
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), this
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), this
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t)
  }
  applyMatrix3(t) {
    const e = this.x,
      n = this.y,
      i = t.elements
    return (
      (this.x = i[0] * e + i[3] * n + i[6]),
      (this.y = i[1] * e + i[4] * n + i[7]),
      this
    )
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
    )
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
    )
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      this
    )
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      this
    )
  }
  clampLength(t, e) {
    const n = this.length()
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this
  }
  dot(t) {
    return this.x * t.x + this.y * t.y
  }
  cross(t) {
    return this.x * t.y - this.y * t.x
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq())
    if (0 === e) return Math.PI / 2
    const n = this.dot(t) / e
    return Math.acos(Zn(n, -1, 1))
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t))
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      n = this.y - t.y
    return e * e + n * n
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t)
  }
  lerp(t, e) {
    return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this
    )
  }
  equals(t) {
    return t.x === this.x && t.y === this.y
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), this
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), t
  }
  fromBufferAttribute(t, e) {
    return (this.x = t.getX(e)), (this.y = t.getY(e)), this
  }
  rotateAround(t, e) {
    const n = Math.cos(e),
      i = Math.sin(e),
      s = this.x - t.x,
      r = this.y - t.y
    return (this.x = s * n - r * i + t.x), (this.y = s * i + r * n + t.y), this
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y
  }
}
class yi {
  static {
    e(this, 'Matrix3')
  }
  constructor(t, e, n, i, s, r, a, o, l) {
    ;(yi.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      void 0 !== t && this.set(t, e, n, i, s, r, a, o, l)
  }
  set(t, e, n, i, s, r, a, o, l) {
    const c = this.elements
    return (
      (c[0] = t),
      (c[1] = i),
      (c[2] = a),
      (c[3] = e),
      (c[4] = s),
      (c[5] = o),
      (c[6] = n),
      (c[7] = r),
      (c[8] = l),
      this
    )
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
  }
  copy(t) {
    const e = this.elements,
      n = t.elements
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      this
    )
  }
  extractBasis(t, e, n) {
    return (
      t.setFromMatrix3Column(this, 0),
      e.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    )
  }
  setFromMatrix4(t) {
    const e = t.elements
    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
  }
  multiply(t) {
    return this.multiplyMatrices(this, t)
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this)
  }
  multiplyMatrices(t, e) {
    const n = t.elements,
      i = e.elements,
      s = this.elements,
      r = n[0],
      a = n[3],
      o = n[6],
      l = n[1],
      c = n[4],
      h = n[7],
      u = n[2],
      d = n[5],
      p = n[8],
      m = i[0],
      f = i[3],
      g = i[6],
      v = i[1],
      y = i[4],
      _ = i[7],
      x = i[2],
      b = i[5],
      w = i[8]
    return (
      (s[0] = r * m + a * v + o * x),
      (s[3] = r * f + a * y + o * b),
      (s[6] = r * g + a * _ + o * w),
      (s[1] = l * m + c * v + h * x),
      (s[4] = l * f + c * y + h * b),
      (s[7] = l * g + c * _ + h * w),
      (s[2] = u * m + d * v + p * x),
      (s[5] = u * f + d * y + p * b),
      (s[8] = u * g + d * _ + p * w),
      this
    )
  }
  multiplyScalar(t) {
    const e = this.elements
    return (
      (e[0] *= t),
      (e[3] *= t),
      (e[6] *= t),
      (e[1] *= t),
      (e[4] *= t),
      (e[7] *= t),
      (e[2] *= t),
      (e[5] *= t),
      (e[8] *= t),
      this
    )
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      s = t[3],
      r = t[4],
      a = t[5],
      o = t[6],
      l = t[7],
      c = t[8]
    return e * r * c - e * a * l - n * s * c + n * a * o + i * s * l - i * r * o
  }
  invert() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      s = t[3],
      r = t[4],
      a = t[5],
      o = t[6],
      l = t[7],
      c = t[8],
      h = c * r - a * l,
      u = a * o - c * s,
      d = l * s - r * o,
      p = e * h + n * u + i * d
    if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
    const m = 1 / p
    return (
      (t[0] = h * m),
      (t[1] = (i * l - c * n) * m),
      (t[2] = (a * n - i * r) * m),
      (t[3] = u * m),
      (t[4] = (c * e - i * o) * m),
      (t[5] = (i * s - a * e) * m),
      (t[6] = d * m),
      (t[7] = (n * o - l * e) * m),
      (t[8] = (r * e - n * s) * m),
      this
    )
  }
  transpose() {
    let t
    const e = this.elements
    return (
      (t = e[1]),
      (e[1] = e[3]),
      (e[3] = t),
      (t = e[2]),
      (e[2] = e[6]),
      (e[6] = t),
      (t = e[5]),
      (e[5] = e[7]),
      (e[7] = t),
      this
    )
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose()
  }
  transposeIntoArray(t) {
    const e = this.elements
    return (
      (t[0] = e[0]),
      (t[1] = e[3]),
      (t[2] = e[6]),
      (t[3] = e[1]),
      (t[4] = e[4]),
      (t[5] = e[7]),
      (t[6] = e[2]),
      (t[7] = e[5]),
      (t[8] = e[8]),
      this
    )
  }
  setUvTransform(t, e, n, i, s, r, a) {
    const o = Math.cos(s),
      l = Math.sin(s)
    return (
      this.set(
        n * o,
        n * l,
        -n * (o * r + l * a) + r + t,
        -i * l,
        i * o,
        -i * (-l * r + o * a) + a + e,
        0,
        0,
        1
      ),
      this
    )
  }
  scale(t, e) {
    return this.premultiply(_i.makeScale(t, e)), this
  }
  rotate(t) {
    return this.premultiply(_i.makeRotation(-t)), this
  }
  translate(t, e) {
    return this.premultiply(_i.makeTranslation(t, e)), this
  }
  makeTranslation(t, e) {
    return (
      t.isVector2
        ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
        : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
      this
    )
  }
  makeRotation(t) {
    const e = Math.cos(t),
      n = Math.sin(t)
    return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this
  }
  makeScale(t, e) {
    return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
  }
  equals(t) {
    const e = this.elements,
      n = t.elements
    for (let i = 0; i < 9; i++) if (e[i] !== n[i]) return !1
    return !0
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = t[n + e]
    return this
  }
  toArray(t = [], e = 0) {
    const n = this.elements
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      t
    )
  }
  clone() {
    return new this.constructor().fromArray(this.elements)
  }
}
const _i = new yi()
function xi(t) {
  for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0
  return !1
}
e(xi, 'arrayNeedsUint32')
const bi = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  Uint8ClampedArray: Uint8ClampedArray,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
}
function wi(t, e) {
  return new bi[t](e)
}
function Mi(t) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', t)
}
function Si() {
  const t = Mi('canvas')
  return (t.style.display = 'block'), t
}
e(wi, 'getTypedArray'), e(Mi, 'createElementNS'), e(Si, 'createCanvasElement')
const Ti = {}
function Ei(t) {
  t in Ti || ((Ti[t] = !0), console.warn(t))
}
function Ai(t, n, i) {
  return new Promise(function (s, r) {
    function a() {
      switch (t.clientWaitSync(n, t.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case t.WAIT_FAILED:
          r()
          break
        case t.TIMEOUT_EXPIRED:
          setTimeout(a, i)
          break
        default:
          s()
      }
    }
    e(a, 'probe'), setTimeout(a, i)
  })
}
function Ci(t) {
  const e = t.elements
  ;(e[2] = 0.5 * e[2] + 0.5 * e[3]),
    (e[6] = 0.5 * e[6] + 0.5 * e[7]),
    (e[10] = 0.5 * e[10] + 0.5 * e[11]),
    (e[14] = 0.5 * e[14] + 0.5 * e[15])
}
function Ri(t) {
  const e = t.elements
  ;-1 === e[11]
    ? ((e[10] = -e[10] - 1), (e[14] = -e[14]))
    : ((e[10] = -e[10]), (e[14] = 1 - e[14]))
}
e(Ei, 'warnOnce'),
  e(Ai, 'probeAsync'),
  e(Ci, 'toNormalizedProjectionMatrix'),
  e(Ri, 'toReversedProjectionMatrix')
const Pi = {
  enabled: !0,
  workingColorSpace: An,
  spaces: {},
  convert: e(function (t, e, n) {
    return !1 !== this.enabled && e !== n && e && n
      ? (this.spaces[e].transfer === Rn &&
          ((t.r = Ii(t.r)), (t.g = Ii(t.g)), (t.b = Ii(t.b))),
        this.spaces[e].primaries !== this.spaces[n].primaries &&
          (t.applyMatrix3(this.spaces[e].toXYZ),
          t.applyMatrix3(this.spaces[n].fromXYZ)),
        this.spaces[n].transfer === Rn &&
          ((t.r = Li(t.r)), (t.g = Li(t.g)), (t.b = Li(t.b))),
        t)
      : t
  }, 'convert'),
  fromWorkingColorSpace: e(function (t, e) {
    return this.convert(t, this.workingColorSpace, e)
  }, 'fromWorkingColorSpace'),
  toWorkingColorSpace: e(function (t, e) {
    return this.convert(t, e, this.workingColorSpace)
  }, 'toWorkingColorSpace'),
  getPrimaries: e(function (t) {
    return this.spaces[t].primaries
  }, 'getPrimaries'),
  getTransfer: e(function (t) {
    return t === Tn ? Cn : this.spaces[t].transfer
  }, 'getTransfer'),
  getLuminanceCoefficients: e(function (t, e = this.workingColorSpace) {
    return t.fromArray(this.spaces[e].luminanceCoefficients)
  }, 'getLuminanceCoefficients'),
  define: e(function (t) {
    Object.assign(this.spaces, t)
  }, 'define'),
  _getMatrix: e(function (t, e, n) {
    return t.copy(this.spaces[e].toXYZ).multiply(this.spaces[n].fromXYZ)
  }, '_getMatrix'),
  _getDrawingBufferColorSpace: e(function (t) {
    return this.spaces[t].outputColorSpaceConfig.drawingBufferColorSpace
  }, '_getDrawingBufferColorSpace'),
  _getUnpackColorSpace: e(function (t = this.workingColorSpace) {
    return this.spaces[t].workingColorSpaceConfig.unpackColorSpace
  }, '_getUnpackColorSpace')
}
function Ii(t) {
  return t < 0.04045
    ? 0.0773993808 * t
    : Math.pow(0.9478672986 * t + 0.0521327014, 2.4)
}
function Li(t) {
  return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055
}
e(Ii, 'SRGBToLinear'), e(Li, 'LinearToSRGB')
const Di = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
  ki = [0.2126, 0.7152, 0.0722],
  Ni = [0.3127, 0.329],
  Ui = new yi().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  ),
  Bi = new yi().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  )
let Oi
Pi.define({
  [An]: {
    primaries: Di,
    whitePoint: Ni,
    transfer: Cn,
    toXYZ: Ui,
    fromXYZ: Bi,
    luminanceCoefficients: ki,
    workingColorSpaceConfig: { unpackColorSpace: En },
    outputColorSpaceConfig: { drawingBufferColorSpace: En }
  },
  [En]: {
    primaries: Di,
    whitePoint: Ni,
    transfer: Rn,
    toXYZ: Ui,
    fromXYZ: Bi,
    luminanceCoefficients: ki,
    outputColorSpaceConfig: { drawingBufferColorSpace: En }
  }
})
class Fi {
  static {
    e(this, 'ImageUtils')
  }
  static getDataURL(t) {
    if (/^data:/i.test(t.src)) return t.src
    if ('undefined' == typeof HTMLCanvasElement) return t.src
    let e
    if (t instanceof HTMLCanvasElement) e = t
    else {
      void 0 === Oi && (Oi = Mi('canvas')),
        (Oi.width = t.width),
        (Oi.height = t.height)
      const n = Oi.getContext('2d')
      t instanceof ImageData
        ? n.putImageData(t, 0, 0)
        : n.drawImage(t, 0, 0, t.width, t.height),
        (e = Oi)
    }
    return e.width > 2048 || e.height > 2048
      ? (console.warn(
          'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
          t
        ),
        e.toDataURL('image/jpeg', 0.6))
      : e.toDataURL('image/png')
  }
  static sRGBToLinear(t) {
    if (
      ('undefined' != typeof HTMLImageElement &&
        t instanceof HTMLImageElement) ||
      ('undefined' != typeof HTMLCanvasElement &&
        t instanceof HTMLCanvasElement) ||
      ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
    ) {
      const e = Mi('canvas')
      ;(e.width = t.width), (e.height = t.height)
      const n = e.getContext('2d')
      n.drawImage(t, 0, 0, t.width, t.height)
      const i = n.getImageData(0, 0, t.width, t.height),
        s = i.data
      for (let t = 0; t < s.length; t++) s[t] = 255 * Ii(s[t] / 255)
      return n.putImageData(i, 0, 0), e
    }
    if (t.data) {
      const e = t.data.slice(0)
      for (let t = 0; t < e.length; t++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray
          ? (e[t] = Math.floor(255 * Ii(e[t] / 255)))
          : (e[t] = Ii(e[t]))
      return { data: e, width: t.width, height: t.height }
    }
    return (
      console.warn(
        'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.'
      ),
      t
    )
  }
}
let zi = 0
class Vi {
  static {
    e(this, 'Source')
  }
  constructor(t = null) {
    ;(this.isSource = !0),
      Object.defineProperty(this, 'id', { value: zi++ }),
      (this.uuid = Yn()),
      (this.data = t),
      (this.dataReady = !0),
      (this.version = 0)
  }
  set needsUpdate(t) {
    !0 === t && this.version++
  }
  toJSON(t) {
    const e = void 0 === t || 'string' == typeof t
    if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid]
    const n = { uuid: this.uuid, url: '' },
      i = this.data
    if (null !== i) {
      let t
      if (Array.isArray(i)) {
        t = []
        for (let e = 0, n = i.length; e < n; e++)
          i[e].isDataTexture ? t.push(Hi(i[e].image)) : t.push(Hi(i[e]))
      } else t = Hi(i)
      n.url = t
    }
    return e || (t.images[this.uuid] = n), n
  }
}
function Hi(t) {
  return ('undefined' != typeof HTMLImageElement &&
    t instanceof HTMLImageElement) ||
    ('undefined' != typeof HTMLCanvasElement &&
      t instanceof HTMLCanvasElement) ||
    ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
    ? Fi.getDataURL(t)
    : t.data
      ? {
          data: Array.from(t.data),
          width: t.width,
          height: t.height,
          type: t.data.constructor.name
        }
      : (console.warn('THREE.Texture: Unable to serialize Texture.'), {})
}
e(Hi, 'serializeImage')
let Gi = 0
class Wi extends Gn {
  static {
    e(this, 'Texture')
  }
  constructor(
    t = Wi.DEFAULT_IMAGE,
    e = Wi.DEFAULT_MAPPING,
    n = 1001,
    i = 1001,
    s = 1006,
    r = 1008,
    a = 1023,
    o = 1009,
    l = Wi.DEFAULT_ANISOTROPY,
    c = ''
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, 'id', { value: Gi++ }),
      (this.uuid = Yn()),
      (this.name = ''),
      (this.source = new Vi(t)),
      (this.mipmaps = []),
      (this.mapping = e),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = s),
      (this.minFilter = r),
      (this.anisotropy = l),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = o),
      (this.offset = new vi(0, 0)),
      (this.repeat = new vi(1, 1)),
      (this.center = new vi(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new yi()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = c),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0)
  }
  get image() {
    return this.source.data
  }
  set image(t = null) {
    this.source.data = t
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.source = t.source),
      (this.mipmaps = t.mipmaps.slice(0)),
      (this.mapping = t.mapping),
      (this.channel = t.channel),
      (this.wrapS = t.wrapS),
      (this.wrapT = t.wrapT),
      (this.magFilter = t.magFilter),
      (this.minFilter = t.minFilter),
      (this.anisotropy = t.anisotropy),
      (this.format = t.format),
      (this.internalFormat = t.internalFormat),
      (this.type = t.type),
      this.offset.copy(t.offset),
      this.repeat.copy(t.repeat),
      this.center.copy(t.center),
      (this.rotation = t.rotation),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this.matrix.copy(t.matrix),
      (this.generateMipmaps = t.generateMipmaps),
      (this.premultiplyAlpha = t.premultiplyAlpha),
      (this.flipY = t.flipY),
      (this.unpackAlignment = t.unpackAlignment),
      (this.colorSpace = t.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      (this.needsUpdate = !0),
      this
    )
  }
  toJSON(t) {
    const e = void 0 === t || 'string' == typeof t
    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]
    const n = {
      metadata: { version: 4.6, type: 'Texture', generator: 'Texture.toJSON' },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(t).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    }
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      e || (t.textures[this.uuid] = n),
      n
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
  transformUv(t) {
    if (300 !== this.mapping) return t
    if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
      switch (this.wrapS) {
        case me:
          t.x = t.x - Math.floor(t.x)
          break
        case fe:
          t.x = t.x < 0 ? 0 : 1
          break
        case ge:
          1 === Math.abs(Math.floor(t.x) % 2)
            ? (t.x = Math.ceil(t.x) - t.x)
            : (t.x = t.x - Math.floor(t.x))
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case me:
          t.y = t.y - Math.floor(t.y)
          break
        case fe:
          t.y = t.y < 0 ? 0 : 1
          break
        case ge:
          1 === Math.abs(Math.floor(t.y) % 2)
            ? (t.y = Math.ceil(t.y) - t.y)
            : (t.y = t.y - Math.floor(t.y))
      }
    return this.flipY && (t.y = 1 - t.y), t
  }
  set needsUpdate(t) {
    !0 === t && (this.version++, (this.source.needsUpdate = !0))
  }
  set needsPMREMUpdate(t) {
    !0 === t && this.pmremVersion++
  }
}
;(Wi.DEFAULT_IMAGE = null),
  (Wi.DEFAULT_MAPPING = 300),
  (Wi.DEFAULT_ANISOTROPY = 1)
class ji {
  static {
    e(this, 'Vector4')
  }
  constructor(t = 0, e = 0, n = 0, i = 1) {
    ;(ji.prototype.isVector4 = !0),
      (this.x = t),
      (this.y = e),
      (this.z = n),
      (this.w = i)
  }
  get width() {
    return this.z
  }
  set width(t) {
    this.z = t
  }
  get height() {
    return this.w
  }
  set height(t) {
    this.w = t
  }
  set(t, e, n, i) {
    return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this
  }
  setX(t) {
    return (this.x = t), this
  }
  setY(t) {
    return (this.y = t), this
  }
  setZ(t) {
    return (this.z = t), this
  }
  setW(t) {
    return (this.w = t), this
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e
        break
      case 1:
        this.y = e
        break
      case 2:
        this.z = e
        break
      case 3:
        this.w = e
        break
      default:
        throw new Error('index is out of range: ' + t)
    }
    return this
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      case 3:
        return this.w
      default:
        throw new Error('index is out of range: ' + t)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w)
  }
  copy(t) {
    return (
      (this.x = t.x),
      (this.y = t.y),
      (this.z = t.z),
      (this.w = void 0 !== t.w ? t.w : 1),
      this
    )
  }
  add(t) {
    return (
      (this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this
    )
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x),
      (this.y = t.y + e.y),
      (this.z = t.z + e.z),
      (this.w = t.w + e.w),
      this
    )
  }
  addScaledVector(t, e) {
    return (
      (this.x += t.x * e),
      (this.y += t.y * e),
      (this.z += t.z * e),
      (this.w += t.w * e),
      this
    )
  }
  sub(t) {
    return (
      (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this
    )
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x),
      (this.y = t.y - e.y),
      (this.z = t.z - e.z),
      (this.w = t.w - e.w),
      this
    )
  }
  multiply(t) {
    return (
      (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
    )
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
  }
  applyMatrix4(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      s = this.w,
      r = t.elements
    return (
      (this.x = r[0] * e + r[4] * n + r[8] * i + r[12] * s),
      (this.y = r[1] * e + r[5] * n + r[9] * i + r[13] * s),
      (this.z = r[2] * e + r[6] * n + r[10] * i + r[14] * s),
      (this.w = r[3] * e + r[7] * n + r[11] * i + r[15] * s),
      this
    )
  }
  divide(t) {
    return (
      (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), (this.w /= t.w), this
    )
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t)
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w)
    const e = Math.sqrt(1 - t.w * t.w)
    return (
      e < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
      this
    )
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, n, i, s
    const r = 0.01,
      a = 0.1,
      o = t.elements,
      l = o[0],
      c = o[4],
      h = o[8],
      u = o[1],
      d = o[5],
      p = o[9],
      m = o[2],
      f = o[6],
      g = o[10]
    if (Math.abs(c - u) < r && Math.abs(h - m) < r && Math.abs(p - f) < r) {
      if (
        Math.abs(c + u) < a &&
        Math.abs(h + m) < a &&
        Math.abs(p + f) < a &&
        Math.abs(l + d + g - 3) < a
      )
        return this.set(1, 0, 0, 0), this
      e = Math.PI
      const t = (l + 1) / 2,
        o = (d + 1) / 2,
        v = (g + 1) / 2,
        y = (c + u) / 4,
        _ = (h + m) / 4,
        x = (p + f) / 4
      return (
        t > o && t > v
          ? t < r
            ? ((n = 0), (i = 0.707106781), (s = 0.707106781))
            : ((n = Math.sqrt(t)), (i = y / n), (s = _ / n))
          : o > v
            ? o < r
              ? ((n = 0.707106781), (i = 0), (s = 0.707106781))
              : ((i = Math.sqrt(o)), (n = y / i), (s = x / i))
            : v < r
              ? ((n = 0.707106781), (i = 0.707106781), (s = 0))
              : ((s = Math.sqrt(v)), (n = _ / s), (i = x / s)),
        this.set(n, i, s, e),
        this
      )
    }
    let v = Math.sqrt((f - p) * (f - p) + (h - m) * (h - m) + (u - c) * (u - c))
    return (
      Math.abs(v) < 0.001 && (v = 1),
      (this.x = (f - p) / v),
      (this.y = (h - m) / v),
      (this.z = (u - c) / v),
      (this.w = Math.acos((l + d + g - 1) / 2)),
      this
    )
  }
  setFromMatrixPosition(t) {
    const e = t.elements
    return (
      (this.x = e[12]),
      (this.y = e[13]),
      (this.z = e[14]),
      (this.w = e[15]),
      this
    )
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      (this.w = Math.min(this.w, t.w)),
      this
    )
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      (this.w = Math.max(this.w, t.w)),
      this
    )
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      (this.w = Math.max(t.w, Math.min(e.w, this.w))),
      this
    )
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      (this.w = Math.max(t, Math.min(e, this.w))),
      this
    )
  }
  clampLength(t, e) {
    const n = this.length()
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    )
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    )
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    )
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    )
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t)
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      (this.w += (t.w - this.w) * e),
      this
    )
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      (this.w = t.w + (e.w - t.w) * n),
      this
    )
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
  }
  fromArray(t, e = 0) {
    return (
      (this.x = t[e]),
      (this.y = t[e + 1]),
      (this.z = t[e + 2]),
      (this.w = t[e + 3]),
      this
    )
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this.x),
      (t[e + 1] = this.y),
      (t[e + 2] = this.z),
      (t[e + 3] = this.w),
      t
    )
  }
  fromBufferAttribute(t, e) {
    return (
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      (this.z = t.getZ(e)),
      (this.w = t.getW(e)),
      this
    )
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    )
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w
  }
}
class Xi extends Gn {
  static {
    e(this, 'RenderTarget')
  }
  constructor(t = 1, e = 1, n = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = t),
      (this.height = e),
      (this.depth = 1),
      (this.scissor = new ji(0, 0, t, e)),
      (this.scissorTest = !1),
      (this.viewport = new ji(0, 0, t, e))
    const i = { width: t, height: e, depth: 1 }
    n = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: xe,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1
      },
      n
    )
    const s = new Wi(
      i,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.colorSpace
    )
    ;(s.flipY = !1),
      (s.generateMipmaps = n.generateMipmaps),
      (s.internalFormat = n.internalFormat),
      (this.textures = [])
    const r = n.count
    for (let a = 0; a < r; a++)
      (this.textures[a] = s.clone()),
        (this.textures[a].isRenderTargetTexture = !0)
    ;(this.depthBuffer = n.depthBuffer),
      (this.stencilBuffer = n.stencilBuffer),
      (this.resolveDepthBuffer = n.resolveDepthBuffer),
      (this.resolveStencilBuffer = n.resolveStencilBuffer),
      (this.depthTexture = n.depthTexture),
      (this.samples = n.samples)
  }
  get texture() {
    return this.textures[0]
  }
  set texture(t) {
    this.textures[0] = t
  }
  setSize(t, e, n = 1) {
    if (this.width !== t || this.height !== e || this.depth !== n) {
      ;(this.width = t), (this.height = e), (this.depth = n)
      for (let i = 0, s = this.textures.length; i < s; i++)
        (this.textures[i].image.width = t),
          (this.textures[i].image.height = e),
          (this.textures[i].image.depth = n)
      this.dispose()
    }
    this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    ;(this.width = t.width),
      (this.height = t.height),
      (this.depth = t.depth),
      this.scissor.copy(t.scissor),
      (this.scissorTest = t.scissorTest),
      this.viewport.copy(t.viewport),
      (this.textures.length = 0)
    for (let n = 0, i = t.textures.length; n < i; n++)
      (this.textures[n] = t.textures[n].clone()),
        (this.textures[n].isRenderTargetTexture = !0)
    const e = Object.assign({}, t.texture.image)
    return (
      (this.texture.source = new Vi(e)),
      (this.depthBuffer = t.depthBuffer),
      (this.stencilBuffer = t.stencilBuffer),
      (this.resolveDepthBuffer = t.resolveDepthBuffer),
      (this.resolveStencilBuffer = t.resolveStencilBuffer),
      null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()),
      (this.samples = t.samples),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
}
class qi extends Xi {
  static {
    e(this, 'WebGLRenderTarget')
  }
  constructor(t = 1, e = 1, n = {}) {
    super(t, e, n), (this.isWebGLRenderTarget = !0)
  }
}
class Yi extends Wi {
  static {
    e(this, 'DataArrayTexture')
  }
  constructor(t = null, e = 1, n = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: t, width: e, height: n, depth: i }),
      (this.magFilter = ve),
      (this.minFilter = ve),
      (this.wrapR = fe),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set())
  }
  addLayerUpdate(t) {
    this.layerUpdates.add(t)
  }
  clearLayerUpdates() {
    this.layerUpdates.clear()
  }
}
class Zi extends qi {
  static {
    e(this, 'WebGLArrayRenderTarget')
  }
  constructor(t = 1, e = 1, n = 1, i = {}) {
    super(t, e, i),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = n),
      (this.texture = new Yi(null, t, e, n)),
      (this.texture.isRenderTargetTexture = !0)
  }
}
class Ki extends Wi {
  static {
    e(this, 'Data3DTexture')
  }
  constructor(t = null, e = 1, n = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: t, width: e, height: n, depth: i }),
      (this.magFilter = ve),
      (this.minFilter = ve),
      (this.wrapR = fe),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
class $i extends qi {
  static {
    e(this, 'WebGL3DRenderTarget')
  }
  constructor(t = 1, e = 1, n = 1, i = {}) {
    super(t, e, i),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = n),
      (this.texture = new Ki(null, t, e, n)),
      (this.texture.isRenderTargetTexture = !0)
  }
}
class Ji {
  static {
    e(this, 'Quaternion')
  }
  constructor(t = 0, e = 0, n = 0, i = 1) {
    ;(this.isQuaternion = !0),
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._w = i)
  }
  static slerpFlat(t, e, n, i, s, r, a) {
    let o = n[i + 0],
      l = n[i + 1],
      c = n[i + 2],
      h = n[i + 3]
    const u = s[r + 0],
      d = s[r + 1],
      p = s[r + 2],
      m = s[r + 3]
    if (0 === a)
      return (t[e + 0] = o), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = h)
    if (1 === a)
      return (t[e + 0] = u), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = m)
    if (h !== m || o !== u || l !== d || c !== p) {
      let t = 1 - a
      const e = o * u + l * d + c * p + h * m,
        n = e >= 0 ? 1 : -1,
        i = 1 - e * e
      if (i > Number.EPSILON) {
        const s = Math.sqrt(i),
          r = Math.atan2(s, e * n)
        ;(t = Math.sin(t * r) / s), (a = Math.sin(a * r) / s)
      }
      const s = a * n
      if (
        ((o = o * t + u * s),
        (l = l * t + d * s),
        (c = c * t + p * s),
        (h = h * t + m * s),
        t === 1 - a)
      ) {
        const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h)
        ;(o *= t), (l *= t), (c *= t), (h *= t)
      }
    }
    ;(t[e] = o), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = h)
  }
  static multiplyQuaternionsFlat(t, e, n, i, s, r) {
    const a = n[i],
      o = n[i + 1],
      l = n[i + 2],
      c = n[i + 3],
      h = s[r],
      u = s[r + 1],
      d = s[r + 2],
      p = s[r + 3]
    return (
      (t[e] = a * p + c * h + o * d - l * u),
      (t[e + 1] = o * p + c * u + l * h - a * d),
      (t[e + 2] = l * p + c * d + a * u - o * h),
      (t[e + 3] = c * p - a * h - o * u - l * d),
      t
    )
  }
  get x() {
    return this._x
  }
  set x(t) {
    ;(this._x = t), this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(t) {
    ;(this._y = t), this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(t) {
    ;(this._z = t), this._onChangeCallback()
  }
  get w() {
    return this._w
  }
  set w(t) {
    ;(this._w = t), this._onChangeCallback()
  }
  set(t, e, n, i) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w)
  }
  copy(t) {
    return (
      (this._x = t.x),
      (this._y = t.y),
      (this._z = t.z),
      (this._w = t.w),
      this._onChangeCallback(),
      this
    )
  }
  setFromEuler(t, e = !0) {
    const n = t._x,
      i = t._y,
      s = t._z,
      r = t._order,
      a = Math.cos,
      o = Math.sin,
      l = a(n / 2),
      c = a(i / 2),
      h = a(s / 2),
      u = o(n / 2),
      d = o(i / 2),
      p = o(s / 2)
    switch (r) {
      case 'XYZ':
        ;(this._x = u * c * h + l * d * p),
          (this._y = l * d * h - u * c * p),
          (this._z = l * c * p + u * d * h),
          (this._w = l * c * h - u * d * p)
        break
      case 'YXZ':
        ;(this._x = u * c * h + l * d * p),
          (this._y = l * d * h - u * c * p),
          (this._z = l * c * p - u * d * h),
          (this._w = l * c * h + u * d * p)
        break
      case 'ZXY':
        ;(this._x = u * c * h - l * d * p),
          (this._y = l * d * h + u * c * p),
          (this._z = l * c * p + u * d * h),
          (this._w = l * c * h - u * d * p)
        break
      case 'ZYX':
        ;(this._x = u * c * h - l * d * p),
          (this._y = l * d * h + u * c * p),
          (this._z = l * c * p - u * d * h),
          (this._w = l * c * h + u * d * p)
        break
      case 'YZX':
        ;(this._x = u * c * h + l * d * p),
          (this._y = l * d * h + u * c * p),
          (this._z = l * c * p - u * d * h),
          (this._w = l * c * h - u * d * p)
        break
      case 'XZY':
        ;(this._x = u * c * h - l * d * p),
          (this._y = l * d * h - u * c * p),
          (this._z = l * c * p + u * d * h),
          (this._w = l * c * h + u * d * p)
        break
      default:
        console.warn(
          'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + r
        )
    }
    return !0 === e && this._onChangeCallback(), this
  }
  setFromAxisAngle(t, e) {
    const n = e / 2,
      i = Math.sin(n)
    return (
      (this._x = t.x * i),
      (this._y = t.y * i),
      (this._z = t.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(t) {
    const e = t.elements,
      n = e[0],
      i = e[4],
      s = e[8],
      r = e[1],
      a = e[5],
      o = e[9],
      l = e[2],
      c = e[6],
      h = e[10],
      u = n + a + h
    if (u > 0) {
      const t = 0.5 / Math.sqrt(u + 1)
      ;(this._w = 0.25 / t),
        (this._x = (c - o) * t),
        (this._y = (s - l) * t),
        (this._z = (r - i) * t)
    } else if (n > a && n > h) {
      const t = 2 * Math.sqrt(1 + n - a - h)
      ;(this._w = (c - o) / t),
        (this._x = 0.25 * t),
        (this._y = (i + r) / t),
        (this._z = (s + l) / t)
    } else if (a > h) {
      const t = 2 * Math.sqrt(1 + a - n - h)
      ;(this._w = (s - l) / t),
        (this._x = (i + r) / t),
        (this._y = 0.25 * t),
        (this._z = (o + c) / t)
    } else {
      const t = 2 * Math.sqrt(1 + h - n - a)
      ;(this._w = (r - i) / t),
        (this._x = (s + l) / t),
        (this._y = (o + c) / t),
        (this._z = 0.25 * t)
    }
    return this._onChangeCallback(), this
  }
  setFromUnitVectors(t, e) {
    let n = t.dot(e) + 1
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(t.x) > Math.abs(t.z)
            ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = n)))
        : ((this._x = t.y * e.z - t.z * e.y),
          (this._y = t.z * e.x - t.x * e.z),
          (this._z = t.x * e.y - t.y * e.x),
          (this._w = n)),
      this.normalize()
    )
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(Zn(this.dot(t), -1, 1)))
  }
  rotateTowards(t, e) {
    const n = this.angleTo(t)
    if (0 === n) return this
    const i = Math.min(1, e / n)
    return this.slerp(t, i), this
  }
  identity() {
    return this.set(0, 0, 0, 1)
  }
  invert() {
    return this.conjugate()
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    )
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    )
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    )
  }
  normalize() {
    let t = this.length()
    return (
      0 === t
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((t = 1 / t),
          (this._x = this._x * t),
          (this._y = this._y * t),
          (this._z = this._z * t),
          (this._w = this._w * t)),
      this._onChangeCallback(),
      this
    )
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t)
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this)
  }
  multiplyQuaternions(t, e) {
    const n = t._x,
      i = t._y,
      s = t._z,
      r = t._w,
      a = e._x,
      o = e._y,
      l = e._z,
      c = e._w
    return (
      (this._x = n * c + r * a + i * l - s * o),
      (this._y = i * c + r * o + s * a - n * l),
      (this._z = s * c + r * l + n * o - i * a),
      (this._w = r * c - n * a - i * o - s * l),
      this._onChangeCallback(),
      this
    )
  }
  slerp(t, e) {
    if (0 === e) return this
    if (1 === e) return this.copy(t)
    const n = this._x,
      i = this._y,
      s = this._z,
      r = this._w
    let a = r * t._w + n * t._x + i * t._y + s * t._z
    if (
      (a < 0
        ? ((this._w = -t._w),
          (this._x = -t._x),
          (this._y = -t._y),
          (this._z = -t._z),
          (a = -a))
        : this.copy(t),
      a >= 1)
    )
      return (this._w = r), (this._x = n), (this._y = i), (this._z = s), this
    const o = 1 - a * a
    if (o <= Number.EPSILON) {
      const t = 1 - e
      return (
        (this._w = t * r + e * this._w),
        (this._x = t * n + e * this._x),
        (this._y = t * i + e * this._y),
        (this._z = t * s + e * this._z),
        this.normalize(),
        this
      )
    }
    const l = Math.sqrt(o),
      c = Math.atan2(l, a),
      h = Math.sin((1 - e) * c) / l,
      u = Math.sin(e * c) / l
    return (
      (this._w = r * h + this._w * u),
      (this._x = n * h + this._x * u),
      (this._y = i * h + this._y * u),
      (this._z = s * h + this._z * u),
      this._onChangeCallback(),
      this
    )
  }
  slerpQuaternions(t, e, n) {
    return this.copy(t).slerp(e, n)
  }
  random() {
    const t = 2 * Math.PI * Math.random(),
      e = 2 * Math.PI * Math.random(),
      n = Math.random(),
      i = Math.sqrt(1 - n),
      s = Math.sqrt(n)
    return this.set(
      i * Math.sin(t),
      i * Math.cos(t),
      s * Math.sin(e),
      s * Math.cos(e)
    )
  }
  equals(t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._w === this._w
    )
  }
  fromArray(t, e = 0) {
    return (
      (this._x = t[e]),
      (this._y = t[e + 1]),
      (this._z = t[e + 2]),
      (this._w = t[e + 3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._w),
      t
    )
  }
  fromBufferAttribute(t, e) {
    return (
      (this._x = t.getX(e)),
      (this._y = t.getY(e)),
      (this._z = t.getZ(e)),
      (this._w = t.getW(e)),
      this._onChangeCallback(),
      this
    )
  }
  toJSON() {
    return this.toArray()
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w
  }
}
class Qi {
  static {
    e(this, 'Vector3')
  }
  constructor(t = 0, e = 0, n = 0) {
    ;(Qi.prototype.isVector3 = !0), (this.x = t), (this.y = e), (this.z = n)
  }
  set(t, e, n) {
    return (
      void 0 === n && (n = this.z),
      (this.x = t),
      (this.y = e),
      (this.z = n),
      this
    )
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), this
  }
  setX(t) {
    return (this.x = t), this
  }
  setY(t) {
    return (this.y = t), this
  }
  setZ(t) {
    return (this.z = t), this
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e
        break
      case 1:
        this.y = e
        break
      case 2:
        this.z = e
        break
      default:
        throw new Error('index is out of range: ' + t)
    }
    return this
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      default:
        throw new Error('index is out of range: ' + t)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z)
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this
  }
  add(t) {
    return (this.x += t.x), (this.y += t.y), (this.z += t.z), this
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), this
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
    )
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
  }
  sub(t) {
    return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), this
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
    )
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), this
  }
  multiplyVectors(t, e) {
    return (
      (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
    )
  }
  applyEuler(t) {
    return this.applyQuaternion(es.setFromEuler(t))
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(es.setFromAxisAngle(t, e))
  }
  applyMatrix3(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      s = t.elements
    return (
      (this.x = s[0] * e + s[3] * n + s[6] * i),
      (this.y = s[1] * e + s[4] * n + s[7] * i),
      (this.z = s[2] * e + s[5] * n + s[8] * i),
      this
    )
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize()
  }
  applyMatrix4(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      s = t.elements,
      r = 1 / (s[3] * e + s[7] * n + s[11] * i + s[15])
    return (
      (this.x = (s[0] * e + s[4] * n + s[8] * i + s[12]) * r),
      (this.y = (s[1] * e + s[5] * n + s[9] * i + s[13]) * r),
      (this.z = (s[2] * e + s[6] * n + s[10] * i + s[14]) * r),
      this
    )
  }
  applyQuaternion(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      s = t.x,
      r = t.y,
      a = t.z,
      o = t.w,
      l = 2 * (r * i - a * n),
      c = 2 * (a * e - s * i),
      h = 2 * (s * n - r * e)
    return (
      (this.x = e + o * l + r * h - a * c),
      (this.y = n + o * c + a * l - s * h),
      (this.z = i + o * h + s * c - r * l),
      this
    )
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
      t.projectionMatrix
    )
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
      t.matrixWorld
    )
  }
  transformDirection(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      s = t.elements
    return (
      (this.x = s[0] * e + s[4] * n + s[8] * i),
      (this.y = s[1] * e + s[5] * n + s[9] * i),
      (this.z = s[2] * e + s[6] * n + s[10] * i),
      this.normalize()
    )
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t)
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      this
    )
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      this
    )
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      this
    )
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      this
    )
  }
  clampLength(t, e) {
    const n = this.length()
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    )
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t)
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      this
    )
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      this
    )
  }
  cross(t) {
    return this.crossVectors(this, t)
  }
  crossVectors(t, e) {
    const n = t.x,
      i = t.y,
      s = t.z,
      r = e.x,
      a = e.y,
      o = e.z
    return (
      (this.x = i * o - s * a),
      (this.y = s * r - n * o),
      (this.z = n * a - i * r),
      this
    )
  }
  projectOnVector(t) {
    const e = t.lengthSq()
    if (0 === e) return this.set(0, 0, 0)
    const n = t.dot(this) / e
    return this.copy(t).multiplyScalar(n)
  }
  projectOnPlane(t) {
    return ts.copy(this).projectOnVector(t), this.sub(ts)
  }
  reflect(t) {
    return this.sub(ts.copy(t).multiplyScalar(2 * this.dot(t)))
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq())
    if (0 === e) return Math.PI / 2
    const n = this.dot(t) / e
    return Math.acos(Zn(n, -1, 1))
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t))
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      n = this.y - t.y,
      i = this.z - t.z
    return e * e + n * n + i * i
  }
  manhattanDistanceTo(t) {
    return (
      Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    )
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
  }
  setFromSphericalCoords(t, e, n) {
    const i = Math.sin(e) * t
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(e) * t),
      (this.z = i * Math.cos(n)),
      this
    )
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
  }
  setFromCylindricalCoords(t, e, n) {
    return (
      (this.x = t * Math.sin(e)), (this.y = n), (this.z = t * Math.cos(e)), this
    )
  }
  setFromMatrixPosition(t) {
    const e = t.elements
    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(),
      n = this.setFromMatrixColumn(t, 1).length(),
      i = this.setFromMatrixColumn(t, 2).length()
    return (this.x = e), (this.y = n), (this.z = i), this
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, 4 * e)
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, 3 * e)
  }
  setFromEuler(t) {
    return (this.x = t._x), (this.y = t._y), (this.z = t._z), this
  }
  setFromColor(t) {
    return (this.x = t.r), (this.y = t.g), (this.z = t.b), this
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t
  }
  fromBufferAttribute(t, e) {
    return (
      (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this
    )
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    )
  }
  randomDirection() {
    const t = Math.random() * Math.PI * 2,
      e = 2 * Math.random() - 1,
      n = Math.sqrt(1 - e * e)
    return (
      (this.x = n * Math.cos(t)), (this.y = e), (this.z = n * Math.sin(t)), this
    )
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z
  }
}
const ts = new Qi(),
  es = new Ji()
class ns {
  static {
    e(this, 'Box3')
  }
  constructor(
    t = new Qi(1 / 0, 1 / 0, 1 / 0),
    e = new Qi(-1 / 0, -1 / 0, -1 / 0)
  ) {
    ;(this.isBox3 = !0), (this.min = t), (this.max = e)
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this
  }
  setFromArray(t) {
    this.makeEmpty()
    for (let e = 0, n = t.length; e < n; e += 3)
      this.expandByPoint(ss.fromArray(t, e))
    return this
  }
  setFromBufferAttribute(t) {
    this.makeEmpty()
    for (let e = 0, n = t.count; e < n; e++)
      this.expandByPoint(ss.fromBufferAttribute(t, e))
    return this
  }
  setFromPoints(t) {
    this.makeEmpty()
    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e])
    return this
  }
  setFromCenterAndSize(t, e) {
    const n = ss.copy(e).multiplyScalar(0.5)
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
  }
  setFromObject(t, e = !1) {
    return this.makeEmpty(), this.expandByObject(t, e)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    )
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    )
  }
  getCenter(t) {
    return this.isEmpty()
      ? t.set(0, 0, 0)
      : t.addVectors(this.min, this.max).multiplyScalar(0.5)
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this
  }
  expandByObject(t, e = !1) {
    t.updateWorldMatrix(!1, !1)
    const n = t.geometry
    if (void 0 !== n) {
      const i = n.getAttribute('position')
      if (!0 === e && void 0 !== i && !0 !== t.isInstancedMesh)
        for (let e = 0, n = i.count; e < n; e++)
          !0 === t.isMesh
            ? t.getVertexPosition(e, ss)
            : ss.fromBufferAttribute(i, e),
            ss.applyMatrix4(t.matrixWorld),
            this.expandByPoint(ss)
      else
        void 0 !== t.boundingBox
          ? (null === t.boundingBox && t.computeBoundingBox(),
            rs.copy(t.boundingBox))
          : (null === n.boundingBox && n.computeBoundingBox(),
            rs.copy(n.boundingBox)),
          rs.applyMatrix4(t.matrixWorld),
          this.union(rs)
    }
    const i = t.children
    for (let s = 0, r = i.length; s < r; s++) this.expandByObject(i[s], e)
    return this
  }
  containsPoint(t) {
    return (
      t.x >= this.min.x &&
      t.x <= this.max.x &&
      t.y >= this.min.y &&
      t.y <= this.max.y &&
      t.z >= this.min.z &&
      t.z <= this.max.z
    )
  }
  containsBox(t) {
    return (
      this.min.x <= t.min.x &&
      t.max.x <= this.max.x &&
      this.min.y <= t.min.y &&
      t.max.y <= this.max.y &&
      this.min.z <= t.min.z &&
      t.max.z <= this.max.z
    )
  }
  getParameter(t, e) {
    return e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y),
      (t.z - this.min.z) / (this.max.z - this.min.z)
    )
  }
  intersectsBox(t) {
    return (
      t.max.x >= this.min.x &&
      t.min.x <= this.max.x &&
      t.max.y >= this.min.y &&
      t.min.y <= this.max.y &&
      t.max.z >= this.min.z &&
      t.min.z <= this.max.z
    )
  }
  intersectsSphere(t) {
    return (
      this.clampPoint(t.center, ss),
      ss.distanceToSquared(t.center) <= t.radius * t.radius
    )
  }
  intersectsPlane(t) {
    let e, n
    return (
      t.normal.x > 0
        ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
        : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
      t.normal.y > 0
        ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
        : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
      t.normal.z > 0
        ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
        : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
      e <= -t.constant && n >= -t.constant
    )
  }
  intersectsTriangle(t) {
    if (this.isEmpty()) return !1
    this.getCenter(ds),
      ps.subVectors(this.max, ds),
      as.subVectors(t.a, ds),
      os.subVectors(t.b, ds),
      ls.subVectors(t.c, ds),
      cs.subVectors(os, as),
      hs.subVectors(ls, os),
      us.subVectors(as, ls)
    let e = [
      0,
      -cs.z,
      cs.y,
      0,
      -hs.z,
      hs.y,
      0,
      -us.z,
      us.y,
      cs.z,
      0,
      -cs.x,
      hs.z,
      0,
      -hs.x,
      us.z,
      0,
      -us.x,
      -cs.y,
      cs.x,
      0,
      -hs.y,
      hs.x,
      0,
      -us.y,
      us.x,
      0
    ]
    return (
      !!gs(e, as, os, ls, ps) &&
      ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      !!gs(e, as, os, ls, ps) &&
        (ms.crossVectors(cs, hs),
        (e = [ms.x, ms.y, ms.z]),
        gs(e, as, os, ls, ps)))
    )
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max)
  }
  distanceToPoint(t) {
    return this.clampPoint(t, ss).distanceTo(t)
  }
  getBoundingSphere(t) {
    return (
      this.isEmpty()
        ? t.makeEmpty()
        : (this.getCenter(t.center),
          (t.radius = 0.5 * this.getSize(ss).length())),
      t
    )
  }
  intersect(t) {
    return (
      this.min.max(t.min),
      this.max.min(t.max),
      this.isEmpty() && this.makeEmpty(),
      this
    )
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this
  }
  applyMatrix4(t) {
    return (
      this.isEmpty() ||
        (is[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
        is[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
        is[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
        is[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
        is[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
        is[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
        is[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
        is[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
        this.setFromPoints(is)),
      this
    )
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max)
  }
}
const is = [
    new Qi(),
    new Qi(),
    new Qi(),
    new Qi(),
    new Qi(),
    new Qi(),
    new Qi(),
    new Qi()
  ],
  ss = new Qi(),
  rs = new ns(),
  as = new Qi(),
  os = new Qi(),
  ls = new Qi(),
  cs = new Qi(),
  hs = new Qi(),
  us = new Qi(),
  ds = new Qi(),
  ps = new Qi(),
  ms = new Qi(),
  fs = new Qi()
function gs(t, e, n, i, s) {
  for (let r = 0, a = t.length - 3; r <= a; r += 3) {
    fs.fromArray(t, r)
    const a =
        s.x * Math.abs(fs.x) + s.y * Math.abs(fs.y) + s.z * Math.abs(fs.z),
      o = e.dot(fs),
      l = n.dot(fs),
      c = i.dot(fs)
    if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1
  }
  return !0
}
e(gs, 'satForAxes')
const vs = new ns(),
  ys = new Qi(),
  _s = new Qi()
class xs {
  static {
    e(this, 'Sphere')
  }
  constructor(t = new Qi(), e = -1) {
    ;(this.isSphere = !0), (this.center = t), (this.radius = e)
  }
  set(t, e) {
    return this.center.copy(t), (this.radius = e), this
  }
  setFromPoints(t, e) {
    const n = this.center
    void 0 !== e ? n.copy(e) : vs.setFromPoints(t).getCenter(n)
    let i = 0
    for (let s = 0, r = t.length; s < r; s++)
      i = Math.max(i, n.distanceToSquared(t[s]))
    return (this.radius = Math.sqrt(i)), this
  }
  copy(t) {
    return this.center.copy(t.center), (this.radius = t.radius), this
  }
  isEmpty() {
    return this.radius < 0
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius
  }
  intersectsSphere(t) {
    const e = this.radius + t.radius
    return t.center.distanceToSquared(this.center) <= e * e
  }
  intersectsBox(t) {
    return t.intersectsSphere(this)
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
  }
  clampPoint(t, e) {
    const n = this.center.distanceToSquared(t)
    return (
      e.copy(t),
      n > this.radius * this.radius &&
        (e.sub(this.center).normalize(),
        e.multiplyScalar(this.radius).add(this.center)),
      e
    )
  }
  getBoundingBox(t) {
    return this.isEmpty()
      ? (t.makeEmpty(), t)
      : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
  }
  applyMatrix4(t) {
    return (
      this.center.applyMatrix4(t),
      (this.radius = this.radius * t.getMaxScaleOnAxis()),
      this
    )
  }
  translate(t) {
    return this.center.add(t), this
  }
  expandByPoint(t) {
    if (this.isEmpty()) return this.center.copy(t), (this.radius = 0), this
    ys.subVectors(t, this.center)
    const e = ys.lengthSq()
    if (e > this.radius * this.radius) {
      const t = Math.sqrt(e),
        n = 0.5 * (t - this.radius)
      this.center.addScaledVector(ys, n / t), (this.radius += n)
    }
    return this
  }
  union(t) {
    return t.isEmpty()
      ? this
      : this.isEmpty()
        ? (this.copy(t), this)
        : (!0 === this.center.equals(t.center)
            ? (this.radius = Math.max(this.radius, t.radius))
            : (_s.subVectors(t.center, this.center).setLength(t.radius),
              this.expandByPoint(ys.copy(t.center).add(_s)),
              this.expandByPoint(ys.copy(t.center).sub(_s))),
          this)
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const bs = new Qi(),
  ws = new Qi(),
  Ms = new Qi(),
  Ss = new Qi(),
  Ts = new Qi(),
  Es = new Qi(),
  As = new Qi()
class Cs {
  static {
    e(this, 'Ray')
  }
  constructor(t = new Qi(), e = new Qi(0, 0, -1)) {
    ;(this.origin = t), (this.direction = e)
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
  }
  at(t, e) {
    return e.copy(this.origin).addScaledVector(this.direction, t)
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this
  }
  recast(t) {
    return this.origin.copy(this.at(t, bs)), this
  }
  closestPointToPoint(t, e) {
    e.subVectors(t, this.origin)
    const n = e.dot(this.direction)
    return n < 0
      ? e.copy(this.origin)
      : e.copy(this.origin).addScaledVector(this.direction, n)
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t))
  }
  distanceSqToPoint(t) {
    const e = bs.subVectors(t, this.origin).dot(this.direction)
    return e < 0
      ? this.origin.distanceToSquared(t)
      : (bs.copy(this.origin).addScaledVector(this.direction, e),
        bs.distanceToSquared(t))
  }
  distanceSqToSegment(t, e, n, i) {
    ws.copy(t).add(e).multiplyScalar(0.5),
      Ms.copy(e).sub(t).normalize(),
      Ss.copy(this.origin).sub(ws)
    const s = 0.5 * t.distanceTo(e),
      r = -this.direction.dot(Ms),
      a = Ss.dot(this.direction),
      o = -Ss.dot(Ms),
      l = Ss.lengthSq(),
      c = Math.abs(1 - r * r)
    let h, u, d, p
    if (c > 0)
      if (((h = r * o - a), (u = r * a - o), (p = s * c), h >= 0))
        if (u >= -p)
          if (u <= p) {
            const t = 1 / c
            ;(h *= t),
              (u *= t),
              (d = h * (h + r * u + 2 * a) + u * (r * h + u + 2 * o) + l)
          } else
            (u = s),
              (h = Math.max(0, -(r * u + a))),
              (d = -h * h + u * (u + 2 * o) + l)
        else
          (u = -s),
            (h = Math.max(0, -(r * u + a))),
            (d = -h * h + u * (u + 2 * o) + l)
      else
        u <= -p
          ? ((h = Math.max(0, -(-r * s + a))),
            (u = h > 0 ? -s : Math.min(Math.max(-s, -o), s)),
            (d = -h * h + u * (u + 2 * o) + l))
          : u <= p
            ? ((h = 0),
              (u = Math.min(Math.max(-s, -o), s)),
              (d = u * (u + 2 * o) + l))
            : ((h = Math.max(0, -(r * s + a))),
              (u = h > 0 ? s : Math.min(Math.max(-s, -o), s)),
              (d = -h * h + u * (u + 2 * o) + l))
    else
      (u = r > 0 ? -s : s),
        (h = Math.max(0, -(r * u + a))),
        (d = -h * h + u * (u + 2 * o) + l)
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, h),
      i && i.copy(ws).addScaledVector(Ms, u),
      d
    )
  }
  intersectSphere(t, e) {
    bs.subVectors(t.center, this.origin)
    const n = bs.dot(this.direction),
      i = bs.dot(bs) - n * n,
      s = t.radius * t.radius
    if (i > s) return null
    const r = Math.sqrt(s - i),
      a = n - r,
      o = n + r
    return o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
  }
  intersectsSphere(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
  }
  distanceToPlane(t) {
    const e = t.normal.dot(this.direction)
    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null
    const n = -(this.origin.dot(t.normal) + t.constant) / e
    return n >= 0 ? n : null
  }
  intersectPlane(t, e) {
    const n = this.distanceToPlane(t)
    return null === n ? null : this.at(n, e)
  }
  intersectsPlane(t) {
    const e = t.distanceToPoint(this.origin)
    if (0 === e) return !0
    return t.normal.dot(this.direction) * e < 0
  }
  intersectBox(t, e) {
    let n, i, s, r, a, o
    const l = 1 / this.direction.x,
      c = 1 / this.direction.y,
      h = 1 / this.direction.z,
      u = this.origin
    return (
      l >= 0
        ? ((n = (t.min.x - u.x) * l), (i = (t.max.x - u.x) * l))
        : ((n = (t.max.x - u.x) * l), (i = (t.min.x - u.x) * l)),
      c >= 0
        ? ((s = (t.min.y - u.y) * c), (r = (t.max.y - u.y) * c))
        : ((s = (t.max.y - u.y) * c), (r = (t.min.y - u.y) * c)),
      n > r || s > i
        ? null
        : ((s > n || isNaN(n)) && (n = s),
          (r < i || isNaN(i)) && (i = r),
          h >= 0
            ? ((a = (t.min.z - u.z) * h), (o = (t.max.z - u.z) * h))
            : ((a = (t.max.z - u.z) * h), (o = (t.min.z - u.z) * h)),
          n > o || a > i
            ? null
            : ((a > n || n != n) && (n = a),
              (o < i || i != i) && (i = o),
              i < 0 ? null : this.at(n >= 0 ? n : i, e)))
    )
  }
  intersectsBox(t) {
    return null !== this.intersectBox(t, bs)
  }
  intersectTriangle(t, e, n, i, s) {
    Ts.subVectors(e, t), Es.subVectors(n, t), As.crossVectors(Ts, Es)
    let r,
      a = this.direction.dot(As)
    if (a > 0) {
      if (i) return null
      r = 1
    } else {
      if (!(a < 0)) return null
      ;(r = -1), (a = -a)
    }
    Ss.subVectors(this.origin, t)
    const o = r * this.direction.dot(Es.crossVectors(Ss, Es))
    if (o < 0) return null
    const l = r * this.direction.dot(Ts.cross(Ss))
    if (l < 0) return null
    if (o + l > a) return null
    const c = -r * Ss.dot(As)
    return c < 0 ? null : this.at(c / a, s)
  }
  applyMatrix4(t) {
    return (
      this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    )
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class Rs {
  static {
    e(this, 'Matrix4')
  }
  constructor(t, e, n, i, s, r, a, o, l, c, h, u, d, p, m, f) {
    ;(Rs.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      void 0 !== t && this.set(t, e, n, i, s, r, a, o, l, c, h, u, d, p, m, f)
  }
  set(t, e, n, i, s, r, a, o, l, c, h, u, d, p, m, f) {
    const g = this.elements
    return (
      (g[0] = t),
      (g[4] = e),
      (g[8] = n),
      (g[12] = i),
      (g[1] = s),
      (g[5] = r),
      (g[9] = a),
      (g[13] = o),
      (g[2] = l),
      (g[6] = c),
      (g[10] = h),
      (g[14] = u),
      (g[3] = d),
      (g[7] = p),
      (g[11] = m),
      (g[15] = f),
      this
    )
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
  }
  clone() {
    return new Rs().fromArray(this.elements)
  }
  copy(t) {
    const e = this.elements,
      n = t.elements
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      (e[9] = n[9]),
      (e[10] = n[10]),
      (e[11] = n[11]),
      (e[12] = n[12]),
      (e[13] = n[13]),
      (e[14] = n[14]),
      (e[15] = n[15]),
      this
    )
  }
  copyPosition(t) {
    const e = this.elements,
      n = t.elements
    return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this
  }
  setFromMatrix3(t) {
    const e = t.elements
    return (
      this.set(
        e[0],
        e[3],
        e[6],
        0,
        e[1],
        e[4],
        e[7],
        0,
        e[2],
        e[5],
        e[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    )
  }
  extractBasis(t, e, n) {
    return (
      t.setFromMatrixColumn(this, 0),
      e.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    )
  }
  makeBasis(t, e, n) {
    return (
      this.set(
        t.x,
        e.x,
        n.x,
        0,
        t.y,
        e.y,
        n.y,
        0,
        t.z,
        e.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    )
  }
  extractRotation(t) {
    const e = this.elements,
      n = t.elements,
      i = 1 / Ps.setFromMatrixColumn(t, 0).length(),
      s = 1 / Ps.setFromMatrixColumn(t, 1).length(),
      r = 1 / Ps.setFromMatrixColumn(t, 2).length()
    return (
      (e[0] = n[0] * i),
      (e[1] = n[1] * i),
      (e[2] = n[2] * i),
      (e[3] = 0),
      (e[4] = n[4] * s),
      (e[5] = n[5] * s),
      (e[6] = n[6] * s),
      (e[7] = 0),
      (e[8] = n[8] * r),
      (e[9] = n[9] * r),
      (e[10] = n[10] * r),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    )
  }
  makeRotationFromEuler(t) {
    const e = this.elements,
      n = t.x,
      i = t.y,
      s = t.z,
      r = Math.cos(n),
      a = Math.sin(n),
      o = Math.cos(i),
      l = Math.sin(i),
      c = Math.cos(s),
      h = Math.sin(s)
    if ('XYZ' === t.order) {
      const t = r * c,
        n = r * h,
        i = a * c,
        s = a * h
      ;(e[0] = o * c),
        (e[4] = -o * h),
        (e[8] = l),
        (e[1] = n + i * l),
        (e[5] = t - s * l),
        (e[9] = -a * o),
        (e[2] = s - t * l),
        (e[6] = i + n * l),
        (e[10] = r * o)
    } else if ('YXZ' === t.order) {
      const t = o * c,
        n = o * h,
        i = l * c,
        s = l * h
      ;(e[0] = t + s * a),
        (e[4] = i * a - n),
        (e[8] = r * l),
        (e[1] = r * h),
        (e[5] = r * c),
        (e[9] = -a),
        (e[2] = n * a - i),
        (e[6] = s + t * a),
        (e[10] = r * o)
    } else if ('ZXY' === t.order) {
      const t = o * c,
        n = o * h,
        i = l * c,
        s = l * h
      ;(e[0] = t - s * a),
        (e[4] = -r * h),
        (e[8] = i + n * a),
        (e[1] = n + i * a),
        (e[5] = r * c),
        (e[9] = s - t * a),
        (e[2] = -r * l),
        (e[6] = a),
        (e[10] = r * o)
    } else if ('ZYX' === t.order) {
      const t = r * c,
        n = r * h,
        i = a * c,
        s = a * h
      ;(e[0] = o * c),
        (e[4] = i * l - n),
        (e[8] = t * l + s),
        (e[1] = o * h),
        (e[5] = s * l + t),
        (e[9] = n * l - i),
        (e[2] = -l),
        (e[6] = a * o),
        (e[10] = r * o)
    } else if ('YZX' === t.order) {
      const t = r * o,
        n = r * l,
        i = a * o,
        s = a * l
      ;(e[0] = o * c),
        (e[4] = s - t * h),
        (e[8] = i * h + n),
        (e[1] = h),
        (e[5] = r * c),
        (e[9] = -a * c),
        (e[2] = -l * c),
        (e[6] = n * h + i),
        (e[10] = t - s * h)
    } else if ('XZY' === t.order) {
      const t = r * o,
        n = r * l,
        i = a * o,
        s = a * l
      ;(e[0] = o * c),
        (e[4] = -h),
        (e[8] = l * c),
        (e[1] = t * h + s),
        (e[5] = r * c),
        (e[9] = n * h - i),
        (e[2] = i * h - n),
        (e[6] = a * c),
        (e[10] = s * h + t)
    }
    return (
      (e[3] = 0),
      (e[7] = 0),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    )
  }
  makeRotationFromQuaternion(t) {
    return this.compose(Ls, t, Ds)
  }
  lookAt(t, e, n) {
    const i = this.elements
    return (
      Us.subVectors(t, e),
      0 === Us.lengthSq() && (Us.z = 1),
      Us.normalize(),
      ks.crossVectors(n, Us),
      0 === ks.lengthSq() &&
        (1 === Math.abs(n.z) ? (Us.x += 1e-4) : (Us.z += 1e-4),
        Us.normalize(),
        ks.crossVectors(n, Us)),
      ks.normalize(),
      Ns.crossVectors(Us, ks),
      (i[0] = ks.x),
      (i[4] = Ns.x),
      (i[8] = Us.x),
      (i[1] = ks.y),
      (i[5] = Ns.y),
      (i[9] = Us.y),
      (i[2] = ks.z),
      (i[6] = Ns.z),
      (i[10] = Us.z),
      this
    )
  }
  multiply(t) {
    return this.multiplyMatrices(this, t)
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this)
  }
  multiplyMatrices(t, e) {
    const n = t.elements,
      i = e.elements,
      s = this.elements,
      r = n[0],
      a = n[4],
      o = n[8],
      l = n[12],
      c = n[1],
      h = n[5],
      u = n[9],
      d = n[13],
      p = n[2],
      m = n[6],
      f = n[10],
      g = n[14],
      v = n[3],
      y = n[7],
      _ = n[11],
      x = n[15],
      b = i[0],
      w = i[4],
      M = i[8],
      S = i[12],
      T = i[1],
      E = i[5],
      A = i[9],
      C = i[13],
      R = i[2],
      P = i[6],
      I = i[10],
      L = i[14],
      D = i[3],
      k = i[7],
      N = i[11],
      U = i[15]
    return (
      (s[0] = r * b + a * T + o * R + l * D),
      (s[4] = r * w + a * E + o * P + l * k),
      (s[8] = r * M + a * A + o * I + l * N),
      (s[12] = r * S + a * C + o * L + l * U),
      (s[1] = c * b + h * T + u * R + d * D),
      (s[5] = c * w + h * E + u * P + d * k),
      (s[9] = c * M + h * A + u * I + d * N),
      (s[13] = c * S + h * C + u * L + d * U),
      (s[2] = p * b + m * T + f * R + g * D),
      (s[6] = p * w + m * E + f * P + g * k),
      (s[10] = p * M + m * A + f * I + g * N),
      (s[14] = p * S + m * C + f * L + g * U),
      (s[3] = v * b + y * T + _ * R + x * D),
      (s[7] = v * w + y * E + _ * P + x * k),
      (s[11] = v * M + y * A + _ * I + x * N),
      (s[15] = v * S + y * C + _ * L + x * U),
      this
    )
  }
  multiplyScalar(t) {
    const e = this.elements
    return (
      (e[0] *= t),
      (e[4] *= t),
      (e[8] *= t),
      (e[12] *= t),
      (e[1] *= t),
      (e[5] *= t),
      (e[9] *= t),
      (e[13] *= t),
      (e[2] *= t),
      (e[6] *= t),
      (e[10] *= t),
      (e[14] *= t),
      (e[3] *= t),
      (e[7] *= t),
      (e[11] *= t),
      (e[15] *= t),
      this
    )
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      n = t[4],
      i = t[8],
      s = t[12],
      r = t[1],
      a = t[5],
      o = t[9],
      l = t[13],
      c = t[2],
      h = t[6],
      u = t[10],
      d = t[14]
    return (
      t[3] *
        (+s * o * h -
          i * l * h -
          s * a * u +
          n * l * u +
          i * a * d -
          n * o * d) +
      t[7] *
        (+e * o * d -
          e * l * u +
          s * r * u -
          i * r * d +
          i * l * c -
          s * o * c) +
      t[11] *
        (+e * l * h -
          e * a * d -
          s * r * h +
          n * r * d +
          s * a * c -
          n * l * c) +
      t[15] *
        (-i * a * c - e * o * h + e * a * u + i * r * h - n * r * u + n * o * c)
    )
  }
  transpose() {
    const t = this.elements
    let e
    return (
      (e = t[1]),
      (t[1] = t[4]),
      (t[4] = e),
      (e = t[2]),
      (t[2] = t[8]),
      (t[8] = e),
      (e = t[6]),
      (t[6] = t[9]),
      (t[9] = e),
      (e = t[3]),
      (t[3] = t[12]),
      (t[12] = e),
      (e = t[7]),
      (t[7] = t[13]),
      (t[13] = e),
      (e = t[11]),
      (t[11] = t[14]),
      (t[14] = e),
      this
    )
  }
  setPosition(t, e, n) {
    const i = this.elements
    return (
      t.isVector3
        ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
        : ((i[12] = t), (i[13] = e), (i[14] = n)),
      this
    )
  }
  invert() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      s = t[3],
      r = t[4],
      a = t[5],
      o = t[6],
      l = t[7],
      c = t[8],
      h = t[9],
      u = t[10],
      d = t[11],
      p = t[12],
      m = t[13],
      f = t[14],
      g = t[15],
      v = h * f * l - m * u * l + m * o * d - a * f * d - h * o * g + a * u * g,
      y = p * u * l - c * f * l - p * o * d + r * f * d + c * o * g - r * u * g,
      _ = c * m * l - p * h * l + p * a * d - r * m * d - c * a * g + r * h * g,
      x = p * h * o - c * m * o - p * a * u + r * m * u + c * a * f - r * h * f,
      b = e * v + n * y + i * _ + s * x
    if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    const w = 1 / b
    return (
      (t[0] = v * w),
      (t[1] =
        (m * u * s -
          h * f * s -
          m * i * d +
          n * f * d +
          h * i * g -
          n * u * g) *
        w),
      (t[2] =
        (a * f * s -
          m * o * s +
          m * i * l -
          n * f * l -
          a * i * g +
          n * o * g) *
        w),
      (t[3] =
        (h * o * s -
          a * u * s -
          h * i * l +
          n * u * l +
          a * i * d -
          n * o * d) *
        w),
      (t[4] = y * w),
      (t[5] =
        (c * f * s -
          p * u * s +
          p * i * d -
          e * f * d -
          c * i * g +
          e * u * g) *
        w),
      (t[6] =
        (p * o * s -
          r * f * s -
          p * i * l +
          e * f * l +
          r * i * g -
          e * o * g) *
        w),
      (t[7] =
        (r * u * s -
          c * o * s +
          c * i * l -
          e * u * l -
          r * i * d +
          e * o * d) *
        w),
      (t[8] = _ * w),
      (t[9] =
        (p * h * s -
          c * m * s -
          p * n * d +
          e * m * d +
          c * n * g -
          e * h * g) *
        w),
      (t[10] =
        (r * m * s -
          p * a * s +
          p * n * l -
          e * m * l -
          r * n * g +
          e * a * g) *
        w),
      (t[11] =
        (c * a * s -
          r * h * s -
          c * n * l +
          e * h * l +
          r * n * d -
          e * a * d) *
        w),
      (t[12] = x * w),
      (t[13] =
        (c * m * i -
          p * h * i +
          p * n * u -
          e * m * u -
          c * n * f +
          e * h * f) *
        w),
      (t[14] =
        (p * a * i -
          r * m * i -
          p * n * o +
          e * m * o +
          r * n * f -
          e * a * f) *
        w),
      (t[15] =
        (r * h * i -
          c * a * i +
          c * n * o -
          e * h * o -
          r * n * u +
          e * a * u) *
        w),
      this
    )
  }
  scale(t) {
    const e = this.elements,
      n = t.x,
      i = t.y,
      s = t.z
    return (
      (e[0] *= n),
      (e[4] *= i),
      (e[8] *= s),
      (e[1] *= n),
      (e[5] *= i),
      (e[9] *= s),
      (e[2] *= n),
      (e[6] *= i),
      (e[10] *= s),
      (e[3] *= n),
      (e[7] *= i),
      (e[11] *= s),
      this
    )
  }
  getMaxScaleOnAxis() {
    const t = this.elements,
      e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
      n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
      i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]
    return Math.sqrt(Math.max(e, n, i))
  }
  makeTranslation(t, e, n) {
    return (
      t.isVector3
        ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
      this
    )
  }
  makeRotationX(t) {
    const e = Math.cos(t),
      n = Math.sin(t)
    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
  }
  makeRotationY(t) {
    const e = Math.cos(t),
      n = Math.sin(t)
    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
  }
  makeRotationZ(t) {
    const e = Math.cos(t),
      n = Math.sin(t)
    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
  }
  makeRotationAxis(t, e) {
    const n = Math.cos(e),
      i = Math.sin(e),
      s = 1 - n,
      r = t.x,
      a = t.y,
      o = t.z,
      l = s * r,
      c = s * a
    return (
      this.set(
        l * r + n,
        l * a - i * o,
        l * o + i * a,
        0,
        l * a + i * o,
        c * a + n,
        c * o - i * r,
        0,
        l * o - i * a,
        c * o + i * r,
        s * o * o + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    )
  }
  makeScale(t, e, n) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
  }
  makeShear(t, e, n, i, s, r) {
    return this.set(1, n, s, 0, t, 1, r, 0, e, i, 1, 0, 0, 0, 0, 1), this
  }
  compose(t, e, n) {
    const i = this.elements,
      s = e._x,
      r = e._y,
      a = e._z,
      o = e._w,
      l = s + s,
      c = r + r,
      h = a + a,
      u = s * l,
      d = s * c,
      p = s * h,
      m = r * c,
      f = r * h,
      g = a * h,
      v = o * l,
      y = o * c,
      _ = o * h,
      x = n.x,
      b = n.y,
      w = n.z
    return (
      (i[0] = (1 - (m + g)) * x),
      (i[1] = (d + _) * x),
      (i[2] = (p - y) * x),
      (i[3] = 0),
      (i[4] = (d - _) * b),
      (i[5] = (1 - (u + g)) * b),
      (i[6] = (f + v) * b),
      (i[7] = 0),
      (i[8] = (p + y) * w),
      (i[9] = (f - v) * w),
      (i[10] = (1 - (u + m)) * w),
      (i[11] = 0),
      (i[12] = t.x),
      (i[13] = t.y),
      (i[14] = t.z),
      (i[15] = 1),
      this
    )
  }
  decompose(t, e, n) {
    const i = this.elements
    let s = Ps.set(i[0], i[1], i[2]).length()
    const r = Ps.set(i[4], i[5], i[6]).length(),
      a = Ps.set(i[8], i[9], i[10]).length()
    this.determinant() < 0 && (s = -s),
      (t.x = i[12]),
      (t.y = i[13]),
      (t.z = i[14]),
      Is.copy(this)
    const o = 1 / s,
      l = 1 / r,
      c = 1 / a
    return (
      (Is.elements[0] *= o),
      (Is.elements[1] *= o),
      (Is.elements[2] *= o),
      (Is.elements[4] *= l),
      (Is.elements[5] *= l),
      (Is.elements[6] *= l),
      (Is.elements[8] *= c),
      (Is.elements[9] *= c),
      (Is.elements[10] *= c),
      e.setFromRotationMatrix(Is),
      (n.x = s),
      (n.y = r),
      (n.z = a),
      this
    )
  }
  makePerspective(t, e, n, i, s, r, a = 2e3) {
    const o = this.elements,
      l = (2 * s) / (e - t),
      c = (2 * s) / (n - i),
      h = (e + t) / (e - t),
      u = (n + i) / (n - i)
    let d, p
    if (a === Vn) (d = -(r + s) / (r - s)), (p = (-2 * r * s) / (r - s))
    else {
      if (a !== Hn)
        throw new Error(
          'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + a
        )
      ;(d = -r / (r - s)), (p = (-r * s) / (r - s))
    }
    return (
      (o[0] = l),
      (o[4] = 0),
      (o[8] = h),
      (o[12] = 0),
      (o[1] = 0),
      (o[5] = c),
      (o[9] = u),
      (o[13] = 0),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = d),
      (o[14] = p),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = -1),
      (o[15] = 0),
      this
    )
  }
  makeOrthographic(t, e, n, i, s, r, a = 2e3) {
    const o = this.elements,
      l = 1 / (e - t),
      c = 1 / (n - i),
      h = 1 / (r - s),
      u = (e + t) * l,
      d = (n + i) * c
    let p, m
    if (a === Vn) (p = (r + s) * h), (m = -2 * h)
    else {
      if (a !== Hn)
        throw new Error(
          'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + a
        )
      ;(p = s * h), (m = -1 * h)
    }
    return (
      (o[0] = 2 * l),
      (o[4] = 0),
      (o[8] = 0),
      (o[12] = -u),
      (o[1] = 0),
      (o[5] = 2 * c),
      (o[9] = 0),
      (o[13] = -d),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = m),
      (o[14] = -p),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = 0),
      (o[15] = 1),
      this
    )
  }
  equals(t) {
    const e = this.elements,
      n = t.elements
    for (let i = 0; i < 16; i++) if (e[i] !== n[i]) return !1
    return !0
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = t[n + e]
    return this
  }
  toArray(t = [], e = 0) {
    const n = this.elements
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      (t[e + 9] = n[9]),
      (t[e + 10] = n[10]),
      (t[e + 11] = n[11]),
      (t[e + 12] = n[12]),
      (t[e + 13] = n[13]),
      (t[e + 14] = n[14]),
      (t[e + 15] = n[15]),
      t
    )
  }
}
const Ps = new Qi(),
  Is = new Rs(),
  Ls = new Qi(0, 0, 0),
  Ds = new Qi(1, 1, 1),
  ks = new Qi(),
  Ns = new Qi(),
  Us = new Qi(),
  Bs = new Rs(),
  Os = new Ji()
class Fs {
  static {
    e(this, 'Euler')
  }
  constructor(t = 0, e = 0, n = 0, i = Fs.DEFAULT_ORDER) {
    ;(this.isEuler = !0),
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._order = i)
  }
  get x() {
    return this._x
  }
  set x(t) {
    ;(this._x = t), this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(t) {
    ;(this._y = t), this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(t) {
    ;(this._z = t), this._onChangeCallback()
  }
  get order() {
    return this._order
  }
  set order(t) {
    ;(this._order = t), this._onChangeCallback()
  }
  set(t, e, n, i = this._order) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._order = i),
      this._onChangeCallback(),
      this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order)
  }
  copy(t) {
    return (
      (this._x = t._x),
      (this._y = t._y),
      (this._z = t._z),
      (this._order = t._order),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(t, e = this._order, n = !0) {
    const i = t.elements,
      s = i[0],
      r = i[4],
      a = i[8],
      o = i[1],
      l = i[5],
      c = i[9],
      h = i[2],
      u = i[6],
      d = i[10]
    switch (e) {
      case 'XYZ':
        ;(this._y = Math.asin(Zn(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-r, s)))
            : ((this._x = Math.atan2(u, l)), (this._z = 0))
        break
      case 'YXZ':
        ;(this._x = Math.asin(-Zn(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
            : ((this._y = Math.atan2(-h, s)), (this._z = 0))
        break
      case 'ZXY':
        ;(this._x = Math.asin(Zn(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(-h, d)), (this._z = Math.atan2(-r, l)))
            : ((this._y = 0), (this._z = Math.atan2(o, s)))
        break
      case 'ZYX':
        ;(this._y = Math.asin(-Zn(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, s)))
            : ((this._x = 0), (this._z = Math.atan2(-r, l)))
        break
      case 'YZX':
        ;(this._z = Math.asin(Zn(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-h, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, d)))
        break
      case 'XZY':
        ;(this._z = Math.asin(-Zn(r, -1, 1))),
          Math.abs(r) < 0.9999999
            ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-c, d)), (this._y = 0))
        break
      default:
        console.warn(
          'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
            e
        )
    }
    return (this._order = e), !0 === n && this._onChangeCallback(), this
  }
  setFromQuaternion(t, e, n) {
    return (
      Bs.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Bs, e, n)
    )
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e)
  }
  reorder(t) {
    return Os.setFromEuler(this), this.setFromQuaternion(Os, t)
  }
  equals(t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._order === this._order
    )
  }
  fromArray(t) {
    return (
      (this._x = t[0]),
      (this._y = t[1]),
      (this._z = t[2]),
      void 0 !== t[3] && (this._order = t[3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._order),
      t
    )
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order
  }
}
Fs.DEFAULT_ORDER = 'XYZ'
class zs {
  static {
    e(this, 'Layers')
  }
  constructor() {
    this.mask = 1
  }
  set(t) {
    this.mask = (1 << t) >>> 0
  }
  enable(t) {
    this.mask |= 1 << t
  }
  enableAll() {
    this.mask = -1
  }
  toggle(t) {
    this.mask ^= 1 << t
  }
  disable(t) {
    this.mask &= ~(1 << t)
  }
  disableAll() {
    this.mask = 0
  }
  test(t) {
    return !!(this.mask & t.mask)
  }
  isEnabled(t) {
    return !!(this.mask & (1 << t))
  }
}
let Vs = 0
const Hs = new Qi(),
  Gs = new Ji(),
  Ws = new Rs(),
  js = new Qi(),
  Xs = new Qi(),
  qs = new Qi(),
  Ys = new Ji(),
  Zs = new Qi(1, 0, 0),
  Ks = new Qi(0, 1, 0),
  $s = new Qi(0, 0, 1),
  Js = { type: 'added' },
  Qs = { type: 'removed' },
  tr = { type: 'childadded', child: null },
  er = { type: 'childremoved', child: null }
class nr extends Gn {
  static {
    e(this, 'Object3D')
  }
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, 'id', { value: Vs++ }),
      (this.uuid = Yn()),
      (this.name = ''),
      (this.type = 'Object3D'),
      (this.parent = null),
      (this.children = []),
      (this.up = nr.DEFAULT_UP.clone())
    const t = new Qi(),
      n = new Fs(),
      i = new Ji(),
      s = new Qi(1, 1, 1)
    function r() {
      i.setFromEuler(n, !1)
    }
    function a() {
      n.setFromQuaternion(i, void 0, !1)
    }
    e(r, 'onRotationChange'),
      e(a, 'onQuaternionChange'),
      n._onChange(r),
      i._onChange(a),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: t },
        rotation: { configurable: !0, enumerable: !0, value: n },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: s },
        modelViewMatrix: { value: new Rs() },
        normalMatrix: { value: new yi() }
      }),
      (this.matrix = new Rs()),
      (this.matrixWorld = new Rs()),
      (this.matrixAutoUpdate = nr.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = nr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new zs()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {})
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(t),
      this.matrix.decompose(this.position, this.quaternion, this.scale)
  }
  applyQuaternion(t) {
    return this.quaternion.premultiply(t), this
  }
  setRotationFromAxisAngle(t, e) {
    this.quaternion.setFromAxisAngle(t, e)
  }
  setRotationFromEuler(t) {
    this.quaternion.setFromEuler(t, !0)
  }
  setRotationFromMatrix(t) {
    this.quaternion.setFromRotationMatrix(t)
  }
  setRotationFromQuaternion(t) {
    this.quaternion.copy(t)
  }
  rotateOnAxis(t, e) {
    return Gs.setFromAxisAngle(t, e), this.quaternion.multiply(Gs), this
  }
  rotateOnWorldAxis(t, e) {
    return Gs.setFromAxisAngle(t, e), this.quaternion.premultiply(Gs), this
  }
  rotateX(t) {
    return this.rotateOnAxis(Zs, t)
  }
  rotateY(t) {
    return this.rotateOnAxis(Ks, t)
  }
  rotateZ(t) {
    return this.rotateOnAxis($s, t)
  }
  translateOnAxis(t, e) {
    return (
      Hs.copy(t).applyQuaternion(this.quaternion),
      this.position.add(Hs.multiplyScalar(e)),
      this
    )
  }
  translateX(t) {
    return this.translateOnAxis(Zs, t)
  }
  translateY(t) {
    return this.translateOnAxis(Ks, t)
  }
  translateZ(t) {
    return this.translateOnAxis($s, t)
  }
  localToWorld(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
  }
  worldToLocal(t) {
    return (
      this.updateWorldMatrix(!0, !1),
      t.applyMatrix4(Ws.copy(this.matrixWorld).invert())
    )
  }
  lookAt(t, e, n) {
    t.isVector3 ? js.copy(t) : js.set(t, e, n)
    const i = this.parent
    this.updateWorldMatrix(!0, !1),
      Xs.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Ws.lookAt(Xs, js, this.up)
        : Ws.lookAt(js, Xs, this.up),
      this.quaternion.setFromRotationMatrix(Ws),
      i &&
        (Ws.extractRotation(i.matrixWorld),
        Gs.setFromRotationMatrix(Ws),
        this.quaternion.premultiply(Gs.invert()))
  }
  add(t) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t])
      return this
    }
    return t === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          t
        ),
        this)
      : (t && t.isObject3D
          ? (t.removeFromParent(),
            (t.parent = this),
            this.children.push(t),
            t.dispatchEvent(Js),
            (tr.child = t),
            this.dispatchEvent(tr),
            (tr.child = null))
          : console.error(
              'THREE.Object3D.add: object not an instance of THREE.Object3D.',
              t
            ),
        this)
  }
  remove(t) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.remove(arguments[t])
      return this
    }
    const e = this.children.indexOf(t)
    return (
      -1 !== e &&
        ((t.parent = null),
        this.children.splice(e, 1),
        t.dispatchEvent(Qs),
        (er.child = t),
        this.dispatchEvent(er),
        (er.child = null)),
      this
    )
  }
  removeFromParent() {
    const t = this.parent
    return null !== t && t.remove(this), this
  }
  clear() {
    return this.remove(...this.children)
  }
  attach(t) {
    return (
      this.updateWorldMatrix(!0, !1),
      Ws.copy(this.matrixWorld).invert(),
      null !== t.parent &&
        (t.parent.updateWorldMatrix(!0, !1), Ws.multiply(t.parent.matrixWorld)),
      t.applyMatrix4(Ws),
      t.removeFromParent(),
      (t.parent = this),
      this.children.push(t),
      t.updateWorldMatrix(!1, !0),
      t.dispatchEvent(Js),
      (tr.child = t),
      this.dispatchEvent(tr),
      (tr.child = null),
      this
    )
  }
  getObjectById(t) {
    return this.getObjectByProperty('id', t)
  }
  getObjectByName(t) {
    return this.getObjectByProperty('name', t)
  }
  getObjectByProperty(t, e) {
    if (this[t] === e) return this
    for (let n = 0, i = this.children.length; n < i; n++) {
      const i = this.children[n].getObjectByProperty(t, e)
      if (void 0 !== i) return i
    }
  }
  getObjectsByProperty(t, e, n = []) {
    this[t] === e && n.push(this)
    const i = this.children
    for (let s = 0, r = i.length; s < r; s++) i[s].getObjectsByProperty(t, e, n)
    return n
  }
  getWorldPosition(t) {
    return (
      this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
    )
  }
  getWorldQuaternion(t) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Xs, t, qs), t
    )
  }
  getWorldScale(t) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Xs, Ys, t), t
    )
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1)
    const e = this.matrixWorld.elements
    return t.set(e[8], e[9], e[10]).normalize()
  }
  raycast() {}
  traverse(t) {
    t(this)
    const e = this.children
    for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
  }
  traverseVisible(t) {
    if (!1 === this.visible) return
    t(this)
    const e = this.children
    for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
  }
  traverseAncestors(t) {
    const e = this.parent
    null !== e && (t(e), e.traverseAncestors(t))
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0)
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || t) &&
        (!0 === this.matrixWorldAutoUpdate &&
          (null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (t = !0))
    const e = this.children
    for (let n = 0, i = e.length; n < i; n++) {
      e[n].updateMatrixWorld(t)
    }
  }
  updateWorldMatrix(t, e) {
    const n = this.parent
    if (
      (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      !0 === this.matrixWorldAutoUpdate &&
        (null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      !0 === e)
    ) {
      const t = this.children
      for (let e = 0, n = t.length; e < n; e++) {
        t[e].updateWorldMatrix(!1, !0)
      }
    }
  }
  toJSON(t) {
    const n = void 0 === t || 'string' == typeof t,
      i = {}
    n &&
      ((t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      }),
      (i.metadata = {
        version: 4.6,
        type: 'Object',
        generator: 'Object3D.toJSON'
      }))
    const s = {}
    function r(e, n) {
      return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
    }
    if (
      ((s.uuid = this.uuid),
      (s.type = this.type),
      '' !== this.name && (s.name = this.name),
      !0 === this.castShadow && (s.castShadow = !0),
      !0 === this.receiveShadow && (s.receiveShadow = !0),
      !1 === this.visible && (s.visible = !1),
      !1 === this.frustumCulled && (s.frustumCulled = !1),
      0 !== this.renderOrder && (s.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (s.userData = this.userData),
      (s.layers = this.layers.mask),
      (s.matrix = this.matrix.toArray()),
      (s.up = this.up.toArray()),
      !1 === this.matrixAutoUpdate && (s.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((s.type = 'InstancedMesh'),
        (s.count = this.count),
        (s.instanceMatrix = this.instanceMatrix.toJSON()),
        null !== this.instanceColor &&
          (s.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((s.type = 'BatchedMesh'),
        (s.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (s.sortObjects = this.sortObjects),
        (s.drawRanges = this._drawRanges),
        (s.reservedRanges = this._reservedRanges),
        (s.visibility = this._visibility),
        (s.active = this._active),
        (s.bounds = this._bounds.map((t) => ({
          boxInitialized: t.boxInitialized,
          boxMin: t.box.min.toArray(),
          boxMax: t.box.max.toArray(),
          sphereInitialized: t.sphereInitialized,
          sphereRadius: t.sphere.radius,
          sphereCenter: t.sphere.center.toArray()
        }))),
        (s.maxInstanceCount = this._maxInstanceCount),
        (s.maxVertexCount = this._maxVertexCount),
        (s.maxIndexCount = this._maxIndexCount),
        (s.geometryInitialized = this._geometryInitialized),
        (s.geometryCount = this._geometryCount),
        (s.matricesTexture = this._matricesTexture.toJSON(t)),
        null !== this._colorsTexture &&
          (s.colorsTexture = this._colorsTexture.toJSON(t)),
        null !== this.boundingSphere &&
          (s.boundingSphere = {
            center: s.boundingSphere.center.toArray(),
            radius: s.boundingSphere.radius
          }),
        null !== this.boundingBox &&
          (s.boundingBox = {
            min: s.boundingBox.min.toArray(),
            max: s.boundingBox.max.toArray()
          })),
      e(r, 'serialize'),
      this.isScene)
    )
      this.background &&
        (this.background.isColor
          ? (s.background = this.background.toJSON())
          : this.background.isTexture &&
            (s.background = this.background.toJSON(t).uuid)),
        this.environment &&
          this.environment.isTexture &&
          !0 !== this.environment.isRenderTargetTexture &&
          (s.environment = this.environment.toJSON(t).uuid)
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = r(t.geometries, this.geometry)
      const e = this.geometry.parameters
      if (void 0 !== e && void 0 !== e.shapes) {
        const n = e.shapes
        if (Array.isArray(n))
          for (let e = 0, i = n.length; e < i; e++) {
            const i = n[e]
            r(t.shapes, i)
          }
        else r(t.shapes, n)
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((s.bindMode = this.bindMode),
        (s.bindMatrix = this.bindMatrix.toArray()),
        void 0 !== this.skeleton &&
          (r(t.skeletons, this.skeleton), (s.skeleton = this.skeleton.uuid))),
      void 0 !== this.material)
    )
      if (Array.isArray(this.material)) {
        const e = []
        for (let n = 0, i = this.material.length; n < i; n++)
          e.push(r(t.materials, this.material[n]))
        s.material = e
      } else s.material = r(t.materials, this.material)
    if (this.children.length > 0) {
      s.children = []
      for (let e = 0; e < this.children.length; e++)
        s.children.push(this.children[e].toJSON(t).object)
    }
    if (this.animations.length > 0) {
      s.animations = []
      for (let e = 0; e < this.animations.length; e++) {
        const n = this.animations[e]
        s.animations.push(r(t.animations, n))
      }
    }
    if (n) {
      const e = a(t.geometries),
        n = a(t.materials),
        s = a(t.textures),
        r = a(t.images),
        o = a(t.shapes),
        l = a(t.skeletons),
        c = a(t.animations),
        h = a(t.nodes)
      e.length > 0 && (i.geometries = e),
        n.length > 0 && (i.materials = n),
        s.length > 0 && (i.textures = s),
        r.length > 0 && (i.images = r),
        o.length > 0 && (i.shapes = o),
        l.length > 0 && (i.skeletons = l),
        c.length > 0 && (i.animations = c),
        h.length > 0 && (i.nodes = h)
    }
    return (i.object = s), i
    function a(t) {
      const e = []
      for (const n in t) {
        const i = t[n]
        delete i.metadata, e.push(i)
      }
      return e
    }
  }
  clone(t) {
    return new this.constructor().copy(this, t)
  }
  copy(t, e = !0) {
    if (
      ((this.name = t.name),
      this.up.copy(t.up),
      this.position.copy(t.position),
      (this.rotation.order = t.rotation.order),
      this.quaternion.copy(t.quaternion),
      this.scale.copy(t.scale),
      this.matrix.copy(t.matrix),
      this.matrixWorld.copy(t.matrixWorld),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
      (this.layers.mask = t.layers.mask),
      (this.visible = t.visible),
      (this.castShadow = t.castShadow),
      (this.receiveShadow = t.receiveShadow),
      (this.frustumCulled = t.frustumCulled),
      (this.renderOrder = t.renderOrder),
      (this.animations = t.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      !0 === e)
    )
      for (let n = 0; n < t.children.length; n++) {
        const e = t.children[n]
        this.add(e.clone())
      }
    return this
  }
}
;(nr.DEFAULT_UP = new Qi(0, 1, 0)),
  (nr.DEFAULT_MATRIX_AUTO_UPDATE = !0),
  (nr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0)
const ir = new Qi(),
  sr = new Qi(),
  rr = new Qi(),
  ar = new Qi(),
  or = new Qi(),
  lr = new Qi(),
  cr = new Qi(),
  hr = new Qi(),
  ur = new Qi(),
  dr = new Qi(),
  pr = new ji(),
  mr = new ji(),
  fr = new ji()
class gr {
  static {
    e(this, 'Triangle')
  }
  constructor(t = new Qi(), e = new Qi(), n = new Qi()) {
    ;(this.a = t), (this.b = e), (this.c = n)
  }
  static getNormal(t, e, n, i) {
    i.subVectors(n, e), ir.subVectors(t, e), i.cross(ir)
    const s = i.lengthSq()
    return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
  }
  static getBarycoord(t, e, n, i, s) {
    ir.subVectors(i, e), sr.subVectors(n, e), rr.subVectors(t, e)
    const r = ir.dot(ir),
      a = ir.dot(sr),
      o = ir.dot(rr),
      l = sr.dot(sr),
      c = sr.dot(rr),
      h = r * l - a * a
    if (0 === h) return s.set(0, 0, 0), null
    const u = 1 / h,
      d = (l * o - a * c) * u,
      p = (r * c - a * o) * u
    return s.set(1 - d - p, p, d)
  }
  static containsPoint(t, e, n, i) {
    return (
      null !== this.getBarycoord(t, e, n, i, ar) &&
      ar.x >= 0 &&
      ar.y >= 0 &&
      ar.x + ar.y <= 1
    )
  }
  static getInterpolation(t, e, n, i, s, r, a, o) {
    return null === this.getBarycoord(t, e, n, i, ar)
      ? ((o.x = 0),
        (o.y = 0),
        'z' in o && (o.z = 0),
        'w' in o && (o.w = 0),
        null)
      : (o.setScalar(0),
        o.addScaledVector(s, ar.x),
        o.addScaledVector(r, ar.y),
        o.addScaledVector(a, ar.z),
        o)
  }
  static getInterpolatedAttribute(t, e, n, i, s, r) {
    return (
      pr.setScalar(0),
      mr.setScalar(0),
      fr.setScalar(0),
      pr.fromBufferAttribute(t, e),
      mr.fromBufferAttribute(t, n),
      fr.fromBufferAttribute(t, i),
      r.setScalar(0),
      r.addScaledVector(pr, s.x),
      r.addScaledVector(mr, s.y),
      r.addScaledVector(fr, s.z),
      r
    )
  }
  static isFrontFacing(t, e, n, i) {
    return ir.subVectors(n, e), sr.subVectors(t, e), ir.cross(sr).dot(i) < 0
  }
  set(t, e, n) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
  }
  setFromPointsAndIndices(t, e, n, i) {
    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
  }
  setFromAttributeAndIndices(t, e, n, i) {
    return (
      this.a.fromBufferAttribute(t, e),
      this.b.fromBufferAttribute(t, n),
      this.c.fromBufferAttribute(t, i),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
  }
  getArea() {
    return (
      ir.subVectors(this.c, this.b),
      sr.subVectors(this.a, this.b),
      0.5 * ir.cross(sr).length()
    )
  }
  getMidpoint(t) {
    return t
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3)
  }
  getNormal(t) {
    return gr.getNormal(this.a, this.b, this.c, t)
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c)
  }
  getBarycoord(t, e) {
    return gr.getBarycoord(t, this.a, this.b, this.c, e)
  }
  getInterpolation(t, e, n, i, s) {
    return gr.getInterpolation(t, this.a, this.b, this.c, e, n, i, s)
  }
  containsPoint(t) {
    return gr.containsPoint(t, this.a, this.b, this.c)
  }
  isFrontFacing(t) {
    return gr.isFrontFacing(this.a, this.b, this.c, t)
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this)
  }
  closestPointToPoint(t, e) {
    const n = this.a,
      i = this.b,
      s = this.c
    let r, a
    or.subVectors(i, n), lr.subVectors(s, n), hr.subVectors(t, n)
    const o = or.dot(hr),
      l = lr.dot(hr)
    if (o <= 0 && l <= 0) return e.copy(n)
    ur.subVectors(t, i)
    const c = or.dot(ur),
      h = lr.dot(ur)
    if (c >= 0 && h <= c) return e.copy(i)
    const u = o * h - c * l
    if (u <= 0 && o >= 0 && c <= 0)
      return (r = o / (o - c)), e.copy(n).addScaledVector(or, r)
    dr.subVectors(t, s)
    const d = or.dot(dr),
      p = lr.dot(dr)
    if (p >= 0 && d <= p) return e.copy(s)
    const m = d * l - o * p
    if (m <= 0 && l >= 0 && p <= 0)
      return (a = l / (l - p)), e.copy(n).addScaledVector(lr, a)
    const f = c * p - d * h
    if (f <= 0 && h - c >= 0 && d - p >= 0)
      return (
        cr.subVectors(s, i),
        (a = (h - c) / (h - c + (d - p))),
        e.copy(i).addScaledVector(cr, a)
      )
    const g = 1 / (f + m + u)
    return (
      (r = m * g),
      (a = u * g),
      e.copy(n).addScaledVector(or, r).addScaledVector(lr, a)
    )
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
  }
}
const vr = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  },
  yr = { h: 0, s: 0, l: 0 },
  _r = { h: 0, s: 0, l: 0 }
function xr(t, e, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? t + 6 * (e - t) * n
      : n < 0.5
        ? e
        : n < 2 / 3
          ? t + 6 * (e - t) * (2 / 3 - n)
          : t
  )
}
e(xr, 'hue2rgb')
class br {
  static {
    e(this, 'Color')
  }
  constructor(t, e, n) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(t, e, n)
    )
  }
  set(t, e, n) {
    if (void 0 === e && void 0 === n) {
      const e = t
      e && e.isColor
        ? this.copy(e)
        : 'number' == typeof e
          ? this.setHex(e)
          : 'string' == typeof e && this.setStyle(e)
    } else this.setRGB(t, e, n)
    return this
  }
  setScalar(t) {
    return (this.r = t), (this.g = t), (this.b = t), this
  }
  setHex(t, e = En) {
    return (
      (t = Math.floor(t)),
      (this.r = ((t >> 16) & 255) / 255),
      (this.g = ((t >> 8) & 255) / 255),
      (this.b = (255 & t) / 255),
      Pi.toWorkingColorSpace(this, e),
      this
    )
  }
  setRGB(t, e, n, i = Pi.workingColorSpace) {
    return (
      (this.r = t),
      (this.g = e),
      (this.b = n),
      Pi.toWorkingColorSpace(this, i),
      this
    )
  }
  setHSL(t, e, n, i = Pi.workingColorSpace) {
    if (((t = Kn(t, 1)), (e = Zn(e, 0, 1)), (n = Zn(n, 0, 1)), 0 === e))
      this.r = this.g = this.b = n
    else {
      const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
        s = 2 * n - i
      ;(this.r = xr(s, i, t + 1 / 3)),
        (this.g = xr(s, i, t)),
        (this.b = xr(s, i, t - 1 / 3))
    }
    return Pi.toWorkingColorSpace(this, i), this
  }
  setStyle(t, n = En) {
    function i(e) {
      void 0 !== e &&
        parseFloat(e) < 1 &&
        console.warn(
          'THREE.Color: Alpha component of ' + t + ' will be ignored.'
        )
    }
    let s
    if ((e(i, 'handleAlpha'), (s = /^(\w+)\(([^\)]*)\)/.exec(t)))) {
      let e
      const r = s[1],
        a = s[2]
      switch (r) {
        case 'rgb':
        case 'rgba':
          if (
            (e =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(e[4]),
              this.setRGB(
                Math.min(255, parseInt(e[1], 10)) / 255,
                Math.min(255, parseInt(e[2], 10)) / 255,
                Math.min(255, parseInt(e[3], 10)) / 255,
                n
              )
            )
          if (
            (e =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(e[4]),
              this.setRGB(
                Math.min(100, parseInt(e[1], 10)) / 100,
                Math.min(100, parseInt(e[2], 10)) / 100,
                Math.min(100, parseInt(e[3], 10)) / 100,
                n
              )
            )
          break
        case 'hsl':
        case 'hsla':
          if (
            (e =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(e[4]),
              this.setHSL(
                parseFloat(e[1]) / 360,
                parseFloat(e[2]) / 100,
                parseFloat(e[3]) / 100,
                n
              )
            )
          break
        default:
          console.warn('THREE.Color: Unknown color model ' + t)
      }
    } else if ((s = /^\#([A-Fa-f\d]+)$/.exec(t))) {
      const e = s[1],
        i = e.length
      if (3 === i)
        return this.setRGB(
          parseInt(e.charAt(0), 16) / 15,
          parseInt(e.charAt(1), 16) / 15,
          parseInt(e.charAt(2), 16) / 15,
          n
        )
      if (6 === i) return this.setHex(parseInt(e, 16), n)
      console.warn('THREE.Color: Invalid hex color ' + t)
    } else if (t && t.length > 0) return this.setColorName(t, n)
    return this
  }
  setColorName(t, e = En) {
    const n = vr[t.toLowerCase()]
    return (
      void 0 !== n
        ? this.setHex(n, e)
        : console.warn('THREE.Color: Unknown color ' + t),
      this
    )
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b)
  }
  copy(t) {
    return (this.r = t.r), (this.g = t.g), (this.b = t.b), this
  }
  copySRGBToLinear(t) {
    return (this.r = Ii(t.r)), (this.g = Ii(t.g)), (this.b = Ii(t.b)), this
  }
  copyLinearToSRGB(t) {
    return (this.r = Li(t.r)), (this.g = Li(t.g)), (this.b = Li(t.b)), this
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this
  }
  getHex(t = En) {
    return (
      Pi.fromWorkingColorSpace(wr.copy(this), t),
      65536 * Math.round(Zn(255 * wr.r, 0, 255)) +
        256 * Math.round(Zn(255 * wr.g, 0, 255)) +
        Math.round(Zn(255 * wr.b, 0, 255))
    )
  }
  getHexString(t = En) {
    return ('000000' + this.getHex(t).toString(16)).slice(-6)
  }
  getHSL(t, e = Pi.workingColorSpace) {
    Pi.fromWorkingColorSpace(wr.copy(this), e)
    const n = wr.r,
      i = wr.g,
      s = wr.b,
      r = Math.max(n, i, s),
      a = Math.min(n, i, s)
    let o, l
    const c = (a + r) / 2
    if (a === r) (o = 0), (l = 0)
    else {
      const t = r - a
      switch (((l = c <= 0.5 ? t / (r + a) : t / (2 - r - a)), r)) {
        case n:
          o = (i - s) / t + (i < s ? 6 : 0)
          break
        case i:
          o = (s - n) / t + 2
          break
        case s:
          o = (n - i) / t + 4
      }
      o /= 6
    }
    return (t.h = o), (t.s = l), (t.l = c), t
  }
  getRGB(t, e = Pi.workingColorSpace) {
    return (
      Pi.fromWorkingColorSpace(wr.copy(this), e),
      (t.r = wr.r),
      (t.g = wr.g),
      (t.b = wr.b),
      t
    )
  }
  getStyle(t = En) {
    Pi.fromWorkingColorSpace(wr.copy(this), t)
    const e = wr.r,
      n = wr.g,
      i = wr.b
    return t !== En
      ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(255 * i)})`
  }
  offsetHSL(t, e, n) {
    return this.getHSL(yr), this.setHSL(yr.h + t, yr.s + e, yr.l + n)
  }
  add(t) {
    return (this.r += t.r), (this.g += t.g), (this.b += t.b), this
  }
  addColors(t, e) {
    return (
      (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
    )
  }
  addScalar(t) {
    return (this.r += t), (this.g += t), (this.b += t), this
  }
  sub(t) {
    return (
      (this.r = Math.max(0, this.r - t.r)),
      (this.g = Math.max(0, this.g - t.g)),
      (this.b = Math.max(0, this.b - t.b)),
      this
    )
  }
  multiply(t) {
    return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this
  }
  multiplyScalar(t) {
    return (this.r *= t), (this.g *= t), (this.b *= t), this
  }
  lerp(t, e) {
    return (
      (this.r += (t.r - this.r) * e),
      (this.g += (t.g - this.g) * e),
      (this.b += (t.b - this.b) * e),
      this
    )
  }
  lerpColors(t, e, n) {
    return (
      (this.r = t.r + (e.r - t.r) * n),
      (this.g = t.g + (e.g - t.g) * n),
      (this.b = t.b + (e.b - t.b) * n),
      this
    )
  }
  lerpHSL(t, e) {
    this.getHSL(yr), t.getHSL(_r)
    const n = Qn(yr.h, _r.h, e),
      i = Qn(yr.s, _r.s, e),
      s = Qn(yr.l, _r.l, e)
    return this.setHSL(n, i, s), this
  }
  setFromVector3(t) {
    return (this.r = t.x), (this.g = t.y), (this.b = t.z), this
  }
  applyMatrix3(t) {
    const e = this.r,
      n = this.g,
      i = this.b,
      s = t.elements
    return (
      (this.r = s[0] * e + s[3] * n + s[6] * i),
      (this.g = s[1] * e + s[4] * n + s[7] * i),
      (this.b = s[2] * e + s[5] * n + s[8] * i),
      this
    )
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b
  }
  fromArray(t, e = 0) {
    return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t
  }
  fromBufferAttribute(t, e) {
    return (
      (this.r = t.getX(e)), (this.g = t.getY(e)), (this.b = t.getZ(e)), this
    )
  }
  toJSON() {
    return this.getHex()
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b
  }
}
const wr = new br()
br.NAMES = vr
let Mr = 0
class Sr extends Gn {
  static {
    e(this, 'Material')
  }
  static get type() {
    return 'Material'
  }
  get type() {
    return this.constructor.type
  }
  set type(t) {}
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, 'id', { value: Mr++ }),
      (this.uuid = Yn()),
      (this.name = ''),
      (this.blending = 1),
      (this.side = 0),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = 204),
      (this.blendDst = 205),
      (this.blendEquation = Ut),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new br(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = 3),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = 519),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Pn),
      (this.stencilZFail = Pn),
      (this.stencilZPass = Pn),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0)
  }
  get alphaTest() {
    return this._alphaTest
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t)
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString()
  }
  setValues(t) {
    if (void 0 !== t)
      for (const e in t) {
        const n = t[e]
        if (void 0 === n) {
          console.warn(
            `THREE.Material: parameter '${e}' has value of undefined.`
          )
          continue
        }
        const i = this[e]
        void 0 !== i
          ? i && i.isColor
            ? i.set(n)
            : i && i.isVector3 && n && n.isVector3
              ? i.copy(n)
              : (this[e] = n)
          : console.warn(
              `THREE.Material: '${e}' is not a property of THREE.${this.type}.`
            )
      }
  }
  toJSON(t) {
    const n = void 0 === t || 'string' == typeof t
    n && (t = { textures: {}, images: {} })
    const i = {
      metadata: { version: 4.6, type: 'Material', generator: 'Material.toJSON' }
    }
    function s(t) {
      const e = []
      for (const n in t) {
        const i = t[n]
        delete i.metadata, e.push(i)
      }
      return e
    }
    if (
      ((i.uuid = this.uuid),
      (i.type = this.type),
      '' !== this.name && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      void 0 !== this.roughness && (i.roughness = this.roughness),
      void 0 !== this.metalness && (i.metalness = this.metalness),
      void 0 !== this.sheen && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      void 0 !== this.sheenRoughness &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      void 0 !== this.emissiveIntensity &&
        1 !== this.emissiveIntensity &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      void 0 !== this.specularIntensity &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      void 0 !== this.shininess && (i.shininess = this.shininess),
      void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
      void 0 !== this.clearcoatRoughness &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      void 0 !== this.dispersion && (i.dispersion = this.dispersion),
      void 0 !== this.iridescence && (i.iridescence = this.iridescence),
      void 0 !== this.iridescenceIOR &&
        (i.iridescenceIOR = this.iridescenceIOR),
      void 0 !== this.iridescenceThicknessRange &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(t).uuid),
      void 0 !== this.anisotropy && (i.anisotropy = this.anisotropy),
      void 0 !== this.anisotropyRotation &&
        (i.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (i.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(t).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(t).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(t).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(t).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(t).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(t).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(t).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(t).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(t).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(t).uuid),
        void 0 !== this.combine && (i.combine = this.combine)),
      void 0 !== this.envMapRotation &&
        (i.envMapRotation = this.envMapRotation.toArray()),
      void 0 !== this.envMapIntensity &&
        (i.envMapIntensity = this.envMapIntensity),
      void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity),
      void 0 !== this.refractionRatio &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(t).uuid),
      void 0 !== this.transmission && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(t).uuid),
      void 0 !== this.thickness && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(t).uuid),
      void 0 !== this.attenuationDistance &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      void 0 !== this.attenuationColor &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      void 0 !== this.size && (i.size = this.size),
      null !== this.shadowSide && (i.shadowSide = this.shadowSide),
      void 0 !== this.sizeAttenuation &&
        (i.sizeAttenuation = this.sizeAttenuation),
      1 !== this.blending && (i.blending = this.blending),
      0 !== this.side && (i.side = this.side),
      !0 === this.vertexColors && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      !0 === this.transparent && (i.transparent = !0),
      204 !== this.blendSrc && (i.blendSrc = this.blendSrc),
      205 !== this.blendDst && (i.blendDst = this.blendDst),
      this.blendEquation !== Ut && (i.blendEquation = this.blendEquation),
      null !== this.blendSrcAlpha && (i.blendSrcAlpha = this.blendSrcAlpha),
      null !== this.blendDstAlpha && (i.blendDstAlpha = this.blendDstAlpha),
      null !== this.blendEquationAlpha &&
        (i.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (i.blendColor = this.blendColor.getHex()),
      0 !== this.blendAlpha && (i.blendAlpha = this.blendAlpha),
      3 !== this.depthFunc && (i.depthFunc = this.depthFunc),
      !1 === this.depthTest && (i.depthTest = this.depthTest),
      !1 === this.depthWrite && (i.depthWrite = this.depthWrite),
      !1 === this.colorWrite && (i.colorWrite = this.colorWrite),
      255 !== this.stencilWriteMask &&
        (i.stencilWriteMask = this.stencilWriteMask),
      519 !== this.stencilFunc && (i.stencilFunc = this.stencilFunc),
      0 !== this.stencilRef && (i.stencilRef = this.stencilRef),
      255 !== this.stencilFuncMask &&
        (i.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== Pn && (i.stencilFail = this.stencilFail),
      this.stencilZFail !== Pn && (i.stencilZFail = this.stencilZFail),
      this.stencilZPass !== Pn && (i.stencilZPass = this.stencilZPass),
      !0 === this.stencilWrite && (i.stencilWrite = this.stencilWrite),
      void 0 !== this.rotation &&
        0 !== this.rotation &&
        (i.rotation = this.rotation),
      !0 === this.polygonOffset && (i.polygonOffset = !0),
      0 !== this.polygonOffsetFactor &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      0 !== this.polygonOffsetUnits &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      void 0 !== this.linewidth &&
        1 !== this.linewidth &&
        (i.linewidth = this.linewidth),
      void 0 !== this.dashSize && (i.dashSize = this.dashSize),
      void 0 !== this.gapSize && (i.gapSize = this.gapSize),
      void 0 !== this.scale && (i.scale = this.scale),
      !0 === this.dithering && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      !0 === this.alphaHash && (i.alphaHash = !0),
      !0 === this.alphaToCoverage && (i.alphaToCoverage = !0),
      !0 === this.premultipliedAlpha && (i.premultipliedAlpha = !0),
      !0 === this.forceSinglePass && (i.forceSinglePass = !0),
      !0 === this.wireframe && (i.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      'round' !== this.wireframeLinecap &&
        (i.wireframeLinecap = this.wireframeLinecap),
      'round' !== this.wireframeLinejoin &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      !0 === this.flatShading && (i.flatShading = !0),
      !1 === this.visible && (i.visible = !1),
      !1 === this.toneMapped && (i.toneMapped = !1),
      !1 === this.fog && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      e(s, 'extractFromCache'),
      n)
    ) {
      const e = s(t.textures),
        n = s(t.images)
      e.length > 0 && (i.textures = e), n.length > 0 && (i.images = n)
    }
    return i
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    ;(this.name = t.name),
      (this.blending = t.blending),
      (this.side = t.side),
      (this.vertexColors = t.vertexColors),
      (this.opacity = t.opacity),
      (this.transparent = t.transparent),
      (this.blendSrc = t.blendSrc),
      (this.blendDst = t.blendDst),
      (this.blendEquation = t.blendEquation),
      (this.blendSrcAlpha = t.blendSrcAlpha),
      (this.blendDstAlpha = t.blendDstAlpha),
      (this.blendEquationAlpha = t.blendEquationAlpha),
      this.blendColor.copy(t.blendColor),
      (this.blendAlpha = t.blendAlpha),
      (this.depthFunc = t.depthFunc),
      (this.depthTest = t.depthTest),
      (this.depthWrite = t.depthWrite),
      (this.stencilWriteMask = t.stencilWriteMask),
      (this.stencilFunc = t.stencilFunc),
      (this.stencilRef = t.stencilRef),
      (this.stencilFuncMask = t.stencilFuncMask),
      (this.stencilFail = t.stencilFail),
      (this.stencilZFail = t.stencilZFail),
      (this.stencilZPass = t.stencilZPass),
      (this.stencilWrite = t.stencilWrite)
    const e = t.clippingPlanes
    let n = null
    if (null !== e) {
      const t = e.length
      n = new Array(t)
      for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = t.clipIntersection),
      (this.clipShadows = t.clipShadows),
      (this.shadowSide = t.shadowSide),
      (this.colorWrite = t.colorWrite),
      (this.precision = t.precision),
      (this.polygonOffset = t.polygonOffset),
      (this.polygonOffsetFactor = t.polygonOffsetFactor),
      (this.polygonOffsetUnits = t.polygonOffsetUnits),
      (this.dithering = t.dithering),
      (this.alphaTest = t.alphaTest),
      (this.alphaHash = t.alphaHash),
      (this.alphaToCoverage = t.alphaToCoverage),
      (this.premultipliedAlpha = t.premultipliedAlpha),
      (this.forceSinglePass = t.forceSinglePass),
      (this.visible = t.visible),
      (this.toneMapped = t.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
  set needsUpdate(t) {
    !0 === t && this.version++
  }
  onBuild() {
    console.warn('Material: onBuild() has been removed.')
  }
}
class Tr extends Sr {
  static {
    e(this, 'MeshBasicMaterial')
  }
  static get type() {
    return 'MeshBasicMaterial'
  }
  constructor(t) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.color = new br(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Fs()),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      this.envMapRotation.copy(t.envMapRotation),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.fog = t.fog),
      this
    )
  }
}
const Er = Ar()
function Ar() {
  const t = new ArrayBuffer(4),
    e = new Float32Array(t),
    n = new Uint32Array(t),
    i = new Uint32Array(512),
    s = new Uint32Array(512)
  for (let l = 0; l < 256; ++l) {
    const t = l - 127
    t < -27
      ? ((i[l] = 0), (i[256 | l] = 32768), (s[l] = 24), (s[256 | l] = 24))
      : t < -14
        ? ((i[l] = 1024 >> (-t - 14)),
          (i[256 | l] = (1024 >> (-t - 14)) | 32768),
          (s[l] = -t - 1),
          (s[256 | l] = -t - 1))
        : t <= 15
          ? ((i[l] = (t + 15) << 10),
            (i[256 | l] = ((t + 15) << 10) | 32768),
            (s[l] = 13),
            (s[256 | l] = 13))
          : t < 128
            ? ((i[l] = 31744),
              (i[256 | l] = 64512),
              (s[l] = 24),
              (s[256 | l] = 24))
            : ((i[l] = 31744),
              (i[256 | l] = 64512),
              (s[l] = 13),
              (s[256 | l] = 13))
  }
  const r = new Uint32Array(2048),
    a = new Uint32Array(64),
    o = new Uint32Array(64)
  for (let l = 1; l < 1024; ++l) {
    let t = l << 13,
      e = 0
    for (; !(8388608 & t); ) (t <<= 1), (e -= 8388608)
    ;(t &= -8388609), (e += 947912704), (r[l] = t | e)
  }
  for (let l = 1024; l < 2048; ++l) r[l] = 939524096 + ((l - 1024) << 13)
  for (let l = 1; l < 31; ++l) a[l] = l << 23
  ;(a[31] = 1199570944), (a[32] = 2147483648)
  for (let l = 33; l < 63; ++l) a[l] = 2147483648 + ((l - 32) << 23)
  a[63] = 3347054592
  for (let l = 1; l < 64; ++l) 32 !== l && (o[l] = 1024)
  return {
    floatView: e,
    uint32View: n,
    baseTable: i,
    shiftTable: s,
    mantissaTable: r,
    exponentTable: a,
    offsetTable: o
  }
}
function Cr(t) {
  Math.abs(t) > 65504 &&
    console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.'),
    (t = Zn(t, -65504, 65504)),
    (Er.floatView[0] = t)
  const e = Er.uint32View[0],
    n = (e >> 23) & 511
  return Er.baseTable[n] + ((8388607 & e) >> Er.shiftTable[n])
}
function Rr(t) {
  const e = t >> 10
  return (
    (Er.uint32View[0] =
      Er.mantissaTable[Er.offsetTable[e] + (1023 & t)] + Er.exponentTable[e]),
    Er.floatView[0]
  )
}
e(Ar, '_generateTables'), e(Cr, 'toHalfFloat'), e(Rr, 'fromHalfFloat')
const Pr = new Qi(),
  Ir = new vi()
class Lr {
  static {
    e(this, 'BufferAttribute')
  }
  constructor(t, e, n = !1) {
    if (Array.isArray(t))
      throw new TypeError(
        'THREE.BufferAttribute: array should be a Typed Array.'
      )
    ;(this.isBufferAttribute = !0),
      (this.name = ''),
      (this.array = t),
      (this.itemSize = e),
      (this.count = void 0 !== t ? t.length / e : 0),
      (this.normalized = n),
      (this.usage = Fn),
      (this.updateRanges = []),
      (this.gpuType = Ae),
      (this.version = 0)
  }
  onUploadCallback() {}
  set needsUpdate(t) {
    !0 === t && this.version++
  }
  setUsage(t) {
    return (this.usage = t), this
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({ start: t, count: e })
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.array = new t.array.constructor(t.array)),
      (this.itemSize = t.itemSize),
      (this.count = t.count),
      (this.normalized = t.normalized),
      (this.usage = t.usage),
      (this.gpuType = t.gpuType),
      this
    )
  }
  copyAt(t, e, n) {
    ;(t *= this.itemSize), (n *= e.itemSize)
    for (let i = 0, s = this.itemSize; i < s; i++)
      this.array[t + i] = e.array[n + i]
    return this
  }
  copyArray(t) {
    return this.array.set(t), this
  }
  applyMatrix3(t) {
    if (2 === this.itemSize)
      for (let e = 0, n = this.count; e < n; e++)
        Ir.fromBufferAttribute(this, e),
          Ir.applyMatrix3(t),
          this.setXY(e, Ir.x, Ir.y)
    else if (3 === this.itemSize)
      for (let e = 0, n = this.count; e < n; e++)
        Pr.fromBufferAttribute(this, e),
          Pr.applyMatrix3(t),
          this.setXYZ(e, Pr.x, Pr.y, Pr.z)
    return this
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.count; e < n; e++)
      Pr.fromBufferAttribute(this, e),
        Pr.applyMatrix4(t),
        this.setXYZ(e, Pr.x, Pr.y, Pr.z)
    return this
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      Pr.fromBufferAttribute(this, e),
        Pr.applyNormalMatrix(t),
        this.setXYZ(e, Pr.x, Pr.y, Pr.z)
    return this
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      Pr.fromBufferAttribute(this, e),
        Pr.transformDirection(t),
        this.setXYZ(e, Pr.x, Pr.y, Pr.z)
    return this
  }
  set(t, e = 0) {
    return this.array.set(t, e), this
  }
  getComponent(t, e) {
    let n = this.array[t * this.itemSize + e]
    return this.normalized && (n = mi(n, this.array)), n
  }
  setComponent(t, e, n) {
    return (
      this.normalized && (n = fi(n, this.array)),
      (this.array[t * this.itemSize + e] = n),
      this
    )
  }
  getX(t) {
    let e = this.array[t * this.itemSize]
    return this.normalized && (e = mi(e, this.array)), e
  }
  setX(t, e) {
    return (
      this.normalized && (e = fi(e, this.array)),
      (this.array[t * this.itemSize] = e),
      this
    )
  }
  getY(t) {
    let e = this.array[t * this.itemSize + 1]
    return this.normalized && (e = mi(e, this.array)), e
  }
  setY(t, e) {
    return (
      this.normalized && (e = fi(e, this.array)),
      (this.array[t * this.itemSize + 1] = e),
      this
    )
  }
  getZ(t) {
    let e = this.array[t * this.itemSize + 2]
    return this.normalized && (e = mi(e, this.array)), e
  }
  setZ(t, e) {
    return (
      this.normalized && (e = fi(e, this.array)),
      (this.array[t * this.itemSize + 2] = e),
      this
    )
  }
  getW(t) {
    let e = this.array[t * this.itemSize + 3]
    return this.normalized && (e = mi(e, this.array)), e
  }
  setW(t, e) {
    return (
      this.normalized && (e = fi(e, this.array)),
      (this.array[t * this.itemSize + 3] = e),
      this
    )
  }
  setXY(t, e, n) {
    return (
      (t *= this.itemSize),
      this.normalized && ((e = fi(e, this.array)), (n = fi(n, this.array))),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      this
    )
  }
  setXYZ(t, e, n, i) {
    return (
      (t *= this.itemSize),
      this.normalized &&
        ((e = fi(e, this.array)),
        (n = fi(n, this.array)),
        (i = fi(i, this.array))),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      (this.array[t + 2] = i),
      this
    )
  }
  setXYZW(t, e, n, i, s) {
    return (
      (t *= this.itemSize),
      this.normalized &&
        ((e = fi(e, this.array)),
        (n = fi(n, this.array)),
        (i = fi(i, this.array)),
        (s = fi(s, this.array))),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      (this.array[t + 2] = i),
      (this.array[t + 3] = s),
      this
    )
  }
  onUpload(t) {
    return (this.onUploadCallback = t), this
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this)
  }
  toJSON() {
    const t = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    }
    return (
      '' !== this.name && (t.name = this.name),
      this.usage !== Fn && (t.usage = this.usage),
      t
    )
  }
}
class Dr extends Lr {
  static {
    e(this, 'Int8BufferAttribute')
  }
  constructor(t, e, n) {
    super(new Int8Array(t), e, n)
  }
}
class kr extends Lr {
  static {
    e(this, 'Uint8BufferAttribute')
  }
  constructor(t, e, n) {
    super(new Uint8Array(t), e, n)
  }
}
class Nr extends Lr {
  static {
    e(this, 'Uint8ClampedBufferAttribute')
  }
  constructor(t, e, n) {
    super(new Uint8ClampedArray(t), e, n)
  }
}
class Ur extends Lr {
  static {
    e(this, 'Int16BufferAttribute')
  }
  constructor(t, e, n) {
    super(new Int16Array(t), e, n)
  }
}
class Br extends Lr {
  static {
    e(this, 'Uint16BufferAttribute')
  }
  constructor(t, e, n) {
    super(new Uint16Array(t), e, n)
  }
}
class Or extends Lr {
  static {
    e(this, 'Int32BufferAttribute')
  }
  constructor(t, e, n) {
    super(new Int32Array(t), e, n)
  }
}
class Fr extends Lr {
  static {
    e(this, 'Uint32BufferAttribute')
  }
  constructor(t, e, n) {
    super(new Uint32Array(t), e, n)
  }
}
class zr extends Lr {
  static {
    e(this, 'Float16BufferAttribute')
  }
  constructor(t, e, n) {
    super(new Uint16Array(t), e, n), (this.isFloat16BufferAttribute = !0)
  }
  getX(t) {
    let e = Rr(this.array[t * this.itemSize])
    return this.normalized && (e = mi(e, this.array)), e
  }
  setX(t, e) {
    return (
      this.normalized && (e = fi(e, this.array)),
      (this.array[t * this.itemSize] = Cr(e)),
      this
    )
  }
  getY(t) {
    let e = Rr(this.array[t * this.itemSize + 1])
    return this.normalized && (e = mi(e, this.array)), e
  }
  setY(t, e) {
    return (
      this.normalized && (e = fi(e, this.array)),
      (this.array[t * this.itemSize + 1] = Cr(e)),
      this
    )
  }
  getZ(t) {
    let e = Rr(this.array[t * this.itemSize + 2])
    return this.normalized && (e = mi(e, this.array)), e
  }
  setZ(t, e) {
    return (
      this.normalized && (e = fi(e, this.array)),
      (this.array[t * this.itemSize + 2] = Cr(e)),
      this
    )
  }
  getW(t) {
    let e = Rr(this.array[t * this.itemSize + 3])
    return this.normalized && (e = mi(e, this.array)), e
  }
  setW(t, e) {
    return (
      this.normalized && (e = fi(e, this.array)),
      (this.array[t * this.itemSize + 3] = Cr(e)),
      this
    )
  }
  setXY(t, e, n) {
    return (
      (t *= this.itemSize),
      this.normalized && ((e = fi(e, this.array)), (n = fi(n, this.array))),
      (this.array[t + 0] = Cr(e)),
      (this.array[t + 1] = Cr(n)),
      this
    )
  }
  setXYZ(t, e, n, i) {
    return (
      (t *= this.itemSize),
      this.normalized &&
        ((e = fi(e, this.array)),
        (n = fi(n, this.array)),
        (i = fi(i, this.array))),
      (this.array[t + 0] = Cr(e)),
      (this.array[t + 1] = Cr(n)),
      (this.array[t + 2] = Cr(i)),
      this
    )
  }
  setXYZW(t, e, n, i, s) {
    return (
      (t *= this.itemSize),
      this.normalized &&
        ((e = fi(e, this.array)),
        (n = fi(n, this.array)),
        (i = fi(i, this.array)),
        (s = fi(s, this.array))),
      (this.array[t + 0] = Cr(e)),
      (this.array[t + 1] = Cr(n)),
      (this.array[t + 2] = Cr(i)),
      (this.array[t + 3] = Cr(s)),
      this
    )
  }
}
class Vr extends Lr {
  static {
    e(this, 'Float32BufferAttribute')
  }
  constructor(t, e, n) {
    super(new Float32Array(t), e, n)
  }
}
let Hr = 0
const Gr = new Rs(),
  Wr = new nr(),
  jr = new Qi(),
  Xr = new ns(),
  qr = new ns(),
  Yr = new Qi()
class Zr extends Gn {
  static {
    e(this, 'BufferGeometry')
  }
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, 'id', { value: Hr++ }),
      (this.uuid = Yn()),
      (this.name = ''),
      (this.type = 'BufferGeometry'),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {})
  }
  getIndex() {
    return this.index
  }
  setIndex(t) {
    return (
      Array.isArray(t)
        ? (this.index = new (xi(t) ? Fr : Br)(t, 1))
        : (this.index = t),
      this
    )
  }
  setIndirect(t) {
    return (this.indirect = t), this
  }
  getIndirect() {
    return this.indirect
  }
  getAttribute(t) {
    return this.attributes[t]
  }
  setAttribute(t, e) {
    return (this.attributes[t] = e), this
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this
  }
  hasAttribute(t) {
    return void 0 !== this.attributes[t]
  }
  addGroup(t, e, n = 0) {
    this.groups.push({ start: t, count: e, materialIndex: n })
  }
  clearGroups() {
    this.groups = []
  }
  setDrawRange(t, e) {
    ;(this.drawRange.start = t), (this.drawRange.count = e)
  }
  applyMatrix4(t) {
    const e = this.attributes.position
    void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0))
    const n = this.attributes.normal
    if (void 0 !== n) {
      const e = new yi().getNormalMatrix(t)
      n.applyNormalMatrix(e), (n.needsUpdate = !0)
    }
    const i = this.attributes.tangent
    return (
      void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
      null !== this.boundingBox && this.computeBoundingBox(),
      null !== this.boundingSphere && this.computeBoundingSphere(),
      this
    )
  }
  applyQuaternion(t) {
    return Gr.makeRotationFromQuaternion(t), this.applyMatrix4(Gr), this
  }
  rotateX(t) {
    return Gr.makeRotationX(t), this.applyMatrix4(Gr), this
  }
  rotateY(t) {
    return Gr.makeRotationY(t), this.applyMatrix4(Gr), this
  }
  rotateZ(t) {
    return Gr.makeRotationZ(t), this.applyMatrix4(Gr), this
  }
  translate(t, e, n) {
    return Gr.makeTranslation(t, e, n), this.applyMatrix4(Gr), this
  }
  scale(t, e, n) {
    return Gr.makeScale(t, e, n), this.applyMatrix4(Gr), this
  }
  lookAt(t) {
    return Wr.lookAt(t), Wr.updateMatrix(), this.applyMatrix4(Wr.matrix), this
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(jr).negate(),
      this.translate(jr.x, jr.y, jr.z),
      this
    )
  }
  setFromPoints(t) {
    const e = this.getAttribute('position')
    if (void 0 === e) {
      const e = []
      for (let n = 0, i = t.length; n < i; n++) {
        const i = t[n]
        e.push(i.x, i.y, i.z || 0)
      }
      this.setAttribute('position', new Vr(e, 3))
    } else {
      for (let n = 0, i = e.count; n < i; n++) {
        const i = t[n]
        e.setXYZ(n, i.x, i.y, i.z || 0)
      }
      t.length > e.count &&
        console.warn(
          'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.'
        ),
        (e.needsUpdate = !0)
    }
    return this
  }
  computeBoundingBox() {
    null === this.boundingBox && (this.boundingBox = new ns())
    const t = this.attributes.position,
      e = this.morphAttributes.position
    if (t && t.isGLBufferAttribute)
      return (
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.',
          this
        ),
        void this.boundingBox.set(
          new Qi(-1 / 0, -1 / 0, -1 / 0),
          new Qi(1 / 0, 1 / 0, 1 / 0)
        )
      )
    if (void 0 !== t) {
      if ((this.boundingBox.setFromBufferAttribute(t), e))
        for (let n = 0, i = e.length; n < i; n++) {
          const t = e[n]
          Xr.setFromBufferAttribute(t),
            this.morphTargetsRelative
              ? (Yr.addVectors(this.boundingBox.min, Xr.min),
                this.boundingBox.expandByPoint(Yr),
                Yr.addVectors(this.boundingBox.max, Xr.max),
                this.boundingBox.expandByPoint(Yr))
              : (this.boundingBox.expandByPoint(Xr.min),
                this.boundingBox.expandByPoint(Xr.max))
        }
    } else this.boundingBox.makeEmpty()
    ;(isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      )
  }
  computeBoundingSphere() {
    null === this.boundingSphere && (this.boundingSphere = new xs())
    const t = this.attributes.position,
      e = this.morphAttributes.position
    if (t && t.isGLBufferAttribute)
      return (
        console.error(
          'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.',
          this
        ),
        void this.boundingSphere.set(new Qi(), 1 / 0)
      )
    if (t) {
      const n = this.boundingSphere.center
      if ((Xr.setFromBufferAttribute(t), e))
        for (let t = 0, s = e.length; t < s; t++) {
          const n = e[t]
          qr.setFromBufferAttribute(n),
            this.morphTargetsRelative
              ? (Yr.addVectors(Xr.min, qr.min),
                Xr.expandByPoint(Yr),
                Yr.addVectors(Xr.max, qr.max),
                Xr.expandByPoint(Yr))
              : (Xr.expandByPoint(qr.min), Xr.expandByPoint(qr.max))
        }
      Xr.getCenter(n)
      let i = 0
      for (let e = 0, s = t.count; e < s; e++)
        Yr.fromBufferAttribute(t, e), (i = Math.max(i, n.distanceToSquared(Yr)))
      if (e)
        for (let s = 0, r = e.length; s < r; s++) {
          const r = e[s],
            a = this.morphTargetsRelative
          for (let e = 0, s = r.count; e < s; e++)
            Yr.fromBufferAttribute(r, e),
              a && (jr.fromBufferAttribute(t, e), Yr.add(jr)),
              (i = Math.max(i, n.distanceToSquared(Yr)))
        }
      ;(this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          )
    }
  }
  computeTangents() {
    const t = this.index,
      n = this.attributes
    if (
      null === t ||
      void 0 === n.position ||
      void 0 === n.normal ||
      void 0 === n.uv
    )
      return void console.error(
        'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)'
      )
    const i = n.position,
      s = n.normal,
      r = n.uv
    !1 === this.hasAttribute('tangent') &&
      this.setAttribute('tangent', new Lr(new Float32Array(4 * i.count), 4))
    const a = this.getAttribute('tangent'),
      o = [],
      l = []
    for (let e = 0; e < i.count; e++) (o[e] = new Qi()), (l[e] = new Qi())
    const c = new Qi(),
      h = new Qi(),
      u = new Qi(),
      d = new vi(),
      p = new vi(),
      m = new vi(),
      f = new Qi(),
      g = new Qi()
    function v(t, e, n) {
      c.fromBufferAttribute(i, t),
        h.fromBufferAttribute(i, e),
        u.fromBufferAttribute(i, n),
        d.fromBufferAttribute(r, t),
        p.fromBufferAttribute(r, e),
        m.fromBufferAttribute(r, n),
        h.sub(c),
        u.sub(c),
        p.sub(d),
        m.sub(d)
      const s = 1 / (p.x * m.y - m.x * p.y)
      isFinite(s) &&
        (f
          .copy(h)
          .multiplyScalar(m.y)
          .addScaledVector(u, -p.y)
          .multiplyScalar(s),
        g
          .copy(u)
          .multiplyScalar(p.x)
          .addScaledVector(h, -m.x)
          .multiplyScalar(s),
        o[t].add(f),
        o[e].add(f),
        o[n].add(f),
        l[t].add(g),
        l[e].add(g),
        l[n].add(g))
    }
    e(v, 'handleTriangle')
    let y = this.groups
    0 === y.length && (y = [{ start: 0, count: t.count }])
    for (let e = 0, S = y.length; e < S; ++e) {
      const n = y[e],
        i = n.start
      for (let e = i, s = i + n.count; e < s; e += 3)
        v(t.getX(e + 0), t.getX(e + 1), t.getX(e + 2))
    }
    const _ = new Qi(),
      x = new Qi(),
      b = new Qi(),
      w = new Qi()
    function M(t) {
      b.fromBufferAttribute(s, t), w.copy(b)
      const e = o[t]
      _.copy(e),
        _.sub(b.multiplyScalar(b.dot(e))).normalize(),
        x.crossVectors(w, e)
      const n = x.dot(l[t]) < 0 ? -1 : 1
      a.setXYZW(t, _.x, _.y, _.z, n)
    }
    e(M, 'handleVertex')
    for (let e = 0, S = y.length; e < S; ++e) {
      const n = y[e],
        i = n.start
      for (let e = i, s = i + n.count; e < s; e += 3)
        M(t.getX(e + 0)), M(t.getX(e + 1)), M(t.getX(e + 2))
    }
  }
  computeVertexNormals() {
    const t = this.index,
      e = this.getAttribute('position')
    if (void 0 !== e) {
      let n = this.getAttribute('normal')
      if (void 0 === n)
        (n = new Lr(new Float32Array(3 * e.count), 3)),
          this.setAttribute('normal', n)
      else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0)
      const i = new Qi(),
        s = new Qi(),
        r = new Qi(),
        a = new Qi(),
        o = new Qi(),
        l = new Qi(),
        c = new Qi(),
        h = new Qi()
      if (t)
        for (let u = 0, d = t.count; u < d; u += 3) {
          const d = t.getX(u + 0),
            p = t.getX(u + 1),
            m = t.getX(u + 2)
          i.fromBufferAttribute(e, d),
            s.fromBufferAttribute(e, p),
            r.fromBufferAttribute(e, m),
            c.subVectors(r, s),
            h.subVectors(i, s),
            c.cross(h),
            a.fromBufferAttribute(n, d),
            o.fromBufferAttribute(n, p),
            l.fromBufferAttribute(n, m),
            a.add(c),
            o.add(c),
            l.add(c),
            n.setXYZ(d, a.x, a.y, a.z),
            n.setXYZ(p, o.x, o.y, o.z),
            n.setXYZ(m, l.x, l.y, l.z)
        }
      else
        for (let t = 0, u = e.count; t < u; t += 3)
          i.fromBufferAttribute(e, t + 0),
            s.fromBufferAttribute(e, t + 1),
            r.fromBufferAttribute(e, t + 2),
            c.subVectors(r, s),
            h.subVectors(i, s),
            c.cross(h),
            n.setXYZ(t + 0, c.x, c.y, c.z),
            n.setXYZ(t + 1, c.x, c.y, c.z),
            n.setXYZ(t + 2, c.x, c.y, c.z)
      this.normalizeNormals(), (n.needsUpdate = !0)
    }
  }
  normalizeNormals() {
    const t = this.attributes.normal
    for (let e = 0, n = t.count; e < n; e++)
      Yr.fromBufferAttribute(t, e),
        Yr.normalize(),
        t.setXYZ(e, Yr.x, Yr.y, Yr.z)
  }
  toNonIndexed() {
    function t(t, e) {
      const n = t.array,
        i = t.itemSize,
        s = t.normalized,
        r = new n.constructor(e.length * i)
      let a = 0,
        o = 0
      for (let l = 0, c = e.length; l < c; l++) {
        a = t.isInterleavedBufferAttribute
          ? e[l] * t.data.stride + t.offset
          : e[l] * i
        for (let t = 0; t < i; t++) r[o++] = n[a++]
      }
      return new Lr(r, i, s)
    }
    if ((e(t, 'convertBufferAttribute'), null === this.index))
      return (
        console.warn(
          'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'
        ),
        this
      )
    const n = new Zr(),
      i = this.index.array,
      s = this.attributes
    for (const e in s) {
      const r = t(s[e], i)
      n.setAttribute(e, r)
    }
    const r = this.morphAttributes
    for (const e in r) {
      const s = [],
        a = r[e]
      for (let e = 0, n = a.length; e < n; e++) {
        const n = t(a[e], i)
        s.push(n)
      }
      n.morphAttributes[e] = s
    }
    n.morphTargetsRelative = this.morphTargetsRelative
    const a = this.groups
    for (let e = 0, o = a.length; e < o; e++) {
      const t = a[e]
      n.addGroup(t.start, t.count, t.materialIndex)
    }
    return n
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    }
    if (
      ((t.uuid = this.uuid),
      (t.type = this.type),
      '' !== this.name && (t.name = this.name),
      Object.keys(this.userData).length > 0 && (t.userData = this.userData),
      void 0 !== this.parameters)
    ) {
      const e = this.parameters
      for (const n in e) void 0 !== e[n] && (t[n] = e[n])
      return t
    }
    t.data = { attributes: {} }
    const e = this.index
    null !== e &&
      (t.data.index = {
        type: e.array.constructor.name,
        array: Array.prototype.slice.call(e.array)
      })
    const n = this.attributes
    for (const o in n) {
      const e = n[o]
      t.data.attributes[o] = e.toJSON(t.data)
    }
    const i = {}
    let s = !1
    for (const o in this.morphAttributes) {
      const e = this.morphAttributes[o],
        n = []
      for (let i = 0, s = e.length; i < s; i++) {
        const s = e[i]
        n.push(s.toJSON(t.data))
      }
      n.length > 0 && ((i[o] = n), (s = !0))
    }
    s &&
      ((t.data.morphAttributes = i),
      (t.data.morphTargetsRelative = this.morphTargetsRelative))
    const r = this.groups
    r.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(r)))
    const a = this.boundingSphere
    return (
      null !== a &&
        (t.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius
        }),
      t
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    ;(this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null)
    const e = {}
    this.name = t.name
    const n = t.index
    null !== n && this.setIndex(n.clone(e))
    const i = t.attributes
    for (const l in i) {
      const t = i[l]
      this.setAttribute(l, t.clone(e))
    }
    const s = t.morphAttributes
    for (const l in s) {
      const t = [],
        n = s[l]
      for (let i = 0, s = n.length; i < s; i++) t.push(n[i].clone(e))
      this.morphAttributes[l] = t
    }
    this.morphTargetsRelative = t.morphTargetsRelative
    const r = t.groups
    for (let l = 0, c = r.length; l < c; l++) {
      const t = r[l]
      this.addGroup(t.start, t.count, t.materialIndex)
    }
    const a = t.boundingBox
    null !== a && (this.boundingBox = a.clone())
    const o = t.boundingSphere
    return (
      null !== o && (this.boundingSphere = o.clone()),
      (this.drawRange.start = t.drawRange.start),
      (this.drawRange.count = t.drawRange.count),
      (this.userData = t.userData),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
}
const Kr = new Rs(),
  $r = new Cs(),
  Jr = new xs(),
  Qr = new Qi(),
  ta = new Qi(),
  ea = new Qi(),
  na = new Qi(),
  ia = new Qi(),
  sa = new Qi(),
  ra = new Qi(),
  aa = new Qi()
class oa extends nr {
  static {
    e(this, 'Mesh')
  }
  constructor(t = new Zr(), e = new Tr()) {
    super(),
      (this.isMesh = !0),
      (this.type = 'Mesh'),
      (this.geometry = t),
      (this.material = e),
      this.updateMorphTargets()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      void 0 !== t.morphTargetInfluences &&
        (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
      void 0 !== t.morphTargetDictionary &&
        (this.morphTargetDictionary = Object.assign(
          {},
          t.morphTargetDictionary
        )),
      (this.material = Array.isArray(t.material)
        ? t.material.slice()
        : t.material),
      (this.geometry = t.geometry),
      this
    )
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      e = Object.keys(t)
    if (e.length > 0) {
      const n = t[e[0]]
      if (void 0 !== n) {
        ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
        for (let t = 0, e = n.length; t < e; t++) {
          const e = n[t].name || String(t)
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[e] = t)
        }
      }
    }
  }
  getVertexPosition(t, e) {
    const n = this.geometry,
      i = n.attributes.position,
      s = n.morphAttributes.position,
      r = n.morphTargetsRelative
    e.fromBufferAttribute(i, t)
    const a = this.morphTargetInfluences
    if (s && a) {
      sa.set(0, 0, 0)
      for (let n = 0, i = s.length; n < i; n++) {
        const i = a[n],
          o = s[n]
        0 !== i &&
          (ia.fromBufferAttribute(o, t),
          r ? sa.addScaledVector(ia, i) : sa.addScaledVector(ia.sub(e), i))
      }
      e.add(sa)
    }
    return e
  }
  raycast(t, e) {
    const n = this.geometry,
      i = this.material,
      s = this.matrixWorld
    if (void 0 !== i) {
      if (
        (null === n.boundingSphere && n.computeBoundingSphere(),
        Jr.copy(n.boundingSphere),
        Jr.applyMatrix4(s),
        $r.copy(t.ray).recast(t.near),
        !1 === Jr.containsPoint($r.origin))
      ) {
        if (null === $r.intersectSphere(Jr, Qr)) return
        if ($r.origin.distanceToSquared(Qr) > (t.far - t.near) ** 2) return
      }
      Kr.copy(s).invert(),
        $r.copy(t.ray).applyMatrix4(Kr),
        (null !== n.boundingBox && !1 === $r.intersectsBox(n.boundingBox)) ||
          this._computeIntersections(t, e, $r)
    }
  }
  _computeIntersections(t, e, n) {
    let i
    const s = this.geometry,
      r = this.material,
      a = s.index,
      o = s.attributes.position,
      l = s.attributes.uv,
      c = s.attributes.uv1,
      h = s.attributes.normal,
      u = s.groups,
      d = s.drawRange
    if (null !== a)
      if (Array.isArray(r))
        for (let p = 0, m = u.length; p < m; p++) {
          const s = u[p],
            o = r[s.materialIndex]
          for (
            let r = Math.max(s.start, d.start),
              u = Math.min(
                a.count,
                Math.min(s.start + s.count, d.start + d.count)
              );
            r < u;
            r += 3
          ) {
            ;(i = ca(
              this,
              o,
              t,
              n,
              l,
              c,
              h,
              a.getX(r),
              a.getX(r + 1),
              a.getX(r + 2)
            )),
              i &&
                ((i.faceIndex = Math.floor(r / 3)),
                (i.face.materialIndex = s.materialIndex),
                e.push(i))
          }
        }
      else {
        for (
          let s = Math.max(0, d.start),
            o = Math.min(a.count, d.start + d.count);
          s < o;
          s += 3
        ) {
          ;(i = ca(
            this,
            r,
            t,
            n,
            l,
            c,
            h,
            a.getX(s),
            a.getX(s + 1),
            a.getX(s + 2)
          )),
            i && ((i.faceIndex = Math.floor(s / 3)), e.push(i))
        }
      }
    else if (void 0 !== o)
      if (Array.isArray(r))
        for (let p = 0, m = u.length; p < m; p++) {
          const s = u[p],
            a = r[s.materialIndex]
          for (
            let r = Math.max(s.start, d.start),
              u = Math.min(
                o.count,
                Math.min(s.start + s.count, d.start + d.count)
              );
            r < u;
            r += 3
          ) {
            ;(i = ca(this, a, t, n, l, c, h, r, r + 1, r + 2)),
              i &&
                ((i.faceIndex = Math.floor(r / 3)),
                (i.face.materialIndex = s.materialIndex),
                e.push(i))
          }
        }
      else {
        for (
          let s = Math.max(0, d.start),
            a = Math.min(o.count, d.start + d.count);
          s < a;
          s += 3
        ) {
          ;(i = ca(this, r, t, n, l, c, h, s, s + 1, s + 2)),
            i && ((i.faceIndex = Math.floor(s / 3)), e.push(i))
        }
      }
  }
}
function la(t, e, n, i, s, r, a, o) {
  let l
  if (
    ((l =
      1 === e.side
        ? i.intersectTriangle(a, r, s, !0, o)
        : i.intersectTriangle(s, r, a, 0 === e.side, o)),
    null === l)
  )
    return null
  aa.copy(o), aa.applyMatrix4(t.matrixWorld)
  const c = n.ray.origin.distanceTo(aa)
  return c < n.near || c > n.far
    ? null
    : { distance: c, point: aa.clone(), object: t }
}
function ca(t, e, n, i, s, r, a, o, l, c) {
  t.getVertexPosition(o, ta),
    t.getVertexPosition(l, ea),
    t.getVertexPosition(c, na)
  const h = la(t, e, n, i, ta, ea, na, ra)
  if (h) {
    const t = new Qi()
    gr.getBarycoord(ra, ta, ea, na, t),
      s && (h.uv = gr.getInterpolatedAttribute(s, o, l, c, t, new vi())),
      r && (h.uv1 = gr.getInterpolatedAttribute(r, o, l, c, t, new vi())),
      a &&
        ((h.normal = gr.getInterpolatedAttribute(a, o, l, c, t, new Qi())),
        h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1))
    const e = { a: o, b: l, c: c, normal: new Qi(), materialIndex: 0 }
    gr.getNormal(ta, ea, na, e.normal), (h.face = e), (h.barycoord = t)
  }
  return h
}
e(la, 'checkIntersection$1'), e(ca, 'checkGeometryIntersection')
class ha extends Zr {
  static {
    e(this, 'BoxGeometry')
  }
  constructor(t = 1, n = 1, i = 1, s = 1, r = 1, a = 1) {
    super(),
      (this.type = 'BoxGeometry'),
      (this.parameters = {
        width: t,
        height: n,
        depth: i,
        widthSegments: s,
        heightSegments: r,
        depthSegments: a
      })
    const o = this
    ;(s = Math.floor(s)), (r = Math.floor(r)), (a = Math.floor(a))
    const l = [],
      c = [],
      h = [],
      u = []
    let d = 0,
      p = 0
    function m(t, e, n, i, s, r, a, m, f, g, v) {
      const y = r / f,
        _ = a / g,
        x = r / 2,
        b = a / 2,
        w = m / 2,
        M = f + 1,
        S = g + 1
      let T = 0,
        E = 0
      const A = new Qi()
      for (let o = 0; o < S; o++) {
        const r = o * _ - b
        for (let a = 0; a < M; a++) {
          const l = a * y - x
          ;(A[t] = l * i),
            (A[e] = r * s),
            (A[n] = w),
            c.push(A.x, A.y, A.z),
            (A[t] = 0),
            (A[e] = 0),
            (A[n] = m > 0 ? 1 : -1),
            h.push(A.x, A.y, A.z),
            u.push(a / f),
            u.push(1 - o / g),
            (T += 1)
        }
      }
      for (let o = 0; o < g; o++)
        for (let t = 0; t < f; t++) {
          const e = d + t + M * o,
            n = d + t + M * (o + 1),
            i = d + (t + 1) + M * (o + 1),
            s = d + (t + 1) + M * o
          l.push(e, n, s), l.push(n, i, s), (E += 6)
        }
      o.addGroup(p, E, v), (p += E), (d += T)
    }
    m('z', 'y', 'x', -1, -1, i, n, t, a, r, 0),
      m('z', 'y', 'x', 1, -1, i, n, -t, a, r, 1),
      m('x', 'z', 'y', 1, 1, t, i, n, s, a, 2),
      m('x', 'z', 'y', 1, -1, t, i, -n, s, a, 3),
      m('x', 'y', 'z', 1, -1, t, n, i, s, r, 4),
      m('x', 'y', 'z', -1, -1, t, n, -i, s, r, 5),
      this.setIndex(l),
      this.setAttribute('position', new Vr(c, 3)),
      this.setAttribute('normal', new Vr(h, 3)),
      this.setAttribute('uv', new Vr(u, 2)),
      e(m, 'buildPlane')
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  static fromJSON(t) {
    return new ha(
      t.width,
      t.height,
      t.depth,
      t.widthSegments,
      t.heightSegments,
      t.depthSegments
    )
  }
}
function ua(t) {
  const e = {}
  for (const n in t) {
    e[n] = {}
    for (const i in t[n]) {
      const s = t[n][i]
      s &&
      (s.isColor ||
        s.isMatrix3 ||
        s.isMatrix4 ||
        s.isVector2 ||
        s.isVector3 ||
        s.isVector4 ||
        s.isTexture ||
        s.isQuaternion)
        ? s.isRenderTargetTexture
          ? (console.warn(
              'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().'
            ),
            (e[n][i] = null))
          : (e[n][i] = s.clone())
        : Array.isArray(s)
          ? (e[n][i] = s.slice())
          : (e[n][i] = s)
    }
  }
  return e
}
function da(t) {
  const e = {}
  for (let n = 0; n < t.length; n++) {
    const i = ua(t[n])
    for (const t in i) e[t] = i[t]
  }
  return e
}
function pa(t) {
  const e = []
  for (let n = 0; n < t.length; n++) e.push(t[n].clone())
  return e
}
function ma(t) {
  const e = t.getRenderTarget()
  return null === e
    ? t.outputColorSpace
    : !0 === e.isXRRenderTarget
      ? e.texture.colorSpace
      : Pi.workingColorSpace
}
e(ua, 'cloneUniforms'),
  e(da, 'mergeUniforms'),
  e(pa, 'cloneUniformsGroups'),
  e(ma, 'getUnlitUniformColorSpace')
const fa = { clone: ua, merge: da }
class ga extends Sr {
  static {
    e(this, 'ShaderMaterial')
  }
  static get type() {
    return 'ShaderMaterial'
  }
  constructor(t) {
    super(),
      (this.isShaderMaterial = !0),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader =
        'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'),
      (this.fragmentShader =
        'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0]
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      void 0 !== t && this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.fragmentShader = t.fragmentShader),
      (this.vertexShader = t.vertexShader),
      (this.uniforms = ua(t.uniforms)),
      (this.uniformsGroups = pa(t.uniformsGroups)),
      (this.defines = Object.assign({}, t.defines)),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.fog = t.fog),
      (this.lights = t.lights),
      (this.clipping = t.clipping),
      (this.extensions = Object.assign({}, t.extensions)),
      (this.glslVersion = t.glslVersion),
      this
    )
  }
  toJSON(t) {
    const e = super.toJSON(t)
    ;(e.glslVersion = this.glslVersion), (e.uniforms = {})
    for (const i in this.uniforms) {
      const n = this.uniforms[i].value
      n && n.isTexture
        ? (e.uniforms[i] = { type: 't', value: n.toJSON(t).uuid })
        : n && n.isColor
          ? (e.uniforms[i] = { type: 'c', value: n.getHex() })
          : n && n.isVector2
            ? (e.uniforms[i] = { type: 'v2', value: n.toArray() })
            : n && n.isVector3
              ? (e.uniforms[i] = { type: 'v3', value: n.toArray() })
              : n && n.isVector4
                ? (e.uniforms[i] = { type: 'v4', value: n.toArray() })
                : n && n.isMatrix3
                  ? (e.uniforms[i] = { type: 'm3', value: n.toArray() })
                  : n && n.isMatrix4
                    ? (e.uniforms[i] = { type: 'm4', value: n.toArray() })
                    : (e.uniforms[i] = { value: n })
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines),
      (e.vertexShader = this.vertexShader),
      (e.fragmentShader = this.fragmentShader),
      (e.lights = this.lights),
      (e.clipping = this.clipping)
    const n = {}
    for (const i in this.extensions) !0 === this.extensions[i] && (n[i] = !0)
    return Object.keys(n).length > 0 && (e.extensions = n), e
  }
}
class va extends nr {
  static {
    e(this, 'Camera')
  }
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = 'Camera'),
      (this.matrixWorldInverse = new Rs()),
      (this.projectionMatrix = new Rs()),
      (this.projectionMatrixInverse = new Rs()),
      (this.coordinateSystem = Vn)
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      this.matrixWorldInverse.copy(t.matrixWorldInverse),
      this.projectionMatrix.copy(t.projectionMatrix),
      this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
      (this.coordinateSystem = t.coordinateSystem),
      this
    )
  }
  getWorldDirection(t) {
    return super.getWorldDirection(t).negate()
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  updateWorldMatrix(t, e) {
    super.updateWorldMatrix(t, e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const ya = new Qi(),
  _a = new vi(),
  xa = new vi()
class ba extends va {
  static {
    e(this, 'PerspectiveCamera')
  }
  constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = 'PerspectiveCamera'),
      (this.fov = t),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = e),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.fov = t.fov),
      (this.zoom = t.zoom),
      (this.near = t.near),
      (this.far = t.far),
      (this.focus = t.focus),
      (this.aspect = t.aspect),
      (this.view = null === t.view ? null : Object.assign({}, t.view)),
      (this.filmGauge = t.filmGauge),
      (this.filmOffset = t.filmOffset),
      this
    )
  }
  setFocalLength(t) {
    const e = (0.5 * this.getFilmHeight()) / t
    ;(this.fov = 2 * qn * Math.atan(e)), this.updateProjectionMatrix()
  }
  getFocalLength() {
    const t = Math.tan(0.5 * Xn * this.fov)
    return (0.5 * this.getFilmHeight()) / t
  }
  getEffectiveFOV() {
    return 2 * qn * Math.atan(Math.tan(0.5 * Xn * this.fov) / this.zoom)
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1)
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1)
  }
  getViewBounds(t, e, n) {
    ya.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      e.set(ya.x, ya.y).multiplyScalar(-t / ya.z),
      ya.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      n.set(ya.x, ya.y).multiplyScalar(-t / ya.z)
  }
  getViewSize(t, e) {
    return this.getViewBounds(t, _a, xa), e.subVectors(xa, _a)
  }
  setViewOffset(t, e, n, i, s, r) {
    ;(this.aspect = t / e),
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = r),
      this.updateProjectionMatrix()
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = !1),
      this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const t = this.near
    let e = (t * Math.tan(0.5 * Xn * this.fov)) / this.zoom,
      n = 2 * e,
      i = this.aspect * n,
      s = -0.5 * i
    const r = this.view
    if (null !== this.view && this.view.enabled) {
      const t = r.fullWidth,
        a = r.fullHeight
      ;(s += (r.offsetX * i) / t),
        (e -= (r.offsetY * n) / a),
        (i *= r.width / t),
        (n *= r.height / a)
    }
    const a = this.filmOffset
    0 !== a && (s += (t * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + i,
        e,
        e - n,
        t,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      (e.object.fov = this.fov),
      (e.object.zoom = this.zoom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      (e.object.focus = this.focus),
      (e.object.aspect = this.aspect),
      null !== this.view && (e.object.view = Object.assign({}, this.view)),
      (e.object.filmGauge = this.filmGauge),
      (e.object.filmOffset = this.filmOffset),
      e
    )
  }
}
const wa = -90
class Ma extends nr {
  static {
    e(this, 'CubeCamera')
  }
  constructor(t, e, n) {
    super(),
      (this.type = 'CubeCamera'),
      (this.renderTarget = n),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0)
    const i = new ba(wa, 1, t, e)
    ;(i.layers = this.layers), this.add(i)
    const s = new ba(wa, 1, t, e)
    ;(s.layers = this.layers), this.add(s)
    const r = new ba(wa, 1, t, e)
    ;(r.layers = this.layers), this.add(r)
    const a = new ba(wa, 1, t, e)
    ;(a.layers = this.layers), this.add(a)
    const o = new ba(wa, 1, t, e)
    ;(o.layers = this.layers), this.add(o)
    const l = new ba(wa, 1, t, e)
    ;(l.layers = this.layers), this.add(l)
  }
  updateCoordinateSystem() {
    const t = this.coordinateSystem,
      e = this.children.concat(),
      [n, i, s, r, a, o] = e
    for (const l of e) this.remove(l)
    if (t === Vn)
      n.up.set(0, 1, 0),
        n.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        r.up.set(0, 0, 1),
        r.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        o.up.set(0, 1, 0),
        o.lookAt(0, 0, -1)
    else {
      if (t !== Hn)
        throw new Error(
          'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' +
            t
        )
      n.up.set(0, -1, 0),
        n.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        r.up.set(0, 0, -1),
        r.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        o.up.set(0, -1, 0),
        o.lookAt(0, 0, -1)
    }
    for (const l of e) this.add(l), l.updateMatrixWorld()
  }
  update(t, e) {
    null === this.parent && this.updateMatrixWorld()
    const { renderTarget: n, activeMipmapLevel: i } = this
    this.coordinateSystem !== t.coordinateSystem &&
      ((this.coordinateSystem = t.coordinateSystem),
      this.updateCoordinateSystem())
    const [s, r, a, o, l, c] = this.children,
      h = t.getRenderTarget(),
      u = t.getActiveCubeFace(),
      d = t.getActiveMipmapLevel(),
      p = t.xr.enabled
    t.xr.enabled = !1
    const m = n.texture.generateMipmaps
    ;(n.texture.generateMipmaps = !1),
      t.setRenderTarget(n, 0, i),
      t.render(e, s),
      t.setRenderTarget(n, 1, i),
      t.render(e, r),
      t.setRenderTarget(n, 2, i),
      t.render(e, a),
      t.setRenderTarget(n, 3, i),
      t.render(e, o),
      t.setRenderTarget(n, 4, i),
      t.render(e, l),
      (n.texture.generateMipmaps = m),
      t.setRenderTarget(n, 5, i),
      t.render(e, c),
      t.setRenderTarget(h, u, d),
      (t.xr.enabled = p),
      (n.texture.needsPMREMUpdate = !0)
  }
}
class Sa extends Wi {
  static {
    e(this, 'CubeTexture')
  }
  constructor(t, e, n, i, s, r, a, o, l, c) {
    super(
      (t = void 0 !== t ? t : []),
      (e = void 0 !== e ? e : ce),
      n,
      i,
      s,
      r,
      a,
      o,
      l,
      c
    ),
      (this.isCubeTexture = !0),
      (this.flipY = !1)
  }
  get images() {
    return this.image
  }
  set images(t) {
    this.image = t
  }
}
class Ta extends qi {
  static {
    e(this, 'WebGLCubeRenderTarget')
  }
  constructor(t = 1, e = {}) {
    super(t, t, e), (this.isWebGLCubeRenderTarget = !0)
    const n = { width: t, height: t, depth: 1 },
      i = [n, n, n, n, n, n]
    ;(this.texture = new Sa(
      i,
      e.mapping,
      e.wrapS,
      e.wrapT,
      e.magFilter,
      e.minFilter,
      e.format,
      e.type,
      e.anisotropy,
      e.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        void 0 !== e.generateMipmaps && e.generateMipmaps),
      (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : xe)
  }
  fromEquirectangularTexture(t, e) {
    ;(this.texture.type = e.type),
      (this.texture.colorSpace = e.colorSpace),
      (this.texture.generateMipmaps = e.generateMipmaps),
      (this.texture.minFilter = e.minFilter),
      (this.texture.magFilter = e.magFilter)
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader:
          '\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t',
        fragmentShader:
          '\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t'
      },
      i = new ha(5, 5, 5),
      s = new ga({
        name: 'CubemapFromEquirect',
        uniforms: ua(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: 1,
        blending: 0
      })
    s.uniforms.tEquirect.value = e
    const r = new oa(i, s),
      a = e.minFilter
    e.minFilter === we && (e.minFilter = xe)
    return (
      new Ma(1, 10, this).update(t, r),
      (e.minFilter = a),
      r.geometry.dispose(),
      r.material.dispose(),
      this
    )
  }
  clear(t, e, n, i) {
    const s = t.getRenderTarget()
    for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i)
    t.setRenderTarget(s)
  }
}
const Ea = new Qi(),
  Aa = new Qi(),
  Ca = new yi()
class Ra {
  static {
    e(this, 'Plane')
  }
  constructor(t = new Qi(1, 0, 0), e = 0) {
    ;(this.isPlane = !0), (this.normal = t), (this.constant = e)
  }
  set(t, e) {
    return this.normal.copy(t), (this.constant = e), this
  }
  setComponents(t, e, n, i) {
    return this.normal.set(t, e, n), (this.constant = i), this
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
  }
  setFromCoplanarPoints(t, e, n) {
    const i = Ea.subVectors(n, e).cross(Aa.subVectors(t, e)).normalize()
    return this.setFromNormalAndCoplanarPoint(i, t), this
  }
  copy(t) {
    return this.normal.copy(t.normal), (this.constant = t.constant), this
  }
  normalize() {
    const t = 1 / this.normal.length()
    return this.normal.multiplyScalar(t), (this.constant *= t), this
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius
  }
  projectPoint(t, e) {
    return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
  }
  intersectLine(t, e) {
    const n = t.delta(Ea),
      i = this.normal.dot(n)
    if (0 === i)
      return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null
    const s = -(t.start.dot(this.normal) + this.constant) / i
    return s < 0 || s > 1 ? null : e.copy(t.start).addScaledVector(n, s)
  }
  intersectsLine(t) {
    const e = this.distanceToPoint(t.start),
      n = this.distanceToPoint(t.end)
    return (e < 0 && n > 0) || (n < 0 && e > 0)
  }
  intersectsBox(t) {
    return t.intersectsPlane(this)
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this)
  }
  coplanarPoint(t) {
    return t.copy(this.normal).multiplyScalar(-this.constant)
  }
  applyMatrix4(t, e) {
    const n = e || Ca.getNormalMatrix(t),
      i = this.coplanarPoint(Ea).applyMatrix4(t),
      s = this.normal.applyMatrix3(n).normalize()
    return (this.constant = -i.dot(s)), this
  }
  translate(t) {
    return (this.constant -= t.dot(this.normal)), this
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const Pa = new xs(),
  Ia = new Qi()
class La {
  static {
    e(this, 'Frustum')
  }
  constructor(
    t = new Ra(),
    e = new Ra(),
    n = new Ra(),
    i = new Ra(),
    s = new Ra(),
    r = new Ra()
  ) {
    this.planes = [t, e, n, i, s, r]
  }
  set(t, e, n, i, s, r) {
    const a = this.planes
    return (
      a[0].copy(t),
      a[1].copy(e),
      a[2].copy(n),
      a[3].copy(i),
      a[4].copy(s),
      a[5].copy(r),
      this
    )
  }
  copy(t) {
    const e = this.planes
    for (let n = 0; n < 6; n++) e[n].copy(t.planes[n])
    return this
  }
  setFromProjectionMatrix(t, e = 2e3) {
    const n = this.planes,
      i = t.elements,
      s = i[0],
      r = i[1],
      a = i[2],
      o = i[3],
      l = i[4],
      c = i[5],
      h = i[6],
      u = i[7],
      d = i[8],
      p = i[9],
      m = i[10],
      f = i[11],
      g = i[12],
      v = i[13],
      y = i[14],
      _ = i[15]
    if (
      (n[0].setComponents(o - s, u - l, f - d, _ - g).normalize(),
      n[1].setComponents(o + s, u + l, f + d, _ + g).normalize(),
      n[2].setComponents(o + r, u + c, f + p, _ + v).normalize(),
      n[3].setComponents(o - r, u - c, f - p, _ - v).normalize(),
      n[4].setComponents(o - a, u - h, f - m, _ - y).normalize(),
      e === Vn)
    )
      n[5].setComponents(o + a, u + h, f + m, _ + y).normalize()
    else {
      if (e !== Hn)
        throw new Error(
          'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' +
            e
        )
      n[5].setComponents(a, h, m, y).normalize()
    }
    return this
  }
  intersectsObject(t) {
    if (void 0 !== t.boundingSphere)
      null === t.boundingSphere && t.computeBoundingSphere(),
        Pa.copy(t.boundingSphere).applyMatrix4(t.matrixWorld)
    else {
      const e = t.geometry
      null === e.boundingSphere && e.computeBoundingSphere(),
        Pa.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
    }
    return this.intersectsSphere(Pa)
  }
  intersectsSprite(t) {
    return (
      Pa.center.set(0, 0, 0),
      (Pa.radius = 0.7071067811865476),
      Pa.applyMatrix4(t.matrixWorld),
      this.intersectsSphere(Pa)
    )
  }
  intersectsSphere(t) {
    const e = this.planes,
      n = t.center,
      i = -t.radius
    for (let s = 0; s < 6; s++) {
      if (e[s].distanceToPoint(n) < i) return !1
    }
    return !0
  }
  intersectsBox(t) {
    const e = this.planes
    for (let n = 0; n < 6; n++) {
      const i = e[n]
      if (
        ((Ia.x = i.normal.x > 0 ? t.max.x : t.min.x),
        (Ia.y = i.normal.y > 0 ? t.max.y : t.min.y),
        (Ia.z = i.normal.z > 0 ? t.max.z : t.min.z),
        i.distanceToPoint(Ia) < 0)
      )
        return !1
    }
    return !0
  }
  containsPoint(t) {
    const e = this.planes
    for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1
    return !0
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
function Da() {
  let t = null,
    n = !1,
    i = null,
    s = null
  function r(e, n) {
    i(e, n), (s = t.requestAnimationFrame(r))
  }
  return (
    e(r, 'onAnimationFrame'),
    {
      start: e(function () {
        !0 !== n && null !== i && ((s = t.requestAnimationFrame(r)), (n = !0))
      }, 'start'),
      stop: e(function () {
        t.cancelAnimationFrame(s), (n = !1)
      }, 'stop'),
      setAnimationLoop: e(function (t) {
        i = t
      }, 'setAnimationLoop'),
      setContext: e(function (e) {
        t = e
      }, 'setContext')
    }
  )
}
function ka(t) {
  const n = new WeakMap()
  function i(e, n) {
    const i = e.array,
      s = e.usage,
      r = i.byteLength,
      a = t.createBuffer()
    let o
    if (
      (t.bindBuffer(n, a),
      t.bufferData(n, i, s),
      e.onUploadCallback(),
      i instanceof Float32Array)
    )
      o = t.FLOAT
    else if (i instanceof Uint16Array)
      o = e.isFloat16BufferAttribute ? t.HALF_FLOAT : t.UNSIGNED_SHORT
    else if (i instanceof Int16Array) o = t.SHORT
    else if (i instanceof Uint32Array) o = t.UNSIGNED_INT
    else if (i instanceof Int32Array) o = t.INT
    else if (i instanceof Int8Array) o = t.BYTE
    else if (i instanceof Uint8Array) o = t.UNSIGNED_BYTE
    else {
      if (!(i instanceof Uint8ClampedArray))
        throw new Error(
          'THREE.WebGLAttributes: Unsupported buffer data format: ' + i
        )
      o = t.UNSIGNED_BYTE
    }
    return {
      buffer: a,
      type: o,
      bytesPerElement: i.BYTES_PER_ELEMENT,
      version: e.version,
      size: r
    }
  }
  function s(e, n, i) {
    const s = n.array,
      r = n.updateRanges
    if ((t.bindBuffer(i, e), 0 === r.length)) t.bufferSubData(i, 0, s)
    else {
      r.sort((t, e) => t.start - e.start)
      let e = 0
      for (let t = 1; t < r.length; t++) {
        const n = r[e],
          i = r[t]
        i.start <= n.start + n.count + 1
          ? (n.count = Math.max(n.count, i.start + i.count - n.start))
          : (++e, (r[e] = i))
      }
      r.length = e + 1
      for (let n = 0, a = r.length; n < a; n++) {
        const e = r[n]
        t.bufferSubData(i, e.start * s.BYTES_PER_ELEMENT, s, e.start, e.count)
      }
      n.clearUpdateRanges()
    }
    n.onUploadCallback()
  }
  function r(t) {
    return t.isInterleavedBufferAttribute && (t = t.data), n.get(t)
  }
  function a(e) {
    e.isInterleavedBufferAttribute && (e = e.data)
    const i = n.get(e)
    i && (t.deleteBuffer(i.buffer), n.delete(e))
  }
  function o(t, e) {
    if (
      (t.isInterleavedBufferAttribute && (t = t.data), t.isGLBufferAttribute)
    ) {
      const e = n.get(t)
      return void (
        (!e || e.version < t.version) &&
        n.set(t, {
          buffer: t.buffer,
          type: t.type,
          bytesPerElement: t.elementSize,
          version: t.version
        })
      )
    }
    const r = n.get(t)
    if (void 0 === r) n.set(t, i(t, e))
    else if (r.version < t.version) {
      if (r.size !== t.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        )
      s(r.buffer, t, e), (r.version = t.version)
    }
  }
  return (
    e(i, 'createBuffer'),
    e(s, 'updateBuffer'),
    e(r, 'get'),
    e(a, 'remove'),
    e(o, 'update'),
    { get: r, remove: a, update: o }
  )
}
e(Da, 'WebGLAnimation'), e(ka, 'WebGLAttributes')
class Na extends Zr {
  static {
    e(this, 'PlaneGeometry')
  }
  constructor(t = 1, e = 1, n = 1, i = 1) {
    super(),
      (this.type = 'PlaneGeometry'),
      (this.parameters = {
        width: t,
        height: e,
        widthSegments: n,
        heightSegments: i
      })
    const s = t / 2,
      r = e / 2,
      a = Math.floor(n),
      o = Math.floor(i),
      l = a + 1,
      c = o + 1,
      h = t / a,
      u = e / o,
      d = [],
      p = [],
      m = [],
      f = []
    for (let g = 0; g < c; g++) {
      const t = g * u - r
      for (let e = 0; e < l; e++) {
        const n = e * h - s
        p.push(n, -t, 0), m.push(0, 0, 1), f.push(e / a), f.push(1 - g / o)
      }
    }
    for (let g = 0; g < o; g++)
      for (let t = 0; t < a; t++) {
        const e = t + l * g,
          n = t + l * (g + 1),
          i = t + 1 + l * (g + 1),
          s = t + 1 + l * g
        d.push(e, n, s), d.push(n, i, s)
      }
    this.setIndex(d),
      this.setAttribute('position', new Vr(p, 3)),
      this.setAttribute('normal', new Vr(m, 3)),
      this.setAttribute('uv', new Vr(f, 2))
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  static fromJSON(t) {
    return new Na(t.width, t.height, t.widthSegments, t.heightSegments)
  }
}
const Ua = {
    alphahash_fragment:
      '#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif',
    alphahash_pars_fragment:
      '#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif',
    alphamap_fragment:
      '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif',
    alphamap_pars_fragment:
      '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
    alphatest_fragment:
      '#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif',
    alphatest_pars_fragment:
      '#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif',
    aomap_fragment:
      '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif',
    aomap_pars_fragment:
      '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
    batching_pars_vertex:
      '#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif',
    batching_vertex:
      '#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif',
    begin_vertex:
      'vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif',
    beginnormal_vertex:
      'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif',
    bsdfs:
      'float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated',
    iridescence_fragment:
      '#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif',
    bumpmap_pars_fragment:
      '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
    clipping_planes_fragment:
      '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif',
    clipping_planes_pars_fragment:
      '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
    clipping_planes_pars_vertex:
      '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif',
    clipping_planes_vertex:
      '#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif',
    color_fragment:
      '#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif',
    color_pars_fragment:
      '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif',
    color_pars_vertex:
      '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif',
    color_vertex:
      '#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif',
    common:
      '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated',
    cube_uv_reflection_fragment:
      '#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif',
    defaultnormal_vertex:
      'vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif',
    displacementmap_pars_vertex:
      '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
    displacementmap_vertex:
      '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif',
    emissivemap_fragment:
      '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
    emissivemap_pars_fragment:
      '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
    colorspace_fragment: 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
    colorspace_pars_fragment:
      'vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}',
    envmap_fragment:
      '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
    envmap_common_pars_fragment:
      '#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif',
    envmap_pars_fragment:
      '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
    envmap_pars_vertex:
      '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
    envmap_physical_pars_fragment:
      '#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif',
    envmap_vertex:
      '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
    fog_vertex: '#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif',
    fog_pars_vertex: '#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif',
    fog_fragment:
      '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
    fog_pars_fragment:
      '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
    gradientmap_pars_fragment:
      '#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}',
    lightmap_pars_fragment:
      '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
    lights_lambert_fragment:
      'LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;',
    lights_lambert_pars_fragment:
      'varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert',
    lights_pars_begin:
      'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif',
    lights_toon_fragment:
      'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
    lights_toon_pars_fragment:
      'varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon',
    lights_phong_fragment:
      'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
    lights_phong_pars_fragment:
      'varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong',
    lights_physical_fragment:
      'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif',
    lights_physical_pars_fragment:
      'struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
    lights_fragment_begin:
      '\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
    lights_fragment_maps:
      '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif',
    lights_fragment_end:
      '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif',
    logdepthbuf_fragment:
      '#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
    logdepthbuf_pars_fragment:
      '#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
    logdepthbuf_pars_vertex:
      '#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
    logdepthbuf_vertex:
      '#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif',
    map_fragment:
      '#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif',
    map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
    map_particle_fragment:
      '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
    map_particle_pars_fragment:
      '#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
    metalnessmap_fragment:
      'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
    metalnessmap_pars_fragment:
      '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
    morphinstance_vertex:
      '#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif',
    morphcolor_vertex:
      '#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif',
    morphnormal_vertex:
      '#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif',
    morphtarget_pars_vertex:
      '#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif',
    morphtarget_vertex:
      '#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif',
    normal_fragment_begin:
      'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;',
    normal_fragment_maps:
      '#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif',
    normal_pars_fragment:
      '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
    normal_pars_vertex:
      '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
    normal_vertex:
      '#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif',
    normalmap_pars_fragment:
      '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif',
    clearcoat_normal_fragment_begin:
      '#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif',
    clearcoat_normal_fragment_maps:
      '#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif',
    clearcoat_pars_fragment:
      '#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif',
    iridescence_pars_fragment:
      '#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif',
    opaque_fragment:
      '#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );',
    packing:
      'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}',
    premultiplied_alpha_fragment:
      '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
    project_vertex:
      'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
    dithering_fragment:
      '#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
    dithering_pars_fragment:
      '#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
    roughnessmap_fragment:
      'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
    roughnessmap_pars_fragment:
      '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
    shadowmap_pars_fragment:
      '#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif',
    shadowmap_pars_vertex:
      '#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif',
    shadowmap_vertex:
      '#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif',
    shadowmask_pars_fragment:
      'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}',
    skinbase_vertex:
      '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
    skinning_pars_vertex:
      '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif',
    skinning_vertex:
      '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
    skinnormal_vertex:
      '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif',
    specularmap_fragment:
      'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
    specularmap_pars_fragment:
      '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
    tonemapping_fragment:
      '#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
    tonemapping_pars_fragment:
      '#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
    transmission_fragment:
      '#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif',
    transmission_pars_fragment:
      '#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif',
    uv_pars_fragment:
      '#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif',
    uv_pars_vertex:
      '#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif',
    uv_vertex:
      '#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif',
    worldpos_vertex:
      '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif',
    background_vert:
      'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
    background_frag:
      'uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}',
    backgroundCube_vert:
      'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
    backgroundCube_frag:
      '#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}',
    cube_vert:
      'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
    cube_frag:
      'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}',
    depth_vert:
      '#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}',
    depth_frag:
      '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}',
    distanceRGBA_vert:
      '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
    distanceRGBA_frag:
      '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
    equirect_vert:
      'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
    equirect_frag:
      'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}',
    linedashed_vert:
      'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
    linedashed_frag:
      'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
    meshbasic_vert:
      '#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
    meshbasic_frag:
      'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
    meshlambert_vert:
      '#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
    meshlambert_frag:
      '#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
    meshmatcap_vert:
      '#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
    meshmatcap_frag:
      '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
    meshnormal_vert:
      '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
    meshnormal_frag:
      '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}',
    meshphong_vert:
      '#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
    meshphong_frag:
      '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
    meshphysical_vert:
      '#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}',
    meshphysical_frag:
      '#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
    meshtoon_vert:
      '#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
    meshtoon_frag:
      '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
    points_vert:
      'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
    points_frag:
      'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
    shadow_vert:
      '#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
    shadow_frag:
      'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}',
    sprite_vert:
      'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
    sprite_frag:
      'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}'
  },
  Ba = {
    common: {
      diffuse: { value: new br(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new yi() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new yi() },
      alphaTest: { value: 0 }
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new yi() }
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new yi() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 }
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new yi() }
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new yi() }
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new yi() },
      bumpScale: { value: 1 }
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new yi() },
      normalScale: { value: new vi(1, 1) }
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new yi() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new yi() }
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new yi() }
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new yi() }
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new br(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} }
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {}
        }
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} }
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} }
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} }
      },
      ltc_1: { value: null },
      ltc_2: { value: null }
    },
    points: {
      diffuse: { value: new br(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new yi() },
      alphaTest: { value: 0 },
      uvTransform: { value: new yi() }
    },
    sprite: {
      diffuse: { value: new br(16777215) },
      opacity: { value: 1 },
      center: { value: new vi(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new yi() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new yi() },
      alphaTest: { value: 0 }
    }
  },
  Oa = {
    basic: {
      uniforms: da([
        Ba.common,
        Ba.specularmap,
        Ba.envmap,
        Ba.aomap,
        Ba.lightmap,
        Ba.fog
      ]),
      vertexShader: Ua.meshbasic_vert,
      fragmentShader: Ua.meshbasic_frag
    },
    lambert: {
      uniforms: da([
        Ba.common,
        Ba.specularmap,
        Ba.envmap,
        Ba.aomap,
        Ba.lightmap,
        Ba.emissivemap,
        Ba.bumpmap,
        Ba.normalmap,
        Ba.displacementmap,
        Ba.fog,
        Ba.lights,
        { emissive: { value: new br(0) } }
      ]),
      vertexShader: Ua.meshlambert_vert,
      fragmentShader: Ua.meshlambert_frag
    },
    phong: {
      uniforms: da([
        Ba.common,
        Ba.specularmap,
        Ba.envmap,
        Ba.aomap,
        Ba.lightmap,
        Ba.emissivemap,
        Ba.bumpmap,
        Ba.normalmap,
        Ba.displacementmap,
        Ba.fog,
        Ba.lights,
        {
          emissive: { value: new br(0) },
          specular: { value: new br(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: Ua.meshphong_vert,
      fragmentShader: Ua.meshphong_frag
    },
    standard: {
      uniforms: da([
        Ba.common,
        Ba.envmap,
        Ba.aomap,
        Ba.lightmap,
        Ba.emissivemap,
        Ba.bumpmap,
        Ba.normalmap,
        Ba.displacementmap,
        Ba.roughnessmap,
        Ba.metalnessmap,
        Ba.fog,
        Ba.lights,
        {
          emissive: { value: new br(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 }
        }
      ]),
      vertexShader: Ua.meshphysical_vert,
      fragmentShader: Ua.meshphysical_frag
    },
    toon: {
      uniforms: da([
        Ba.common,
        Ba.aomap,
        Ba.lightmap,
        Ba.emissivemap,
        Ba.bumpmap,
        Ba.normalmap,
        Ba.displacementmap,
        Ba.gradientmap,
        Ba.fog,
        Ba.lights,
        { emissive: { value: new br(0) } }
      ]),
      vertexShader: Ua.meshtoon_vert,
      fragmentShader: Ua.meshtoon_frag
    },
    matcap: {
      uniforms: da([
        Ba.common,
        Ba.bumpmap,
        Ba.normalmap,
        Ba.displacementmap,
        Ba.fog,
        { matcap: { value: null } }
      ]),
      vertexShader: Ua.meshmatcap_vert,
      fragmentShader: Ua.meshmatcap_frag
    },
    points: {
      uniforms: da([Ba.points, Ba.fog]),
      vertexShader: Ua.points_vert,
      fragmentShader: Ua.points_frag
    },
    dashed: {
      uniforms: da([
        Ba.common,
        Ba.fog,
        { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }
      ]),
      vertexShader: Ua.linedashed_vert,
      fragmentShader: Ua.linedashed_frag
    },
    depth: {
      uniforms: da([Ba.common, Ba.displacementmap]),
      vertexShader: Ua.depth_vert,
      fragmentShader: Ua.depth_frag
    },
    normal: {
      uniforms: da([
        Ba.common,
        Ba.bumpmap,
        Ba.normalmap,
        Ba.displacementmap,
        { opacity: { value: 1 } }
      ]),
      vertexShader: Ua.meshnormal_vert,
      fragmentShader: Ua.meshnormal_frag
    },
    sprite: {
      uniforms: da([Ba.sprite, Ba.fog]),
      vertexShader: Ua.sprite_vert,
      fragmentShader: Ua.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: { value: new yi() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 }
      },
      vertexShader: Ua.background_vert,
      fragmentShader: Ua.background_frag
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new yi() }
      },
      vertexShader: Ua.backgroundCube_vert,
      fragmentShader: Ua.backgroundCube_frag
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 }
      },
      vertexShader: Ua.cube_vert,
      fragmentShader: Ua.cube_frag
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Ua.equirect_vert,
      fragmentShader: Ua.equirect_frag
    },
    distanceRGBA: {
      uniforms: da([
        Ba.common,
        Ba.displacementmap,
        {
          referencePosition: { value: new Qi() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: Ua.distanceRGBA_vert,
      fragmentShader: Ua.distanceRGBA_frag
    },
    shadow: {
      uniforms: da([
        Ba.lights,
        Ba.fog,
        { color: { value: new br(0) }, opacity: { value: 1 } }
      ]),
      vertexShader: Ua.shadow_vert,
      fragmentShader: Ua.shadow_frag
    }
  }
Oa.physical = {
  uniforms: da([
    Oa.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new yi() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new yi() },
      clearcoatNormalScale: { value: new vi(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new yi() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new yi() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new yi() },
      sheen: { value: 0 },
      sheenColor: { value: new br(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new yi() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new yi() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new yi() },
      transmissionSamplerSize: { value: new vi() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new yi() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new br(0) },
      specularColor: { value: new br(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new yi() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new yi() },
      anisotropyVector: { value: new vi() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new yi() }
    }
  ]),
  vertexShader: Ua.meshphysical_vert,
  fragmentShader: Ua.meshphysical_frag
}
const Fa = { r: 0, b: 0, g: 0 },
  za = new Fs(),
  Va = new Rs()
function Ha(t, n, i, s, r, a, o) {
  const l = new br(0)
  let c,
    h,
    u = !0 === a ? 0 : 1,
    d = null,
    p = 0,
    m = null
  function f(t) {
    let e = !0 === t.isScene ? t.background : null
    if (e && e.isTexture) {
      e = (t.backgroundBlurriness > 0 ? i : n).get(e)
    }
    return e
  }
  function g(e) {
    let n = !1
    const i = f(e)
    null === i ? y(l, u) : i && i.isColor && (y(i, 1), (n = !0))
    const r = t.xr.getEnvironmentBlendMode()
    'additive' === r
      ? s.buffers.color.setClear(0, 0, 0, 1, o)
      : 'alpha-blend' === r && s.buffers.color.setClear(0, 0, 0, 0, o),
      (t.autoClear || n) &&
        (s.buffers.depth.setTest(!0),
        s.buffers.depth.setMask(!0),
        s.buffers.color.setMask(!0),
        t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil))
  }
  function v(n, i) {
    const s = f(i)
    s && (s.isCubeTexture || s.mapping === pe)
      ? (void 0 === h &&
          ((h = new oa(
            new ha(1, 1, 1),
            new ga({
              name: 'BackgroundCubeMaterial',
              uniforms: ua(Oa.backgroundCube.uniforms),
              vertexShader: Oa.backgroundCube.vertexShader,
              fragmentShader: Oa.backgroundCube.fragmentShader,
              side: 1,
              depthTest: !1,
              depthWrite: !1,
              fog: !1
            })
          )),
          h.geometry.deleteAttribute('normal'),
          h.geometry.deleteAttribute('uv'),
          (h.onBeforeRender = function (t, e, n) {
            this.matrixWorld.copyPosition(n.matrixWorld)
          }),
          Object.defineProperty(h.material, 'envMap', {
            get: e(function () {
              return this.uniforms.envMap.value
            }, 'get')
          }),
          r.update(h)),
        za.copy(i.backgroundRotation),
        (za.x *= -1),
        (za.y *= -1),
        (za.z *= -1),
        s.isCubeTexture &&
          !1 === s.isRenderTargetTexture &&
          ((za.y *= -1), (za.z *= -1)),
        (h.material.uniforms.envMap.value = s),
        (h.material.uniforms.flipEnvMap.value =
          s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
        (h.material.uniforms.backgroundBlurriness.value =
          i.backgroundBlurriness),
        (h.material.uniforms.backgroundIntensity.value = i.backgroundIntensity),
        h.material.uniforms.backgroundRotation.value.setFromMatrix4(
          Va.makeRotationFromEuler(za)
        ),
        (h.material.toneMapped = Pi.getTransfer(s.colorSpace) !== Rn),
        (d === s && p === s.version && m === t.toneMapping) ||
          ((h.material.needsUpdate = !0),
          (d = s),
          (p = s.version),
          (m = t.toneMapping)),
        h.layers.enableAll(),
        n.unshift(h, h.geometry, h.material, 0, 0, null))
      : s &&
        s.isTexture &&
        (void 0 === c &&
          ((c = new oa(
            new Na(2, 2),
            new ga({
              name: 'BackgroundMaterial',
              uniforms: ua(Oa.background.uniforms),
              vertexShader: Oa.background.vertexShader,
              fragmentShader: Oa.background.fragmentShader,
              side: 0,
              depthTest: !1,
              depthWrite: !1,
              fog: !1
            })
          )),
          c.geometry.deleteAttribute('normal'),
          Object.defineProperty(c.material, 'map', {
            get: e(function () {
              return this.uniforms.t2D.value
            }, 'get')
          }),
          r.update(c)),
        (c.material.uniforms.t2D.value = s),
        (c.material.uniforms.backgroundIntensity.value = i.backgroundIntensity),
        (c.material.toneMapped = Pi.getTransfer(s.colorSpace) !== Rn),
        !0 === s.matrixAutoUpdate && s.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(s.matrix),
        (d === s && p === s.version && m === t.toneMapping) ||
          ((c.material.needsUpdate = !0),
          (d = s),
          (p = s.version),
          (m = t.toneMapping)),
        c.layers.enableAll(),
        n.unshift(c, c.geometry, c.material, 0, 0, null))
  }
  function y(e, n) {
    e.getRGB(Fa, ma(t)), s.buffers.color.setClear(Fa.r, Fa.g, Fa.b, n, o)
  }
  return (
    e(f, 'getBackground'),
    e(g, 'render'),
    e(v, 'addToRenderList'),
    e(y, 'setClear'),
    {
      getClearColor: e(function () {
        return l
      }, 'getClearColor'),
      setClearColor: e(function (t, e = 1) {
        l.set(t), (u = e), y(l, u)
      }, 'setClearColor'),
      getClearAlpha: e(function () {
        return u
      }, 'getClearAlpha'),
      setClearAlpha: e(function (t) {
        ;(u = t), y(l, u)
      }, 'setClearAlpha'),
      render: g,
      addToRenderList: v
    }
  )
}
function Ga(t, n) {
  const i = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    s = {},
    r = p(null)
  let a = r,
    o = !1
  function l(e, i, s, r, l) {
    let c = !1
    const u = d(r, s, i)
    a !== u && ((a = u), h(a.object)),
      (c = m(e, r, s, l)),
      c && f(e, r, s, l),
      null !== l && n.update(l, t.ELEMENT_ARRAY_BUFFER),
      (c || o) &&
        ((o = !1),
        b(e, i, s, r),
        null !== l && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(l).buffer))
  }
  function c() {
    return t.createVertexArray()
  }
  function h(e) {
    return t.bindVertexArray(e)
  }
  function u(e) {
    return t.deleteVertexArray(e)
  }
  function d(t, e, n) {
    const i = !0 === n.wireframe
    let r = s[t.id]
    void 0 === r && ((r = {}), (s[t.id] = r))
    let a = r[e.id]
    void 0 === a && ((a = {}), (r[e.id] = a))
    let o = a[i]
    return void 0 === o && ((o = p(c())), (a[i] = o)), o
  }
  function p(t) {
    const e = [],
      n = [],
      s = []
    for (let r = 0; r < i; r++) (e[r] = 0), (n[r] = 0), (s[r] = 0)
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: e,
      enabledAttributes: n,
      attributeDivisors: s,
      object: t,
      attributes: {},
      index: null
    }
  }
  function m(t, e, n, i) {
    const s = a.attributes,
      r = e.attributes
    let o = 0
    const l = n.getAttributes()
    for (const a in l) {
      if (l[a].location >= 0) {
        const e = s[a]
        let n = r[a]
        if (
          (void 0 === n &&
            ('instanceMatrix' === a &&
              t.instanceMatrix &&
              (n = t.instanceMatrix),
            'instanceColor' === a && t.instanceColor && (n = t.instanceColor)),
          void 0 === e)
        )
          return !0
        if (e.attribute !== n) return !0
        if (n && e.data !== n.data) return !0
        o++
      }
    }
    return a.attributesNum !== o || a.index !== i
  }
  function f(t, e, n, i) {
    const s = {},
      r = e.attributes
    let o = 0
    const l = n.getAttributes()
    for (const a in l) {
      if (l[a].location >= 0) {
        let e = r[a]
        void 0 === e &&
          ('instanceMatrix' === a && t.instanceMatrix && (e = t.instanceMatrix),
          'instanceColor' === a && t.instanceColor && (e = t.instanceColor))
        const n = {}
        ;(n.attribute = e), e && e.data && (n.data = e.data), (s[a] = n), o++
      }
    }
    ;(a.attributes = s), (a.attributesNum = o), (a.index = i)
  }
  function g() {
    const t = a.newAttributes
    for (let e = 0, n = t.length; e < n; e++) t[e] = 0
  }
  function v(t) {
    y(t, 0)
  }
  function y(e, n) {
    const i = a.newAttributes,
      s = a.enabledAttributes,
      r = a.attributeDivisors
    ;(i[e] = 1),
      0 === s[e] && (t.enableVertexAttribArray(e), (s[e] = 1)),
      r[e] !== n && (t.vertexAttribDivisor(e, n), (r[e] = n))
  }
  function _() {
    const e = a.newAttributes,
      n = a.enabledAttributes
    for (let i = 0, s = n.length; i < s; i++)
      n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0))
  }
  function x(e, n, i, s, r, a, o) {
    !0 === o
      ? t.vertexAttribIPointer(e, n, i, r, a)
      : t.vertexAttribPointer(e, n, i, s, r, a)
  }
  function b(e, i, s, r) {
    g()
    const a = r.attributes,
      o = s.getAttributes(),
      l = i.defaultAttributeValues
    for (const c in o) {
      const i = o[c]
      if (i.location >= 0) {
        let s = a[c]
        if (
          (void 0 === s &&
            ('instanceMatrix' === c &&
              e.instanceMatrix &&
              (s = e.instanceMatrix),
            'instanceColor' === c && e.instanceColor && (s = e.instanceColor)),
          void 0 !== s)
        ) {
          const a = s.normalized,
            o = s.itemSize,
            l = n.get(s)
          if (void 0 === l) continue
          const c = l.buffer,
            h = l.type,
            u = l.bytesPerElement,
            d = h === t.INT || h === t.UNSIGNED_INT || s.gpuType === Te
          if (s.isInterleavedBufferAttribute) {
            const n = s.data,
              l = n.stride,
              p = s.offset
            if (n.isInstancedInterleavedBuffer) {
              for (let t = 0; t < i.locationSize; t++)
                y(i.location + t, n.meshPerAttribute)
              !0 !== e.isInstancedMesh &&
                void 0 === r._maxInstanceCount &&
                (r._maxInstanceCount = n.meshPerAttribute * n.count)
            } else for (let t = 0; t < i.locationSize; t++) v(i.location + t)
            t.bindBuffer(t.ARRAY_BUFFER, c)
            for (let t = 0; t < i.locationSize; t++)
              x(
                i.location + t,
                o / i.locationSize,
                h,
                a,
                l * u,
                (p + (o / i.locationSize) * t) * u,
                d
              )
          } else {
            if (s.isInstancedBufferAttribute) {
              for (let t = 0; t < i.locationSize; t++)
                y(i.location + t, s.meshPerAttribute)
              !0 !== e.isInstancedMesh &&
                void 0 === r._maxInstanceCount &&
                (r._maxInstanceCount = s.meshPerAttribute * s.count)
            } else for (let t = 0; t < i.locationSize; t++) v(i.location + t)
            t.bindBuffer(t.ARRAY_BUFFER, c)
            for (let t = 0; t < i.locationSize; t++)
              x(
                i.location + t,
                o / i.locationSize,
                h,
                a,
                o * u,
                (o / i.locationSize) * t * u,
                d
              )
          }
        } else if (void 0 !== l) {
          const e = l[c]
          if (void 0 !== e)
            switch (e.length) {
              case 2:
                t.vertexAttrib2fv(i.location, e)
                break
              case 3:
                t.vertexAttrib3fv(i.location, e)
                break
              case 4:
                t.vertexAttrib4fv(i.location, e)
                break
              default:
                t.vertexAttrib1fv(i.location, e)
            }
        }
      }
    }
    _()
  }
  function w() {
    T()
    for (const t in s) {
      const e = s[t]
      for (const t in e) {
        const n = e[t]
        for (const t in n) u(n[t].object), delete n[t]
        delete e[t]
      }
      delete s[t]
    }
  }
  function M(t) {
    if (void 0 === s[t.id]) return
    const e = s[t.id]
    for (const n in e) {
      const t = e[n]
      for (const e in t) u(t[e].object), delete t[e]
      delete e[n]
    }
    delete s[t.id]
  }
  function S(t) {
    for (const e in s) {
      const n = s[e]
      if (void 0 === n[t.id]) continue
      const i = n[t.id]
      for (const t in i) u(i[t].object), delete i[t]
      delete n[t.id]
    }
  }
  function T() {
    E(), (o = !0), a !== r && ((a = r), h(a.object))
  }
  function E() {
    ;(r.geometry = null), (r.program = null), (r.wireframe = !1)
  }
  return (
    e(l, 'setup'),
    e(c, 'createVertexArrayObject'),
    e(h, 'bindVertexArrayObject'),
    e(u, 'deleteVertexArrayObject'),
    e(d, 'getBindingState'),
    e(p, 'createBindingState'),
    e(m, 'needsUpdate'),
    e(f, 'saveCache'),
    e(g, 'initAttributes'),
    e(v, 'enableAttribute'),
    e(y, 'enableAttributeAndDivisor'),
    e(_, 'disableUnusedAttributes'),
    e(x, 'vertexAttribPointer'),
    e(b, 'setupVertexAttributes'),
    e(w, 'dispose'),
    e(M, 'releaseStatesOfGeometry'),
    e(S, 'releaseStatesOfProgram'),
    e(T, 'reset'),
    e(E, 'resetDefaultState'),
    {
      setup: l,
      reset: T,
      resetDefaultState: E,
      dispose: w,
      releaseStatesOfGeometry: M,
      releaseStatesOfProgram: S,
      initAttributes: g,
      enableAttribute: v,
      disableUnusedAttributes: _
    }
  )
}
function Wa(t, n, i) {
  let s
  function r(t) {
    s = t
  }
  function a(e, n) {
    t.drawArrays(s, e, n), i.update(n, s, 1)
  }
  function o(e, n, r) {
    0 !== r && (t.drawArraysInstanced(s, e, n, r), i.update(n, s, r))
  }
  function l(t, e, r) {
    if (0 === r) return
    n.get('WEBGL_multi_draw').multiDrawArraysWEBGL(s, t, 0, e, 0, r)
    let a = 0
    for (let n = 0; n < r; n++) a += e[n]
    i.update(a, s, 1)
  }
  function c(t, e, r, a) {
    if (0 === r) return
    const l = n.get('WEBGL_multi_draw')
    if (null === l) for (let n = 0; n < t.length; n++) o(t[n], e[n], a[n])
    else {
      l.multiDrawArraysInstancedWEBGL(s, t, 0, e, 0, a, 0, r)
      let n = 0
      for (let t = 0; t < r; t++) n += e[t] * a[t]
      i.update(n, s, 1)
    }
  }
  e(r, 'setMode'),
    e(a, 'render'),
    e(o, 'renderInstances'),
    e(l, 'renderMultiDraw'),
    e(c, 'renderMultiDrawInstances'),
    (this.setMode = r),
    (this.render = a),
    (this.renderInstances = o),
    (this.renderMultiDraw = l),
    (this.renderMultiDrawInstances = c)
}
function ja(t, n, i, s) {
  let r
  function a() {
    if (void 0 !== r) return r
    if (!0 === n.has('EXT_texture_filter_anisotropic')) {
      const e = n.get('EXT_texture_filter_anisotropic')
      r = t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
    } else r = 0
    return r
  }
  function o(e) {
    return (
      e === Le ||
      s.convert(e) === t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT)
    )
  }
  function l(e) {
    const i =
      e === Ce &&
      (n.has('EXT_color_buffer_half_float') || n.has('EXT_color_buffer_float'))
    return !(
      e !== Me &&
      s.convert(e) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE) &&
      e !== Ae &&
      !i
    )
  }
  function c(e) {
    if ('highp' === e) {
      if (
        t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision >
          0 &&
        t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision >
          0
      )
        return 'highp'
      e = 'mediump'
    }
    return 'mediump' === e &&
      t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision >
        0 &&
      t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision >
        0
      ? 'mediump'
      : 'lowp'
  }
  e(a, 'getMaxAnisotropy'),
    e(o, 'textureFormatReadable'),
    e(l, 'textureTypeReadable'),
    e(c, 'getMaxPrecision')
  let h = void 0 !== i.precision ? i.precision : 'highp'
  const u = c(h)
  u !== h &&
    (console.warn(
      'THREE.WebGLRenderer:',
      h,
      'not supported, using',
      u,
      'instead.'
    ),
    (h = u))
  const d = !0 === i.logarithmicDepthBuffer,
    p = !0 === i.reverseDepthBuffer && n.has('EXT_clip_control'),
    m = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
    f = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
  return {
    isWebGL2: !0,
    getMaxAnisotropy: a,
    getMaxPrecision: c,
    textureFormatReadable: o,
    textureTypeReadable: l,
    precision: h,
    logarithmicDepthBuffer: d,
    reverseDepthBuffer: p,
    maxTextures: m,
    maxVertexTextures: f,
    maxTextureSize: t.getParameter(t.MAX_TEXTURE_SIZE),
    maxCubemapSize: t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
    maxAttributes: t.getParameter(t.MAX_VERTEX_ATTRIBS),
    maxVertexUniforms: t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
    maxVaryings: t.getParameter(t.MAX_VARYING_VECTORS),
    maxFragmentUniforms: t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
    vertexTextures: f > 0,
    maxSamples: t.getParameter(t.MAX_SAMPLES)
  }
}
function Xa(t) {
  const n = this
  let i = null,
    s = 0,
    r = !1,
    a = !1
  const o = new Ra(),
    l = new yi(),
    c = { value: null, needsUpdate: !1 }
  function h() {
    c.value !== i && ((c.value = i), (c.needsUpdate = s > 0)),
      (n.numPlanes = s),
      (n.numIntersection = 0)
  }
  function u(t, e, i, s) {
    const r = null !== t ? t.length : 0
    let a = null
    if (0 !== r) {
      if (((a = c.value), !0 !== s || null === a)) {
        const n = i + 4 * r,
          s = e.matrixWorldInverse
        l.getNormalMatrix(s),
          (null === a || a.length < n) && (a = new Float32Array(n))
        for (let e = 0, c = i; e !== r; ++e, c += 4)
          o.copy(t[e]).applyMatrix4(s, l),
            o.normal.toArray(a, c),
            (a[c + 3] = o.constant)
      }
      ;(c.value = a), (c.needsUpdate = !0)
    }
    return (n.numPlanes = r), (n.numIntersection = 0), a
  }
  ;(this.uniform = c),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (t, e) {
      const n = 0 !== t.length || e || 0 !== s || r
      return (r = e), (s = t.length), n
    }),
    (this.beginShadows = function () {
      ;(a = !0), u(null)
    }),
    (this.endShadows = function () {
      a = !1
    }),
    (this.setGlobalState = function (t, e) {
      i = u(t, e, 0)
    }),
    (this.setState = function (e, n, o) {
      const l = e.clippingPlanes,
        d = e.clipIntersection,
        p = e.clipShadows,
        m = t.get(e)
      if (!r || null === l || 0 === l.length || (a && !p)) a ? u(null) : h()
      else {
        const t = a ? 0 : s,
          e = 4 * t
        let r = m.clippingState || null
        ;(c.value = r), (r = u(l, n, e, o))
        for (let n = 0; n !== e; ++n) r[n] = i[n]
        ;(m.clippingState = r),
          (this.numIntersection = d ? this.numPlanes : 0),
          (this.numPlanes += t)
      }
    }),
    e(h, 'resetGlobalState'),
    e(u, 'projectPlanes')
}
function qa(t) {
  let n = new WeakMap()
  function i(t, e) {
    return e === ue ? (t.mapping = ce) : e === de && (t.mapping = he), t
  }
  function s(e) {
    if (e && e.isTexture) {
      const s = e.mapping
      if (s === ue || s === de) {
        if (n.has(e)) {
          return i(n.get(e).texture, e.mapping)
        }
        {
          const s = e.image
          if (s && s.height > 0) {
            const a = new Ta(s.height)
            return (
              a.fromEquirectangularTexture(t, e),
              n.set(e, a),
              e.addEventListener('dispose', r),
              i(a.texture, e.mapping)
            )
          }
          return null
        }
      }
    }
    return e
  }
  function r(t) {
    const e = t.target
    e.removeEventListener('dispose', r)
    const i = n.get(e)
    void 0 !== i && (n.delete(e), i.dispose())
  }
  function a() {
    n = new WeakMap()
  }
  return (
    e(i, 'mapTextureMapping'),
    e(s, 'get'),
    e(r, 'onTextureDispose'),
    e(a, 'dispose'),
    { get: s, dispose: a }
  )
}
e(Ha, 'WebGLBackground'),
  e(Ga, 'WebGLBindingStates'),
  e(Wa, 'WebGLBufferRenderer'),
  e(ja, 'WebGLCapabilities'),
  e(Xa, 'WebGLClipping'),
  e(qa, 'WebGLCubeMaps')
class Ya extends va {
  static {
    e(this, 'OrthographicCamera')
  }
  constructor(t = -1, e = 1, n = 1, i = -1, s = 0.1, r = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = 'OrthographicCamera'),
      (this.zoom = 1),
      (this.view = null),
      (this.left = t),
      (this.right = e),
      (this.top = n),
      (this.bottom = i),
      (this.near = s),
      (this.far = r),
      this.updateProjectionMatrix()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.left = t.left),
      (this.right = t.right),
      (this.top = t.top),
      (this.bottom = t.bottom),
      (this.near = t.near),
      (this.far = t.far),
      (this.zoom = t.zoom),
      (this.view = null === t.view ? null : Object.assign({}, t.view)),
      this
    )
  }
  setViewOffset(t, e, n, i, s, r) {
    null === this.view &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = r),
      this.updateProjectionMatrix()
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = !1),
      this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const t = (this.right - this.left) / (2 * this.zoom),
      e = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2
    let s = n - t,
      r = n + t,
      a = i + e,
      o = i - e
    if (null !== this.view && this.view.enabled) {
      const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
        e = (this.top - this.bottom) / this.view.fullHeight / this.zoom
      ;(s += t * this.view.offsetX),
        (r = s + t * this.view.width),
        (a -= e * this.view.offsetY),
        (o = a - e * this.view.height)
    }
    this.projectionMatrix.makeOrthographic(
      s,
      r,
      a,
      o,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      (e.object.zoom = this.zoom),
      (e.object.left = this.left),
      (e.object.right = this.right),
      (e.object.top = this.top),
      (e.object.bottom = this.bottom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      null !== this.view && (e.object.view = Object.assign({}, this.view)),
      e
    )
  }
}
const Za = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Ka = 20,
  $a = new Ya(),
  Ja = new br()
let Qa = null,
  to = 0,
  eo = 0,
  no = !1
const io = (1 + Math.sqrt(5)) / 2,
  so = 1 / io,
  ro = [
    new Qi(-io, so, 0),
    new Qi(io, so, 0),
    new Qi(-so, 0, io),
    new Qi(so, 0, io),
    new Qi(0, io, -so),
    new Qi(0, io, so),
    new Qi(-1, 1, -1),
    new Qi(1, 1, -1),
    new Qi(-1, 1, 1),
    new Qi(1, 1, 1)
  ]
class ao {
  static {
    e(this, 'PMREMGenerator')
  }
  constructor(t) {
    ;(this._renderer = t),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial)
  }
  fromScene(t, e = 0, n = 0.1, i = 100) {
    ;(Qa = this._renderer.getRenderTarget()),
      (to = this._renderer.getActiveCubeFace()),
      (eo = this._renderer.getActiveMipmapLevel()),
      (no = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256)
    const s = this._allocateTargets()
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(t, n, i, s),
      e > 0 && this._blur(s, 0, 0, e),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    )
  }
  fromEquirectangular(t, e = null) {
    return this._fromTexture(t, e)
  }
  fromCubemap(t, e = null) {
    return this._fromTexture(t, e)
  }
  compileCubemapShader() {
    null === this._cubemapMaterial &&
      ((this._cubemapMaterial = po()),
      this._compileMaterial(this._cubemapMaterial))
  }
  compileEquirectangularShader() {
    null === this._equirectMaterial &&
      ((this._equirectMaterial = uo()),
      this._compileMaterial(this._equirectMaterial))
  }
  dispose() {
    this._dispose(),
      null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
      null !== this._equirectMaterial && this._equirectMaterial.dispose()
  }
  _setSize(t) {
    ;(this._lodMax = Math.floor(Math.log2(t))),
      (this._cubeSize = Math.pow(2, this._lodMax))
  }
  _dispose() {
    null !== this._blurMaterial && this._blurMaterial.dispose(),
      null !== this._pingPongRenderTarget &&
        this._pingPongRenderTarget.dispose()
    for (let t = 0; t < this._lodPlanes.length; t++)
      this._lodPlanes[t].dispose()
  }
  _cleanup(t) {
    this._renderer.setRenderTarget(Qa, to, eo),
      (this._renderer.xr.enabled = no),
      (t.scissorTest = !1),
      co(t, 0, 0, t.width, t.height)
  }
  _fromTexture(t, e) {
    t.mapping === ce || t.mapping === he
      ? this._setSize(
          0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width
        )
      : this._setSize(t.image.width / 4),
      (Qa = this._renderer.getRenderTarget()),
      (to = this._renderer.getActiveCubeFace()),
      (eo = this._renderer.getActiveMipmapLevel()),
      (no = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1)
    const n = e || this._allocateTargets()
    return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
  }
  _allocateTargets() {
    const t = 3 * Math.max(this._cubeSize, 112),
      e = 4 * this._cubeSize,
      n = {
        magFilter: xe,
        minFilter: xe,
        generateMipmaps: !1,
        type: Ce,
        format: Le,
        colorSpace: An,
        depthBuffer: !1
      },
      i = lo(t, e, n)
    if (
      null === this._pingPongRenderTarget ||
      this._pingPongRenderTarget.width !== t ||
      this._pingPongRenderTarget.height !== e
    ) {
      null !== this._pingPongRenderTarget && this._dispose(),
        (this._pingPongRenderTarget = lo(t, e, n))
      const { _lodMax: i } = this
      ;({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas
      } = oo(i)),
        (this._blurMaterial = ho(i, t, e))
    }
    return i
  }
  _compileMaterial(t) {
    const e = new oa(this._lodPlanes[0], t)
    this._renderer.compile(e, $a)
  }
  _sceneToCubeUV(t, e, n, i) {
    const s = new ba(90, 1, e, n),
      r = [1, -1, 1, 1, 1, 1],
      a = [1, 1, 1, -1, -1, -1],
      o = this._renderer,
      l = o.autoClear,
      c = o.toneMapping
    o.getClearColor(Ja), (o.toneMapping = 0), (o.autoClear = !1)
    const h = new Tr({
        name: 'PMREM.Background',
        side: 1,
        depthWrite: !1,
        depthTest: !1
      }),
      u = new oa(new ha(), h)
    let d = !1
    const p = t.background
    p
      ? p.isColor && (h.color.copy(p), (t.background = null), (d = !0))
      : (h.color.copy(Ja), (d = !0))
    for (let m = 0; m < 6; m++) {
      const e = m % 3
      0 === e
        ? (s.up.set(0, r[m], 0), s.lookAt(a[m], 0, 0))
        : 1 === e
          ? (s.up.set(0, 0, r[m]), s.lookAt(0, a[m], 0))
          : (s.up.set(0, r[m], 0), s.lookAt(0, 0, a[m]))
      const n = this._cubeSize
      co(i, e * n, m > 2 ? n : 0, n, n),
        o.setRenderTarget(i),
        d && o.render(u, s),
        o.render(t, s)
    }
    u.geometry.dispose(),
      u.material.dispose(),
      (o.toneMapping = c),
      (o.autoClear = l),
      (t.background = p)
  }
  _textureToCubeUV(t, e) {
    const n = this._renderer,
      i = t.mapping === ce || t.mapping === he
    i
      ? (null === this._cubemapMaterial && (this._cubemapMaterial = po()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          !1 === t.isRenderTargetTexture ? -1 : 1))
      : null === this._equirectMaterial && (this._equirectMaterial = uo())
    const s = i ? this._cubemapMaterial : this._equirectMaterial,
      r = new oa(this._lodPlanes[0], s)
    s.uniforms.envMap.value = t
    const a = this._cubeSize
    co(e, 0, 0, 3 * a, 2 * a), n.setRenderTarget(e), n.render(r, $a)
  }
  _applyPMREM(t) {
    const e = this._renderer,
      n = e.autoClear
    e.autoClear = !1
    const i = this._lodPlanes.length
    for (let s = 1; s < i; s++) {
      const e = Math.sqrt(
          this._sigmas[s] * this._sigmas[s] -
            this._sigmas[s - 1] * this._sigmas[s - 1]
        ),
        n = ro[(i - s - 1) % ro.length]
      this._blur(t, s - 1, s, e, n)
    }
    e.autoClear = n
  }
  _blur(t, e, n, i, s) {
    const r = this._pingPongRenderTarget
    this._halfBlur(t, r, e, n, i, 'latitudinal', s),
      this._halfBlur(r, t, n, n, i, 'longitudinal', s)
  }
  _halfBlur(t, e, n, i, s, r, a) {
    const o = this._renderer,
      l = this._blurMaterial
    'latitudinal' !== r &&
      'longitudinal' !== r &&
      console.error(
        'blur direction must be either latitudinal or longitudinal!'
      )
    const c = new oa(this._lodPlanes[i], l),
      h = l.uniforms,
      u = this._sizeLods[n] - 1,
      d = isFinite(s) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
      p = s / d,
      m = isFinite(s) ? 1 + Math.floor(3 * p) : Ka
    m > Ka &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`
      )
    const f = []
    let g = 0
    for (let _ = 0; _ < Ka; ++_) {
      const t = _ / p,
        e = Math.exp((-t * t) / 2)
      f.push(e), 0 === _ ? (g += e) : _ < m && (g += 2 * e)
    }
    for (let _ = 0; _ < f.length; _++) f[_] = f[_] / g
    ;(h.envMap.value = t.texture),
      (h.samples.value = m),
      (h.weights.value = f),
      (h.latitudinal.value = 'latitudinal' === r),
      a && (h.poleAxis.value = a)
    const { _lodMax: v } = this
    ;(h.dTheta.value = d), (h.mipInt.value = v - n)
    const y = this._sizeLods[i]
    co(
      e,
      3 * y * (i > v - 4 ? i - v + 4 : 0),
      4 * (this._cubeSize - y),
      3 * y,
      2 * y
    ),
      o.setRenderTarget(e),
      o.render(c, $a)
  }
}
function oo(t) {
  const e = [],
    n = [],
    i = []
  let s = t
  const r = t - 4 + 1 + Za.length
  for (let a = 0; a < r; a++) {
    const r = Math.pow(2, s)
    n.push(r)
    let o = 1 / r
    a > t - 4 ? (o = Za[a - t + 4 - 1]) : 0 === a && (o = 0), i.push(o)
    const l = 1 / (r - 2),
      c = -l,
      h = 1 + l,
      u = [c, c, h, c, h, h, c, c, h, h, c, h],
      d = 6,
      p = 6,
      m = 3,
      f = 2,
      g = 1,
      v = new Float32Array(m * p * d),
      y = new Float32Array(f * p * d),
      _ = new Float32Array(g * p * d)
    for (let t = 0; t < d; t++) {
      const e = ((t % 3) * 2) / 3 - 1,
        n = t > 2 ? 0 : -1,
        i = [
          e,
          n,
          0,
          e + 2 / 3,
          n,
          0,
          e + 2 / 3,
          n + 1,
          0,
          e,
          n,
          0,
          e + 2 / 3,
          n + 1,
          0,
          e,
          n + 1,
          0
        ]
      v.set(i, m * p * t), y.set(u, f * p * t)
      const s = [t, t, t, t, t, t]
      _.set(s, g * p * t)
    }
    const x = new Zr()
    x.setAttribute('position', new Lr(v, m)),
      x.setAttribute('uv', new Lr(y, f)),
      x.setAttribute('faceIndex', new Lr(_, g)),
      e.push(x),
      s > 4 && s--
  }
  return { lodPlanes: e, sizeLods: n, sigmas: i }
}
function lo(t, e, n) {
  const i = new qi(t, e, n)
  return (
    (i.texture.mapping = pe),
    (i.texture.name = 'PMREM.cubeUv'),
    (i.scissorTest = !0),
    i
  )
}
function co(t, e, n, i, s) {
  t.viewport.set(e, n, i, s), t.scissor.set(e, n, i, s)
}
function ho(t, e, n) {
  const i = new Float32Array(Ka),
    s = new Qi(0, 1, 0)
  return new ga({
    name: 'SphericalGaussianBlur',
    defines: {
      n: Ka,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / n,
      CUBEUV_MAX_MIP: `${t}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: s }
    },
    vertexShader: mo(),
    fragmentShader:
      "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  })
}
function uo() {
  return new ga({
    name: 'EquirectangularToCubeUV',
    uniforms: { envMap: { value: null } },
    vertexShader: mo(),
    fragmentShader:
      '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t',
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  })
}
function po() {
  return new ga({
    name: 'CubemapToCubeUV',
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: mo(),
    fragmentShader:
      '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t',
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  })
}
function mo() {
  return '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t'
}
function fo(t) {
  let n = new WeakMap(),
    i = null
  function s(e) {
    if (e && e.isTexture) {
      const s = e.mapping,
        o = s === ue || s === de,
        l = s === ce || s === he
      if (o || l) {
        let s = n.get(e)
        const c = void 0 !== s ? s.texture.pmremVersion : 0
        if (e.isRenderTargetTexture && e.pmremVersion !== c)
          return (
            null === i && (i = new ao(t)),
            (s = o ? i.fromEquirectangular(e, s) : i.fromCubemap(e, s)),
            (s.texture.pmremVersion = e.pmremVersion),
            n.set(e, s),
            s.texture
          )
        if (void 0 !== s) return s.texture
        {
          const c = e.image
          return (o && c && c.height > 0) || (l && c && r(c))
            ? (null === i && (i = new ao(t)),
              (s = o ? i.fromEquirectangular(e) : i.fromCubemap(e)),
              (s.texture.pmremVersion = e.pmremVersion),
              n.set(e, s),
              e.addEventListener('dispose', a),
              s.texture)
            : null
        }
      }
    }
    return e
  }
  function r(t) {
    let e = 0
    for (let n = 0; n < 6; n++) void 0 !== t[n] && e++
    return 6 === e
  }
  function a(t) {
    const e = t.target
    e.removeEventListener('dispose', a)
    const i = n.get(e)
    void 0 !== i && (n.delete(e), i.dispose())
  }
  function o() {
    ;(n = new WeakMap()), null !== i && (i.dispose(), (i = null))
  }
  return (
    e(s, 'get'),
    e(r, 'isCubeTextureComplete'),
    e(a, 'onTextureDispose'),
    e(o, 'dispose'),
    { get: s, dispose: o }
  )
}
function go(t) {
  const n = {}
  function i(e) {
    if (void 0 !== n[e]) return n[e]
    let i
    switch (e) {
      case 'WEBGL_depth_texture':
        i =
          t.getExtension('WEBGL_depth_texture') ||
          t.getExtension('MOZ_WEBGL_depth_texture') ||
          t.getExtension('WEBKIT_WEBGL_depth_texture')
        break
      case 'EXT_texture_filter_anisotropic':
        i =
          t.getExtension('EXT_texture_filter_anisotropic') ||
          t.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
          t.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
        break
      case 'WEBGL_compressed_texture_s3tc':
        i =
          t.getExtension('WEBGL_compressed_texture_s3tc') ||
          t.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
          t.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
        break
      case 'WEBGL_compressed_texture_pvrtc':
        i =
          t.getExtension('WEBGL_compressed_texture_pvrtc') ||
          t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')
        break
      default:
        i = t.getExtension(e)
    }
    return (n[e] = i), i
  }
  return (
    e(i, 'getExtension'),
    {
      has: e(function (t) {
        return null !== i(t)
      }, 'has'),
      init: e(function () {
        i('EXT_color_buffer_float'),
          i('WEBGL_clip_cull_distance'),
          i('OES_texture_float_linear'),
          i('EXT_color_buffer_half_float'),
          i('WEBGL_multisampled_render_to_texture'),
          i('WEBGL_render_shared_exponent')
      }, 'init'),
      get: e(function (t) {
        const e = i(t)
        return (
          null === e &&
            Ei('THREE.WebGLRenderer: ' + t + ' extension not supported.'),
          e
        )
      }, 'get')
    }
  )
}
function vo(t, n, i, s) {
  const r = {},
    a = new WeakMap()
  function o(t) {
    const e = t.target
    null !== e.index && n.remove(e.index)
    for (const i in e.attributes) n.remove(e.attributes[i])
    for (const i in e.morphAttributes) {
      const t = e.morphAttributes[i]
      for (let e = 0, i = t.length; e < i; e++) n.remove(t[e])
    }
    e.removeEventListener('dispose', o), delete r[e.id]
    const l = a.get(e)
    l && (n.remove(l), a.delete(e)),
      s.releaseStatesOfGeometry(e),
      !0 === e.isInstancedBufferGeometry && delete e._maxInstanceCount,
      i.memory.geometries--
  }
  function l(t, e) {
    return (
      !0 === r[e.id] ||
        (e.addEventListener('dispose', o),
        (r[e.id] = !0),
        i.memory.geometries++),
      e
    )
  }
  function c(e) {
    const i = e.attributes
    for (const r in i) n.update(i[r], t.ARRAY_BUFFER)
    const s = e.morphAttributes
    for (const r in s) {
      const e = s[r]
      for (let i = 0, s = e.length; i < s; i++) n.update(e[i], t.ARRAY_BUFFER)
    }
  }
  function h(t) {
    const e = [],
      i = t.index,
      s = t.attributes.position
    let r = 0
    if (null !== i) {
      const t = i.array
      r = i.version
      for (let n = 0, i = t.length; n < i; n += 3) {
        const i = t[n + 0],
          s = t[n + 1],
          r = t[n + 2]
        e.push(i, s, s, r, r, i)
      }
    } else {
      if (void 0 === s) return
      {
        const t = s.array
        r = s.version
        for (let n = 0, i = t.length / 3 - 1; n < i; n += 3) {
          const t = n + 0,
            i = n + 1,
            s = n + 2
          e.push(t, i, i, s, s, t)
        }
      }
    }
    const o = new (xi(e) ? Fr : Br)(e, 1)
    o.version = r
    const l = a.get(t)
    l && n.remove(l), a.set(t, o)
  }
  function u(t) {
    const e = a.get(t)
    if (e) {
      const n = t.index
      null !== n && e.version < n.version && h(t)
    } else h(t)
    return a.get(t)
  }
  return (
    e(o, 'onGeometryDispose'),
    e(l, 'get'),
    e(c, 'update'),
    e(h, 'updateWireframeAttribute'),
    e(u, 'getWireframeAttribute'),
    { get: l, update: c, getWireframeAttribute: u }
  )
}
function yo(t, n, i) {
  let s, r, a
  function o(t) {
    s = t
  }
  function l(t) {
    ;(r = t.type), (a = t.bytesPerElement)
  }
  function c(e, n) {
    t.drawElements(s, n, r, e * a), i.update(n, s, 1)
  }
  function h(e, n, o) {
    0 !== o && (t.drawElementsInstanced(s, n, r, e * a, o), i.update(n, s, o))
  }
  function u(t, e, a) {
    if (0 === a) return
    n.get('WEBGL_multi_draw').multiDrawElementsWEBGL(s, e, 0, r, t, 0, a)
    let o = 0
    for (let n = 0; n < a; n++) o += e[n]
    i.update(o, s, 1)
  }
  function d(t, e, o, l) {
    if (0 === o) return
    const c = n.get('WEBGL_multi_draw')
    if (null === c) for (let n = 0; n < t.length; n++) h(t[n] / a, e[n], l[n])
    else {
      c.multiDrawElementsInstancedWEBGL(s, e, 0, r, t, 0, l, 0, o)
      let n = 0
      for (let t = 0; t < o; t++) n += e[t] * l[t]
      i.update(n, s, 1)
    }
  }
  e(o, 'setMode'),
    e(l, 'setIndex'),
    e(c, 'render'),
    e(h, 'renderInstances'),
    e(u, 'renderMultiDraw'),
    e(d, 'renderMultiDrawInstances'),
    (this.setMode = o),
    (this.setIndex = l),
    (this.render = c),
    (this.renderInstances = h),
    (this.renderMultiDraw = u),
    (this.renderMultiDrawInstances = d)
}
function _o(t) {
  const n = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
  function i(e, i, s) {
    switch ((n.calls++, i)) {
      case t.TRIANGLES:
        n.triangles += s * (e / 3)
        break
      case t.LINES:
        n.lines += s * (e / 2)
        break
      case t.LINE_STRIP:
        n.lines += s * (e - 1)
        break
      case t.LINE_LOOP:
        n.lines += s * e
        break
      case t.POINTS:
        n.points += s * e
        break
      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', i)
    }
  }
  function s() {
    ;(n.calls = 0), (n.triangles = 0), (n.points = 0), (n.lines = 0)
  }
  return (
    e(i, 'update'),
    e(s, 'reset'),
    {
      memory: { geometries: 0, textures: 0 },
      render: n,
      programs: null,
      autoReset: !0,
      reset: s,
      update: i
    }
  )
}
function xo(t, n, i) {
  const s = new WeakMap(),
    r = new ji()
  function a(a, o, l) {
    const c = a.morphTargetInfluences,
      h =
        o.morphAttributes.position ||
        o.morphAttributes.normal ||
        o.morphAttributes.color,
      u = void 0 !== h ? h.length : 0
    let d = s.get(o)
    if (void 0 === d || d.count !== u) {
      let t = function () {
        y.dispose(), s.delete(o), o.removeEventListener('dispose', t)
      }
      e(t, 'disposeTexture'), void 0 !== d && d.texture.dispose()
      const i = void 0 !== o.morphAttributes.position,
        a = void 0 !== o.morphAttributes.normal,
        l = void 0 !== o.morphAttributes.color,
        c = o.morphAttributes.position || [],
        h = o.morphAttributes.normal || [],
        p = o.morphAttributes.color || []
      let m = 0
      !0 === i && (m = 1), !0 === a && (m = 2), !0 === l && (m = 3)
      let f = o.attributes.position.count * m,
        g = 1
      f > n.maxTextureSize &&
        ((g = Math.ceil(f / n.maxTextureSize)), (f = n.maxTextureSize))
      const v = new Float32Array(f * g * 4 * u),
        y = new Yi(v, f, g, u)
      ;(y.type = Ae), (y.needsUpdate = !0)
      const _ = 4 * m
      for (let e = 0; e < u; e++) {
        const t = c[e],
          n = h[e],
          s = p[e],
          o = f * g * 4 * e
        for (let e = 0; e < t.count; e++) {
          const c = e * _
          !0 === i &&
            (r.fromBufferAttribute(t, e),
            (v[o + c + 0] = r.x),
            (v[o + c + 1] = r.y),
            (v[o + c + 2] = r.z),
            (v[o + c + 3] = 0)),
            !0 === a &&
              (r.fromBufferAttribute(n, e),
              (v[o + c + 4] = r.x),
              (v[o + c + 5] = r.y),
              (v[o + c + 6] = r.z),
              (v[o + c + 7] = 0)),
            !0 === l &&
              (r.fromBufferAttribute(s, e),
              (v[o + c + 8] = r.x),
              (v[o + c + 9] = r.y),
              (v[o + c + 10] = r.z),
              (v[o + c + 11] = 4 === s.itemSize ? r.w : 1))
        }
      }
      ;(d = { count: u, texture: y, size: new vi(f, g) }),
        s.set(o, d),
        o.addEventListener('dispose', t)
    }
    if (!0 === a.isInstancedMesh && null !== a.morphTexture)
      l.getUniforms().setValue(t, 'morphTexture', a.morphTexture, i)
    else {
      let e = 0
      for (let t = 0; t < c.length; t++) e += c[t]
      const n = o.morphTargetsRelative ? 1 : 1 - e
      l.getUniforms().setValue(t, 'morphTargetBaseInfluence', n),
        l.getUniforms().setValue(t, 'morphTargetInfluences', c)
    }
    l.getUniforms().setValue(t, 'morphTargetsTexture', d.texture, i),
      l.getUniforms().setValue(t, 'morphTargetsTextureSize', d.size)
  }
  return e(a, 'update'), { update: a }
}
function bo(t, n, i, s) {
  let r = new WeakMap()
  function a(e) {
    const a = s.render.frame,
      o = e.geometry,
      c = n.get(e, o)
    if (
      (r.get(c) !== a && (n.update(c), r.set(c, a)),
      e.isInstancedMesh &&
        (!1 === e.hasEventListener('dispose', l) &&
          e.addEventListener('dispose', l),
        r.get(e) !== a &&
          (i.update(e.instanceMatrix, t.ARRAY_BUFFER),
          null !== e.instanceColor && i.update(e.instanceColor, t.ARRAY_BUFFER),
          r.set(e, a))),
      e.isSkinnedMesh)
    ) {
      const t = e.skeleton
      r.get(t) !== a && (t.update(), r.set(t, a))
    }
    return c
  }
  function o() {
    r = new WeakMap()
  }
  function l(t) {
    const e = t.target
    e.removeEventListener('dispose', l),
      i.remove(e.instanceMatrix),
      null !== e.instanceColor && i.remove(e.instanceColor)
  }
  return (
    e(a, 'update'),
    e(o, 'dispose'),
    e(l, 'onInstancedMeshDispose'),
    { update: a, dispose: o }
  )
}
e(oo, '_createPlanes'),
  e(lo, '_createRenderTarget'),
  e(co, '_setViewport'),
  e(ho, '_getBlurShader'),
  e(uo, '_getEquirectMaterial'),
  e(po, '_getCubemapMaterial'),
  e(mo, '_getCommonVertexShader'),
  e(fo, 'WebGLCubeUVMaps'),
  e(go, 'WebGLExtensions'),
  e(vo, 'WebGLGeometries'),
  e(yo, 'WebGLIndexedBufferRenderer'),
  e(_o, 'WebGLInfo'),
  e(xo, 'WebGLMorphtargets'),
  e(bo, 'WebGLObjects')
class wo extends Wi {
  static {
    e(this, 'DepthTexture')
  }
  constructor(t, e, n, i, s, r, a, o, l, c = 1026) {
    if (c !== De && c !== ke)
      throw new Error(
        'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat'
      )
    void 0 === n && c === De && (n = Ee),
      void 0 === n && c === ke && (n = Ie),
      super(null, i, s, r, a, o, c, n, l),
      (this.isDepthTexture = !0),
      (this.image = { width: t, height: e }),
      (this.magFilter = void 0 !== a ? a : ve),
      (this.minFilter = void 0 !== o ? o : ve),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null)
  }
  copy(t) {
    return super.copy(t), (this.compareFunction = t.compareFunction), this
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      null !== this.compareFunction &&
        (e.compareFunction = this.compareFunction),
      e
    )
  }
}
const Mo = new Wi(),
  So = new wo(1, 1),
  To = new Yi(),
  Eo = new Ki(),
  Ao = new Sa(),
  Co = [],
  Ro = [],
  Po = new Float32Array(16),
  Io = new Float32Array(9),
  Lo = new Float32Array(4)
function Do(t, e, n) {
  const i = t[0]
  if (i <= 0 || i > 0) return t
  const s = e * n
  let r = Co[s]
  if ((void 0 === r && ((r = new Float32Array(s)), (Co[s] = r)), 0 !== e)) {
    i.toArray(r, 0)
    for (let i = 1, s = 0; i !== e; ++i) (s += n), t[i].toArray(r, s)
  }
  return r
}
function ko(t, e) {
  if (t.length !== e.length) return !1
  for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1
  return !0
}
function No(t, e) {
  for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
}
function Uo(t, e) {
  let n = Ro[e]
  void 0 === n && ((n = new Int32Array(e)), (Ro[e] = n))
  for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit()
  return n
}
function Bo(t, e) {
  const n = this.cache
  n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e))
}
function Oo(t, e) {
  const n = this.cache
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y) ||
      (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y))
  else {
    if (ko(n, e)) return
    t.uniform2fv(this.addr, e), No(n, e)
  }
}
function Fo(t, e) {
  const n = this.cache
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
      (t.uniform3f(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z))
  else if (void 0 !== e.r)
    (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
      (t.uniform3f(this.addr, e.r, e.g, e.b),
      (n[0] = e.r),
      (n[1] = e.g),
      (n[2] = e.b))
  else {
    if (ko(n, e)) return
    t.uniform3fv(this.addr, e), No(n, e)
  }
}
function zo(t, e) {
  const n = this.cache
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
      (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w))
  else {
    if (ko(n, e)) return
    t.uniform4fv(this.addr, e), No(n, e)
  }
}
function Vo(t, e) {
  const n = this.cache,
    i = e.elements
  if (void 0 === i) {
    if (ko(n, e)) return
    t.uniformMatrix2fv(this.addr, !1, e), No(n, e)
  } else {
    if (ko(n, i)) return
    Lo.set(i), t.uniformMatrix2fv(this.addr, !1, Lo), No(n, i)
  }
}
function Ho(t, e) {
  const n = this.cache,
    i = e.elements
  if (void 0 === i) {
    if (ko(n, e)) return
    t.uniformMatrix3fv(this.addr, !1, e), No(n, e)
  } else {
    if (ko(n, i)) return
    Io.set(i), t.uniformMatrix3fv(this.addr, !1, Io), No(n, i)
  }
}
function Go(t, e) {
  const n = this.cache,
    i = e.elements
  if (void 0 === i) {
    if (ko(n, e)) return
    t.uniformMatrix4fv(this.addr, !1, e), No(n, e)
  } else {
    if (ko(n, i)) return
    Po.set(i), t.uniformMatrix4fv(this.addr, !1, Po), No(n, i)
  }
}
function Wo(t, e) {
  const n = this.cache
  n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e))
}
function jo(t, e) {
  const n = this.cache
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y) ||
      (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y))
  else {
    if (ko(n, e)) return
    t.uniform2iv(this.addr, e), No(n, e)
  }
}
function Xo(t, e) {
  const n = this.cache
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
      (t.uniform3i(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z))
  else {
    if (ko(n, e)) return
    t.uniform3iv(this.addr, e), No(n, e)
  }
}
function qo(t, e) {
  const n = this.cache
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
      (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w))
  else {
    if (ko(n, e)) return
    t.uniform4iv(this.addr, e), No(n, e)
  }
}
function Yo(t, e) {
  const n = this.cache
  n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e))
}
function Zo(t, e) {
  const n = this.cache
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y) ||
      (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y))
  else {
    if (ko(n, e)) return
    t.uniform2uiv(this.addr, e), No(n, e)
  }
}
function Ko(t, e) {
  const n = this.cache
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
      (t.uniform3ui(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z))
  else {
    if (ko(n, e)) return
    t.uniform3uiv(this.addr, e), No(n, e)
  }
}
function $o(t, e) {
  const n = this.cache
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
      (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w))
  else {
    if (ko(n, e)) return
    t.uniform4uiv(this.addr, e), No(n, e)
  }
}
function Jo(t, e, n) {
  const i = this.cache,
    s = n.allocateTextureUnit()
  let r
  i[0] !== s && (t.uniform1i(this.addr, s), (i[0] = s)),
    this.type === t.SAMPLER_2D_SHADOW
      ? ((So.compareFunction = 515), (r = So))
      : (r = Mo),
    n.setTexture2D(e || r, s)
}
function Qo(t, e, n) {
  const i = this.cache,
    s = n.allocateTextureUnit()
  i[0] !== s && (t.uniform1i(this.addr, s), (i[0] = s)),
    n.setTexture3D(e || Eo, s)
}
function tl(t, e, n) {
  const i = this.cache,
    s = n.allocateTextureUnit()
  i[0] !== s && (t.uniform1i(this.addr, s), (i[0] = s)),
    n.setTextureCube(e || Ao, s)
}
function el(t, e, n) {
  const i = this.cache,
    s = n.allocateTextureUnit()
  i[0] !== s && (t.uniform1i(this.addr, s), (i[0] = s)),
    n.setTexture2DArray(e || To, s)
}
function nl(t) {
  switch (t) {
    case 5126:
      return Bo
    case 35664:
      return Oo
    case 35665:
      return Fo
    case 35666:
      return zo
    case 35674:
      return Vo
    case 35675:
      return Ho
    case 35676:
      return Go
    case 5124:
    case 35670:
      return Wo
    case 35667:
    case 35671:
      return jo
    case 35668:
    case 35672:
      return Xo
    case 35669:
    case 35673:
      return qo
    case 5125:
      return Yo
    case 36294:
      return Zo
    case 36295:
      return Ko
    case 36296:
      return $o
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Jo
    case 35679:
    case 36299:
    case 36307:
      return Qo
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return tl
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return el
  }
}
function il(t, e) {
  t.uniform1fv(this.addr, e)
}
function sl(t, e) {
  const n = Do(e, this.size, 2)
  t.uniform2fv(this.addr, n)
}
function rl(t, e) {
  const n = Do(e, this.size, 3)
  t.uniform3fv(this.addr, n)
}
function al(t, e) {
  const n = Do(e, this.size, 4)
  t.uniform4fv(this.addr, n)
}
function ol(t, e) {
  const n = Do(e, this.size, 4)
  t.uniformMatrix2fv(this.addr, !1, n)
}
function ll(t, e) {
  const n = Do(e, this.size, 9)
  t.uniformMatrix3fv(this.addr, !1, n)
}
function cl(t, e) {
  const n = Do(e, this.size, 16)
  t.uniformMatrix4fv(this.addr, !1, n)
}
function hl(t, e) {
  t.uniform1iv(this.addr, e)
}
function ul(t, e) {
  t.uniform2iv(this.addr, e)
}
function dl(t, e) {
  t.uniform3iv(this.addr, e)
}
function pl(t, e) {
  t.uniform4iv(this.addr, e)
}
function ml(t, e) {
  t.uniform1uiv(this.addr, e)
}
function fl(t, e) {
  t.uniform2uiv(this.addr, e)
}
function gl(t, e) {
  t.uniform3uiv(this.addr, e)
}
function vl(t, e) {
  t.uniform4uiv(this.addr, e)
}
function yl(t, e, n) {
  const i = this.cache,
    s = e.length,
    r = Uo(n, s)
  ko(i, r) || (t.uniform1iv(this.addr, r), No(i, r))
  for (let a = 0; a !== s; ++a) n.setTexture2D(e[a] || Mo, r[a])
}
function _l(t, e, n) {
  const i = this.cache,
    s = e.length,
    r = Uo(n, s)
  ko(i, r) || (t.uniform1iv(this.addr, r), No(i, r))
  for (let a = 0; a !== s; ++a) n.setTexture3D(e[a] || Eo, r[a])
}
function xl(t, e, n) {
  const i = this.cache,
    s = e.length,
    r = Uo(n, s)
  ko(i, r) || (t.uniform1iv(this.addr, r), No(i, r))
  for (let a = 0; a !== s; ++a) n.setTextureCube(e[a] || Ao, r[a])
}
function bl(t, e, n) {
  const i = this.cache,
    s = e.length,
    r = Uo(n, s)
  ko(i, r) || (t.uniform1iv(this.addr, r), No(i, r))
  for (let a = 0; a !== s; ++a) n.setTexture2DArray(e[a] || To, r[a])
}
function wl(t) {
  switch (t) {
    case 5126:
      return il
    case 35664:
      return sl
    case 35665:
      return rl
    case 35666:
      return al
    case 35674:
      return ol
    case 35675:
      return ll
    case 35676:
      return cl
    case 5124:
    case 35670:
      return hl
    case 35667:
    case 35671:
      return ul
    case 35668:
    case 35672:
      return dl
    case 35669:
    case 35673:
      return pl
    case 5125:
      return ml
    case 36294:
      return fl
    case 36295:
      return gl
    case 36296:
      return vl
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return yl
    case 35679:
    case 36299:
    case 36307:
      return _l
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return xl
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return bl
  }
}
e(Do, 'flatten'),
  e(ko, 'arraysEqual'),
  e(No, 'copyArray'),
  e(Uo, 'allocTexUnits'),
  e(Bo, 'setValueV1f'),
  e(Oo, 'setValueV2f'),
  e(Fo, 'setValueV3f'),
  e(zo, 'setValueV4f'),
  e(Vo, 'setValueM2'),
  e(Ho, 'setValueM3'),
  e(Go, 'setValueM4'),
  e(Wo, 'setValueV1i'),
  e(jo, 'setValueV2i'),
  e(Xo, 'setValueV3i'),
  e(qo, 'setValueV4i'),
  e(Yo, 'setValueV1ui'),
  e(Zo, 'setValueV2ui'),
  e(Ko, 'setValueV3ui'),
  e($o, 'setValueV4ui'),
  e(Jo, 'setValueT1'),
  e(Qo, 'setValueT3D1'),
  e(tl, 'setValueT6'),
  e(el, 'setValueT2DArray1'),
  e(nl, 'getSingularSetter'),
  e(il, 'setValueV1fArray'),
  e(sl, 'setValueV2fArray'),
  e(rl, 'setValueV3fArray'),
  e(al, 'setValueV4fArray'),
  e(ol, 'setValueM2Array'),
  e(ll, 'setValueM3Array'),
  e(cl, 'setValueM4Array'),
  e(hl, 'setValueV1iArray'),
  e(ul, 'setValueV2iArray'),
  e(dl, 'setValueV3iArray'),
  e(pl, 'setValueV4iArray'),
  e(ml, 'setValueV1uiArray'),
  e(fl, 'setValueV2uiArray'),
  e(gl, 'setValueV3uiArray'),
  e(vl, 'setValueV4uiArray'),
  e(yl, 'setValueT1Array'),
  e(_l, 'setValueT3DArray'),
  e(xl, 'setValueT6Array'),
  e(bl, 'setValueT2DArrayArray'),
  e(wl, 'getPureArraySetter')
class Ml {
  static {
    e(this, 'SingleUniform')
  }
  constructor(t, e, n) {
    ;(this.id = t),
      (this.addr = n),
      (this.cache = []),
      (this.type = e.type),
      (this.setValue = nl(e.type))
  }
}
class Sl {
  static {
    e(this, 'PureArrayUniform')
  }
  constructor(t, e, n) {
    ;(this.id = t),
      (this.addr = n),
      (this.cache = []),
      (this.type = e.type),
      (this.size = e.size),
      (this.setValue = wl(e.type))
  }
}
class Tl {
  static {
    e(this, 'StructuredUniform')
  }
  constructor(t) {
    ;(this.id = t), (this.seq = []), (this.map = {})
  }
  setValue(t, e, n) {
    const i = this.seq
    for (let s = 0, r = i.length; s !== r; ++s) {
      const r = i[s]
      r.setValue(t, e[r.id], n)
    }
  }
}
const El = /(\w+)(\])?(\[|\.)?/g
function Al(t, e) {
  t.seq.push(e), (t.map[e.id] = e)
}
function Cl(t, e, n) {
  const i = t.name,
    s = i.length
  for (El.lastIndex = 0; ; ) {
    const r = El.exec(i),
      a = El.lastIndex
    let o = r[1]
    const l = ']' === r[2],
      c = r[3]
    if ((l && (o |= 0), void 0 === c || ('[' === c && a + 2 === s))) {
      Al(n, void 0 === c ? new Ml(o, t, e) : new Sl(o, t, e))
      break
    }
    {
      let t = n.map[o]
      void 0 === t && ((t = new Tl(o)), Al(n, t)), (n = t)
    }
  }
}
e(Al, 'addUniform'), e(Cl, 'parseUniform')
class Rl {
  static {
    e(this, 'WebGLUniforms')
  }
  constructor(t, e) {
    ;(this.seq = []), (this.map = {})
    const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS)
    for (let i = 0; i < n; ++i) {
      const n = t.getActiveUniform(e, i)
      Cl(n, t.getUniformLocation(e, n.name), this)
    }
  }
  setValue(t, e, n, i) {
    const s = this.map[e]
    void 0 !== s && s.setValue(t, n, i)
  }
  setOptional(t, e, n) {
    const i = e[n]
    void 0 !== i && this.setValue(t, n, i)
  }
  static upload(t, e, n, i) {
    for (let s = 0, r = e.length; s !== r; ++s) {
      const r = e[s],
        a = n[r.id]
      !1 !== a.needsUpdate && r.setValue(t, a.value, i)
    }
  }
  static seqWithValue(t, e) {
    const n = []
    for (let i = 0, s = t.length; i !== s; ++i) {
      const s = t[i]
      s.id in e && n.push(s)
    }
    return n
  }
}
function Pl(t, e, n) {
  const i = t.createShader(e)
  return t.shaderSource(i, n), t.compileShader(i), i
}
e(Pl, 'WebGLShader')
let Il = 0
function Ll(t, e) {
  const n = t.split('\n'),
    i = [],
    s = Math.max(e - 6, 0),
    r = Math.min(e + 6, n.length)
  for (let a = s; a < r; a++) {
    const t = a + 1
    i.push(`${t === e ? '>' : ' '} ${t}: ${n[a]}`)
  }
  return i.join('\n')
}
e(Ll, 'handleSource')
const Dl = new yi()
function kl(t) {
  Pi._getMatrix(Dl, Pi.workingColorSpace, t)
  const e = `mat3( ${Dl.elements.map((t) => t.toFixed(4))} )`
  switch (Pi.getTransfer(t)) {
    case Cn:
      return [e, 'LinearTransferOETF']
    case Rn:
      return [e, 'sRGBTransferOETF']
    default:
      return (
        console.warn('THREE.WebGLProgram: Unsupported color space: ', t),
        [e, 'LinearTransferOETF']
      )
  }
}
function Nl(t, e, n) {
  const i = t.getShaderParameter(e, t.COMPILE_STATUS),
    s = t.getShaderInfoLog(e).trim()
  if (i && '' === s) return ''
  const r = /ERROR: 0:(\d+)/.exec(s)
  if (r) {
    const i = parseInt(r[1])
    return n.toUpperCase() + '\n\n' + s + '\n\n' + Ll(t.getShaderSource(e), i)
  }
  return s
}
function Ul(t, e) {
  const n = kl(e)
  return [
    `vec4 ${t}( vec4 value ) {`,
    `\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,
    '}'
  ].join('\n')
}
function Bl(t, e) {
  let n
  switch (e) {
    case 1:
      n = 'Linear'
      break
    case 2:
      n = 'Reinhard'
      break
    case 3:
      n = 'Cineon'
      break
    case 4:
      n = 'ACESFilmic'
      break
    case 6:
      n = 'AgX'
      break
    case 7:
      n = 'Neutral'
      break
    case 5:
      n = 'Custom'
      break
    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e),
        (n = 'Linear')
  }
  return (
    'vec3 ' + t + '( vec3 color ) { return ' + n + 'ToneMapping( color ); }'
  )
}
e(kl, 'getEncodingComponents'),
  e(Nl, 'getShaderErrors'),
  e(Ul, 'getTexelEncodingFunction'),
  e(Bl, 'getToneMappingFunction')
const Ol = new Qi()
function Fl() {
  Pi.getLuminanceCoefficients(Ol)
  return [
    'float luminance( const in vec3 rgb ) {',
    `\tconst vec3 weights = vec3( ${Ol.x.toFixed(4)}, ${Ol.y.toFixed(4)}, ${Ol.z.toFixed(4)} );`,
    '\treturn dot( weights, rgb );',
    '}'
  ].join('\n')
}
function zl(t) {
  return [
    t.extensionClipCullDistance
      ? '#extension GL_ANGLE_clip_cull_distance : require'
      : '',
    t.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : ''
  ]
    .filter(Gl)
    .join('\n')
}
function Vl(t) {
  const e = []
  for (const n in t) {
    const i = t[n]
    !1 !== i && e.push('#define ' + n + ' ' + i)
  }
  return e.join('\n')
}
function Hl(t, e) {
  const n = {},
    i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES)
  for (let s = 0; s < i; s++) {
    const i = t.getActiveAttrib(e, s),
      r = i.name
    let a = 1
    i.type === t.FLOAT_MAT2 && (a = 2),
      i.type === t.FLOAT_MAT3 && (a = 3),
      i.type === t.FLOAT_MAT4 && (a = 4),
      (n[r] = {
        type: i.type,
        location: t.getAttribLocation(e, r),
        locationSize: a
      })
  }
  return n
}
function Gl(t) {
  return '' !== t
}
function Wl(t, e) {
  const n =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps
  return t
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function jl(t, e) {
  return t
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    )
}
e(Fl, 'getLuminanceFunction'),
  e(zl, 'generateVertexExtensions'),
  e(Vl, 'generateDefines'),
  e(Hl, 'fetchAttributeLocations'),
  e(Gl, 'filterEmptyLine'),
  e(Wl, 'replaceLightNums'),
  e(jl, 'replaceClippingPlaneNums')
const Xl = /^[ \t]*#include +<([\w\d./]+)>/gm
function ql(t) {
  return t.replace(Xl, Zl)
}
e(ql, 'resolveIncludes')
const Yl = new Map()
function Zl(t, e) {
  let n = Ua[e]
  if (void 0 === n) {
    const t = Yl.get(e)
    if (void 0 === t) throw new Error('Can not resolve #include <' + e + '>')
    ;(n = Ua[t]),
      console.warn(
        'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
        e,
        t
      )
  }
  return ql(n)
}
e(Zl, 'includeReplacer')
const Kl =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
function $l(t) {
  return t.replace(Kl, Jl)
}
function Jl(t, e, n, i) {
  let s = ''
  for (let r = parseInt(e); r < parseInt(n); r++)
    s += i
      .replace(/\[\s*i\s*\]/g, '[ ' + r + ' ]')
      .replace(/UNROLLED_LOOP_INDEX/g, r)
  return s
}
function Ql(t) {
  let e = `precision ${t.precision} float;\n\tprecision ${t.precision} int;\n\tprecision ${t.precision} sampler2D;\n\tprecision ${t.precision} samplerCube;\n\tprecision ${t.precision} sampler3D;\n\tprecision ${t.precision} sampler2DArray;\n\tprecision ${t.precision} sampler2DShadow;\n\tprecision ${t.precision} samplerCubeShadow;\n\tprecision ${t.precision} sampler2DArrayShadow;\n\tprecision ${t.precision} isampler2D;\n\tprecision ${t.precision} isampler3D;\n\tprecision ${t.precision} isamplerCube;\n\tprecision ${t.precision} isampler2DArray;\n\tprecision ${t.precision} usampler2D;\n\tprecision ${t.precision} usampler3D;\n\tprecision ${t.precision} usamplerCube;\n\tprecision ${t.precision} usampler2DArray;\n\t`
  return (
    'highp' === t.precision
      ? (e += '\n#define HIGH_PRECISION')
      : 'mediump' === t.precision
        ? (e += '\n#define MEDIUM_PRECISION')
        : 'lowp' === t.precision && (e += '\n#define LOW_PRECISION'),
    e
  )
}
function tc(t) {
  let e = 'SHADOWMAP_TYPE_BASIC'
  return (
    1 === t.shadowMapType
      ? (e = 'SHADOWMAP_TYPE_PCF')
      : 2 === t.shadowMapType
        ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
        : 3 === t.shadowMapType && (e = 'SHADOWMAP_TYPE_VSM'),
    e
  )
}
function ec(t) {
  let e = 'ENVMAP_TYPE_CUBE'
  if (t.envMap)
    switch (t.envMapMode) {
      case ce:
      case he:
        e = 'ENVMAP_TYPE_CUBE'
        break
      case pe:
        e = 'ENVMAP_TYPE_CUBE_UV'
    }
  return e
}
function nc(t) {
  let e = 'ENVMAP_MODE_REFLECTION'
  if (t.envMap && t.envMapMode === he) e = 'ENVMAP_MODE_REFRACTION'
  return e
}
function ic(t) {
  let e = 'ENVMAP_BLENDING_NONE'
  if (t.envMap)
    switch (t.combine) {
      case 0:
        e = 'ENVMAP_BLENDING_MULTIPLY'
        break
      case 1:
        e = 'ENVMAP_BLENDING_MIX'
        break
      case 2:
        e = 'ENVMAP_BLENDING_ADD'
    }
  return e
}
function sc(t) {
  const e = t.envMapCubeUVHeight
  if (null === e) return null
  const n = Math.log2(e) - 2,
    i = 1 / e
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
    texelHeight: i,
    maxMip: n
  }
}
function rc(t, n, i, s) {
  const r = t.getContext(),
    a = i.defines
  let o = i.vertexShader,
    l = i.fragmentShader
  const c = tc(i),
    h = ec(i),
    u = nc(i),
    d = ic(i),
    p = sc(i),
    m = zl(i),
    f = Vl(a),
    g = r.createProgram()
  let v,
    y,
    _ = i.glslVersion ? '#version ' + i.glslVersion + '\n' : ''
  i.isRawShaderMaterial
    ? ((v = [
        '#define SHADER_TYPE ' + i.shaderType,
        '#define SHADER_NAME ' + i.shaderName,
        f
      ]
        .filter(Gl)
        .join('\n')),
      v.length > 0 && (v += '\n'),
      (y = [
        '#define SHADER_TYPE ' + i.shaderType,
        '#define SHADER_NAME ' + i.shaderName,
        f
      ]
        .filter(Gl)
        .join('\n')),
      y.length > 0 && (y += '\n'))
    : ((v = [
        Ql(i),
        '#define SHADER_TYPE ' + i.shaderType,
        '#define SHADER_NAME ' + i.shaderName,
        f,
        i.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
        i.batching ? '#define USE_BATCHING' : '',
        i.batchingColor ? '#define USE_BATCHING_COLOR' : '',
        i.instancing ? '#define USE_INSTANCING' : '',
        i.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
        i.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',
        i.useFog && i.fog ? '#define USE_FOG' : '',
        i.useFog && i.fogExp2 ? '#define FOG_EXP2' : '',
        i.map ? '#define USE_MAP' : '',
        i.envMap ? '#define USE_ENVMAP' : '',
        i.envMap ? '#define ' + u : '',
        i.lightMap ? '#define USE_LIGHTMAP' : '',
        i.aoMap ? '#define USE_AOMAP' : '',
        i.bumpMap ? '#define USE_BUMPMAP' : '',
        i.normalMap ? '#define USE_NORMALMAP' : '',
        i.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        i.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        i.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
        i.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        i.anisotropy ? '#define USE_ANISOTROPY' : '',
        i.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        i.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        i.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        i.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        i.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        i.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        i.specularMap ? '#define USE_SPECULARMAP' : '',
        i.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        i.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        i.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        i.metalnessMap ? '#define USE_METALNESSMAP' : '',
        i.alphaMap ? '#define USE_ALPHAMAP' : '',
        i.alphaHash ? '#define USE_ALPHAHASH' : '',
        i.transmission ? '#define USE_TRANSMISSION' : '',
        i.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        i.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        i.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        i.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        i.mapUv ? '#define MAP_UV ' + i.mapUv : '',
        i.alphaMapUv ? '#define ALPHAMAP_UV ' + i.alphaMapUv : '',
        i.lightMapUv ? '#define LIGHTMAP_UV ' + i.lightMapUv : '',
        i.aoMapUv ? '#define AOMAP_UV ' + i.aoMapUv : '',
        i.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + i.emissiveMapUv : '',
        i.bumpMapUv ? '#define BUMPMAP_UV ' + i.bumpMapUv : '',
        i.normalMapUv ? '#define NORMALMAP_UV ' + i.normalMapUv : '',
        i.displacementMapUv
          ? '#define DISPLACEMENTMAP_UV ' + i.displacementMapUv
          : '',
        i.metalnessMapUv ? '#define METALNESSMAP_UV ' + i.metalnessMapUv : '',
        i.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + i.roughnessMapUv : '',
        i.anisotropyMapUv
          ? '#define ANISOTROPYMAP_UV ' + i.anisotropyMapUv
          : '',
        i.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + i.clearcoatMapUv : '',
        i.clearcoatNormalMapUv
          ? '#define CLEARCOAT_NORMALMAP_UV ' + i.clearcoatNormalMapUv
          : '',
        i.clearcoatRoughnessMapUv
          ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + i.clearcoatRoughnessMapUv
          : '',
        i.iridescenceMapUv
          ? '#define IRIDESCENCEMAP_UV ' + i.iridescenceMapUv
          : '',
        i.iridescenceThicknessMapUv
          ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + i.iridescenceThicknessMapUv
          : '',
        i.sheenColorMapUv
          ? '#define SHEEN_COLORMAP_UV ' + i.sheenColorMapUv
          : '',
        i.sheenRoughnessMapUv
          ? '#define SHEEN_ROUGHNESSMAP_UV ' + i.sheenRoughnessMapUv
          : '',
        i.specularMapUv ? '#define SPECULARMAP_UV ' + i.specularMapUv : '',
        i.specularColorMapUv
          ? '#define SPECULAR_COLORMAP_UV ' + i.specularColorMapUv
          : '',
        i.specularIntensityMapUv
          ? '#define SPECULAR_INTENSITYMAP_UV ' + i.specularIntensityMapUv
          : '',
        i.transmissionMapUv
          ? '#define TRANSMISSIONMAP_UV ' + i.transmissionMapUv
          : '',
        i.thicknessMapUv ? '#define THICKNESSMAP_UV ' + i.thicknessMapUv : '',
        i.vertexTangents && !1 === i.flatShading ? '#define USE_TANGENT' : '',
        i.vertexColors ? '#define USE_COLOR' : '',
        i.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        i.vertexUv1s ? '#define USE_UV1' : '',
        i.vertexUv2s ? '#define USE_UV2' : '',
        i.vertexUv3s ? '#define USE_UV3' : '',
        i.pointsUvs ? '#define USE_POINTS_UV' : '',
        i.flatShading ? '#define FLAT_SHADED' : '',
        i.skinning ? '#define USE_SKINNING' : '',
        i.morphTargets ? '#define USE_MORPHTARGETS' : '',
        i.morphNormals && !1 === i.flatShading
          ? '#define USE_MORPHNORMALS'
          : '',
        i.morphColors ? '#define USE_MORPHCOLORS' : '',
        i.morphTargetsCount > 0
          ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + i.morphTextureStride
          : '',
        i.morphTargetsCount > 0
          ? '#define MORPHTARGETS_COUNT ' + i.morphTargetsCount
          : '',
        i.doubleSided ? '#define DOUBLE_SIDED' : '',
        i.flipSided ? '#define FLIP_SIDED' : '',
        i.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        i.shadowMapEnabled ? '#define ' + c : '',
        i.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        i.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        i.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        i.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',
        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        '#ifdef USE_INSTANCING',
        '\tattribute mat4 instanceMatrix;',
        '#endif',
        '#ifdef USE_INSTANCING_COLOR',
        '\tattribute vec3 instanceColor;',
        '#endif',
        '#ifdef USE_INSTANCING_MORPH',
        '\tuniform sampler2D morphTexture;',
        '#endif',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        '#ifdef USE_UV1',
        '\tattribute vec2 uv1;',
        '#endif',
        '#ifdef USE_UV2',
        '\tattribute vec2 uv2;',
        '#endif',
        '#ifdef USE_UV3',
        '\tattribute vec2 uv3;',
        '#endif',
        '#ifdef USE_TANGENT',
        '\tattribute vec4 tangent;',
        '#endif',
        '#if defined( USE_COLOR_ALPHA )',
        '\tattribute vec4 color;',
        '#elif defined( USE_COLOR )',
        '\tattribute vec3 color;',
        '#endif',
        '#ifdef USE_SKINNING',
        '\tattribute vec4 skinIndex;',
        '\tattribute vec4 skinWeight;',
        '#endif',
        '\n'
      ]
        .filter(Gl)
        .join('\n')),
      (y = [
        Ql(i),
        '#define SHADER_TYPE ' + i.shaderType,
        '#define SHADER_NAME ' + i.shaderName,
        f,
        i.useFog && i.fog ? '#define USE_FOG' : '',
        i.useFog && i.fogExp2 ? '#define FOG_EXP2' : '',
        i.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
        i.map ? '#define USE_MAP' : '',
        i.matcap ? '#define USE_MATCAP' : '',
        i.envMap ? '#define USE_ENVMAP' : '',
        i.envMap ? '#define ' + h : '',
        i.envMap ? '#define ' + u : '',
        i.envMap ? '#define ' + d : '',
        p ? '#define CUBEUV_TEXEL_WIDTH ' + p.texelWidth : '',
        p ? '#define CUBEUV_TEXEL_HEIGHT ' + p.texelHeight : '',
        p ? '#define CUBEUV_MAX_MIP ' + p.maxMip + '.0' : '',
        i.lightMap ? '#define USE_LIGHTMAP' : '',
        i.aoMap ? '#define USE_AOMAP' : '',
        i.bumpMap ? '#define USE_BUMPMAP' : '',
        i.normalMap ? '#define USE_NORMALMAP' : '',
        i.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        i.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        i.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        i.anisotropy ? '#define USE_ANISOTROPY' : '',
        i.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        i.clearcoat ? '#define USE_CLEARCOAT' : '',
        i.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        i.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        i.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        i.dispersion ? '#define USE_DISPERSION' : '',
        i.iridescence ? '#define USE_IRIDESCENCE' : '',
        i.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        i.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        i.specularMap ? '#define USE_SPECULARMAP' : '',
        i.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        i.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        i.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        i.metalnessMap ? '#define USE_METALNESSMAP' : '',
        i.alphaMap ? '#define USE_ALPHAMAP' : '',
        i.alphaTest ? '#define USE_ALPHATEST' : '',
        i.alphaHash ? '#define USE_ALPHAHASH' : '',
        i.sheen ? '#define USE_SHEEN' : '',
        i.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        i.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        i.transmission ? '#define USE_TRANSMISSION' : '',
        i.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        i.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        i.vertexTangents && !1 === i.flatShading ? '#define USE_TANGENT' : '',
        i.vertexColors || i.instancingColor || i.batchingColor
          ? '#define USE_COLOR'
          : '',
        i.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        i.vertexUv1s ? '#define USE_UV1' : '',
        i.vertexUv2s ? '#define USE_UV2' : '',
        i.vertexUv3s ? '#define USE_UV3' : '',
        i.pointsUvs ? '#define USE_POINTS_UV' : '',
        i.gradientMap ? '#define USE_GRADIENTMAP' : '',
        i.flatShading ? '#define FLAT_SHADED' : '',
        i.doubleSided ? '#define DOUBLE_SIDED' : '',
        i.flipSided ? '#define FLIP_SIDED' : '',
        i.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        i.shadowMapEnabled ? '#define ' + c : '',
        i.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
        i.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        i.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
        i.decodeVideoTextureEmissive
          ? '#define DECODE_VIDEO_TEXTURE_EMISSIVE'
          : '',
        i.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        i.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',
        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        0 !== i.toneMapping ? '#define TONE_MAPPING' : '',
        0 !== i.toneMapping ? Ua.tonemapping_pars_fragment : '',
        0 !== i.toneMapping ? Bl('toneMapping', i.toneMapping) : '',
        i.dithering ? '#define DITHERING' : '',
        i.opaque ? '#define OPAQUE' : '',
        Ua.colorspace_pars_fragment,
        Ul('linearToOutputTexel', i.outputColorSpace),
        Fl(),
        i.useDepthPacking ? '#define DEPTH_PACKING ' + i.depthPacking : '',
        '\n'
      ]
        .filter(Gl)
        .join('\n'))),
    (o = ql(o)),
    (o = Wl(o, i)),
    (o = jl(o, i)),
    (l = ql(l)),
    (l = Wl(l, i)),
    (l = jl(l, i)),
    (o = $l(o)),
    (l = $l(l)),
    !0 !== i.isRawShaderMaterial &&
      ((_ = '#version 300 es\n'),
      (v =
        [
          m,
          '#define attribute in',
          '#define varying out',
          '#define texture2D texture'
        ].join('\n') +
        '\n' +
        v),
      (y =
        [
          '#define varying in',
          i.glslVersion === zn
            ? ''
            : 'layout(location = 0) out highp vec4 pc_fragColor;',
          i.glslVersion === zn ? '' : '#define gl_FragColor pc_fragColor',
          '#define gl_FragDepthEXT gl_FragDepth',
          '#define texture2D texture',
          '#define textureCube texture',
          '#define texture2DProj textureProj',
          '#define texture2DLodEXT textureLod',
          '#define texture2DProjLodEXT textureProjLod',
          '#define textureCubeLodEXT textureLod',
          '#define texture2DGradEXT textureGrad',
          '#define texture2DProjGradEXT textureProjGrad',
          '#define textureCubeGradEXT textureGrad'
        ].join('\n') +
        '\n' +
        y))
  const x = _ + v + o,
    b = _ + y + l,
    w = Pl(r, r.VERTEX_SHADER, x),
    M = Pl(r, r.FRAGMENT_SHADER, b)
  function S(e) {
    if (t.debug.checkShaderErrors) {
      const n = r.getProgramInfoLog(g).trim(),
        i = r.getShaderInfoLog(w).trim(),
        s = r.getShaderInfoLog(M).trim()
      let a = !0,
        o = !0
      if (!1 === r.getProgramParameter(g, r.LINK_STATUS))
        if (((a = !1), 'function' == typeof t.debug.onShaderError))
          t.debug.onShaderError(r, g, w, M)
        else {
          const t = Nl(r, w, 'vertex'),
            i = Nl(r, M, 'fragment')
          console.error(
            'THREE.WebGLProgram: Shader Error ' +
              r.getError() +
              ' - VALIDATE_STATUS ' +
              r.getProgramParameter(g, r.VALIDATE_STATUS) +
              '\n\nMaterial Name: ' +
              e.name +
              '\nMaterial Type: ' +
              e.type +
              '\n\nProgram Info Log: ' +
              n +
              '\n' +
              t +
              '\n' +
              i
          )
        }
      else
        '' !== n
          ? console.warn('THREE.WebGLProgram: Program Info Log:', n)
          : ('' !== i && '' !== s) || (o = !1)
      o &&
        (e.diagnostics = {
          runnable: a,
          programLog: n,
          vertexShader: { log: i, prefix: v },
          fragmentShader: { log: s, prefix: y }
        })
    }
    r.deleteShader(w), r.deleteShader(M), (T = new Rl(r, g)), (E = Hl(r, g))
  }
  let T, E
  r.attachShader(g, w),
    r.attachShader(g, M),
    void 0 !== i.index0AttributeName
      ? r.bindAttribLocation(g, 0, i.index0AttributeName)
      : !0 === i.morphTargets && r.bindAttribLocation(g, 0, 'position'),
    r.linkProgram(g),
    e(S, 'onFirstUse'),
    (this.getUniforms = function () {
      return void 0 === T && S(this), T
    }),
    (this.getAttributes = function () {
      return void 0 === E && S(this), E
    })
  let A = !1 === i.rendererExtensionParallelShaderCompile
  return (
    (this.isReady = function () {
      return !1 === A && (A = r.getProgramParameter(g, 37297)), A
    }),
    (this.destroy = function () {
      s.releaseStatesOfProgram(this),
        r.deleteProgram(g),
        (this.program = void 0)
    }),
    (this.type = i.shaderType),
    (this.name = i.shaderName),
    (this.id = Il++),
    (this.cacheKey = n),
    (this.usedTimes = 1),
    (this.program = g),
    (this.vertexShader = w),
    (this.fragmentShader = M),
    this
  )
}
e($l, 'unrollLoops'),
  e(Jl, 'loopReplacer'),
  e(Ql, 'generatePrecision'),
  e(tc, 'generateShadowMapTypeDefine'),
  e(ec, 'generateEnvMapTypeDefine'),
  e(nc, 'generateEnvMapModeDefine'),
  e(ic, 'generateEnvMapBlendingDefine'),
  e(sc, 'generateCubeUVSize'),
  e(rc, 'WebGLProgram')
let ac = 0
class oc {
  static {
    e(this, 'WebGLShaderCache')
  }
  constructor() {
    ;(this.shaderCache = new Map()), (this.materialCache = new Map())
  }
  update(t) {
    const e = t.vertexShader,
      n = t.fragmentShader,
      i = this._getShaderStage(e),
      s = this._getShaderStage(n),
      r = this._getShaderCacheForMaterial(t)
    return (
      !1 === r.has(i) && (r.add(i), i.usedTimes++),
      !1 === r.has(s) && (r.add(s), s.usedTimes++),
      this
    )
  }
  remove(t) {
    const e = this.materialCache.get(t)
    for (const n of e)
      n.usedTimes--, 0 === n.usedTimes && this.shaderCache.delete(n.code)
    return this.materialCache.delete(t), this
  }
  getVertexShaderID(t) {
    return this._getShaderStage(t.vertexShader).id
  }
  getFragmentShaderID(t) {
    return this._getShaderStage(t.fragmentShader).id
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear()
  }
  _getShaderCacheForMaterial(t) {
    const e = this.materialCache
    let n = e.get(t)
    return void 0 === n && ((n = new Set()), e.set(t, n)), n
  }
  _getShaderStage(t) {
    const e = this.shaderCache
    let n = e.get(t)
    return void 0 === n && ((n = new lc(t)), e.set(t, n)), n
  }
}
class lc {
  static {
    e(this, 'WebGLShaderStage')
  }
  constructor(t) {
    ;(this.id = ac++), (this.code = t), (this.usedTimes = 0)
  }
}
function cc(t, n, i, s, r, a, o) {
  const l = new zs(),
    c = new oc(),
    h = new Set(),
    u = [],
    d = r.logarithmicDepthBuffer,
    p = r.vertexTextures
  let m = r.precision
  const f = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  }
  function g(t) {
    return h.add(t), 0 === t ? 'uv' : `uv${t}`
  }
  function v(e, a, l, u, v) {
    const y = u.fog,
      _ = v.geometry,
      x = e.isMeshStandardMaterial ? u.environment : null,
      b = (e.isMeshStandardMaterial ? i : n).get(e.envMap || x),
      w = b && b.mapping === pe ? b.image.height : null,
      M = f[e.type]
    null !== e.precision &&
      ((m = r.getMaxPrecision(e.precision)),
      m !== e.precision &&
        console.warn(
          'THREE.WebGLProgram.getParameters:',
          e.precision,
          'not supported, using',
          m,
          'instead.'
        ))
    const S =
        _.morphAttributes.position ||
        _.morphAttributes.normal ||
        _.morphAttributes.color,
      T = void 0 !== S ? S.length : 0
    let E,
      A,
      C,
      R,
      P = 0
    if (
      (void 0 !== _.morphAttributes.position && (P = 1),
      void 0 !== _.morphAttributes.normal && (P = 2),
      void 0 !== _.morphAttributes.color && (P = 3),
      M)
    ) {
      const t = Oa[M]
      ;(E = t.vertexShader), (A = t.fragmentShader)
    } else
      (E = e.vertexShader),
        (A = e.fragmentShader),
        c.update(e),
        (C = c.getVertexShaderID(e)),
        (R = c.getFragmentShaderID(e))
    const I = t.getRenderTarget(),
      L = t.state.buffers.depth.getReversed(),
      D = !0 === v.isInstancedMesh,
      k = !0 === v.isBatchedMesh,
      N = !!e.map,
      U = !!e.matcap,
      B = !!b,
      O = !!e.aoMap,
      F = !!e.lightMap,
      z = !!e.bumpMap,
      V = !!e.normalMap,
      H = !!e.displacementMap,
      G = !!e.emissiveMap,
      W = !!e.metalnessMap,
      j = !!e.roughnessMap,
      X = e.anisotropy > 0,
      q = e.clearcoat > 0,
      Y = e.dispersion > 0,
      Z = e.iridescence > 0,
      K = e.sheen > 0,
      $ = e.transmission > 0,
      J = X && !!e.anisotropyMap,
      Q = q && !!e.clearcoatMap,
      tt = q && !!e.clearcoatNormalMap,
      et = q && !!e.clearcoatRoughnessMap,
      nt = Z && !!e.iridescenceMap,
      it = Z && !!e.iridescenceThicknessMap,
      st = K && !!e.sheenColorMap,
      rt = K && !!e.sheenRoughnessMap,
      at = !!e.specularMap,
      ot = !!e.specularColorMap,
      lt = !!e.specularIntensityMap,
      ct = $ && !!e.transmissionMap,
      ht = $ && !!e.thicknessMap,
      ut = !!e.gradientMap,
      dt = !!e.alphaMap,
      pt = e.alphaTest > 0,
      mt = !!e.alphaHash,
      ft = !!e.extensions
    let gt = 0
    e.toneMapped &&
      ((null !== I && !0 !== I.isXRRenderTarget) || (gt = t.toneMapping))
    const vt = {
      shaderID: M,
      shaderType: e.type,
      shaderName: e.name,
      vertexShader: E,
      fragmentShader: A,
      defines: e.defines,
      customVertexShaderID: C,
      customFragmentShaderID: R,
      isRawShaderMaterial: !0 === e.isRawShaderMaterial,
      glslVersion: e.glslVersion,
      precision: m,
      batching: k,
      batchingColor: k && null !== v._colorsTexture,
      instancing: D,
      instancingColor: D && null !== v.instanceColor,
      instancingMorph: D && null !== v.morphTexture,
      supportsVertexTextures: p,
      outputColorSpace:
        null === I
          ? t.outputColorSpace
          : !0 === I.isXRRenderTarget
            ? I.texture.colorSpace
            : An,
      alphaToCoverage: !!e.alphaToCoverage,
      map: N,
      matcap: U,
      envMap: B,
      envMapMode: B && b.mapping,
      envMapCubeUVHeight: w,
      aoMap: O,
      lightMap: F,
      bumpMap: z,
      normalMap: V,
      displacementMap: p && H,
      emissiveMap: G,
      normalMapObjectSpace: V && 1 === e.normalMapType,
      normalMapTangentSpace: V && 0 === e.normalMapType,
      metalnessMap: W,
      roughnessMap: j,
      anisotropy: X,
      anisotropyMap: J,
      clearcoat: q,
      clearcoatMap: Q,
      clearcoatNormalMap: tt,
      clearcoatRoughnessMap: et,
      dispersion: Y,
      iridescence: Z,
      iridescenceMap: nt,
      iridescenceThicknessMap: it,
      sheen: K,
      sheenColorMap: st,
      sheenRoughnessMap: rt,
      specularMap: at,
      specularColorMap: ot,
      specularIntensityMap: lt,
      transmission: $,
      transmissionMap: ct,
      thicknessMap: ht,
      gradientMap: ut,
      opaque:
        !1 === e.transparent && 1 === e.blending && !1 === e.alphaToCoverage,
      alphaMap: dt,
      alphaTest: pt,
      alphaHash: mt,
      combine: e.combine,
      mapUv: N && g(e.map.channel),
      aoMapUv: O && g(e.aoMap.channel),
      lightMapUv: F && g(e.lightMap.channel),
      bumpMapUv: z && g(e.bumpMap.channel),
      normalMapUv: V && g(e.normalMap.channel),
      displacementMapUv: H && g(e.displacementMap.channel),
      emissiveMapUv: G && g(e.emissiveMap.channel),
      metalnessMapUv: W && g(e.metalnessMap.channel),
      roughnessMapUv: j && g(e.roughnessMap.channel),
      anisotropyMapUv: J && g(e.anisotropyMap.channel),
      clearcoatMapUv: Q && g(e.clearcoatMap.channel),
      clearcoatNormalMapUv: tt && g(e.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: et && g(e.clearcoatRoughnessMap.channel),
      iridescenceMapUv: nt && g(e.iridescenceMap.channel),
      iridescenceThicknessMapUv: it && g(e.iridescenceThicknessMap.channel),
      sheenColorMapUv: st && g(e.sheenColorMap.channel),
      sheenRoughnessMapUv: rt && g(e.sheenRoughnessMap.channel),
      specularMapUv: at && g(e.specularMap.channel),
      specularColorMapUv: ot && g(e.specularColorMap.channel),
      specularIntensityMapUv: lt && g(e.specularIntensityMap.channel),
      transmissionMapUv: ct && g(e.transmissionMap.channel),
      thicknessMapUv: ht && g(e.thicknessMap.channel),
      alphaMapUv: dt && g(e.alphaMap.channel),
      vertexTangents: !!_.attributes.tangent && (V || X),
      vertexColors: e.vertexColors,
      vertexAlphas:
        !0 === e.vertexColors &&
        !!_.attributes.color &&
        4 === _.attributes.color.itemSize,
      pointsUvs: !0 === v.isPoints && !!_.attributes.uv && (N || dt),
      fog: !!y,
      useFog: !0 === e.fog,
      fogExp2: !!y && y.isFogExp2,
      flatShading: !0 === e.flatShading,
      sizeAttenuation: !0 === e.sizeAttenuation,
      logarithmicDepthBuffer: d,
      reverseDepthBuffer: L,
      skinning: !0 === v.isSkinnedMesh,
      morphTargets: void 0 !== _.morphAttributes.position,
      morphNormals: void 0 !== _.morphAttributes.normal,
      morphColors: void 0 !== _.morphAttributes.color,
      morphTargetsCount: T,
      morphTextureStride: P,
      numDirLights: a.directional.length,
      numPointLights: a.point.length,
      numSpotLights: a.spot.length,
      numSpotLightMaps: a.spotLightMap.length,
      numRectAreaLights: a.rectArea.length,
      numHemiLights: a.hemi.length,
      numDirLightShadows: a.directionalShadowMap.length,
      numPointLightShadows: a.pointShadowMap.length,
      numSpotLightShadows: a.spotShadowMap.length,
      numSpotLightShadowsWithMaps: a.numSpotLightShadowsWithMaps,
      numLightProbes: a.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: e.dithering,
      shadowMapEnabled: t.shadowMap.enabled && l.length > 0,
      shadowMapType: t.shadowMap.type,
      toneMapping: gt,
      decodeVideoTexture:
        N &&
        !0 === e.map.isVideoTexture &&
        Pi.getTransfer(e.map.colorSpace) === Rn,
      decodeVideoTextureEmissive:
        G &&
        !0 === e.emissiveMap.isVideoTexture &&
        Pi.getTransfer(e.emissiveMap.colorSpace) === Rn,
      premultipliedAlpha: e.premultipliedAlpha,
      doubleSided: 2 === e.side,
      flipSided: 1 === e.side,
      useDepthPacking: e.depthPacking >= 0,
      depthPacking: e.depthPacking || 0,
      index0AttributeName: e.index0AttributeName,
      extensionClipCullDistance:
        ft &&
        !0 === e.extensions.clipCullDistance &&
        s.has('WEBGL_clip_cull_distance'),
      extensionMultiDraw:
        ((ft && !0 === e.extensions.multiDraw) || k) &&
        s.has('WEBGL_multi_draw'),
      rendererExtensionParallelShaderCompile: s.has(
        'KHR_parallel_shader_compile'
      ),
      customProgramCacheKey: e.customProgramCacheKey()
    }
    return (
      (vt.vertexUv1s = h.has(1)),
      (vt.vertexUv2s = h.has(2)),
      (vt.vertexUv3s = h.has(3)),
      h.clear(),
      vt
    )
  }
  function y(e) {
    const n = []
    if (
      (e.shaderID
        ? n.push(e.shaderID)
        : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)),
      void 0 !== e.defines)
    )
      for (const t in e.defines) n.push(t), n.push(e.defines[t])
    return (
      !1 === e.isRawShaderMaterial &&
        (_(n, e), x(n, e), n.push(t.outputColorSpace)),
      n.push(e.customProgramCacheKey),
      n.join()
    )
  }
  function _(t, e) {
    t.push(e.precision),
      t.push(e.outputColorSpace),
      t.push(e.envMapMode),
      t.push(e.envMapCubeUVHeight),
      t.push(e.mapUv),
      t.push(e.alphaMapUv),
      t.push(e.lightMapUv),
      t.push(e.aoMapUv),
      t.push(e.bumpMapUv),
      t.push(e.normalMapUv),
      t.push(e.displacementMapUv),
      t.push(e.emissiveMapUv),
      t.push(e.metalnessMapUv),
      t.push(e.roughnessMapUv),
      t.push(e.anisotropyMapUv),
      t.push(e.clearcoatMapUv),
      t.push(e.clearcoatNormalMapUv),
      t.push(e.clearcoatRoughnessMapUv),
      t.push(e.iridescenceMapUv),
      t.push(e.iridescenceThicknessMapUv),
      t.push(e.sheenColorMapUv),
      t.push(e.sheenRoughnessMapUv),
      t.push(e.specularMapUv),
      t.push(e.specularColorMapUv),
      t.push(e.specularIntensityMapUv),
      t.push(e.transmissionMapUv),
      t.push(e.thicknessMapUv),
      t.push(e.combine),
      t.push(e.fogExp2),
      t.push(e.sizeAttenuation),
      t.push(e.morphTargetsCount),
      t.push(e.morphAttributeCount),
      t.push(e.numDirLights),
      t.push(e.numPointLights),
      t.push(e.numSpotLights),
      t.push(e.numSpotLightMaps),
      t.push(e.numHemiLights),
      t.push(e.numRectAreaLights),
      t.push(e.numDirLightShadows),
      t.push(e.numPointLightShadows),
      t.push(e.numSpotLightShadows),
      t.push(e.numSpotLightShadowsWithMaps),
      t.push(e.numLightProbes),
      t.push(e.shadowMapType),
      t.push(e.toneMapping),
      t.push(e.numClippingPlanes),
      t.push(e.numClipIntersection),
      t.push(e.depthPacking)
  }
  function x(t, e) {
    l.disableAll(),
      e.supportsVertexTextures && l.enable(0),
      e.instancing && l.enable(1),
      e.instancingColor && l.enable(2),
      e.instancingMorph && l.enable(3),
      e.matcap && l.enable(4),
      e.envMap && l.enable(5),
      e.normalMapObjectSpace && l.enable(6),
      e.normalMapTangentSpace && l.enable(7),
      e.clearcoat && l.enable(8),
      e.iridescence && l.enable(9),
      e.alphaTest && l.enable(10),
      e.vertexColors && l.enable(11),
      e.vertexAlphas && l.enable(12),
      e.vertexUv1s && l.enable(13),
      e.vertexUv2s && l.enable(14),
      e.vertexUv3s && l.enable(15),
      e.vertexTangents && l.enable(16),
      e.anisotropy && l.enable(17),
      e.alphaHash && l.enable(18),
      e.batching && l.enable(19),
      e.dispersion && l.enable(20),
      e.batchingColor && l.enable(21),
      t.push(l.mask),
      l.disableAll(),
      e.fog && l.enable(0),
      e.useFog && l.enable(1),
      e.flatShading && l.enable(2),
      e.logarithmicDepthBuffer && l.enable(3),
      e.reverseDepthBuffer && l.enable(4),
      e.skinning && l.enable(5),
      e.morphTargets && l.enable(6),
      e.morphNormals && l.enable(7),
      e.morphColors && l.enable(8),
      e.premultipliedAlpha && l.enable(9),
      e.shadowMapEnabled && l.enable(10),
      e.doubleSided && l.enable(11),
      e.flipSided && l.enable(12),
      e.useDepthPacking && l.enable(13),
      e.dithering && l.enable(14),
      e.transmission && l.enable(15),
      e.sheen && l.enable(16),
      e.opaque && l.enable(17),
      e.pointsUvs && l.enable(18),
      e.decodeVideoTexture && l.enable(19),
      e.decodeVideoTextureEmissive && l.enable(20),
      e.alphaToCoverage && l.enable(21),
      t.push(l.mask)
  }
  function b(t) {
    const e = f[t.type]
    let n
    if (e) {
      const t = Oa[e]
      n = fa.clone(t.uniforms)
    } else n = t.uniforms
    return n
  }
  function w(e, n) {
    let i
    for (let t = 0, s = u.length; t < s; t++) {
      const e = u[t]
      if (e.cacheKey === n) {
        ;(i = e), ++i.usedTimes
        break
      }
    }
    return void 0 === i && ((i = new rc(t, n, e, a)), u.push(i)), i
  }
  function M(t) {
    if (0 == --t.usedTimes) {
      const e = u.indexOf(t)
      ;(u[e] = u[u.length - 1]), u.pop(), t.destroy()
    }
  }
  function S(t) {
    c.remove(t)
  }
  function T() {
    c.dispose()
  }
  return (
    e(g, 'getChannel'),
    e(v, 'getParameters'),
    e(y, 'getProgramCacheKey'),
    e(_, 'getProgramCacheKeyParameters'),
    e(x, 'getProgramCacheKeyBooleans'),
    e(b, 'getUniforms'),
    e(w, 'acquireProgram'),
    e(M, 'releaseProgram'),
    e(S, 'releaseShaderCache'),
    e(T, 'dispose'),
    {
      getParameters: v,
      getProgramCacheKey: y,
      getUniforms: b,
      acquireProgram: w,
      releaseProgram: M,
      releaseShaderCache: S,
      programs: u,
      dispose: T
    }
  )
}
function hc() {
  let t = new WeakMap()
  function n(e) {
    return t.has(e)
  }
  function i(e) {
    let n = t.get(e)
    return void 0 === n && ((n = {}), t.set(e, n)), n
  }
  function s(e) {
    t.delete(e)
  }
  function r(e, n, i) {
    t.get(e)[n] = i
  }
  function a() {
    t = new WeakMap()
  }
  return (
    e(n, 'has'),
    e(i, 'get'),
    e(s, 'remove'),
    e(r, 'update'),
    e(a, 'dispose'),
    { has: n, get: i, remove: s, update: r, dispose: a }
  )
}
function uc(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.material.id !== e.material.id
        ? t.material.id - e.material.id
        : t.z !== e.z
          ? t.z - e.z
          : t.id - e.id
}
function dc(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.z !== e.z
        ? e.z - t.z
        : t.id - e.id
}
function pc() {
  const t = []
  let n = 0
  const i = [],
    s = [],
    r = []
  function a() {
    ;(n = 0), (i.length = 0), (s.length = 0), (r.length = 0)
  }
  function o(e, i, s, r, a, o) {
    let l = t[n]
    return (
      void 0 === l
        ? ((l = {
            id: e.id,
            object: e,
            geometry: i,
            material: s,
            groupOrder: r,
            renderOrder: e.renderOrder,
            z: a,
            group: o
          }),
          (t[n] = l))
        : ((l.id = e.id),
          (l.object = e),
          (l.geometry = i),
          (l.material = s),
          (l.groupOrder = r),
          (l.renderOrder = e.renderOrder),
          (l.z = a),
          (l.group = o)),
      n++,
      l
    )
  }
  function l(t, e, n, a, l, c) {
    const h = o(t, e, n, a, l, c)
    n.transmission > 0
      ? s.push(h)
      : !0 === n.transparent
        ? r.push(h)
        : i.push(h)
  }
  function c(t, e, n, a, l, c) {
    const h = o(t, e, n, a, l, c)
    n.transmission > 0
      ? s.unshift(h)
      : !0 === n.transparent
        ? r.unshift(h)
        : i.unshift(h)
  }
  function h(t, e) {
    i.length > 1 && i.sort(t || uc),
      s.length > 1 && s.sort(e || dc),
      r.length > 1 && r.sort(e || dc)
  }
  function u() {
    for (let e = n, i = t.length; e < i; e++) {
      const n = t[e]
      if (null === n.id) break
      ;(n.id = null),
        (n.object = null),
        (n.geometry = null),
        (n.material = null),
        (n.group = null)
    }
  }
  return (
    e(a, 'init'),
    e(o, 'getNextRenderItem'),
    e(l, 'push'),
    e(c, 'unshift'),
    e(h, 'sort'),
    e(u, 'finish'),
    {
      opaque: i,
      transmissive: s,
      transparent: r,
      init: a,
      push: l,
      unshift: c,
      finish: u,
      sort: h
    }
  )
}
function mc() {
  let t = new WeakMap()
  function n(e, n) {
    const i = t.get(e)
    let s
    return (
      void 0 === i
        ? ((s = new pc()), t.set(e, [s]))
        : n >= i.length
          ? ((s = new pc()), i.push(s))
          : (s = i[n]),
      s
    )
  }
  function i() {
    t = new WeakMap()
  }
  return e(n, 'get'), e(i, 'dispose'), { get: n, dispose: i }
}
function fc() {
  const t = {}
  return {
    get: e(function (e) {
      if (void 0 !== t[e.id]) return t[e.id]
      let n
      switch (e.type) {
        case 'DirectionalLight':
          n = { direction: new Qi(), color: new br() }
          break
        case 'SpotLight':
          n = {
            position: new Qi(),
            direction: new Qi(),
            color: new br(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          }
          break
        case 'PointLight':
          n = { position: new Qi(), color: new br(), distance: 0, decay: 0 }
          break
        case 'HemisphereLight':
          n = { direction: new Qi(), skyColor: new br(), groundColor: new br() }
          break
        case 'RectAreaLight':
          n = {
            color: new br(),
            position: new Qi(),
            halfWidth: new Qi(),
            halfHeight: new Qi()
          }
      }
      return (t[e.id] = n), n
    }, 'get')
  }
}
function gc() {
  const t = {}
  return {
    get: e(function (e) {
      if (void 0 !== t[e.id]) return t[e.id]
      let n
      switch (e.type) {
        case 'DirectionalLight':
        case 'SpotLight':
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new vi()
          }
          break
        case 'PointLight':
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new vi(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          }
      }
      return (t[e.id] = n), n
    }, 'get')
  }
}
e(cc, 'WebGLPrograms'),
  e(hc, 'WebGLProperties'),
  e(uc, 'painterSortStable'),
  e(dc, 'reversePainterSortStable'),
  e(pc, 'WebGLRenderList'),
  e(mc, 'WebGLRenderLists'),
  e(fc, 'UniformsCache'),
  e(gc, 'ShadowUniformsCache')
let vc = 0
function yc(t, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (t.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (t.map ? 1 : 0)
  )
}
function _c(t) {
  const n = new fc(),
    i = gc(),
    s = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0
    }
  for (let e = 0; e < 9; e++) s.probe.push(new Qi())
  const r = new Qi(),
    a = new Rs(),
    o = new Rs()
  function l(e) {
    let r = 0,
      a = 0,
      o = 0
    for (let t = 0; t < 9; t++) s.probe[t].set(0, 0, 0)
    let l = 0,
      c = 0,
      h = 0,
      u = 0,
      d = 0,
      p = 0,
      m = 0,
      f = 0,
      g = 0,
      v = 0,
      y = 0
    e.sort(yc)
    for (let t = 0, x = e.length; t < x; t++) {
      const _ = e[t],
        x = _.color,
        b = _.intensity,
        w = _.distance,
        M = _.shadow && _.shadow.map ? _.shadow.map.texture : null
      if (_.isAmbientLight) (r += x.r * b), (a += x.g * b), (o += x.b * b)
      else if (_.isLightProbe) {
        for (let t = 0; t < 9; t++)
          s.probe[t].addScaledVector(_.sh.coefficients[t], b)
        y++
      } else if (_.isDirectionalLight) {
        const t = n.get(_)
        if ((t.color.copy(_.color).multiplyScalar(_.intensity), _.castShadow)) {
          const t = _.shadow,
            e = i.get(_)
          ;(e.shadowIntensity = t.intensity),
            (e.shadowBias = t.bias),
            (e.shadowNormalBias = t.normalBias),
            (e.shadowRadius = t.radius),
            (e.shadowMapSize = t.mapSize),
            (s.directionalShadow[l] = e),
            (s.directionalShadowMap[l] = M),
            (s.directionalShadowMatrix[l] = _.shadow.matrix),
            p++
        }
        ;(s.directional[l] = t), l++
      } else if (_.isSpotLight) {
        const t = n.get(_)
        t.position.setFromMatrixPosition(_.matrixWorld),
          t.color.copy(x).multiplyScalar(b),
          (t.distance = w),
          (t.coneCos = Math.cos(_.angle)),
          (t.penumbraCos = Math.cos(_.angle * (1 - _.penumbra))),
          (t.decay = _.decay),
          (s.spot[h] = t)
        const e = _.shadow
        if (
          (_.map &&
            ((s.spotLightMap[g] = _.map),
            g++,
            e.updateMatrices(_),
            _.castShadow && v++),
          (s.spotLightMatrix[h] = e.matrix),
          _.castShadow)
        ) {
          const t = i.get(_)
          ;(t.shadowIntensity = e.intensity),
            (t.shadowBias = e.bias),
            (t.shadowNormalBias = e.normalBias),
            (t.shadowRadius = e.radius),
            (t.shadowMapSize = e.mapSize),
            (s.spotShadow[h] = t),
            (s.spotShadowMap[h] = M),
            f++
        }
        h++
      } else if (_.isRectAreaLight) {
        const t = n.get(_)
        t.color.copy(x).multiplyScalar(b),
          t.halfWidth.set(0.5 * _.width, 0, 0),
          t.halfHeight.set(0, 0.5 * _.height, 0),
          (s.rectArea[u] = t),
          u++
      } else if (_.isPointLight) {
        const t = n.get(_)
        if (
          (t.color.copy(_.color).multiplyScalar(_.intensity),
          (t.distance = _.distance),
          (t.decay = _.decay),
          _.castShadow)
        ) {
          const t = _.shadow,
            e = i.get(_)
          ;(e.shadowIntensity = t.intensity),
            (e.shadowBias = t.bias),
            (e.shadowNormalBias = t.normalBias),
            (e.shadowRadius = t.radius),
            (e.shadowMapSize = t.mapSize),
            (e.shadowCameraNear = t.camera.near),
            (e.shadowCameraFar = t.camera.far),
            (s.pointShadow[c] = e),
            (s.pointShadowMap[c] = M),
            (s.pointShadowMatrix[c] = _.shadow.matrix),
            m++
        }
        ;(s.point[c] = t), c++
      } else if (_.isHemisphereLight) {
        const t = n.get(_)
        t.skyColor.copy(_.color).multiplyScalar(b),
          t.groundColor.copy(_.groundColor).multiplyScalar(b),
          (s.hemi[d] = t),
          d++
      }
    }
    u > 0 &&
      (!0 === t.has('OES_texture_float_linear')
        ? ((s.rectAreaLTC1 = Ba.LTC_FLOAT_1), (s.rectAreaLTC2 = Ba.LTC_FLOAT_2))
        : ((s.rectAreaLTC1 = Ba.LTC_HALF_1), (s.rectAreaLTC2 = Ba.LTC_HALF_2))),
      (s.ambient[0] = r),
      (s.ambient[1] = a),
      (s.ambient[2] = o)
    const _ = s.hash
    ;(_.directionalLength === l &&
      _.pointLength === c &&
      _.spotLength === h &&
      _.rectAreaLength === u &&
      _.hemiLength === d &&
      _.numDirectionalShadows === p &&
      _.numPointShadows === m &&
      _.numSpotShadows === f &&
      _.numSpotMaps === g &&
      _.numLightProbes === y) ||
      ((s.directional.length = l),
      (s.spot.length = h),
      (s.rectArea.length = u),
      (s.point.length = c),
      (s.hemi.length = d),
      (s.directionalShadow.length = p),
      (s.directionalShadowMap.length = p),
      (s.pointShadow.length = m),
      (s.pointShadowMap.length = m),
      (s.spotShadow.length = f),
      (s.spotShadowMap.length = f),
      (s.directionalShadowMatrix.length = p),
      (s.pointShadowMatrix.length = m),
      (s.spotLightMatrix.length = f + g - v),
      (s.spotLightMap.length = g),
      (s.numSpotLightShadowsWithMaps = v),
      (s.numLightProbes = y),
      (_.directionalLength = l),
      (_.pointLength = c),
      (_.spotLength = h),
      (_.rectAreaLength = u),
      (_.hemiLength = d),
      (_.numDirectionalShadows = p),
      (_.numPointShadows = m),
      (_.numSpotShadows = f),
      (_.numSpotMaps = g),
      (_.numLightProbes = y),
      (s.version = vc++))
  }
  function c(t, e) {
    let n = 0,
      i = 0,
      l = 0,
      c = 0,
      h = 0
    const u = e.matrixWorldInverse
    for (let d = 0, p = t.length; d < p; d++) {
      const e = t[d]
      if (e.isDirectionalLight) {
        const t = s.directional[n]
        t.direction.setFromMatrixPosition(e.matrixWorld),
          r.setFromMatrixPosition(e.target.matrixWorld),
          t.direction.sub(r),
          t.direction.transformDirection(u),
          n++
      } else if (e.isSpotLight) {
        const t = s.spot[l]
        t.position.setFromMatrixPosition(e.matrixWorld),
          t.position.applyMatrix4(u),
          t.direction.setFromMatrixPosition(e.matrixWorld),
          r.setFromMatrixPosition(e.target.matrixWorld),
          t.direction.sub(r),
          t.direction.transformDirection(u),
          l++
      } else if (e.isRectAreaLight) {
        const t = s.rectArea[c]
        t.position.setFromMatrixPosition(e.matrixWorld),
          t.position.applyMatrix4(u),
          o.identity(),
          a.copy(e.matrixWorld),
          a.premultiply(u),
          o.extractRotation(a),
          t.halfWidth.set(0.5 * e.width, 0, 0),
          t.halfHeight.set(0, 0.5 * e.height, 0),
          t.halfWidth.applyMatrix4(o),
          t.halfHeight.applyMatrix4(o),
          c++
      } else if (e.isPointLight) {
        const t = s.point[i]
        t.position.setFromMatrixPosition(e.matrixWorld),
          t.position.applyMatrix4(u),
          i++
      } else if (e.isHemisphereLight) {
        const t = s.hemi[h]
        t.direction.setFromMatrixPosition(e.matrixWorld),
          t.direction.transformDirection(u),
          h++
      }
    }
  }
  return e(l, 'setup'), e(c, 'setupView'), { setup: l, setupView: c, state: s }
}
function xc(t) {
  const n = new _c(t),
    i = [],
    s = []
  function r(t) {
    ;(h.camera = t), (i.length = 0), (s.length = 0)
  }
  function a(t) {
    i.push(t)
  }
  function o(t) {
    s.push(t)
  }
  function l() {
    n.setup(i)
  }
  function c(t) {
    n.setupView(i, t)
  }
  e(r, 'init'),
    e(a, 'pushLight'),
    e(o, 'pushShadow'),
    e(l, 'setupLights'),
    e(c, 'setupLightsView')
  const h = {
    lightsArray: i,
    shadowsArray: s,
    camera: null,
    lights: n,
    transmissionRenderTarget: {}
  }
  return {
    init: r,
    state: h,
    setupLights: l,
    setupLightsView: c,
    pushLight: a,
    pushShadow: o
  }
}
function bc(t) {
  let n = new WeakMap()
  function i(e, i = 0) {
    const s = n.get(e)
    let r
    return (
      void 0 === s
        ? ((r = new xc(t)), n.set(e, [r]))
        : i >= s.length
          ? ((r = new xc(t)), s.push(r))
          : (r = s[i]),
      r
    )
  }
  function s() {
    n = new WeakMap()
  }
  return e(i, 'get'), e(s, 'dispose'), { get: i, dispose: s }
}
e(yc, 'shadowCastingAndTexturingLightsFirst'),
  e(_c, 'WebGLLights'),
  e(xc, 'WebGLRenderState'),
  e(bc, 'WebGLRenderStates')
class wc extends Sr {
  static {
    e(this, 'MeshDepthMaterial')
  }
  static get type() {
    return 'MeshDepthMaterial'
  }
  constructor(t) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.depthPacking = Sn),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.depthPacking = t.depthPacking),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      this
    )
  }
}
class Mc extends Sr {
  static {
    e(this, 'MeshDistanceMaterial')
  }
  static get type() {
    return 'MeshDistanceMaterial'
  }
  constructor(t) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      this
    )
  }
}
function Sc(t, n, i) {
  let s = new La()
  const r = new vi(),
    a = new vi(),
    o = new ji(),
    l = new wc({ depthPacking: 3201 }),
    c = new Mc(),
    h = {},
    u = i.maxTextureSize,
    d = { [Dt]: 1, [kt]: 0, [Nt]: 2 },
    p = new ga({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new vi() },
        radius: { value: 4 }
      },
      vertexShader: 'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}',
      fragmentShader:
        'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}'
    }),
    m = p.clone()
  m.defines.HORIZONTAL_PASS = 1
  const f = new Zr()
  f.setAttribute(
    'position',
    new Lr(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  )
  const g = new oa(f, p),
    v = this
  ;(this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = 1)
  let y = this.type
  function _(e, i) {
    const s = n.update(g)
    p.defines.VSM_SAMPLES !== e.blurSamples &&
      ((p.defines.VSM_SAMPLES = e.blurSamples),
      (m.defines.VSM_SAMPLES = e.blurSamples),
      (p.needsUpdate = !0),
      (m.needsUpdate = !0)),
      null === e.mapPass && (e.mapPass = new qi(r.x, r.y)),
      (p.uniforms.shadow_pass.value = e.map.texture),
      (p.uniforms.resolution.value = e.mapSize),
      (p.uniforms.radius.value = e.radius),
      t.setRenderTarget(e.mapPass),
      t.clear(),
      t.renderBufferDirect(i, null, s, p, g, null),
      (m.uniforms.shadow_pass.value = e.mapPass.texture),
      (m.uniforms.resolution.value = e.mapSize),
      (m.uniforms.radius.value = e.radius),
      t.setRenderTarget(e.map),
      t.clear(),
      t.renderBufferDirect(i, null, s, m, g, null)
  }
  function x(e, n, i, s) {
    let r = null
    const a =
      !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial
    if (void 0 !== a) r = a
    else if (
      ((r = !0 === i.isPointLight ? c : l),
      (t.localClippingEnabled &&
        !0 === n.clipShadows &&
        Array.isArray(n.clippingPlanes) &&
        0 !== n.clippingPlanes.length) ||
        (n.displacementMap && 0 !== n.displacementScale) ||
        (n.alphaMap && n.alphaTest > 0) ||
        (n.map && n.alphaTest > 0))
    ) {
      const t = r.uuid,
        e = n.uuid
      let i = h[t]
      void 0 === i && ((i = {}), (h[t] = i))
      let s = i[e]
      void 0 === s &&
        ((s = r.clone()), (i[e] = s), n.addEventListener('dispose', w)),
        (r = s)
    }
    if (
      ((r.visible = n.visible),
      (r.wireframe = n.wireframe),
      (r.side =
        3 === s
          ? null !== n.shadowSide
            ? n.shadowSide
            : n.side
          : null !== n.shadowSide
            ? n.shadowSide
            : d[n.side]),
      (r.alphaMap = n.alphaMap),
      (r.alphaTest = n.alphaTest),
      (r.map = n.map),
      (r.clipShadows = n.clipShadows),
      (r.clippingPlanes = n.clippingPlanes),
      (r.clipIntersection = n.clipIntersection),
      (r.displacementMap = n.displacementMap),
      (r.displacementScale = n.displacementScale),
      (r.displacementBias = n.displacementBias),
      (r.wireframeLinewidth = n.wireframeLinewidth),
      (r.linewidth = n.linewidth),
      !0 === i.isPointLight && !0 === r.isMeshDistanceMaterial)
    ) {
      t.properties.get(r).light = i
    }
    return r
  }
  function b(e, i, r, a, o) {
    if (!1 === e.visible) return
    if (
      e.layers.test(i.layers) &&
      (e.isMesh || e.isLine || e.isPoints) &&
      (e.castShadow || (e.receiveShadow && 3 === o)) &&
      (!e.frustumCulled || s.intersectsObject(e))
    ) {
      e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, e.matrixWorld)
      const s = n.update(e),
        l = e.material
      if (Array.isArray(l)) {
        const n = s.groups
        for (let c = 0, h = n.length; c < h; c++) {
          const h = n[c],
            u = l[h.materialIndex]
          if (u && u.visible) {
            const n = x(e, u, a, o)
            e.onBeforeShadow(t, e, i, r, s, n, h),
              t.renderBufferDirect(r, null, s, n, e, h),
              e.onAfterShadow(t, e, i, r, s, n, h)
          }
        }
      } else if (l.visible) {
        const n = x(e, l, a, o)
        e.onBeforeShadow(t, e, i, r, s, n, null),
          t.renderBufferDirect(r, null, s, n, e, null),
          e.onAfterShadow(t, e, i, r, s, n, null)
      }
    }
    const l = e.children
    for (let t = 0, n = l.length; t < n; t++) b(l[t], i, r, a, o)
  }
  function w(t) {
    t.target.removeEventListener('dispose', w)
    for (const e in h) {
      const n = h[e],
        i = t.target.uuid
      if (i in n) {
        n[i].dispose(), delete n[i]
      }
    }
  }
  ;(this.render = function (e, n, i) {
    if (!1 === v.enabled) return
    if (!1 === v.autoUpdate && !1 === v.needsUpdate) return
    if (0 === e.length) return
    const l = t.getRenderTarget(),
      c = t.getActiveCubeFace(),
      h = t.getActiveMipmapLevel(),
      d = t.state
    d.setBlending(0),
      d.buffers.color.setClear(1, 1, 1, 1),
      d.buffers.depth.setTest(!0),
      d.setScissorTest(!1)
    const p = 3 !== y && 3 === this.type,
      m = 3 === y && 3 !== this.type
    for (let f = 0, g = e.length; f < g; f++) {
      const l = e[f],
        c = l.shadow
      if (void 0 === c) {
        console.warn('THREE.WebGLShadowMap:', l, 'has no shadow.')
        continue
      }
      if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue
      r.copy(c.mapSize)
      const h = c.getFrameExtents()
      if (
        (r.multiply(h),
        a.copy(c.mapSize),
        (r.x > u || r.y > u) &&
          (r.x > u &&
            ((a.x = Math.floor(u / h.x)),
            (r.x = a.x * h.x),
            (c.mapSize.x = a.x)),
          r.y > u &&
            ((a.y = Math.floor(u / h.y)),
            (r.y = a.y * h.y),
            (c.mapSize.y = a.y))),
        null === c.map || !0 === p || !0 === m)
      ) {
        const t = 3 !== this.type ? { minFilter: ve, magFilter: ve } : {}
        null !== c.map && c.map.dispose(),
          (c.map = new qi(r.x, r.y, t)),
          (c.map.texture.name = l.name + '.shadowMap'),
          c.camera.updateProjectionMatrix()
      }
      t.setRenderTarget(c.map), t.clear()
      const g = c.getViewportCount()
      for (let t = 0; t < g; t++) {
        const e = c.getViewport(t)
        o.set(a.x * e.x, a.y * e.y, a.x * e.z, a.y * e.w),
          d.viewport(o),
          c.updateMatrices(l, t),
          (s = c.getFrustum()),
          b(n, i, c.camera, l, this.type)
      }
      !0 !== c.isPointLightShadow && 3 === this.type && _(c, i),
        (c.needsUpdate = !1)
    }
    ;(y = this.type), (v.needsUpdate = !1), t.setRenderTarget(l, c, h)
  }),
    e(_, 'VSMPass'),
    e(x, 'getDepthMaterial'),
    e(b, 'renderObject'),
    e(w, 'onMaterialDispose')
}
e(Sc, 'WebGLShadowMap')
const Tc = {
  [te]: 1,
  [ne]: 6,
  [se]: 7,
  [ie]: 5,
  [ee]: 0,
  [ae]: 2,
  [oe]: 4,
  [re]: 3
}
function Ec(t, n) {
  function i() {
    let n = !1
    const i = new ji()
    let s = null
    const r = new ji(0, 0, 0, 0)
    return {
      setMask: e(function (e) {
        s === e || n || (t.colorMask(e, e, e, e), (s = e))
      }, 'setMask'),
      setLocked: e(function (t) {
        n = t
      }, 'setLocked'),
      setClear: e(function (e, n, s, a, o) {
        !0 === o && ((e *= a), (n *= a), (s *= a)),
          i.set(e, n, s, a),
          !1 === r.equals(i) && (t.clearColor(e, n, s, a), r.copy(i))
      }, 'setClear'),
      reset: e(function () {
        ;(n = !1), (s = null), r.set(-1, 0, 0, 0)
      }, 'reset')
    }
  }
  function s() {
    let i = !1,
      s = !1,
      r = null,
      a = null,
      o = null
    return {
      setReversed: e(function (t) {
        if (s !== t) {
          const t = n.get('EXT_clip_control')
          s
            ? t.clipControlEXT(t.LOWER_LEFT_EXT, t.ZERO_TO_ONE_EXT)
            : t.clipControlEXT(t.LOWER_LEFT_EXT, t.NEGATIVE_ONE_TO_ONE_EXT)
          const e = o
          ;(o = null), this.setClear(e)
        }
        s = t
      }, 'setReversed'),
      getReversed: e(function () {
        return s
      }, 'getReversed'),
      setTest: e(function (e) {
        e ? W(t.DEPTH_TEST) : j(t.DEPTH_TEST)
      }, 'setTest'),
      setMask: e(function (e) {
        r === e || i || (t.depthMask(e), (r = e))
      }, 'setMask'),
      setFunc: e(function (e) {
        if ((s && (e = Tc[e]), a !== e)) {
          switch (e) {
            case 0:
              t.depthFunc(t.NEVER)
              break
            case 1:
              t.depthFunc(t.ALWAYS)
              break
            case 2:
              t.depthFunc(t.LESS)
              break
            case 3:
            default:
              t.depthFunc(t.LEQUAL)
              break
            case 4:
              t.depthFunc(t.EQUAL)
              break
            case 5:
              t.depthFunc(t.GEQUAL)
              break
            case 6:
              t.depthFunc(t.GREATER)
              break
            case 7:
              t.depthFunc(t.NOTEQUAL)
          }
          a = e
        }
      }, 'setFunc'),
      setLocked: e(function (t) {
        i = t
      }, 'setLocked'),
      setClear: e(function (e) {
        o !== e && (s && (e = 1 - e), t.clearDepth(e), (o = e))
      }, 'setClear'),
      reset: e(function () {
        ;(i = !1), (r = null), (a = null), (o = null), (s = !1)
      }, 'reset')
    }
  }
  function r() {
    let n = !1,
      i = null,
      s = null,
      r = null,
      a = null,
      o = null,
      l = null,
      c = null,
      h = null
    return {
      setTest: e(function (e) {
        n || (e ? W(t.STENCIL_TEST) : j(t.STENCIL_TEST))
      }, 'setTest'),
      setMask: e(function (e) {
        i === e || n || (t.stencilMask(e), (i = e))
      }, 'setMask'),
      setFunc: e(function (e, n, i) {
        ;(s === e && r === n && a === i) ||
          (t.stencilFunc(e, n, i), (s = e), (r = n), (a = i))
      }, 'setFunc'),
      setOp: e(function (e, n, i) {
        ;(o === e && l === n && c === i) ||
          (t.stencilOp(e, n, i), (o = e), (l = n), (c = i))
      }, 'setOp'),
      setLocked: e(function (t) {
        n = t
      }, 'setLocked'),
      setClear: e(function (e) {
        h !== e && (t.clearStencil(e), (h = e))
      }, 'setClear'),
      reset: e(function () {
        ;(n = !1),
          (i = null),
          (s = null),
          (r = null),
          (a = null),
          (o = null),
          (l = null),
          (c = null),
          (h = null)
      }, 'reset')
    }
  }
  e(i, 'ColorBuffer'), e(s, 'DepthBuffer'), e(r, 'StencilBuffer')
  const a = new i(),
    o = new s(),
    l = new r(),
    c = new WeakMap(),
    h = new WeakMap()
  let u = {},
    d = {},
    p = new WeakMap(),
    m = [],
    f = null,
    g = !1,
    v = null,
    y = null,
    _ = null,
    x = null,
    b = null,
    w = null,
    M = null,
    S = new br(0, 0, 0),
    T = 0,
    E = !1,
    A = null,
    C = null,
    R = null,
    P = null,
    I = null
  const L = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
  let D = !1,
    k = 0
  const N = t.getParameter(t.VERSION)
  ;-1 !== N.indexOf('WebGL')
    ? ((k = parseFloat(/^WebGL (\d)/.exec(N)[1])), (D = k >= 1))
    : -1 !== N.indexOf('OpenGL ES') &&
      ((k = parseFloat(/^OpenGL ES (\d)/.exec(N)[1])), (D = k >= 2))
  let U = null,
    B = {}
  const O = t.getParameter(t.SCISSOR_BOX),
    F = t.getParameter(t.VIEWPORT),
    z = new ji().fromArray(O),
    V = new ji().fromArray(F)
  function H(e, n, i, s) {
    const r = new Uint8Array(4),
      a = t.createTexture()
    t.bindTexture(e, a),
      t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
      t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST)
    for (let o = 0; o < i; o++)
      e === t.TEXTURE_3D || e === t.TEXTURE_2D_ARRAY
        ? t.texImage3D(n, 0, t.RGBA, 1, 1, s, 0, t.RGBA, t.UNSIGNED_BYTE, r)
        : t.texImage2D(n + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r)
    return a
  }
  e(H, 'createTexture')
  const G = {}
  function W(e) {
    !0 !== u[e] && (t.enable(e), (u[e] = !0))
  }
  function j(e) {
    !1 !== u[e] && (t.disable(e), (u[e] = !1))
  }
  function X(e, n) {
    return (
      d[e] !== n &&
      (t.bindFramebuffer(e, n),
      (d[e] = n),
      e === t.DRAW_FRAMEBUFFER && (d[t.FRAMEBUFFER] = n),
      e === t.FRAMEBUFFER && (d[t.DRAW_FRAMEBUFFER] = n),
      !0)
    )
  }
  function q(e, n) {
    let i = m,
      s = !1
    if (e) {
      ;(i = p.get(n)), void 0 === i && ((i = []), p.set(n, i))
      const r = e.textures
      if (i.length !== r.length || i[0] !== t.COLOR_ATTACHMENT0) {
        for (let e = 0, n = r.length; e < n; e++) i[e] = t.COLOR_ATTACHMENT0 + e
        ;(i.length = r.length), (s = !0)
      }
    } else i[0] !== t.BACK && ((i[0] = t.BACK), (s = !0))
    s && t.drawBuffers(i)
  }
  function Y(e) {
    return f !== e && (t.useProgram(e), (f = e), !0)
  }
  ;(G[t.TEXTURE_2D] = H(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
    (G[t.TEXTURE_CUBE_MAP] = H(
      t.TEXTURE_CUBE_MAP,
      t.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (G[t.TEXTURE_2D_ARRAY] = H(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1)),
    (G[t.TEXTURE_3D] = H(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1)),
    a.setClear(0, 0, 0, 1),
    o.setClear(1),
    l.setClear(0),
    W(t.DEPTH_TEST),
    o.setFunc(3),
    Q(!1),
    tt(1),
    W(t.CULL_FACE),
    $(0),
    e(W, 'enable'),
    e(j, 'disable'),
    e(X, 'bindFramebuffer'),
    e(q, 'drawBuffers'),
    e(Y, 'useProgram')
  const Z = {
    [Ut]: t.FUNC_ADD,
    [Bt]: t.FUNC_SUBTRACT,
    [Ot]: t.FUNC_REVERSE_SUBTRACT
  }
  ;(Z[103] = t.MIN), (Z[104] = t.MAX)
  const K = {
    [Ft]: t.ZERO,
    [zt]: t.ONE,
    [Vt]: t.SRC_COLOR,
    [Gt]: t.SRC_ALPHA,
    [Zt]: t.SRC_ALPHA_SATURATE,
    [qt]: t.DST_COLOR,
    [jt]: t.DST_ALPHA,
    [Ht]: t.ONE_MINUS_SRC_COLOR,
    [Wt]: t.ONE_MINUS_SRC_ALPHA,
    [Yt]: t.ONE_MINUS_DST_COLOR,
    [Xt]: t.ONE_MINUS_DST_ALPHA,
    [Kt]: t.CONSTANT_COLOR,
    [$t]: t.ONE_MINUS_CONSTANT_COLOR,
    [Jt]: t.CONSTANT_ALPHA,
    [Qt]: t.ONE_MINUS_CONSTANT_ALPHA
  }
  function $(e, n, i, s, r, a, o, l, c, h) {
    if (0 !== e) {
      if ((!1 === g && (W(t.BLEND), (g = !0)), 5 === e))
        (r = r || n),
          (a = a || i),
          (o = o || s),
          (n === y && r === b) ||
            (t.blendEquationSeparate(Z[n], Z[r]), (y = n), (b = r)),
          (i === _ && s === x && a === w && o === M) ||
            (t.blendFuncSeparate(K[i], K[s], K[a], K[o]),
            (_ = i),
            (x = s),
            (w = a),
            (M = o)),
          (!1 !== l.equals(S) && c === T) ||
            (t.blendColor(l.r, l.g, l.b, c), S.copy(l), (T = c)),
          (v = e),
          (E = !1)
      else if (e !== v || h !== E) {
        if (
          ((y === Ut && b === Ut) ||
            (t.blendEquation(t.FUNC_ADD), (y = Ut), (b = Ut)),
          h)
        )
          switch (e) {
            case 1:
              t.blendFuncSeparate(
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              )
              break
            case 2:
              t.blendFunc(t.ONE, t.ONE)
              break
            case 3:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE)
              break
            case 4:
              t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)
              break
            default:
              console.error('THREE.WebGLState: Invalid blending: ', e)
          }
        else
          switch (e) {
            case 1:
              t.blendFuncSeparate(
                t.SRC_ALPHA,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              )
              break
            case 2:
              t.blendFunc(t.SRC_ALPHA, t.ONE)
              break
            case 3:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE)
              break
            case 4:
              t.blendFunc(t.ZERO, t.SRC_COLOR)
              break
            default:
              console.error('THREE.WebGLState: Invalid blending: ', e)
          }
        ;(_ = null),
          (x = null),
          (w = null),
          (M = null),
          S.set(0, 0, 0),
          (T = 0),
          (v = e),
          (E = h)
      }
    } else !0 === g && (j(t.BLEND), (g = !1))
  }
  function J(e, n) {
    2 === e.side ? j(t.CULL_FACE) : W(t.CULL_FACE)
    let i = 1 === e.side
    n && (i = !i),
      Q(i),
      1 === e.blending && !1 === e.transparent
        ? $(0)
        : $(
            e.blending,
            e.blendEquation,
            e.blendSrc,
            e.blendDst,
            e.blendEquationAlpha,
            e.blendSrcAlpha,
            e.blendDstAlpha,
            e.blendColor,
            e.blendAlpha,
            e.premultipliedAlpha
          ),
      o.setFunc(e.depthFunc),
      o.setTest(e.depthTest),
      o.setMask(e.depthWrite),
      a.setMask(e.colorWrite)
    const s = e.stencilWrite
    l.setTest(s),
      s &&
        (l.setMask(e.stencilWriteMask),
        l.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
        l.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
      nt(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
      !0 === e.alphaToCoverage
        ? W(t.SAMPLE_ALPHA_TO_COVERAGE)
        : j(t.SAMPLE_ALPHA_TO_COVERAGE)
  }
  function Q(e) {
    A !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (A = e))
  }
  function tt(e) {
    0 !== e
      ? (W(t.CULL_FACE),
        e !== C &&
          (1 === e
            ? t.cullFace(t.BACK)
            : 2 === e
              ? t.cullFace(t.FRONT)
              : t.cullFace(t.FRONT_AND_BACK)))
      : j(t.CULL_FACE),
      (C = e)
  }
  function et(e) {
    e !== R && (D && t.lineWidth(e), (R = e))
  }
  function nt(e, n, i) {
    e
      ? (W(t.POLYGON_OFFSET_FILL),
        (P === n && I === i) || (t.polygonOffset(n, i), (P = n), (I = i)))
      : j(t.POLYGON_OFFSET_FILL)
  }
  function it(e) {
    e ? W(t.SCISSOR_TEST) : j(t.SCISSOR_TEST)
  }
  function st(e) {
    void 0 === e && (e = t.TEXTURE0 + L - 1),
      U !== e && (t.activeTexture(e), (U = e))
  }
  function rt(e, n, i) {
    void 0 === i && (i = null === U ? t.TEXTURE0 + L - 1 : U)
    let s = B[i]
    void 0 === s && ((s = { type: void 0, texture: void 0 }), (B[i] = s)),
      (s.type === e && s.texture === n) ||
        (U !== i && (t.activeTexture(i), (U = i)),
        t.bindTexture(e, n || G[e]),
        (s.type = e),
        (s.texture = n))
  }
  function at() {
    const e = B[U]
    void 0 !== e &&
      void 0 !== e.type &&
      (t.bindTexture(e.type, null), (e.type = void 0), (e.texture = void 0))
  }
  function ot() {
    try {
      t.compressedTexImage2D.apply(t, arguments)
    } catch (e) {
      console.error('THREE.WebGLState:', e)
    }
  }
  function lt() {
    try {
      t.compressedTexImage3D.apply(t, arguments)
    } catch (e) {
      console.error('THREE.WebGLState:', e)
    }
  }
  function ct() {
    try {
      t.texSubImage2D.apply(t, arguments)
    } catch (e) {
      console.error('THREE.WebGLState:', e)
    }
  }
  function ht() {
    try {
      t.texSubImage3D.apply(t, arguments)
    } catch (e) {
      console.error('THREE.WebGLState:', e)
    }
  }
  function ut() {
    try {
      t.compressedTexSubImage2D.apply(t, arguments)
    } catch (e) {
      console.error('THREE.WebGLState:', e)
    }
  }
  function dt() {
    try {
      t.compressedTexSubImage3D.apply(t, arguments)
    } catch (e) {
      console.error('THREE.WebGLState:', e)
    }
  }
  function pt() {
    try {
      t.texStorage2D.apply(t, arguments)
    } catch (e) {
      console.error('THREE.WebGLState:', e)
    }
  }
  function mt() {
    try {
      t.texStorage3D.apply(t, arguments)
    } catch (e) {
      console.error('THREE.WebGLState:', e)
    }
  }
  function ft() {
    try {
      t.texImage2D.apply(t, arguments)
    } catch (e) {
      console.error('THREE.WebGLState:', e)
    }
  }
  function gt() {
    try {
      t.texImage3D.apply(t, arguments)
    } catch (e) {
      console.error('THREE.WebGLState:', e)
    }
  }
  function vt(e) {
    !1 === z.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), z.copy(e))
  }
  function yt(e) {
    !1 === V.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), V.copy(e))
  }
  function _t(e, n) {
    let i = h.get(n)
    void 0 === i && ((i = new WeakMap()), h.set(n, i))
    let s = i.get(e)
    void 0 === s && ((s = t.getUniformBlockIndex(n, e.name)), i.set(e, s))
  }
  function xt(e, n) {
    const i = h.get(n).get(e)
    c.get(n) !== i &&
      (t.uniformBlockBinding(n, i, e.__bindingPointIndex), c.set(n, i))
  }
  function bt() {
    t.disable(t.BLEND),
      t.disable(t.CULL_FACE),
      t.disable(t.DEPTH_TEST),
      t.disable(t.POLYGON_OFFSET_FILL),
      t.disable(t.SCISSOR_TEST),
      t.disable(t.STENCIL_TEST),
      t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
      t.blendEquation(t.FUNC_ADD),
      t.blendFunc(t.ONE, t.ZERO),
      t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
      t.blendColor(0, 0, 0, 0),
      t.colorMask(!0, !0, !0, !0),
      t.clearColor(0, 0, 0, 0),
      t.depthMask(!0),
      t.depthFunc(t.LESS),
      o.setReversed(!1),
      t.clearDepth(1),
      t.stencilMask(4294967295),
      t.stencilFunc(t.ALWAYS, 0, 4294967295),
      t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
      t.clearStencil(0),
      t.cullFace(t.BACK),
      t.frontFace(t.CCW),
      t.polygonOffset(0, 0),
      t.activeTexture(t.TEXTURE0),
      t.bindFramebuffer(t.FRAMEBUFFER, null),
      t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
      t.bindFramebuffer(t.READ_FRAMEBUFFER, null),
      t.useProgram(null),
      t.lineWidth(1),
      t.scissor(0, 0, t.canvas.width, t.canvas.height),
      t.viewport(0, 0, t.canvas.width, t.canvas.height),
      (u = {}),
      (U = null),
      (B = {}),
      (d = {}),
      (p = new WeakMap()),
      (m = []),
      (f = null),
      (g = !1),
      (v = null),
      (y = null),
      (_ = null),
      (x = null),
      (b = null),
      (w = null),
      (M = null),
      (S = new br(0, 0, 0)),
      (T = 0),
      (E = !1),
      (A = null),
      (C = null),
      (R = null),
      (P = null),
      (I = null),
      z.set(0, 0, t.canvas.width, t.canvas.height),
      V.set(0, 0, t.canvas.width, t.canvas.height),
      a.reset(),
      o.reset(),
      l.reset()
  }
  return (
    e($, 'setBlending'),
    e(J, 'setMaterial'),
    e(Q, 'setFlipSided'),
    e(tt, 'setCullFace'),
    e(et, 'setLineWidth'),
    e(nt, 'setPolygonOffset'),
    e(it, 'setScissorTest'),
    e(st, 'activeTexture'),
    e(rt, 'bindTexture'),
    e(at, 'unbindTexture'),
    e(ot, 'compressedTexImage2D'),
    e(lt, 'compressedTexImage3D'),
    e(ct, 'texSubImage2D'),
    e(ht, 'texSubImage3D'),
    e(ut, 'compressedTexSubImage2D'),
    e(dt, 'compressedTexSubImage3D'),
    e(pt, 'texStorage2D'),
    e(mt, 'texStorage3D'),
    e(ft, 'texImage2D'),
    e(gt, 'texImage3D'),
    e(vt, 'scissor'),
    e(yt, 'viewport'),
    e(_t, 'updateUBOMapping'),
    e(xt, 'uniformBlockBinding'),
    e(bt, 'reset'),
    {
      buffers: { color: a, depth: o, stencil: l },
      enable: W,
      disable: j,
      bindFramebuffer: X,
      drawBuffers: q,
      useProgram: Y,
      setBlending: $,
      setMaterial: J,
      setFlipSided: Q,
      setCullFace: tt,
      setLineWidth: et,
      setPolygonOffset: nt,
      setScissorTest: it,
      activeTexture: st,
      bindTexture: rt,
      unbindTexture: at,
      compressedTexImage2D: ot,
      compressedTexImage3D: lt,
      texImage2D: ft,
      texImage3D: gt,
      updateUBOMapping: _t,
      uniformBlockBinding: xt,
      texStorage2D: pt,
      texStorage3D: mt,
      texSubImage2D: ct,
      texSubImage3D: ht,
      compressedTexSubImage2D: ut,
      compressedTexSubImage3D: dt,
      scissor: vt,
      viewport: yt,
      reset: bt
    }
  )
}
function Ac(t, e) {
  const n = t.image && t.image.width ? t.image.width / t.image.height : 1
  return (
    n > e
      ? ((t.repeat.x = 1),
        (t.repeat.y = n / e),
        (t.offset.x = 0),
        (t.offset.y = (1 - t.repeat.y) / 2))
      : ((t.repeat.x = e / n),
        (t.repeat.y = 1),
        (t.offset.x = (1 - t.repeat.x) / 2),
        (t.offset.y = 0)),
    t
  )
}
function Cc(t, e) {
  const n = t.image && t.image.width ? t.image.width / t.image.height : 1
  return (
    n > e
      ? ((t.repeat.x = e / n),
        (t.repeat.y = 1),
        (t.offset.x = (1 - t.repeat.x) / 2),
        (t.offset.y = 0))
      : ((t.repeat.x = 1),
        (t.repeat.y = n / e),
        (t.offset.x = 0),
        (t.offset.y = (1 - t.repeat.y) / 2)),
    t
  )
}
function Rc(t) {
  return (
    (t.repeat.x = 1), (t.repeat.y = 1), (t.offset.x = 0), (t.offset.y = 0), t
  )
}
function Pc(t, e, n, i) {
  const s = Ic(i)
  switch (n) {
    case 1021:
    case 1024:
      return t * e
    case 1025:
      return t * e * 2
    case Ne:
    case Ue:
      return ((t * e) / s.components) * s.byteLength
    case 1030:
    case Be:
      return ((t * e * 2) / s.components) * s.byteLength
    case 1022:
      return ((t * e * 3) / s.components) * s.byteLength
    case Le:
    case Oe:
      return ((t * e * 4) / s.components) * s.byteLength
    case Fe:
    case ze:
      return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8
    case Ve:
    case He:
      return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16
    case We:
    case Xe:
      return (Math.max(t, 16) * Math.max(e, 8)) / 4
    case Ge:
    case je:
      return (Math.max(t, 8) * Math.max(e, 8)) / 2
    case qe:
    case Ye:
      return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8
    case Ze:
    case Ke:
      return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16
    case $e:
      return Math.floor((t + 4) / 5) * Math.floor((e + 3) / 4) * 16
    case Je:
      return Math.floor((t + 4) / 5) * Math.floor((e + 4) / 5) * 16
    case Qe:
      return Math.floor((t + 5) / 6) * Math.floor((e + 4) / 5) * 16
    case tn:
      return Math.floor((t + 5) / 6) * Math.floor((e + 5) / 6) * 16
    case en:
      return Math.floor((t + 7) / 8) * Math.floor((e + 4) / 5) * 16
    case nn:
      return Math.floor((t + 7) / 8) * Math.floor((e + 5) / 6) * 16
    case sn:
      return Math.floor((t + 7) / 8) * Math.floor((e + 7) / 8) * 16
    case rn:
      return Math.floor((t + 9) / 10) * Math.floor((e + 4) / 5) * 16
    case an:
      return Math.floor((t + 9) / 10) * Math.floor((e + 5) / 6) * 16
    case on:
      return Math.floor((t + 9) / 10) * Math.floor((e + 7) / 8) * 16
    case ln:
      return Math.floor((t + 9) / 10) * Math.floor((e + 9) / 10) * 16
    case cn:
      return Math.floor((t + 11) / 12) * Math.floor((e + 9) / 10) * 16
    case hn:
      return Math.floor((t + 11) / 12) * Math.floor((e + 11) / 12) * 16
    case un:
    case dn:
    case pn:
      return Math.ceil(t / 4) * Math.ceil(e / 4) * 16
    case 36283:
    case mn:
      return Math.ceil(t / 4) * Math.ceil(e / 4) * 8
    case fn:
    case gn:
      return Math.ceil(t / 4) * Math.ceil(e / 4) * 16
  }
  throw new Error(`Unable to determine texture byte length for ${n} format.`)
}
function Ic(t) {
  switch (t) {
    case Me:
    case 1010:
      return { byteLength: 1, components: 1 }
    case Se:
    case 1011:
    case Ce:
      return { byteLength: 2, components: 1 }
    case Re:
    case Pe:
      return { byteLength: 2, components: 4 }
    case Ee:
    case Te:
    case Ae:
      return { byteLength: 4, components: 1 }
    case 35902:
      return { byteLength: 4, components: 3 }
  }
  throw new Error(`Unknown texture type ${t}.`)
}
e(Ec, 'WebGLState'),
  e(Ac, 'contain'),
  e(Cc, 'cover'),
  e(Rc, 'fill'),
  e(Pc, 'getByteLength'),
  e(Ic, 'getTextureTypeByteLength')
function Lc(t, n, i, s, r, a, o) {
  const l = n.has('WEBGL_multisampled_render_to_texture')
      ? n.get('WEBGL_multisampled_render_to_texture')
      : null,
    c =
      'undefined' != typeof navigator &&
      /OculusBrowser/g.test(navigator.userAgent),
    h = new vi(),
    u = new WeakMap()
  let d
  const p = new WeakMap()
  let m = !1
  try {
    m =
      'undefined' != typeof OffscreenCanvas &&
      null !== new OffscreenCanvas(1, 1).getContext('2d')
  } catch (st) {}
  function f(t, e) {
    return m ? new OffscreenCanvas(t, e) : Mi('canvas')
  }
  function g(t, e, n) {
    let i = 1
    const s = it(t)
    if (
      ((s.width > n || s.height > n) && (i = n / Math.max(s.width, s.height)),
      i < 1)
    ) {
      if (
        ('undefined' != typeof HTMLImageElement &&
          t instanceof HTMLImageElement) ||
        ('undefined' != typeof HTMLCanvasElement &&
          t instanceof HTMLCanvasElement) ||
        ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap) ||
        ('undefined' != typeof VideoFrame && t instanceof VideoFrame)
      ) {
        const n = Math.floor(i * s.width),
          r = Math.floor(i * s.height)
        void 0 === d && (d = f(n, r))
        const a = e ? f(n, r) : d
        ;(a.width = n), (a.height = r)
        return (
          a.getContext('2d').drawImage(t, 0, 0, n, r),
          console.warn(
            'THREE.WebGLRenderer: Texture has been resized from (' +
              s.width +
              'x' +
              s.height +
              ') to (' +
              n +
              'x' +
              r +
              ').'
          ),
          a
        )
      }
      return (
        'data' in t &&
          console.warn(
            'THREE.WebGLRenderer: Image in DataTexture is too big (' +
              s.width +
              'x' +
              s.height +
              ').'
          ),
        t
      )
    }
    return t
  }
  function v(t) {
    return t.generateMipmaps
  }
  function y(e) {
    t.generateMipmap(e)
  }
  function _(e) {
    return e.isWebGLCubeRenderTarget
      ? t.TEXTURE_CUBE_MAP
      : e.isWebGL3DRenderTarget
        ? t.TEXTURE_3D
        : e.isWebGLArrayRenderTarget || e.isCompressedArrayTexture
          ? t.TEXTURE_2D_ARRAY
          : t.TEXTURE_2D
  }
  function x(e, i, s, r, a = !1) {
    if (null !== e) {
      if (void 0 !== t[e]) return t[e]
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          e +
          "'"
      )
    }
    let o = i
    if (
      (i === t.RED &&
        (s === t.FLOAT && (o = t.R32F),
        s === t.HALF_FLOAT && (o = t.R16F),
        s === t.UNSIGNED_BYTE && (o = t.R8)),
      i === t.RED_INTEGER &&
        (s === t.UNSIGNED_BYTE && (o = t.R8UI),
        s === t.UNSIGNED_SHORT && (o = t.R16UI),
        s === t.UNSIGNED_INT && (o = t.R32UI),
        s === t.BYTE && (o = t.R8I),
        s === t.SHORT && (o = t.R16I),
        s === t.INT && (o = t.R32I)),
      i === t.RG &&
        (s === t.FLOAT && (o = t.RG32F),
        s === t.HALF_FLOAT && (o = t.RG16F),
        s === t.UNSIGNED_BYTE && (o = t.RG8)),
      i === t.RG_INTEGER &&
        (s === t.UNSIGNED_BYTE && (o = t.RG8UI),
        s === t.UNSIGNED_SHORT && (o = t.RG16UI),
        s === t.UNSIGNED_INT && (o = t.RG32UI),
        s === t.BYTE && (o = t.RG8I),
        s === t.SHORT && (o = t.RG16I),
        s === t.INT && (o = t.RG32I)),
      i === t.RGB_INTEGER &&
        (s === t.UNSIGNED_BYTE && (o = t.RGB8UI),
        s === t.UNSIGNED_SHORT && (o = t.RGB16UI),
        s === t.UNSIGNED_INT && (o = t.RGB32UI),
        s === t.BYTE && (o = t.RGB8I),
        s === t.SHORT && (o = t.RGB16I),
        s === t.INT && (o = t.RGB32I)),
      i === t.RGBA_INTEGER &&
        (s === t.UNSIGNED_BYTE && (o = t.RGBA8UI),
        s === t.UNSIGNED_SHORT && (o = t.RGBA16UI),
        s === t.UNSIGNED_INT && (o = t.RGBA32UI),
        s === t.BYTE && (o = t.RGBA8I),
        s === t.SHORT && (o = t.RGBA16I),
        s === t.INT && (o = t.RGBA32I)),
      i === t.RGB && s === t.UNSIGNED_INT_5_9_9_9_REV && (o = t.RGB9_E5),
      i === t.RGBA)
    ) {
      const e = a ? Cn : Pi.getTransfer(r)
      s === t.FLOAT && (o = t.RGBA32F),
        s === t.HALF_FLOAT && (o = t.RGBA16F),
        s === t.UNSIGNED_BYTE && (o = e === Rn ? t.SRGB8_ALPHA8 : t.RGBA8),
        s === t.UNSIGNED_SHORT_4_4_4_4 && (o = t.RGBA4),
        s === t.UNSIGNED_SHORT_5_5_5_1 && (o = t.RGB5_A1)
    }
    return (
      (o !== t.R16F &&
        o !== t.R32F &&
        o !== t.RG16F &&
        o !== t.RG32F &&
        o !== t.RGBA16F &&
        o !== t.RGBA32F) ||
        n.get('EXT_color_buffer_float'),
      o
    )
  }
  function b(e, n) {
    let i
    return (
      e
        ? null === n || n === Ee || n === Ie
          ? (i = t.DEPTH24_STENCIL8)
          : n === Ae
            ? (i = t.DEPTH32F_STENCIL8)
            : n === Se &&
              ((i = t.DEPTH24_STENCIL8),
              console.warn(
                'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.'
              ))
        : null === n || n === Ee || n === Ie
          ? (i = t.DEPTH_COMPONENT24)
          : n === Ae
            ? (i = t.DEPTH_COMPONENT32F)
            : n === Se && (i = t.DEPTH_COMPONENT16),
      i
    )
  }
  function w(t, e) {
    return !0 === v(t) ||
      (t.isFramebufferTexture && t.minFilter !== ve && t.minFilter !== xe)
      ? Math.log2(Math.max(e.width, e.height)) + 1
      : void 0 !== t.mipmaps && t.mipmaps.length > 0
        ? t.mipmaps.length
        : t.isCompressedTexture && Array.isArray(t.image)
          ? e.mipmaps.length
          : 1
  }
  function M(t) {
    const e = t.target
    e.removeEventListener('dispose', M), T(e), e.isVideoTexture && u.delete(e)
  }
  function S(t) {
    const e = t.target
    e.removeEventListener('dispose', S), A(e)
  }
  function T(t) {
    const e = s.get(t)
    if (void 0 === e.__webglInit) return
    const n = t.source,
      i = p.get(n)
    if (i) {
      const s = i[e.__cacheKey]
      s.usedTimes--,
        0 === s.usedTimes && E(t),
        0 === Object.keys(i).length && p.delete(n)
    }
    s.remove(t)
  }
  function E(e) {
    const n = s.get(e)
    t.deleteTexture(n.__webglTexture)
    const i = e.source
    delete p.get(i)[n.__cacheKey], o.memory.textures--
  }
  function A(e) {
    const n = s.get(e)
    if (
      (e.depthTexture && (e.depthTexture.dispose(), s.remove(e.depthTexture)),
      e.isWebGLCubeRenderTarget)
    )
      for (let s = 0; s < 6; s++) {
        if (Array.isArray(n.__webglFramebuffer[s]))
          for (let e = 0; e < n.__webglFramebuffer[s].length; e++)
            t.deleteFramebuffer(n.__webglFramebuffer[s][e])
        else t.deleteFramebuffer(n.__webglFramebuffer[s])
        n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[s])
      }
    else {
      if (Array.isArray(n.__webglFramebuffer))
        for (let e = 0; e < n.__webglFramebuffer.length; e++)
          t.deleteFramebuffer(n.__webglFramebuffer[e])
      else t.deleteFramebuffer(n.__webglFramebuffer)
      if (
        (n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer),
        n.__webglMultisampledFramebuffer &&
          t.deleteFramebuffer(n.__webglMultisampledFramebuffer),
        n.__webglColorRenderbuffer)
      )
        for (let e = 0; e < n.__webglColorRenderbuffer.length; e++)
          n.__webglColorRenderbuffer[e] &&
            t.deleteRenderbuffer(n.__webglColorRenderbuffer[e])
      n.__webglDepthRenderbuffer &&
        t.deleteRenderbuffer(n.__webglDepthRenderbuffer)
    }
    const i = e.textures
    for (let r = 0, a = i.length; r < a; r++) {
      const e = s.get(i[r])
      e.__webglTexture &&
        (t.deleteTexture(e.__webglTexture), o.memory.textures--),
        s.remove(i[r])
    }
    s.remove(e)
  }
  e(f, 'createCanvas'),
    e(g, 'resizeImage'),
    e(v, 'textureNeedsGenerateMipmaps'),
    e(y, 'generateMipmap'),
    e(_, 'getTargetType'),
    e(x, 'getInternalFormat'),
    e(b, 'getInternalDepthFormat'),
    e(w, 'getMipLevels'),
    e(M, 'onTextureDispose'),
    e(S, 'onRenderTargetDispose'),
    e(T, 'deallocateTexture'),
    e(E, 'deleteTexture'),
    e(A, 'deallocateRenderTarget')
  let C = 0
  function R() {
    C = 0
  }
  function P() {
    const t = C
    return (
      t >= r.maxTextures &&
        console.warn(
          'THREE.WebGLTextures: Trying to use ' +
            t +
            ' texture units while this GPU supports only ' +
            r.maxTextures
        ),
      (C += 1),
      t
    )
  }
  function I(t) {
    const e = []
    return (
      e.push(t.wrapS),
      e.push(t.wrapT),
      e.push(t.wrapR || 0),
      e.push(t.magFilter),
      e.push(t.minFilter),
      e.push(t.anisotropy),
      e.push(t.internalFormat),
      e.push(t.format),
      e.push(t.type),
      e.push(t.generateMipmaps),
      e.push(t.premultiplyAlpha),
      e.push(t.flipY),
      e.push(t.unpackAlignment),
      e.push(t.colorSpace),
      e.join()
    )
  }
  function L(e, n) {
    const r = s.get(e)
    if (
      (e.isVideoTexture && et(e),
      !1 === e.isRenderTargetTexture &&
        e.version > 0 &&
        r.__version !== e.version)
    ) {
      const t = e.image
      if (null === t)
        console.warn(
          'THREE.WebGLRenderer: Texture marked for update but no image data found.'
        )
      else {
        if (!1 !== t.complete) return void V(r, e, n)
        console.warn(
          'THREE.WebGLRenderer: Texture marked for update but image is incomplete'
        )
      }
    }
    i.bindTexture(t.TEXTURE_2D, r.__webglTexture, t.TEXTURE0 + n)
  }
  function D(e, n) {
    const r = s.get(e)
    e.version > 0 && r.__version !== e.version
      ? V(r, e, n)
      : i.bindTexture(t.TEXTURE_2D_ARRAY, r.__webglTexture, t.TEXTURE0 + n)
  }
  function k(e, n) {
    const r = s.get(e)
    e.version > 0 && r.__version !== e.version
      ? V(r, e, n)
      : i.bindTexture(t.TEXTURE_3D, r.__webglTexture, t.TEXTURE0 + n)
  }
  function N(e, n) {
    const r = s.get(e)
    e.version > 0 && r.__version !== e.version
      ? H(r, e, n)
      : i.bindTexture(t.TEXTURE_CUBE_MAP, r.__webglTexture, t.TEXTURE0 + n)
  }
  e(R, 'resetTextureUnits'),
    e(P, 'allocateTextureUnit'),
    e(I, 'getTextureCacheKey'),
    e(L, 'setTexture2D'),
    e(D, 'setTexture2DArray'),
    e(k, 'setTexture3D'),
    e(N, 'setTextureCube')
  const U = { [me]: t.REPEAT, [fe]: t.CLAMP_TO_EDGE, [ge]: t.MIRRORED_REPEAT },
    B = {
      [ve]: t.NEAREST,
      [ye]: t.NEAREST_MIPMAP_NEAREST,
      [_e]: t.NEAREST_MIPMAP_LINEAR,
      [xe]: t.LINEAR,
      [be]: t.LINEAR_MIPMAP_NEAREST,
      [we]: t.LINEAR_MIPMAP_LINEAR
    },
    O = {
      [In]: t.NEVER,
      [On]: t.ALWAYS,
      [Ln]: t.LESS,
      [kn]: t.LEQUAL,
      [Dn]: t.EQUAL,
      [Bn]: t.GEQUAL,
      [Nn]: t.GREATER,
      [Un]: t.NOTEQUAL
    }
  function F(e, i) {
    if (
      (i.type !== Ae ||
        !1 !== n.has('OES_texture_float_linear') ||
        (i.magFilter !== xe &&
          i.magFilter !== be &&
          i.magFilter !== _e &&
          i.magFilter !== we &&
          i.minFilter !== xe &&
          i.minFilter !== be &&
          i.minFilter !== _e &&
          i.minFilter !== we) ||
        console.warn(
          'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.'
        ),
      t.texParameteri(e, t.TEXTURE_WRAP_S, U[i.wrapS]),
      t.texParameteri(e, t.TEXTURE_WRAP_T, U[i.wrapT]),
      (e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY) ||
        t.texParameteri(e, t.TEXTURE_WRAP_R, U[i.wrapR]),
      t.texParameteri(e, t.TEXTURE_MAG_FILTER, B[i.magFilter]),
      t.texParameteri(e, t.TEXTURE_MIN_FILTER, B[i.minFilter]),
      i.compareFunction &&
        (t.texParameteri(e, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
        t.texParameteri(e, t.TEXTURE_COMPARE_FUNC, O[i.compareFunction])),
      !0 === n.has('EXT_texture_filter_anisotropic'))
    ) {
      if (i.magFilter === ve) return
      if (i.minFilter !== _e && i.minFilter !== we) return
      if (i.type === Ae && !1 === n.has('OES_texture_float_linear')) return
      if (i.anisotropy > 1 || s.get(i).__currentAnisotropy) {
        const a = n.get('EXT_texture_filter_anisotropic')
        t.texParameterf(
          e,
          a.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(i.anisotropy, r.getMaxAnisotropy())
        ),
          (s.get(i).__currentAnisotropy = i.anisotropy)
      }
    }
  }
  function z(e, n) {
    let i = !1
    void 0 === e.__webglInit &&
      ((e.__webglInit = !0), n.addEventListener('dispose', M))
    const s = n.source
    let r = p.get(s)
    void 0 === r && ((r = {}), p.set(s, r))
    const a = I(n)
    if (a !== e.__cacheKey) {
      void 0 === r[a] &&
        ((r[a] = { texture: t.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (i = !0)),
        r[a].usedTimes++
      const s = r[e.__cacheKey]
      void 0 !== s && (r[e.__cacheKey].usedTimes--, 0 === s.usedTimes && E(n)),
        (e.__cacheKey = a),
        (e.__webglTexture = r[a].texture)
    }
    return i
  }
  function V(e, n, o) {
    let l = t.TEXTURE_2D
    ;(n.isDataArrayTexture || n.isCompressedArrayTexture) &&
      (l = t.TEXTURE_2D_ARRAY),
      n.isData3DTexture && (l = t.TEXTURE_3D)
    const c = z(e, n),
      h = n.source
    i.bindTexture(l, e.__webglTexture, t.TEXTURE0 + o)
    const u = s.get(h)
    if (h.version !== u.__version || !0 === c) {
      i.activeTexture(t.TEXTURE0 + o)
      const e = Pi.getPrimaries(Pi.workingColorSpace),
        s = n.colorSpace === Tn ? null : Pi.getPrimaries(n.colorSpace),
        d = n.colorSpace === Tn || e === s ? t.NONE : t.BROWSER_DEFAULT_WEBGL
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, n.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, n.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, d)
      let p = g(n.image, !1, r.maxTextureSize)
      p = nt(n, p)
      const m = a.convert(n.format, n.colorSpace),
        f = a.convert(n.type)
      let _,
        M = x(n.internalFormat, m, f, n.colorSpace, n.isVideoTexture)
      F(l, n)
      const S = n.mipmaps,
        T = !0 !== n.isVideoTexture,
        E = void 0 === u.__version || !0 === c,
        A = h.dataReady,
        C = w(n, p)
      if (n.isDepthTexture)
        (M = b(n.format === ke, n.type)),
          E &&
            (T
              ? i.texStorage2D(t.TEXTURE_2D, 1, M, p.width, p.height)
              : i.texImage2D(
                  t.TEXTURE_2D,
                  0,
                  M,
                  p.width,
                  p.height,
                  0,
                  m,
                  f,
                  null
                ))
      else if (n.isDataTexture)
        if (S.length > 0) {
          T && E && i.texStorage2D(t.TEXTURE_2D, C, M, S[0].width, S[0].height)
          for (let e = 0, n = S.length; e < n; e++)
            (_ = S[e]),
              T
                ? A &&
                  i.texSubImage2D(
                    t.TEXTURE_2D,
                    e,
                    0,
                    0,
                    _.width,
                    _.height,
                    m,
                    f,
                    _.data
                  )
                : i.texImage2D(
                    t.TEXTURE_2D,
                    e,
                    M,
                    _.width,
                    _.height,
                    0,
                    m,
                    f,
                    _.data
                  )
          n.generateMipmaps = !1
        } else
          T
            ? (E && i.texStorage2D(t.TEXTURE_2D, C, M, p.width, p.height),
              A &&
                i.texSubImage2D(
                  t.TEXTURE_2D,
                  0,
                  0,
                  0,
                  p.width,
                  p.height,
                  m,
                  f,
                  p.data
                ))
            : i.texImage2D(
                t.TEXTURE_2D,
                0,
                M,
                p.width,
                p.height,
                0,
                m,
                f,
                p.data
              )
      else if (n.isCompressedTexture)
        if (n.isCompressedArrayTexture) {
          T &&
            E &&
            i.texStorage3D(
              t.TEXTURE_2D_ARRAY,
              C,
              M,
              S[0].width,
              S[0].height,
              p.depth
            )
          for (let e = 0, s = S.length; e < s; e++)
            if (((_ = S[e]), n.format !== Le))
              if (null !== m)
                if (T) {
                  if (A)
                    if (n.layerUpdates.size > 0) {
                      const s = Pc(_.width, _.height, n.format, n.type)
                      for (const r of n.layerUpdates) {
                        const n = _.data.subarray(
                          (r * s) / _.data.BYTES_PER_ELEMENT,
                          ((r + 1) * s) / _.data.BYTES_PER_ELEMENT
                        )
                        i.compressedTexSubImage3D(
                          t.TEXTURE_2D_ARRAY,
                          e,
                          0,
                          0,
                          r,
                          _.width,
                          _.height,
                          1,
                          m,
                          n
                        )
                      }
                      n.clearLayerUpdates()
                    } else
                      i.compressedTexSubImage3D(
                        t.TEXTURE_2D_ARRAY,
                        e,
                        0,
                        0,
                        0,
                        _.width,
                        _.height,
                        p.depth,
                        m,
                        _.data
                      )
                } else
                  i.compressedTexImage3D(
                    t.TEXTURE_2D_ARRAY,
                    e,
                    M,
                    _.width,
                    _.height,
                    p.depth,
                    0,
                    _.data,
                    0,
                    0
                  )
              else
                console.warn(
                  'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                )
            else
              T
                ? A &&
                  i.texSubImage3D(
                    t.TEXTURE_2D_ARRAY,
                    e,
                    0,
                    0,
                    0,
                    _.width,
                    _.height,
                    p.depth,
                    m,
                    f,
                    _.data
                  )
                : i.texImage3D(
                    t.TEXTURE_2D_ARRAY,
                    e,
                    M,
                    _.width,
                    _.height,
                    p.depth,
                    0,
                    m,
                    f,
                    _.data
                  )
        } else {
          T && E && i.texStorage2D(t.TEXTURE_2D, C, M, S[0].width, S[0].height)
          for (let e = 0, s = S.length; e < s; e++)
            (_ = S[e]),
              n.format !== Le
                ? null !== m
                  ? T
                    ? A &&
                      i.compressedTexSubImage2D(
                        t.TEXTURE_2D,
                        e,
                        0,
                        0,
                        _.width,
                        _.height,
                        m,
                        _.data
                      )
                    : i.compressedTexImage2D(
                        t.TEXTURE_2D,
                        e,
                        M,
                        _.width,
                        _.height,
                        0,
                        _.data
                      )
                  : console.warn(
                      'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                    )
                : T
                  ? A &&
                    i.texSubImage2D(
                      t.TEXTURE_2D,
                      e,
                      0,
                      0,
                      _.width,
                      _.height,
                      m,
                      f,
                      _.data
                    )
                  : i.texImage2D(
                      t.TEXTURE_2D,
                      e,
                      M,
                      _.width,
                      _.height,
                      0,
                      m,
                      f,
                      _.data
                    )
        }
      else if (n.isDataArrayTexture)
        if (T) {
          if (
            (E &&
              i.texStorage3D(
                t.TEXTURE_2D_ARRAY,
                C,
                M,
                p.width,
                p.height,
                p.depth
              ),
            A)
          )
            if (n.layerUpdates.size > 0) {
              const e = Pc(p.width, p.height, n.format, n.type)
              for (const s of n.layerUpdates) {
                const n = p.data.subarray(
                  (s * e) / p.data.BYTES_PER_ELEMENT,
                  ((s + 1) * e) / p.data.BYTES_PER_ELEMENT
                )
                i.texSubImage3D(
                  t.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  s,
                  p.width,
                  p.height,
                  1,
                  m,
                  f,
                  n
                )
              }
              n.clearLayerUpdates()
            } else
              i.texSubImage3D(
                t.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                p.width,
                p.height,
                p.depth,
                m,
                f,
                p.data
              )
        } else
          i.texImage3D(
            t.TEXTURE_2D_ARRAY,
            0,
            M,
            p.width,
            p.height,
            p.depth,
            0,
            m,
            f,
            p.data
          )
      else if (n.isData3DTexture)
        T
          ? (E &&
              i.texStorage3D(t.TEXTURE_3D, C, M, p.width, p.height, p.depth),
            A &&
              i.texSubImage3D(
                t.TEXTURE_3D,
                0,
                0,
                0,
                0,
                p.width,
                p.height,
                p.depth,
                m,
                f,
                p.data
              ))
          : i.texImage3D(
              t.TEXTURE_3D,
              0,
              M,
              p.width,
              p.height,
              p.depth,
              0,
              m,
              f,
              p.data
            )
      else if (n.isFramebufferTexture) {
        if (E)
          if (T) i.texStorage2D(t.TEXTURE_2D, C, M, p.width, p.height)
          else {
            let e = p.width,
              n = p.height
            for (let s = 0; s < C; s++)
              i.texImage2D(t.TEXTURE_2D, s, M, e, n, 0, m, f, null),
                (e >>= 1),
                (n >>= 1)
          }
      } else if (S.length > 0) {
        if (T && E) {
          const e = it(S[0])
          i.texStorage2D(t.TEXTURE_2D, C, M, e.width, e.height)
        }
        for (let e = 0, n = S.length; e < n; e++)
          (_ = S[e]),
            T
              ? A && i.texSubImage2D(t.TEXTURE_2D, e, 0, 0, m, f, _)
              : i.texImage2D(t.TEXTURE_2D, e, M, m, f, _)
        n.generateMipmaps = !1
      } else if (T) {
        if (E) {
          const e = it(p)
          i.texStorage2D(t.TEXTURE_2D, C, M, e.width, e.height)
        }
        A && i.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, m, f, p)
      } else i.texImage2D(t.TEXTURE_2D, 0, M, m, f, p)
      v(n) && y(l), (u.__version = h.version), n.onUpdate && n.onUpdate(n)
    }
    e.__version = n.version
  }
  function H(e, n, o) {
    if (6 !== n.image.length) return
    const l = z(e, n),
      c = n.source
    i.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture, t.TEXTURE0 + o)
    const h = s.get(c)
    if (c.version !== h.__version || !0 === l) {
      i.activeTexture(t.TEXTURE0 + o)
      const e = Pi.getPrimaries(Pi.workingColorSpace),
        s = n.colorSpace === Tn ? null : Pi.getPrimaries(n.colorSpace),
        u = n.colorSpace === Tn || e === s ? t.NONE : t.BROWSER_DEFAULT_WEBGL
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, n.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, n.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, u)
      const d = n.isCompressedTexture || n.image[0].isCompressedTexture,
        p = n.image[0] && n.image[0].isDataTexture,
        m = []
      for (let t = 0; t < 6; t++)
        (m[t] =
          d || p
            ? p
              ? n.image[t].image
              : n.image[t]
            : g(n.image[t], !0, r.maxCubemapSize)),
          (m[t] = nt(n, m[t]))
      const f = m[0],
        _ = a.convert(n.format, n.colorSpace),
        b = a.convert(n.type),
        M = x(n.internalFormat, _, b, n.colorSpace),
        S = !0 !== n.isVideoTexture,
        T = void 0 === h.__version || !0 === l,
        E = c.dataReady
      let A,
        C = w(n, f)
      if ((F(t.TEXTURE_CUBE_MAP, n), d)) {
        S && T && i.texStorage2D(t.TEXTURE_CUBE_MAP, C, M, f.width, f.height)
        for (let e = 0; e < 6; e++) {
          A = m[e].mipmaps
          for (let s = 0; s < A.length; s++) {
            const r = A[s]
            n.format !== Le
              ? null !== _
                ? S
                  ? E &&
                    i.compressedTexSubImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                      s,
                      0,
                      0,
                      r.width,
                      r.height,
                      _,
                      r.data
                    )
                  : i.compressedTexImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                      s,
                      M,
                      r.width,
                      r.height,
                      0,
                      r.data
                    )
                : console.warn(
                    'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
                  )
              : S
                ? E &&
                  i.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                    s,
                    0,
                    0,
                    r.width,
                    r.height,
                    _,
                    b,
                    r.data
                  )
                : i.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                    s,
                    M,
                    r.width,
                    r.height,
                    0,
                    _,
                    b,
                    r.data
                  )
          }
        }
      } else {
        if (((A = n.mipmaps), S && T)) {
          A.length > 0 && C++
          const e = it(m[0])
          i.texStorage2D(t.TEXTURE_CUBE_MAP, C, M, e.width, e.height)
        }
        for (let e = 0; e < 6; e++)
          if (p) {
            S
              ? E &&
                i.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                  0,
                  0,
                  0,
                  m[e].width,
                  m[e].height,
                  _,
                  b,
                  m[e].data
                )
              : i.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                  0,
                  M,
                  m[e].width,
                  m[e].height,
                  0,
                  _,
                  b,
                  m[e].data
                )
            for (let n = 0; n < A.length; n++) {
              const s = A[n].image[e].image
              S
                ? E &&
                  i.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                    n + 1,
                    0,
                    0,
                    s.width,
                    s.height,
                    _,
                    b,
                    s.data
                  )
                : i.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                    n + 1,
                    M,
                    s.width,
                    s.height,
                    0,
                    _,
                    b,
                    s.data
                  )
            }
          } else {
            S
              ? E &&
                i.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                  0,
                  0,
                  0,
                  _,
                  b,
                  m[e]
                )
              : i.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                  0,
                  M,
                  _,
                  b,
                  m[e]
                )
            for (let n = 0; n < A.length; n++) {
              const s = A[n]
              S
                ? E &&
                  i.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                    n + 1,
                    0,
                    0,
                    _,
                    b,
                    s.image[e]
                  )
                : i.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                    n + 1,
                    M,
                    _,
                    b,
                    s.image[e]
                  )
            }
          }
      }
      v(n) && y(t.TEXTURE_CUBE_MAP),
        (h.__version = c.version),
        n.onUpdate && n.onUpdate(n)
    }
    e.__version = n.version
  }
  function G(e, n, r, o, c, h) {
    const u = a.convert(r.format, r.colorSpace),
      d = a.convert(r.type),
      p = x(r.internalFormat, u, d, r.colorSpace),
      m = s.get(n),
      f = s.get(r)
    if (((f.__renderTarget = n), !m.__hasExternalTextures)) {
      const e = Math.max(1, n.width >> h),
        s = Math.max(1, n.height >> h)
      c === t.TEXTURE_3D || c === t.TEXTURE_2D_ARRAY
        ? i.texImage3D(c, h, p, e, s, n.depth, 0, u, d, null)
        : i.texImage2D(c, h, p, e, s, 0, u, d, null)
    }
    i.bindFramebuffer(t.FRAMEBUFFER, e),
      tt(n)
        ? l.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            o,
            c,
            f.__webglTexture,
            0,
            Q(n)
          )
        : (c === t.TEXTURE_2D ||
            (c >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
              c <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          t.framebufferTexture2D(t.FRAMEBUFFER, o, c, f.__webglTexture, h),
      i.bindFramebuffer(t.FRAMEBUFFER, null)
  }
  function W(e, n, i) {
    if ((t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer)) {
      const s = n.depthTexture,
        r = s && s.isDepthTexture ? s.type : null,
        a = b(n.stencilBuffer, r),
        o = n.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
        c = Q(n)
      tt(n)
        ? l.renderbufferStorageMultisampleEXT(
            t.RENDERBUFFER,
            c,
            a,
            n.width,
            n.height
          )
        : i
          ? t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              c,
              a,
              n.width,
              n.height
            )
          : t.renderbufferStorage(t.RENDERBUFFER, a, n.width, n.height),
        t.framebufferRenderbuffer(t.FRAMEBUFFER, o, t.RENDERBUFFER, e)
    } else {
      const e = n.textures
      for (let s = 0; s < e.length; s++) {
        const r = e[s],
          o = a.convert(r.format, r.colorSpace),
          c = a.convert(r.type),
          h = x(r.internalFormat, o, c, r.colorSpace),
          u = Q(n)
        i && !1 === tt(n)
          ? t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              u,
              h,
              n.width,
              n.height
            )
          : tt(n)
            ? l.renderbufferStorageMultisampleEXT(
                t.RENDERBUFFER,
                u,
                h,
                n.width,
                n.height
              )
            : t.renderbufferStorage(t.RENDERBUFFER, h, n.width, n.height)
      }
    }
    t.bindRenderbuffer(t.RENDERBUFFER, null)
  }
  function j(e, n) {
    if (n && n.isWebGLCubeRenderTarget)
      throw new Error('Depth Texture with cube render targets is not supported')
    if (
      (i.bindFramebuffer(t.FRAMEBUFFER, e),
      !n.depthTexture || !n.depthTexture.isDepthTexture)
    )
      throw new Error(
        'renderTarget.depthTexture must be an instance of THREE.DepthTexture'
      )
    const r = s.get(n.depthTexture)
    ;(r.__renderTarget = n),
      (r.__webglTexture &&
        n.depthTexture.image.width === n.width &&
        n.depthTexture.image.height === n.height) ||
        ((n.depthTexture.image.width = n.width),
        (n.depthTexture.image.height = n.height),
        (n.depthTexture.needsUpdate = !0)),
      L(n.depthTexture, 0)
    const a = r.__webglTexture,
      o = Q(n)
    if (n.depthTexture.format === De)
      tt(n)
        ? l.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            a,
            0,
            o
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            a,
            0
          )
    else {
      if (n.depthTexture.format !== ke)
        throw new Error('Unknown depthTexture format')
      tt(n)
        ? l.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            a,
            0,
            o
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            a,
            0
          )
    }
  }
  function X(n) {
    const r = s.get(n),
      a = !0 === n.isWebGLCubeRenderTarget
    if (r.__boundDepthTexture !== n.depthTexture) {
      const t = n.depthTexture
      if ((r.__depthDisposeCallback && r.__depthDisposeCallback(), t)) {
        const n = e(() => {
          delete r.__boundDepthTexture,
            delete r.__depthDisposeCallback,
            t.removeEventListener('dispose', n)
        }, 'disposeEvent')
        t.addEventListener('dispose', n), (r.__depthDisposeCallback = n)
      }
      r.__boundDepthTexture = t
    }
    if (n.depthTexture && !r.__autoAllocateDepthBuffer) {
      if (a)
        throw new Error(
          'target.depthTexture not supported in Cube render targets'
        )
      j(r.__webglFramebuffer, n)
    } else if (a) {
      r.__webglDepthbuffer = []
      for (let e = 0; e < 6; e++)
        if (
          (i.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[e]),
          void 0 === r.__webglDepthbuffer[e])
        )
          (r.__webglDepthbuffer[e] = t.createRenderbuffer()),
            W(r.__webglDepthbuffer[e], n, !1)
        else {
          const i = n.stencilBuffer
              ? t.DEPTH_STENCIL_ATTACHMENT
              : t.DEPTH_ATTACHMENT,
            s = r.__webglDepthbuffer[e]
          t.bindRenderbuffer(t.RENDERBUFFER, s),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, i, t.RENDERBUFFER, s)
        }
    } else if (
      (i.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer),
      void 0 === r.__webglDepthbuffer)
    )
      (r.__webglDepthbuffer = t.createRenderbuffer()),
        W(r.__webglDepthbuffer, n, !1)
    else {
      const e = n.stencilBuffer
          ? t.DEPTH_STENCIL_ATTACHMENT
          : t.DEPTH_ATTACHMENT,
        i = r.__webglDepthbuffer
      t.bindRenderbuffer(t.RENDERBUFFER, i),
        t.framebufferRenderbuffer(t.FRAMEBUFFER, e, t.RENDERBUFFER, i)
    }
    i.bindFramebuffer(t.FRAMEBUFFER, null)
  }
  function q(e, n, i) {
    const r = s.get(e)
    void 0 !== n &&
      G(
        r.__webglFramebuffer,
        e,
        e.texture,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D,
        0
      ),
      void 0 !== i && X(e)
  }
  function Y(e) {
    const n = e.texture,
      r = s.get(e),
      l = s.get(n)
    e.addEventListener('dispose', S)
    const c = e.textures,
      h = !0 === e.isWebGLCubeRenderTarget,
      u = c.length > 1
    if (
      (u ||
        (void 0 === l.__webglTexture && (l.__webglTexture = t.createTexture()),
        (l.__version = n.version),
        o.memory.textures++),
      h)
    ) {
      r.__webglFramebuffer = []
      for (let e = 0; e < 6; e++)
        if (n.mipmaps && n.mipmaps.length > 0) {
          r.__webglFramebuffer[e] = []
          for (let i = 0; i < n.mipmaps.length; i++)
            r.__webglFramebuffer[e][i] = t.createFramebuffer()
        } else r.__webglFramebuffer[e] = t.createFramebuffer()
    } else {
      if (n.mipmaps && n.mipmaps.length > 0) {
        r.__webglFramebuffer = []
        for (let e = 0; e < n.mipmaps.length; e++)
          r.__webglFramebuffer[e] = t.createFramebuffer()
      } else r.__webglFramebuffer = t.createFramebuffer()
      if (u)
        for (let e = 0, n = c.length; e < n; e++) {
          const n = s.get(c[e])
          void 0 === n.__webglTexture &&
            ((n.__webglTexture = t.createTexture()), o.memory.textures++)
        }
      if (e.samples > 0 && !1 === tt(e)) {
        ;(r.__webglMultisampledFramebuffer = t.createFramebuffer()),
          (r.__webglColorRenderbuffer = []),
          i.bindFramebuffer(t.FRAMEBUFFER, r.__webglMultisampledFramebuffer)
        for (let n = 0; n < c.length; n++) {
          const i = c[n]
          ;(r.__webglColorRenderbuffer[n] = t.createRenderbuffer()),
            t.bindRenderbuffer(t.RENDERBUFFER, r.__webglColorRenderbuffer[n])
          const s = a.convert(i.format, i.colorSpace),
            o = a.convert(i.type),
            l = x(
              i.internalFormat,
              s,
              o,
              i.colorSpace,
              !0 === e.isXRRenderTarget
            ),
            h = Q(e)
          t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            h,
            l,
            e.width,
            e.height
          ),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + n,
              t.RENDERBUFFER,
              r.__webglColorRenderbuffer[n]
            )
        }
        t.bindRenderbuffer(t.RENDERBUFFER, null),
          e.depthBuffer &&
            ((r.__webglDepthRenderbuffer = t.createRenderbuffer()),
            W(r.__webglDepthRenderbuffer, e, !0)),
          i.bindFramebuffer(t.FRAMEBUFFER, null)
      }
    }
    if (h) {
      i.bindTexture(t.TEXTURE_CUBE_MAP, l.__webglTexture),
        F(t.TEXTURE_CUBE_MAP, n)
      for (let i = 0; i < 6; i++)
        if (n.mipmaps && n.mipmaps.length > 0)
          for (let s = 0; s < n.mipmaps.length; s++)
            G(
              r.__webglFramebuffer[i][s],
              e,
              n,
              t.COLOR_ATTACHMENT0,
              t.TEXTURE_CUBE_MAP_POSITIVE_X + i,
              s
            )
        else
          G(
            r.__webglFramebuffer[i],
            e,
            n,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_CUBE_MAP_POSITIVE_X + i,
            0
          )
      v(n) && y(t.TEXTURE_CUBE_MAP), i.unbindTexture()
    } else if (u) {
      for (let n = 0, a = c.length; n < a; n++) {
        const a = c[n],
          o = s.get(a)
        i.bindTexture(t.TEXTURE_2D, o.__webglTexture),
          F(t.TEXTURE_2D, a),
          G(
            r.__webglFramebuffer,
            e,
            a,
            t.COLOR_ATTACHMENT0 + n,
            t.TEXTURE_2D,
            0
          ),
          v(a) && y(t.TEXTURE_2D)
      }
      i.unbindTexture()
    } else {
      let s = t.TEXTURE_2D
      if (
        ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) &&
          (s = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY),
        i.bindTexture(s, l.__webglTexture),
        F(s, n),
        n.mipmaps && n.mipmaps.length > 0)
      )
        for (let i = 0; i < n.mipmaps.length; i++)
          G(r.__webglFramebuffer[i], e, n, t.COLOR_ATTACHMENT0, s, i)
      else G(r.__webglFramebuffer, e, n, t.COLOR_ATTACHMENT0, s, 0)
      v(n) && y(s), i.unbindTexture()
    }
    e.depthBuffer && X(e)
  }
  function Z(t) {
    const e = t.textures
    for (let n = 0, r = e.length; n < r; n++) {
      const r = e[n]
      if (v(r)) {
        const e = _(t),
          n = s.get(r).__webglTexture
        i.bindTexture(e, n), y(e), i.unbindTexture()
      }
    }
  }
  e(F, 'setTextureParameters'),
    e(z, 'initTexture'),
    e(V, 'uploadTexture'),
    e(H, 'uploadCubeTexture'),
    e(G, 'setupFrameBufferTexture'),
    e(W, 'setupRenderBufferStorage'),
    e(j, 'setupDepthTexture'),
    e(X, 'setupDepthRenderbuffer'),
    e(q, 'rebindTextures'),
    e(Y, 'setupRenderTarget'),
    e(Z, 'updateRenderTargetMipmap')
  const K = [],
    $ = []
  function J(e) {
    if (e.samples > 0)
      if (!1 === tt(e)) {
        const n = e.textures,
          r = e.width,
          a = e.height
        let o = t.COLOR_BUFFER_BIT
        const l = e.stencilBuffer
            ? t.DEPTH_STENCIL_ATTACHMENT
            : t.DEPTH_ATTACHMENT,
          h = s.get(e),
          u = n.length > 1
        if (u)
          for (let e = 0; e < n.length; e++)
            i.bindFramebuffer(t.FRAMEBUFFER, h.__webglMultisampledFramebuffer),
              t.framebufferRenderbuffer(
                t.FRAMEBUFFER,
                t.COLOR_ATTACHMENT0 + e,
                t.RENDERBUFFER,
                null
              ),
              i.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer),
              t.framebufferTexture2D(
                t.DRAW_FRAMEBUFFER,
                t.COLOR_ATTACHMENT0 + e,
                t.TEXTURE_2D,
                null,
                0
              )
        i.bindFramebuffer(t.READ_FRAMEBUFFER, h.__webglMultisampledFramebuffer),
          i.bindFramebuffer(t.DRAW_FRAMEBUFFER, h.__webglFramebuffer)
        for (let i = 0; i < n.length; i++) {
          if (
            (e.resolveDepthBuffer &&
              (e.depthBuffer && (o |= t.DEPTH_BUFFER_BIT),
              e.stencilBuffer &&
                e.resolveStencilBuffer &&
                (o |= t.STENCIL_BUFFER_BIT)),
            u)
          ) {
            t.framebufferRenderbuffer(
              t.READ_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0,
              t.RENDERBUFFER,
              h.__webglColorRenderbuffer[i]
            )
            const e = s.get(n[i]).__webglTexture
            t.framebufferTexture2D(
              t.DRAW_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0,
              t.TEXTURE_2D,
              e,
              0
            )
          }
          t.blitFramebuffer(0, 0, r, a, 0, 0, r, a, o, t.NEAREST),
            !0 === c &&
              ((K.length = 0),
              ($.length = 0),
              K.push(t.COLOR_ATTACHMENT0 + i),
              e.depthBuffer &&
                !1 === e.resolveDepthBuffer &&
                (K.push(l),
                $.push(l),
                t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, $)),
              t.invalidateFramebuffer(t.READ_FRAMEBUFFER, K))
        }
        if (
          (i.bindFramebuffer(t.READ_FRAMEBUFFER, null),
          i.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
          u)
        )
          for (let e = 0; e < n.length; e++) {
            i.bindFramebuffer(t.FRAMEBUFFER, h.__webglMultisampledFramebuffer),
              t.framebufferRenderbuffer(
                t.FRAMEBUFFER,
                t.COLOR_ATTACHMENT0 + e,
                t.RENDERBUFFER,
                h.__webglColorRenderbuffer[e]
              )
            const r = s.get(n[e]).__webglTexture
            i.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer),
              t.framebufferTexture2D(
                t.DRAW_FRAMEBUFFER,
                t.COLOR_ATTACHMENT0 + e,
                t.TEXTURE_2D,
                r,
                0
              )
          }
        i.bindFramebuffer(t.DRAW_FRAMEBUFFER, h.__webglMultisampledFramebuffer)
      } else if (e.depthBuffer && !1 === e.resolveDepthBuffer && c) {
        const n = e.stencilBuffer
          ? t.DEPTH_STENCIL_ATTACHMENT
          : t.DEPTH_ATTACHMENT
        t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [n])
      }
  }
  function Q(t) {
    return Math.min(r.maxSamples, t.samples)
  }
  function tt(t) {
    const e = s.get(t)
    return (
      t.samples > 0 &&
      !0 === n.has('WEBGL_multisampled_render_to_texture') &&
      !1 !== e.__useRenderToTexture
    )
  }
  function et(t) {
    const e = o.render.frame
    u.get(t) !== e && (u.set(t, e), t.update())
  }
  function nt(t, e) {
    const n = t.colorSpace,
      i = t.format,
      s = t.type
    return (
      !0 === t.isCompressedTexture ||
        !0 === t.isVideoTexture ||
        (n !== An &&
          n !== Tn &&
          (Pi.getTransfer(n) === Rn
            ? (i === Le && s === Me) ||
              console.warn(
                'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.'
              )
            : console.error(
                'THREE.WebGLTextures: Unsupported texture color space:',
                n
              ))),
      e
    )
  }
  function it(t) {
    return (
      'undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement
        ? ((h.width = t.naturalWidth || t.width),
          (h.height = t.naturalHeight || t.height))
        : 'undefined' != typeof VideoFrame && t instanceof VideoFrame
          ? ((h.width = t.displayWidth), (h.height = t.displayHeight))
          : ((h.width = t.width), (h.height = t.height)),
      h
    )
  }
  e(J, 'updateMultisampleRenderTarget'),
    e(Q, 'getRenderTargetSamples'),
    e(tt, 'useMultisampledRTT'),
    e(et, 'updateVideoTexture'),
    e(nt, 'verifyColorSpace'),
    e(it, 'getDimensions'),
    (this.allocateTextureUnit = P),
    (this.resetTextureUnits = R),
    (this.setTexture2D = L),
    (this.setTexture2DArray = D),
    (this.setTexture3D = k),
    (this.setTextureCube = N),
    (this.rebindTextures = q),
    (this.setupRenderTarget = Y),
    (this.updateRenderTargetMipmap = Z),
    (this.updateMultisampleRenderTarget = J),
    (this.setupDepthRenderbuffer = X),
    (this.setupFrameBufferTexture = G),
    (this.useMultisampledRTT = tt)
}
function Dc(t, n) {
  function i(e, i = '') {
    let s
    const r = Pi.getTransfer(i)
    if (e === Me) return t.UNSIGNED_BYTE
    if (e === Re) return t.UNSIGNED_SHORT_4_4_4_4
    if (e === Pe) return t.UNSIGNED_SHORT_5_5_5_1
    if (35902 === e) return t.UNSIGNED_INT_5_9_9_9_REV
    if (1010 === e) return t.BYTE
    if (1011 === e) return t.SHORT
    if (e === Se) return t.UNSIGNED_SHORT
    if (e === Te) return t.INT
    if (e === Ee) return t.UNSIGNED_INT
    if (e === Ae) return t.FLOAT
    if (e === Ce) return t.HALF_FLOAT
    if (1021 === e) return t.ALPHA
    if (1022 === e) return t.RGB
    if (e === Le) return t.RGBA
    if (1024 === e) return t.LUMINANCE
    if (1025 === e) return t.LUMINANCE_ALPHA
    if (e === De) return t.DEPTH_COMPONENT
    if (e === ke) return t.DEPTH_STENCIL
    if (e === Ne) return t.RED
    if (e === Ue) return t.RED_INTEGER
    if (1030 === e) return t.RG
    if (e === Be) return t.RG_INTEGER
    if (e === Oe) return t.RGBA_INTEGER
    if (e === Fe || e === ze || e === Ve || e === He)
      if (r === Rn) {
        if (((s = n.get('WEBGL_compressed_texture_s3tc_srgb')), null === s))
          return null
        if (e === Fe) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT
        if (e === ze) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT
        if (e === Ve) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT
        if (e === He) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
      } else {
        if (((s = n.get('WEBGL_compressed_texture_s3tc')), null === s))
          return null
        if (e === Fe) return s.COMPRESSED_RGB_S3TC_DXT1_EXT
        if (e === ze) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT
        if (e === Ve) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT
        if (e === He) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
      }
    if (e === Ge || e === We || e === je || e === Xe) {
      if (((s = n.get('WEBGL_compressed_texture_pvrtc')), null === s))
        return null
      if (e === Ge) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
      if (e === We) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
      if (e === je) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
      if (e === Xe) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
    }
    if (e === qe || e === Ye || e === Ze) {
      if (((s = n.get('WEBGL_compressed_texture_etc')), null === s)) return null
      if (e === qe || e === Ye)
        return r === Rn ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2
      if (e === Ze)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
          : s.COMPRESSED_RGBA8_ETC2_EAC
    }
    if (
      e === Ke ||
      e === $e ||
      e === Je ||
      e === Qe ||
      e === tn ||
      e === en ||
      e === nn ||
      e === sn ||
      e === rn ||
      e === an ||
      e === on ||
      e === ln ||
      e === cn ||
      e === hn
    ) {
      if (((s = n.get('WEBGL_compressed_texture_astc')), null === s))
        return null
      if (e === Ke)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
          : s.COMPRESSED_RGBA_ASTC_4x4_KHR
      if (e === $e)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
          : s.COMPRESSED_RGBA_ASTC_5x4_KHR
      if (e === Je)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
          : s.COMPRESSED_RGBA_ASTC_5x5_KHR
      if (e === Qe)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
          : s.COMPRESSED_RGBA_ASTC_6x5_KHR
      if (e === tn)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
          : s.COMPRESSED_RGBA_ASTC_6x6_KHR
      if (e === en)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
          : s.COMPRESSED_RGBA_ASTC_8x5_KHR
      if (e === nn)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
          : s.COMPRESSED_RGBA_ASTC_8x6_KHR
      if (e === sn)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
          : s.COMPRESSED_RGBA_ASTC_8x8_KHR
      if (e === rn)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
          : s.COMPRESSED_RGBA_ASTC_10x5_KHR
      if (e === an)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
          : s.COMPRESSED_RGBA_ASTC_10x6_KHR
      if (e === on)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
          : s.COMPRESSED_RGBA_ASTC_10x8_KHR
      if (e === ln)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
          : s.COMPRESSED_RGBA_ASTC_10x10_KHR
      if (e === cn)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
          : s.COMPRESSED_RGBA_ASTC_12x10_KHR
      if (e === hn)
        return r === Rn
          ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
          : s.COMPRESSED_RGBA_ASTC_12x12_KHR
    }
    if (e === un || e === dn || e === pn) {
      if (((s = n.get('EXT_texture_compression_bptc')), null === s)) return null
      if (e === un)
        return r === Rn
          ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
          : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
      if (e === dn) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT
      if (e === pn) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
    }
    if (36283 === e || e === mn || e === fn || e === gn) {
      if (((s = n.get('EXT_texture_compression_rgtc')), null === s)) return null
      if (e === un) return s.COMPRESSED_RED_RGTC1_EXT
      if (e === mn) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT
      if (e === fn) return s.COMPRESSED_RED_GREEN_RGTC2_EXT
      if (e === gn) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
    }
    return e === Ie ? t.UNSIGNED_INT_24_8 : void 0 !== t[e] ? t[e] : null
  }
  return e(i, 'convert'), { convert: i }
}
e(Lc, 'WebGLTextures'), e(Dc, 'WebGLUtils')
class kc extends ba {
  static {
    e(this, 'ArrayCamera')
  }
  constructor(t = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = t)
  }
}
class Nc extends nr {
  static {
    e(this, 'Group')
  }
  constructor() {
    super(), (this.isGroup = !0), (this.type = 'Group')
  }
}
const Uc = { type: 'move' }
class Bc {
  static {
    e(this, 'WebXRController')
  }
  constructor() {
    ;(this._targetRay = null), (this._grip = null), (this._hand = null)
  }
  getHandSpace() {
    return (
      null === this._hand &&
        ((this._hand = new Nc()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    )
  }
  getTargetRaySpace() {
    return (
      null === this._targetRay &&
        ((this._targetRay = new Nc()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Qi()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Qi())),
      this._targetRay
    )
  }
  getGripSpace() {
    return (
      null === this._grip &&
        ((this._grip = new Nc()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Qi()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Qi())),
      this._grip
    )
  }
  dispatchEvent(t) {
    return (
      null !== this._targetRay && this._targetRay.dispatchEvent(t),
      null !== this._grip && this._grip.dispatchEvent(t),
      null !== this._hand && this._hand.dispatchEvent(t),
      this
    )
  }
  connect(t) {
    if (t && t.hand) {
      const e = this._hand
      if (e) for (const n of t.hand.values()) this._getHandJoint(e, n)
    }
    return this.dispatchEvent({ type: 'connected', data: t }), this
  }
  disconnect(t) {
    return (
      this.dispatchEvent({ type: 'disconnected', data: t }),
      null !== this._targetRay && (this._targetRay.visible = !1),
      null !== this._grip && (this._grip.visible = !1),
      null !== this._hand && (this._hand.visible = !1),
      this
    )
  }
  update(t, e, n) {
    let i = null,
      s = null,
      r = null
    const a = this._targetRay,
      o = this._grip,
      l = this._hand
    if (t && 'visible-blurred' !== e.session.visibilityState) {
      if (l && t.hand) {
        r = !0
        for (const r of t.hand.values()) {
          const t = e.getJointPose(r, n),
            i = this._getHandJoint(l, r)
          null !== t &&
            (i.matrix.fromArray(t.transform.matrix),
            i.matrix.decompose(i.position, i.rotation, i.scale),
            (i.matrixWorldNeedsUpdate = !0),
            (i.jointRadius = t.radius)),
            (i.visible = null !== t)
        }
        const i = l.joints['index-finger-tip'],
          s = l.joints['thumb-tip'],
          a = i.position.distanceTo(s.position),
          o = 0.02,
          c = 0.005
        l.inputState.pinching && a > o + c
          ? ((l.inputState.pinching = !1),
            this.dispatchEvent({
              type: 'pinchend',
              handedness: t.handedness,
              target: this
            }))
          : !l.inputState.pinching &&
            a <= o - c &&
            ((l.inputState.pinching = !0),
            this.dispatchEvent({
              type: 'pinchstart',
              handedness: t.handedness,
              target: this
            }))
      } else
        null !== o &&
          t.gripSpace &&
          ((s = e.getPose(t.gripSpace, n)),
          null !== s &&
            (o.matrix.fromArray(s.transform.matrix),
            o.matrix.decompose(o.position, o.rotation, o.scale),
            (o.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((o.hasLinearVelocity = !0),
                o.linearVelocity.copy(s.linearVelocity))
              : (o.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((o.hasAngularVelocity = !0),
                o.angularVelocity.copy(s.angularVelocity))
              : (o.hasAngularVelocity = !1)))
      null !== a &&
        ((i = e.getPose(t.targetRaySpace, n)),
        null === i && null !== s && (i = s),
        null !== i &&
          (a.matrix.fromArray(i.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(i.linearVelocity))
            : (a.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(i.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(Uc)))
    }
    return (
      null !== a && (a.visible = null !== i),
      null !== o && (o.visible = null !== s),
      null !== l && (l.visible = null !== r),
      this
    )
  }
  _getHandJoint(t, e) {
    if (void 0 === t.joints[e.jointName]) {
      const n = new Nc()
      ;(n.matrixAutoUpdate = !1),
        (n.visible = !1),
        (t.joints[e.jointName] = n),
        t.add(n)
    }
    return t.joints[e.jointName]
  }
}
class Oc {
  static {
    e(this, 'WebXRDepthSensing')
  }
  constructor() {
    ;(this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0)
  }
  init(t, e, n) {
    if (null === this.texture) {
      const i = new Wi()
      ;(t.properties.get(i).__webglTexture = e.texture),
        (e.depthNear == n.depthNear && e.depthFar == n.depthFar) ||
          ((this.depthNear = e.depthNear), (this.depthFar = e.depthFar)),
        (this.texture = i)
    }
  }
  getMesh(t) {
    if (null !== this.texture && null === this.mesh) {
      const e = t.cameras[0].viewport,
        n = new ga({
          vertexShader:
            '\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}',
          fragmentShader:
            '\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}',
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: e.z },
            depthHeight: { value: e.w }
          }
        })
      this.mesh = new oa(new Na(20, 20), n)
    }
    return this.mesh
  }
  reset() {
    ;(this.texture = null), (this.mesh = null)
  }
  getDepthTexture() {
    return this.texture
  }
}
class Fc extends Gn {
  static {
    e(this, 'WebXRManager')
  }
  constructor(t, n) {
    super()
    const i = this
    let s = null,
      r = 1,
      a = null,
      o = 'local-floor',
      l = 1,
      c = null,
      h = null,
      u = null,
      d = null,
      p = null,
      m = null
    const f = new Oc(),
      g = n.getContextAttributes()
    let v = null,
      y = null
    const _ = [],
      x = [],
      b = new vi()
    let w = null
    const M = new ba()
    M.viewport = new ji()
    const S = new ba()
    S.viewport = new ji()
    const T = [M, S],
      E = new kc()
    let A = null,
      C = null
    function R(t) {
      const e = x.indexOf(t.inputSource)
      if (-1 === e) return
      const n = _[e]
      void 0 !== n &&
        (n.update(t.inputSource, t.frame, c || a),
        n.dispatchEvent({ type: t.type, data: t.inputSource }))
    }
    function P() {
      s.removeEventListener('select', R),
        s.removeEventListener('selectstart', R),
        s.removeEventListener('selectend', R),
        s.removeEventListener('squeeze', R),
        s.removeEventListener('squeezestart', R),
        s.removeEventListener('squeezeend', R),
        s.removeEventListener('end', P),
        s.removeEventListener('inputsourceschange', I)
      for (let t = 0; t < _.length; t++) {
        const e = x[t]
        null !== e && ((x[t] = null), _[t].disconnect(e))
      }
      ;(A = null),
        (C = null),
        f.reset(),
        t.setRenderTarget(v),
        (p = null),
        (d = null),
        (u = null),
        (s = null),
        (y = null),
        F.stop(),
        (i.isPresenting = !1),
        t.setPixelRatio(w),
        t.setSize(b.width, b.height, !1),
        i.dispatchEvent({ type: 'sessionend' })
    }
    function I(t) {
      for (let e = 0; e < t.removed.length; e++) {
        const n = t.removed[e],
          i = x.indexOf(n)
        i >= 0 && ((x[i] = null), _[i].disconnect(n))
      }
      for (let e = 0; e < t.added.length; e++) {
        const n = t.added[e]
        let i = x.indexOf(n)
        if (-1 === i) {
          for (let t = 0; t < _.length; t++) {
            if (t >= x.length) {
              x.push(n), (i = t)
              break
            }
            if (null === x[t]) {
              ;(x[t] = n), (i = t)
              break
            }
          }
          if (-1 === i) break
        }
        const s = _[i]
        s && s.connect(n)
      }
    }
    ;(this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (t) {
        let e = _[t]
        return (
          void 0 === e && ((e = new Bc()), (_[t] = e)), e.getTargetRaySpace()
        )
      }),
      (this.getControllerGrip = function (t) {
        let e = _[t]
        return void 0 === e && ((e = new Bc()), (_[t] = e)), e.getGripSpace()
      }),
      (this.getHand = function (t) {
        let e = _[t]
        return void 0 === e && ((e = new Bc()), (_[t] = e)), e.getHandSpace()
      }),
      e(R, 'onSessionEvent'),
      e(P, 'onSessionEnd'),
      (this.setFramebufferScaleFactor = function (t) {
        ;(r = t),
          !0 === i.isPresenting &&
            console.warn(
              'THREE.WebXRManager: Cannot change framebuffer scale while presenting.'
            )
      }),
      (this.setReferenceSpaceType = function (t) {
        ;(o = t),
          !0 === i.isPresenting &&
            console.warn(
              'THREE.WebXRManager: Cannot change reference space type while presenting.'
            )
      }),
      (this.getReferenceSpace = function () {
        return c || a
      }),
      (this.setReferenceSpace = function (t) {
        c = t
      }),
      (this.getBaseLayer = function () {
        return null !== d ? d : p
      }),
      (this.getBinding = function () {
        return u
      }),
      (this.getFrame = function () {
        return m
      }),
      (this.getSession = function () {
        return s
      }),
      (this.setSession = async function (e) {
        if (((s = e), null !== s)) {
          if (
            ((v = t.getRenderTarget()),
            s.addEventListener('select', R),
            s.addEventListener('selectstart', R),
            s.addEventListener('selectend', R),
            s.addEventListener('squeeze', R),
            s.addEventListener('squeezestart', R),
            s.addEventListener('squeezeend', R),
            s.addEventListener('end', P),
            s.addEventListener('inputsourceschange', I),
            !0 !== g.xrCompatible && (await n.makeXRCompatible()),
            (w = t.getPixelRatio()),
            t.getSize(b),
            void 0 === s.renderState.layers)
          ) {
            const e = {
              antialias: g.antialias,
              alpha: !0,
              depth: g.depth,
              stencil: g.stencil,
              framebufferScaleFactor: r
            }
            ;(p = new XRWebGLLayer(s, n, e)),
              s.updateRenderState({ baseLayer: p }),
              t.setPixelRatio(1),
              t.setSize(p.framebufferWidth, p.framebufferHeight, !1),
              (y = new qi(p.framebufferWidth, p.framebufferHeight, {
                format: Le,
                type: Me,
                colorSpace: t.outputColorSpace,
                stencilBuffer: g.stencil
              }))
          } else {
            let e = null,
              i = null,
              a = null
            g.depth &&
              ((a = g.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24),
              (e = g.stencil ? ke : De),
              (i = g.stencil ? Ie : Ee))
            const o = { colorFormat: n.RGBA8, depthFormat: a, scaleFactor: r }
            ;(u = new XRWebGLBinding(s, n)),
              (d = u.createProjectionLayer(o)),
              s.updateRenderState({ layers: [d] }),
              t.setPixelRatio(1),
              t.setSize(d.textureWidth, d.textureHeight, !1),
              (y = new qi(d.textureWidth, d.textureHeight, {
                format: Le,
                type: Me,
                depthTexture: new wo(
                  d.textureWidth,
                  d.textureHeight,
                  i,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  e
                ),
                stencilBuffer: g.stencil,
                colorSpace: t.outputColorSpace,
                samples: g.antialias ? 4 : 0,
                resolveDepthBuffer: !1 === d.ignoreDepthValues
              }))
          }
          ;(y.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (a = await s.requestReferenceSpace(o)),
            F.setContext(s),
            F.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: 'sessionstart' })
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (null !== s) return s.environmentBlendMode
      }),
      (this.getDepthTexture = function () {
        return f.getDepthTexture()
      }),
      e(I, 'onInputSourcesChange')
    const L = new Qi(),
      D = new Qi()
    function k(t, e, n) {
      L.setFromMatrixPosition(e.matrixWorld),
        D.setFromMatrixPosition(n.matrixWorld)
      const i = L.distanceTo(D),
        s = e.projectionMatrix.elements,
        r = n.projectionMatrix.elements,
        a = s[14] / (s[10] - 1),
        o = s[14] / (s[10] + 1),
        l = (s[9] + 1) / s[5],
        c = (s[9] - 1) / s[5],
        h = (s[8] - 1) / s[0],
        u = (r[8] + 1) / r[0],
        d = a * h,
        p = a * u,
        m = i / (-h + u),
        f = m * -h
      if (
        (e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
        t.translateX(f),
        t.translateZ(m),
        t.matrixWorld.compose(t.position, t.quaternion, t.scale),
        t.matrixWorldInverse.copy(t.matrixWorld).invert(),
        -1 === s[10])
      )
        t.projectionMatrix.copy(e.projectionMatrix),
          t.projectionMatrixInverse.copy(e.projectionMatrixInverse)
      else {
        const e = a + m,
          n = o + m,
          s = d - f,
          r = p + (i - f),
          h = ((l * o) / n) * e,
          u = ((c * o) / n) * e
        t.projectionMatrix.makePerspective(s, r, h, u, e, n),
          t.projectionMatrixInverse.copy(t.projectionMatrix).invert()
      }
    }
    function N(t, e) {
      null === e
        ? t.matrixWorld.copy(t.matrix)
        : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
        t.matrixWorldInverse.copy(t.matrixWorld).invert()
    }
    function U(t, e, n) {
      null === n
        ? t.matrix.copy(e.matrixWorld)
        : (t.matrix.copy(n.matrixWorld),
          t.matrix.invert(),
          t.matrix.multiply(e.matrixWorld)),
        t.matrix.decompose(t.position, t.quaternion, t.scale),
        t.updateMatrixWorld(!0),
        t.projectionMatrix.copy(e.projectionMatrix),
        t.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        t.isPerspectiveCamera &&
          ((t.fov = 2 * qn * Math.atan(1 / t.projectionMatrix.elements[5])),
          (t.zoom = 1))
    }
    e(k, 'setProjectionFromUnion'),
      e(N, 'updateCamera'),
      (this.updateCamera = function (t) {
        if (null === s) return
        let e = t.near,
          n = t.far
        null !== f.texture &&
          (f.depthNear > 0 && (e = f.depthNear),
          f.depthFar > 0 && (n = f.depthFar)),
          (E.near = S.near = M.near = e),
          (E.far = S.far = M.far = n),
          (A === E.near && C === E.far) ||
            (s.updateRenderState({ depthNear: E.near, depthFar: E.far }),
            (A = E.near),
            (C = E.far)),
          (M.layers.mask = 2 | t.layers.mask),
          (S.layers.mask = 4 | t.layers.mask),
          (E.layers.mask = M.layers.mask | S.layers.mask)
        const i = t.parent,
          r = E.cameras
        N(E, i)
        for (let s = 0; s < r.length; s++) N(r[s], i)
        2 === r.length
          ? k(E, M, S)
          : E.projectionMatrix.copy(M.projectionMatrix),
          U(t, E, i)
      }),
      e(U, 'updateUserCamera'),
      (this.getCamera = function () {
        return E
      }),
      (this.getFoveation = function () {
        if (null !== d || null !== p) return l
      }),
      (this.setFoveation = function (t) {
        ;(l = t),
          null !== d && (d.fixedFoveation = t),
          null !== p && void 0 !== p.fixedFoveation && (p.fixedFoveation = t)
      }),
      (this.hasDepthSensing = function () {
        return null !== f.texture
      }),
      (this.getDepthSensingMesh = function () {
        return f.getMesh(E)
      })
    let B = null
    function O(e, n) {
      if (((h = n.getViewerPose(c || a)), (m = n), null !== h)) {
        const e = h.views
        null !== p &&
          (t.setRenderTargetFramebuffer(y, p.framebuffer), t.setRenderTarget(y))
        let n = !1
        e.length !== E.cameras.length && ((E.cameras.length = 0), (n = !0))
        for (let s = 0; s < e.length; s++) {
          const i = e[s]
          let r = null
          if (null !== p) r = p.getViewport(i)
          else {
            const e = u.getViewSubImage(d, i)
            ;(r = e.viewport),
              0 === s &&
                (t.setRenderTargetTextures(
                  y,
                  e.colorTexture,
                  d.ignoreDepthValues ? void 0 : e.depthStencilTexture
                ),
                t.setRenderTarget(y))
          }
          let a = T[s]
          void 0 === a &&
            ((a = new ba()),
            a.layers.enable(s),
            (a.viewport = new ji()),
            (T[s] = a)),
            a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.quaternion, a.scale),
            a.projectionMatrix.fromArray(i.projectionMatrix),
            a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
            a.viewport.set(r.x, r.y, r.width, r.height),
            0 === s &&
              (E.matrix.copy(a.matrix),
              E.matrix.decompose(E.position, E.quaternion, E.scale)),
            !0 === n && E.cameras.push(a)
        }
        const i = s.enabledFeatures
        if (i && i.includes('depth-sensing')) {
          const n = u.getDepthInformation(e[0])
          n && n.isValid && n.texture && f.init(t, n, s.renderState)
        }
      }
      for (let t = 0; t < _.length; t++) {
        const e = x[t],
          i = _[t]
        null !== e && void 0 !== i && i.update(e, n, c || a)
      }
      B && B(e, n),
        n.detectedPlanes &&
          i.dispatchEvent({ type: 'planesdetected', data: n }),
        (m = null)
    }
    e(O, 'onAnimationFrame')
    const F = new Da()
    F.setAnimationLoop(O),
      (this.setAnimationLoop = function (t) {
        B = t
      }),
      (this.dispose = function () {})
  }
}
const zc = new Fs(),
  Vc = new Rs()
function Hc(t, n) {
  function i(t, e) {
    !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix)
  }
  function s(e, n) {
    n.color.getRGB(e.fogColor.value, ma(t)),
      n.isFog
        ? ((e.fogNear.value = n.near), (e.fogFar.value = n.far))
        : n.isFogExp2 && (e.fogDensity.value = n.density)
  }
  function r(t, e, n, i, s) {
    e.isMeshBasicMaterial || e.isMeshLambertMaterial
      ? a(t, e)
      : e.isMeshToonMaterial
        ? (a(t, e), d(t, e))
        : e.isMeshPhongMaterial
          ? (a(t, e), u(t, e))
          : e.isMeshStandardMaterial
            ? (a(t, e), p(t, e), e.isMeshPhysicalMaterial && m(t, e, s))
            : e.isMeshMatcapMaterial
              ? (a(t, e), f(t, e))
              : e.isMeshDepthMaterial
                ? a(t, e)
                : e.isMeshDistanceMaterial
                  ? (a(t, e), g(t, e))
                  : e.isMeshNormalMaterial
                    ? a(t, e)
                    : e.isLineBasicMaterial
                      ? (o(t, e), e.isLineDashedMaterial && l(t, e))
                      : e.isPointsMaterial
                        ? c(t, e, n, i)
                        : e.isSpriteMaterial
                          ? h(t, e)
                          : e.isShadowMaterial
                            ? (t.color.value.copy(e.color),
                              (t.opacity.value = e.opacity))
                            : e.isShaderMaterial && (e.uniformsNeedUpdate = !1)
  }
  function a(t, e) {
    ;(t.opacity.value = e.opacity),
      e.color && t.diffuse.value.copy(e.color),
      e.emissive &&
        t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
      e.map && ((t.map.value = e.map), i(e.map, t.mapTransform)),
      e.alphaMap &&
        ((t.alphaMap.value = e.alphaMap), i(e.alphaMap, t.alphaMapTransform)),
      e.bumpMap &&
        ((t.bumpMap.value = e.bumpMap),
        i(e.bumpMap, t.bumpMapTransform),
        (t.bumpScale.value = e.bumpScale),
        1 === e.side && (t.bumpScale.value *= -1)),
      e.normalMap &&
        ((t.normalMap.value = e.normalMap),
        i(e.normalMap, t.normalMapTransform),
        t.normalScale.value.copy(e.normalScale),
        1 === e.side && t.normalScale.value.negate()),
      e.displacementMap &&
        ((t.displacementMap.value = e.displacementMap),
        i(e.displacementMap, t.displacementMapTransform),
        (t.displacementScale.value = e.displacementScale),
        (t.displacementBias.value = e.displacementBias)),
      e.emissiveMap &&
        ((t.emissiveMap.value = e.emissiveMap),
        i(e.emissiveMap, t.emissiveMapTransform)),
      e.specularMap &&
        ((t.specularMap.value = e.specularMap),
        i(e.specularMap, t.specularMapTransform)),
      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
    const s = n.get(e),
      r = s.envMap,
      a = s.envMapRotation
    r &&
      ((t.envMap.value = r),
      zc.copy(a),
      (zc.x *= -1),
      (zc.y *= -1),
      (zc.z *= -1),
      r.isCubeTexture &&
        !1 === r.isRenderTargetTexture &&
        ((zc.y *= -1), (zc.z *= -1)),
      t.envMapRotation.value.setFromMatrix4(Vc.makeRotationFromEuler(zc)),
      (t.flipEnvMap.value =
        r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1),
      (t.reflectivity.value = e.reflectivity),
      (t.ior.value = e.ior),
      (t.refractionRatio.value = e.refractionRatio)),
      e.lightMap &&
        ((t.lightMap.value = e.lightMap),
        (t.lightMapIntensity.value = e.lightMapIntensity),
        i(e.lightMap, t.lightMapTransform)),
      e.aoMap &&
        ((t.aoMap.value = e.aoMap),
        (t.aoMapIntensity.value = e.aoMapIntensity),
        i(e.aoMap, t.aoMapTransform))
  }
  function o(t, e) {
    t.diffuse.value.copy(e.color),
      (t.opacity.value = e.opacity),
      e.map && ((t.map.value = e.map), i(e.map, t.mapTransform))
  }
  function l(t, e) {
    ;(t.dashSize.value = e.dashSize),
      (t.totalSize.value = e.dashSize + e.gapSize),
      (t.scale.value = e.scale)
  }
  function c(t, e, n, s) {
    t.diffuse.value.copy(e.color),
      (t.opacity.value = e.opacity),
      (t.size.value = e.size * n),
      (t.scale.value = 0.5 * s),
      e.map && ((t.map.value = e.map), i(e.map, t.uvTransform)),
      e.alphaMap &&
        ((t.alphaMap.value = e.alphaMap), i(e.alphaMap, t.alphaMapTransform)),
      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
  }
  function h(t, e) {
    t.diffuse.value.copy(e.color),
      (t.opacity.value = e.opacity),
      (t.rotation.value = e.rotation),
      e.map && ((t.map.value = e.map), i(e.map, t.mapTransform)),
      e.alphaMap &&
        ((t.alphaMap.value = e.alphaMap), i(e.alphaMap, t.alphaMapTransform)),
      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
  }
  function u(t, e) {
    t.specular.value.copy(e.specular),
      (t.shininess.value = Math.max(e.shininess, 1e-4))
  }
  function d(t, e) {
    e.gradientMap && (t.gradientMap.value = e.gradientMap)
  }
  function p(t, e) {
    ;(t.metalness.value = e.metalness),
      e.metalnessMap &&
        ((t.metalnessMap.value = e.metalnessMap),
        i(e.metalnessMap, t.metalnessMapTransform)),
      (t.roughness.value = e.roughness),
      e.roughnessMap &&
        ((t.roughnessMap.value = e.roughnessMap),
        i(e.roughnessMap, t.roughnessMapTransform)),
      e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
  }
  function m(t, e, n) {
    ;(t.ior.value = e.ior),
      e.sheen > 0 &&
        (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),
        (t.sheenRoughness.value = e.sheenRoughness),
        e.sheenColorMap &&
          ((t.sheenColorMap.value = e.sheenColorMap),
          i(e.sheenColorMap, t.sheenColorMapTransform)),
        e.sheenRoughnessMap &&
          ((t.sheenRoughnessMap.value = e.sheenRoughnessMap),
          i(e.sheenRoughnessMap, t.sheenRoughnessMapTransform))),
      e.clearcoat > 0 &&
        ((t.clearcoat.value = e.clearcoat),
        (t.clearcoatRoughness.value = e.clearcoatRoughness),
        e.clearcoatMap &&
          ((t.clearcoatMap.value = e.clearcoatMap),
          i(e.clearcoatMap, t.clearcoatMapTransform)),
        e.clearcoatRoughnessMap &&
          ((t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
          i(e.clearcoatRoughnessMap, t.clearcoatRoughnessMapTransform)),
        e.clearcoatNormalMap &&
          ((t.clearcoatNormalMap.value = e.clearcoatNormalMap),
          i(e.clearcoatNormalMap, t.clearcoatNormalMapTransform),
          t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
          1 === e.side && t.clearcoatNormalScale.value.negate())),
      e.dispersion > 0 && (t.dispersion.value = e.dispersion),
      e.iridescence > 0 &&
        ((t.iridescence.value = e.iridescence),
        (t.iridescenceIOR.value = e.iridescenceIOR),
        (t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0]),
        (t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1]),
        e.iridescenceMap &&
          ((t.iridescenceMap.value = e.iridescenceMap),
          i(e.iridescenceMap, t.iridescenceMapTransform)),
        e.iridescenceThicknessMap &&
          ((t.iridescenceThicknessMap.value = e.iridescenceThicknessMap),
          i(e.iridescenceThicknessMap, t.iridescenceThicknessMapTransform))),
      e.transmission > 0 &&
        ((t.transmission.value = e.transmission),
        (t.transmissionSamplerMap.value = n.texture),
        t.transmissionSamplerSize.value.set(n.width, n.height),
        e.transmissionMap &&
          ((t.transmissionMap.value = e.transmissionMap),
          i(e.transmissionMap, t.transmissionMapTransform)),
        (t.thickness.value = e.thickness),
        e.thicknessMap &&
          ((t.thicknessMap.value = e.thicknessMap),
          i(e.thicknessMap, t.thicknessMapTransform)),
        (t.attenuationDistance.value = e.attenuationDistance),
        t.attenuationColor.value.copy(e.attenuationColor)),
      e.anisotropy > 0 &&
        (t.anisotropyVector.value.set(
          e.anisotropy * Math.cos(e.anisotropyRotation),
          e.anisotropy * Math.sin(e.anisotropyRotation)
        ),
        e.anisotropyMap &&
          ((t.anisotropyMap.value = e.anisotropyMap),
          i(e.anisotropyMap, t.anisotropyMapTransform))),
      (t.specularIntensity.value = e.specularIntensity),
      t.specularColor.value.copy(e.specularColor),
      e.specularColorMap &&
        ((t.specularColorMap.value = e.specularColorMap),
        i(e.specularColorMap, t.specularColorMapTransform)),
      e.specularIntensityMap &&
        ((t.specularIntensityMap.value = e.specularIntensityMap),
        i(e.specularIntensityMap, t.specularIntensityMapTransform))
  }
  function f(t, e) {
    e.matcap && (t.matcap.value = e.matcap)
  }
  function g(t, e) {
    const i = n.get(e).light
    t.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
      (t.nearDistance.value = i.shadow.camera.near),
      (t.farDistance.value = i.shadow.camera.far)
  }
  return (
    e(i, 'refreshTransformUniform'),
    e(s, 'refreshFogUniforms'),
    e(r, 'refreshMaterialUniforms'),
    e(a, 'refreshUniformsCommon'),
    e(o, 'refreshUniformsLine'),
    e(l, 'refreshUniformsDash'),
    e(c, 'refreshUniformsPoints'),
    e(h, 'refreshUniformsSprites'),
    e(u, 'refreshUniformsPhong'),
    e(d, 'refreshUniformsToon'),
    e(p, 'refreshUniformsStandard'),
    e(m, 'refreshUniformsPhysical'),
    e(f, 'refreshUniformsMatcap'),
    e(g, 'refreshUniformsDistance'),
    { refreshFogUniforms: s, refreshMaterialUniforms: r }
  )
}
function Gc(t, n, i, s) {
  let r = {},
    a = {},
    o = []
  const l = t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS)
  function c(t, e) {
    const n = e.program
    s.uniformBlockBinding(t, n)
  }
  function h(t, e) {
    let i = r[t.id]
    void 0 === i &&
      (f(t), (i = u(t)), (r[t.id] = i), t.addEventListener('dispose', v))
    const o = e.program
    s.updateUBOMapping(t, o)
    const l = n.render.frame
    a[t.id] !== l && (p(t), (a[t.id] = l))
  }
  function u(e) {
    const n = d()
    e.__bindingPointIndex = n
    const i = t.createBuffer(),
      s = e.__size,
      r = e.usage
    return (
      t.bindBuffer(t.UNIFORM_BUFFER, i),
      t.bufferData(t.UNIFORM_BUFFER, s, r),
      t.bindBuffer(t.UNIFORM_BUFFER, null),
      t.bindBufferBase(t.UNIFORM_BUFFER, n, i),
      i
    )
  }
  function d() {
    for (let t = 0; t < l; t++) if (-1 === o.indexOf(t)) return o.push(t), t
    return (
      console.error(
        'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.'
      ),
      0
    )
  }
  function p(e) {
    const n = r[e.id],
      i = e.uniforms,
      s = e.__cache
    t.bindBuffer(t.UNIFORM_BUFFER, n)
    for (let r = 0, a = i.length; r < a; r++) {
      const e = Array.isArray(i[r]) ? i[r] : [i[r]]
      for (let n = 0, i = e.length; n < i; n++) {
        const i = e[n]
        if (!0 === m(i, r, n, s)) {
          const e = i.__offset,
            n = Array.isArray(i.value) ? i.value : [i.value]
          let s = 0
          for (let r = 0; r < n.length; r++) {
            const a = n[r],
              o = g(a)
            'number' == typeof a || 'boolean' == typeof a
              ? ((i.__data[0] = a),
                t.bufferSubData(t.UNIFORM_BUFFER, e + s, i.__data))
              : a.isMatrix3
                ? ((i.__data[0] = a.elements[0]),
                  (i.__data[1] = a.elements[1]),
                  (i.__data[2] = a.elements[2]),
                  (i.__data[3] = 0),
                  (i.__data[4] = a.elements[3]),
                  (i.__data[5] = a.elements[4]),
                  (i.__data[6] = a.elements[5]),
                  (i.__data[7] = 0),
                  (i.__data[8] = a.elements[6]),
                  (i.__data[9] = a.elements[7]),
                  (i.__data[10] = a.elements[8]),
                  (i.__data[11] = 0))
                : (a.toArray(i.__data, s),
                  (s += o.storage / Float32Array.BYTES_PER_ELEMENT))
          }
          t.bufferSubData(t.UNIFORM_BUFFER, e, i.__data)
        }
      }
    }
    t.bindBuffer(t.UNIFORM_BUFFER, null)
  }
  function m(t, e, n, i) {
    const s = t.value,
      r = e + '_' + n
    if (void 0 === i[r])
      return (
        (i[r] = 'number' == typeof s || 'boolean' == typeof s ? s : s.clone()),
        !0
      )
    {
      const t = i[r]
      if ('number' == typeof s || 'boolean' == typeof s) {
        if (t !== s) return (i[r] = s), !0
      } else if (!1 === t.equals(s)) return t.copy(s), !0
    }
    return !1
  }
  function f(t) {
    const e = t.uniforms
    let n = 0
    for (let s = 0, r = e.length; s < r; s++) {
      const t = Array.isArray(e[s]) ? e[s] : [e[s]]
      for (let e = 0, i = t.length; e < i; e++) {
        const i = t[e],
          s = Array.isArray(i.value) ? i.value : [i.value]
        for (let t = 0, e = s.length; t < e; t++) {
          const e = g(s[t]),
            r = n % 16,
            a = r % e.boundary,
            o = r + a
          ;(n += a),
            0 !== o && 16 - o < e.storage && (n += 16 - o),
            (i.__data = new Float32Array(
              e.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (i.__offset = n),
            (n += e.storage)
        }
      }
    }
    const i = n % 16
    return i > 0 && (n += 16 - i), (t.__size = n), (t.__cache = {}), this
  }
  function g(t) {
    const e = { boundary: 0, storage: 0 }
    return (
      'number' == typeof t || 'boolean' == typeof t
        ? ((e.boundary = 4), (e.storage = 4))
        : t.isVector2
          ? ((e.boundary = 8), (e.storage = 8))
          : t.isVector3 || t.isColor
            ? ((e.boundary = 16), (e.storage = 12))
            : t.isVector4
              ? ((e.boundary = 16), (e.storage = 16))
              : t.isMatrix3
                ? ((e.boundary = 48), (e.storage = 48))
                : t.isMatrix4
                  ? ((e.boundary = 64), (e.storage = 64))
                  : t.isTexture
                    ? console.warn(
                        'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.'
                      )
                    : console.warn(
                        'THREE.WebGLRenderer: Unsupported uniform value type.',
                        t
                      ),
      e
    )
  }
  function v(e) {
    const n = e.target
    n.removeEventListener('dispose', v)
    const i = o.indexOf(n.__bindingPointIndex)
    o.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete a[n.id]
  }
  function y() {
    for (const e in r) t.deleteBuffer(r[e])
    ;(o = []), (r = {}), (a = {})
  }
  return (
    e(c, 'bind'),
    e(h, 'update'),
    e(u, 'createBuffer'),
    e(d, 'allocateBindingPointIndex'),
    e(p, 'updateBufferData'),
    e(m, 'hasUniformChanged'),
    e(f, 'prepareUniformsGroup'),
    e(g, 'getUniformSize'),
    e(v, 'onUniformsGroupsDispose'),
    e(y, 'dispose'),
    { bind: c, update: h, dispose: y }
  )
}
e(Hc, 'WebGLMaterials'), e(Gc, 'WebGLUniformsGroups')
class Wc {
  static {
    e(this, 'WebGLRenderer')
  }
  constructor(t = {}) {
    const {
      canvas: n = Si(),
      context: i = null,
      depth: s = !0,
      stencil: r = !1,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: h = 'default',
      failIfMajorPerformanceCaveat: u = !1,
      reverseDepthBuffer: d = !1
    } = t
    let p
    if (((this.isWebGLRenderer = !0), null !== i)) {
      if (
        'undefined' != typeof WebGLRenderingContext &&
        i instanceof WebGLRenderingContext
      )
        throw new Error(
          'THREE.WebGLRenderer: WebGL 1 is not supported since r163.'
        )
      p = i.getContextAttributes().alpha
    } else p = a
    const m = new Uint32Array(4),
      f = new Int32Array(4)
    let g = null,
      v = null
    const y = [],
      _ = []
    ;(this.domElement = n),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = En),
      (this.toneMapping = 0),
      (this.toneMappingExposure = 1)
    const x = this
    let b = !1,
      w = 0,
      M = 0,
      S = null,
      T = -1,
      E = null
    const A = new ji(),
      C = new ji()
    let R = null
    const P = new br(0)
    let I = 0,
      L = n.width,
      D = n.height,
      k = 1,
      N = null,
      U = null
    const B = new ji(0, 0, L, D),
      O = new ji(0, 0, L, D)
    let F = !1
    const z = new La()
    let V = !1,
      H = !1
    const G = new Rs(),
      W = new Rs(),
      j = new Qi(),
      X = new ji(),
      q = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
      }
    let Y = !1
    function Z() {
      return null === S ? k : 1
    }
    e(Z, 'getTargetPixelRatio')
    let K,
      $,
      J,
      Q,
      tt,
      et,
      nt,
      it,
      st,
      rt,
      at,
      ot,
      lt,
      ct,
      ht,
      ut,
      dt,
      pt,
      mt,
      ft,
      gt,
      vt,
      yt,
      _t,
      xt = i
    function bt(t, e) {
      return n.getContext(t, e)
    }
    e(bt, 'getContext')
    try {
      const t = {
        alpha: !0,
        depth: s,
        stencil: r,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: h,
        failIfMajorPerformanceCaveat: u
      }
      if (
        ('setAttribute' in n &&
          n.setAttribute('data-engine', `three.js r${Tt}`),
        n.addEventListener('webglcontextlost', St, !1),
        n.addEventListener('webglcontextrestored', Et, !1),
        n.addEventListener('webglcontextcreationerror', At, !1),
        null === xt)
      ) {
        const e = 'webgl2'
        if (((xt = bt(e, t)), null === xt))
          throw bt(e)
            ? new Error(
                'Error creating WebGL context with your selected attributes.'
              )
            : new Error('Error creating WebGL context.')
      }
    } catch (Yt) {
      throw (console.error('THREE.WebGLRenderer: ' + Yt.message), Yt)
    }
    function wt() {
      ;(K = new go(xt)),
        K.init(),
        (vt = new Dc(xt, K)),
        ($ = new ja(xt, K, t, vt)),
        (J = new Ec(xt, K)),
        $.reverseDepthBuffer && d && J.buffers.depth.setReversed(!0),
        (Q = new _o(xt)),
        (tt = new hc()),
        (et = new Lc(xt, K, J, tt, $, vt, Q)),
        (nt = new qa(x)),
        (it = new fo(x)),
        (st = new ka(xt)),
        (yt = new Ga(xt, st)),
        (rt = new vo(xt, st, Q, yt)),
        (at = new bo(xt, rt, st, Q)),
        (mt = new xo(xt, $, et)),
        (ut = new Xa(tt)),
        (ot = new cc(x, nt, it, K, $, yt, ut)),
        (lt = new Hc(x, tt)),
        (ct = new mc()),
        (ht = new bc(K)),
        (pt = new Ha(x, nt, it, J, at, p, l)),
        (dt = new Sc(x, at, $)),
        (_t = new Gc(xt, Q, $, J)),
        (ft = new Wa(xt, K, Q)),
        (gt = new yo(xt, K, Q)),
        (Q.programs = ot.programs),
        (x.capabilities = $),
        (x.extensions = K),
        (x.properties = tt),
        (x.renderLists = ct),
        (x.shadowMap = dt),
        (x.state = J),
        (x.info = Q)
    }
    e(wt, 'initGLContext'), wt()
    const Mt = new Fc(x, xt)
    function St(t) {
      t.preventDefault(),
        console.log('THREE.WebGLRenderer: Context Lost.'),
        (b = !0)
    }
    function Et() {
      console.log('THREE.WebGLRenderer: Context Restored.'), (b = !1)
      const t = Q.autoReset,
        e = dt.enabled,
        n = dt.autoUpdate,
        i = dt.needsUpdate,
        s = dt.type
      wt(),
        (Q.autoReset = t),
        (dt.enabled = e),
        (dt.autoUpdate = n),
        (dt.needsUpdate = i),
        (dt.type = s)
    }
    function At(t) {
      console.error(
        'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',
        t.statusMessage
      )
    }
    function Ct(t) {
      const e = t.target
      e.removeEventListener('dispose', Ct), Rt(e)
    }
    function Rt(t) {
      Pt(t), tt.remove(t)
    }
    function Pt(t) {
      const e = tt.get(t).programs
      void 0 !== e &&
        (e.forEach(function (t) {
          ot.releaseProgram(t)
        }),
        t.isShaderMaterial && ot.releaseShaderCache(t))
    }
    function It(t, e, n) {
      !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass
        ? ((t.side = 1),
          (t.needsUpdate = !0),
          Ht(t, e, n),
          (t.side = 0),
          (t.needsUpdate = !0),
          Ht(t, e, n),
          (t.side = 2))
        : Ht(t, e, n)
    }
    ;(this.xr = Mt),
      (this.getContext = function () {
        return xt
      }),
      (this.getContextAttributes = function () {
        return xt.getContextAttributes()
      }),
      (this.forceContextLoss = function () {
        const t = K.get('WEBGL_lose_context')
        t && t.loseContext()
      }),
      (this.forceContextRestore = function () {
        const t = K.get('WEBGL_lose_context')
        t && t.restoreContext()
      }),
      (this.getPixelRatio = function () {
        return k
      }),
      (this.setPixelRatio = function (t) {
        void 0 !== t && ((k = t), this.setSize(L, D, !1))
      }),
      (this.getSize = function (t) {
        return t.set(L, D)
      }),
      (this.setSize = function (t, e, i = !0) {
        Mt.isPresenting
          ? console.warn(
              "THREE.WebGLRenderer: Can't change size while VR device is presenting."
            )
          : ((L = t),
            (D = e),
            (n.width = Math.floor(t * k)),
            (n.height = Math.floor(e * k)),
            !0 === i &&
              ((n.style.width = t + 'px'), (n.style.height = e + 'px')),
            this.setViewport(0, 0, t, e))
      }),
      (this.getDrawingBufferSize = function (t) {
        return t.set(L * k, D * k).floor()
      }),
      (this.setDrawingBufferSize = function (t, e, i) {
        ;(L = t),
          (D = e),
          (k = i),
          (n.width = Math.floor(t * i)),
          (n.height = Math.floor(e * i)),
          this.setViewport(0, 0, t, e)
      }),
      (this.getCurrentViewport = function (t) {
        return t.copy(A)
      }),
      (this.getViewport = function (t) {
        return t.copy(B)
      }),
      (this.setViewport = function (t, e, n, i) {
        t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, n, i),
          J.viewport(A.copy(B).multiplyScalar(k).round())
      }),
      (this.getScissor = function (t) {
        return t.copy(O)
      }),
      (this.setScissor = function (t, e, n, i) {
        t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i),
          J.scissor(C.copy(O).multiplyScalar(k).round())
      }),
      (this.getScissorTest = function () {
        return F
      }),
      (this.setScissorTest = function (t) {
        J.setScissorTest((F = t))
      }),
      (this.setOpaqueSort = function (t) {
        N = t
      }),
      (this.setTransparentSort = function (t) {
        U = t
      }),
      (this.getClearColor = function (t) {
        return t.copy(pt.getClearColor())
      }),
      (this.setClearColor = function () {
        pt.setClearColor.apply(pt, arguments)
      }),
      (this.getClearAlpha = function () {
        return pt.getClearAlpha()
      }),
      (this.setClearAlpha = function () {
        pt.setClearAlpha.apply(pt, arguments)
      }),
      (this.clear = function (t = !0, e = !0, n = !0) {
        let i = 0
        if (t) {
          let t = !1
          if (null !== S) {
            const e = S.texture.format
            t = e === Oe || e === Be || e === Ue
          }
          if (t) {
            const t = S.texture.type,
              e =
                t === Me ||
                t === Ee ||
                t === Se ||
                t === Ie ||
                t === Re ||
                t === Pe,
              n = pt.getClearColor(),
              i = pt.getClearAlpha(),
              s = n.r,
              r = n.g,
              a = n.b
            e
              ? ((m[0] = s),
                (m[1] = r),
                (m[2] = a),
                (m[3] = i),
                xt.clearBufferuiv(xt.COLOR, 0, m))
              : ((f[0] = s),
                (f[1] = r),
                (f[2] = a),
                (f[3] = i),
                xt.clearBufferiv(xt.COLOR, 0, f))
          } else i |= xt.COLOR_BUFFER_BIT
        }
        e && (i |= xt.DEPTH_BUFFER_BIT),
          n &&
            ((i |= xt.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          xt.clear(i)
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1)
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1)
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0)
      }),
      (this.dispose = function () {
        n.removeEventListener('webglcontextlost', St, !1),
          n.removeEventListener('webglcontextrestored', Et, !1),
          n.removeEventListener('webglcontextcreationerror', At, !1),
          ct.dispose(),
          ht.dispose(),
          tt.dispose(),
          nt.dispose(),
          it.dispose(),
          at.dispose(),
          yt.dispose(),
          _t.dispose(),
          ot.dispose(),
          Mt.dispose(),
          Mt.removeEventListener('sessionstart', kt),
          Mt.removeEventListener('sessionend', Nt),
          Ut.stop()
      }),
      e(St, 'onContextLost'),
      e(Et, 'onContextRestore'),
      e(At, 'onContextCreationError'),
      e(Ct, 'onMaterialDispose'),
      e(Rt, 'deallocateMaterial'),
      e(Pt, 'releaseMaterialProgramReferences'),
      (this.renderBufferDirect = function (t, e, n, i, s, r) {
        null === e && (e = q)
        const a = s.isMesh && s.matrixWorld.determinant() < 0,
          o = jt(t, e, n, i, s)
        J.setMaterial(i, a)
        let l = n.index,
          c = 1
        if (!0 === i.wireframe) {
          if (((l = rt.getWireframeAttribute(n)), void 0 === l)) return
          c = 2
        }
        const h = n.drawRange,
          u = n.attributes.position
        let d = h.start * c,
          p = (h.start + h.count) * c
        null !== r &&
          ((d = Math.max(d, r.start * c)),
          (p = Math.min(p, (r.start + r.count) * c))),
          null !== l
            ? ((d = Math.max(d, 0)), (p = Math.min(p, l.count)))
            : null != u && ((d = Math.max(d, 0)), (p = Math.min(p, u.count)))
        const m = p - d
        if (m < 0 || m === 1 / 0) return
        let f
        yt.setup(s, i, o, n, l)
        let g = ft
        if (
          (null !== l && ((f = st.get(l)), (g = gt), g.setIndex(f)), s.isMesh)
        )
          !0 === i.wireframe
            ? (J.setLineWidth(i.wireframeLinewidth * Z()), g.setMode(xt.LINES))
            : g.setMode(xt.TRIANGLES)
        else if (s.isLine) {
          let t = i.linewidth
          void 0 === t && (t = 1),
            J.setLineWidth(t * Z()),
            s.isLineSegments
              ? g.setMode(xt.LINES)
              : s.isLineLoop
                ? g.setMode(xt.LINE_LOOP)
                : g.setMode(xt.LINE_STRIP)
        } else
          s.isPoints
            ? g.setMode(xt.POINTS)
            : s.isSprite && g.setMode(xt.TRIANGLES)
        if (s.isBatchedMesh)
          if (null !== s._multiDrawInstances)
            g.renderMultiDrawInstances(
              s._multiDrawStarts,
              s._multiDrawCounts,
              s._multiDrawCount,
              s._multiDrawInstances
            )
          else if (K.get('WEBGL_multi_draw'))
            g.renderMultiDraw(
              s._multiDrawStarts,
              s._multiDrawCounts,
              s._multiDrawCount
            )
          else {
            const t = s._multiDrawStarts,
              e = s._multiDrawCounts,
              n = s._multiDrawCount,
              r = l ? st.get(l).bytesPerElement : 1,
              a = tt.get(i).currentProgram.getUniforms()
            for (let i = 0; i < n; i++)
              a.setValue(xt, '_gl_DrawID', i), g.render(t[i] / r, e[i])
          }
        else if (s.isInstancedMesh) g.renderInstances(d, m, s.count)
        else if (n.isInstancedBufferGeometry) {
          const t =
              void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
            e = Math.min(n.instanceCount, t)
          g.renderInstances(d, m, e)
        } else g.render(d, m)
      }),
      e(It, 'prepareMaterial'),
      (this.compile = function (t, e, n = null) {
        null === n && (n = t),
          (v = ht.get(n)),
          v.init(e),
          _.push(v),
          n.traverseVisible(function (t) {
            t.isLight &&
              t.layers.test(e.layers) &&
              (v.pushLight(t), t.castShadow && v.pushShadow(t))
          }),
          t !== n &&
            t.traverseVisible(function (t) {
              t.isLight &&
                t.layers.test(e.layers) &&
                (v.pushLight(t), t.castShadow && v.pushShadow(t))
            }),
          v.setupLights()
        const i = new Set()
        return (
          t.traverse(function (t) {
            if (!(t.isMesh || t.isPoints || t.isLine || t.isSprite)) return
            const e = t.material
            if (e)
              if (Array.isArray(e))
                for (let s = 0; s < e.length; s++) {
                  const r = e[s]
                  It(r, n, t), i.add(r)
                }
              else It(e, n, t), i.add(e)
          }),
          _.pop(),
          (v = null),
          i
        )
      }),
      (this.compileAsync = function (t, n, i = null) {
        const s = this.compile(t, n, i)
        return new Promise((n) => {
          function i() {
            s.forEach(function (t) {
              tt.get(t).currentProgram.isReady() && s.delete(t)
            }),
              0 !== s.size ? setTimeout(i, 10) : n(t)
          }
          e(i, 'checkMaterialsReady'),
            null !== K.get('KHR_parallel_shader_compile')
              ? i()
              : setTimeout(i, 10)
        })
      })
    let Lt = null
    function Dt(t) {
      Lt && Lt(t)
    }
    function kt() {
      Ut.stop()
    }
    function Nt() {
      Ut.start()
    }
    e(Dt, 'onAnimationFrame'),
      e(kt, 'onXRSessionStart'),
      e(Nt, 'onXRSessionEnd')
    const Ut = new Da()
    function Bt(t, e, n, i) {
      if (!1 === t.visible) return
      if (t.layers.test(e.layers))
        if (t.isGroup) n = t.renderOrder
        else if (t.isLOD) !0 === t.autoUpdate && t.update(e)
        else if (t.isLight) v.pushLight(t), t.castShadow && v.pushShadow(t)
        else if (t.isSprite) {
          if (!t.frustumCulled || z.intersectsSprite(t)) {
            i && X.setFromMatrixPosition(t.matrixWorld).applyMatrix4(W)
            const e = at.update(t),
              s = t.material
            s.visible && g.push(t, e, s, n, X.z, null)
          }
        } else if (
          (t.isMesh || t.isLine || t.isPoints) &&
          (!t.frustumCulled || z.intersectsObject(t))
        ) {
          const e = at.update(t),
            s = t.material
          if (
            (i &&
              (void 0 !== t.boundingSphere
                ? (null === t.boundingSphere && t.computeBoundingSphere(),
                  X.copy(t.boundingSphere.center))
                : (null === e.boundingSphere && e.computeBoundingSphere(),
                  X.copy(e.boundingSphere.center)),
              X.applyMatrix4(t.matrixWorld).applyMatrix4(W)),
            Array.isArray(s))
          ) {
            const i = e.groups
            for (let r = 0, a = i.length; r < a; r++) {
              const a = i[r],
                o = s[a.materialIndex]
              o && o.visible && g.push(t, e, o, n, X.z, a)
            }
          } else s.visible && g.push(t, e, s, n, X.z, null)
        }
      const s = t.children
      for (let r = 0, a = s.length; r < a; r++) Bt(s[r], e, n, i)
    }
    function Ot(t, e, n, i) {
      const s = t.opaque,
        r = t.transmissive,
        a = t.transparent
      v.setupLightsView(n),
        !0 === V && ut.setGlobalState(x.clippingPlanes, n),
        i && J.viewport(A.copy(i)),
        s.length > 0 && zt(s, e, n),
        r.length > 0 && zt(r, e, n),
        a.length > 0 && zt(a, e, n),
        J.buffers.depth.setTest(!0),
        J.buffers.depth.setMask(!0),
        J.buffers.color.setMask(!0),
        J.setPolygonOffset(!1)
    }
    function Ft(t, e, n, i) {
      if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return
      void 0 === v.state.transmissionRenderTarget[i.id] &&
        (v.state.transmissionRenderTarget[i.id] = new qi(1, 1, {
          generateMipmaps: !0,
          type:
            K.has('EXT_color_buffer_half_float') ||
            K.has('EXT_color_buffer_float')
              ? Ce
              : Me,
          minFilter: we,
          samples: 4,
          stencilBuffer: r,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: Pi.workingColorSpace
        }))
      const s = v.state.transmissionRenderTarget[i.id],
        a = i.viewport || A
      s.setSize(a.z, a.w)
      const o = x.getRenderTarget()
      x.setRenderTarget(s),
        x.getClearColor(P),
        (I = x.getClearAlpha()),
        I < 1 && x.setClearColor(16777215, 0.5),
        x.clear(),
        Y && pt.render(n)
      const l = x.toneMapping
      x.toneMapping = 0
      const c = i.viewport
      if (
        (void 0 !== i.viewport && (i.viewport = void 0),
        v.setupLightsView(i),
        !0 === V && ut.setGlobalState(x.clippingPlanes, i),
        zt(t, n, i),
        et.updateMultisampleRenderTarget(s),
        et.updateRenderTargetMipmap(s),
        !1 === K.has('WEBGL_multisampled_render_to_texture'))
      ) {
        let t = !1
        for (let s = 0, r = e.length; s < r; s++) {
          const r = e[s],
            a = r.object,
            o = r.geometry,
            l = r.material,
            c = r.group
          if (2 === l.side && a.layers.test(i.layers)) {
            const e = l.side
            ;(l.side = 1),
              (l.needsUpdate = !0),
              Vt(a, n, i, o, l, c),
              (l.side = e),
              (l.needsUpdate = !0),
              (t = !0)
          }
        }
        !0 === t &&
          (et.updateMultisampleRenderTarget(s), et.updateRenderTargetMipmap(s))
      }
      x.setRenderTarget(o),
        x.setClearColor(P, I),
        void 0 !== c && (i.viewport = c),
        (x.toneMapping = l)
    }
    function zt(t, e, n) {
      const i = !0 === e.isScene ? e.overrideMaterial : null
      for (let s = 0, r = t.length; s < r; s++) {
        const r = t[s],
          a = r.object,
          o = r.geometry,
          l = null === i ? r.material : i,
          c = r.group
        a.layers.test(n.layers) && Vt(a, e, n, o, l, c)
      }
    }
    function Vt(t, e, n, i, s, r) {
      t.onBeforeRender(x, e, n, i, s, r),
        t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
        t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
        s.onBeforeRender(x, e, n, i, t, r),
        !0 === s.transparent && 2 === s.side && !1 === s.forceSinglePass
          ? ((s.side = 1),
            (s.needsUpdate = !0),
            x.renderBufferDirect(n, e, i, s, t, r),
            (s.side = 0),
            (s.needsUpdate = !0),
            x.renderBufferDirect(n, e, i, s, t, r),
            (s.side = 2))
          : x.renderBufferDirect(n, e, i, s, t, r),
        t.onAfterRender(x, e, n, i, s, r)
    }
    function Ht(t, e, n) {
      !0 !== e.isScene && (e = q)
      const i = tt.get(t),
        s = v.state.lights,
        r = v.state.shadowsArray,
        a = s.state.version,
        o = ot.getParameters(t, s.state, r, e, n),
        l = ot.getProgramCacheKey(o)
      let c = i.programs
      ;(i.environment = t.isMeshStandardMaterial ? e.environment : null),
        (i.fog = e.fog),
        (i.envMap = (t.isMeshStandardMaterial ? it : nt).get(
          t.envMap || i.environment
        )),
        (i.envMapRotation =
          null !== i.environment && null === t.envMap
            ? e.environmentRotation
            : t.envMapRotation),
        void 0 === c &&
          (t.addEventListener('dispose', Ct), (c = new Map()), (i.programs = c))
      let h = c.get(l)
      if (void 0 !== h) {
        if (i.currentProgram === h && i.lightsStateVersion === a)
          return Wt(t, o), h
      } else
        (o.uniforms = ot.getUniforms(t)),
          t.onBeforeCompile(o, x),
          (h = ot.acquireProgram(o, l)),
          c.set(l, h),
          (i.uniforms = o.uniforms)
      const u = i.uniforms
      return (
        ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
          (u.clippingPlanes = ut.uniform),
        Wt(t, o),
        (i.needsLights = qt(t)),
        (i.lightsStateVersion = a),
        i.needsLights &&
          ((u.ambientLightColor.value = s.state.ambient),
          (u.lightProbe.value = s.state.probe),
          (u.directionalLights.value = s.state.directional),
          (u.directionalLightShadows.value = s.state.directionalShadow),
          (u.spotLights.value = s.state.spot),
          (u.spotLightShadows.value = s.state.spotShadow),
          (u.rectAreaLights.value = s.state.rectArea),
          (u.ltc_1.value = s.state.rectAreaLTC1),
          (u.ltc_2.value = s.state.rectAreaLTC2),
          (u.pointLights.value = s.state.point),
          (u.pointLightShadows.value = s.state.pointShadow),
          (u.hemisphereLights.value = s.state.hemi),
          (u.directionalShadowMap.value = s.state.directionalShadowMap),
          (u.directionalShadowMatrix.value = s.state.directionalShadowMatrix),
          (u.spotShadowMap.value = s.state.spotShadowMap),
          (u.spotLightMatrix.value = s.state.spotLightMatrix),
          (u.spotLightMap.value = s.state.spotLightMap),
          (u.pointShadowMap.value = s.state.pointShadowMap),
          (u.pointShadowMatrix.value = s.state.pointShadowMatrix)),
        (i.currentProgram = h),
        (i.uniformsList = null),
        h
      )
    }
    function Gt(t) {
      if (null === t.uniformsList) {
        const e = t.currentProgram.getUniforms()
        t.uniformsList = Rl.seqWithValue(e.seq, t.uniforms)
      }
      return t.uniformsList
    }
    function Wt(t, e) {
      const n = tt.get(t)
      ;(n.outputColorSpace = e.outputColorSpace),
        (n.batching = e.batching),
        (n.batchingColor = e.batchingColor),
        (n.instancing = e.instancing),
        (n.instancingColor = e.instancingColor),
        (n.instancingMorph = e.instancingMorph),
        (n.skinning = e.skinning),
        (n.morphTargets = e.morphTargets),
        (n.morphNormals = e.morphNormals),
        (n.morphColors = e.morphColors),
        (n.morphTargetsCount = e.morphTargetsCount),
        (n.numClippingPlanes = e.numClippingPlanes),
        (n.numIntersection = e.numClipIntersection),
        (n.vertexAlphas = e.vertexAlphas),
        (n.vertexTangents = e.vertexTangents),
        (n.toneMapping = e.toneMapping)
    }
    function jt(t, e, n, i, s) {
      !0 !== e.isScene && (e = q), et.resetTextureUnits()
      const r = e.fog,
        a = i.isMeshStandardMaterial ? e.environment : null,
        o =
          null === S
            ? x.outputColorSpace
            : !0 === S.isXRRenderTarget
              ? S.texture.colorSpace
              : An,
        l = (i.isMeshStandardMaterial ? it : nt).get(i.envMap || a),
        c =
          !0 === i.vertexColors &&
          !!n.attributes.color &&
          4 === n.attributes.color.itemSize,
        h = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
        u = !!n.morphAttributes.position,
        d = !!n.morphAttributes.normal,
        p = !!n.morphAttributes.color
      let m = 0
      i.toneMapped &&
        ((null !== S && !0 !== S.isXRRenderTarget) || (m = x.toneMapping))
      const f =
          n.morphAttributes.position ||
          n.morphAttributes.normal ||
          n.morphAttributes.color,
        g = void 0 !== f ? f.length : 0,
        y = tt.get(i),
        _ = v.state.lights
      if (!0 === V && (!0 === H || t !== E)) {
        const e = t === E && i.id === T
        ut.setState(i, t, e)
      }
      let b = !1
      i.version === y.__version
        ? (y.needsLights && y.lightsStateVersion !== _.state.version) ||
          y.outputColorSpace !== o ||
          (s.isBatchedMesh && !1 === y.batching)
          ? (b = !0)
          : s.isBatchedMesh || !0 !== y.batching
            ? (s.isBatchedMesh &&
                !0 === y.batchingColor &&
                null === s.colorTexture) ||
              (s.isBatchedMesh &&
                !1 === y.batchingColor &&
                null !== s.colorTexture) ||
              (s.isInstancedMesh && !1 === y.instancing)
              ? (b = !0)
              : s.isInstancedMesh || !0 !== y.instancing
                ? s.isSkinnedMesh && !1 === y.skinning
                  ? (b = !0)
                  : s.isSkinnedMesh || !0 !== y.skinning
                    ? (s.isInstancedMesh &&
                        !0 === y.instancingColor &&
                        null === s.instanceColor) ||
                      (s.isInstancedMesh &&
                        !1 === y.instancingColor &&
                        null !== s.instanceColor) ||
                      (s.isInstancedMesh &&
                        !0 === y.instancingMorph &&
                        null === s.morphTexture) ||
                      (s.isInstancedMesh &&
                        !1 === y.instancingMorph &&
                        null !== s.morphTexture) ||
                      y.envMap !== l ||
                      (!0 === i.fog && y.fog !== r)
                      ? (b = !0)
                      : void 0 === y.numClippingPlanes ||
                          (y.numClippingPlanes === ut.numPlanes &&
                            y.numIntersection === ut.numIntersection)
                        ? (y.vertexAlphas !== c ||
                            y.vertexTangents !== h ||
                            y.morphTargets !== u ||
                            y.morphNormals !== d ||
                            y.morphColors !== p ||
                            y.toneMapping !== m ||
                            y.morphTargetsCount !== g) &&
                          (b = !0)
                        : (b = !0)
                    : (b = !0)
                : (b = !0)
            : (b = !0)
        : ((b = !0), (y.__version = i.version))
      let w = y.currentProgram
      !0 === b && (w = Ht(i, e, s))
      let M = !1,
        A = !1,
        C = !1
      const R = w.getUniforms(),
        P = y.uniforms
      if (
        (J.useProgram(w.program) && ((M = !0), (A = !0), (C = !0)),
        i.id !== T && ((T = i.id), (A = !0)),
        M || E !== t)
      ) {
        J.buffers.depth.getReversed()
          ? (G.copy(t.projectionMatrix),
            Ci(G),
            Ri(G),
            R.setValue(xt, 'projectionMatrix', G))
          : R.setValue(xt, 'projectionMatrix', t.projectionMatrix),
          R.setValue(xt, 'viewMatrix', t.matrixWorldInverse)
        const e = R.map.cameraPosition
        void 0 !== e && e.setValue(xt, j.setFromMatrixPosition(t.matrixWorld)),
          $.logarithmicDepthBuffer &&
            R.setValue(
              xt,
              'logDepthBufFC',
              2 / (Math.log(t.far + 1) / Math.LN2)
            ),
          (i.isMeshPhongMaterial ||
            i.isMeshToonMaterial ||
            i.isMeshLambertMaterial ||
            i.isMeshBasicMaterial ||
            i.isMeshStandardMaterial ||
            i.isShaderMaterial) &&
            R.setValue(xt, 'isOrthographic', !0 === t.isOrthographicCamera),
          E !== t && ((E = t), (A = !0), (C = !0))
      }
      if (s.isSkinnedMesh) {
        R.setOptional(xt, s, 'bindMatrix'),
          R.setOptional(xt, s, 'bindMatrixInverse')
        const t = s.skeleton
        t &&
          (null === t.boneTexture && t.computeBoneTexture(),
          R.setValue(xt, 'boneTexture', t.boneTexture, et))
      }
      s.isBatchedMesh &&
        (R.setOptional(xt, s, 'batchingTexture'),
        R.setValue(xt, 'batchingTexture', s._matricesTexture, et),
        R.setOptional(xt, s, 'batchingIdTexture'),
        R.setValue(xt, 'batchingIdTexture', s._indirectTexture, et),
        R.setOptional(xt, s, 'batchingColorTexture'),
        null !== s._colorsTexture &&
          R.setValue(xt, 'batchingColorTexture', s._colorsTexture, et))
      const I = n.morphAttributes
      if (
        ((void 0 === I.position && void 0 === I.normal && void 0 === I.color) ||
          mt.update(s, n, w),
        (A || y.receiveShadow !== s.receiveShadow) &&
          ((y.receiveShadow = s.receiveShadow),
          R.setValue(xt, 'receiveShadow', s.receiveShadow)),
        i.isMeshGouraudMaterial &&
          null !== i.envMap &&
          ((P.envMap.value = l),
          (P.flipEnvMap.value =
            l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1)),
        i.isMeshStandardMaterial &&
          null === i.envMap &&
          null !== e.environment &&
          (P.envMapIntensity.value = e.environmentIntensity),
        A &&
          (R.setValue(xt, 'toneMappingExposure', x.toneMappingExposure),
          y.needsLights && Xt(P, C),
          r && !0 === i.fog && lt.refreshFogUniforms(P, r),
          lt.refreshMaterialUniforms(
            P,
            i,
            k,
            D,
            v.state.transmissionRenderTarget[t.id]
          ),
          Rl.upload(xt, Gt(y), P, et)),
        i.isShaderMaterial &&
          !0 === i.uniformsNeedUpdate &&
          (Rl.upload(xt, Gt(y), P, et), (i.uniformsNeedUpdate = !1)),
        i.isSpriteMaterial && R.setValue(xt, 'center', s.center),
        R.setValue(xt, 'modelViewMatrix', s.modelViewMatrix),
        R.setValue(xt, 'normalMatrix', s.normalMatrix),
        R.setValue(xt, 'modelMatrix', s.matrixWorld),
        i.isShaderMaterial || i.isRawShaderMaterial)
      ) {
        const t = i.uniformsGroups
        for (let e = 0, n = t.length; e < n; e++) {
          const n = t[e]
          _t.update(n, w), _t.bind(n, w)
        }
      }
      return w
    }
    function Xt(t, e) {
      ;(t.ambientLightColor.needsUpdate = e),
        (t.lightProbe.needsUpdate = e),
        (t.directionalLights.needsUpdate = e),
        (t.directionalLightShadows.needsUpdate = e),
        (t.pointLights.needsUpdate = e),
        (t.pointLightShadows.needsUpdate = e),
        (t.spotLights.needsUpdate = e),
        (t.spotLightShadows.needsUpdate = e),
        (t.rectAreaLights.needsUpdate = e),
        (t.hemisphereLights.needsUpdate = e)
    }
    function qt(t) {
      return (
        t.isMeshLambertMaterial ||
        t.isMeshToonMaterial ||
        t.isMeshPhongMaterial ||
        t.isMeshStandardMaterial ||
        t.isShadowMaterial ||
        (t.isShaderMaterial && !0 === t.lights)
      )
    }
    Ut.setAnimationLoop(Dt),
      'undefined' != typeof self && Ut.setContext(self),
      (this.setAnimationLoop = function (t) {
        ;(Lt = t), Mt.setAnimationLoop(t), null === t ? Ut.stop() : Ut.start()
      }),
      Mt.addEventListener('sessionstart', kt),
      Mt.addEventListener('sessionend', Nt),
      (this.render = function (t, e) {
        if (void 0 !== e && !0 !== e.isCamera)
          return void console.error(
            'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.'
          )
        if (!0 === b) return
        if (
          (!0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
          null === e.parent &&
            !0 === e.matrixWorldAutoUpdate &&
            e.updateMatrixWorld(),
          !0 === Mt.enabled &&
            !0 === Mt.isPresenting &&
            (!0 === Mt.cameraAutoUpdate && Mt.updateCamera(e),
            (e = Mt.getCamera())),
          !0 === t.isScene && t.onBeforeRender(x, t, e, S),
          (v = ht.get(t, _.length)),
          v.init(e),
          _.push(v),
          W.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
          z.setFromProjectionMatrix(W),
          (H = this.localClippingEnabled),
          (V = ut.init(this.clippingPlanes, H)),
          (g = ct.get(t, y.length)),
          g.init(),
          y.push(g),
          !0 === Mt.enabled && !0 === Mt.isPresenting)
        ) {
          const t = x.xr.getDepthSensingMesh()
          null !== t && Bt(t, e, -1 / 0, x.sortObjects)
        }
        Bt(t, e, 0, x.sortObjects),
          g.finish(),
          !0 === x.sortObjects && g.sort(N, U),
          (Y =
            !1 === Mt.enabled ||
            !1 === Mt.isPresenting ||
            !1 === Mt.hasDepthSensing()),
          Y && pt.addToRenderList(g, t),
          this.info.render.frame++,
          !0 === V && ut.beginShadows()
        const n = v.state.shadowsArray
        dt.render(n, t, e),
          !0 === V && ut.endShadows(),
          !0 === this.info.autoReset && this.info.reset()
        const i = g.opaque,
          s = g.transmissive
        if ((v.setupLights(), e.isArrayCamera)) {
          const n = e.cameras
          if (s.length > 0)
            for (let e = 0, r = n.length; e < r; e++) {
              Ft(i, s, t, n[e])
            }
          Y && pt.render(t)
          for (let e = 0, i = n.length; e < i; e++) {
            const i = n[e]
            Ot(g, t, i, i.viewport)
          }
        } else s.length > 0 && Ft(i, s, t, e), Y && pt.render(t), Ot(g, t, e)
        null !== S &&
          (et.updateMultisampleRenderTarget(S), et.updateRenderTargetMipmap(S)),
          !0 === t.isScene && t.onAfterRender(x, t, e),
          yt.resetDefaultState(),
          (T = -1),
          (E = null),
          _.pop(),
          _.length > 0
            ? ((v = _[_.length - 1]),
              !0 === V && ut.setGlobalState(x.clippingPlanes, v.state.camera))
            : (v = null),
          y.pop(),
          (g = y.length > 0 ? y[y.length - 1] : null)
      }),
      e(Bt, 'projectObject'),
      e(Ot, 'renderScene'),
      e(Ft, 'renderTransmissionPass'),
      e(zt, 'renderObjects'),
      e(Vt, 'renderObject'),
      e(Ht, 'getProgram'),
      e(Gt, 'getUniformList'),
      e(Wt, 'updateCommonMaterialProperties'),
      e(jt, 'setProgram'),
      e(Xt, 'markUniformsLightsNeedsUpdate'),
      e(qt, 'materialNeedsLights'),
      (this.getActiveCubeFace = function () {
        return w
      }),
      (this.getActiveMipmapLevel = function () {
        return M
      }),
      (this.getRenderTarget = function () {
        return S
      }),
      (this.setRenderTargetTextures = function (t, e, n) {
        ;(tt.get(t.texture).__webglTexture = e),
          (tt.get(t.depthTexture).__webglTexture = n)
        const i = tt.get(t)
        ;(i.__hasExternalTextures = !0),
          (i.__autoAllocateDepthBuffer = void 0 === n),
          i.__autoAllocateDepthBuffer ||
            (!0 === K.has('WEBGL_multisampled_render_to_texture') &&
              (console.warn(
                'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided'
              ),
              (i.__useRenderToTexture = !1)))
      }),
      (this.setRenderTargetFramebuffer = function (t, e) {
        const n = tt.get(t)
        ;(n.__webglFramebuffer = e), (n.__useDefaultFramebuffer = void 0 === e)
      }),
      (this.setRenderTarget = function (t, e = 0, n = 0) {
        ;(S = t), (w = e), (M = n)
        let i = !0,
          s = null,
          r = !1,
          a = !1
        if (t) {
          const o = tt.get(t)
          if (void 0 !== o.__useDefaultFramebuffer)
            J.bindFramebuffer(xt.FRAMEBUFFER, null), (i = !1)
          else if (void 0 === o.__webglFramebuffer) et.setupRenderTarget(t)
          else if (o.__hasExternalTextures)
            et.rebindTextures(
              t,
              tt.get(t.texture).__webglTexture,
              tt.get(t.depthTexture).__webglTexture
            )
          else if (t.depthBuffer) {
            const e = t.depthTexture
            if (o.__boundDepthTexture !== e) {
              if (
                null !== e &&
                tt.has(e) &&
                (t.width !== e.image.width || t.height !== e.image.height)
              )
                throw new Error(
                  'WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.'
                )
              et.setupDepthRenderbuffer(t)
            }
          }
          const l = t.texture
          ;(l.isData3DTexture ||
            l.isDataArrayTexture ||
            l.isCompressedArrayTexture) &&
            (a = !0)
          const c = tt.get(t).__webglFramebuffer
          t.isWebGLCubeRenderTarget
            ? ((s = Array.isArray(c[e]) ? c[e][n] : c[e]), (r = !0))
            : (s =
                t.samples > 0 && !1 === et.useMultisampledRTT(t)
                  ? tt.get(t).__webglMultisampledFramebuffer
                  : Array.isArray(c)
                    ? c[n]
                    : c),
            A.copy(t.viewport),
            C.copy(t.scissor),
            (R = t.scissorTest)
        } else
          A.copy(B).multiplyScalar(k).floor(),
            C.copy(O).multiplyScalar(k).floor(),
            (R = F)
        if (
          (J.bindFramebuffer(xt.FRAMEBUFFER, s) && i && J.drawBuffers(t, s),
          J.viewport(A),
          J.scissor(C),
          J.setScissorTest(R),
          r)
        ) {
          const i = tt.get(t.texture)
          xt.framebufferTexture2D(
            xt.FRAMEBUFFER,
            xt.COLOR_ATTACHMENT0,
            xt.TEXTURE_CUBE_MAP_POSITIVE_X + e,
            i.__webglTexture,
            n
          )
        } else if (a) {
          const i = tt.get(t.texture),
            s = e || 0
          xt.framebufferTextureLayer(
            xt.FRAMEBUFFER,
            xt.COLOR_ATTACHMENT0,
            i.__webglTexture,
            n || 0,
            s
          )
        }
        T = -1
      }),
      (this.readRenderTargetPixels = function (t, e, n, i, s, r, a) {
        if (!t || !t.isWebGLRenderTarget)
          return void console.error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
          )
        let o = tt.get(t).__webglFramebuffer
        if ((t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
          J.bindFramebuffer(xt.FRAMEBUFFER, o)
          try {
            const a = t.texture,
              o = a.format,
              l = a.type
            if (!$.textureFormatReadable(o))
              return void console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
              )
            if (!$.textureTypeReadable(l))
              return void console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
              )
            e >= 0 &&
              e <= t.width - i &&
              n >= 0 &&
              n <= t.height - s &&
              xt.readPixels(e, n, i, s, vt.convert(o), vt.convert(l), r)
          } finally {
            const t = null !== S ? tt.get(S).__webglFramebuffer : null
            J.bindFramebuffer(xt.FRAMEBUFFER, t)
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (t, e, n, i, s, r, a) {
        if (!t || !t.isWebGLRenderTarget)
          throw new Error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
          )
        let o = tt.get(t).__webglFramebuffer
        if ((t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
          const a = t.texture,
            l = a.format,
            c = a.type
          if (!$.textureFormatReadable(l))
            throw new Error(
              'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.'
            )
          if (!$.textureTypeReadable(c))
            throw new Error(
              'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.'
            )
          if (e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - s) {
            J.bindFramebuffer(xt.FRAMEBUFFER, o)
            const t = xt.createBuffer()
            xt.bindBuffer(xt.PIXEL_PACK_BUFFER, t),
              xt.bufferData(xt.PIXEL_PACK_BUFFER, r.byteLength, xt.STREAM_READ),
              xt.readPixels(e, n, i, s, vt.convert(l), vt.convert(c), 0)
            const a = null !== S ? tt.get(S).__webglFramebuffer : null
            J.bindFramebuffer(xt.FRAMEBUFFER, a)
            const h = xt.fenceSync(xt.SYNC_GPU_COMMANDS_COMPLETE, 0)
            return (
              xt.flush(),
              await Ai(xt, h, 4),
              xt.bindBuffer(xt.PIXEL_PACK_BUFFER, t),
              xt.getBufferSubData(xt.PIXEL_PACK_BUFFER, 0, r),
              xt.deleteBuffer(t),
              xt.deleteSync(h),
              r
            )
          }
          throw new Error(
            'THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.'
          )
        }
      }),
      (this.copyFramebufferToTexture = function (t, e = null, n = 0) {
        !0 !== t.isTexture &&
          (Ei(
            'WebGLRenderer: copyFramebufferToTexture function signature has changed.'
          ),
          (e = arguments[0] || null),
          (t = arguments[1]))
        const i = Math.pow(2, -n),
          s = Math.floor(t.image.width * i),
          r = Math.floor(t.image.height * i),
          a = null !== e ? e.x : 0,
          o = null !== e ? e.y : 0
        et.setTexture2D(t, 0),
          xt.copyTexSubImage2D(xt.TEXTURE_2D, n, 0, 0, a, o, s, r),
          J.unbindTexture()
      }),
      (this.copyTextureToTexture = function (t, e, n = null, i = null, s = 0) {
        let r, a, o, l, c, h, u, d, p
        !0 !== t.isTexture &&
          (Ei(
            'WebGLRenderer: copyTextureToTexture function signature has changed.'
          ),
          (i = arguments[0] || null),
          (t = arguments[1]),
          (e = arguments[2]),
          (s = arguments[3] || 0),
          (n = null))
        const m = t.isCompressedTexture ? t.mipmaps[s] : t.image
        null !== n
          ? ((r = n.max.x - n.min.x),
            (a = n.max.y - n.min.y),
            (o = n.isBox3 ? n.max.z - n.min.z : 1),
            (l = n.min.x),
            (c = n.min.y),
            (h = n.isBox3 ? n.min.z : 0))
          : ((r = m.width),
            (a = m.height),
            (o = m.depth || 1),
            (l = 0),
            (c = 0),
            (h = 0)),
          null !== i
            ? ((u = i.x), (d = i.y), (p = i.z))
            : ((u = 0), (d = 0), (p = 0))
        const f = vt.convert(e.format),
          g = vt.convert(e.type)
        let v
        e.isData3DTexture
          ? (et.setTexture3D(e, 0), (v = xt.TEXTURE_3D))
          : e.isDataArrayTexture || e.isCompressedArrayTexture
            ? (et.setTexture2DArray(e, 0), (v = xt.TEXTURE_2D_ARRAY))
            : (et.setTexture2D(e, 0), (v = xt.TEXTURE_2D)),
          xt.pixelStorei(xt.UNPACK_FLIP_Y_WEBGL, e.flipY),
          xt.pixelStorei(xt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha),
          xt.pixelStorei(xt.UNPACK_ALIGNMENT, e.unpackAlignment)
        const y = xt.getParameter(xt.UNPACK_ROW_LENGTH),
          _ = xt.getParameter(xt.UNPACK_IMAGE_HEIGHT),
          x = xt.getParameter(xt.UNPACK_SKIP_PIXELS),
          b = xt.getParameter(xt.UNPACK_SKIP_ROWS),
          w = xt.getParameter(xt.UNPACK_SKIP_IMAGES)
        xt.pixelStorei(xt.UNPACK_ROW_LENGTH, m.width),
          xt.pixelStorei(xt.UNPACK_IMAGE_HEIGHT, m.height),
          xt.pixelStorei(xt.UNPACK_SKIP_PIXELS, l),
          xt.pixelStorei(xt.UNPACK_SKIP_ROWS, c),
          xt.pixelStorei(xt.UNPACK_SKIP_IMAGES, h)
        const M = t.isDataArrayTexture || t.isData3DTexture,
          S = e.isDataArrayTexture || e.isData3DTexture
        if (t.isRenderTargetTexture || t.isDepthTexture) {
          const n = tt.get(t),
            i = tt.get(e),
            m = tt.get(n.__renderTarget),
            f = tt.get(i.__renderTarget)
          J.bindFramebuffer(xt.READ_FRAMEBUFFER, m.__webglFramebuffer),
            J.bindFramebuffer(xt.DRAW_FRAMEBUFFER, f.__webglFramebuffer)
          for (let g = 0; g < o; g++)
            M &&
              xt.framebufferTextureLayer(
                xt.READ_FRAMEBUFFER,
                xt.COLOR_ATTACHMENT0,
                tt.get(t).__webglTexture,
                s,
                h + g
              ),
              t.isDepthTexture
                ? (S &&
                    xt.framebufferTextureLayer(
                      xt.DRAW_FRAMEBUFFER,
                      xt.COLOR_ATTACHMENT0,
                      tt.get(e).__webglTexture,
                      s,
                      p + g
                    ),
                  xt.blitFramebuffer(
                    l,
                    c,
                    r,
                    a,
                    u,
                    d,
                    r,
                    a,
                    xt.DEPTH_BUFFER_BIT,
                    xt.NEAREST
                  ))
                : S
                  ? xt.copyTexSubImage3D(v, s, u, d, p + g, l, c, r, a)
                  : xt.copyTexSubImage2D(v, s, u, d, p + g, l, c, r, a)
          J.bindFramebuffer(xt.READ_FRAMEBUFFER, null),
            J.bindFramebuffer(xt.DRAW_FRAMEBUFFER, null)
        } else
          S
            ? t.isDataTexture || t.isData3DTexture
              ? xt.texSubImage3D(v, s, u, d, p, r, a, o, f, g, m.data)
              : e.isCompressedArrayTexture
                ? xt.compressedTexSubImage3D(v, s, u, d, p, r, a, o, f, m.data)
                : xt.texSubImage3D(v, s, u, d, p, r, a, o, f, g, m)
            : t.isDataTexture
              ? xt.texSubImage2D(xt.TEXTURE_2D, s, u, d, r, a, f, g, m.data)
              : t.isCompressedTexture
                ? xt.compressedTexSubImage2D(
                    xt.TEXTURE_2D,
                    s,
                    u,
                    d,
                    m.width,
                    m.height,
                    f,
                    m.data
                  )
                : xt.texSubImage2D(xt.TEXTURE_2D, s, u, d, r, a, f, g, m)
        xt.pixelStorei(xt.UNPACK_ROW_LENGTH, y),
          xt.pixelStorei(xt.UNPACK_IMAGE_HEIGHT, _),
          xt.pixelStorei(xt.UNPACK_SKIP_PIXELS, x),
          xt.pixelStorei(xt.UNPACK_SKIP_ROWS, b),
          xt.pixelStorei(xt.UNPACK_SKIP_IMAGES, w),
          0 === s && e.generateMipmaps && xt.generateMipmap(v),
          J.unbindTexture()
      }),
      (this.copyTextureToTexture3D = function (
        t,
        e,
        n = null,
        i = null,
        s = 0
      ) {
        return (
          !0 !== t.isTexture &&
            (Ei(
              'WebGLRenderer: copyTextureToTexture3D function signature has changed.'
            ),
            (n = arguments[0] || null),
            (i = arguments[1] || null),
            (t = arguments[2]),
            (e = arguments[3]),
            (s = arguments[4] || 0)),
          Ei(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'
          ),
          this.copyTextureToTexture(t, e, n, i, s)
        )
      }),
      (this.initRenderTarget = function (t) {
        void 0 === tt.get(t).__webglFramebuffer && et.setupRenderTarget(t)
      }),
      (this.initTexture = function (t) {
        t.isCubeTexture
          ? et.setTextureCube(t, 0)
          : t.isData3DTexture
            ? et.setTexture3D(t, 0)
            : t.isDataArrayTexture || t.isCompressedArrayTexture
              ? et.setTexture2DArray(t, 0)
              : et.setTexture2D(t, 0),
          J.unbindTexture()
      }),
      (this.resetState = function () {
        ;(w = 0), (M = 0), (S = null), J.reset(), yt.reset()
      }),
      'undefined' != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent('observe', { detail: this })
        )
  }
  get coordinateSystem() {
    return Vn
  }
  get outputColorSpace() {
    return this._outputColorSpace
  }
  set outputColorSpace(t) {
    this._outputColorSpace = t
    const e = this.getContext()
    ;(e.drawingBufferColorspace = Pi._getDrawingBufferColorSpace(t)),
      (e.unpackColorSpace = Pi._getUnpackColorSpace())
  }
}
class jc {
  static {
    e(this, 'FogExp2')
  }
  constructor(t, e = 25e-5) {
    ;(this.isFogExp2 = !0),
      (this.name = ''),
      (this.color = new br(t)),
      (this.density = e)
  }
  clone() {
    return new jc(this.color, this.density)
  }
  toJSON() {
    return {
      type: 'FogExp2',
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    }
  }
}
class Xc {
  static {
    e(this, 'Fog')
  }
  constructor(t, e = 1, n = 1e3) {
    ;(this.isFog = !0),
      (this.name = ''),
      (this.color = new br(t)),
      (this.near = e),
      (this.far = n)
  }
  clone() {
    return new Xc(this.color, this.near, this.far)
  }
  toJSON() {
    return {
      type: 'Fog',
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    }
  }
}
class qc extends nr {
  static {
    e(this, 'Scene')
  }
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = 'Scene'),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Fs()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Fs()),
      (this.overrideMaterial = null),
      'undefined' != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent('observe', { detail: this })
        )
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      null !== t.background && (this.background = t.background.clone()),
      null !== t.environment && (this.environment = t.environment.clone()),
      null !== t.fog && (this.fog = t.fog.clone()),
      (this.backgroundBlurriness = t.backgroundBlurriness),
      (this.backgroundIntensity = t.backgroundIntensity),
      this.backgroundRotation.copy(t.backgroundRotation),
      (this.environmentIntensity = t.environmentIntensity),
      this.environmentRotation.copy(t.environmentRotation),
      null !== t.overrideMaterial &&
        (this.overrideMaterial = t.overrideMaterial.clone()),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this
    )
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      null !== this.fog && (e.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (e.object.backgroundBlurriness = this.backgroundBlurriness),
      1 !== this.backgroundIntensity &&
        (e.object.backgroundIntensity = this.backgroundIntensity),
      (e.object.backgroundRotation = this.backgroundRotation.toArray()),
      1 !== this.environmentIntensity &&
        (e.object.environmentIntensity = this.environmentIntensity),
      (e.object.environmentRotation = this.environmentRotation.toArray()),
      e
    )
  }
}
class Yc {
  static {
    e(this, 'InterleavedBuffer')
  }
  constructor(t, e) {
    ;(this.isInterleavedBuffer = !0),
      (this.array = t),
      (this.stride = e),
      (this.count = void 0 !== t ? t.length / e : 0),
      (this.usage = Fn),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = Yn())
  }
  onUploadCallback() {}
  set needsUpdate(t) {
    !0 === t && this.version++
  }
  setUsage(t) {
    return (this.usage = t), this
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({ start: t, count: e })
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0
  }
  copy(t) {
    return (
      (this.array = new t.array.constructor(t.array)),
      (this.count = t.count),
      (this.stride = t.stride),
      (this.usage = t.usage),
      this
    )
  }
  copyAt(t, e, n) {
    ;(t *= this.stride), (n *= e.stride)
    for (let i = 0, s = this.stride; i < s; i++)
      this.array[t + i] = e.array[n + i]
    return this
  }
  set(t, e = 0) {
    return this.array.set(t, e), this
  }
  clone(t) {
    void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
      void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Yn()),
      void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
        (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer)
    const e = new this.array.constructor(
        t.arrayBuffers[this.array.buffer._uuid]
      ),
      n = new this.constructor(e, this.stride)
    return n.setUsage(this.usage), n
  }
  onUpload(t) {
    return (this.onUploadCallback = t), this
  }
  toJSON(t) {
    return (
      void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
      void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Yn()),
      void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
        (t.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      }
    )
  }
}
const Zc = new Qi()
class Kc {
  static {
    e(this, 'InterleavedBufferAttribute')
  }
  constructor(t, e, n, i = !1) {
    ;(this.isInterleavedBufferAttribute = !0),
      (this.name = ''),
      (this.data = t),
      (this.itemSize = e),
      (this.offset = n),
      (this.normalized = i)
  }
  get count() {
    return this.data.count
  }
  get array() {
    return this.data.array
  }
  set needsUpdate(t) {
    this.data.needsUpdate = t
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.data.count; e < n; e++)
      Zc.fromBufferAttribute(this, e),
        Zc.applyMatrix4(t),
        this.setXYZ(e, Zc.x, Zc.y, Zc.z)
    return this
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      Zc.fromBufferAttribute(this, e),
        Zc.applyNormalMatrix(t),
        this.setXYZ(e, Zc.x, Zc.y, Zc.z)
    return this
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      Zc.fromBufferAttribute(this, e),
        Zc.transformDirection(t),
        this.setXYZ(e, Zc.x, Zc.y, Zc.z)
    return this
  }
  getComponent(t, e) {
    let n = this.array[t * this.data.stride + this.offset + e]
    return this.normalized && (n = mi(n, this.array)), n
  }
  setComponent(t, e, n) {
    return (
      this.normalized && (n = fi(n, this.array)),
      (this.data.array[t * this.data.stride + this.offset + e] = n),
      this
    )
  }
  setX(t, e) {
    return (
      this.normalized && (e = fi(e, this.array)),
      (this.data.array[t * this.data.stride + this.offset] = e),
      this
    )
  }
  setY(t, e) {
    return (
      this.normalized && (e = fi(e, this.array)),
      (this.data.array[t * this.data.stride + this.offset + 1] = e),
      this
    )
  }
  setZ(t, e) {
    return (
      this.normalized && (e = fi(e, this.array)),
      (this.data.array[t * this.data.stride + this.offset + 2] = e),
      this
    )
  }
  setW(t, e) {
    return (
      this.normalized && (e = fi(e, this.array)),
      (this.data.array[t * this.data.stride + this.offset + 3] = e),
      this
    )
  }
  getX(t) {
    let e = this.data.array[t * this.data.stride + this.offset]
    return this.normalized && (e = mi(e, this.array)), e
  }
  getY(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 1]
    return this.normalized && (e = mi(e, this.array)), e
  }
  getZ(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 2]
    return this.normalized && (e = mi(e, this.array)), e
  }
  getW(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 3]
    return this.normalized && (e = mi(e, this.array)), e
  }
  setXY(t, e, n) {
    return (
      (t = t * this.data.stride + this.offset),
      this.normalized && ((e = fi(e, this.array)), (n = fi(n, this.array))),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      this
    )
  }
  setXYZ(t, e, n, i) {
    return (
      (t = t * this.data.stride + this.offset),
      this.normalized &&
        ((e = fi(e, this.array)),
        (n = fi(n, this.array)),
        (i = fi(i, this.array))),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      (this.data.array[t + 2] = i),
      this
    )
  }
  setXYZW(t, e, n, i, s) {
    return (
      (t = t * this.data.stride + this.offset),
      this.normalized &&
        ((e = fi(e, this.array)),
        (n = fi(n, this.array)),
        (i = fi(i, this.array)),
        (s = fi(s, this.array))),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      (this.data.array[t + 2] = i),
      (this.data.array[t + 3] = s),
      this
    )
  }
  clone(t) {
    if (void 0 === t) {
      console.log(
        'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.'
      )
      const t = []
      for (let e = 0; e < this.count; e++) {
        const n = e * this.data.stride + this.offset
        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
      }
      return new Lr(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      )
    }
    return (
      void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
      void 0 === t.interleavedBuffers[this.data.uuid] &&
        (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
      new Kc(
        t.interleavedBuffers[this.data.uuid],
        this.itemSize,
        this.offset,
        this.normalized
      )
    )
  }
  toJSON(t) {
    if (void 0 === t) {
      console.log(
        'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.'
      )
      const t = []
      for (let e = 0; e < this.count; e++) {
        const n = e * this.data.stride + this.offset
        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      }
    }
    return (
      void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
      void 0 === t.interleavedBuffers[this.data.uuid] &&
        (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
      {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      }
    )
  }
}
class $c extends Sr {
  static {
    e(this, 'SpriteMaterial')
  }
  static get type() {
    return 'SpriteMaterial'
  }
  constructor(t) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.color = new br(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.rotation = t.rotation),
      (this.sizeAttenuation = t.sizeAttenuation),
      (this.fog = t.fog),
      this
    )
  }
}
let Jc
const Qc = new Qi(),
  th = new Qi(),
  eh = new Qi(),
  nh = new vi(),
  ih = new vi(),
  sh = new Rs(),
  rh = new Qi(),
  ah = new Qi(),
  oh = new Qi(),
  lh = new vi(),
  ch = new vi(),
  hh = new vi()
class uh extends nr {
  static {
    e(this, 'Sprite')
  }
  constructor(t = new $c()) {
    if (
      (super(), (this.isSprite = !0), (this.type = 'Sprite'), void 0 === Jc)
    ) {
      Jc = new Zr()
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1
        ]),
        e = new Yc(t, 5)
      Jc.setIndex([0, 1, 2, 0, 2, 3]),
        Jc.setAttribute('position', new Kc(e, 3, 0, !1)),
        Jc.setAttribute('uv', new Kc(e, 2, 3, !1))
    }
    ;(this.geometry = Jc), (this.material = t), (this.center = new vi(0.5, 0.5))
  }
  raycast(t, e) {
    null === t.camera &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      th.setFromMatrixScale(this.matrixWorld),
      sh.copy(t.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        t.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      eh.setFromMatrixPosition(this.modelViewMatrix),
      t.camera.isPerspectiveCamera &&
        !1 === this.material.sizeAttenuation &&
        th.multiplyScalar(-eh.z)
    const n = this.material.rotation
    let i, s
    0 !== n && ((s = Math.cos(n)), (i = Math.sin(n)))
    const r = this.center
    dh(rh.set(-0.5, -0.5, 0), eh, r, th, i, s),
      dh(ah.set(0.5, -0.5, 0), eh, r, th, i, s),
      dh(oh.set(0.5, 0.5, 0), eh, r, th, i, s),
      lh.set(0, 0),
      ch.set(1, 0),
      hh.set(1, 1)
    let a = t.ray.intersectTriangle(rh, ah, oh, !1, Qc)
    if (
      null === a &&
      (dh(ah.set(-0.5, 0.5, 0), eh, r, th, i, s),
      ch.set(0, 1),
      (a = t.ray.intersectTriangle(rh, oh, ah, !1, Qc)),
      null === a)
    )
      return
    const o = t.ray.origin.distanceTo(Qc)
    o < t.near ||
      o > t.far ||
      e.push({
        distance: o,
        point: Qc.clone(),
        uv: gr.getInterpolation(Qc, rh, ah, oh, lh, ch, hh, new vi()),
        face: null,
        object: this
      })
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      void 0 !== t.center && this.center.copy(t.center),
      (this.material = t.material),
      this
    )
  }
}
function dh(t, e, n, i, s, r) {
  nh.subVectors(t, n).addScalar(0.5).multiply(i),
    void 0 !== s
      ? ((ih.x = r * nh.x - s * nh.y), (ih.y = s * nh.x + r * nh.y))
      : ih.copy(nh),
    t.copy(e),
    (t.x += ih.x),
    (t.y += ih.y),
    t.applyMatrix4(sh)
}
e(dh, 'transformVertex')
const ph = new Qi(),
  mh = new Qi()
class fh extends nr {
  static {
    e(this, 'LOD')
  }
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = 'LOD'),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 }
      }),
      (this.autoUpdate = !0)
  }
  copy(t) {
    super.copy(t, !1)
    const e = t.levels
    for (let n = 0, i = e.length; n < i; n++) {
      const t = e[n]
      this.addLevel(t.object.clone(), t.distance, t.hysteresis)
    }
    return (this.autoUpdate = t.autoUpdate), this
  }
  addLevel(t, e = 0, n = 0) {
    e = Math.abs(e)
    const i = this.levels
    let s
    for (s = 0; s < i.length && !(e < i[s].distance); s++);
    return (
      i.splice(s, 0, { distance: e, hysteresis: n, object: t }),
      this.add(t),
      this
    )
  }
  removeLevel(t) {
    const e = this.levels
    for (let n = 0; n < e.length; n++)
      if (e[n].distance === t) {
        const t = e.splice(n, 1)
        return this.remove(t[0].object), !0
      }
    return !1
  }
  getCurrentLevel() {
    return this._currentLevel
  }
  getObjectForDistance(t) {
    const e = this.levels
    if (e.length > 0) {
      let n, i
      for (n = 1, i = e.length; n < i; n++) {
        let i = e[n].distance
        if ((e[n].object.visible && (i -= i * e[n].hysteresis), t < i)) break
      }
      return e[n - 1].object
    }
    return null
  }
  raycast(t, e) {
    if (this.levels.length > 0) {
      ph.setFromMatrixPosition(this.matrixWorld)
      const n = t.ray.origin.distanceTo(ph)
      this.getObjectForDistance(n).raycast(t, e)
    }
  }
  update(t) {
    const e = this.levels
    if (e.length > 1) {
      ph.setFromMatrixPosition(t.matrixWorld),
        mh.setFromMatrixPosition(this.matrixWorld)
      const n = ph.distanceTo(mh) / t.zoom
      let i, s
      for (e[0].object.visible = !0, i = 1, s = e.length; i < s; i++) {
        let t = e[i].distance
        if ((e[i].object.visible && (t -= t * e[i].hysteresis), !(n >= t)))
          break
        ;(e[i - 1].object.visible = !1), (e[i].object.visible = !0)
      }
      for (this._currentLevel = i - 1; i < s; i++) e[i].object.visible = !1
    }
  }
  toJSON(t) {
    const e = super.toJSON(t)
    !1 === this.autoUpdate && (e.object.autoUpdate = !1), (e.object.levels = [])
    const n = this.levels
    for (let i = 0, s = n.length; i < s; i++) {
      const t = n[i]
      e.object.levels.push({
        object: t.object.uuid,
        distance: t.distance,
        hysteresis: t.hysteresis
      })
    }
    return e
  }
}
const gh = new Qi(),
  vh = new ji(),
  yh = new ji(),
  _h = new Qi(),
  xh = new Rs(),
  bh = new Qi(),
  wh = new xs(),
  Mh = new Rs(),
  Sh = new Cs()
class Th extends oa {
  static {
    e(this, 'SkinnedMesh')
  }
  constructor(t, e) {
    super(t, e),
      (this.isSkinnedMesh = !0),
      (this.type = 'SkinnedMesh'),
      (this.bindMode = le),
      (this.bindMatrix = new Rs()),
      (this.bindMatrixInverse = new Rs()),
      (this.boundingBox = null),
      (this.boundingSphere = null)
  }
  computeBoundingBox() {
    const t = this.geometry
    null === this.boundingBox && (this.boundingBox = new ns()),
      this.boundingBox.makeEmpty()
    const e = t.getAttribute('position')
    for (let n = 0; n < e.count; n++)
      this.getVertexPosition(n, bh), this.boundingBox.expandByPoint(bh)
  }
  computeBoundingSphere() {
    const t = this.geometry
    null === this.boundingSphere && (this.boundingSphere = new xs()),
      this.boundingSphere.makeEmpty()
    const e = t.getAttribute('position')
    for (let n = 0; n < e.count; n++)
      this.getVertexPosition(n, bh), this.boundingSphere.expandByPoint(bh)
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.bindMode = t.bindMode),
      this.bindMatrix.copy(t.bindMatrix),
      this.bindMatrixInverse.copy(t.bindMatrixInverse),
      (this.skeleton = t.skeleton),
      null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
      null !== t.boundingSphere &&
        (this.boundingSphere = t.boundingSphere.clone()),
      this
    )
  }
  raycast(t, e) {
    const n = this.material,
      i = this.matrixWorld
    void 0 !== n &&
      (null === this.boundingSphere && this.computeBoundingSphere(),
      wh.copy(this.boundingSphere),
      wh.applyMatrix4(i),
      !1 !== t.ray.intersectsSphere(wh) &&
        (Mh.copy(i).invert(),
        Sh.copy(t.ray).applyMatrix4(Mh),
        (null !== this.boundingBox &&
          !1 === Sh.intersectsBox(this.boundingBox)) ||
          this._computeIntersections(t, e, Sh)))
  }
  getVertexPosition(t, e) {
    return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e
  }
  bind(t, e) {
    ;(this.skeleton = t),
      void 0 === e &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (e = this.matrixWorld)),
      this.bindMatrix.copy(e),
      this.bindMatrixInverse.copy(e).invert()
  }
  pose() {
    this.skeleton.pose()
  }
  normalizeSkinWeights() {
    const t = new ji(),
      e = this.geometry.attributes.skinWeight
    for (let n = 0, i = e.count; n < i; n++) {
      t.fromBufferAttribute(e, n)
      const i = 1 / t.manhattanLength()
      i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
        e.setXYZW(n, t.x, t.y, t.z, t.w)
    }
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t),
      this.bindMode === le
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : 'detached' === this.bindMode
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn(
              'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode
            )
  }
  applyBoneTransform(t, e) {
    const n = this.skeleton,
      i = this.geometry
    vh.fromBufferAttribute(i.attributes.skinIndex, t),
      yh.fromBufferAttribute(i.attributes.skinWeight, t),
      gh.copy(e).applyMatrix4(this.bindMatrix),
      e.set(0, 0, 0)
    for (let s = 0; s < 4; s++) {
      const t = yh.getComponent(s)
      if (0 !== t) {
        const i = vh.getComponent(s)
        xh.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]),
          e.addScaledVector(_h.copy(gh).applyMatrix4(xh), t)
      }
    }
    return e.applyMatrix4(this.bindMatrixInverse)
  }
}
class Eh extends nr {
  static {
    e(this, 'Bone')
  }
  constructor() {
    super(), (this.isBone = !0), (this.type = 'Bone')
  }
}
class Ah extends Wi {
  static {
    e(this, 'DataTexture')
  }
  constructor(t = null, e = 1, n = 1, i, s, r, a, o, l = 1003, c = 1003, h, u) {
    super(null, r, a, o, l, c, i, s, h, u),
      (this.isDataTexture = !0),
      (this.image = { data: t, width: e, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
const Ch = new Rs(),
  Rh = new Rs()
class Ph {
  static {
    e(this, 'Skeleton')
  }
  constructor(t = [], e = []) {
    ;(this.uuid = Yn()),
      (this.bones = t.slice(0)),
      (this.boneInverses = e),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init()
  }
  init() {
    const t = this.bones,
      e = this.boneInverses
    if (((this.boneMatrices = new Float32Array(16 * t.length)), 0 === e.length))
      this.calculateInverses()
    else if (t.length !== e.length) {
      console.warn(
        'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.'
      ),
        (this.boneInverses = [])
      for (let t = 0, e = this.bones.length; t < e; t++)
        this.boneInverses.push(new Rs())
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const e = new Rs()
      this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
        this.boneInverses.push(e)
    }
  }
  pose() {
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const e = this.bones[t]
      e && e.matrixWorld.copy(this.boneInverses[t]).invert()
    }
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const e = this.bones[t]
      e &&
        (e.parent && e.parent.isBone
          ? (e.matrix.copy(e.parent.matrixWorld).invert(),
            e.matrix.multiply(e.matrixWorld))
          : e.matrix.copy(e.matrixWorld),
        e.matrix.decompose(e.position, e.quaternion, e.scale))
    }
  }
  update() {
    const t = this.bones,
      e = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture
    for (let s = 0, r = t.length; s < r; s++) {
      const i = t[s] ? t[s].matrixWorld : Rh
      Ch.multiplyMatrices(i, e[s]), Ch.toArray(n, 16 * s)
    }
    null !== i && (i.needsUpdate = !0)
  }
  clone() {
    return new Ph(this.bones, this.boneInverses)
  }
  computeBoneTexture() {
    let t = Math.sqrt(4 * this.bones.length)
    ;(t = 4 * Math.ceil(t / 4)), (t = Math.max(t, 4))
    const e = new Float32Array(t * t * 4)
    e.set(this.boneMatrices)
    const n = new Ah(e, t, t, Le, Ae)
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = e),
      (this.boneTexture = n),
      this
    )
  }
  getBoneByName(t) {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const n = this.bones[e]
      if (n.name === t) return n
    }
  }
  dispose() {
    null !== this.boneTexture &&
      (this.boneTexture.dispose(), (this.boneTexture = null))
  }
  fromJSON(t, e) {
    this.uuid = t.uuid
    for (let n = 0, i = t.bones.length; n < i; n++) {
      const i = t.bones[n]
      let s = e[i]
      void 0 === s &&
        (console.warn('THREE.Skeleton: No bone found with UUID:', i),
        (s = new Eh())),
        this.bones.push(s),
        this.boneInverses.push(new Rs().fromArray(t.boneInverses[n]))
    }
    return this.init(), this
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: 'Skeleton',
        generator: 'Skeleton.toJSON'
      },
      bones: [],
      boneInverses: []
    }
    t.uuid = this.uuid
    const e = this.bones,
      n = this.boneInverses
    for (let i = 0, s = e.length; i < s; i++) {
      const s = e[i]
      t.bones.push(s.uuid)
      const r = n[i]
      t.boneInverses.push(r.toArray())
    }
    return t
  }
}
class Ih extends Lr {
  static {
    e(this, 'InstancedBufferAttribute')
  }
  constructor(t, e, n, i = 1) {
    super(t, e, n),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i)
  }
  copy(t) {
    return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.meshPerAttribute = this.meshPerAttribute),
      (t.isInstancedBufferAttribute = !0),
      t
    )
  }
}
const Lh = new Rs(),
  Dh = new Rs(),
  kh = [],
  Nh = new ns(),
  Uh = new Rs(),
  Bh = new oa(),
  Oh = new xs()
class Fh extends oa {
  static {
    e(this, 'InstancedMesh')
  }
  constructor(t, e, n) {
    super(t, e),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Ih(new Float32Array(16 * n), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = n),
      (this.boundingBox = null),
      (this.boundingSphere = null)
    for (let i = 0; i < n; i++) this.setMatrixAt(i, Uh)
  }
  computeBoundingBox() {
    const t = this.geometry,
      e = this.count
    null === this.boundingBox && (this.boundingBox = new ns()),
      null === t.boundingBox && t.computeBoundingBox(),
      this.boundingBox.makeEmpty()
    for (let n = 0; n < e; n++)
      this.getMatrixAt(n, Lh),
        Nh.copy(t.boundingBox).applyMatrix4(Lh),
        this.boundingBox.union(Nh)
  }
  computeBoundingSphere() {
    const t = this.geometry,
      e = this.count
    null === this.boundingSphere && (this.boundingSphere = new xs()),
      null === t.boundingSphere && t.computeBoundingSphere(),
      this.boundingSphere.makeEmpty()
    for (let n = 0; n < e; n++)
      this.getMatrixAt(n, Lh),
        Oh.copy(t.boundingSphere).applyMatrix4(Lh),
        this.boundingSphere.union(Oh)
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      this.instanceMatrix.copy(t.instanceMatrix),
      null !== t.morphTexture && (this.morphTexture = t.morphTexture.clone()),
      null !== t.instanceColor &&
        (this.instanceColor = t.instanceColor.clone()),
      (this.count = t.count),
      null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
      null !== t.boundingSphere &&
        (this.boundingSphere = t.boundingSphere.clone()),
      this
    )
  }
  getColorAt(t, e) {
    e.fromArray(this.instanceColor.array, 3 * t)
  }
  getMatrixAt(t, e) {
    e.fromArray(this.instanceMatrix.array, 16 * t)
  }
  getMorphAt(t, e) {
    const n = e.morphTargetInfluences,
      i = this.morphTexture.source.data.data,
      s = t * (n.length + 1) + 1
    for (let r = 0; r < n.length; r++) n[r] = i[s + r]
  }
  raycast(t, e) {
    const n = this.matrixWorld,
      i = this.count
    if (
      ((Bh.geometry = this.geometry),
      (Bh.material = this.material),
      void 0 !== Bh.material &&
        (null === this.boundingSphere && this.computeBoundingSphere(),
        Oh.copy(this.boundingSphere),
        Oh.applyMatrix4(n),
        !1 !== t.ray.intersectsSphere(Oh)))
    )
      for (let s = 0; s < i; s++) {
        this.getMatrixAt(s, Lh),
          Dh.multiplyMatrices(n, Lh),
          (Bh.matrixWorld = Dh),
          Bh.raycast(t, kh)
        for (let t = 0, n = kh.length; t < n; t++) {
          const n = kh[t]
          ;(n.instanceId = s), (n.object = this), e.push(n)
        }
        kh.length = 0
      }
  }
  setColorAt(t, e) {
    null === this.instanceColor &&
      (this.instanceColor = new Ih(
        new Float32Array(3 * this.instanceMatrix.count).fill(1),
        3
      )),
      e.toArray(this.instanceColor.array, 3 * t)
  }
  setMatrixAt(t, e) {
    e.toArray(this.instanceMatrix.array, 16 * t)
  }
  setMorphAt(t, e) {
    const n = e.morphTargetInfluences,
      i = n.length + 1
    null === this.morphTexture &&
      (this.morphTexture = new Ah(
        new Float32Array(i * this.count),
        i,
        this.count,
        Ne,
        Ae
      ))
    const s = this.morphTexture.source.data.data
    let r = 0
    for (let l = 0; l < n.length; l++) r += n[l]
    const a = this.geometry.morphTargetsRelative ? 1 : 1 - r,
      o = i * t
    ;(s[o] = a), s.set(n, o + 1)
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: 'dispose' }),
      null !== this.morphTexture &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    )
  }
}
function zh(t, e) {
  return t - e
}
function Vh(t, e) {
  return t.z - e.z
}
function Hh(t, e) {
  return e.z - t.z
}
e(zh, 'ascIdSort'), e(Vh, 'sortOpaque'), e(Hh, 'sortTransparent')
class Gh {
  static {
    e(this, 'MultiDrawRenderList')
  }
  constructor() {
    ;(this.index = 0), (this.pool = []), (this.list = [])
  }
  push(t, e, n, i) {
    const s = this.pool,
      r = this.list
    this.index >= s.length && s.push({ start: -1, count: -1, z: -1, index: -1 })
    const a = s[this.index]
    r.push(a),
      this.index++,
      (a.start = t),
      (a.count = e),
      (a.z = n),
      (a.index = i)
  }
  reset() {
    ;(this.list.length = 0), (this.index = 0)
  }
}
const Wh = new Rs(),
  jh = new br(1, 1, 1),
  Xh = new La(),
  qh = new ns(),
  Yh = new xs(),
  Zh = new Qi(),
  Kh = new Qi(),
  $h = new Qi(),
  Jh = new Gh(),
  Qh = new oa(),
  tu = []
function eu(t, e, n = 0) {
  const i = e.itemSize
  if (
    t.isInterleavedBufferAttribute ||
    t.array.constructor !== e.array.constructor
  ) {
    const s = t.count
    for (let r = 0; r < s; r++)
      for (let s = 0; s < i; s++) e.setComponent(r + n, s, t.getComponent(r, s))
  } else e.array.set(t.array, n * i)
  e.needsUpdate = !0
}
function nu(t, e) {
  if (t.constructor !== e.constructor) {
    const n = Math.min(t.length, e.length)
    for (let i = 0; i < n; i++) e[i] = t[i]
  } else {
    const n = Math.min(t.length, e.length)
    e.set(new t.constructor(t.buffer, 0, n))
  }
}
e(eu, 'copyAttributeData'), e(nu, 'copyArrayContents')
class iu extends oa {
  static {
    e(this, 'BatchedMesh')
  }
  get maxInstanceCount() {
    return this._maxInstanceCount
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart
  }
  constructor(t, e, n = 2 * e, i) {
    super(new Zr(), i),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._instanceInfo = []),
      (this._geometryInfo = []),
      (this._availableInstanceIds = []),
      (this._availableGeometryIds = []),
      (this._nextIndexStart = 0),
      (this._nextVertexStart = 0),
      (this._geometryCount = 0),
      (this._visibilityChanged = !0),
      (this._geometryInitialized = !1),
      (this._maxInstanceCount = t),
      (this._maxVertexCount = e),
      (this._maxIndexCount = n),
      (this._multiDrawCounts = new Int32Array(t)),
      (this._multiDrawStarts = new Int32Array(t)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture()
  }
  _initMatricesTexture() {
    let t = Math.sqrt(4 * this._maxInstanceCount)
    ;(t = 4 * Math.ceil(t / 4)), (t = Math.max(t, 4))
    const e = new Float32Array(t * t * 4),
      n = new Ah(e, t, t, Le, Ae)
    this._matricesTexture = n
  }
  _initIndirectTexture() {
    let t = Math.sqrt(this._maxInstanceCount)
    t = Math.ceil(t)
    const e = new Uint32Array(t * t),
      n = new Ah(e, t, t, Ue, Ee)
    this._indirectTexture = n
  }
  _initColorsTexture() {
    let t = Math.sqrt(this._maxInstanceCount)
    t = Math.ceil(t)
    const e = new Float32Array(t * t * 4).fill(1),
      n = new Ah(e, t, t, Le, Ae)
    ;(n.colorSpace = Pi.workingColorSpace), (this._colorsTexture = n)
  }
  _initializeGeometry(t) {
    const e = this.geometry,
      n = this._maxVertexCount,
      i = this._maxIndexCount
    if (!1 === this._geometryInitialized) {
      for (const i in t.attributes) {
        const s = t.getAttribute(i),
          { array: r, itemSize: a, normalized: o } = s,
          l = new r.constructor(n * a),
          c = new Lr(l, a, o)
        e.setAttribute(i, c)
      }
      if (null !== t.getIndex()) {
        const t = n > 65535 ? new Uint32Array(i) : new Uint16Array(i)
        e.setIndex(new Lr(t, 1))
      }
      this._geometryInitialized = !0
    }
  }
  _validateGeometry(t) {
    const e = this.geometry
    if (Boolean(t.getIndex()) !== Boolean(e.getIndex()))
      throw new Error(
        'BatchedMesh: All geometries must consistently have "index".'
      )
    for (const n in e.attributes) {
      if (!t.hasAttribute(n))
        throw new Error(
          `BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`
        )
      const i = t.getAttribute(n),
        s = e.getAttribute(n)
      if (i.itemSize !== s.itemSize || i.normalized !== s.normalized)
        throw new Error(
          'BatchedMesh: All attributes must have a consistent itemSize and normalized value.'
        )
    }
  }
  setCustomSort(t) {
    return (this.customSort = t), this
  }
  computeBoundingBox() {
    null === this.boundingBox && (this.boundingBox = new ns())
    const t = this.boundingBox,
      e = this._instanceInfo
    t.makeEmpty()
    for (let n = 0, i = e.length; n < i; n++) {
      if (!1 === e[n].active) continue
      const i = e[n].geometryIndex
      this.getMatrixAt(n, Wh),
        this.getBoundingBoxAt(i, qh).applyMatrix4(Wh),
        t.union(qh)
    }
  }
  computeBoundingSphere() {
    null === this.boundingSphere && (this.boundingSphere = new xs())
    const t = this.boundingSphere,
      e = this._instanceInfo
    t.makeEmpty()
    for (let n = 0, i = e.length; n < i; n++) {
      if (!1 === e[n].active) continue
      const i = e[n].geometryIndex
      this.getMatrixAt(n, Wh),
        this.getBoundingSphereAt(i, Yh).applyMatrix4(Wh),
        t.union(Yh)
    }
  }
  addInstance(t) {
    if (
      this._instanceInfo.length >= this.maxInstanceCount &&
      0 === this._availableInstanceIds.length
    )
      throw new Error('BatchedMesh: Maximum item count reached.')
    const e = { visible: !0, active: !0, geometryIndex: t }
    let n = null
    this._availableInstanceIds.length > 0
      ? (this._availableInstanceIds.sort(zh),
        (n = this._availableInstanceIds.shift()),
        (this._instanceInfo[n] = e))
      : ((n = this._instanceInfo.length), this._instanceInfo.push(e))
    const i = this._matricesTexture
    Wh.identity().toArray(i.image.data, 16 * n), (i.needsUpdate = !0)
    const s = this._colorsTexture
    return (
      s && (jh.toArray(s.image.data, 4 * n), (s.needsUpdate = !0)),
      (this._visibilityChanged = !0),
      n
    )
  }
  addGeometry(t, e = -1, n = -1) {
    this._initializeGeometry(t), this._validateGeometry(t)
    const i = {
        vertexStart: -1,
        vertexCount: -1,
        reservedVertexCount: -1,
        indexStart: -1,
        indexCount: -1,
        reservedIndexCount: -1,
        start: -1,
        count: -1,
        boundingBox: null,
        boundingSphere: null,
        active: !0
      },
      s = this._geometryInfo
    ;(i.vertexStart = this._nextVertexStart),
      (i.reservedVertexCount = -1 === e ? t.getAttribute('position').count : e)
    const r = t.getIndex()
    if (
      (null !== r &&
        ((i.indexStart = this._nextIndexStart),
        (i.reservedIndexCount = -1 === n ? r.count : n)),
      (-1 !== i.indexStart &&
        i.indexStart + i.reservedIndexCount > this._maxIndexCount) ||
        i.vertexStart + i.reservedVertexCount > this._maxVertexCount)
    )
      throw new Error(
        'BatchedMesh: Reserved space request exceeds the maximum buffer size.'
      )
    let a
    return (
      this._availableGeometryIds.length > 0
        ? (this._availableGeometryIds.sort(zh),
          (a = this._availableGeometryIds.shift()),
          (s[a] = i))
        : ((a = this._geometryCount), this._geometryCount++, s.push(i)),
      this.setGeometryAt(a, t),
      (this._nextIndexStart = i.indexStart + i.reservedIndexCount),
      (this._nextVertexStart = i.vertexStart + i.reservedVertexCount),
      a
    )
  }
  setGeometryAt(t, e) {
    if (t >= this._geometryCount)
      throw new Error('BatchedMesh: Maximum geometry count reached.')
    this._validateGeometry(e)
    const n = this.geometry,
      i = null !== n.getIndex(),
      s = n.getIndex(),
      r = e.getIndex(),
      a = this._geometryInfo[t]
    if (
      (i && r.count > a.reservedIndexCount) ||
      e.attributes.position.count > a.reservedVertexCount
    )
      throw new Error(
        'BatchedMesh: Reserved space not large enough for provided geometry.'
      )
    const o = a.vertexStart,
      l = a.reservedVertexCount
    a.vertexCount = e.getAttribute('position').count
    for (const c in n.attributes) {
      const t = e.getAttribute(c),
        i = n.getAttribute(c)
      eu(t, i, o)
      const s = t.itemSize
      for (let e = t.count, n = l; e < n; e++) {
        const t = o + e
        for (let e = 0; e < s; e++) i.setComponent(t, e, 0)
      }
      ;(i.needsUpdate = !0), i.addUpdateRange(o * s, l * s)
    }
    if (i) {
      const t = a.indexStart,
        n = a.reservedIndexCount
      a.indexCount = e.getIndex().count
      for (let e = 0; e < r.count; e++) s.setX(t + e, o + r.getX(e))
      for (let e = r.count, i = n; e < i; e++) s.setX(t + e, o)
      ;(s.needsUpdate = !0), s.addUpdateRange(t, a.reservedIndexCount)
    }
    return (
      (a.start = i ? a.indexStart : a.vertexStart),
      (a.count = i ? a.indexCount : a.vertexCount),
      (a.boundingBox = null),
      null !== e.boundingBox && (a.boundingBox = e.boundingBox.clone()),
      (a.boundingSphere = null),
      null !== e.boundingSphere &&
        (a.boundingSphere = e.boundingSphere.clone()),
      (this._visibilityChanged = !0),
      t
    )
  }
  deleteGeometry(t) {
    const e = this._geometryInfo
    if (t >= e.length || !1 === e[t].active) return this
    const n = this._instanceInfo
    for (let i = 0, s = n.length; i < s; i++)
      n[i].geometryIndex === t && this.deleteInstance(i)
    return (
      (e[t].active = !1),
      this._availableGeometryIds.push(t),
      (this._visibilityChanged = !0),
      this
    )
  }
  deleteInstance(t) {
    const e = this._instanceInfo
    return (
      t >= e.length ||
        !1 === e[t].active ||
        ((e[t].active = !1),
        this._availableInstanceIds.push(t),
        (this._visibilityChanged = !0)),
      this
    )
  }
  optimize() {
    let t = 0,
      e = 0
    const n = this._geometryInfo,
      i = n
        .map((t, e) => e)
        .sort((t, e) => n[t].vertexStart - n[e].vertexStart),
      s = this.geometry
    for (let r = 0, a = n.length; r < a; r++) {
      const a = i[r],
        o = n[a]
      if (!1 !== o.active) {
        if (null !== s.index) {
          if (o.indexStart !== e) {
            const { indexStart: n, vertexStart: i, reservedIndexCount: r } = o,
              a = s.index,
              l = a.array,
              c = t - i
            for (let t = n; t < n + r; t++) l[t] = l[t] + c
            a.array.copyWithin(e, n, n + r),
              a.addUpdateRange(e, r),
              (o.indexStart = e)
          }
          e += o.reservedIndexCount
        }
        if (o.vertexStart !== t) {
          const { vertexStart: e, reservedVertexCount: n } = o,
            i = s.attributes
          for (const s in i) {
            const r = i[s],
              { array: a, itemSize: o } = r
            a.copyWithin(t * o, e * o, (e + n) * o),
              r.addUpdateRange(t * o, n * o)
          }
          o.vertexStart = t
        }
        ;(t += o.reservedVertexCount),
          (o.start = s.index ? o.indexStart : o.vertexStart),
          (this._nextIndexStart = s.index
            ? o.indexStart + o.reservedIndexCount
            : 0),
          (this._nextVertexStart = o.vertexStart + o.reservedVertexCount)
      }
    }
    return this
  }
  getBoundingBoxAt(t, e) {
    if (t >= this._geometryCount) return null
    const n = this.geometry,
      i = this._geometryInfo[t]
    if (null === i.boundingBox) {
      const t = new ns(),
        e = n.index,
        s = n.attributes.position
      for (let n = i.start, r = i.start + i.count; n < r; n++) {
        let i = n
        e && (i = e.getX(i)), t.expandByPoint(Zh.fromBufferAttribute(s, i))
      }
      i.boundingBox = t
    }
    return e.copy(i.boundingBox), e
  }
  getBoundingSphereAt(t, e) {
    if (t >= this._geometryCount) return null
    const n = this.geometry,
      i = this._geometryInfo[t]
    if (null === i.boundingSphere) {
      const e = new xs()
      this.getBoundingBoxAt(t, qh), qh.getCenter(e.center)
      const s = n.index,
        r = n.attributes.position
      let a = 0
      for (let t = i.start, n = i.start + i.count; t < n; t++) {
        let n = t
        s && (n = s.getX(n)),
          Zh.fromBufferAttribute(r, n),
          (a = Math.max(a, e.center.distanceToSquared(Zh)))
      }
      ;(e.radius = Math.sqrt(a)), (i.boundingSphere = e)
    }
    return e.copy(i.boundingSphere), e
  }
  setMatrixAt(t, e) {
    const n = this._instanceInfo,
      i = this._matricesTexture,
      s = this._matricesTexture.image.data
    return (
      t >= n.length ||
        !1 === n[t].active ||
        (e.toArray(s, 16 * t), (i.needsUpdate = !0)),
      this
    )
  }
  getMatrixAt(t, e) {
    const n = this._instanceInfo,
      i = this._matricesTexture.image.data
    return t >= n.length || !1 === n[t].active ? null : e.fromArray(i, 16 * t)
  }
  setColorAt(t, e) {
    null === this._colorsTexture && this._initColorsTexture()
    const n = this._colorsTexture,
      i = this._colorsTexture.image.data,
      s = this._instanceInfo
    return (
      t >= s.length ||
        !1 === s[t].active ||
        (e.toArray(i, 4 * t), (n.needsUpdate = !0)),
      this
    )
  }
  getColorAt(t, e) {
    const n = this._colorsTexture.image.data,
      i = this._instanceInfo
    return t >= i.length || !1 === i[t].active ? null : e.fromArray(n, 4 * t)
  }
  setVisibleAt(t, e) {
    const n = this._instanceInfo
    return (
      t >= n.length ||
        !1 === n[t].active ||
        n[t].visible === e ||
        ((n[t].visible = e), (this._visibilityChanged = !0)),
      this
    )
  }
  getVisibleAt(t) {
    const e = this._instanceInfo
    return !(t >= e.length || !1 === e[t].active) && e[t].visible
  }
  setGeometryIdAt(t, e) {
    const n = this._instanceInfo,
      i = this._geometryInfo
    return t >= n.length ||
      !1 === n[t].active ||
      e >= i.length ||
      !1 === i[e].active
      ? null
      : ((n[t].geometryIndex = e), this)
  }
  getGeometryIdAt(t) {
    const e = this._instanceInfo
    return t >= e.length || !1 === e[t].active ? -1 : e[t].geometryIndex
  }
  getGeometryRangeAt(t, e = {}) {
    if (t < 0 || t >= this._geometryCount) return null
    const n = this._geometryInfo[t]
    return (
      (e.vertexStart = n.vertexStart),
      (e.vertexCount = n.vertexCount),
      (e.reservedVertexCount = n.reservedVertexCount),
      (e.indexStart = n.indexStart),
      (e.indexCount = n.indexCount),
      (e.reservedIndexCount = n.reservedIndexCount),
      (e.start = n.start),
      (e.count = n.count),
      e
    )
  }
  setInstanceCount(t) {
    const e = this._availableInstanceIds,
      n = this._instanceInfo
    for (e.sort(zh); e[e.length - 1] === n.length; ) n.pop(), e.pop()
    if (t < n.length)
      throw new Error(
        `BatchedMesh: Instance ids outside the range ${t} are being used. Cannot shrink instance count.`
      )
    const i = new Int32Array(t),
      s = new Int32Array(t)
    nu(this._multiDrawCounts, i),
      nu(this._multiDrawStarts, s),
      (this._multiDrawCounts = i),
      (this._multiDrawStarts = s),
      (this._maxInstanceCount = t)
    const r = this._indirectTexture,
      a = this._matricesTexture,
      o = this._colorsTexture
    r.dispose(),
      this._initIndirectTexture(),
      nu(r.image.data, this._indirectTexture.image.data),
      a.dispose(),
      this._initMatricesTexture(),
      nu(a.image.data, this._matricesTexture.image.data),
      o &&
        (o.dispose(),
        this._initColorsTexture(),
        nu(o.image.data, this._colorsTexture.image.data))
  }
  setGeometrySize(t, e) {
    const n = [...this._geometryInfo].filter((t) => t.active)
    if (Math.max(...n.map((t) => t.vertexStart + t.reservedVertexCount)) > t)
      throw new Error(
        `BatchedMesh: Geometry vertex values are being used outside the range ${e}. Cannot shrink further.`
      )
    if (this.geometry.index) {
      if (Math.max(...n.map((t) => t.indexStart + t.reservedIndexCount)) > e)
        throw new Error(
          `BatchedMesh: Geometry index values are being used outside the range ${e}. Cannot shrink further.`
        )
    }
    const i = this.geometry
    i.dispose(),
      (this._maxVertexCount = t),
      (this._maxIndexCount = e),
      this._geometryInitialized &&
        ((this._geometryInitialized = !1),
        (this.geometry = new Zr()),
        this._initializeGeometry(i))
    const s = this.geometry
    i.index && nu(i.index.array, s.index.array)
    for (const r in i.attributes)
      nu(i.attributes[r].array, s.attributes[r].array)
  }
  raycast(t, e) {
    const n = this._instanceInfo,
      i = this._geometryInfo,
      s = this.matrixWorld,
      r = this.geometry
    ;(Qh.material = this.material),
      (Qh.geometry.index = r.index),
      (Qh.geometry.attributes = r.attributes),
      null === Qh.geometry.boundingBox && (Qh.geometry.boundingBox = new ns()),
      null === Qh.geometry.boundingSphere &&
        (Qh.geometry.boundingSphere = new xs())
    for (let a = 0, o = n.length; a < o; a++) {
      if (!n[a].visible || !n[a].active) continue
      const r = n[a].geometryIndex,
        o = i[r]
      Qh.geometry.setDrawRange(o.start, o.count),
        this.getMatrixAt(a, Qh.matrixWorld).premultiply(s),
        this.getBoundingBoxAt(r, Qh.geometry.boundingBox),
        this.getBoundingSphereAt(r, Qh.geometry.boundingSphere),
        Qh.raycast(t, tu)
      for (let t = 0, n = tu.length; t < n; t++) {
        const n = tu[t]
        ;(n.object = this), (n.batchId = a), e.push(n)
      }
      tu.length = 0
    }
    ;(Qh.material = null),
      (Qh.geometry.index = null),
      (Qh.geometry.attributes = {}),
      Qh.geometry.setDrawRange(0, 1 / 0)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.geometry = t.geometry.clone()),
      (this.perObjectFrustumCulled = t.perObjectFrustumCulled),
      (this.sortObjects = t.sortObjects),
      (this.boundingBox =
        null !== t.boundingBox ? t.boundingBox.clone() : null),
      (this.boundingSphere =
        null !== t.boundingSphere ? t.boundingSphere.clone() : null),
      (this._geometryInfo = t._geometryInfo.map((t) => ({
        ...t,
        boundingBox: null !== t.boundingBox ? t.boundingBox.clone() : null,
        boundingSphere:
          null !== t.boundingSphere ? t.boundingSphere.clone() : null
      }))),
      (this._instanceInfo = t._instanceInfo.map((t) => ({ ...t }))),
      (this._maxInstanceCount = t._maxInstanceCount),
      (this._maxVertexCount = t._maxVertexCount),
      (this._maxIndexCount = t._maxIndexCount),
      (this._geometryInitialized = t._geometryInitialized),
      (this._geometryCount = t._geometryCount),
      (this._multiDrawCounts = t._multiDrawCounts.slice()),
      (this._multiDrawStarts = t._multiDrawStarts.slice()),
      (this._matricesTexture = t._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      null !== this._colorsTexture &&
        ((this._colorsTexture = t._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    )
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      null !== this._colorsTexture &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null)),
      this
    )
  }
  onBeforeRender(t, e, n, i, s) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return
    const r = i.getIndex(),
      a = null === r ? 1 : r.array.BYTES_PER_ELEMENT,
      o = this._instanceInfo,
      l = this._multiDrawStarts,
      c = this._multiDrawCounts,
      h = this._geometryInfo,
      u = this.perObjectFrustumCulled,
      d = this._indirectTexture,
      p = d.image.data
    u &&
      (Wh.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(
        this.matrixWorld
      ),
      Xh.setFromProjectionMatrix(Wh, t.coordinateSystem))
    let m = 0
    if (this.sortObjects) {
      Wh.copy(this.matrixWorld).invert(),
        Zh.setFromMatrixPosition(n.matrixWorld).applyMatrix4(Wh),
        Kh.set(0, 0, -1)
          .transformDirection(n.matrixWorld)
          .transformDirection(Wh)
      for (let n = 0, i = o.length; n < i; n++)
        if (o[n].visible && o[n].active) {
          const t = o[n].geometryIndex
          this.getMatrixAt(n, Wh),
            this.getBoundingSphereAt(t, Yh).applyMatrix4(Wh)
          let e = !1
          if ((u && (e = !Xh.intersectsSphere(Yh)), !e)) {
            const e = h[t],
              i = $h.subVectors(Yh.center, Zh).dot(Kh)
            Jh.push(e.start, e.count, i, n)
          }
        }
      const t = Jh.list,
        e = this.customSort
      null === e ? t.sort(s.transparent ? Hh : Vh) : e.call(this, t, n)
      for (let n = 0, i = t.length; n < i; n++) {
        const e = t[n]
        ;(l[m] = e.start * a), (c[m] = e.count), (p[m] = e.index), m++
      }
      Jh.reset()
    } else
      for (let f = 0, g = o.length; f < g; f++)
        if (o[f].visible && o[f].active) {
          const t = o[f].geometryIndex
          let e = !1
          if (
            (u &&
              (this.getMatrixAt(f, Wh),
              this.getBoundingSphereAt(t, Yh).applyMatrix4(Wh),
              (e = !Xh.intersectsSphere(Yh))),
            !e)
          ) {
            const e = h[t]
            ;(l[m] = e.start * a), (c[m] = e.count), (p[m] = f), m++
          }
        }
    ;(d.needsUpdate = !0),
      (this._multiDrawCount = m),
      (this._visibilityChanged = !1)
  }
  onBeforeShadow(t, e, n, i, s, r) {
    this.onBeforeRender(t, null, i, s, r)
  }
}
class su extends Sr {
  static {
    e(this, 'LineBasicMaterial')
  }
  static get type() {
    return 'LineBasicMaterial'
  }
  constructor(t) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.color = new br(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = 'round'),
      (this.linejoin = 'round'),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.linewidth = t.linewidth),
      (this.linecap = t.linecap),
      (this.linejoin = t.linejoin),
      (this.fog = t.fog),
      this
    )
  }
}
const ru = new Qi(),
  au = new Qi(),
  ou = new Rs(),
  lu = new Cs(),
  cu = new xs(),
  hu = new Qi(),
  uu = new Qi()
class du extends nr {
  static {
    e(this, 'Line')
  }
  constructor(t = new Zr(), e = new su()) {
    super(),
      (this.isLine = !0),
      (this.type = 'Line'),
      (this.geometry = t),
      (this.material = e),
      this.updateMorphTargets()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.material = Array.isArray(t.material)
        ? t.material.slice()
        : t.material),
      (this.geometry = t.geometry),
      this
    )
  }
  computeLineDistances() {
    const t = this.geometry
    if (null === t.index) {
      const e = t.attributes.position,
        n = [0]
      for (let t = 1, i = e.count; t < i; t++)
        ru.fromBufferAttribute(e, t - 1),
          au.fromBufferAttribute(e, t),
          (n[t] = n[t - 1]),
          (n[t] += ru.distanceTo(au))
      t.setAttribute('lineDistance', new Vr(n, 1))
    } else
      console.warn(
        'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
      )
    return this
  }
  raycast(t, e) {
    const n = this.geometry,
      i = this.matrixWorld,
      s = t.params.Line.threshold,
      r = n.drawRange
    if (
      (null === n.boundingSphere && n.computeBoundingSphere(),
      cu.copy(n.boundingSphere),
      cu.applyMatrix4(i),
      (cu.radius += s),
      !1 === t.ray.intersectsSphere(cu))
    )
      return
    ou.copy(i).invert(), lu.copy(t.ray).applyMatrix4(ou)
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      o = a * a,
      l = this.isLineSegments ? 2 : 1,
      c = n.index,
      h = n.attributes.position
    if (null !== c) {
      const n = Math.max(0, r.start),
        i = Math.min(c.count, r.start + r.count)
      for (let s = n, r = i - 1; s < r; s += l) {
        const n = c.getX(s),
          i = c.getX(s + 1),
          r = pu(this, t, lu, o, n, i)
        r && e.push(r)
      }
      if (this.isLineLoop) {
        const s = c.getX(i - 1),
          r = c.getX(n),
          a = pu(this, t, lu, o, s, r)
        a && e.push(a)
      }
    } else {
      const n = Math.max(0, r.start),
        i = Math.min(h.count, r.start + r.count)
      for (let s = n, r = i - 1; s < r; s += l) {
        const n = pu(this, t, lu, o, s, s + 1)
        n && e.push(n)
      }
      if (this.isLineLoop) {
        const s = pu(this, t, lu, o, i - 1, n)
        s && e.push(s)
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      e = Object.keys(t)
    if (e.length > 0) {
      const n = t[e[0]]
      if (void 0 !== n) {
        ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
        for (let t = 0, e = n.length; t < e; t++) {
          const e = n[t].name || String(t)
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[e] = t)
        }
      }
    }
  }
}
function pu(t, e, n, i, s, r) {
  const a = t.geometry.attributes.position
  ru.fromBufferAttribute(a, s), au.fromBufferAttribute(a, r)
  if (n.distanceSqToSegment(ru, au, hu, uu) > i) return
  hu.applyMatrix4(t.matrixWorld)
  const o = e.ray.origin.distanceTo(hu)
  return o < e.near || o > e.far
    ? void 0
    : {
        distance: o,
        point: uu.clone().applyMatrix4(t.matrixWorld),
        index: s,
        face: null,
        faceIndex: null,
        barycoord: null,
        object: t
      }
}
e(pu, 'checkIntersection')
const mu = new Qi(),
  fu = new Qi()
class gu extends du {
  static {
    e(this, 'LineSegments')
  }
  constructor(t, e) {
    super(t, e), (this.isLineSegments = !0), (this.type = 'LineSegments')
  }
  computeLineDistances() {
    const t = this.geometry
    if (null === t.index) {
      const e = t.attributes.position,
        n = []
      for (let t = 0, i = e.count; t < i; t += 2)
        mu.fromBufferAttribute(e, t),
          fu.fromBufferAttribute(e, t + 1),
          (n[t] = 0 === t ? 0 : n[t - 1]),
          (n[t + 1] = n[t] + mu.distanceTo(fu))
      t.setAttribute('lineDistance', new Vr(n, 1))
    } else
      console.warn(
        'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
      )
    return this
  }
}
class vu extends du {
  static {
    e(this, 'LineLoop')
  }
  constructor(t, e) {
    super(t, e), (this.isLineLoop = !0), (this.type = 'LineLoop')
  }
}
class yu extends Sr {
  static {
    e(this, 'PointsMaterial')
  }
  static get type() {
    return 'PointsMaterial'
  }
  constructor(t) {
    super(),
      (this.isPointsMaterial = !0),
      (this.color = new br(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.size = t.size),
      (this.sizeAttenuation = t.sizeAttenuation),
      (this.fog = t.fog),
      this
    )
  }
}
const _u = new Rs(),
  xu = new Cs(),
  bu = new xs(),
  wu = new Qi()
class Mu extends nr {
  static {
    e(this, 'Points')
  }
  constructor(t = new Zr(), e = new yu()) {
    super(),
      (this.isPoints = !0),
      (this.type = 'Points'),
      (this.geometry = t),
      (this.material = e),
      this.updateMorphTargets()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.material = Array.isArray(t.material)
        ? t.material.slice()
        : t.material),
      (this.geometry = t.geometry),
      this
    )
  }
  raycast(t, e) {
    const n = this.geometry,
      i = this.matrixWorld,
      s = t.params.Points.threshold,
      r = n.drawRange
    if (
      (null === n.boundingSphere && n.computeBoundingSphere(),
      bu.copy(n.boundingSphere),
      bu.applyMatrix4(i),
      (bu.radius += s),
      !1 === t.ray.intersectsSphere(bu))
    )
      return
    _u.copy(i).invert(), xu.copy(t.ray).applyMatrix4(_u)
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      o = a * a,
      l = n.index,
      c = n.attributes.position
    if (null !== l) {
      for (
        let n = Math.max(0, r.start), s = Math.min(l.count, r.start + r.count);
        n < s;
        n++
      ) {
        const s = l.getX(n)
        wu.fromBufferAttribute(c, s), Su(wu, s, o, i, t, e, this)
      }
    } else {
      for (
        let n = Math.max(0, r.start), s = Math.min(c.count, r.start + r.count);
        n < s;
        n++
      )
        wu.fromBufferAttribute(c, n), Su(wu, n, o, i, t, e, this)
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      e = Object.keys(t)
    if (e.length > 0) {
      const n = t[e[0]]
      if (void 0 !== n) {
        ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
        for (let t = 0, e = n.length; t < e; t++) {
          const e = n[t].name || String(t)
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[e] = t)
        }
      }
    }
  }
}
function Su(t, e, n, i, s, r, a) {
  const o = xu.distanceSqToPoint(t)
  if (o < n) {
    const n = new Qi()
    xu.closestPointToPoint(t, n), n.applyMatrix4(i)
    const l = s.ray.origin.distanceTo(n)
    if (l < s.near || l > s.far) return
    r.push({
      distance: l,
      distanceToRay: Math.sqrt(o),
      point: n,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: a
    })
  }
}
e(Su, 'testPoint')
class Tu extends Wi {
  static {
    e(this, 'VideoTexture')
  }
  constructor(t, n, i, s, r, a, o, l, c) {
    super(t, n, i, s, r, a, o, l, c),
      (this.isVideoTexture = !0),
      (this.minFilter = void 0 !== a ? a : xe),
      (this.magFilter = void 0 !== r ? r : xe),
      (this.generateMipmaps = !1)
    const h = this
    function u() {
      ;(h.needsUpdate = !0), t.requestVideoFrameCallback(u)
    }
    e(u, 'updateVideo'),
      'requestVideoFrameCallback' in t && t.requestVideoFrameCallback(u)
  }
  clone() {
    return new this.constructor(this.image).copy(this)
  }
  update() {
    const t = this.image
    !1 === 'requestVideoFrameCallback' in t &&
      t.readyState >= t.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0)
  }
}
class Eu extends Wi {
  static {
    e(this, 'FramebufferTexture')
  }
  constructor(t, e) {
    super({ width: t, height: e }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = ve),
      (this.minFilter = ve),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0)
  }
}
class Au extends Wi {
  static {
    e(this, 'CompressedTexture')
  }
  constructor(t, e, n, i, s, r, a, o, l, c, h, u) {
    super(null, r, a, o, l, c, i, s, h, u),
      (this.isCompressedTexture = !0),
      (this.image = { width: e, height: n }),
      (this.mipmaps = t),
      (this.flipY = !1),
      (this.generateMipmaps = !1)
  }
}
class Cu extends Au {
  static {
    e(this, 'CompressedArrayTexture')
  }
  constructor(t, e, n, i, s, r) {
    super(t, e, n, s, r),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = fe),
      (this.layerUpdates = new Set())
  }
  addLayerUpdate(t) {
    this.layerUpdates.add(t)
  }
  clearLayerUpdates() {
    this.layerUpdates.clear()
  }
}
class Ru extends Au {
  static {
    e(this, 'CompressedCubeTexture')
  }
  constructor(t, e, n) {
    super(void 0, t[0].width, t[0].height, e, n, ce),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = t)
  }
}
class Pu extends Wi {
  static {
    e(this, 'CanvasTexture')
  }
  constructor(t, e, n, i, s, r, a, o, l) {
    super(t, e, n, i, s, r, a, o, l),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0)
  }
}
class Iu {
  static {
    e(this, 'Curve')
  }
  constructor() {
    ;(this.type = 'Curve'), (this.arcLengthDivisions = 200)
  }
  getPoint() {
    return console.warn('THREE.Curve: .getPoint() not implemented.'), null
  }
  getPointAt(t, e) {
    const n = this.getUtoTmapping(t)
    return this.getPoint(n, e)
  }
  getPoints(t = 5) {
    const e = []
    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t))
    return e
  }
  getSpacedPoints(t = 5) {
    const e = []
    for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t))
    return e
  }
  getLength() {
    const t = this.getLengths()
    return t[t.length - 1]
  }
  getLengths(t = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === t + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths
    this.needsUpdate = !1
    const e = []
    let n,
      i = this.getPoint(0),
      s = 0
    e.push(0)
    for (let r = 1; r <= t; r++)
      (n = this.getPoint(r / t)), (s += n.distanceTo(i)), e.push(s), (i = n)
    return (this.cacheArcLengths = e), e
  }
  updateArcLengths() {
    ;(this.needsUpdate = !0), this.getLengths()
  }
  getUtoTmapping(t, e) {
    const n = this.getLengths()
    let i = 0
    const s = n.length
    let r
    r = e || t * n[s - 1]
    let a,
      o = 0,
      l = s - 1
    for (; o <= l; )
      if (((i = Math.floor(o + (l - o) / 2)), (a = n[i] - r), a < 0)) o = i + 1
      else {
        if (!(a > 0)) {
          l = i
          break
        }
        l = i - 1
      }
    if (((i = l), n[i] === r)) return i / (s - 1)
    const c = n[i]
    return (i + (r - c) / (n[i + 1] - c)) / (s - 1)
  }
  getTangent(t, e) {
    const n = 1e-4
    let i = t - n,
      s = t + n
    i < 0 && (i = 0), s > 1 && (s = 1)
    const r = this.getPoint(i),
      a = this.getPoint(s),
      o = e || (r.isVector2 ? new vi() : new Qi())
    return o.copy(a).sub(r).normalize(), o
  }
  getTangentAt(t, e) {
    const n = this.getUtoTmapping(t)
    return this.getTangent(n, e)
  }
  computeFrenetFrames(t, e) {
    const n = new Qi(),
      i = [],
      s = [],
      r = [],
      a = new Qi(),
      o = new Rs()
    for (let d = 0; d <= t; d++) {
      const e = d / t
      i[d] = this.getTangentAt(e, new Qi())
    }
    ;(s[0] = new Qi()), (r[0] = new Qi())
    let l = Number.MAX_VALUE
    const c = Math.abs(i[0].x),
      h = Math.abs(i[0].y),
      u = Math.abs(i[0].z)
    c <= l && ((l = c), n.set(1, 0, 0)),
      h <= l && ((l = h), n.set(0, 1, 0)),
      u <= l && n.set(0, 0, 1),
      a.crossVectors(i[0], n).normalize(),
      s[0].crossVectors(i[0], a),
      r[0].crossVectors(i[0], s[0])
    for (let d = 1; d <= t; d++) {
      if (
        ((s[d] = s[d - 1].clone()),
        (r[d] = r[d - 1].clone()),
        a.crossVectors(i[d - 1], i[d]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize()
        const t = Math.acos(Zn(i[d - 1].dot(i[d]), -1, 1))
        s[d].applyMatrix4(o.makeRotationAxis(a, t))
      }
      r[d].crossVectors(i[d], s[d])
    }
    if (!0 === e) {
      let e = Math.acos(Zn(s[0].dot(s[t]), -1, 1))
      ;(e /= t), i[0].dot(a.crossVectors(s[0], s[t])) > 0 && (e = -e)
      for (let n = 1; n <= t; n++)
        s[n].applyMatrix4(o.makeRotationAxis(i[n], e * n)),
          r[n].crossVectors(i[n], s[n])
    }
    return { tangents: i, normals: s, binormals: r }
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this
  }
  toJSON() {
    const t = {
      metadata: { version: 4.6, type: 'Curve', generator: 'Curve.toJSON' }
    }
    return (
      (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t
    )
  }
  fromJSON(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this
  }
}
class Lu extends Iu {
  static {
    e(this, 'EllipseCurve')
  }
  constructor(
    t = 0,
    e = 0,
    n = 1,
    i = 1,
    s = 0,
    r = 2 * Math.PI,
    a = !1,
    o = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = 'EllipseCurve'),
      (this.aX = t),
      (this.aY = e),
      (this.xRadius = n),
      (this.yRadius = i),
      (this.aStartAngle = s),
      (this.aEndAngle = r),
      (this.aClockwise = a),
      (this.aRotation = o)
  }
  getPoint(t, e = new vi()) {
    const n = e,
      i = 2 * Math.PI
    let s = this.aEndAngle - this.aStartAngle
    const r = Math.abs(s) < Number.EPSILON
    for (; s < 0; ) s += i
    for (; s > i; ) s -= i
    s < Number.EPSILON && (s = r ? 0 : i),
      !0 !== this.aClockwise || r || (s === i ? (s = -i) : (s -= i))
    const a = this.aStartAngle + t * s
    let o = this.aX + this.xRadius * Math.cos(a),
      l = this.aY + this.yRadius * Math.sin(a)
    if (0 !== this.aRotation) {
      const t = Math.cos(this.aRotation),
        e = Math.sin(this.aRotation),
        n = o - this.aX,
        i = l - this.aY
      ;(o = n * t - i * e + this.aX), (l = n * e + i * t + this.aY)
    }
    return n.set(o, l)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.aX = this.aX),
      (t.aY = this.aY),
      (t.xRadius = this.xRadius),
      (t.yRadius = this.yRadius),
      (t.aStartAngle = this.aStartAngle),
      (t.aEndAngle = this.aEndAngle),
      (t.aClockwise = this.aClockwise),
      (t.aRotation = this.aRotation),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    )
  }
}
class Du extends Lu {
  static {
    e(this, 'ArcCurve')
  }
  constructor(t, e, n, i, s, r) {
    super(t, e, n, n, i, s, r), (this.isArcCurve = !0), (this.type = 'ArcCurve')
  }
}
function ku() {
  let t = 0,
    n = 0,
    i = 0,
    s = 0
  function r(e, r, a, o) {
    ;(t = e),
      (n = a),
      (i = -3 * e + 3 * r - 2 * a - o),
      (s = 2 * e - 2 * r + a + o)
  }
  return (
    e(r, 'init'),
    {
      initCatmullRom: e(function (t, e, n, i, s) {
        r(e, n, s * (n - t), s * (i - e))
      }, 'initCatmullRom'),
      initNonuniformCatmullRom: e(function (t, e, n, i, s, a, o) {
        let l = (e - t) / s - (n - t) / (s + a) + (n - e) / a,
          c = (n - e) / a - (i - e) / (a + o) + (i - n) / o
        ;(l *= a), (c *= a), r(e, n, l, c)
      }, 'initNonuniformCatmullRom'),
      calc: e(function (e) {
        const r = e * e
        return t + n * e + i * r + s * (r * e)
      }, 'calc')
    }
  )
}
e(ku, 'CubicPoly')
const Nu = new Qi(),
  Uu = new ku(),
  Bu = new ku(),
  Ou = new ku()
class Fu extends Iu {
  static {
    e(this, 'CatmullRomCurve3')
  }
  constructor(t = [], e = !1, n = 'centripetal', i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = 'CatmullRomCurve3'),
      (this.points = t),
      (this.closed = e),
      (this.curveType = n),
      (this.tension = i)
  }
  getPoint(t, e = new Qi()) {
    const n = e,
      i = this.points,
      s = i.length,
      r = (s - (this.closed ? 0 : 1)) * t
    let a,
      o,
      l = Math.floor(r),
      c = r - l
    this.closed
      ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s) + 1) * s)
      : 0 === c && l === s - 1 && ((l = s - 2), (c = 1)),
      this.closed || l > 0
        ? (a = i[(l - 1) % s])
        : (Nu.subVectors(i[0], i[1]).add(i[0]), (a = Nu))
    const h = i[l % s],
      u = i[(l + 1) % s]
    if (
      (this.closed || l + 2 < s
        ? (o = i[(l + 2) % s])
        : (Nu.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), (o = Nu)),
      'centripetal' === this.curveType || 'chordal' === this.curveType)
    ) {
      const t = 'chordal' === this.curveType ? 0.5 : 0.25
      let e = Math.pow(a.distanceToSquared(h), t),
        n = Math.pow(h.distanceToSquared(u), t),
        i = Math.pow(u.distanceToSquared(o), t)
      n < 1e-4 && (n = 1),
        e < 1e-4 && (e = n),
        i < 1e-4 && (i = n),
        Uu.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i),
        Bu.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i),
        Ou.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i)
    } else
      'catmullrom' === this.curveType &&
        (Uu.initCatmullRom(a.x, h.x, u.x, o.x, this.tension),
        Bu.initCatmullRom(a.y, h.y, u.y, o.y, this.tension),
        Ou.initCatmullRom(a.z, h.z, u.z, o.z, this.tension))
    return n.set(Uu.calc(c), Bu.calc(c), Ou.calc(c)), n
  }
  copy(t) {
    super.copy(t), (this.points = [])
    for (let e = 0, n = t.points.length; e < n; e++) {
      const n = t.points[e]
      this.points.push(n.clone())
    }
    return (
      (this.closed = t.closed),
      (this.curveType = t.curveType),
      (this.tension = t.tension),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    t.points = []
    for (let e = 0, n = this.points.length; e < n; e++) {
      const n = this.points[e]
      t.points.push(n.toArray())
    }
    return (
      (t.closed = this.closed),
      (t.curveType = this.curveType),
      (t.tension = this.tension),
      t
    )
  }
  fromJSON(t) {
    super.fromJSON(t), (this.points = [])
    for (let e = 0, n = t.points.length; e < n; e++) {
      const n = t.points[e]
      this.points.push(new Qi().fromArray(n))
    }
    return (
      (this.closed = t.closed),
      (this.curveType = t.curveType),
      (this.tension = t.tension),
      this
    )
  }
}
function zu(t, e, n, i, s) {
  const r = 0.5 * (i - e),
    a = 0.5 * (s - n),
    o = t * t
  return (
    (2 * n - 2 * i + r + a) * (t * o) +
    (-3 * n + 3 * i - 2 * r - a) * o +
    r * t +
    n
  )
}
function Vu(t, e) {
  const n = 1 - t
  return n * n * e
}
function Hu(t, e) {
  return 2 * (1 - t) * t * e
}
function Gu(t, e) {
  return t * t * e
}
function Wu(t, e, n, i) {
  return Vu(t, e) + Hu(t, n) + Gu(t, i)
}
function ju(t, e) {
  const n = 1 - t
  return n * n * n * e
}
function Xu(t, e) {
  const n = 1 - t
  return 3 * n * n * t * e
}
function qu(t, e) {
  return 3 * (1 - t) * t * t * e
}
function Yu(t, e) {
  return t * t * t * e
}
function Zu(t, e, n, i, s) {
  return ju(t, e) + Xu(t, n) + qu(t, i) + Yu(t, s)
}
e(zu, 'CatmullRom'),
  e(Vu, 'QuadraticBezierP0'),
  e(Hu, 'QuadraticBezierP1'),
  e(Gu, 'QuadraticBezierP2'),
  e(Wu, 'QuadraticBezier'),
  e(ju, 'CubicBezierP0'),
  e(Xu, 'CubicBezierP1'),
  e(qu, 'CubicBezierP2'),
  e(Yu, 'CubicBezierP3'),
  e(Zu, 'CubicBezier')
class Ku extends Iu {
  static {
    e(this, 'CubicBezierCurve')
  }
  constructor(t = new vi(), e = new vi(), n = new vi(), i = new vi()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = 'CubicBezierCurve'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n),
      (this.v3 = i)
  }
  getPoint(t, e = new vi()) {
    const n = e,
      i = this.v0,
      s = this.v1,
      r = this.v2,
      a = this.v3
    return n.set(Zu(t, i.x, s.x, r.x, a.x), Zu(t, i.y, s.y, r.y, a.y)), n
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    )
  }
}
class $u extends Iu {
  static {
    e(this, 'CubicBezierCurve3')
  }
  constructor(t = new Qi(), e = new Qi(), n = new Qi(), i = new Qi()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = 'CubicBezierCurve3'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n),
      (this.v3 = i)
  }
  getPoint(t, e = new Qi()) {
    const n = e,
      i = this.v0,
      s = this.v1,
      r = this.v2,
      a = this.v3
    return (
      n.set(
        Zu(t, i.x, s.x, r.x, a.x),
        Zu(t, i.y, s.y, r.y, a.y),
        Zu(t, i.z, s.z, r.z, a.z)
      ),
      n
    )
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    )
  }
}
class Ju extends Iu {
  static {
    e(this, 'LineCurve')
  }
  constructor(t = new vi(), e = new vi()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = 'LineCurve'),
      (this.v1 = t),
      (this.v2 = e)
  }
  getPoint(t, e = new vi()) {
    const n = e
    return (
      1 === t
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
      n
    )
  }
  getPointAt(t, e) {
    return this.getPoint(t, e)
  }
  getTangent(t, e = new vi()) {
    return e.subVectors(this.v2, this.v1).normalize()
  }
  getTangentAt(t, e) {
    return this.getTangent(t, e)
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
  }
  toJSON() {
    const t = super.toJSON()
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
  }
  fromJSON(t) {
    return (
      super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    )
  }
}
class Qu extends Iu {
  static {
    e(this, 'LineCurve3')
  }
  constructor(t = new Qi(), e = new Qi()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = 'LineCurve3'),
      (this.v1 = t),
      (this.v2 = e)
  }
  getPoint(t, e = new Qi()) {
    const n = e
    return (
      1 === t
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
      n
    )
  }
  getPointAt(t, e) {
    return this.getPoint(t, e)
  }
  getTangent(t, e = new Qi()) {
    return e.subVectors(this.v2, this.v1).normalize()
  }
  getTangentAt(t, e) {
    return this.getTangent(t, e)
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
  }
  toJSON() {
    const t = super.toJSON()
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
  }
  fromJSON(t) {
    return (
      super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    )
  }
}
class td extends Iu {
  static {
    e(this, 'QuadraticBezierCurve')
  }
  constructor(t = new vi(), e = new vi(), n = new vi()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = 'QuadraticBezierCurve'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n)
  }
  getPoint(t, e = new vi()) {
    const n = e,
      i = this.v0,
      s = this.v1,
      r = this.v2
    return n.set(Wu(t, i.x, s.x, r.x), Wu(t, i.y, s.y, r.y)), n
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    )
  }
}
class ed extends Iu {
  static {
    e(this, 'QuadraticBezierCurve3')
  }
  constructor(t = new Qi(), e = new Qi(), n = new Qi()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = 'QuadraticBezierCurve3'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n)
  }
  getPoint(t, e = new Qi()) {
    const n = e,
      i = this.v0,
      s = this.v1,
      r = this.v2
    return (
      n.set(Wu(t, i.x, s.x, r.x), Wu(t, i.y, s.y, r.y), Wu(t, i.z, s.z, r.z)), n
    )
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    )
  }
}
class nd extends Iu {
  static {
    e(this, 'SplineCurve')
  }
  constructor(t = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = 'SplineCurve'),
      (this.points = t)
  }
  getPoint(t, e = new vi()) {
    const n = e,
      i = this.points,
      s = (i.length - 1) * t,
      r = Math.floor(s),
      a = s - r,
      o = i[0 === r ? r : r - 1],
      l = i[r],
      c = i[r > i.length - 2 ? i.length - 1 : r + 1],
      h = i[r > i.length - 3 ? i.length - 1 : r + 2]
    return n.set(zu(a, o.x, l.x, c.x, h.x), zu(a, o.y, l.y, c.y, h.y)), n
  }
  copy(t) {
    super.copy(t), (this.points = [])
    for (let e = 0, n = t.points.length; e < n; e++) {
      const n = t.points[e]
      this.points.push(n.clone())
    }
    return this
  }
  toJSON() {
    const t = super.toJSON()
    t.points = []
    for (let e = 0, n = this.points.length; e < n; e++) {
      const n = this.points[e]
      t.points.push(n.toArray())
    }
    return t
  }
  fromJSON(t) {
    super.fromJSON(t), (this.points = [])
    for (let e = 0, n = t.points.length; e < n; e++) {
      const n = t.points[e]
      this.points.push(new vi().fromArray(n))
    }
    return this
  }
}
var id = Object.freeze({
  __proto__: null,
  ArcCurve: Du,
  CatmullRomCurve3: Fu,
  CubicBezierCurve: Ku,
  CubicBezierCurve3: $u,
  EllipseCurve: Lu,
  LineCurve: Ju,
  LineCurve3: Qu,
  QuadraticBezierCurve: td,
  QuadraticBezierCurve3: ed,
  SplineCurve: nd
})
class sd extends Iu {
  static {
    e(this, 'CurvePath')
  }
  constructor() {
    super(),
      (this.type = 'CurvePath'),
      (this.curves = []),
      (this.autoClose = !1)
  }
  add(t) {
    this.curves.push(t)
  }
  closePath() {
    const t = this.curves[0].getPoint(0),
      e = this.curves[this.curves.length - 1].getPoint(1)
    if (!t.equals(e)) {
      const n = !0 === t.isVector2 ? 'LineCurve' : 'LineCurve3'
      this.curves.push(new id[n](e, t))
    }
    return this
  }
  getPoint(t, e) {
    const n = t * this.getLength(),
      i = this.getCurveLengths()
    let s = 0
    for (; s < i.length; ) {
      if (i[s] >= n) {
        const t = i[s] - n,
          r = this.curves[s],
          a = r.getLength(),
          o = 0 === a ? 0 : 1 - t / a
        return r.getPointAt(o, e)
      }
      s++
    }
    return null
  }
  getLength() {
    const t = this.getCurveLengths()
    return t[t.length - 1]
  }
  updateArcLengths() {
    ;(this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths()
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths
    const t = []
    let e = 0
    for (let n = 0, i = this.curves.length; n < i; n++)
      (e += this.curves[n].getLength()), t.push(e)
    return (this.cacheLengths = t), t
  }
  getSpacedPoints(t = 40) {
    const e = []
    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t))
    return this.autoClose && e.push(e[0]), e
  }
  getPoints(t = 12) {
    const e = []
    let n
    for (let i = 0, s = this.curves; i < s.length; i++) {
      const r = s[i],
        a = r.isEllipseCurve
          ? 2 * t
          : r.isLineCurve || r.isLineCurve3
            ? 1
            : r.isSplineCurve
              ? t * r.points.length
              : t,
        o = r.getPoints(a)
      for (let t = 0; t < o.length; t++) {
        const i = o[t]
        ;(n && n.equals(i)) || (e.push(i), (n = i))
      }
    }
    return (
      this.autoClose &&
        e.length > 1 &&
        !e[e.length - 1].equals(e[0]) &&
        e.push(e[0]),
      e
    )
  }
  copy(t) {
    super.copy(t), (this.curves = [])
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const n = t.curves[e]
      this.curves.push(n.clone())
    }
    return (this.autoClose = t.autoClose), this
  }
  toJSON() {
    const t = super.toJSON()
    ;(t.autoClose = this.autoClose), (t.curves = [])
    for (let e = 0, n = this.curves.length; e < n; e++) {
      const n = this.curves[e]
      t.curves.push(n.toJSON())
    }
    return t
  }
  fromJSON(t) {
    super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = [])
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const n = t.curves[e]
      this.curves.push(new id[n.type]().fromJSON(n))
    }
    return this
  }
}
class rd extends sd {
  static {
    e(this, 'Path')
  }
  constructor(t) {
    super(),
      (this.type = 'Path'),
      (this.currentPoint = new vi()),
      t && this.setFromPoints(t)
  }
  setFromPoints(t) {
    this.moveTo(t[0].x, t[0].y)
    for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y)
    return this
  }
  moveTo(t, e) {
    return this.currentPoint.set(t, e), this
  }
  lineTo(t, e) {
    const n = new Ju(this.currentPoint.clone(), new vi(t, e))
    return this.curves.push(n), this.currentPoint.set(t, e), this
  }
  quadraticCurveTo(t, e, n, i) {
    const s = new td(this.currentPoint.clone(), new vi(t, e), new vi(n, i))
    return this.curves.push(s), this.currentPoint.set(n, i), this
  }
  bezierCurveTo(t, e, n, i, s, r) {
    const a = new Ku(
      this.currentPoint.clone(),
      new vi(t, e),
      new vi(n, i),
      new vi(s, r)
    )
    return this.curves.push(a), this.currentPoint.set(s, r), this
  }
  splineThru(t) {
    const e = [this.currentPoint.clone()].concat(t),
      n = new nd(e)
    return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
  }
  arc(t, e, n, i, s, r) {
    const a = this.currentPoint.x,
      o = this.currentPoint.y
    return this.absarc(t + a, e + o, n, i, s, r), this
  }
  absarc(t, e, n, i, s, r) {
    return this.absellipse(t, e, n, n, i, s, r), this
  }
  ellipse(t, e, n, i, s, r, a, o) {
    const l = this.currentPoint.x,
      c = this.currentPoint.y
    return this.absellipse(t + l, e + c, n, i, s, r, a, o), this
  }
  absellipse(t, e, n, i, s, r, a, o) {
    const l = new Lu(t, e, n, i, s, r, a, o)
    if (this.curves.length > 0) {
      const t = l.getPoint(0)
      t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
    }
    this.curves.push(l)
    const c = l.getPoint(1)
    return this.currentPoint.copy(c), this
  }
  copy(t) {
    return super.copy(t), this.currentPoint.copy(t.currentPoint), this
  }
  toJSON() {
    const t = super.toJSON()
    return (t.currentPoint = this.currentPoint.toArray()), t
  }
  fromJSON(t) {
    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
  }
}
class ad extends Zr {
  static {
    e(this, 'LatheGeometry')
  }
  constructor(
    t = [new vi(0, -0.5), new vi(0.5, 0), new vi(0, 0.5)],
    e = 12,
    n = 0,
    i = 2 * Math.PI
  ) {
    super(),
      (this.type = 'LatheGeometry'),
      (this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }),
      (e = Math.floor(e)),
      (i = Zn(i, 0, 2 * Math.PI))
    const s = [],
      r = [],
      a = [],
      o = [],
      l = [],
      c = 1 / e,
      h = new Qi(),
      u = new vi(),
      d = new Qi(),
      p = new Qi(),
      m = new Qi()
    let f = 0,
      g = 0
    for (let v = 0; v <= t.length - 1; v++)
      switch (v) {
        case 0:
          ;(f = t[v + 1].x - t[v].x),
            (g = t[v + 1].y - t[v].y),
            (d.x = 1 * g),
            (d.y = -f),
            (d.z = 0 * g),
            m.copy(d),
            d.normalize(),
            o.push(d.x, d.y, d.z)
          break
        case t.length - 1:
          o.push(m.x, m.y, m.z)
          break
        default:
          ;(f = t[v + 1].x - t[v].x),
            (g = t[v + 1].y - t[v].y),
            (d.x = 1 * g),
            (d.y = -f),
            (d.z = 0 * g),
            p.copy(d),
            (d.x += m.x),
            (d.y += m.y),
            (d.z += m.z),
            d.normalize(),
            o.push(d.x, d.y, d.z),
            m.copy(p)
      }
    for (let v = 0; v <= e; v++) {
      const s = n + v * c * i,
        d = Math.sin(s),
        p = Math.cos(s)
      for (let n = 0; n <= t.length - 1; n++) {
        ;(h.x = t[n].x * d),
          (h.y = t[n].y),
          (h.z = t[n].x * p),
          r.push(h.x, h.y, h.z),
          (u.x = v / e),
          (u.y = n / (t.length - 1)),
          a.push(u.x, u.y)
        const i = o[3 * n + 0] * d,
          s = o[3 * n + 1],
          c = o[3 * n + 0] * p
        l.push(i, s, c)
      }
    }
    for (let v = 0; v < e; v++)
      for (let e = 0; e < t.length - 1; e++) {
        const n = e + v * t.length,
          i = n,
          r = n + t.length,
          a = n + t.length + 1,
          o = n + 1
        s.push(i, r, o), s.push(a, o, r)
      }
    this.setIndex(s),
      this.setAttribute('position', new Vr(r, 3)),
      this.setAttribute('uv', new Vr(a, 2)),
      this.setAttribute('normal', new Vr(l, 3))
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  static fromJSON(t) {
    return new ad(t.points, t.segments, t.phiStart, t.phiLength)
  }
}
class od extends ad {
  static {
    e(this, 'CapsuleGeometry')
  }
  constructor(t = 1, e = 1, n = 4, i = 8) {
    const s = new rd()
    s.absarc(0, -e / 2, t, 1.5 * Math.PI, 0),
      s.absarc(0, e / 2, t, 0, 0.5 * Math.PI),
      super(s.getPoints(n), i),
      (this.type = 'CapsuleGeometry'),
      (this.parameters = {
        radius: t,
        length: e,
        capSegments: n,
        radialSegments: i
      })
  }
  static fromJSON(t) {
    return new od(t.radius, t.length, t.capSegments, t.radialSegments)
  }
}
class ld extends Zr {
  static {
    e(this, 'CircleGeometry')
  }
  constructor(t = 1, e = 32, n = 0, i = 2 * Math.PI) {
    super(),
      (this.type = 'CircleGeometry'),
      (this.parameters = {
        radius: t,
        segments: e,
        thetaStart: n,
        thetaLength: i
      }),
      (e = Math.max(3, e))
    const s = [],
      r = [],
      a = [],
      o = [],
      l = new Qi(),
      c = new vi()
    r.push(0, 0, 0), a.push(0, 0, 1), o.push(0.5, 0.5)
    for (let h = 0, u = 3; h <= e; h++, u += 3) {
      const s = n + (h / e) * i
      ;(l.x = t * Math.cos(s)),
        (l.y = t * Math.sin(s)),
        r.push(l.x, l.y, l.z),
        a.push(0, 0, 1),
        (c.x = (r[u] / t + 1) / 2),
        (c.y = (r[u + 1] / t + 1) / 2),
        o.push(c.x, c.y)
    }
    for (let h = 1; h <= e; h++) s.push(h, h + 1, 0)
    this.setIndex(s),
      this.setAttribute('position', new Vr(r, 3)),
      this.setAttribute('normal', new Vr(a, 3)),
      this.setAttribute('uv', new Vr(o, 2))
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  static fromJSON(t) {
    return new ld(t.radius, t.segments, t.thetaStart, t.thetaLength)
  }
}
class cd extends Zr {
  static {
    e(this, 'CylinderGeometry')
  }
  constructor(
    t = 1,
    n = 1,
    i = 1,
    s = 32,
    r = 1,
    a = !1,
    o = 0,
    l = 2 * Math.PI
  ) {
    super(),
      (this.type = 'CylinderGeometry'),
      (this.parameters = {
        radiusTop: t,
        radiusBottom: n,
        height: i,
        radialSegments: s,
        heightSegments: r,
        openEnded: a,
        thetaStart: o,
        thetaLength: l
      })
    const c = this
    ;(s = Math.floor(s)), (r = Math.floor(r))
    const h = [],
      u = [],
      d = [],
      p = []
    let m = 0
    const f = [],
      g = i / 2
    let v = 0
    function y() {
      const e = new Qi(),
        a = new Qi()
      let y = 0
      const _ = (n - t) / i
      for (let c = 0; c <= r; c++) {
        const h = [],
          v = c / r,
          y = v * (n - t) + t
        for (let t = 0; t <= s; t++) {
          const n = t / s,
            r = n * l + o,
            c = Math.sin(r),
            f = Math.cos(r)
          ;(a.x = y * c),
            (a.y = -v * i + g),
            (a.z = y * f),
            u.push(a.x, a.y, a.z),
            e.set(c, _, f).normalize(),
            d.push(e.x, e.y, e.z),
            p.push(n, 1 - v),
            h.push(m++)
        }
        f.push(h)
      }
      for (let i = 0; i < s; i++)
        for (let e = 0; e < r; e++) {
          const s = f[e][i],
            a = f[e + 1][i],
            o = f[e + 1][i + 1],
            l = f[e][i + 1]
          ;(t > 0 || 0 !== e) && (h.push(s, a, l), (y += 3)),
            (n > 0 || e !== r - 1) && (h.push(a, o, l), (y += 3))
        }
      c.addGroup(v, y, 0), (v += y)
    }
    function _(e) {
      const i = m,
        r = new vi(),
        a = new Qi()
      let f = 0
      const y = !0 === e ? t : n,
        _ = !0 === e ? 1 : -1
      for (let t = 1; t <= s; t++)
        u.push(0, g * _, 0), d.push(0, _, 0), p.push(0.5, 0.5), m++
      const x = m
      for (let t = 0; t <= s; t++) {
        const e = (t / s) * l + o,
          n = Math.cos(e),
          i = Math.sin(e)
        ;(a.x = y * i),
          (a.y = g * _),
          (a.z = y * n),
          u.push(a.x, a.y, a.z),
          d.push(0, _, 0),
          (r.x = 0.5 * n + 0.5),
          (r.y = 0.5 * i * _ + 0.5),
          p.push(r.x, r.y),
          m++
      }
      for (let t = 0; t < s; t++) {
        const n = i + t,
          s = x + t
        !0 === e ? h.push(s, s + 1, n) : h.push(s + 1, s, n), (f += 3)
      }
      c.addGroup(v, f, !0 === e ? 1 : 2), (v += f)
    }
    y(),
      !1 === a && (t > 0 && _(!0), n > 0 && _(!1)),
      this.setIndex(h),
      this.setAttribute('position', new Vr(u, 3)),
      this.setAttribute('normal', new Vr(d, 3)),
      this.setAttribute('uv', new Vr(p, 2)),
      e(y, 'generateTorso'),
      e(_, 'generateCap')
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  static fromJSON(t) {
    return new cd(
      t.radiusTop,
      t.radiusBottom,
      t.height,
      t.radialSegments,
      t.heightSegments,
      t.openEnded,
      t.thetaStart,
      t.thetaLength
    )
  }
}
class hd extends cd {
  static {
    e(this, 'ConeGeometry')
  }
  constructor(t = 1, e = 1, n = 32, i = 1, s = !1, r = 0, a = 2 * Math.PI) {
    super(0, t, e, n, i, s, r, a),
      (this.type = 'ConeGeometry'),
      (this.parameters = {
        radius: t,
        height: e,
        radialSegments: n,
        heightSegments: i,
        openEnded: s,
        thetaStart: r,
        thetaLength: a
      })
  }
  static fromJSON(t) {
    return new hd(
      t.radius,
      t.height,
      t.radialSegments,
      t.heightSegments,
      t.openEnded,
      t.thetaStart,
      t.thetaLength
    )
  }
}
class ud extends Zr {
  static {
    e(this, 'PolyhedronGeometry')
  }
  constructor(t = [], n = [], i = 1, s = 0) {
    super(),
      (this.type = 'PolyhedronGeometry'),
      (this.parameters = { vertices: t, indices: n, radius: i, detail: s })
    const r = [],
      a = []
    function o(t) {
      const e = new Qi(),
        i = new Qi(),
        s = new Qi()
      for (let r = 0; r < n.length; r += 3)
        p(n[r + 0], e), p(n[r + 1], i), p(n[r + 2], s), l(e, i, s, t)
    }
    function l(t, e, n, i) {
      const s = i + 1,
        r = []
      for (let a = 0; a <= s; a++) {
        r[a] = []
        const i = t.clone().lerp(n, a / s),
          o = e.clone().lerp(n, a / s),
          l = s - a
        for (let t = 0; t <= l; t++)
          r[a][t] = 0 === t && a === s ? i : i.clone().lerp(o, t / l)
      }
      for (let a = 0; a < s; a++)
        for (let t = 0; t < 2 * (s - a) - 1; t++) {
          const e = Math.floor(t / 2)
          t % 2 == 0
            ? (d(r[a][e + 1]), d(r[a + 1][e]), d(r[a][e]))
            : (d(r[a][e + 1]), d(r[a + 1][e + 1]), d(r[a + 1][e]))
        }
    }
    function c(t) {
      const e = new Qi()
      for (let n = 0; n < r.length; n += 3)
        (e.x = r[n + 0]),
          (e.y = r[n + 1]),
          (e.z = r[n + 2]),
          e.normalize().multiplyScalar(t),
          (r[n + 0] = e.x),
          (r[n + 1] = e.y),
          (r[n + 2] = e.z)
    }
    function h() {
      const t = new Qi()
      for (let e = 0; e < r.length; e += 3) {
        ;(t.x = r[e + 0]), (t.y = r[e + 1]), (t.z = r[e + 2])
        const n = g(t) / 2 / Math.PI + 0.5,
          i = v(t) / Math.PI + 0.5
        a.push(n, 1 - i)
      }
      m(), u()
    }
    function u() {
      for (let t = 0; t < a.length; t += 6) {
        const e = a[t + 0],
          n = a[t + 2],
          i = a[t + 4],
          s = Math.max(e, n, i),
          r = Math.min(e, n, i)
        s > 0.9 &&
          r < 0.1 &&
          (e < 0.2 && (a[t + 0] += 1),
          n < 0.2 && (a[t + 2] += 1),
          i < 0.2 && (a[t + 4] += 1))
      }
    }
    function d(t) {
      r.push(t.x, t.y, t.z)
    }
    function p(e, n) {
      const i = 3 * e
      ;(n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2])
    }
    function m() {
      const t = new Qi(),
        e = new Qi(),
        n = new Qi(),
        i = new Qi(),
        s = new vi(),
        o = new vi(),
        l = new vi()
      for (let c = 0, h = 0; c < r.length; c += 9, h += 6) {
        t.set(r[c + 0], r[c + 1], r[c + 2]),
          e.set(r[c + 3], r[c + 4], r[c + 5]),
          n.set(r[c + 6], r[c + 7], r[c + 8]),
          s.set(a[h + 0], a[h + 1]),
          o.set(a[h + 2], a[h + 3]),
          l.set(a[h + 4], a[h + 5]),
          i.copy(t).add(e).add(n).divideScalar(3)
        const u = g(i)
        f(s, h + 0, t, u), f(o, h + 2, e, u), f(l, h + 4, n, u)
      }
    }
    function f(t, e, n, i) {
      i < 0 && 1 === t.x && (a[e] = t.x - 1),
        0 === n.x && 0 === n.z && (a[e] = i / 2 / Math.PI + 0.5)
    }
    function g(t) {
      return Math.atan2(t.z, -t.x)
    }
    function v(t) {
      return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
    }
    o(s),
      c(i),
      h(),
      this.setAttribute('position', new Vr(r, 3)),
      this.setAttribute('normal', new Vr(r.slice(), 3)),
      this.setAttribute('uv', new Vr(a, 2)),
      0 === s ? this.computeVertexNormals() : this.normalizeNormals(),
      e(o, 'subdivide'),
      e(l, 'subdivideFace'),
      e(c, 'applyRadius'),
      e(h, 'generateUVs'),
      e(u, 'correctSeam'),
      e(d, 'pushVertex'),
      e(p, 'getVertexByIndex'),
      e(m, 'correctUVs'),
      e(f, 'correctUV'),
      e(g, 'azimuth'),
      e(v, 'inclination')
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  static fromJSON(t) {
    return new ud(t.vertices, t.indices, t.radius, t.details)
  }
}
class dd extends ud {
  static {
    e(this, 'DodecahedronGeometry')
  }
  constructor(t = 1, e = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      i = 1 / n
    super(
      [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        0,
        -n,
        0,
        -i,
        n,
        0,
        -i,
        -n,
        0,
        i,
        n,
        0,
        i
      ],
      [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9
      ],
      t,
      e
    ),
      (this.type = 'DodecahedronGeometry'),
      (this.parameters = { radius: t, detail: e })
  }
  static fromJSON(t) {
    return new dd(t.radius, t.detail)
  }
}
const pd = new Qi(),
  md = new Qi(),
  fd = new Qi(),
  gd = new gr()
class vd extends Zr {
  static {
    e(this, 'EdgesGeometry')
  }
  constructor(t = null, e = 1) {
    if (
      (super(),
      (this.type = 'EdgesGeometry'),
      (this.parameters = { geometry: t, thresholdAngle: e }),
      null !== t)
    ) {
      const n = 4,
        i = Math.pow(10, n),
        s = Math.cos(Xn * e),
        r = t.getIndex(),
        a = t.getAttribute('position'),
        o = r ? r.count : a.count,
        l = [0, 0, 0],
        c = ['a', 'b', 'c'],
        h = new Array(3),
        u = {},
        d = []
      for (let t = 0; t < o; t += 3) {
        r
          ? ((l[0] = r.getX(t)), (l[1] = r.getX(t + 1)), (l[2] = r.getX(t + 2)))
          : ((l[0] = t), (l[1] = t + 1), (l[2] = t + 2))
        const { a: e, b: n, c: o } = gd
        if (
          (e.fromBufferAttribute(a, l[0]),
          n.fromBufferAttribute(a, l[1]),
          o.fromBufferAttribute(a, l[2]),
          gd.getNormal(fd),
          (h[0] = `${Math.round(e.x * i)},${Math.round(e.y * i)},${Math.round(e.z * i)}`),
          (h[1] = `${Math.round(n.x * i)},${Math.round(n.y * i)},${Math.round(n.z * i)}`),
          (h[2] = `${Math.round(o.x * i)},${Math.round(o.y * i)},${Math.round(o.z * i)}`),
          h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
        )
          for (let t = 0; t < 3; t++) {
            const e = (t + 1) % 3,
              n = h[t],
              i = h[e],
              r = gd[c[t]],
              a = gd[c[e]],
              o = `${n}_${i}`,
              p = `${i}_${n}`
            p in u && u[p]
              ? (fd.dot(u[p].normal) <= s &&
                  (d.push(r.x, r.y, r.z), d.push(a.x, a.y, a.z)),
                (u[p] = null))
              : o in u ||
                (u[o] = { index0: l[t], index1: l[e], normal: fd.clone() })
          }
      }
      for (const t in u)
        if (u[t]) {
          const { index0: e, index1: n } = u[t]
          pd.fromBufferAttribute(a, e),
            md.fromBufferAttribute(a, n),
            d.push(pd.x, pd.y, pd.z),
            d.push(md.x, md.y, md.z)
        }
      this.setAttribute('position', new Vr(d, 3))
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
}
class yd extends rd {
  static {
    e(this, 'Shape')
  }
  constructor(t) {
    super(t), (this.uuid = Yn()), (this.type = 'Shape'), (this.holes = [])
  }
  getPointsHoles(t) {
    const e = []
    for (let n = 0, i = this.holes.length; n < i; n++)
      e[n] = this.holes[n].getPoints(t)
    return e
  }
  extractPoints(t) {
    return { shape: this.getPoints(t), holes: this.getPointsHoles(t) }
  }
  copy(t) {
    super.copy(t), (this.holes = [])
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const n = t.holes[e]
      this.holes.push(n.clone())
    }
    return this
  }
  toJSON() {
    const t = super.toJSON()
    ;(t.uuid = this.uuid), (t.holes = [])
    for (let e = 0, n = this.holes.length; e < n; e++) {
      const n = this.holes[e]
      t.holes.push(n.toJSON())
    }
    return t
  }
  fromJSON(t) {
    super.fromJSON(t), (this.uuid = t.uuid), (this.holes = [])
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const n = t.holes[e]
      this.holes.push(new rd().fromJSON(n))
    }
    return this
  }
}
const _d = {
  triangulate: e(function (t, e, n = 2) {
    const i = e && e.length,
      s = i ? e[0] * n : t.length
    let r = xd(t, 0, s, n, !0)
    const a = []
    if (!r || r.next === r.prev) return a
    let o, l, c, h, u, d, p
    if ((i && (r = Ad(t, e, r, n)), t.length > 80 * n)) {
      ;(o = c = t[0]), (l = h = t[1])
      for (let e = n; e < s; e += n)
        (u = t[e]),
          (d = t[e + 1]),
          u < o && (o = u),
          d < l && (l = d),
          u > c && (c = u),
          d > h && (h = d)
      ;(p = Math.max(c - o, h - l)), (p = 0 !== p ? 32767 / p : 0)
    }
    return wd(r, a, n, o, l, p, 0), a
  }, 'triangulate')
}
function xd(t, e, n, i, s) {
  let r, a
  if (s === Kd(t, e, n, i) > 0)
    for (r = e; r < n; r += i) a = qd(r, t[r], t[r + 1], a)
  else for (r = n - i; r >= e; r -= i) a = qd(r, t[r], t[r + 1], a)
  return a && Fd(a, a.next) && (Yd(a), (a = a.next)), a
}
function bd(t, e) {
  if (!t) return t
  e || (e = t)
  let n,
    i = t
  do {
    if (
      ((n = !1), i.steiner || (!Fd(i, i.next) && 0 !== Od(i.prev, i, i.next)))
    )
      i = i.next
    else {
      if ((Yd(i), (i = e = i.prev), i === i.next)) break
      n = !0
    }
  } while (n || i !== e)
  return e
}
function wd(t, e, n, i, s, r, a) {
  if (!t) return
  !a && r && Ld(t, i, s, r)
  let o,
    l,
    c = t
  for (; t.prev !== t.next; )
    if (((o = t.prev), (l = t.next), r ? Sd(t, i, s, r) : Md(t)))
      e.push((o.i / n) | 0),
        e.push((t.i / n) | 0),
        e.push((l.i / n) | 0),
        Yd(t),
        (t = l.next),
        (c = l.next)
    else if ((t = l) === c) {
      a
        ? 1 === a
          ? wd((t = Td(bd(t), e, n)), e, n, i, s, r, 2)
          : 2 === a && Ed(t, e, n, i, s, r)
        : wd(bd(t), e, n, i, s, r, 1)
      break
    }
}
function Md(t) {
  const e = t.prev,
    n = t,
    i = t.next
  if (Od(e, n, i) >= 0) return !1
  const s = e.x,
    r = n.x,
    a = i.x,
    o = e.y,
    l = n.y,
    c = i.y,
    h = s < r ? (s < a ? s : a) : r < a ? r : a,
    u = o < l ? (o < c ? o : c) : l < c ? l : c,
    d = s > r ? (s > a ? s : a) : r > a ? r : a,
    p = o > l ? (o > c ? o : c) : l > c ? l : c
  let m = i.next
  for (; m !== e; ) {
    if (
      m.x >= h &&
      m.x <= d &&
      m.y >= u &&
      m.y <= p &&
      Ud(s, o, r, l, a, c, m.x, m.y) &&
      Od(m.prev, m, m.next) >= 0
    )
      return !1
    m = m.next
  }
  return !0
}
function Sd(t, e, n, i) {
  const s = t.prev,
    r = t,
    a = t.next
  if (Od(s, r, a) >= 0) return !1
  const o = s.x,
    l = r.x,
    c = a.x,
    h = s.y,
    u = r.y,
    d = a.y,
    p = o < l ? (o < c ? o : c) : l < c ? l : c,
    m = h < u ? (h < d ? h : d) : u < d ? u : d,
    f = o > l ? (o > c ? o : c) : l > c ? l : c,
    g = h > u ? (h > d ? h : d) : u > d ? u : d,
    v = kd(p, m, e, n, i),
    y = kd(f, g, e, n, i)
  let _ = t.prevZ,
    x = t.nextZ
  for (; _ && _.z >= v && x && x.z <= y; ) {
    if (
      _.x >= p &&
      _.x <= f &&
      _.y >= m &&
      _.y <= g &&
      _ !== s &&
      _ !== a &&
      Ud(o, h, l, u, c, d, _.x, _.y) &&
      Od(_.prev, _, _.next) >= 0
    )
      return !1
    if (
      ((_ = _.prevZ),
      x.x >= p &&
        x.x <= f &&
        x.y >= m &&
        x.y <= g &&
        x !== s &&
        x !== a &&
        Ud(o, h, l, u, c, d, x.x, x.y) &&
        Od(x.prev, x, x.next) >= 0)
    )
      return !1
    x = x.nextZ
  }
  for (; _ && _.z >= v; ) {
    if (
      _.x >= p &&
      _.x <= f &&
      _.y >= m &&
      _.y <= g &&
      _ !== s &&
      _ !== a &&
      Ud(o, h, l, u, c, d, _.x, _.y) &&
      Od(_.prev, _, _.next) >= 0
    )
      return !1
    _ = _.prevZ
  }
  for (; x && x.z <= y; ) {
    if (
      x.x >= p &&
      x.x <= f &&
      x.y >= m &&
      x.y <= g &&
      x !== s &&
      x !== a &&
      Ud(o, h, l, u, c, d, x.x, x.y) &&
      Od(x.prev, x, x.next) >= 0
    )
      return !1
    x = x.nextZ
  }
  return !0
}
function Td(t, e, n) {
  let i = t
  do {
    const s = i.prev,
      r = i.next.next
    !Fd(s, r) &&
      zd(s, i, i.next, r) &&
      Wd(s, r) &&
      Wd(r, s) &&
      (e.push((s.i / n) | 0),
      e.push((i.i / n) | 0),
      e.push((r.i / n) | 0),
      Yd(i),
      Yd(i.next),
      (i = t = r)),
      (i = i.next)
  } while (i !== t)
  return bd(i)
}
function Ed(t, e, n, i, s, r) {
  let a = t
  do {
    let t = a.next.next
    for (; t !== a.prev; ) {
      if (a.i !== t.i && Bd(a, t)) {
        let o = Xd(a, t)
        return (
          (a = bd(a, a.next)),
          (o = bd(o, o.next)),
          wd(a, e, n, i, s, r, 0),
          void wd(o, e, n, i, s, r, 0)
        )
      }
      t = t.next
    }
    a = a.next
  } while (a !== t)
}
function Ad(t, e, n, i) {
  const s = []
  let r, a, o, l, c
  for (r = 0, a = e.length; r < a; r++)
    (o = e[r] * i),
      (l = r < a - 1 ? e[r + 1] * i : t.length),
      (c = xd(t, o, l, i, !1)),
      c === c.next && (c.steiner = !0),
      s.push(Nd(c))
  for (s.sort(Cd), r = 0; r < s.length; r++) n = Rd(s[r], n)
  return n
}
function Cd(t, e) {
  return t.x - e.x
}
function Rd(t, e) {
  const n = Pd(t, e)
  if (!n) return e
  const i = Xd(n, t)
  return bd(i, i.next), bd(n, n.next)
}
function Pd(t, e) {
  let n,
    i = e,
    s = -1 / 0
  const r = t.x,
    a = t.y
  do {
    if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
      const t = i.x + ((a - i.y) * (i.next.x - i.x)) / (i.next.y - i.y)
      if (
        t <= r &&
        t > s &&
        ((s = t), (n = i.x < i.next.x ? i : i.next), t === r)
      )
        return n
    }
    i = i.next
  } while (i !== e)
  if (!n) return null
  const o = n,
    l = n.x,
    c = n.y
  let h,
    u = 1 / 0
  i = n
  do {
    r >= i.x &&
      i.x >= l &&
      r !== i.x &&
      Ud(a < c ? r : s, a, l, c, a < c ? s : r, a, i.x, i.y) &&
      ((h = Math.abs(a - i.y) / (r - i.x)),
      Wd(i, t) &&
        (h < u || (h === u && (i.x > n.x || (i.x === n.x && Id(n, i))))) &&
        ((n = i), (u = h))),
      (i = i.next)
  } while (i !== o)
  return n
}
function Id(t, e) {
  return Od(t.prev, t, e.prev) < 0 && Od(e.next, t, t.next) < 0
}
function Ld(t, e, n, i) {
  let s = t
  do {
    0 === s.z && (s.z = kd(s.x, s.y, e, n, i)),
      (s.prevZ = s.prev),
      (s.nextZ = s.next),
      (s = s.next)
  } while (s !== t)
  ;(s.prevZ.nextZ = null), (s.prevZ = null), Dd(s)
}
function Dd(t) {
  let e,
    n,
    i,
    s,
    r,
    a,
    o,
    l,
    c = 1
  do {
    for (n = t, t = null, r = null, a = 0; n; ) {
      for (a++, i = n, o = 0, e = 0; e < c && (o++, (i = i.nextZ), i); e++);
      for (l = c; o > 0 || (l > 0 && i); )
        0 !== o && (0 === l || !i || n.z <= i.z)
          ? ((s = n), (n = n.nextZ), o--)
          : ((s = i), (i = i.nextZ), l--),
          r ? (r.nextZ = s) : (t = s),
          (s.prevZ = r),
          (r = s)
      n = i
    }
    ;(r.nextZ = null), (c *= 2)
  } while (a > 1)
  return t
}
function kd(t, e, n, i, s) {
  return (
    (t =
      1431655765 &
      ((t =
        858993459 &
        ((t =
          252645135 &
          ((t = 16711935 & ((t = ((t - n) * s) | 0) | (t << 8))) | (t << 4))) |
          (t << 2))) |
        (t << 1))) |
    ((e =
      1431655765 &
      ((e =
        858993459 &
        ((e =
          252645135 &
          ((e = 16711935 & ((e = ((e - i) * s) | 0) | (e << 8))) | (e << 4))) |
          (e << 2))) |
        (e << 1))) <<
      1)
  )
}
function Nd(t) {
  let e = t,
    n = t
  do {
    ;(e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next)
  } while (e !== t)
  return n
}
function Ud(t, e, n, i, s, r, a, o) {
  return (
    (s - a) * (e - o) >= (t - a) * (r - o) &&
    (t - a) * (i - o) >= (n - a) * (e - o) &&
    (n - a) * (r - o) >= (s - a) * (i - o)
  )
}
function Bd(t, e) {
  return (
    t.next.i !== e.i &&
    t.prev.i !== e.i &&
    !Gd(t, e) &&
    ((Wd(t, e) &&
      Wd(e, t) &&
      jd(t, e) &&
      (Od(t.prev, t, e.prev) || Od(t, e.prev, e))) ||
      (Fd(t, e) && Od(t.prev, t, t.next) > 0 && Od(e.prev, e, e.next) > 0))
  )
}
function Od(t, e, n) {
  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
}
function Fd(t, e) {
  return t.x === e.x && t.y === e.y
}
function zd(t, e, n, i) {
  const s = Hd(Od(t, e, n)),
    r = Hd(Od(t, e, i)),
    a = Hd(Od(n, i, t)),
    o = Hd(Od(n, i, e))
  return (
    (s !== r && a !== o) ||
    !(0 !== s || !Vd(t, n, e)) ||
    !(0 !== r || !Vd(t, i, e)) ||
    !(0 !== a || !Vd(n, t, i)) ||
    !(0 !== o || !Vd(n, e, i))
  )
}
function Vd(t, e, n) {
  return (
    e.x <= Math.max(t.x, n.x) &&
    e.x >= Math.min(t.x, n.x) &&
    e.y <= Math.max(t.y, n.y) &&
    e.y >= Math.min(t.y, n.y)
  )
}
function Hd(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0
}
function Gd(t, e) {
  let n = t
  do {
    if (
      n.i !== t.i &&
      n.next.i !== t.i &&
      n.i !== e.i &&
      n.next.i !== e.i &&
      zd(n, n.next, t, e)
    )
      return !0
    n = n.next
  } while (n !== t)
  return !1
}
function Wd(t, e) {
  return Od(t.prev, t, t.next) < 0
    ? Od(t, e, t.next) >= 0 && Od(t, t.prev, e) >= 0
    : Od(t, e, t.prev) < 0 || Od(t, t.next, e) < 0
}
function jd(t, e) {
  let n = t,
    i = !1
  const s = (t.x + e.x) / 2,
    r = (t.y + e.y) / 2
  do {
    n.y > r != n.next.y > r &&
      n.next.y !== n.y &&
      s < ((n.next.x - n.x) * (r - n.y)) / (n.next.y - n.y) + n.x &&
      (i = !i),
      (n = n.next)
  } while (n !== t)
  return i
}
function Xd(t, e) {
  const n = new Zd(t.i, t.x, t.y),
    i = new Zd(e.i, e.x, e.y),
    s = t.next,
    r = e.prev
  return (
    (t.next = e),
    (e.prev = t),
    (n.next = s),
    (s.prev = n),
    (i.next = n),
    (n.prev = i),
    (r.next = i),
    (i.prev = r),
    i
  )
}
function qd(t, e, n, i) {
  const s = new Zd(t, e, n)
  return (
    i
      ? ((s.next = i.next), (s.prev = i), (i.next.prev = s), (i.next = s))
      : ((s.prev = s), (s.next = s)),
    s
  )
}
function Yd(t) {
  ;(t.next.prev = t.prev),
    (t.prev.next = t.next),
    t.prevZ && (t.prevZ.nextZ = t.nextZ),
    t.nextZ && (t.nextZ.prevZ = t.prevZ)
}
function Zd(t, e, n) {
  ;(this.i = t),
    (this.x = e),
    (this.y = n),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1)
}
function Kd(t, e, n, i) {
  let s = 0
  for (let r = e, a = n - i; r < n; r += i)
    (s += (t[a] - t[r]) * (t[r + 1] + t[a + 1])), (a = r)
  return s
}
e(xd, 'linkedList'),
  e(bd, 'filterPoints'),
  e(wd, 'earcutLinked'),
  e(Md, 'isEar'),
  e(Sd, 'isEarHashed'),
  e(Td, 'cureLocalIntersections'),
  e(Ed, 'splitEarcut'),
  e(Ad, 'eliminateHoles'),
  e(Cd, 'compareX'),
  e(Rd, 'eliminateHole'),
  e(Pd, 'findHoleBridge'),
  e(Id, 'sectorContainsSector'),
  e(Ld, 'indexCurve'),
  e(Dd, 'sortLinked'),
  e(kd, 'zOrder'),
  e(Nd, 'getLeftmost'),
  e(Ud, 'pointInTriangle'),
  e(Bd, 'isValidDiagonal'),
  e(Od, 'area'),
  e(Fd, 'equals'),
  e(zd, 'intersects'),
  e(Vd, 'onSegment'),
  e(Hd, 'sign'),
  e(Gd, 'intersectsPolygon'),
  e(Wd, 'locallyInside'),
  e(jd, 'middleInside'),
  e(Xd, 'splitPolygon'),
  e(qd, 'insertNode'),
  e(Yd, 'removeNode'),
  e(Zd, 'Node'),
  e(Kd, 'signedArea')
class $d {
  static {
    e(this, 'ShapeUtils')
  }
  static area(t) {
    const e = t.length
    let n = 0
    for (let i = e - 1, s = 0; s < e; i = s++)
      n += t[i].x * t[s].y - t[s].x * t[i].y
    return 0.5 * n
  }
  static isClockWise(t) {
    return $d.area(t) < 0
  }
  static triangulateShape(t, e) {
    const n = [],
      i = [],
      s = []
    Jd(t), Qd(n, t)
    let r = t.length
    e.forEach(Jd)
    for (let o = 0; o < e.length; o++)
      i.push(r), (r += e[o].length), Qd(n, e[o])
    const a = _d.triangulate(n, i)
    for (let o = 0; o < a.length; o += 3) s.push(a.slice(o, o + 3))
    return s
  }
}
function Jd(t) {
  const e = t.length
  e > 2 && t[e - 1].equals(t[0]) && t.pop()
}
function Qd(t, e) {
  for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
}
e(Jd, 'removeDupEndPts'), e(Qd, 'addContour')
class tp extends Zr {
  static {
    e(this, 'ExtrudeGeometry')
  }
  constructor(
    t = new yd([
      new vi(0.5, 0.5),
      new vi(-0.5, 0.5),
      new vi(-0.5, -0.5),
      new vi(0.5, -0.5)
    ]),
    n = {}
  ) {
    super(),
      (this.type = 'ExtrudeGeometry'),
      (this.parameters = { shapes: t, options: n }),
      (t = Array.isArray(t) ? t : [t])
    const i = this,
      s = [],
      r = []
    for (let e = 0, o = t.length; e < o; e++) {
      a(t[e])
    }
    function a(t) {
      const a = [],
        o = void 0 !== n.curveSegments ? n.curveSegments : 12,
        l = void 0 !== n.steps ? n.steps : 1,
        c = void 0 !== n.depth ? n.depth : 1
      let h = void 0 === n.bevelEnabled || n.bevelEnabled,
        u = void 0 !== n.bevelThickness ? n.bevelThickness : 0.2,
        d = void 0 !== n.bevelSize ? n.bevelSize : u - 0.1,
        p = void 0 !== n.bevelOffset ? n.bevelOffset : 0,
        m = void 0 !== n.bevelSegments ? n.bevelSegments : 3
      const f = n.extrudePath,
        g = void 0 !== n.UVGenerator ? n.UVGenerator : ep
      let v,
        y,
        _,
        x,
        b,
        w = !1
      f &&
        ((v = f.getSpacedPoints(l)),
        (w = !0),
        (h = !1),
        (y = f.computeFrenetFrames(l, !1)),
        (_ = new Qi()),
        (x = new Qi()),
        (b = new Qi())),
        h || ((m = 0), (u = 0), (d = 0), (p = 0))
      const M = t.extractPoints(o)
      let S = M.shape
      const T = M.holes
      if (!$d.isClockWise(S)) {
        S = S.reverse()
        for (let t = 0, e = T.length; t < e; t++) {
          const e = T[t]
          $d.isClockWise(e) && (T[t] = e.reverse())
        }
      }
      const E = $d.triangulateShape(S, T),
        A = S
      for (let e = 0, n = T.length; e < n; e++) {
        const t = T[e]
        S = S.concat(t)
      }
      function C(t, e, n) {
        return (
          e || console.error('THREE.ExtrudeGeometry: vec does not exist'),
          t.clone().addScaledVector(e, n)
        )
      }
      e(C, 'scalePt2')
      const R = S.length,
        P = E.length
      function I(t, e, n) {
        let i, s, r
        const a = t.x - e.x,
          o = t.y - e.y,
          l = n.x - t.x,
          c = n.y - t.y,
          h = a * a + o * o,
          u = a * c - o * l
        if (Math.abs(u) > Number.EPSILON) {
          const u = Math.sqrt(h),
            d = Math.sqrt(l * l + c * c),
            p = e.x - o / u,
            m = e.y + a / u,
            f =
              ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (a * c - o * l)
          ;(i = p + a * f - t.x), (s = m + o * f - t.y)
          const g = i * i + s * s
          if (g <= 2) return new vi(i, s)
          r = Math.sqrt(g / 2)
        } else {
          let t = !1
          a > Number.EPSILON
            ? l > Number.EPSILON && (t = !0)
            : a < -Number.EPSILON
              ? l < -Number.EPSILON && (t = !0)
              : Math.sign(o) === Math.sign(c) && (t = !0),
            t
              ? ((i = -o), (s = a), (r = Math.sqrt(h)))
              : ((i = a), (s = o), (r = Math.sqrt(h / 2)))
        }
        return new vi(i / r, s / r)
      }
      e(I, 'getBevelVec')
      const L = []
      for (let e = 0, n = A.length, i = n - 1, s = e + 1; e < n; e++, i++, s++)
        i === n && (i = 0), s === n && (s = 0), (L[e] = I(A[e], A[i], A[s]))
      const D = []
      let k,
        N = L.concat()
      for (let e = 0, n = T.length; e < n; e++) {
        const t = T[e]
        k = []
        for (
          let e = 0, n = t.length, i = n - 1, s = e + 1;
          e < n;
          e++, i++, s++
        )
          i === n && (i = 0), s === n && (s = 0), (k[e] = I(t[e], t[i], t[s]))
        D.push(k), (N = N.concat(k))
      }
      for (let e = 0; e < m; e++) {
        const t = e / m,
          n = u * Math.cos((t * Math.PI) / 2),
          i = d * Math.sin((t * Math.PI) / 2) + p
        for (let e = 0, s = A.length; e < s; e++) {
          const t = C(A[e], L[e], i)
          z(t.x, t.y, -n)
        }
        for (let e = 0, s = T.length; e < s; e++) {
          const t = T[e]
          k = D[e]
          for (let e = 0, s = t.length; e < s; e++) {
            const s = C(t[e], k[e], i)
            z(s.x, s.y, -n)
          }
        }
      }
      const U = d + p
      for (let e = 0; e < R; e++) {
        const t = h ? C(S[e], N[e], U) : S[e]
        w
          ? (x.copy(y.normals[0]).multiplyScalar(t.x),
            _.copy(y.binormals[0]).multiplyScalar(t.y),
            b.copy(v[0]).add(x).add(_),
            z(b.x, b.y, b.z))
          : z(t.x, t.y, 0)
      }
      for (let e = 1; e <= l; e++)
        for (let t = 0; t < R; t++) {
          const n = h ? C(S[t], N[t], U) : S[t]
          w
            ? (x.copy(y.normals[e]).multiplyScalar(n.x),
              _.copy(y.binormals[e]).multiplyScalar(n.y),
              b.copy(v[e]).add(x).add(_),
              z(b.x, b.y, b.z))
            : z(n.x, n.y, (c / l) * e)
        }
      for (let e = m - 1; e >= 0; e--) {
        const t = e / m,
          n = u * Math.cos((t * Math.PI) / 2),
          i = d * Math.sin((t * Math.PI) / 2) + p
        for (let e = 0, s = A.length; e < s; e++) {
          const t = C(A[e], L[e], i)
          z(t.x, t.y, c + n)
        }
        for (let e = 0, s = T.length; e < s; e++) {
          const t = T[e]
          k = D[e]
          for (let e = 0, s = t.length; e < s; e++) {
            const s = C(t[e], k[e], i)
            w ? z(s.x, s.y + v[l - 1].y, v[l - 1].x + n) : z(s.x, s.y, c + n)
          }
        }
      }
      function B() {
        const t = s.length / 3
        if (h) {
          let t = 0,
            e = R * t
          for (let n = 0; n < P; n++) {
            const t = E[n]
            V(t[2] + e, t[1] + e, t[0] + e)
          }
          ;(t = l + 2 * m), (e = R * t)
          for (let n = 0; n < P; n++) {
            const t = E[n]
            V(t[0] + e, t[1] + e, t[2] + e)
          }
        } else {
          for (let t = 0; t < P; t++) {
            const e = E[t]
            V(e[2], e[1], e[0])
          }
          for (let t = 0; t < P; t++) {
            const e = E[t]
            V(e[0] + R * l, e[1] + R * l, e[2] + R * l)
          }
        }
        i.addGroup(t, s.length / 3 - t, 0)
      }
      function O() {
        const t = s.length / 3
        let e = 0
        F(A, e), (e += A.length)
        for (let n = 0, i = T.length; n < i; n++) {
          const t = T[n]
          F(t, e), (e += t.length)
        }
        i.addGroup(t, s.length / 3 - t, 1)
      }
      function F(t, e) {
        let n = t.length
        for (; --n >= 0; ) {
          const i = n
          let s = n - 1
          s < 0 && (s = t.length - 1)
          for (let t = 0, n = l + 2 * m; t < n; t++) {
            const n = R * t,
              r = R * (t + 1)
            H(e + i + n, e + s + n, e + s + r, e + i + r)
          }
        }
      }
      function z(t, e, n) {
        a.push(t), a.push(e), a.push(n)
      }
      function V(t, e, n) {
        G(t), G(e), G(n)
        const r = s.length / 3,
          a = g.generateTopUV(i, s, r - 3, r - 2, r - 1)
        W(a[0]), W(a[1]), W(a[2])
      }
      function H(t, e, n, r) {
        G(t), G(e), G(r), G(e), G(n), G(r)
        const a = s.length / 3,
          o = g.generateSideWallUV(i, s, a - 6, a - 3, a - 2, a - 1)
        W(o[0]), W(o[1]), W(o[3]), W(o[1]), W(o[2]), W(o[3])
      }
      function G(t) {
        s.push(a[3 * t + 0]), s.push(a[3 * t + 1]), s.push(a[3 * t + 2])
      }
      function W(t) {
        r.push(t.x), r.push(t.y)
      }
      B(),
        O(),
        e(B, 'buildLidFaces'),
        e(O, 'buildSideFaces'),
        e(F, 'sidewalls'),
        e(z, 'v'),
        e(V, 'f3'),
        e(H, 'f4'),
        e(G, 'addVertex'),
        e(W, 'addUV')
    }
    this.setAttribute('position', new Vr(s, 3)),
      this.setAttribute('uv', new Vr(r, 2)),
      this.computeVertexNormals(),
      e(a, 'addShape')
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return np(this.parameters.shapes, this.parameters.options, t)
  }
  static fromJSON(t, e) {
    const n = []
    for (let s = 0, r = t.shapes.length; s < r; s++) {
      const i = e[t.shapes[s]]
      n.push(i)
    }
    const i = t.options.extrudePath
    return (
      void 0 !== i && (t.options.extrudePath = new id[i.type]().fromJSON(i)),
      new tp(n, t.options)
    )
  }
}
const ep = {
  generateTopUV: e(function (t, e, n, i, s) {
    const r = e[3 * n],
      a = e[3 * n + 1],
      o = e[3 * i],
      l = e[3 * i + 1],
      c = e[3 * s],
      h = e[3 * s + 1]
    return [new vi(r, a), new vi(o, l), new vi(c, h)]
  }, 'generateTopUV'),
  generateSideWallUV: e(function (t, e, n, i, s, r) {
    const a = e[3 * n],
      o = e[3 * n + 1],
      l = e[3 * n + 2],
      c = e[3 * i],
      h = e[3 * i + 1],
      u = e[3 * i + 2],
      d = e[3 * s],
      p = e[3 * s + 1],
      m = e[3 * s + 2],
      f = e[3 * r],
      g = e[3 * r + 1],
      v = e[3 * r + 2]
    return Math.abs(o - h) < Math.abs(a - c)
      ? [new vi(a, 1 - l), new vi(c, 1 - u), new vi(d, 1 - m), new vi(f, 1 - v)]
      : [new vi(o, 1 - l), new vi(h, 1 - u), new vi(p, 1 - m), new vi(g, 1 - v)]
  }, 'generateSideWallUV')
}
function np(t, e, n) {
  if (((n.shapes = []), Array.isArray(t)))
    for (let i = 0, s = t.length; i < s; i++) {
      const e = t[i]
      n.shapes.push(e.uuid)
    }
  else n.shapes.push(t.uuid)
  return (
    (n.options = Object.assign({}, e)),
    void 0 !== e.extrudePath &&
      (n.options.extrudePath = e.extrudePath.toJSON()),
    n
  )
}
e(np, 'toJSON$1')
class ip extends ud {
  static {
    e(this, 'IcosahedronGeometry')
  }
  constructor(t = 1, e = 0) {
    const n = (1 + Math.sqrt(5)) / 2
    super(
      [
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        0,
        0,
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        n,
        0,
        -1,
        n,
        0,
        1,
        -n,
        0,
        -1,
        -n,
        0,
        1
      ],
      [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
      ],
      t,
      e
    ),
      (this.type = 'IcosahedronGeometry'),
      (this.parameters = { radius: t, detail: e })
  }
  static fromJSON(t) {
    return new ip(t.radius, t.detail)
  }
}
class sp extends ud {
  static {
    e(this, 'OctahedronGeometry')
  }
  constructor(t = 1, e = 0) {
    super(
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      t,
      e
    ),
      (this.type = 'OctahedronGeometry'),
      (this.parameters = { radius: t, detail: e })
  }
  static fromJSON(t) {
    return new sp(t.radius, t.detail)
  }
}
class rp extends Zr {
  static {
    e(this, 'RingGeometry')
  }
  constructor(t = 0.5, e = 1, n = 32, i = 1, s = 0, r = 2 * Math.PI) {
    super(),
      (this.type = 'RingGeometry'),
      (this.parameters = {
        innerRadius: t,
        outerRadius: e,
        thetaSegments: n,
        phiSegments: i,
        thetaStart: s,
        thetaLength: r
      }),
      (n = Math.max(3, n))
    const a = [],
      o = [],
      l = [],
      c = []
    let h = t
    const u = (e - t) / (i = Math.max(1, i)),
      d = new Qi(),
      p = new vi()
    for (let m = 0; m <= i; m++) {
      for (let t = 0; t <= n; t++) {
        const i = s + (t / n) * r
        ;(d.x = h * Math.cos(i)),
          (d.y = h * Math.sin(i)),
          o.push(d.x, d.y, d.z),
          l.push(0, 0, 1),
          (p.x = (d.x / e + 1) / 2),
          (p.y = (d.y / e + 1) / 2),
          c.push(p.x, p.y)
      }
      h += u
    }
    for (let m = 0; m < i; m++) {
      const t = m * (n + 1)
      for (let e = 0; e < n; e++) {
        const i = e + t,
          s = i,
          r = i + n + 1,
          o = i + n + 2,
          l = i + 1
        a.push(s, r, l), a.push(r, o, l)
      }
    }
    this.setIndex(a),
      this.setAttribute('position', new Vr(o, 3)),
      this.setAttribute('normal', new Vr(l, 3)),
      this.setAttribute('uv', new Vr(c, 2))
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  static fromJSON(t) {
    return new rp(
      t.innerRadius,
      t.outerRadius,
      t.thetaSegments,
      t.phiSegments,
      t.thetaStart,
      t.thetaLength
    )
  }
}
class ap extends Zr {
  static {
    e(this, 'ShapeGeometry')
  }
  constructor(
    t = new yd([new vi(0, 0.5), new vi(-0.5, -0.5), new vi(0.5, -0.5)]),
    n = 12
  ) {
    super(),
      (this.type = 'ShapeGeometry'),
      (this.parameters = { shapes: t, curveSegments: n })
    const i = [],
      s = [],
      r = [],
      a = []
    let o = 0,
      l = 0
    if (!1 === Array.isArray(t)) c(t)
    else
      for (let e = 0; e < t.length; e++)
        c(t[e]), this.addGroup(o, l, e), (o += l), (l = 0)
    function c(t) {
      const e = s.length / 3,
        o = t.extractPoints(n)
      let c = o.shape
      const h = o.holes
      !1 === $d.isClockWise(c) && (c = c.reverse())
      for (let n = 0, i = h.length; n < i; n++) {
        const t = h[n]
        !0 === $d.isClockWise(t) && (h[n] = t.reverse())
      }
      const u = $d.triangulateShape(c, h)
      for (let n = 0, i = h.length; n < i; n++) {
        const t = h[n]
        c = c.concat(t)
      }
      for (let n = 0, i = c.length; n < i; n++) {
        const t = c[n]
        s.push(t.x, t.y, 0), r.push(0, 0, 1), a.push(t.x, t.y)
      }
      for (let n = 0, s = u.length; n < s; n++) {
        const t = u[n],
          s = t[0] + e,
          r = t[1] + e,
          a = t[2] + e
        i.push(s, r, a), (l += 3)
      }
    }
    this.setIndex(i),
      this.setAttribute('position', new Vr(s, 3)),
      this.setAttribute('normal', new Vr(r, 3)),
      this.setAttribute('uv', new Vr(a, 2)),
      e(c, 'addShape')
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return op(this.parameters.shapes, t)
  }
  static fromJSON(t, e) {
    const n = []
    for (let i = 0, s = t.shapes.length; i < s; i++) {
      const s = e[t.shapes[i]]
      n.push(s)
    }
    return new ap(n, t.curveSegments)
  }
}
function op(t, e) {
  if (((e.shapes = []), Array.isArray(t)))
    for (let n = 0, i = t.length; n < i; n++) {
      const i = t[n]
      e.shapes.push(i.uuid)
    }
  else e.shapes.push(t.uuid)
  return e
}
e(op, 'toJSON')
class lp extends Zr {
  static {
    e(this, 'SphereGeometry')
  }
  constructor(
    t = 1,
    e = 32,
    n = 16,
    i = 0,
    s = 2 * Math.PI,
    r = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = 'SphereGeometry'),
      (this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: n,
        phiStart: i,
        phiLength: s,
        thetaStart: r,
        thetaLength: a
      }),
      (e = Math.max(3, Math.floor(e))),
      (n = Math.max(2, Math.floor(n)))
    const o = Math.min(r + a, Math.PI)
    let l = 0
    const c = [],
      h = new Qi(),
      u = new Qi(),
      d = [],
      p = [],
      m = [],
      f = []
    for (let g = 0; g <= n; g++) {
      const d = [],
        v = g / n
      let y = 0
      0 === g && 0 === r
        ? (y = 0.5 / e)
        : g === n && o === Math.PI && (y = -0.5 / e)
      for (let n = 0; n <= e; n++) {
        const o = n / e
        ;(h.x = -t * Math.cos(i + o * s) * Math.sin(r + v * a)),
          (h.y = t * Math.cos(r + v * a)),
          (h.z = t * Math.sin(i + o * s) * Math.sin(r + v * a)),
          p.push(h.x, h.y, h.z),
          u.copy(h).normalize(),
          m.push(u.x, u.y, u.z),
          f.push(o + y, 1 - v),
          d.push(l++)
      }
      c.push(d)
    }
    for (let g = 0; g < n; g++)
      for (let t = 0; t < e; t++) {
        const e = c[g][t + 1],
          i = c[g][t],
          s = c[g + 1][t],
          a = c[g + 1][t + 1]
        ;(0 !== g || r > 0) && d.push(e, i, a),
          (g !== n - 1 || o < Math.PI) && d.push(i, s, a)
      }
    this.setIndex(d),
      this.setAttribute('position', new Vr(p, 3)),
      this.setAttribute('normal', new Vr(m, 3)),
      this.setAttribute('uv', new Vr(f, 2))
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  static fromJSON(t) {
    return new lp(
      t.radius,
      t.widthSegments,
      t.heightSegments,
      t.phiStart,
      t.phiLength,
      t.thetaStart,
      t.thetaLength
    )
  }
}
class cp extends ud {
  static {
    e(this, 'TetrahedronGeometry')
  }
  constructor(t = 1, e = 0) {
    super(
      [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
      t,
      e
    ),
      (this.type = 'TetrahedronGeometry'),
      (this.parameters = { radius: t, detail: e })
  }
  static fromJSON(t) {
    return new cp(t.radius, t.detail)
  }
}
class hp extends Zr {
  static {
    e(this, 'TorusGeometry')
  }
  constructor(t = 1, e = 0.4, n = 12, i = 48, s = 2 * Math.PI) {
    super(),
      (this.type = 'TorusGeometry'),
      (this.parameters = {
        radius: t,
        tube: e,
        radialSegments: n,
        tubularSegments: i,
        arc: s
      }),
      (n = Math.floor(n)),
      (i = Math.floor(i))
    const r = [],
      a = [],
      o = [],
      l = [],
      c = new Qi(),
      h = new Qi(),
      u = new Qi()
    for (let d = 0; d <= n; d++)
      for (let r = 0; r <= i; r++) {
        const p = (r / i) * s,
          m = (d / n) * Math.PI * 2
        ;(h.x = (t + e * Math.cos(m)) * Math.cos(p)),
          (h.y = (t + e * Math.cos(m)) * Math.sin(p)),
          (h.z = e * Math.sin(m)),
          a.push(h.x, h.y, h.z),
          (c.x = t * Math.cos(p)),
          (c.y = t * Math.sin(p)),
          u.subVectors(h, c).normalize(),
          o.push(u.x, u.y, u.z),
          l.push(r / i),
          l.push(d / n)
      }
    for (let d = 1; d <= n; d++)
      for (let t = 1; t <= i; t++) {
        const e = (i + 1) * d + t - 1,
          n = (i + 1) * (d - 1) + t - 1,
          s = (i + 1) * (d - 1) + t,
          a = (i + 1) * d + t
        r.push(e, n, a), r.push(n, s, a)
      }
    this.setIndex(r),
      this.setAttribute('position', new Vr(a, 3)),
      this.setAttribute('normal', new Vr(o, 3)),
      this.setAttribute('uv', new Vr(l, 2))
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  static fromJSON(t) {
    return new hp(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc)
  }
}
class up extends Zr {
  static {
    e(this, 'TorusKnotGeometry')
  }
  constructor(t = 1, n = 0.4, i = 64, s = 8, r = 2, a = 3) {
    super(),
      (this.type = 'TorusKnotGeometry'),
      (this.parameters = {
        radius: t,
        tube: n,
        tubularSegments: i,
        radialSegments: s,
        p: r,
        q: a
      }),
      (i = Math.floor(i)),
      (s = Math.floor(s))
    const o = [],
      l = [],
      c = [],
      h = [],
      u = new Qi(),
      d = new Qi(),
      p = new Qi(),
      m = new Qi(),
      f = new Qi(),
      g = new Qi(),
      v = new Qi()
    for (let e = 0; e <= i; ++e) {
      const o = (e / i) * r * Math.PI * 2
      y(o, r, a, t, p),
        y(o + 0.01, r, a, t, m),
        g.subVectors(m, p),
        v.addVectors(m, p),
        f.crossVectors(g, v),
        v.crossVectors(f, g),
        f.normalize(),
        v.normalize()
      for (let t = 0; t <= s; ++t) {
        const r = (t / s) * Math.PI * 2,
          a = -n * Math.cos(r),
          o = n * Math.sin(r)
        ;(u.x = p.x + (a * v.x + o * f.x)),
          (u.y = p.y + (a * v.y + o * f.y)),
          (u.z = p.z + (a * v.z + o * f.z)),
          l.push(u.x, u.y, u.z),
          d.subVectors(u, p).normalize(),
          c.push(d.x, d.y, d.z),
          h.push(e / i),
          h.push(t / s)
      }
    }
    for (let e = 1; e <= i; e++)
      for (let t = 1; t <= s; t++) {
        const n = (s + 1) * (e - 1) + (t - 1),
          i = (s + 1) * e + (t - 1),
          r = (s + 1) * e + t,
          a = (s + 1) * (e - 1) + t
        o.push(n, i, a), o.push(i, r, a)
      }
    function y(t, e, n, i, s) {
      const r = Math.cos(t),
        a = Math.sin(t),
        o = (n / e) * t,
        l = Math.cos(o)
      ;(s.x = i * (2 + l) * 0.5 * r),
        (s.y = i * (2 + l) * a * 0.5),
        (s.z = i * Math.sin(o) * 0.5)
    }
    this.setIndex(o),
      this.setAttribute('position', new Vr(l, 3)),
      this.setAttribute('normal', new Vr(c, 3)),
      this.setAttribute('uv', new Vr(h, 2)),
      e(y, 'calculatePositionOnCurve')
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  static fromJSON(t) {
    return new up(
      t.radius,
      t.tube,
      t.tubularSegments,
      t.radialSegments,
      t.p,
      t.q
    )
  }
}
class dp extends Zr {
  static {
    e(this, 'TubeGeometry')
  }
  constructor(
    t = new ed(new Qi(-1, -1, 0), new Qi(-1, 1, 0), new Qi(1, 1, 0)),
    n = 64,
    i = 1,
    s = 8,
    r = !1
  ) {
    super(),
      (this.type = 'TubeGeometry'),
      (this.parameters = {
        path: t,
        tubularSegments: n,
        radius: i,
        radialSegments: s,
        closed: r
      })
    const a = t.computeFrenetFrames(n, r)
    ;(this.tangents = a.tangents),
      (this.normals = a.normals),
      (this.binormals = a.binormals)
    const o = new Qi(),
      l = new Qi(),
      c = new vi()
    let h = new Qi()
    const u = [],
      d = [],
      p = [],
      m = []
    function f() {
      for (let t = 0; t < n; t++) g(t)
      g(!1 === r ? n : 0), y(), v()
    }
    function g(e) {
      h = t.getPointAt(e / n, h)
      const r = a.normals[e],
        c = a.binormals[e]
      for (let t = 0; t <= s; t++) {
        const e = (t / s) * Math.PI * 2,
          n = Math.sin(e),
          a = -Math.cos(e)
        ;(l.x = a * r.x + n * c.x),
          (l.y = a * r.y + n * c.y),
          (l.z = a * r.z + n * c.z),
          l.normalize(),
          d.push(l.x, l.y, l.z),
          (o.x = h.x + i * l.x),
          (o.y = h.y + i * l.y),
          (o.z = h.z + i * l.z),
          u.push(o.x, o.y, o.z)
      }
    }
    function v() {
      for (let t = 1; t <= n; t++)
        for (let e = 1; e <= s; e++) {
          const n = (s + 1) * (t - 1) + (e - 1),
            i = (s + 1) * t + (e - 1),
            r = (s + 1) * t + e,
            a = (s + 1) * (t - 1) + e
          m.push(n, i, a), m.push(i, r, a)
        }
    }
    function y() {
      for (let t = 0; t <= n; t++)
        for (let e = 0; e <= s; e++)
          (c.x = t / n), (c.y = e / s), p.push(c.x, c.y)
    }
    f(),
      this.setIndex(m),
      this.setAttribute('position', new Vr(u, 3)),
      this.setAttribute('normal', new Vr(d, 3)),
      this.setAttribute('uv', new Vr(p, 2)),
      e(f, 'generateBufferData'),
      e(g, 'generateSegment'),
      e(v, 'generateIndices'),
      e(y, 'generateUVs')
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (t.path = this.parameters.path.toJSON()), t
  }
  static fromJSON(t) {
    return new dp(
      new id[t.path.type]().fromJSON(t.path),
      t.tubularSegments,
      t.radius,
      t.radialSegments,
      t.closed
    )
  }
}
class pp extends Zr {
  static {
    e(this, 'WireframeGeometry')
  }
  constructor(t = null) {
    if (
      (super(),
      (this.type = 'WireframeGeometry'),
      (this.parameters = { geometry: t }),
      null !== t)
    ) {
      const e = [],
        n = new Set(),
        i = new Qi(),
        s = new Qi()
      if (null !== t.index) {
        const r = t.attributes.position,
          a = t.index
        let o = t.groups
        0 === o.length && (o = [{ start: 0, count: a.count, materialIndex: 0 }])
        for (let t = 0, l = o.length; t < l; ++t) {
          const l = o[t],
            c = l.start
          for (let t = c, o = c + l.count; t < o; t += 3)
            for (let l = 0; l < 3; l++) {
              const o = a.getX(t + l),
                c = a.getX(t + ((l + 1) % 3))
              i.fromBufferAttribute(r, o),
                s.fromBufferAttribute(r, c),
                !0 === mp(i, s, n) &&
                  (e.push(i.x, i.y, i.z), e.push(s.x, s.y, s.z))
            }
        }
      } else {
        const r = t.attributes.position
        for (let t = 0, a = r.count / 3; t < a; t++)
          for (let o = 0; o < 3; o++) {
            const a = 3 * t + o,
              l = 3 * t + ((o + 1) % 3)
            i.fromBufferAttribute(r, a),
              s.fromBufferAttribute(r, l),
              !0 === mp(i, s, n) &&
                (e.push(i.x, i.y, i.z), e.push(s.x, s.y, s.z))
          }
      }
      this.setAttribute('position', new Vr(e, 3))
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
}
function mp(t, e, n) {
  const i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
    s = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`
  return !0 !== n.has(i) && !0 !== n.has(s) && (n.add(i), n.add(s), !0)
}
e(mp, 'isUniqueEdge')
var fp = Object.freeze({
  __proto__: null,
  BoxGeometry: ha,
  CapsuleGeometry: od,
  CircleGeometry: ld,
  ConeGeometry: hd,
  CylinderGeometry: cd,
  DodecahedronGeometry: dd,
  EdgesGeometry: vd,
  ExtrudeGeometry: tp,
  IcosahedronGeometry: ip,
  LatheGeometry: ad,
  OctahedronGeometry: sp,
  PlaneGeometry: Na,
  PolyhedronGeometry: ud,
  RingGeometry: rp,
  ShapeGeometry: ap,
  SphereGeometry: lp,
  TetrahedronGeometry: cp,
  TorusGeometry: hp,
  TorusKnotGeometry: up,
  TubeGeometry: dp,
  WireframeGeometry: pp
})
class gp extends Sr {
  static {
    e(this, 'ShadowMaterial')
  }
  static get type() {
    return 'ShadowMaterial'
  }
  constructor(t) {
    super(),
      (this.isShadowMaterial = !0),
      (this.color = new br(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), (this.fog = t.fog), this
  }
}
class vp extends ga {
  static {
    e(this, 'RawShaderMaterial')
  }
  static get type() {
    return 'RawShaderMaterial'
  }
  constructor(t) {
    super(t), (this.isRawShaderMaterial = !0)
  }
}
class yp extends Sr {
  static {
    e(this, 'MeshStandardMaterial')
  }
  static get type() {
    return 'MeshStandardMaterial'
  }
  constructor(t) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: '' }),
      (this.color = new br(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new br(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new vi(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Fs()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = { STANDARD: '' }),
      this.color.copy(t.color),
      (this.roughness = t.roughness),
      (this.metalness = t.metalness),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.roughnessMap = t.roughnessMap),
      (this.metalnessMap = t.metalnessMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      this.envMapRotation.copy(t.envMapRotation),
      (this.envMapIntensity = t.envMapIntensity),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      (this.fog = t.fog),
      this
    )
  }
}
class _p extends yp {
  static {
    e(this, 'MeshPhysicalMaterial')
  }
  static get type() {
    return 'MeshPhysicalMaterial'
  }
  constructor(t) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new vi(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, 'reflectivity', {
        get: e(function () {
          return Zn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1)
        }, 'get'),
        set: e(function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t)
        }, 'set')
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new br(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new br(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new br(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(t)
  }
  get anisotropy() {
    return this._anisotropy
  }
  set anisotropy(t) {
    this._anisotropy > 0 != t > 0 && this.version++, (this._anisotropy = t)
  }
  get clearcoat() {
    return this._clearcoat
  }
  set clearcoat(t) {
    this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t)
  }
  get iridescence() {
    return this._iridescence
  }
  set iridescence(t) {
    this._iridescence > 0 != t > 0 && this.version++, (this._iridescence = t)
  }
  get dispersion() {
    return this._dispersion
  }
  set dispersion(t) {
    this._dispersion > 0 != t > 0 && this.version++, (this._dispersion = t)
  }
  get sheen() {
    return this._sheen
  }
  set sheen(t) {
    this._sheen > 0 != t > 0 && this.version++, (this._sheen = t)
  }
  get transmission() {
    return this._transmission
  }
  set transmission(t) {
    this._transmission > 0 != t > 0 && this.version++, (this._transmission = t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.anisotropy = t.anisotropy),
      (this.anisotropyRotation = t.anisotropyRotation),
      (this.anisotropyMap = t.anisotropyMap),
      (this.clearcoat = t.clearcoat),
      (this.clearcoatMap = t.clearcoatMap),
      (this.clearcoatRoughness = t.clearcoatRoughness),
      (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = t.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
      (this.dispersion = t.dispersion),
      (this.ior = t.ior),
      (this.iridescence = t.iridescence),
      (this.iridescenceMap = t.iridescenceMap),
      (this.iridescenceIOR = t.iridescenceIOR),
      (this.iridescenceThicknessRange = [...t.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = t.iridescenceThicknessMap),
      (this.sheen = t.sheen),
      this.sheenColor.copy(t.sheenColor),
      (this.sheenColorMap = t.sheenColorMap),
      (this.sheenRoughness = t.sheenRoughness),
      (this.sheenRoughnessMap = t.sheenRoughnessMap),
      (this.transmission = t.transmission),
      (this.transmissionMap = t.transmissionMap),
      (this.thickness = t.thickness),
      (this.thicknessMap = t.thicknessMap),
      (this.attenuationDistance = t.attenuationDistance),
      this.attenuationColor.copy(t.attenuationColor),
      (this.specularIntensity = t.specularIntensity),
      (this.specularIntensityMap = t.specularIntensityMap),
      this.specularColor.copy(t.specularColor),
      (this.specularColorMap = t.specularColorMap),
      this
    )
  }
}
class xp extends Sr {
  static {
    e(this, 'MeshPhongMaterial')
  }
  static get type() {
    return 'MeshPhongMaterial'
  }
  constructor(t) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.color = new br(16777215)),
      (this.specular = new br(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new br(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new vi(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Fs()),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      this.specular.copy(t.specular),
      (this.shininess = t.shininess),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      this.envMapRotation.copy(t.envMapRotation),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      (this.fog = t.fog),
      this
    )
  }
}
class bp extends Sr {
  static {
    e(this, 'MeshToonMaterial')
  }
  static get type() {
    return 'MeshToonMaterial'
  }
  constructor(t) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: '' }),
      (this.color = new br(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new br(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new vi(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.gradientMap = t.gradientMap),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.alphaMap = t.alphaMap),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.fog = t.fog),
      this
    )
  }
}
class wp extends Sr {
  static {
    e(this, 'MeshNormalMaterial')
  }
  static get type() {
    return 'MeshNormalMaterial'
  }
  constructor(t) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new vi(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.flatShading = t.flatShading),
      this
    )
  }
}
class Mp extends Sr {
  static {
    e(this, 'MeshLambertMaterial')
  }
  static get type() {
    return 'MeshLambertMaterial'
  }
  constructor(t) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.color = new br(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new br(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new vi(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Fs()),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      this.envMapRotation.copy(t.envMapRotation),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      (this.fog = t.fog),
      this
    )
  }
}
class Sp extends Sr {
  static {
    e(this, 'MeshMatcapMaterial')
  }
  static get type() {
    return 'MeshMatcapMaterial'
  }
  constructor(t) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: '' }),
      (this.color = new br(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new vi(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = { MATCAP: '' }),
      this.color.copy(t.color),
      (this.matcap = t.matcap),
      (this.map = t.map),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.alphaMap = t.alphaMap),
      (this.flatShading = t.flatShading),
      (this.fog = t.fog),
      this
    )
  }
}
class Tp extends su {
  static {
    e(this, 'LineDashedMaterial')
  }
  static get type() {
    return 'LineDashedMaterial'
  }
  constructor(t) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.scale = t.scale),
      (this.dashSize = t.dashSize),
      (this.gapSize = t.gapSize),
      this
    )
  }
}
function Ep(t, e, n) {
  return !t || (!n && t.constructor === e)
    ? t
    : 'number' == typeof e.BYTES_PER_ELEMENT
      ? new e(t)
      : Array.prototype.slice.call(t)
}
function Ap(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView)
}
function Cp(t) {
  function n(e, n) {
    return t[e] - t[n]
  }
  e(n, 'compareTime')
  const i = t.length,
    s = new Array(i)
  for (let e = 0; e !== i; ++e) s[e] = e
  return s.sort(n), s
}
function Rp(t, e, n) {
  const i = t.length,
    s = new t.constructor(i)
  for (let r = 0, a = 0; a !== i; ++r) {
    const i = n[r] * e
    for (let n = 0; n !== e; ++n) s[a++] = t[i + n]
  }
  return s
}
function Pp(t, e, n, i) {
  let s = 1,
    r = t[0]
  for (; void 0 !== r && void 0 === r[i]; ) r = t[s++]
  if (void 0 === r) return
  let a = r[i]
  if (void 0 !== a)
    if (Array.isArray(a))
      do {
        ;(a = r[i]),
          void 0 !== a && (e.push(r.time), n.push.apply(n, a)),
          (r = t[s++])
      } while (void 0 !== r)
    else if (void 0 !== a.toArray)
      do {
        ;(a = r[i]),
          void 0 !== a && (e.push(r.time), a.toArray(n, n.length)),
          (r = t[s++])
      } while (void 0 !== r)
    else
      do {
        ;(a = r[i]), void 0 !== a && (e.push(r.time), n.push(a)), (r = t[s++])
      } while (void 0 !== r)
}
function Ip(t, e, n, i, s = 30) {
  const r = t.clone()
  r.name = e
  const a = []
  for (let l = 0; l < r.tracks.length; ++l) {
    const t = r.tracks[l],
      e = t.getValueSize(),
      o = [],
      c = []
    for (let r = 0; r < t.times.length; ++r) {
      const a = t.times[r] * s
      if (!(a < n || a >= i)) {
        o.push(t.times[r])
        for (let n = 0; n < e; ++n) c.push(t.values[r * e + n])
      }
    }
    0 !== o.length &&
      ((t.times = Ep(o, t.times.constructor)),
      (t.values = Ep(c, t.values.constructor)),
      a.push(t))
  }
  r.tracks = a
  let o = 1 / 0
  for (let l = 0; l < r.tracks.length; ++l)
    o > r.tracks[l].times[0] && (o = r.tracks[l].times[0])
  for (let l = 0; l < r.tracks.length; ++l) r.tracks[l].shift(-1 * o)
  return r.resetDuration(), r
}
function Lp(t, e = 0, n = t, i = 30) {
  i <= 0 && (i = 30)
  const s = n.tracks.length,
    r = e / i
  for (let a = 0; a < s; ++a) {
    const e = n.tracks[a],
      i = e.ValueTypeName
    if ('bool' === i || 'string' === i) continue
    const s = t.tracks.find(function (t) {
      return t.name === e.name && t.ValueTypeName === i
    })
    if (void 0 === s) continue
    let o = 0
    const l = e.getValueSize()
    e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3)
    let c = 0
    const h = s.getValueSize()
    s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3)
    const u = e.times.length - 1
    let d
    if (r <= e.times[0]) {
      const t = o,
        n = l - o
      d = e.values.slice(t, n)
    } else if (r >= e.times[u]) {
      const t = u * l + o,
        n = t + l - o
      d = e.values.slice(t, n)
    } else {
      const t = e.createInterpolant(),
        n = o,
        i = l - o
      t.evaluate(r), (d = t.resultBuffer.slice(n, i))
    }
    if ('quaternion' === i) {
      new Ji().fromArray(d).normalize().conjugate().toArray(d)
    }
    const p = s.times.length
    for (let t = 0; t < p; ++t) {
      const e = t * h + c
      if ('quaternion' === i)
        Ji.multiplyQuaternionsFlat(s.values, e, d, 0, s.values, e)
      else {
        const t = h - 2 * c
        for (let n = 0; n < t; ++n) s.values[e + n] -= d[n]
      }
    }
  }
  return (t.blendMode = 2501), t
}
e(Ep, 'convertArray'),
  e(Ap, 'isTypedArray'),
  e(Cp, 'getKeyframeOrder'),
  e(Rp, 'sortedArray'),
  e(Pp, 'flattenJSON'),
  e(Ip, 'subclip'),
  e(Lp, 'makeClipAdditive')
class Dp {
  static {
    e(this, 'Interpolant')
  }
  constructor(t, e, n, i) {
    ;(this.parameterPositions = t),
      (this._cachedIndex = 0),
      (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
      (this.sampleValues = e),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {})
  }
  evaluate(t) {
    const e = this.parameterPositions
    let n = this._cachedIndex,
      i = e[n],
      s = e[n - 1]
    t: {
      e: {
        let r
        n: {
          i: if (!(t < i)) {
            for (let r = n + 2; ; ) {
              if (void 0 === i) {
                if (t < s) break i
                return (
                  (n = e.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                )
              }
              if (n === r) break
              if (((s = i), (i = e[++n]), t < i)) break e
            }
            r = e.length
            break n
          }
          if (t >= s) break t
          {
            const a = e[1]
            t < a && ((n = 2), (s = a))
            for (let r = n - 2; ; ) {
              if (void 0 === s)
                return (this._cachedIndex = 0), this.copySampleValue_(0)
              if (n === r) break
              if (((i = s), (s = e[--n - 1]), t >= s)) break e
            }
            ;(r = n), (n = 0)
          }
        }
        for (; n < r; ) {
          const i = (n + r) >>> 1
          t < e[i] ? (r = i) : (n = i + 1)
        }
        if (((i = e[n]), (s = e[n - 1]), void 0 === s))
          return (this._cachedIndex = 0), this.copySampleValue_(0)
        if (void 0 === i)
          return (
            (n = e.length),
            (this._cachedIndex = n),
            this.copySampleValue_(n - 1)
          )
      }
      ;(this._cachedIndex = n), this.intervalChanged_(n, s, i)
    }
    return this.interpolate_(n, s, t, i)
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_
  }
  copySampleValue_(t) {
    const e = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      s = t * i
    for (let r = 0; r !== i; ++r) e[r] = n[s + r]
    return e
  }
  interpolate_() {
    throw new Error('call to abstract method')
  }
  intervalChanged_() {}
}
class kp extends Dp {
  static {
    e(this, 'CubicInterpolant')
  }
  constructor(t, e, n, i) {
    super(t, e, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: xn, endingEnd: xn })
  }
  intervalChanged_(t, e, n) {
    const i = this.parameterPositions
    let s = t - 2,
      r = t + 1,
      a = i[s],
      o = i[r]
    if (void 0 === a)
      switch (this.getSettings_().endingStart) {
        case bn:
          ;(s = t), (a = 2 * e - n)
          break
        case wn:
          ;(s = i.length - 2), (a = e + i[s] - i[s + 1])
          break
        default:
          ;(s = t), (a = n)
      }
    if (void 0 === o)
      switch (this.getSettings_().endingEnd) {
        case bn:
          ;(r = t), (o = 2 * n - e)
          break
        case wn:
          ;(r = 1), (o = n + i[1] - i[0])
          break
        default:
          ;(r = t - 1), (o = e)
      }
    const l = 0.5 * (n - e),
      c = this.valueSize
    ;(this._weightPrev = l / (e - a)),
      (this._weightNext = l / (o - n)),
      (this._offsetPrev = s * c),
      (this._offsetNext = r * c)
  }
  interpolate_(t, e, n, i) {
    const s = this.resultBuffer,
      r = this.sampleValues,
      a = this.valueSize,
      o = t * a,
      l = o - a,
      c = this._offsetPrev,
      h = this._offsetNext,
      u = this._weightPrev,
      d = this._weightNext,
      p = (n - e) / (i - e),
      m = p * p,
      f = m * p,
      g = -u * f + 2 * u * m - u * p,
      v = (1 + u) * f + (-1.5 - 2 * u) * m + (-0.5 + u) * p + 1,
      y = (-1 - d) * f + (1.5 + d) * m + 0.5 * p,
      _ = d * f - d * m
    for (let x = 0; x !== a; ++x)
      s[x] = g * r[c + x] + v * r[l + x] + y * r[o + x] + _ * r[h + x]
    return s
  }
}
class Np extends Dp {
  static {
    e(this, 'LinearInterpolant')
  }
  constructor(t, e, n, i) {
    super(t, e, n, i)
  }
  interpolate_(t, e, n, i) {
    const s = this.resultBuffer,
      r = this.sampleValues,
      a = this.valueSize,
      o = t * a,
      l = o - a,
      c = (n - e) / (i - e),
      h = 1 - c
    for (let u = 0; u !== a; ++u) s[u] = r[l + u] * h + r[o + u] * c
    return s
  }
}
class Up extends Dp {
  static {
    e(this, 'DiscreteInterpolant')
  }
  constructor(t, e, n, i) {
    super(t, e, n, i)
  }
  interpolate_(t) {
    return this.copySampleValue_(t - 1)
  }
}
class Bp {
  static {
    e(this, 'KeyframeTrack')
  }
  constructor(t, e, n, i) {
    if (void 0 === t)
      throw new Error('THREE.KeyframeTrack: track name is undefined')
    if (void 0 === e || 0 === e.length)
      throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + t)
    ;(this.name = t),
      (this.times = Ep(e, this.TimeBufferType)),
      (this.values = Ep(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation)
  }
  static toJSON(t) {
    const e = t.constructor
    let n
    if (e.toJSON !== this.toJSON) n = e.toJSON(t)
    else {
      n = {
        name: t.name,
        times: Ep(t.times, Array),
        values: Ep(t.values, Array)
      }
      const e = t.getInterpolation()
      e !== t.DefaultInterpolation && (n.interpolation = e)
    }
    return (n.type = t.ValueTypeName), n
  }
  InterpolantFactoryMethodDiscrete(t) {
    return new Up(this.times, this.values, this.getValueSize(), t)
  }
  InterpolantFactoryMethodLinear(t) {
    return new Np(this.times, this.values, this.getValueSize(), t)
  }
  InterpolantFactoryMethodSmooth(t) {
    return new kp(this.times, this.values, this.getValueSize(), t)
  }
  setInterpolation(t) {
    let e
    switch (t) {
      case vn:
        e = this.InterpolantFactoryMethodDiscrete
        break
      case yn:
        e = this.InterpolantFactoryMethodLinear
        break
      case _n:
        e = this.InterpolantFactoryMethodSmooth
    }
    if (void 0 === e) {
      const e =
        'unsupported interpolation for ' +
        this.ValueTypeName +
        ' keyframe track named ' +
        this.name
      if (void 0 === this.createInterpolant) {
        if (t === this.DefaultInterpolation) throw new Error(e)
        this.setInterpolation(this.DefaultInterpolation)
      }
      return console.warn('THREE.KeyframeTrack:', e), this
    }
    return (this.createInterpolant = e), this
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return vn
      case this.InterpolantFactoryMethodLinear:
        return yn
      case this.InterpolantFactoryMethodSmooth:
        return _n
    }
  }
  getValueSize() {
    return this.values.length / this.times.length
  }
  shift(t) {
    if (0 !== t) {
      const e = this.times
      for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
    }
    return this
  }
  scale(t) {
    if (1 !== t) {
      const e = this.times
      for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
    }
    return this
  }
  trim(t, e) {
    const n = this.times,
      i = n.length
    let s = 0,
      r = i - 1
    for (; s !== i && n[s] < t; ) ++s
    for (; -1 !== r && n[r] > e; ) --r
    if ((++r, 0 !== s || r !== i)) {
      s >= r && ((r = Math.max(r, 1)), (s = r - 1))
      const t = this.getValueSize()
      ;(this.times = n.slice(s, r)),
        (this.values = this.values.slice(s * t, r * t))
    }
    return this
  }
  validate() {
    let t = !0
    const e = this.getValueSize()
    e - Math.floor(e) != 0 &&
      (console.error('THREE.KeyframeTrack: Invalid value size in track.', this),
      (t = !1))
    const n = this.times,
      i = this.values,
      s = n.length
    0 === s &&
      (console.error('THREE.KeyframeTrack: Track is empty.', this), (t = !1))
    let r = null
    for (let a = 0; a !== s; a++) {
      const e = n[a]
      if ('number' == typeof e && isNaN(e)) {
        console.error(
          'THREE.KeyframeTrack: Time is not a valid number.',
          this,
          a,
          e
        ),
          (t = !1)
        break
      }
      if (null !== r && r > e) {
        console.error('THREE.KeyframeTrack: Out of order keys.', this, a, e, r),
          (t = !1)
        break
      }
      r = e
    }
    if (void 0 !== i && Ap(i))
      for (let a = 0, o = i.length; a !== o; ++a) {
        const e = i[a]
        if (isNaN(e)) {
          console.error(
            'THREE.KeyframeTrack: Value is not a valid number.',
            this,
            a,
            e
          ),
            (t = !1)
          break
        }
      }
    return t
  }
  optimize() {
    const t = this.times.slice(),
      e = this.values.slice(),
      n = this.getValueSize(),
      i = this.getInterpolation() === _n,
      s = t.length - 1
    let r = 1
    for (let a = 1; a < s; ++a) {
      let s = !1
      const o = t[a]
      if (o !== t[a + 1] && (1 !== a || o !== t[0]))
        if (i) s = !0
        else {
          const t = a * n,
            i = t - n,
            r = t + n
          for (let a = 0; a !== n; ++a) {
            const n = e[t + a]
            if (n !== e[i + a] || n !== e[r + a]) {
              s = !0
              break
            }
          }
        }
      if (s) {
        if (a !== r) {
          t[r] = t[a]
          const i = a * n,
            s = r * n
          for (let t = 0; t !== n; ++t) e[s + t] = e[i + t]
        }
        ++r
      }
    }
    if (s > 0) {
      t[r] = t[s]
      for (let t = s * n, i = r * n, a = 0; a !== n; ++a) e[i + a] = e[t + a]
      ++r
    }
    return (
      r !== t.length
        ? ((this.times = t.slice(0, r)), (this.values = e.slice(0, r * n)))
        : ((this.times = t), (this.values = e)),
      this
    )
  }
  clone() {
    const t = this.times.slice(),
      e = this.values.slice(),
      n = new (0, this.constructor)(this.name, t, e)
    return (n.createInterpolant = this.createInterpolant), n
  }
}
;(Bp.prototype.TimeBufferType = Float32Array),
  (Bp.prototype.ValueBufferType = Float32Array),
  (Bp.prototype.DefaultInterpolation = yn)
class Op extends Bp {
  static {
    e(this, 'BooleanKeyframeTrack')
  }
  constructor(t, e, n) {
    super(t, e, n)
  }
}
;(Op.prototype.ValueTypeName = 'bool'),
  (Op.prototype.ValueBufferType = Array),
  (Op.prototype.DefaultInterpolation = vn),
  (Op.prototype.InterpolantFactoryMethodLinear = void 0),
  (Op.prototype.InterpolantFactoryMethodSmooth = void 0)
class Fp extends Bp {
  static {
    e(this, 'ColorKeyframeTrack')
  }
}
Fp.prototype.ValueTypeName = 'color'
class zp extends Bp {
  static {
    e(this, 'NumberKeyframeTrack')
  }
}
zp.prototype.ValueTypeName = 'number'
class Vp extends Dp {
  static {
    e(this, 'QuaternionLinearInterpolant')
  }
  constructor(t, e, n, i) {
    super(t, e, n, i)
  }
  interpolate_(t, e, n, i) {
    const s = this.resultBuffer,
      r = this.sampleValues,
      a = this.valueSize,
      o = (n - e) / (i - e)
    let l = t * a
    for (let c = l + a; l !== c; l += 4) Ji.slerpFlat(s, 0, r, l - a, r, l, o)
    return s
  }
}
class Hp extends Bp {
  static {
    e(this, 'QuaternionKeyframeTrack')
  }
  InterpolantFactoryMethodLinear(t) {
    return new Vp(this.times, this.values, this.getValueSize(), t)
  }
}
;(Hp.prototype.ValueTypeName = 'quaternion'),
  (Hp.prototype.InterpolantFactoryMethodSmooth = void 0)
class Gp extends Bp {
  static {
    e(this, 'StringKeyframeTrack')
  }
  constructor(t, e, n) {
    super(t, e, n)
  }
}
;(Gp.prototype.ValueTypeName = 'string'),
  (Gp.prototype.ValueBufferType = Array),
  (Gp.prototype.DefaultInterpolation = vn),
  (Gp.prototype.InterpolantFactoryMethodLinear = void 0),
  (Gp.prototype.InterpolantFactoryMethodSmooth = void 0)
class Wp extends Bp {
  static {
    e(this, 'VectorKeyframeTrack')
  }
}
Wp.prototype.ValueTypeName = 'vector'
class jp {
  static {
    e(this, 'AnimationClip')
  }
  constructor(t = '', e = -1, n = [], i = 2500) {
    ;(this.name = t),
      (this.tracks = n),
      (this.duration = e),
      (this.blendMode = i),
      (this.uuid = Yn()),
      this.duration < 0 && this.resetDuration()
  }
  static parse(t) {
    const e = [],
      n = t.tracks,
      i = 1 / (t.fps || 1)
    for (let r = 0, a = n.length; r !== a; ++r) e.push(qp(n[r]).scale(i))
    const s = new this(t.name, t.duration, e, t.blendMode)
    return (s.uuid = t.uuid), s
  }
  static toJSON(t) {
    const e = [],
      n = t.tracks,
      i = {
        name: t.name,
        duration: t.duration,
        tracks: e,
        uuid: t.uuid,
        blendMode: t.blendMode
      }
    for (let s = 0, r = n.length; s !== r; ++s) e.push(Bp.toJSON(n[s]))
    return i
  }
  static CreateFromMorphTargetSequence(t, e, n, i) {
    const s = e.length,
      r = []
    for (let a = 0; a < s; a++) {
      let t = [],
        o = []
      t.push((a + s - 1) % s, a, (a + 1) % s), o.push(0, 1, 0)
      const l = Cp(t)
      ;(t = Rp(t, 1, l)),
        (o = Rp(o, 1, l)),
        i || 0 !== t[0] || (t.push(s), o.push(o[0])),
        r.push(
          new zp('.morphTargetInfluences[' + e[a].name + ']', t, o).scale(1 / n)
        )
    }
    return new this(t, -1, r)
  }
  static findByName(t, e) {
    let n = t
    if (!Array.isArray(t)) {
      const e = t
      n = (e.geometry && e.geometry.animations) || e.animations
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === e) return n[i]
    return null
  }
  static CreateClipsFromMorphTargetSequences(t, e, n) {
    const i = {},
      s = /^([\w-]*?)([\d]+)$/
    for (let a = 0, o = t.length; a < o; a++) {
      const e = t[a],
        n = e.name.match(s)
      if (n && n.length > 1) {
        const t = n[1]
        let s = i[t]
        s || (i[t] = s = []), s.push(e)
      }
    }
    const r = []
    for (const a in i) r.push(this.CreateFromMorphTargetSequence(a, i[a], e, n))
    return r
  }
  static parseAnimation(t, n) {
    if (!t)
      return (
        console.error('THREE.AnimationClip: No animation in JSONLoader data.'),
        null
      )
    const i = e(function (t, e, n, i, s) {
        if (0 !== n.length) {
          const r = [],
            a = []
          Pp(n, r, a, i), 0 !== r.length && s.push(new t(e, r, a))
        }
      }, 'addNonemptyTrack'),
      s = [],
      r = t.name || 'default',
      a = t.fps || 30,
      o = t.blendMode
    let l = t.length || -1
    const c = t.hierarchy || []
    for (let e = 0; e < c.length; e++) {
      const t = c[e].keys
      if (t && 0 !== t.length)
        if (t[0].morphTargets) {
          const e = {}
          let n
          for (n = 0; n < t.length; n++)
            if (t[n].morphTargets)
              for (let i = 0; i < t[n].morphTargets.length; i++)
                e[t[n].morphTargets[i]] = -1
          for (const i in e) {
            const e = [],
              r = []
            for (let s = 0; s !== t[n].morphTargets.length; ++s) {
              const s = t[n]
              e.push(s.time), r.push(s.morphTarget === i ? 1 : 0)
            }
            s.push(new zp('.morphTargetInfluence[' + i + ']', e, r))
          }
          l = e.length * a
        } else {
          const r = '.bones[' + n[e].name + ']'
          i(Wp, r + '.position', t, 'pos', s),
            i(Hp, r + '.quaternion', t, 'rot', s),
            i(Wp, r + '.scale', t, 'scl', s)
        }
    }
    if (0 === s.length) return null
    return new this(r, l, s, o)
  }
  resetDuration() {
    let t = 0
    for (let e = 0, n = this.tracks.length; e !== n; ++e) {
      const n = this.tracks[e]
      t = Math.max(t, n.times[n.times.length - 1])
    }
    return (this.duration = t), this
  }
  trim() {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].trim(0, this.duration)
    return this
  }
  validate() {
    let t = !0
    for (let e = 0; e < this.tracks.length; e++)
      t = t && this.tracks[e].validate()
    return t
  }
  optimize() {
    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize()
    return this
  }
  clone() {
    const t = []
    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone())
    return new this.constructor(this.name, this.duration, t, this.blendMode)
  }
  toJSON() {
    return this.constructor.toJSON(this)
  }
}
function Xp(t) {
  switch (t.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return zp
    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return Wp
    case 'color':
      return Fp
    case 'quaternion':
      return Hp
    case 'bool':
    case 'boolean':
      return Op
    case 'string':
      return Gp
  }
  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + t)
}
function qp(t) {
  if (void 0 === t.type)
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse')
  const e = Xp(t.type)
  if (void 0 === t.times) {
    const e = [],
      n = []
    Pp(t.keys, e, n, 'value'), (t.times = e), (t.values = n)
  }
  return void 0 !== e.parse
    ? e.parse(t)
    : new e(t.name, t.times, t.values, t.interpolation)
}
e(Xp, 'getTrackTypeForValueTypeName'), e(qp, 'parseKeyframeTrack')
const Yp = {
  enabled: !1,
  files: {},
  add: e(function (t, e) {
    !1 !== this.enabled && (this.files[t] = e)
  }, 'add'),
  get: e(function (t) {
    if (!1 !== this.enabled) return this.files[t]
  }, 'get'),
  remove: e(function (t) {
    delete this.files[t]
  }, 'remove'),
  clear: e(function () {
    this.files = {}
  }, 'clear')
}
class Zp {
  static {
    e(this, 'LoadingManager')
  }
  constructor(t, e, n) {
    const i = this
    let s,
      r = !1,
      a = 0,
      o = 0
    const l = []
    ;(this.onStart = void 0),
      (this.onLoad = t),
      (this.onProgress = e),
      (this.onError = n),
      (this.itemStart = function (t) {
        o++, !1 === r && void 0 !== i.onStart && i.onStart(t, a, o), (r = !0)
      }),
      (this.itemEnd = function (t) {
        a++,
          void 0 !== i.onProgress && i.onProgress(t, a, o),
          a === o && ((r = !1), void 0 !== i.onLoad && i.onLoad())
      }),
      (this.itemError = function (t) {
        void 0 !== i.onError && i.onError(t)
      }),
      (this.resolveURL = function (t) {
        return s ? s(t) : t
      }),
      (this.setURLModifier = function (t) {
        return (s = t), this
      }),
      (this.addHandler = function (t, e) {
        return l.push(t, e), this
      }),
      (this.removeHandler = function (t) {
        const e = l.indexOf(t)
        return -1 !== e && l.splice(e, 2), this
      }),
      (this.getHandler = function (t) {
        for (let e = 0, n = l.length; e < n; e += 2) {
          const n = l[e],
            i = l[e + 1]
          if ((n.global && (n.lastIndex = 0), n.test(t))) return i
        }
        return null
      })
  }
}
const Kp = new Zp()
class $p {
  static {
    e(this, 'Loader')
  }
  constructor(t) {
    ;(this.manager = void 0 !== t ? t : Kp),
      (this.crossOrigin = 'anonymous'),
      (this.withCredentials = !1),
      (this.path = ''),
      (this.resourcePath = ''),
      (this.requestHeader = {})
  }
  load() {}
  loadAsync(t, e) {
    const n = this
    return new Promise(function (i, s) {
      n.load(t, i, e, s)
    })
  }
  parse() {}
  setCrossOrigin(t) {
    return (this.crossOrigin = t), this
  }
  setWithCredentials(t) {
    return (this.withCredentials = t), this
  }
  setPath(t) {
    return (this.path = t), this
  }
  setResourcePath(t) {
    return (this.resourcePath = t), this
  }
  setRequestHeader(t) {
    return (this.requestHeader = t), this
  }
}
$p.DEFAULT_MATERIAL_NAME = '__DEFAULT'
const Jp = {}
class Qp extends Error {
  static {
    e(this, 'HttpError')
  }
  constructor(t, e) {
    super(t), (this.response = e)
  }
}
class tm extends $p {
  static {
    e(this, 'FileLoader')
  }
  constructor(t) {
    super(t)
  }
  load(t, n, i, s) {
    void 0 === t && (t = ''),
      void 0 !== this.path && (t = this.path + t),
      (t = this.manager.resolveURL(t))
    const r = Yp.get(t)
    if (void 0 !== r)
      return (
        this.manager.itemStart(t),
        setTimeout(() => {
          n && n(r), this.manager.itemEnd(t)
        }, 0),
        r
      )
    if (void 0 !== Jp[t])
      return void Jp[t].push({ onLoad: n, onProgress: i, onError: s })
    ;(Jp[t] = []), Jp[t].push({ onLoad: n, onProgress: i, onError: s })
    const a = new Request(t, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? 'include' : 'same-origin'
      }),
      o = this.mimeType,
      l = this.responseType
    fetch(a)
      .then((n) => {
        if (200 === n.status || 0 === n.status) {
          if (
            (0 === n.status &&
              console.warn('THREE.FileLoader: HTTP Status 0 received.'),
            'undefined' == typeof ReadableStream ||
              void 0 === n.body ||
              void 0 === n.body.getReader)
          )
            return n
          const i = Jp[t],
            s = n.body.getReader(),
            r = n.headers.get('X-File-Size') || n.headers.get('Content-Length'),
            a = r ? parseInt(r) : 0,
            o = 0 !== a
          let l = 0
          const c = new ReadableStream({
            start(t) {
              function n() {
                s.read().then(
                  ({ done: e, value: s }) => {
                    if (e) t.close()
                    else {
                      l += s.byteLength
                      const e = new ProgressEvent('progress', {
                        lengthComputable: o,
                        loaded: l,
                        total: a
                      })
                      for (let t = 0, n = i.length; t < n; t++) {
                        const n = i[t]
                        n.onProgress && n.onProgress(e)
                      }
                      t.enqueue(s), n()
                    }
                  },
                  (e) => {
                    t.error(e)
                  }
                )
              }
              n(), e(n, 'readData')
            }
          })
          return new Response(c)
        }
        throw new Qp(
          `fetch for "${n.url}" responded with ${n.status}: ${n.statusText}`,
          n
        )
      })
      .then((t) => {
        switch (l) {
          case 'arraybuffer':
            return t.arrayBuffer()
          case 'blob':
            return t.blob()
          case 'document':
            return t.text().then((t) => new DOMParser().parseFromString(t, o))
          case 'json':
            return t.json()
          default:
            if (void 0 === o) return t.text()
            {
              const e = /charset="?([^;"\s]*)"?/i.exec(o),
                n = e && e[1] ? e[1].toLowerCase() : void 0,
                i = new TextDecoder(n)
              return t.arrayBuffer().then((t) => i.decode(t))
            }
        }
      })
      .then((e) => {
        Yp.add(t, e)
        const n = Jp[t]
        delete Jp[t]
        for (let t = 0, i = n.length; t < i; t++) {
          const i = n[t]
          i.onLoad && i.onLoad(e)
        }
      })
      .catch((e) => {
        const n = Jp[t]
        if (void 0 === n) throw (this.manager.itemError(t), e)
        delete Jp[t]
        for (let t = 0, i = n.length; t < i; t++) {
          const i = n[t]
          i.onError && i.onError(e)
        }
        this.manager.itemError(t)
      })
      .finally(() => {
        this.manager.itemEnd(t)
      }),
      this.manager.itemStart(t)
  }
  setResponseType(t) {
    return (this.responseType = t), this
  }
  setMimeType(t) {
    return (this.mimeType = t), this
  }
}
class em extends $p {
  static {
    e(this, 'AnimationLoader')
  }
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    const s = this,
      r = new tm(this.manager)
    r.setPath(this.path),
      r.setRequestHeader(this.requestHeader),
      r.setWithCredentials(this.withCredentials),
      r.load(
        t,
        function (n) {
          try {
            e(s.parse(JSON.parse(n)))
          } catch (r) {
            i ? i(r) : console.error(r), s.manager.itemError(t)
          }
        },
        n,
        i
      )
  }
  parse(t) {
    const e = []
    for (let n = 0; n < t.length; n++) {
      const i = jp.parse(t[n])
      e.push(i)
    }
    return e
  }
}
class nm extends $p {
  static {
    e(this, 'CompressedTextureLoader')
  }
  constructor(t) {
    super(t)
  }
  load(t, n, i, s) {
    const r = this,
      a = [],
      o = new Au(),
      l = new tm(this.manager)
    l.setPath(this.path),
      l.setResponseType('arraybuffer'),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(r.withCredentials)
    let c = 0
    function h(e) {
      l.load(
        t[e],
        function (t) {
          const i = r.parse(t, !0)
          ;(a[e] = {
            width: i.width,
            height: i.height,
            format: i.format,
            mipmaps: i.mipmaps
          }),
            (c += 1),
            6 === c &&
              (1 === i.mipmapCount && (o.minFilter = xe),
              (o.image = a),
              (o.format = i.format),
              (o.needsUpdate = !0),
              n && n(o))
        },
        i,
        s
      )
    }
    if ((e(h, 'loadTexture'), Array.isArray(t)))
      for (let e = 0, u = t.length; e < u; ++e) h(e)
    else
      l.load(
        t,
        function (t) {
          const e = r.parse(t, !0)
          if (e.isCubemap) {
            const t = e.mipmaps.length / e.mipmapCount
            for (let n = 0; n < t; n++) {
              a[n] = { mipmaps: [] }
              for (let t = 0; t < e.mipmapCount; t++)
                a[n].mipmaps.push(e.mipmaps[n * e.mipmapCount + t]),
                  (a[n].format = e.format),
                  (a[n].width = e.width),
                  (a[n].height = e.height)
            }
            o.image = a
          } else
            (o.image.width = e.width),
              (o.image.height = e.height),
              (o.mipmaps = e.mipmaps)
          1 === e.mipmapCount && (o.minFilter = xe),
            (o.format = e.format),
            (o.needsUpdate = !0),
            n && n(o)
        },
        i,
        s
      )
    return o
  }
}
class im extends $p {
  static {
    e(this, 'ImageLoader')
  }
  constructor(t) {
    super(t)
  }
  load(t, n, i, s) {
    void 0 !== this.path && (t = this.path + t),
      (t = this.manager.resolveURL(t))
    const r = this,
      a = Yp.get(t)
    if (void 0 !== a)
      return (
        r.manager.itemStart(t),
        setTimeout(function () {
          n && n(a), r.manager.itemEnd(t)
        }, 0),
        a
      )
    const o = Mi('img')
    function l() {
      h(), Yp.add(t, this), n && n(this), r.manager.itemEnd(t)
    }
    function c(e) {
      h(), s && s(e), r.manager.itemError(t), r.manager.itemEnd(t)
    }
    function h() {
      o.removeEventListener('load', l, !1),
        o.removeEventListener('error', c, !1)
    }
    return (
      e(l, 'onImageLoad'),
      e(c, 'onImageError'),
      e(h, 'removeEventListeners'),
      o.addEventListener('load', l, !1),
      o.addEventListener('error', c, !1),
      'data:' !== t.slice(0, 5) &&
        void 0 !== this.crossOrigin &&
        (o.crossOrigin = this.crossOrigin),
      r.manager.itemStart(t),
      (o.src = t),
      o
    )
  }
}
class sm extends $p {
  static {
    e(this, 'CubeTextureLoader')
  }
  constructor(t) {
    super(t)
  }
  load(t, n, i, s) {
    const r = new Sa()
    r.colorSpace = En
    const a = new im(this.manager)
    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path)
    let o = 0
    function l(e) {
      a.load(
        t[e],
        function (t) {
          ;(r.images[e] = t), o++, 6 === o && ((r.needsUpdate = !0), n && n(r))
        },
        void 0,
        s
      )
    }
    e(l, 'loadTexture')
    for (let e = 0; e < t.length; ++e) l(e)
    return r
  }
}
class rm extends $p {
  static {
    e(this, 'DataTextureLoader')
  }
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    const s = this,
      r = new Ah(),
      a = new tm(this.manager)
    return (
      a.setResponseType('arraybuffer'),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        t,
        function (t) {
          let n
          try {
            n = s.parse(t)
          } catch (a) {
            if (void 0 === i) return void console.error(a)
            i(a)
          }
          void 0 !== n.image
            ? (r.image = n.image)
            : void 0 !== n.data &&
              ((r.image.width = n.width),
              (r.image.height = n.height),
              (r.image.data = n.data)),
            (r.wrapS = void 0 !== n.wrapS ? n.wrapS : fe),
            (r.wrapT = void 0 !== n.wrapT ? n.wrapT : fe),
            (r.magFilter = void 0 !== n.magFilter ? n.magFilter : xe),
            (r.minFilter = void 0 !== n.minFilter ? n.minFilter : xe),
            (r.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
            void 0 !== n.colorSpace && (r.colorSpace = n.colorSpace),
            void 0 !== n.flipY && (r.flipY = n.flipY),
            void 0 !== n.format && (r.format = n.format),
            void 0 !== n.type && (r.type = n.type),
            void 0 !== n.mipmaps &&
              ((r.mipmaps = n.mipmaps), (r.minFilter = we)),
            1 === n.mipmapCount && (r.minFilter = xe),
            void 0 !== n.generateMipmaps &&
              (r.generateMipmaps = n.generateMipmaps),
            (r.needsUpdate = !0),
            e && e(r, n)
        },
        n,
        i
      ),
      r
    )
  }
}
class am extends $p {
  static {
    e(this, 'TextureLoader')
  }
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    const s = new Wi(),
      r = new im(this.manager)
    return (
      r.setCrossOrigin(this.crossOrigin),
      r.setPath(this.path),
      r.load(
        t,
        function (t) {
          ;(s.image = t), (s.needsUpdate = !0), void 0 !== e && e(s)
        },
        n,
        i
      ),
      s
    )
  }
}
class om extends nr {
  static {
    e(this, 'Light')
  }
  constructor(t, e = 1) {
    super(),
      (this.isLight = !0),
      (this.type = 'Light'),
      (this.color = new br(t)),
      (this.intensity = e)
  }
  dispose() {}
  copy(t, e) {
    return (
      super.copy(t, e),
      this.color.copy(t.color),
      (this.intensity = t.intensity),
      this
    )
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      (e.object.color = this.color.getHex()),
      (e.object.intensity = this.intensity),
      void 0 !== this.groundColor &&
        (e.object.groundColor = this.groundColor.getHex()),
      void 0 !== this.distance && (e.object.distance = this.distance),
      void 0 !== this.angle && (e.object.angle = this.angle),
      void 0 !== this.decay && (e.object.decay = this.decay),
      void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
      void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
      void 0 !== this.target && (e.object.target = this.target.uuid),
      e
    )
  }
}
class lm extends om {
  static {
    e(this, 'HemisphereLight')
  }
  constructor(t, e, n) {
    super(t, n),
      (this.isHemisphereLight = !0),
      (this.type = 'HemisphereLight'),
      this.position.copy(nr.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new br(e))
  }
  copy(t, e) {
    return super.copy(t, e), this.groundColor.copy(t.groundColor), this
  }
}
const cm = new Rs(),
  hm = new Qi(),
  um = new Qi()
class dm {
  static {
    e(this, 'LightShadow')
  }
  constructor(t) {
    ;(this.camera = t),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new vi(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Rs()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new La()),
      (this._frameExtents = new vi(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new ji(0, 0, 1, 1)])
  }
  getViewportCount() {
    return this._viewportCount
  }
  getFrustum() {
    return this._frustum
  }
  updateMatrices(t) {
    const e = this.camera,
      n = this.matrix
    hm.setFromMatrixPosition(t.matrixWorld),
      e.position.copy(hm),
      um.setFromMatrixPosition(t.target.matrixWorld),
      e.lookAt(um),
      e.updateMatrixWorld(),
      cm.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(cm),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(cm)
  }
  getViewport(t) {
    return this._viewports[t]
  }
  getFrameExtents() {
    return this._frameExtents
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
  }
  copy(t) {
    return (
      (this.camera = t.camera.clone()),
      (this.intensity = t.intensity),
      (this.bias = t.bias),
      (this.radius = t.radius),
      this.mapSize.copy(t.mapSize),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  toJSON() {
    const t = {}
    return (
      1 !== this.intensity && (t.intensity = this.intensity),
      0 !== this.bias && (t.bias = this.bias),
      0 !== this.normalBias && (t.normalBias = this.normalBias),
      1 !== this.radius && (t.radius = this.radius),
      (512 === this.mapSize.x && 512 === this.mapSize.y) ||
        (t.mapSize = this.mapSize.toArray()),
      (t.camera = this.camera.toJSON(!1).object),
      delete t.camera.matrix,
      t
    )
  }
}
class pm extends dm {
  static {
    e(this, 'SpotLightShadow')
  }
  constructor() {
    super(new ba(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1)
  }
  updateMatrices(t) {
    const e = this.camera,
      n = 2 * qn * t.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      s = t.distance || e.far
    ;(n === e.fov && i === e.aspect && s === e.far) ||
      ((e.fov = n), (e.aspect = i), (e.far = s), e.updateProjectionMatrix()),
      super.updateMatrices(t)
  }
  copy(t) {
    return super.copy(t), (this.focus = t.focus), this
  }
}
class mm extends om {
  static {
    e(this, 'SpotLight')
  }
  constructor(t, e, n = 0, i = Math.PI / 3, s = 0, r = 2) {
    super(t, e),
      (this.isSpotLight = !0),
      (this.type = 'SpotLight'),
      this.position.copy(nr.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new nr()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = s),
      (this.decay = r),
      (this.map = null),
      (this.shadow = new pm())
  }
  get power() {
    return this.intensity * Math.PI
  }
  set power(t) {
    this.intensity = t / Math.PI
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.distance = t.distance),
      (this.angle = t.angle),
      (this.penumbra = t.penumbra),
      (this.decay = t.decay),
      (this.target = t.target.clone()),
      (this.shadow = t.shadow.clone()),
      this
    )
  }
}
const fm = new Rs(),
  gm = new Qi(),
  vm = new Qi()
class ym extends dm {
  static {
    e(this, 'PointLightShadow')
  }
  constructor() {
    super(new ba(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new vi(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new ji(2, 1, 1, 1),
        new ji(0, 1, 1, 1),
        new ji(3, 1, 1, 1),
        new ji(1, 1, 1, 1),
        new ji(3, 0, 1, 1),
        new ji(1, 0, 1, 1)
      ]),
      (this._cubeDirections = [
        new Qi(1, 0, 0),
        new Qi(-1, 0, 0),
        new Qi(0, 0, 1),
        new Qi(0, 0, -1),
        new Qi(0, 1, 0),
        new Qi(0, -1, 0)
      ]),
      (this._cubeUps = [
        new Qi(0, 1, 0),
        new Qi(0, 1, 0),
        new Qi(0, 1, 0),
        new Qi(0, 1, 0),
        new Qi(0, 0, 1),
        new Qi(0, 0, -1)
      ])
  }
  updateMatrices(t, e = 0) {
    const n = this.camera,
      i = this.matrix,
      s = t.distance || n.far
    s !== n.far && ((n.far = s), n.updateProjectionMatrix()),
      gm.setFromMatrixPosition(t.matrixWorld),
      n.position.copy(gm),
      vm.copy(n.position),
      vm.add(this._cubeDirections[e]),
      n.up.copy(this._cubeUps[e]),
      n.lookAt(vm),
      n.updateMatrixWorld(),
      i.makeTranslation(-gm.x, -gm.y, -gm.z),
      fm.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(fm)
  }
}
class _m extends om {
  static {
    e(this, 'PointLight')
  }
  constructor(t, e, n = 0, i = 2) {
    super(t, e),
      (this.isPointLight = !0),
      (this.type = 'PointLight'),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new ym())
  }
  get power() {
    return 4 * this.intensity * Math.PI
  }
  set power(t) {
    this.intensity = t / (4 * Math.PI)
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.distance = t.distance),
      (this.decay = t.decay),
      (this.shadow = t.shadow.clone()),
      this
    )
  }
}
class xm extends dm {
  static {
    e(this, 'DirectionalLightShadow')
  }
  constructor() {
    super(new Ya(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0)
  }
}
class bm extends om {
  static {
    e(this, 'DirectionalLight')
  }
  constructor(t, e) {
    super(t, e),
      (this.isDirectionalLight = !0),
      (this.type = 'DirectionalLight'),
      this.position.copy(nr.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new nr()),
      (this.shadow = new xm())
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(t) {
    return (
      super.copy(t),
      (this.target = t.target.clone()),
      (this.shadow = t.shadow.clone()),
      this
    )
  }
}
class wm extends om {
  static {
    e(this, 'AmbientLight')
  }
  constructor(t, e) {
    super(t, e), (this.isAmbientLight = !0), (this.type = 'AmbientLight')
  }
}
class Mm extends om {
  static {
    e(this, 'RectAreaLight')
  }
  constructor(t, e, n = 10, i = 10) {
    super(t, e),
      (this.isRectAreaLight = !0),
      (this.type = 'RectAreaLight'),
      (this.width = n),
      (this.height = i)
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI
  }
  set power(t) {
    this.intensity = t / (this.width * this.height * Math.PI)
  }
  copy(t) {
    return super.copy(t), (this.width = t.width), (this.height = t.height), this
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (e.object.width = this.width), (e.object.height = this.height), e
  }
}
class Sm {
  static {
    e(this, 'SphericalHarmonics3')
  }
  constructor() {
    ;(this.isSphericalHarmonics3 = !0), (this.coefficients = [])
    for (let t = 0; t < 9; t++) this.coefficients.push(new Qi())
  }
  set(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e])
    return this
  }
  zero() {
    for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0)
    return this
  }
  getAt(t, e) {
    const n = t.x,
      i = t.y,
      s = t.z,
      r = this.coefficients
    return (
      e.copy(r[0]).multiplyScalar(0.282095),
      e.addScaledVector(r[1], 0.488603 * i),
      e.addScaledVector(r[2], 0.488603 * s),
      e.addScaledVector(r[3], 0.488603 * n),
      e.addScaledVector(r[4], n * i * 1.092548),
      e.addScaledVector(r[5], i * s * 1.092548),
      e.addScaledVector(r[6], 0.315392 * (3 * s * s - 1)),
      e.addScaledVector(r[7], n * s * 1.092548),
      e.addScaledVector(r[8], 0.546274 * (n * n - i * i)),
      e
    )
  }
  getIrradianceAt(t, e) {
    const n = t.x,
      i = t.y,
      s = t.z,
      r = this.coefficients
    return (
      e.copy(r[0]).multiplyScalar(0.886227),
      e.addScaledVector(r[1], 1.023328 * i),
      e.addScaledVector(r[2], 1.023328 * s),
      e.addScaledVector(r[3], 1.023328 * n),
      e.addScaledVector(r[4], 0.858086 * n * i),
      e.addScaledVector(r[5], 0.858086 * i * s),
      e.addScaledVector(r[6], 0.743125 * s * s - 0.247708),
      e.addScaledVector(r[7], 0.858086 * n * s),
      e.addScaledVector(r[8], 0.429043 * (n * n - i * i)),
      e
    )
  }
  add(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e])
    return this
  }
  addScaledSH(t, e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(t.coefficients[n], e)
    return this
  }
  scale(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t)
    return this
  }
  lerp(t, e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e)
    return this
  }
  equals(t) {
    for (let e = 0; e < 9; e++)
      if (!this.coefficients[e].equals(t.coefficients[e])) return !1
    return !0
  }
  copy(t) {
    return this.set(t.coefficients)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  fromArray(t, e = 0) {
    const n = this.coefficients
    for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i)
    return this
  }
  toArray(t = [], e = 0) {
    const n = this.coefficients
    for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i)
    return t
  }
  static getBasisAt(t, e) {
    const n = t.x,
      i = t.y,
      s = t.z
    ;(e[0] = 0.282095),
      (e[1] = 0.488603 * i),
      (e[2] = 0.488603 * s),
      (e[3] = 0.488603 * n),
      (e[4] = 1.092548 * n * i),
      (e[5] = 1.092548 * i * s),
      (e[6] = 0.315392 * (3 * s * s - 1)),
      (e[7] = 1.092548 * n * s),
      (e[8] = 0.546274 * (n * n - i * i))
  }
}
class Tm extends om {
  static {
    e(this, 'LightProbe')
  }
  constructor(t = new Sm(), e = 1) {
    super(void 0, e), (this.isLightProbe = !0), (this.sh = t)
  }
  copy(t) {
    return super.copy(t), this.sh.copy(t.sh), this
  }
  fromJSON(t) {
    return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (e.object.sh = this.sh.toArray()), e
  }
}
class Em extends $p {
  static {
    e(this, 'MaterialLoader')
  }
  constructor(t) {
    super(t), (this.textures = {})
  }
  load(t, e, n, i) {
    const s = this,
      r = new tm(s.manager)
    r.setPath(s.path),
      r.setRequestHeader(s.requestHeader),
      r.setWithCredentials(s.withCredentials),
      r.load(
        t,
        function (n) {
          try {
            e(s.parse(JSON.parse(n)))
          } catch (r) {
            i ? i(r) : console.error(r), s.manager.itemError(t)
          }
        },
        n,
        i
      )
  }
  parse(t) {
    const n = this.textures
    function i(t) {
      return (
        void 0 === n[t] &&
          console.warn('THREE.MaterialLoader: Undefined texture', t),
        n[t]
      )
    }
    e(i, 'getTexture')
    const s = this.createMaterialFromType(t.type)
    if (
      (void 0 !== t.uuid && (s.uuid = t.uuid),
      void 0 !== t.name && (s.name = t.name),
      void 0 !== t.color && void 0 !== s.color && s.color.setHex(t.color),
      void 0 !== t.roughness && (s.roughness = t.roughness),
      void 0 !== t.metalness && (s.metalness = t.metalness),
      void 0 !== t.sheen && (s.sheen = t.sheen),
      void 0 !== t.sheenColor && (s.sheenColor = new br().setHex(t.sheenColor)),
      void 0 !== t.sheenRoughness && (s.sheenRoughness = t.sheenRoughness),
      void 0 !== t.emissive &&
        void 0 !== s.emissive &&
        s.emissive.setHex(t.emissive),
      void 0 !== t.specular &&
        void 0 !== s.specular &&
        s.specular.setHex(t.specular),
      void 0 !== t.specularIntensity &&
        (s.specularIntensity = t.specularIntensity),
      void 0 !== t.specularColor &&
        void 0 !== s.specularColor &&
        s.specularColor.setHex(t.specularColor),
      void 0 !== t.shininess && (s.shininess = t.shininess),
      void 0 !== t.clearcoat && (s.clearcoat = t.clearcoat),
      void 0 !== t.clearcoatRoughness &&
        (s.clearcoatRoughness = t.clearcoatRoughness),
      void 0 !== t.dispersion && (s.dispersion = t.dispersion),
      void 0 !== t.iridescence && (s.iridescence = t.iridescence),
      void 0 !== t.iridescenceIOR && (s.iridescenceIOR = t.iridescenceIOR),
      void 0 !== t.iridescenceThicknessRange &&
        (s.iridescenceThicknessRange = t.iridescenceThicknessRange),
      void 0 !== t.transmission && (s.transmission = t.transmission),
      void 0 !== t.thickness && (s.thickness = t.thickness),
      void 0 !== t.attenuationDistance &&
        (s.attenuationDistance = t.attenuationDistance),
      void 0 !== t.attenuationColor &&
        void 0 !== s.attenuationColor &&
        s.attenuationColor.setHex(t.attenuationColor),
      void 0 !== t.anisotropy && (s.anisotropy = t.anisotropy),
      void 0 !== t.anisotropyRotation &&
        (s.anisotropyRotation = t.anisotropyRotation),
      void 0 !== t.fog && (s.fog = t.fog),
      void 0 !== t.flatShading && (s.flatShading = t.flatShading),
      void 0 !== t.blending && (s.blending = t.blending),
      void 0 !== t.combine && (s.combine = t.combine),
      void 0 !== t.side && (s.side = t.side),
      void 0 !== t.shadowSide && (s.shadowSide = t.shadowSide),
      void 0 !== t.opacity && (s.opacity = t.opacity),
      void 0 !== t.transparent && (s.transparent = t.transparent),
      void 0 !== t.alphaTest && (s.alphaTest = t.alphaTest),
      void 0 !== t.alphaHash && (s.alphaHash = t.alphaHash),
      void 0 !== t.depthFunc && (s.depthFunc = t.depthFunc),
      void 0 !== t.depthTest && (s.depthTest = t.depthTest),
      void 0 !== t.depthWrite && (s.depthWrite = t.depthWrite),
      void 0 !== t.colorWrite && (s.colorWrite = t.colorWrite),
      void 0 !== t.blendSrc && (s.blendSrc = t.blendSrc),
      void 0 !== t.blendDst && (s.blendDst = t.blendDst),
      void 0 !== t.blendEquation && (s.blendEquation = t.blendEquation),
      void 0 !== t.blendSrcAlpha && (s.blendSrcAlpha = t.blendSrcAlpha),
      void 0 !== t.blendDstAlpha && (s.blendDstAlpha = t.blendDstAlpha),
      void 0 !== t.blendEquationAlpha &&
        (s.blendEquationAlpha = t.blendEquationAlpha),
      void 0 !== t.blendColor &&
        void 0 !== s.blendColor &&
        s.blendColor.setHex(t.blendColor),
      void 0 !== t.blendAlpha && (s.blendAlpha = t.blendAlpha),
      void 0 !== t.stencilWriteMask &&
        (s.stencilWriteMask = t.stencilWriteMask),
      void 0 !== t.stencilFunc && (s.stencilFunc = t.stencilFunc),
      void 0 !== t.stencilRef && (s.stencilRef = t.stencilRef),
      void 0 !== t.stencilFuncMask && (s.stencilFuncMask = t.stencilFuncMask),
      void 0 !== t.stencilFail && (s.stencilFail = t.stencilFail),
      void 0 !== t.stencilZFail && (s.stencilZFail = t.stencilZFail),
      void 0 !== t.stencilZPass && (s.stencilZPass = t.stencilZPass),
      void 0 !== t.stencilWrite && (s.stencilWrite = t.stencilWrite),
      void 0 !== t.wireframe && (s.wireframe = t.wireframe),
      void 0 !== t.wireframeLinewidth &&
        (s.wireframeLinewidth = t.wireframeLinewidth),
      void 0 !== t.wireframeLinecap &&
        (s.wireframeLinecap = t.wireframeLinecap),
      void 0 !== t.wireframeLinejoin &&
        (s.wireframeLinejoin = t.wireframeLinejoin),
      void 0 !== t.rotation && (s.rotation = t.rotation),
      void 0 !== t.linewidth && (s.linewidth = t.linewidth),
      void 0 !== t.dashSize && (s.dashSize = t.dashSize),
      void 0 !== t.gapSize && (s.gapSize = t.gapSize),
      void 0 !== t.scale && (s.scale = t.scale),
      void 0 !== t.polygonOffset && (s.polygonOffset = t.polygonOffset),
      void 0 !== t.polygonOffsetFactor &&
        (s.polygonOffsetFactor = t.polygonOffsetFactor),
      void 0 !== t.polygonOffsetUnits &&
        (s.polygonOffsetUnits = t.polygonOffsetUnits),
      void 0 !== t.dithering && (s.dithering = t.dithering),
      void 0 !== t.alphaToCoverage && (s.alphaToCoverage = t.alphaToCoverage),
      void 0 !== t.premultipliedAlpha &&
        (s.premultipliedAlpha = t.premultipliedAlpha),
      void 0 !== t.forceSinglePass && (s.forceSinglePass = t.forceSinglePass),
      void 0 !== t.visible && (s.visible = t.visible),
      void 0 !== t.toneMapped && (s.toneMapped = t.toneMapped),
      void 0 !== t.userData && (s.userData = t.userData),
      void 0 !== t.vertexColors &&
        ('number' == typeof t.vertexColors
          ? (s.vertexColors = t.vertexColors > 0)
          : (s.vertexColors = t.vertexColors)),
      void 0 !== t.uniforms)
    )
      for (const e in t.uniforms) {
        const n = t.uniforms[e]
        switch (((s.uniforms[e] = {}), n.type)) {
          case 't':
            s.uniforms[e].value = i(n.value)
            break
          case 'c':
            s.uniforms[e].value = new br().setHex(n.value)
            break
          case 'v2':
            s.uniforms[e].value = new vi().fromArray(n.value)
            break
          case 'v3':
            s.uniforms[e].value = new Qi().fromArray(n.value)
            break
          case 'v4':
            s.uniforms[e].value = new ji().fromArray(n.value)
            break
          case 'm3':
            s.uniforms[e].value = new yi().fromArray(n.value)
            break
          case 'm4':
            s.uniforms[e].value = new Rs().fromArray(n.value)
            break
          default:
            s.uniforms[e].value = n.value
        }
      }
    if (
      (void 0 !== t.defines && (s.defines = t.defines),
      void 0 !== t.vertexShader && (s.vertexShader = t.vertexShader),
      void 0 !== t.fragmentShader && (s.fragmentShader = t.fragmentShader),
      void 0 !== t.glslVersion && (s.glslVersion = t.glslVersion),
      void 0 !== t.extensions)
    )
      for (const e in t.extensions) s.extensions[e] = t.extensions[e]
    if (
      (void 0 !== t.lights && (s.lights = t.lights),
      void 0 !== t.clipping && (s.clipping = t.clipping),
      void 0 !== t.size && (s.size = t.size),
      void 0 !== t.sizeAttenuation && (s.sizeAttenuation = t.sizeAttenuation),
      void 0 !== t.map && (s.map = i(t.map)),
      void 0 !== t.matcap && (s.matcap = i(t.matcap)),
      void 0 !== t.alphaMap && (s.alphaMap = i(t.alphaMap)),
      void 0 !== t.bumpMap && (s.bumpMap = i(t.bumpMap)),
      void 0 !== t.bumpScale && (s.bumpScale = t.bumpScale),
      void 0 !== t.normalMap && (s.normalMap = i(t.normalMap)),
      void 0 !== t.normalMapType && (s.normalMapType = t.normalMapType),
      void 0 !== t.normalScale)
    ) {
      let e = t.normalScale
      !1 === Array.isArray(e) && (e = [e, e]),
        (s.normalScale = new vi().fromArray(e))
    }
    return (
      void 0 !== t.displacementMap &&
        (s.displacementMap = i(t.displacementMap)),
      void 0 !== t.displacementScale &&
        (s.displacementScale = t.displacementScale),
      void 0 !== t.displacementBias &&
        (s.displacementBias = t.displacementBias),
      void 0 !== t.roughnessMap && (s.roughnessMap = i(t.roughnessMap)),
      void 0 !== t.metalnessMap && (s.metalnessMap = i(t.metalnessMap)),
      void 0 !== t.emissiveMap && (s.emissiveMap = i(t.emissiveMap)),
      void 0 !== t.emissiveIntensity &&
        (s.emissiveIntensity = t.emissiveIntensity),
      void 0 !== t.specularMap && (s.specularMap = i(t.specularMap)),
      void 0 !== t.specularIntensityMap &&
        (s.specularIntensityMap = i(t.specularIntensityMap)),
      void 0 !== t.specularColorMap &&
        (s.specularColorMap = i(t.specularColorMap)),
      void 0 !== t.envMap && (s.envMap = i(t.envMap)),
      void 0 !== t.envMapRotation &&
        s.envMapRotation.fromArray(t.envMapRotation),
      void 0 !== t.envMapIntensity && (s.envMapIntensity = t.envMapIntensity),
      void 0 !== t.reflectivity && (s.reflectivity = t.reflectivity),
      void 0 !== t.refractionRatio && (s.refractionRatio = t.refractionRatio),
      void 0 !== t.lightMap && (s.lightMap = i(t.lightMap)),
      void 0 !== t.lightMapIntensity &&
        (s.lightMapIntensity = t.lightMapIntensity),
      void 0 !== t.aoMap && (s.aoMap = i(t.aoMap)),
      void 0 !== t.aoMapIntensity && (s.aoMapIntensity = t.aoMapIntensity),
      void 0 !== t.gradientMap && (s.gradientMap = i(t.gradientMap)),
      void 0 !== t.clearcoatMap && (s.clearcoatMap = i(t.clearcoatMap)),
      void 0 !== t.clearcoatRoughnessMap &&
        (s.clearcoatRoughnessMap = i(t.clearcoatRoughnessMap)),
      void 0 !== t.clearcoatNormalMap &&
        (s.clearcoatNormalMap = i(t.clearcoatNormalMap)),
      void 0 !== t.clearcoatNormalScale &&
        (s.clearcoatNormalScale = new vi().fromArray(t.clearcoatNormalScale)),
      void 0 !== t.iridescenceMap && (s.iridescenceMap = i(t.iridescenceMap)),
      void 0 !== t.iridescenceThicknessMap &&
        (s.iridescenceThicknessMap = i(t.iridescenceThicknessMap)),
      void 0 !== t.transmissionMap &&
        (s.transmissionMap = i(t.transmissionMap)),
      void 0 !== t.thicknessMap && (s.thicknessMap = i(t.thicknessMap)),
      void 0 !== t.anisotropyMap && (s.anisotropyMap = i(t.anisotropyMap)),
      void 0 !== t.sheenColorMap && (s.sheenColorMap = i(t.sheenColorMap)),
      void 0 !== t.sheenRoughnessMap &&
        (s.sheenRoughnessMap = i(t.sheenRoughnessMap)),
      s
    )
  }
  setTextures(t) {
    return (this.textures = t), this
  }
  createMaterialFromType(t) {
    return Em.createMaterialFromType(t)
  }
  static createMaterialFromType(t) {
    return new {
      ShadowMaterial: gp,
      SpriteMaterial: $c,
      RawShaderMaterial: vp,
      ShaderMaterial: ga,
      PointsMaterial: yu,
      MeshPhysicalMaterial: _p,
      MeshStandardMaterial: yp,
      MeshPhongMaterial: xp,
      MeshToonMaterial: bp,
      MeshNormalMaterial: wp,
      MeshLambertMaterial: Mp,
      MeshDepthMaterial: wc,
      MeshDistanceMaterial: Mc,
      MeshBasicMaterial: Tr,
      MeshMatcapMaterial: Sp,
      LineDashedMaterial: Tp,
      LineBasicMaterial: su,
      Material: Sr
    }[t]()
  }
}
class Am {
  static {
    e(this, 'LoaderUtils')
  }
  static decodeText(t) {
    if (
      (console.warn(
        'THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.'
      ),
      'undefined' != typeof TextDecoder)
    )
      return new TextDecoder().decode(t)
    let e = ''
    for (let i = 0, s = t.length; i < s; i++) e += String.fromCharCode(t[i])
    try {
      return decodeURIComponent(escape(e))
    } catch (n) {
      return e
    }
  }
  static extractUrlBase(t) {
    const e = t.lastIndexOf('/')
    return -1 === e ? './' : t.slice(0, e + 1)
  }
  static resolveURL(t, e) {
    return 'string' != typeof t || '' === t
      ? ''
      : (/^https?:\/\//i.test(e) &&
          /^\//.test(t) &&
          (e = e.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
        /^(https?:)?\/\//i.test(t) ||
        /^data:.*,.*$/i.test(t) ||
        /^blob:.*$/i.test(t)
          ? t
          : e + t)
  }
}
class Cm extends Zr {
  static {
    e(this, 'InstancedBufferGeometry')
  }
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = 'InstancedBufferGeometry'),
      (this.instanceCount = 1 / 0)
  }
  copy(t) {
    return super.copy(t), (this.instanceCount = t.instanceCount), this
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.instanceCount = this.instanceCount),
      (t.isInstancedBufferGeometry = !0),
      t
    )
  }
}
class Rm extends $p {
  static {
    e(this, 'BufferGeometryLoader')
  }
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    const s = this,
      r = new tm(s.manager)
    r.setPath(s.path),
      r.setRequestHeader(s.requestHeader),
      r.setWithCredentials(s.withCredentials),
      r.load(
        t,
        function (n) {
          try {
            e(s.parse(JSON.parse(n)))
          } catch (r) {
            i ? i(r) : console.error(r), s.manager.itemError(t)
          }
        },
        n,
        i
      )
  }
  parse(t) {
    const n = {},
      i = {}
    function s(t, e) {
      if (void 0 !== n[e]) return n[e]
      const i = t.interleavedBuffers[e],
        s = r(t, i.buffer),
        a = wi(i.type, s),
        o = new Yc(a, i.stride)
      return (o.uuid = i.uuid), (n[e] = o), o
    }
    function r(t, e) {
      if (void 0 !== i[e]) return i[e]
      const n = t.arrayBuffers[e],
        s = new Uint32Array(n).buffer
      return (i[e] = s), s
    }
    e(s, 'getInterleavedBuffer'), e(r, 'getArrayBuffer')
    const a = t.isInstancedBufferGeometry ? new Cm() : new Zr(),
      o = t.data.index
    if (void 0 !== o) {
      const t = wi(o.type, o.array)
      a.setIndex(new Lr(t, 1))
    }
    const l = t.data.attributes
    for (const e in l) {
      const n = l[e]
      let i
      if (n.isInterleavedBufferAttribute) {
        const e = s(t.data, n.data)
        i = new Kc(e, n.itemSize, n.offset, n.normalized)
      } else {
        const t = wi(n.type, n.array)
        i = new (n.isInstancedBufferAttribute ? Ih : Lr)(
          t,
          n.itemSize,
          n.normalized
        )
      }
      void 0 !== n.name && (i.name = n.name),
        void 0 !== n.usage && i.setUsage(n.usage),
        a.setAttribute(e, i)
    }
    const c = t.data.morphAttributes
    if (c)
      for (const e in c) {
        const n = c[e],
          i = []
        for (let e = 0, r = n.length; e < r; e++) {
          const r = n[e]
          let a
          if (r.isInterleavedBufferAttribute) {
            const e = s(t.data, r.data)
            a = new Kc(e, r.itemSize, r.offset, r.normalized)
          } else {
            const t = wi(r.type, r.array)
            a = new Lr(t, r.itemSize, r.normalized)
          }
          void 0 !== r.name && (a.name = r.name), i.push(a)
        }
        a.morphAttributes[e] = i
      }
    t.data.morphTargetsRelative && (a.morphTargetsRelative = !0)
    const h = t.data.groups || t.data.drawcalls || t.data.offsets
    if (void 0 !== h)
      for (let e = 0, d = h.length; e !== d; ++e) {
        const t = h[e]
        a.addGroup(t.start, t.count, t.materialIndex)
      }
    const u = t.data.boundingSphere
    if (void 0 !== u) {
      const t = new Qi()
      void 0 !== u.center && t.fromArray(u.center),
        (a.boundingSphere = new xs(t, u.radius))
    }
    return (
      t.name && (a.name = t.name), t.userData && (a.userData = t.userData), a
    )
  }
}
class Pm extends $p {
  static {
    e(this, 'ObjectLoader')
  }
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    const s = this,
      r = '' === this.path ? Am.extractUrlBase(t) : this.path
    this.resourcePath = this.resourcePath || r
    const a = new tm(this.manager)
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        t,
        function (n) {
          let r = null
          try {
            r = JSON.parse(n)
          } catch (o) {
            return (
              void 0 !== i && i(o),
              void console.error(
                "THREE:ObjectLoader: Can't parse " + t + '.',
                o.message
              )
            )
          }
          const a = r.metadata
          if (
            void 0 === a ||
            void 0 === a.type ||
            'geometry' === a.type.toLowerCase()
          )
            return (
              void 0 !== i &&
                i(new Error("THREE.ObjectLoader: Can't load " + t)),
              void console.error("THREE.ObjectLoader: Can't load " + t)
            )
          s.parse(r, e)
        },
        n,
        i
      )
  }
  async loadAsync(t, e) {
    const n = '' === this.path ? Am.extractUrlBase(t) : this.path
    this.resourcePath = this.resourcePath || n
    const i = new tm(this.manager)
    i.setPath(this.path),
      i.setRequestHeader(this.requestHeader),
      i.setWithCredentials(this.withCredentials)
    const s = await i.loadAsync(t, e),
      r = JSON.parse(s),
      a = r.metadata
    if (
      void 0 === a ||
      void 0 === a.type ||
      'geometry' === a.type.toLowerCase()
    )
      throw new Error("THREE.ObjectLoader: Can't load " + t)
    return await this.parseAsync(r)
  }
  parse(t, e) {
    const n = this.parseAnimations(t.animations),
      i = this.parseShapes(t.shapes),
      s = this.parseGeometries(t.geometries, i),
      r = this.parseImages(t.images, function () {
        void 0 !== e && e(l)
      }),
      a = this.parseTextures(t.textures, r),
      o = this.parseMaterials(t.materials, a),
      l = this.parseObject(t.object, s, o, a, n),
      c = this.parseSkeletons(t.skeletons, l)
    if ((this.bindSkeletons(l, c), this.bindLightTargets(l), void 0 !== e)) {
      let t = !1
      for (const e in r)
        if (r[e].data instanceof HTMLImageElement) {
          t = !0
          break
        }
      !1 === t && e(l)
    }
    return l
  }
  async parseAsync(t) {
    const e = this.parseAnimations(t.animations),
      n = this.parseShapes(t.shapes),
      i = this.parseGeometries(t.geometries, n),
      s = await this.parseImagesAsync(t.images),
      r = this.parseTextures(t.textures, s),
      a = this.parseMaterials(t.materials, r),
      o = this.parseObject(t.object, i, a, r, e),
      l = this.parseSkeletons(t.skeletons, o)
    return this.bindSkeletons(o, l), this.bindLightTargets(o), o
  }
  parseShapes(t) {
    const e = {}
    if (void 0 !== t)
      for (let n = 0, i = t.length; n < i; n++) {
        const i = new yd().fromJSON(t[n])
        e[i.uuid] = i
      }
    return e
  }
  parseSkeletons(t, e) {
    const n = {},
      i = {}
    if (
      (e.traverse(function (t) {
        t.isBone && (i[t.uuid] = t)
      }),
      void 0 !== t)
    )
      for (let s = 0, r = t.length; s < r; s++) {
        const e = new Ph().fromJSON(t[s], i)
        n[e.uuid] = e
      }
    return n
  }
  parseGeometries(t, e) {
    const n = {}
    if (void 0 !== t) {
      const i = new Rm()
      for (let s = 0, r = t.length; s < r; s++) {
        let r
        const a = t[s]
        switch (a.type) {
          case 'BufferGeometry':
          case 'InstancedBufferGeometry':
            r = i.parse(a)
            break
          default:
            a.type in fp
              ? (r = fp[a.type].fromJSON(a, e))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${a.type}"`
                )
        }
        ;(r.uuid = a.uuid),
          void 0 !== a.name && (r.name = a.name),
          void 0 !== a.userData && (r.userData = a.userData),
          (n[a.uuid] = r)
      }
    }
    return n
  }
  parseMaterials(t, e) {
    const n = {},
      i = {}
    if (void 0 !== t) {
      const s = new Em()
      s.setTextures(e)
      for (let e = 0, r = t.length; e < r; e++) {
        const r = t[e]
        void 0 === n[r.uuid] && (n[r.uuid] = s.parse(r)),
          (i[r.uuid] = n[r.uuid])
      }
    }
    return i
  }
  parseAnimations(t) {
    const e = {}
    if (void 0 !== t)
      for (let n = 0; n < t.length; n++) {
        const i = t[n],
          s = jp.parse(i)
        e[s.uuid] = s
      }
    return e
  }
  parseImages(t, n) {
    const i = this,
      s = {}
    let r
    function a(t) {
      return (
        i.manager.itemStart(t),
        r.load(
          t,
          function () {
            i.manager.itemEnd(t)
          },
          void 0,
          function () {
            i.manager.itemError(t), i.manager.itemEnd(t)
          }
        )
      )
    }
    function o(t) {
      if ('string' == typeof t) {
        const e = t
        return a(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : i.resourcePath + e)
      }
      return t.data
        ? { data: wi(t.type, t.data), width: t.width, height: t.height }
        : null
    }
    if (
      (e(a, 'loadImage'),
      e(o, 'deserializeImage'),
      void 0 !== t && t.length > 0)
    ) {
      const e = new Zp(n)
      ;(r = new im(e)), r.setCrossOrigin(this.crossOrigin)
      for (let n = 0, i = t.length; n < i; n++) {
        const e = t[n],
          i = e.url
        if (Array.isArray(i)) {
          const t = []
          for (let e = 0, n = i.length; e < n; e++) {
            const n = o(i[e])
            null !== n &&
              (n instanceof HTMLImageElement
                ? t.push(n)
                : t.push(new Ah(n.data, n.width, n.height)))
          }
          s[e.uuid] = new Vi(t)
        } else {
          const t = o(e.url)
          s[e.uuid] = new Vi(t)
        }
      }
    }
    return s
  }
  async parseImagesAsync(t) {
    const n = this,
      i = {}
    let s
    async function r(t) {
      if ('string' == typeof t) {
        const e = t,
          i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e
        return await s.loadAsync(i)
      }
      return t.data
        ? { data: wi(t.type, t.data), width: t.width, height: t.height }
        : null
    }
    if ((e(r, 'deserializeImage'), void 0 !== t && t.length > 0)) {
      ;(s = new im(this.manager)), s.setCrossOrigin(this.crossOrigin)
      for (let e = 0, n = t.length; e < n; e++) {
        const n = t[e],
          s = n.url
        if (Array.isArray(s)) {
          const t = []
          for (let e = 0, n = s.length; e < n; e++) {
            const n = s[e],
              i = await r(n)
            null !== i &&
              (i instanceof HTMLImageElement
                ? t.push(i)
                : t.push(new Ah(i.data, i.width, i.height)))
          }
          i[n.uuid] = new Vi(t)
        } else {
          const t = await r(n.url)
          i[n.uuid] = new Vi(t)
        }
      }
    }
    return i
  }
  parseTextures(t, n) {
    function i(t, e) {
      return 'number' == typeof t
        ? t
        : (console.warn(
            'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',
            t
          ),
          e[t])
    }
    e(i, 'parseConstant')
    const s = {}
    if (void 0 !== t)
      for (let e = 0, r = t.length; e < r; e++) {
        const r = t[e]
        void 0 === r.image &&
          console.warn('THREE.ObjectLoader: No "image" specified for', r.uuid),
          void 0 === n[r.image] &&
            console.warn('THREE.ObjectLoader: Undefined image', r.image)
        const a = n[r.image],
          o = a.data
        let l
        Array.isArray(o)
          ? ((l = new Sa()), 6 === o.length && (l.needsUpdate = !0))
          : ((l = o && o.data ? new Ah() : new Wi()),
            o && (l.needsUpdate = !0)),
          (l.source = a),
          (l.uuid = r.uuid),
          void 0 !== r.name && (l.name = r.name),
          void 0 !== r.mapping && (l.mapping = i(r.mapping, Im)),
          void 0 !== r.channel && (l.channel = r.channel),
          void 0 !== r.offset && l.offset.fromArray(r.offset),
          void 0 !== r.repeat && l.repeat.fromArray(r.repeat),
          void 0 !== r.center && l.center.fromArray(r.center),
          void 0 !== r.rotation && (l.rotation = r.rotation),
          void 0 !== r.wrap &&
            ((l.wrapS = i(r.wrap[0], Lm)), (l.wrapT = i(r.wrap[1], Lm))),
          void 0 !== r.format && (l.format = r.format),
          void 0 !== r.internalFormat && (l.internalFormat = r.internalFormat),
          void 0 !== r.type && (l.type = r.type),
          void 0 !== r.colorSpace && (l.colorSpace = r.colorSpace),
          void 0 !== r.minFilter && (l.minFilter = i(r.minFilter, Dm)),
          void 0 !== r.magFilter && (l.magFilter = i(r.magFilter, Dm)),
          void 0 !== r.anisotropy && (l.anisotropy = r.anisotropy),
          void 0 !== r.flipY && (l.flipY = r.flipY),
          void 0 !== r.generateMipmaps &&
            (l.generateMipmaps = r.generateMipmaps),
          void 0 !== r.premultiplyAlpha &&
            (l.premultiplyAlpha = r.premultiplyAlpha),
          void 0 !== r.unpackAlignment &&
            (l.unpackAlignment = r.unpackAlignment),
          void 0 !== r.compareFunction &&
            (l.compareFunction = r.compareFunction),
          void 0 !== r.userData && (l.userData = r.userData),
          (s[r.uuid] = l)
      }
    return s
  }
  parseObject(t, n, i, s, r) {
    let a, o, l
    function c(t) {
      return (
        void 0 === n[t] &&
          console.warn('THREE.ObjectLoader: Undefined geometry', t),
        n[t]
      )
    }
    function h(t) {
      if (void 0 !== t) {
        if (Array.isArray(t)) {
          const e = []
          for (let n = 0, s = t.length; n < s; n++) {
            const s = t[n]
            void 0 === i[s] &&
              console.warn('THREE.ObjectLoader: Undefined material', s),
              e.push(i[s])
          }
          return e
        }
        return (
          void 0 === i[t] &&
            console.warn('THREE.ObjectLoader: Undefined material', t),
          i[t]
        )
      }
    }
    function u(t) {
      return (
        void 0 === s[t] &&
          console.warn('THREE.ObjectLoader: Undefined texture', t),
        s[t]
      )
    }
    switch (
      (e(c, 'getGeometry'), e(h, 'getMaterial'), e(u, 'getTexture'), t.type)
    ) {
      case 'Scene':
        ;(a = new qc()),
          void 0 !== t.background &&
            (Number.isInteger(t.background)
              ? (a.background = new br(t.background))
              : (a.background = u(t.background))),
          void 0 !== t.environment && (a.environment = u(t.environment)),
          void 0 !== t.fog &&
            ('Fog' === t.fog.type
              ? (a.fog = new Xc(t.fog.color, t.fog.near, t.fog.far))
              : 'FogExp2' === t.fog.type &&
                (a.fog = new jc(t.fog.color, t.fog.density)),
            '' !== t.fog.name && (a.fog.name = t.fog.name)),
          void 0 !== t.backgroundBlurriness &&
            (a.backgroundBlurriness = t.backgroundBlurriness),
          void 0 !== t.backgroundIntensity &&
            (a.backgroundIntensity = t.backgroundIntensity),
          void 0 !== t.backgroundRotation &&
            a.backgroundRotation.fromArray(t.backgroundRotation),
          void 0 !== t.environmentIntensity &&
            (a.environmentIntensity = t.environmentIntensity),
          void 0 !== t.environmentRotation &&
            a.environmentRotation.fromArray(t.environmentRotation)
        break
      case 'PerspectiveCamera':
        ;(a = new ba(t.fov, t.aspect, t.near, t.far)),
          void 0 !== t.focus && (a.focus = t.focus),
          void 0 !== t.zoom && (a.zoom = t.zoom),
          void 0 !== t.filmGauge && (a.filmGauge = t.filmGauge),
          void 0 !== t.filmOffset && (a.filmOffset = t.filmOffset),
          void 0 !== t.view && (a.view = Object.assign({}, t.view))
        break
      case 'OrthographicCamera':
        ;(a = new Ya(t.left, t.right, t.top, t.bottom, t.near, t.far)),
          void 0 !== t.zoom && (a.zoom = t.zoom),
          void 0 !== t.view && (a.view = Object.assign({}, t.view))
        break
      case 'AmbientLight':
        a = new wm(t.color, t.intensity)
        break
      case 'DirectionalLight':
        ;(a = new bm(t.color, t.intensity)), (a.target = t.target || '')
        break
      case 'PointLight':
        a = new _m(t.color, t.intensity, t.distance, t.decay)
        break
      case 'RectAreaLight':
        a = new Mm(t.color, t.intensity, t.width, t.height)
        break
      case 'SpotLight':
        ;(a = new mm(
          t.color,
          t.intensity,
          t.distance,
          t.angle,
          t.penumbra,
          t.decay
        )),
          (a.target = t.target || '')
        break
      case 'HemisphereLight':
        a = new lm(t.color, t.groundColor, t.intensity)
        break
      case 'LightProbe':
        a = new Tm().fromJSON(t)
        break
      case 'SkinnedMesh':
        ;(o = c(t.geometry)),
          (l = h(t.material)),
          (a = new Th(o, l)),
          void 0 !== t.bindMode && (a.bindMode = t.bindMode),
          void 0 !== t.bindMatrix && a.bindMatrix.fromArray(t.bindMatrix),
          void 0 !== t.skeleton && (a.skeleton = t.skeleton)
        break
      case 'Mesh':
        ;(o = c(t.geometry)), (l = h(t.material)), (a = new oa(o, l))
        break
      case 'InstancedMesh':
        ;(o = c(t.geometry)), (l = h(t.material))
        const e = t.count,
          n = t.instanceMatrix,
          i = t.instanceColor
        ;(a = new Fh(o, l, e)),
          (a.instanceMatrix = new Ih(new Float32Array(n.array), 16)),
          void 0 !== i &&
            (a.instanceColor = new Ih(new Float32Array(i.array), i.itemSize))
        break
      case 'BatchedMesh':
        ;(o = c(t.geometry)),
          (l = h(t.material)),
          (a = new iu(
            t.maxInstanceCount,
            t.maxVertexCount,
            t.maxIndexCount,
            l
          )),
          (a.geometry = o),
          (a.perObjectFrustumCulled = t.perObjectFrustumCulled),
          (a.sortObjects = t.sortObjects),
          (a._drawRanges = t.drawRanges),
          (a._reservedRanges = t.reservedRanges),
          (a._visibility = t.visibility),
          (a._active = t.active),
          (a._bounds = t.bounds.map((t) => {
            const e = new ns()
            e.min.fromArray(t.boxMin), e.max.fromArray(t.boxMax)
            const n = new xs()
            return (
              (n.radius = t.sphereRadius),
              n.center.fromArray(t.sphereCenter),
              {
                boxInitialized: t.boxInitialized,
                box: e,
                sphereInitialized: t.sphereInitialized,
                sphere: n
              }
            )
          })),
          (a._maxInstanceCount = t.maxInstanceCount),
          (a._maxVertexCount = t.maxVertexCount),
          (a._maxIndexCount = t.maxIndexCount),
          (a._geometryInitialized = t.geometryInitialized),
          (a._geometryCount = t.geometryCount),
          (a._matricesTexture = u(t.matricesTexture.uuid)),
          void 0 !== t.colorsTexture &&
            (a._colorsTexture = u(t.colorsTexture.uuid))
        break
      case 'LOD':
        a = new fh()
        break
      case 'Line':
        a = new du(c(t.geometry), h(t.material))
        break
      case 'LineLoop':
        a = new vu(c(t.geometry), h(t.material))
        break
      case 'LineSegments':
        a = new gu(c(t.geometry), h(t.material))
        break
      case 'PointCloud':
      case 'Points':
        a = new Mu(c(t.geometry), h(t.material))
        break
      case 'Sprite':
        a = new uh(h(t.material))
        break
      case 'Group':
        a = new Nc()
        break
      case 'Bone':
        a = new Eh()
        break
      default:
        a = new nr()
    }
    if (
      ((a.uuid = t.uuid),
      void 0 !== t.name && (a.name = t.name),
      void 0 !== t.matrix
        ? (a.matrix.fromArray(t.matrix),
          void 0 !== t.matrixAutoUpdate &&
            (a.matrixAutoUpdate = t.matrixAutoUpdate),
          a.matrixAutoUpdate &&
            a.matrix.decompose(a.position, a.quaternion, a.scale))
        : (void 0 !== t.position && a.position.fromArray(t.position),
          void 0 !== t.rotation && a.rotation.fromArray(t.rotation),
          void 0 !== t.quaternion && a.quaternion.fromArray(t.quaternion),
          void 0 !== t.scale && a.scale.fromArray(t.scale)),
      void 0 !== t.up && a.up.fromArray(t.up),
      void 0 !== t.castShadow && (a.castShadow = t.castShadow),
      void 0 !== t.receiveShadow && (a.receiveShadow = t.receiveShadow),
      t.shadow &&
        (void 0 !== t.shadow.intensity &&
          (a.shadow.intensity = t.shadow.intensity),
        void 0 !== t.shadow.bias && (a.shadow.bias = t.shadow.bias),
        void 0 !== t.shadow.normalBias &&
          (a.shadow.normalBias = t.shadow.normalBias),
        void 0 !== t.shadow.radius && (a.shadow.radius = t.shadow.radius),
        void 0 !== t.shadow.mapSize &&
          a.shadow.mapSize.fromArray(t.shadow.mapSize),
        void 0 !== t.shadow.camera &&
          (a.shadow.camera = this.parseObject(t.shadow.camera))),
      void 0 !== t.visible && (a.visible = t.visible),
      void 0 !== t.frustumCulled && (a.frustumCulled = t.frustumCulled),
      void 0 !== t.renderOrder && (a.renderOrder = t.renderOrder),
      void 0 !== t.userData && (a.userData = t.userData),
      void 0 !== t.layers && (a.layers.mask = t.layers),
      void 0 !== t.children)
    ) {
      const e = t.children
      for (let t = 0; t < e.length; t++)
        a.add(this.parseObject(e[t], n, i, s, r))
    }
    if (void 0 !== t.animations) {
      const e = t.animations
      for (let t = 0; t < e.length; t++) {
        const n = e[t]
        a.animations.push(r[n])
      }
    }
    if ('LOD' === t.type) {
      void 0 !== t.autoUpdate && (a.autoUpdate = t.autoUpdate)
      const e = t.levels
      for (let t = 0; t < e.length; t++) {
        const n = e[t],
          i = a.getObjectByProperty('uuid', n.object)
        void 0 !== i && a.addLevel(i, n.distance, n.hysteresis)
      }
    }
    return a
  }
  bindSkeletons(t, e) {
    0 !== Object.keys(e).length &&
      t.traverse(function (t) {
        if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
          const n = e[t.skeleton]
          void 0 === n
            ? console.warn(
                'THREE.ObjectLoader: No skeleton found with UUID:',
                t.skeleton
              )
            : t.bind(n, t.bindMatrix)
        }
      })
  }
  bindLightTargets(t) {
    t.traverse(function (e) {
      if (e.isDirectionalLight || e.isSpotLight) {
        const n = e.target,
          i = t.getObjectByProperty('uuid', n)
        e.target = void 0 !== i ? i : new nr()
      }
    })
  }
}
const Im = {
    UVMapping: 300,
    CubeReflectionMapping: ce,
    CubeRefractionMapping: he,
    EquirectangularReflectionMapping: ue,
    EquirectangularRefractionMapping: de,
    CubeUVReflectionMapping: pe
  },
  Lm = {
    RepeatWrapping: me,
    ClampToEdgeWrapping: fe,
    MirroredRepeatWrapping: ge
  },
  Dm = {
    NearestFilter: ve,
    NearestMipmapNearestFilter: ye,
    NearestMipmapLinearFilter: _e,
    LinearFilter: xe,
    LinearMipmapNearestFilter: be,
    LinearMipmapLinearFilter: we
  }
class km extends $p {
  static {
    e(this, 'ImageBitmapLoader')
  }
  constructor(t) {
    super(t),
      (this.isImageBitmapLoader = !0),
      'undefined' == typeof createImageBitmap &&
        console.warn(
          'THREE.ImageBitmapLoader: createImageBitmap() not supported.'
        ),
      'undefined' == typeof fetch &&
        console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
      (this.options = { premultiplyAlpha: 'none' })
  }
  setOptions(t) {
    return (this.options = t), this
  }
  load(t, e, n, i) {
    void 0 === t && (t = ''),
      void 0 !== this.path && (t = this.path + t),
      (t = this.manager.resolveURL(t))
    const s = this,
      r = Yp.get(t)
    if (void 0 !== r)
      return (
        s.manager.itemStart(t),
        r.then
          ? void r
              .then((n) => {
                e && e(n), s.manager.itemEnd(t)
              })
              .catch((t) => {
                i && i(t)
              })
          : (setTimeout(function () {
              e && e(r), s.manager.itemEnd(t)
            }, 0),
            r)
      )
    const a = {}
    ;(a.credentials =
      'anonymous' === this.crossOrigin ? 'same-origin' : 'include'),
      (a.headers = this.requestHeader)
    const o = fetch(t, a)
      .then(function (t) {
        return t.blob()
      })
      .then(function (t) {
        return createImageBitmap(
          t,
          Object.assign(s.options, { colorSpaceConversion: 'none' })
        )
      })
      .then(function (n) {
        return Yp.add(t, n), e && e(n), s.manager.itemEnd(t), n
      })
      .catch(function (e) {
        i && i(e), Yp.remove(t), s.manager.itemError(t), s.manager.itemEnd(t)
      })
    Yp.add(t, o), s.manager.itemStart(t)
  }
}
let Nm
class Um {
  static {
    e(this, 'AudioContext')
  }
  static getContext() {
    return (
      void 0 === Nm &&
        (Nm = new (window.AudioContext || window.webkitAudioContext)()),
      Nm
    )
  }
  static setContext(t) {
    Nm = t
  }
}
class Bm extends $p {
  static {
    e(this, 'AudioLoader')
  }
  constructor(t) {
    super(t)
  }
  load(t, n, i, s) {
    const r = this,
      a = new tm(this.manager)
    function o(e) {
      s ? s(e) : console.error(e), r.manager.itemError(t)
    }
    a.setResponseType('arraybuffer'),
      a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        t,
        function (t) {
          try {
            const e = t.slice(0)
            Um.getContext()
              .decodeAudioData(e, function (t) {
                n(t)
              })
              .catch(o)
          } catch (e) {
            o(e)
          }
        },
        i,
        s
      ),
      e(o, 'handleError')
  }
}
const Om = new Rs(),
  Fm = new Rs(),
  zm = new Rs()
class Vm {
  static {
    e(this, 'StereoCamera')
  }
  constructor() {
    ;(this.type = 'StereoCamera'),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new ba()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new ba()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null
      })
  }
  update(t) {
    const e = this._cache
    if (
      e.focus !== t.focus ||
      e.fov !== t.fov ||
      e.aspect !== t.aspect * this.aspect ||
      e.near !== t.near ||
      e.far !== t.far ||
      e.zoom !== t.zoom ||
      e.eyeSep !== this.eyeSep
    ) {
      ;(e.focus = t.focus),
        (e.fov = t.fov),
        (e.aspect = t.aspect * this.aspect),
        (e.near = t.near),
        (e.far = t.far),
        (e.zoom = t.zoom),
        (e.eyeSep = this.eyeSep),
        zm.copy(t.projectionMatrix)
      const n = e.eyeSep / 2,
        i = (n * e.near) / e.focus,
        s = (e.near * Math.tan(Xn * e.fov * 0.5)) / e.zoom
      let r, a
      ;(Fm.elements[12] = -n),
        (Om.elements[12] = n),
        (r = -s * e.aspect + i),
        (a = s * e.aspect + i),
        (zm.elements[0] = (2 * e.near) / (a - r)),
        (zm.elements[8] = (a + r) / (a - r)),
        this.cameraL.projectionMatrix.copy(zm),
        (r = -s * e.aspect - i),
        (a = s * e.aspect - i),
        (zm.elements[0] = (2 * e.near) / (a - r)),
        (zm.elements[8] = (a + r) / (a - r)),
        this.cameraR.projectionMatrix.copy(zm)
    }
    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Fm),
      this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Om)
  }
}
class Hm {
  static {
    e(this, 'Clock')
  }
  constructor(t = !0) {
    ;(this.autoStart = t),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1)
  }
  start() {
    ;(this.startTime = Gm()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0)
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1)
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime
  }
  getDelta() {
    let t = 0
    if (this.autoStart && !this.running) return this.start(), 0
    if (this.running) {
      const e = Gm()
      ;(t = (e - this.oldTime) / 1e3),
        (this.oldTime = e),
        (this.elapsedTime += t)
    }
    return t
  }
}
function Gm() {
  return performance.now()
}
e(Gm, 'now')
const Wm = new Qi(),
  jm = new Ji(),
  Xm = new Qi(),
  qm = new Qi()
class Ym extends nr {
  static {
    e(this, 'AudioListener')
  }
  constructor() {
    super(),
      (this.type = 'AudioListener'),
      (this.context = Um.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new Hm())
  }
  getInput() {
    return this.gain
  }
  removeFilter() {
    return (
      null !== this.filter &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    )
  }
  getFilter() {
    return this.filter
  }
  setFilter(t) {
    return (
      null !== this.filter
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = t),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    )
  }
  getMasterVolume() {
    return this.gain.gain.value
  }
  setMasterVolume(t) {
    return (
      this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
    )
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t)
    const e = this.context.listener,
      n = this.up
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(Wm, jm, Xm),
      qm.set(0, 0, -1).applyQuaternion(jm),
      e.positionX)
    ) {
      const t = this.context.currentTime + this.timeDelta
      e.positionX.linearRampToValueAtTime(Wm.x, t),
        e.positionY.linearRampToValueAtTime(Wm.y, t),
        e.positionZ.linearRampToValueAtTime(Wm.z, t),
        e.forwardX.linearRampToValueAtTime(qm.x, t),
        e.forwardY.linearRampToValueAtTime(qm.y, t),
        e.forwardZ.linearRampToValueAtTime(qm.z, t),
        e.upX.linearRampToValueAtTime(n.x, t),
        e.upY.linearRampToValueAtTime(n.y, t),
        e.upZ.linearRampToValueAtTime(n.z, t)
    } else
      e.setPosition(Wm.x, Wm.y, Wm.z),
        e.setOrientation(qm.x, qm.y, qm.z, n.x, n.y, n.z)
  }
}
class Zm extends nr {
  static {
    e(this, 'Audio')
  }
  constructor(t) {
    super(),
      (this.type = 'Audio'),
      (this.listener = t),
      (this.context = t.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(t.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = 'empty'),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = [])
  }
  getOutput() {
    return this.gain
  }
  setNodeSource(t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = 'audioNode'),
      (this.source = t),
      this.connect(),
      this
    )
  }
  setMediaElementSource(t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = 'mediaNode'),
      (this.source = this.context.createMediaElementSource(t)),
      this.connect(),
      this
    )
  }
  setMediaStreamSource(t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = 'mediaStreamNode'),
      (this.source = this.context.createMediaStreamSource(t)),
      this.connect(),
      this
    )
  }
  setBuffer(t) {
    return (
      (this.buffer = t),
      (this.sourceType = 'buffer'),
      this.autoplay && this.play(),
      this
    )
  }
  play(t = 0) {
    if (!0 === this.isPlaying)
      return void console.warn('THREE.Audio: Audio is already playing.')
    if (!1 === this.hasPlaybackControl)
      return void console.warn(
        'THREE.Audio: this Audio has no playback control.'
      )
    this._startedAt = this.context.currentTime + t
    const e = this.context.createBufferSource()
    return (
      (e.buffer = this.buffer),
      (e.loop = this.loop),
      (e.loopStart = this.loopStart),
      (e.loopEnd = this.loopEnd),
      (e.onended = this.onEnded.bind(this)),
      e.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = e),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    )
  }
  pause() {
    if (!1 !== this.hasPlaybackControl)
      return (
        !0 === this.isPlaying &&
          ((this._progress +=
            Math.max(this.context.currentTime - this._startedAt, 0) *
            this.playbackRate),
          !0 === this.loop &&
            (this._progress =
              this._progress % (this.duration || this.buffer.duration)),
          this.source.stop(),
          (this.source.onended = null),
          (this.isPlaying = !1)),
        this
      )
    console.warn('THREE.Audio: this Audio has no playback control.')
  }
  stop(t = 0) {
    if (!1 !== this.hasPlaybackControl)
      return (
        (this._progress = 0),
        null !== this.source &&
          (this.source.stop(this.context.currentTime + t),
          (this.source.onended = null)),
        (this.isPlaying = !1),
        this
      )
    console.warn('THREE.Audio: this Audio has no playback control.')
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0])
      for (let t = 1, e = this.filters.length; t < e; t++)
        this.filters[t - 1].connect(this.filters[t])
      this.filters[this.filters.length - 1].connect(this.getOutput())
    } else this.source.connect(this.getOutput())
    return (this._connected = !0), this
  }
  disconnect() {
    if (!1 !== this._connected) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0])
        for (let t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].disconnect(this.filters[t])
        this.filters[this.filters.length - 1].disconnect(this.getOutput())
      } else this.source.disconnect(this.getOutput())
      return (this._connected = !1), this
    }
  }
  getFilters() {
    return this.filters
  }
  setFilters(t) {
    return (
      t || (t = []),
      !0 === this._connected
        ? (this.disconnect(), (this.filters = t.slice()), this.connect())
        : (this.filters = t.slice()),
      this
    )
  }
  setDetune(t) {
    return (
      (this.detune = t),
      !0 === this.isPlaying &&
        void 0 !== this.source.detune &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01
        ),
      this
    )
  }
  getDetune() {
    return this.detune
  }
  getFilter() {
    return this.getFilters()[0]
  }
  setFilter(t) {
    return this.setFilters(t ? [t] : [])
  }
  setPlaybackRate(t) {
    if (!1 !== this.hasPlaybackControl)
      return (
        (this.playbackRate = t),
        !0 === this.isPlaying &&
          this.source.playbackRate.setTargetAtTime(
            this.playbackRate,
            this.context.currentTime,
            0.01
          ),
        this
      )
    console.warn('THREE.Audio: this Audio has no playback control.')
  }
  getPlaybackRate() {
    return this.playbackRate
  }
  onEnded() {
    this.isPlaying = !1
  }
  getLoop() {
    return !1 === this.hasPlaybackControl
      ? (console.warn('THREE.Audio: this Audio has no playback control.'), !1)
      : this.loop
  }
  setLoop(t) {
    if (!1 !== this.hasPlaybackControl)
      return (
        (this.loop = t),
        !0 === this.isPlaying && (this.source.loop = this.loop),
        this
      )
    console.warn('THREE.Audio: this Audio has no playback control.')
  }
  setLoopStart(t) {
    return (this.loopStart = t), this
  }
  setLoopEnd(t) {
    return (this.loopEnd = t), this
  }
  getVolume() {
    return this.gain.gain.value
  }
  setVolume(t) {
    return (
      this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
    )
  }
}
const Km = new Qi(),
  $m = new Ji(),
  Jm = new Qi(),
  Qm = new Qi()
class tf extends Zm {
  static {
    e(this, 'PositionalAudio')
  }
  constructor(t) {
    super(t),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = 'HRTF'),
      this.panner.connect(this.gain)
  }
  connect() {
    super.connect(), this.panner.connect(this.gain)
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain)
  }
  getOutput() {
    return this.panner
  }
  getRefDistance() {
    return this.panner.refDistance
  }
  setRefDistance(t) {
    return (this.panner.refDistance = t), this
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor
  }
  setRolloffFactor(t) {
    return (this.panner.rolloffFactor = t), this
  }
  getDistanceModel() {
    return this.panner.distanceModel
  }
  setDistanceModel(t) {
    return (this.panner.distanceModel = t), this
  }
  getMaxDistance() {
    return this.panner.maxDistance
  }
  setMaxDistance(t) {
    return (this.panner.maxDistance = t), this
  }
  setDirectionalCone(t, e, n) {
    return (
      (this.panner.coneInnerAngle = t),
      (this.panner.coneOuterAngle = e),
      (this.panner.coneOuterGain = n),
      this
    )
  }
  updateMatrixWorld(t) {
    if (
      (super.updateMatrixWorld(t),
      !0 === this.hasPlaybackControl && !1 === this.isPlaying)
    )
      return
    this.matrixWorld.decompose(Km, $m, Jm), Qm.set(0, 0, 1).applyQuaternion($m)
    const e = this.panner
    if (e.positionX) {
      const t = this.context.currentTime + this.listener.timeDelta
      e.positionX.linearRampToValueAtTime(Km.x, t),
        e.positionY.linearRampToValueAtTime(Km.y, t),
        e.positionZ.linearRampToValueAtTime(Km.z, t),
        e.orientationX.linearRampToValueAtTime(Qm.x, t),
        e.orientationY.linearRampToValueAtTime(Qm.y, t),
        e.orientationZ.linearRampToValueAtTime(Qm.z, t)
    } else e.setPosition(Km.x, Km.y, Km.z), e.setOrientation(Qm.x, Qm.y, Qm.z)
  }
}
class ef {
  static {
    e(this, 'AudioAnalyser')
  }
  constructor(t, e = 2048) {
    ;(this.analyser = t.context.createAnalyser()),
      (this.analyser.fftSize = e),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      t.getOutput().connect(this.analyser)
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data
  }
  getAverageFrequency() {
    let t = 0
    const e = this.getFrequencyData()
    for (let n = 0; n < e.length; n++) t += e[n]
    return t / e.length
  }
}
class nf {
  static {
    e(this, 'PropertyMixer')
  }
  constructor(t, e, n) {
    let i, s, r
    switch (((this.binding = t), (this.valueSize = n), e)) {
      case 'quaternion':
        ;(i = this._slerp),
          (s = this._slerpAdditive),
          (r = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(6 * n)),
          (this._workIndex = 5)
        break
      case 'string':
      case 'bool':
        ;(i = this._select),
          (s = this._select),
          (r = this._setAdditiveIdentityOther),
          (this.buffer = new Array(5 * n))
        break
      default:
        ;(i = this._lerp),
          (s = this._lerpAdditive),
          (r = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(5 * n))
    }
    ;(this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = r),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0)
  }
  accumulate(t, e) {
    const n = this.buffer,
      i = this.valueSize,
      s = t * i + i
    let r = this.cumulativeWeight
    if (0 === r) {
      for (let t = 0; t !== i; ++t) n[s + t] = n[t]
      r = e
    } else {
      r += e
      const t = e / r
      this._mixBufferRegion(n, s, 0, t, i)
    }
    this.cumulativeWeight = r
  }
  accumulateAdditive(t) {
    const e = this.buffer,
      n = this.valueSize,
      i = n * this._addIndex
    0 === this.cumulativeWeightAdditive && this._setIdentity(),
      this._mixBufferRegionAdditive(e, i, 0, t, n),
      (this.cumulativeWeightAdditive += t)
  }
  apply(t) {
    const e = this.valueSize,
      n = this.buffer,
      i = t * e + e,
      s = this.cumulativeWeight,
      r = this.cumulativeWeightAdditive,
      a = this.binding
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const t = e * this._origIndex
      this._mixBufferRegion(n, i, t, 1 - s, e)
    }
    r > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e)
    for (let o = e, l = e + e; o !== l; ++o)
      if (n[o] !== n[o + e]) {
        a.setValue(n, i)
        break
      }
  }
  saveOriginalState() {
    const t = this.binding,
      e = this.buffer,
      n = this.valueSize,
      i = n * this._origIndex
    t.getValue(e, i)
    for (let s = n, r = i; s !== r; ++s) e[s] = e[i + (s % n)]
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0)
  }
  restoreOriginalState() {
    const t = 3 * this.valueSize
    this.binding.setValue(this.buffer, t)
  }
  _setAdditiveIdentityNumeric() {
    const t = this._addIndex * this.valueSize,
      e = t + this.valueSize
    for (let n = t; n < e; n++) this.buffer[n] = 0
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1)
  }
  _setAdditiveIdentityOther() {
    const t = this._origIndex * this.valueSize,
      e = this._addIndex * this.valueSize
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[e + n] = this.buffer[t + n]
  }
  _select(t, e, n, i, s) {
    if (i >= 0.5) for (let r = 0; r !== s; ++r) t[e + r] = t[n + r]
  }
  _slerp(t, e, n, i) {
    Ji.slerpFlat(t, e, t, e, t, n, i)
  }
  _slerpAdditive(t, e, n, i, s) {
    const r = this._workIndex * s
    Ji.multiplyQuaternionsFlat(t, r, t, e, t, n),
      Ji.slerpFlat(t, e, t, e, t, r, i)
  }
  _lerp(t, e, n, i, s) {
    const r = 1 - i
    for (let a = 0; a !== s; ++a) {
      const s = e + a
      t[s] = t[s] * r + t[n + a] * i
    }
  }
  _lerpAdditive(t, e, n, i, s) {
    for (let r = 0; r !== s; ++r) {
      const s = e + r
      t[s] = t[s] + t[n + r] * i
    }
  }
}
const sf = '\\[\\]\\.:\\/',
  rf = new RegExp('[' + sf + ']', 'g'),
  af = '[^' + sf + ']',
  of = '[^' + sf.replace('\\.', '') + ']',
  lf = new RegExp(
    '^' +
      /((?:WC+[\/:])*)/.source.replace('WC', af) +
      /(WCOD+)?/.source.replace('WCOD', of) +
      /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', af) +
      /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', af) +
      '$'
  ),
  cf = ['material', 'materials', 'bones', 'map']
class hf {
  static {
    e(this, 'Composite')
  }
  constructor(t, e, n) {
    const i = n || uf.parseTrackName(e)
    ;(this._targetGroup = t), (this._bindings = t.subscribe_(e, i))
  }
  getValue(t, e) {
    this.bind()
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n]
    void 0 !== i && i.getValue(t, e)
  }
  setValue(t, e) {
    const n = this._bindings
    for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i)
      n[i].setValue(t, e)
  }
  bind() {
    const t = this._bindings
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].bind()
  }
  unbind() {
    const t = this._bindings
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].unbind()
  }
}
class uf {
  static {
    e(this, 'PropertyBinding')
  }
  constructor(t, e, n) {
    ;(this.path = e),
      (this.parsedPath = n || uf.parseTrackName(e)),
      (this.node = uf.findNode(t, this.parsedPath.nodeName)),
      (this.rootNode = t),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound)
  }
  static create(t, e, n) {
    return t && t.isAnimationObjectGroup
      ? new uf.Composite(t, e, n)
      : new uf(t, e, n)
  }
  static sanitizeNodeName(t) {
    return t.replace(/\s/g, '_').replace(rf, '')
  }
  static parseTrackName(t) {
    const e = lf.exec(t)
    if (null === e)
      throw new Error('PropertyBinding: Cannot parse trackName: ' + t)
    const n = {
        nodeName: e[2],
        objectName: e[3],
        objectIndex: e[4],
        propertyName: e[5],
        propertyIndex: e[6]
      },
      i = n.nodeName && n.nodeName.lastIndexOf('.')
    if (void 0 !== i && -1 !== i) {
      const t = n.nodeName.substring(i + 1)
      ;-1 !== cf.indexOf(t) &&
        ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t))
    }
    if (null === n.propertyName || 0 === n.propertyName.length)
      throw new Error(
        'PropertyBinding: can not parse propertyName from trackName: ' + t
      )
    return n
  }
  static findNode(t, n) {
    if (
      void 0 === n ||
      '' === n ||
      '.' === n ||
      -1 === n ||
      n === t.name ||
      n === t.uuid
    )
      return t
    if (t.skeleton) {
      const e = t.skeleton.getBoneByName(n)
      if (void 0 !== e) return e
    }
    if (t.children) {
      const i = e(function (t) {
          for (let e = 0; e < t.length; e++) {
            const s = t[e]
            if (s.name === n || s.uuid === n) return s
            const r = i(s.children)
            if (r) return r
          }
          return null
        }, 'searchNodeSubtree'),
        s = i(t.children)
      if (s) return s
    }
    return null
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(t, e) {
    t[e] = this.targetObject[this.propertyName]
  }
  _getValue_array(t, e) {
    const n = this.resolvedProperty
    for (let i = 0, s = n.length; i !== s; ++i) t[e++] = n[i]
  }
  _getValue_arrayElement(t, e) {
    t[e] = this.resolvedProperty[this.propertyIndex]
  }
  _getValue_toArray(t, e) {
    this.resolvedProperty.toArray(t, e)
  }
  _setValue_direct(t, e) {
    this.targetObject[this.propertyName] = t[e]
  }
  _setValue_direct_setNeedsUpdate(t, e) {
    ;(this.targetObject[this.propertyName] = t[e]),
      (this.targetObject.needsUpdate = !0)
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
    ;(this.targetObject[this.propertyName] = t[e]),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _setValue_array(t, e) {
    const n = this.resolvedProperty
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = t[e++]
  }
  _setValue_array_setNeedsUpdate(t, e) {
    const n = this.resolvedProperty
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = t[e++]
    this.targetObject.needsUpdate = !0
  }
  _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
    const n = this.resolvedProperty
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = t[e++]
    this.targetObject.matrixWorldNeedsUpdate = !0
  }
  _setValue_arrayElement(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e]
  }
  _setValue_arrayElement_setNeedsUpdate(t, e) {
    ;(this.resolvedProperty[this.propertyIndex] = t[e]),
      (this.targetObject.needsUpdate = !0)
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
    ;(this.resolvedProperty[this.propertyIndex] = t[e]),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _setValue_fromArray(t, e) {
    this.resolvedProperty.fromArray(t, e)
  }
  _setValue_fromArray_setNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0)
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _getValue_unbound(t, e) {
    this.bind(), this.getValue(t, e)
  }
  _setValue_unbound(t, e) {
    this.bind(), this.setValue(t, e)
  }
  bind() {
    let t = this.node
    const e = this.parsedPath,
      n = e.objectName,
      i = e.propertyName
    let s = e.propertyIndex
    if (
      (t || ((t = uf.findNode(this.rootNode, e.nodeName)), (this.node = t)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !t)
    )
      return void console.warn(
        'THREE.PropertyBinding: No target node found for track: ' +
          this.path +
          '.'
      )
    if (n) {
      let i = e.objectIndex
      switch (n) {
        case 'materials':
          if (!t.material)
            return void console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this
            )
          if (!t.material.materials)
            return void console.error(
              'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
              this
            )
          t = t.material.materials
          break
        case 'bones':
          if (!t.skeleton)
            return void console.error(
              'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
              this
            )
          t = t.skeleton.bones
          for (let e = 0; e < t.length; e++)
            if (t[e].name === i) {
              i = e
              break
            }
          break
        case 'map':
          if ('map' in t) {
            t = t.map
            break
          }
          if (!t.material)
            return void console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this
            )
          if (!t.material.map)
            return void console.error(
              'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.',
              this
            )
          t = t.material.map
          break
        default:
          if (void 0 === t[n])
            return void console.error(
              'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
              this
            )
          t = t[n]
      }
      if (void 0 !== i) {
        if (void 0 === t[i])
          return void console.error(
            'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
            this,
            t
          )
        t = t[i]
      }
    }
    const r = t[i]
    if (void 0 === r) {
      const n = e.nodeName
      return void console.error(
        'THREE.PropertyBinding: Trying to update property for track: ' +
          n +
          '.' +
          i +
          " but it wasn't found.",
        t
      )
    }
    let a = this.Versioning.None
    ;(this.targetObject = t),
      void 0 !== t.needsUpdate
        ? (a = this.Versioning.NeedsUpdate)
        : void 0 !== t.matrixWorldNeedsUpdate &&
          (a = this.Versioning.MatrixWorldNeedsUpdate)
    let o = this.BindingType.Direct
    if (void 0 !== s) {
      if ('morphTargetInfluences' === i) {
        if (!t.geometry)
          return void console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
            this
          )
        if (!t.geometry.morphAttributes)
          return void console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
            this
          )
        void 0 !== t.morphTargetDictionary[s] &&
          (s = t.morphTargetDictionary[s])
      }
      ;(o = this.BindingType.ArrayElement),
        (this.resolvedProperty = r),
        (this.propertyIndex = s)
    } else
      void 0 !== r.fromArray && void 0 !== r.toArray
        ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = r))
        : Array.isArray(r)
          ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = r))
          : (this.propertyName = i)
    ;(this.getValue = this.GetterByBindingType[o]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[o][a])
  }
  unbind() {
    ;(this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound)
  }
}
;(uf.Composite = hf),
  (uf.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  }),
  (uf.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  }),
  (uf.prototype.GetterByBindingType = [
    uf.prototype._getValue_direct,
    uf.prototype._getValue_array,
    uf.prototype._getValue_arrayElement,
    uf.prototype._getValue_toArray
  ]),
  (uf.prototype.SetterByBindingTypeAndVersioning = [
    [
      uf.prototype._setValue_direct,
      uf.prototype._setValue_direct_setNeedsUpdate,
      uf.prototype._setValue_direct_setMatrixWorldNeedsUpdate
    ],
    [
      uf.prototype._setValue_array,
      uf.prototype._setValue_array_setNeedsUpdate,
      uf.prototype._setValue_array_setMatrixWorldNeedsUpdate
    ],
    [
      uf.prototype._setValue_arrayElement,
      uf.prototype._setValue_arrayElement_setNeedsUpdate,
      uf.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
    ],
    [
      uf.prototype._setValue_fromArray,
      uf.prototype._setValue_fromArray_setNeedsUpdate,
      uf.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
    ]
  ])
class df {
  static {
    e(this, 'AnimationObjectGroup')
  }
  constructor() {
    ;(this.isAnimationObjectGroup = !0),
      (this.uuid = Yn()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0)
    const t = {}
    this._indicesByUUID = t
    for (let n = 0, i = arguments.length; n !== i; ++n) t[arguments[n].uuid] = n
    ;(this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {})
    const e = this
    this.stats = {
      objects: {
        get total() {
          return e._objects.length
        },
        get inUse() {
          return this.total - e.nCachedObjects_
        }
      },
      get bindingsPerObject() {
        return e._bindings.length
      }
    }
  }
  add() {
    const t = this._objects,
      e = this._indicesByUUID,
      n = this._paths,
      i = this._parsedPaths,
      s = this._bindings,
      r = s.length
    let a,
      o = t.length,
      l = this.nCachedObjects_
    for (let c = 0, h = arguments.length; c !== h; ++c) {
      const h = arguments[c],
        u = h.uuid
      let d = e[u]
      if (void 0 === d) {
        ;(d = o++), (e[u] = d), t.push(h)
        for (let t = 0, e = r; t !== e; ++t) s[t].push(new uf(h, n[t], i[t]))
      } else if (d < l) {
        a = t[d]
        const o = --l,
          c = t[o]
        ;(e[c.uuid] = d), (t[d] = c), (e[u] = o), (t[o] = h)
        for (let t = 0, e = r; t !== e; ++t) {
          const e = s[t],
            r = e[o]
          let a = e[d]
          ;(e[d] = r), void 0 === a && (a = new uf(h, n[t], i[t])), (e[o] = a)
        }
      } else
        t[d] !== a &&
          console.error(
            'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.'
          )
    }
    this.nCachedObjects_ = l
  }
  remove() {
    const t = this._objects,
      e = this._indicesByUUID,
      n = this._bindings,
      i = n.length
    let s = this.nCachedObjects_
    for (let r = 0, a = arguments.length; r !== a; ++r) {
      const a = arguments[r],
        o = a.uuid,
        l = e[o]
      if (void 0 !== l && l >= s) {
        const r = s++,
          c = t[r]
        ;(e[c.uuid] = l), (t[l] = c), (e[o] = r), (t[r] = a)
        for (let t = 0, e = i; t !== e; ++t) {
          const e = n[t],
            i = e[r],
            s = e[l]
          ;(e[l] = i), (e[r] = s)
        }
      }
    }
    this.nCachedObjects_ = s
  }
  uncache() {
    const t = this._objects,
      e = this._indicesByUUID,
      n = this._bindings,
      i = n.length
    let s = this.nCachedObjects_,
      r = t.length
    for (let a = 0, o = arguments.length; a !== o; ++a) {
      const o = arguments[a].uuid,
        l = e[o]
      if (void 0 !== l)
        if ((delete e[o], l < s)) {
          const a = --s,
            o = t[a],
            c = --r,
            h = t[c]
          ;(e[o.uuid] = l), (t[l] = o), (e[h.uuid] = a), (t[a] = h), t.pop()
          for (let t = 0, e = i; t !== e; ++t) {
            const e = n[t],
              i = e[a],
              s = e[c]
            ;(e[l] = i), (e[a] = s), e.pop()
          }
        } else {
          const s = --r,
            a = t[s]
          s > 0 && (e[a.uuid] = l), (t[l] = a), t.pop()
          for (let t = 0, e = i; t !== e; ++t) {
            const e = n[t]
            ;(e[l] = e[s]), e.pop()
          }
        }
    }
    this.nCachedObjects_ = s
  }
  subscribe_(t, e) {
    const n = this._bindingsIndicesByPath
    let i = n[t]
    const s = this._bindings
    if (void 0 !== i) return s[i]
    const r = this._paths,
      a = this._parsedPaths,
      o = this._objects,
      l = o.length,
      c = this.nCachedObjects_,
      h = new Array(l)
    ;(i = s.length), (n[t] = i), r.push(t), a.push(e), s.push(h)
    for (let u = c, d = o.length; u !== d; ++u) {
      const n = o[u]
      h[u] = new uf(n, t, e)
    }
    return h
  }
  unsubscribe_(t) {
    const e = this._bindingsIndicesByPath,
      n = e[t]
    if (void 0 !== n) {
      const i = this._paths,
        s = this._parsedPaths,
        r = this._bindings,
        a = r.length - 1,
        o = r[a]
      ;(e[t[a]] = n),
        (r[n] = o),
        r.pop(),
        (s[n] = s[a]),
        s.pop(),
        (i[n] = i[a]),
        i.pop()
    }
  }
}
class pf {
  static {
    e(this, 'AnimationAction')
  }
  constructor(t, e, n = null, i = e.blendMode) {
    ;(this._mixer = t),
      (this._clip = e),
      (this._localRoot = n),
      (this.blendMode = i)
    const s = e.tracks,
      r = s.length,
      a = new Array(r),
      o = { endingStart: xn, endingEnd: xn }
    for (let l = 0; l !== r; ++l) {
      const t = s[l].createInterpolant(null)
      ;(a[l] = t), (t.settings = o)
    }
    ;(this._interpolantSettings = o),
      (this._interpolants = a),
      (this._propertyBindings = new Array(r)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = 2201),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0)
  }
  play() {
    return this._mixer._activateAction(this), this
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset()
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    )
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      0 !== this.timeScale &&
      null === this._startTime &&
      this._mixer._isActiveAction(this)
    )
  }
  isScheduled() {
    return this._mixer._isActiveAction(this)
  }
  startAt(t) {
    return (this._startTime = t), this
  }
  setLoop(t, e) {
    return (this.loop = t), (this.repetitions = e), this
  }
  setEffectiveWeight(t) {
    return (
      (this.weight = t),
      (this._effectiveWeight = this.enabled ? t : 0),
      this.stopFading()
    )
  }
  getEffectiveWeight() {
    return this._effectiveWeight
  }
  fadeIn(t) {
    return this._scheduleFading(t, 0, 1)
  }
  fadeOut(t) {
    return this._scheduleFading(t, 1, 0)
  }
  crossFadeFrom(t, e, n) {
    if ((t.fadeOut(e), this.fadeIn(e), n)) {
      const n = this._clip.duration,
        i = t._clip.duration,
        s = i / n,
        r = n / i
      t.warp(1, s, e), this.warp(r, 1, e)
    }
    return this
  }
  crossFadeTo(t, e, n) {
    return t.crossFadeFrom(this, e, n)
  }
  stopFading() {
    const t = this._weightInterpolant
    return (
      null !== t &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(t)),
      this
    )
  }
  setEffectiveTimeScale(t) {
    return (
      (this.timeScale = t),
      (this._effectiveTimeScale = this.paused ? 0 : t),
      this.stopWarping()
    )
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale
  }
  setDuration(t) {
    return (this.timeScale = this._clip.duration / t), this.stopWarping()
  }
  syncWith(t) {
    return (
      (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping()
    )
  }
  halt(t) {
    return this.warp(this._effectiveTimeScale, 0, t)
  }
  warp(t, e, n) {
    const i = this._mixer,
      s = i.time,
      r = this.timeScale
    let a = this._timeScaleInterpolant
    null === a &&
      ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a))
    const o = a.parameterPositions,
      l = a.sampleValues
    return (o[0] = s), (o[1] = s + n), (l[0] = t / r), (l[1] = e / r), this
  }
  stopWarping() {
    const t = this._timeScaleInterpolant
    return (
      null !== t &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(t)),
      this
    )
  }
  getMixer() {
    return this._mixer
  }
  getClip() {
    return this._clip
  }
  getRoot() {
    return this._localRoot || this._mixer._root
  }
  _update(t, e, n, i) {
    if (!this.enabled) return void this._updateWeight(t)
    const s = this._startTime
    if (null !== s) {
      const i = (t - s) * n
      i < 0 || 0 === n ? (e = 0) : ((this._startTime = null), (e = n * i))
    }
    e *= this._updateTimeScale(t)
    const r = this._updateTime(e),
      a = this._updateWeight(t)
    if (a > 0) {
      const t = this._interpolants,
        e = this._propertyBindings
      if (2501 === this.blendMode)
        for (let n = 0, i = t.length; n !== i; ++n)
          t[n].evaluate(r), e[n].accumulateAdditive(a)
      else
        for (let n = 0, s = t.length; n !== s; ++n)
          t[n].evaluate(r), e[n].accumulate(i, a)
    }
  }
  _updateWeight(t) {
    let e = 0
    if (this.enabled) {
      e = this.weight
      const n = this._weightInterpolant
      if (null !== n) {
        const i = n.evaluate(t)[0]
        ;(e *= i),
          t > n.parameterPositions[1] &&
            (this.stopFading(), 0 === i && (this.enabled = !1))
      }
    }
    return (this._effectiveWeight = e), e
  }
  _updateTimeScale(t) {
    let e = 0
    if (!this.paused) {
      e = this.timeScale
      const n = this._timeScaleInterpolant
      if (null !== n) {
        ;(e *= n.evaluate(t)[0]),
          t > n.parameterPositions[1] &&
            (this.stopWarping(),
            0 === e ? (this.paused = !0) : (this.timeScale = e))
      }
    }
    return (this._effectiveTimeScale = e), e
  }
  _updateTime(t) {
    const e = this._clip.duration,
      n = this.loop
    let i = this.time + t,
      s = this._loopCount
    const r = 2202 === n
    if (0 === t) return -1 === s || !r || 1 & ~s ? i : e - i
    if (2200 === n) {
      ;-1 === s && ((this._loopCount = 0), this._setEndings(!0, !0, !1))
      t: {
        if (i >= e) i = e
        else {
          if (!(i < 0)) {
            this.time = i
            break t
          }
          i = 0
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: t < 0 ? -1 : 1
          })
      }
    } else {
      if (
        (-1 === s &&
          (t >= 0
            ? ((s = 0), this._setEndings(!0, 0 === this.repetitions, r))
            : this._setEndings(0 === this.repetitions, !0, r)),
        i >= e || i < 0)
      ) {
        const n = Math.floor(i / e)
        ;(i -= e * n), (s += Math.abs(n))
        const a = this.repetitions - s
        if (a <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = t > 0 ? e : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: 'finished',
              action: this,
              direction: t > 0 ? 1 : -1
            })
        else {
          if (1 === a) {
            const e = t < 0
            this._setEndings(e, !e, r)
          } else this._setEndings(!1, !1, r)
          ;(this._loopCount = s),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: 'loop',
              action: this,
              loopDelta: n
            })
        }
      } else this.time = i
      if (r && !(1 & ~s)) return e - i
    }
    return i
  }
  _setEndings(t, e, n) {
    const i = this._interpolantSettings
    n
      ? ((i.endingStart = bn), (i.endingEnd = bn))
      : ((i.endingStart = t ? (this.zeroSlopeAtStart ? bn : xn) : wn),
        (i.endingEnd = e ? (this.zeroSlopeAtEnd ? bn : xn) : wn))
  }
  _scheduleFading(t, e, n) {
    const i = this._mixer,
      s = i.time
    let r = this._weightInterpolant
    null === r &&
      ((r = i._lendControlInterpolant()), (this._weightInterpolant = r))
    const a = r.parameterPositions,
      o = r.sampleValues
    return (a[0] = s), (o[0] = e), (a[1] = s + t), (o[1] = n), this
  }
}
const mf = new Float32Array(1)
class ff extends Gn {
  static {
    e(this, 'AnimationMixer')
  }
  constructor(t) {
    super(),
      (this._root = t),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1)
  }
  _bindAction(t, e) {
    const n = t._localRoot || this._root,
      i = t._clip.tracks,
      s = i.length,
      r = t._propertyBindings,
      a = t._interpolants,
      o = n.uuid,
      l = this._bindingsByRootAndName
    let c = l[o]
    void 0 === c && ((c = {}), (l[o] = c))
    for (let h = 0; h !== s; ++h) {
      const t = i[h],
        s = t.name
      let l = c[s]
      if (void 0 !== l) ++l.referenceCount, (r[h] = l)
      else {
        if (((l = r[h]), void 0 !== l)) {
          null === l._cacheIndex &&
            (++l.referenceCount, this._addInactiveBinding(l, o, s))
          continue
        }
        const i = e && e._propertyBindings[h].binding.parsedPath
        ;(l = new nf(uf.create(n, s, i), t.ValueTypeName, t.getValueSize())),
          ++l.referenceCount,
          this._addInactiveBinding(l, o, s),
          (r[h] = l)
      }
      a[h].resultBuffer = l.buffer
    }
  }
  _activateAction(t) {
    if (!this._isActiveAction(t)) {
      if (null === t._cacheIndex) {
        const e = (t._localRoot || this._root).uuid,
          n = t._clip.uuid,
          i = this._actionsByClip[n]
        this._bindAction(t, i && i.knownActions[0]),
          this._addInactiveAction(t, n, e)
      }
      const e = t._propertyBindings
      for (let t = 0, n = e.length; t !== n; ++t) {
        const n = e[t]
        0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
      }
      this._lendAction(t)
    }
  }
  _deactivateAction(t) {
    if (this._isActiveAction(t)) {
      const e = t._propertyBindings
      for (let t = 0, n = e.length; t !== n; ++t) {
        const n = e[t]
        0 == --n.useCount &&
          (n.restoreOriginalState(), this._takeBackBinding(n))
      }
      this._takeBackAction(t)
    }
  }
  _initMemoryManager() {
    ;(this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0)
    const t = this
    this.stats = {
      actions: {
        get total() {
          return t._actions.length
        },
        get inUse() {
          return t._nActiveActions
        }
      },
      bindings: {
        get total() {
          return t._bindings.length
        },
        get inUse() {
          return t._nActiveBindings
        }
      },
      controlInterpolants: {
        get total() {
          return t._controlInterpolants.length
        },
        get inUse() {
          return t._nActiveControlInterpolants
        }
      }
    }
  }
  _isActiveAction(t) {
    const e = t._cacheIndex
    return null !== e && e < this._nActiveActions
  }
  _addInactiveAction(t, e, n) {
    const i = this._actions,
      s = this._actionsByClip
    let r = s[e]
    if (void 0 === r)
      (r = { knownActions: [t], actionByRoot: {} }),
        (t._byClipCacheIndex = 0),
        (s[e] = r)
    else {
      const e = r.knownActions
      ;(t._byClipCacheIndex = e.length), e.push(t)
    }
    ;(t._cacheIndex = i.length), i.push(t), (r.actionByRoot[n] = t)
  }
  _removeInactiveAction(t) {
    const e = this._actions,
      n = e[e.length - 1],
      i = t._cacheIndex
    ;(n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null)
    const s = t._clip.uuid,
      r = this._actionsByClip,
      a = r[s],
      o = a.knownActions,
      l = o[o.length - 1],
      c = t._byClipCacheIndex
    ;(l._byClipCacheIndex = c),
      (o[c] = l),
      o.pop(),
      (t._byClipCacheIndex = null)
    delete a.actionByRoot[(t._localRoot || this._root).uuid],
      0 === o.length && delete r[s],
      this._removeInactiveBindingsForAction(t)
  }
  _removeInactiveBindingsForAction(t) {
    const e = t._propertyBindings
    for (let n = 0, i = e.length; n !== i; ++n) {
      const t = e[n]
      0 == --t.referenceCount && this._removeInactiveBinding(t)
    }
  }
  _lendAction(t) {
    const e = this._actions,
      n = t._cacheIndex,
      i = this._nActiveActions++,
      s = e[i]
    ;(t._cacheIndex = i), (e[i] = t), (s._cacheIndex = n), (e[n] = s)
  }
  _takeBackAction(t) {
    const e = this._actions,
      n = t._cacheIndex,
      i = --this._nActiveActions,
      s = e[i]
    ;(t._cacheIndex = i), (e[i] = t), (s._cacheIndex = n), (e[n] = s)
  }
  _addInactiveBinding(t, e, n) {
    const i = this._bindingsByRootAndName,
      s = this._bindings
    let r = i[e]
    void 0 === r && ((r = {}), (i[e] = r)),
      (r[n] = t),
      (t._cacheIndex = s.length),
      s.push(t)
  }
  _removeInactiveBinding(t) {
    const e = this._bindings,
      n = t.binding,
      i = n.rootNode.uuid,
      s = n.path,
      r = this._bindingsByRootAndName,
      a = r[i],
      o = e[e.length - 1],
      l = t._cacheIndex
    ;(o._cacheIndex = l),
      (e[l] = o),
      e.pop(),
      delete a[s],
      0 === Object.keys(a).length && delete r[i]
  }
  _lendBinding(t) {
    const e = this._bindings,
      n = t._cacheIndex,
      i = this._nActiveBindings++,
      s = e[i]
    ;(t._cacheIndex = i), (e[i] = t), (s._cacheIndex = n), (e[n] = s)
  }
  _takeBackBinding(t) {
    const e = this._bindings,
      n = t._cacheIndex,
      i = --this._nActiveBindings,
      s = e[i]
    ;(t._cacheIndex = i), (e[i] = t), (s._cacheIndex = n), (e[n] = s)
  }
  _lendControlInterpolant() {
    const t = this._controlInterpolants,
      e = this._nActiveControlInterpolants++
    let n = t[e]
    return (
      void 0 === n &&
        ((n = new Np(new Float32Array(2), new Float32Array(2), 1, mf)),
        (n.__cacheIndex = e),
        (t[e] = n)),
      n
    )
  }
  _takeBackControlInterpolant(t) {
    const e = this._controlInterpolants,
      n = t.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      s = e[i]
    ;(t.__cacheIndex = i), (e[i] = t), (s.__cacheIndex = n), (e[n] = s)
  }
  clipAction(t, e, n) {
    const i = e || this._root,
      s = i.uuid
    let r = 'string' == typeof t ? jp.findByName(i, t) : t
    const a = null !== r ? r.uuid : t,
      o = this._actionsByClip[a]
    let l = null
    if ((void 0 === n && (n = null !== r ? r.blendMode : Mn), void 0 !== o)) {
      const t = o.actionByRoot[s]
      if (void 0 !== t && t.blendMode === n) return t
      ;(l = o.knownActions[0]), null === r && (r = l._clip)
    }
    if (null === r) return null
    const c = new pf(this, r, e, n)
    return this._bindAction(c, l), this._addInactiveAction(c, a, s), c
  }
  existingAction(t, e) {
    const n = e || this._root,
      i = n.uuid,
      s = 'string' == typeof t ? jp.findByName(n, t) : t,
      r = s ? s.uuid : t,
      a = this._actionsByClip[r]
    return (void 0 !== a && a.actionByRoot[i]) || null
  }
  stopAllAction() {
    const t = this._actions
    for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop()
    return this
  }
  update(t) {
    t *= this.timeScale
    const e = this._actions,
      n = this._nActiveActions,
      i = (this.time += t),
      s = Math.sign(t),
      r = (this._accuIndex ^= 1)
    for (let l = 0; l !== n; ++l) {
      e[l]._update(i, t, s, r)
    }
    const a = this._bindings,
      o = this._nActiveBindings
    for (let l = 0; l !== o; ++l) a[l].apply(r)
    return this
  }
  setTime(t) {
    this.time = 0
    for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0
    return this.update(t)
  }
  getRoot() {
    return this._root
  }
  uncacheClip(t) {
    const e = this._actions,
      n = t.uuid,
      i = this._actionsByClip,
      s = i[n]
    if (void 0 !== s) {
      const t = s.knownActions
      for (let n = 0, i = t.length; n !== i; ++n) {
        const i = t[n]
        this._deactivateAction(i)
        const s = i._cacheIndex,
          r = e[e.length - 1]
        ;(i._cacheIndex = null),
          (i._byClipCacheIndex = null),
          (r._cacheIndex = s),
          (e[s] = r),
          e.pop(),
          this._removeInactiveBindingsForAction(i)
      }
      delete i[n]
    }
  }
  uncacheRoot(t) {
    const e = t.uuid,
      n = this._actionsByClip
    for (const s in n) {
      const t = n[s].actionByRoot[e]
      void 0 !== t && (this._deactivateAction(t), this._removeInactiveAction(t))
    }
    const i = this._bindingsByRootAndName[e]
    if (void 0 !== i)
      for (const s in i) {
        const t = i[s]
        t.restoreOriginalState(), this._removeInactiveBinding(t)
      }
  }
  uncacheAction(t, e) {
    const n = this.existingAction(t, e)
    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
  }
}
class gf {
  static {
    e(this, 'Uniform')
  }
  constructor(t) {
    this.value = t
  }
  clone() {
    return new gf(void 0 === this.value.clone ? this.value : this.value.clone())
  }
}
let vf = 0
class yf extends Gn {
  static {
    e(this, 'UniformsGroup')
  }
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, 'id', { value: vf++ }),
      (this.name = ''),
      (this.usage = Fn),
      (this.uniforms = [])
  }
  add(t) {
    return this.uniforms.push(t), this
  }
  remove(t) {
    const e = this.uniforms.indexOf(t)
    return -1 !== e && this.uniforms.splice(e, 1), this
  }
  setName(t) {
    return (this.name = t), this
  }
  setUsage(t) {
    return (this.usage = t), this
  }
  dispose() {
    return this.dispatchEvent({ type: 'dispose' }), this
  }
  copy(t) {
    ;(this.name = t.name), (this.usage = t.usage)
    const e = t.uniforms
    this.uniforms.length = 0
    for (let n = 0, i = e.length; n < i; n++) {
      const t = Array.isArray(e[n]) ? e[n] : [e[n]]
      for (let e = 0; e < t.length; e++) this.uniforms.push(t[e].clone())
    }
    return this
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class _f extends Yc {
  static {
    e(this, 'InstancedInterleavedBuffer')
  }
  constructor(t, e, n = 1) {
    super(t, e),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = n)
  }
  copy(t) {
    return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
  }
  clone(t) {
    const e = super.clone(t)
    return (e.meshPerAttribute = this.meshPerAttribute), e
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      (e.isInstancedInterleavedBuffer = !0),
      (e.meshPerAttribute = this.meshPerAttribute),
      e
    )
  }
}
class xf {
  static {
    e(this, 'GLBufferAttribute')
  }
  constructor(t, e, n, i, s) {
    ;(this.isGLBufferAttribute = !0),
      (this.name = ''),
      (this.buffer = t),
      (this.type = e),
      (this.itemSize = n),
      (this.elementSize = i),
      (this.count = s),
      (this.version = 0)
  }
  set needsUpdate(t) {
    !0 === t && this.version++
  }
  setBuffer(t) {
    return (this.buffer = t), this
  }
  setType(t, e) {
    return (this.type = t), (this.elementSize = e), this
  }
  setItemSize(t) {
    return (this.itemSize = t), this
  }
  setCount(t) {
    return (this.count = t), this
  }
}
const bf = new Rs()
class wf {
  static {
    e(this, 'Raycaster')
  }
  constructor(t, e, n = 0, i = 1 / 0) {
    ;(this.ray = new Cs(t, e)),
      (this.near = n),
      (this.far = i),
      (this.camera = null),
      (this.layers = new zs()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {}
      })
  }
  set(t, e) {
    this.ray.set(t, e)
  }
  setFromCamera(t, e) {
    e.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction
          .set(t.x, t.y, 0.5)
          .unproject(e)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = e))
      : e.isOrthographicCamera
        ? (this.ray.origin
            .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
            .unproject(e),
          this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
          (this.camera = e))
        : console.error('THREE.Raycaster: Unsupported camera type: ' + e.type)
  }
  setFromXRController(t) {
    return (
      bf.identity().extractRotation(t.matrixWorld),
      this.ray.origin.setFromMatrixPosition(t.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(bf),
      this
    )
  }
  intersectObject(t, e = !0, n = []) {
    return Sf(t, this, n, e), n.sort(Mf), n
  }
  intersectObjects(t, e = !0, n = []) {
    for (let i = 0, s = t.length; i < s; i++) Sf(t[i], this, n, e)
    return n.sort(Mf), n
  }
}
function Mf(t, e) {
  return t.distance - e.distance
}
function Sf(t, e, n, i) {
  let s = !0
  if (t.layers.test(e.layers)) {
    !1 === t.raycast(e, n) && (s = !1)
  }
  if (!0 === s && !0 === i) {
    const i = t.children
    for (let t = 0, s = i.length; t < s; t++) Sf(i[t], e, n, !0)
  }
}
e(Mf, 'ascSort'), e(Sf, 'intersect')
class Tf {
  static {
    e(this, 'Spherical')
  }
  constructor(t = 1, e = 0, n = 0) {
    return (this.radius = t), (this.phi = e), (this.theta = n), this
  }
  set(t, e, n) {
    return (this.radius = t), (this.phi = e), (this.theta = n), this
  }
  copy(t) {
    return (
      (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this
    )
  }
  makeSafe() {
    const t = 1e-6
    return (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this
  }
  setFromVector3(t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z)
  }
  setFromCartesianCoords(t, e, n) {
    return (
      (this.radius = Math.sqrt(t * t + e * e + n * n)),
      0 === this.radius
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(t, n)),
          (this.phi = Math.acos(Zn(e / this.radius, -1, 1)))),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class Ef {
  static {
    e(this, 'Cylindrical')
  }
  constructor(t = 1, e = 0, n = 0) {
    return (this.radius = t), (this.theta = e), (this.y = n), this
  }
  set(t, e, n) {
    return (this.radius = t), (this.theta = e), (this.y = n), this
  }
  copy(t) {
    return (
      (this.radius = t.radius), (this.theta = t.theta), (this.y = t.y), this
    )
  }
  setFromVector3(t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z)
  }
  setFromCartesianCoords(t, e, n) {
    return (
      (this.radius = Math.sqrt(t * t + n * n)),
      (this.theta = Math.atan2(t, n)),
      (this.y = e),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class Af {
  static {
    e(this, 'Matrix2')
  }
  constructor(t, e, n, i) {
    ;(Af.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      void 0 !== t && this.set(t, e, n, i)
  }
  identity() {
    return this.set(1, 0, 0, 1), this
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 4; n++) this.elements[n] = t[n + e]
    return this
  }
  set(t, e, n, i) {
    const s = this.elements
    return (s[0] = t), (s[2] = e), (s[1] = n), (s[3] = i), this
  }
}
const Cf = new vi()
class Rf {
  static {
    e(this, 'Box2')
  }
  constructor(t = new vi(1 / 0, 1 / 0), e = new vi(-1 / 0, -1 / 0)) {
    ;(this.isBox2 = !0), (this.min = t), (this.max = e)
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this
  }
  setFromPoints(t) {
    this.makeEmpty()
    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e])
    return this
  }
  setFromCenterAndSize(t, e) {
    const n = Cf.copy(e).multiplyScalar(0.5)
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    )
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y
  }
  getCenter(t) {
    return this.isEmpty()
      ? t.set(0, 0)
      : t.addVectors(this.min, this.max).multiplyScalar(0.5)
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this
  }
  containsPoint(t) {
    return (
      t.x >= this.min.x &&
      t.x <= this.max.x &&
      t.y >= this.min.y &&
      t.y <= this.max.y
    )
  }
  containsBox(t) {
    return (
      this.min.x <= t.min.x &&
      t.max.x <= this.max.x &&
      this.min.y <= t.min.y &&
      t.max.y <= this.max.y
    )
  }
  getParameter(t, e) {
    return e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y)
    )
  }
  intersectsBox(t) {
    return (
      t.max.x >= this.min.x &&
      t.min.x <= this.max.x &&
      t.max.y >= this.min.y &&
      t.min.y <= this.max.y
    )
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max)
  }
  distanceToPoint(t) {
    return this.clampPoint(t, Cf).distanceTo(t)
  }
  intersect(t) {
    return (
      this.min.max(t.min),
      this.max.min(t.max),
      this.isEmpty() && this.makeEmpty(),
      this
    )
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max)
  }
}
const Pf = new Qi(),
  If = new Qi()
class Lf {
  static {
    e(this, 'Line3')
  }
  constructor(t = new Qi(), e = new Qi()) {
    ;(this.start = t), (this.end = e)
  }
  set(t, e) {
    return this.start.copy(t), this.end.copy(e), this
  }
  copy(t) {
    return this.start.copy(t.start), this.end.copy(t.end), this
  }
  getCenter(t) {
    return t.addVectors(this.start, this.end).multiplyScalar(0.5)
  }
  delta(t) {
    return t.subVectors(this.end, this.start)
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end)
  }
  distance() {
    return this.start.distanceTo(this.end)
  }
  at(t, e) {
    return this.delta(e).multiplyScalar(t).add(this.start)
  }
  closestPointToPointParameter(t, e) {
    Pf.subVectors(t, this.start), If.subVectors(this.end, this.start)
    const n = If.dot(If)
    let i = If.dot(Pf) / n
    return e && (i = Zn(i, 0, 1)), i
  }
  closestPointToPoint(t, e, n) {
    const i = this.closestPointToPointParameter(t, e)
    return this.delta(n).multiplyScalar(i).add(this.start)
  }
  applyMatrix4(t) {
    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
  }
  equals(t) {
    return t.start.equals(this.start) && t.end.equals(this.end)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const Df = new Qi()
class kf extends nr {
  static {
    e(this, 'SpotLightHelper')
  }
  constructor(t, e) {
    super(),
      (this.light = t),
      (this.matrixAutoUpdate = !1),
      (this.color = e),
      (this.type = 'SpotLightHelper')
    const n = new Zr(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1
      ]
    for (let r = 0, a = 1, o = 32; r < o; r++, a++) {
      const t = (r / o) * Math.PI * 2,
        e = (a / o) * Math.PI * 2
      i.push(Math.cos(t), Math.sin(t), 1, Math.cos(e), Math.sin(e), 1)
    }
    n.setAttribute('position', new Vr(i, 3))
    const s = new su({ fog: !1, toneMapped: !1 })
    ;(this.cone = new gu(n, s)), this.add(this.cone), this.update()
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose()
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld)
    const t = this.light.distance ? this.light.distance : 1e3,
      e = t * Math.tan(this.light.angle)
    this.cone.scale.set(e, e, t),
      Df.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(Df),
      void 0 !== this.color
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color)
  }
}
const Nf = new Qi(),
  Uf = new Rs(),
  Bf = new Rs()
class Of extends gu {
  static {
    e(this, 'SkeletonHelper')
  }
  constructor(t) {
    const e = Ff(t),
      n = new Zr(),
      i = [],
      s = [],
      r = new br(0, 0, 1),
      a = new br(0, 1, 0)
    for (let o = 0; o < e.length; o++) {
      const t = e[o]
      t.parent &&
        t.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        s.push(r.r, r.g, r.b),
        s.push(a.r, a.g, a.b))
    }
    n.setAttribute('position', new Vr(i, 3)),
      n.setAttribute('color', new Vr(s, 3))
    super(
      n,
      new su({
        vertexColors: !0,
        depthTest: !1,
        depthWrite: !1,
        toneMapped: !1,
        transparent: !0
      })
    ),
      (this.isSkeletonHelper = !0),
      (this.type = 'SkeletonHelper'),
      (this.root = t),
      (this.bones = e),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1)
  }
  updateMatrixWorld(t) {
    const e = this.bones,
      n = this.geometry,
      i = n.getAttribute('position')
    Bf.copy(this.root.matrixWorld).invert()
    for (let s = 0, r = 0; s < e.length; s++) {
      const t = e[s]
      t.parent &&
        t.parent.isBone &&
        (Uf.multiplyMatrices(Bf, t.matrixWorld),
        Nf.setFromMatrixPosition(Uf),
        i.setXYZ(r, Nf.x, Nf.y, Nf.z),
        Uf.multiplyMatrices(Bf, t.parent.matrixWorld),
        Nf.setFromMatrixPosition(Uf),
        i.setXYZ(r + 1, Nf.x, Nf.y, Nf.z),
        (r += 2))
    }
    ;(n.getAttribute('position').needsUpdate = !0), super.updateMatrixWorld(t)
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
function Ff(t) {
  const e = []
  !0 === t.isBone && e.push(t)
  for (let n = 0; n < t.children.length; n++) e.push.apply(e, Ff(t.children[n]))
  return e
}
e(Ff, 'getBoneList')
class zf extends oa {
  static {
    e(this, 'PointLightHelper')
  }
  constructor(t, e, n) {
    super(new lp(e, 4, 2), new Tr({ wireframe: !0, fog: !1, toneMapped: !1 })),
      (this.light = t),
      (this.color = n),
      (this.type = 'PointLightHelper'),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update()
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      void 0 !== this.color
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color)
  }
}
const Vf = new Qi(),
  Hf = new br(),
  Gf = new br()
class Wf extends nr {
  static {
    e(this, 'HemisphereLightHelper')
  }
  constructor(t, e, n) {
    super(),
      (this.light = t),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = 'HemisphereLightHelper')
    const i = new sp(e)
    i.rotateY(0.5 * Math.PI),
      (this.material = new Tr({ wireframe: !0, fog: !1, toneMapped: !1 })),
      void 0 === this.color && (this.material.vertexColors = !0)
    const s = i.getAttribute('position'),
      r = new Float32Array(3 * s.count)
    i.setAttribute('color', new Lr(r, 3)),
      this.add(new oa(i, this.material)),
      this.update()
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose()
  }
  update() {
    const t = this.children[0]
    if (void 0 !== this.color) this.material.color.set(this.color)
    else {
      const e = t.geometry.getAttribute('color')
      Hf.copy(this.light.color), Gf.copy(this.light.groundColor)
      for (let t = 0, n = e.count; t < n; t++) {
        const i = t < n / 2 ? Hf : Gf
        e.setXYZ(t, i.r, i.g, i.b)
      }
      e.needsUpdate = !0
    }
    this.light.updateWorldMatrix(!0, !1),
      t.lookAt(Vf.setFromMatrixPosition(this.light.matrixWorld).negate())
  }
}
class jf extends gu {
  static {
    e(this, 'GridHelper')
  }
  constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
    ;(n = new br(n)), (i = new br(i))
    const s = e / 2,
      r = t / e,
      a = t / 2,
      o = [],
      l = []
    for (let h = 0, u = 0, d = -a; h <= e; h++, d += r) {
      o.push(-a, 0, d, a, 0, d), o.push(d, 0, -a, d, 0, a)
      const t = h === s ? n : i
      t.toArray(l, u),
        (u += 3),
        t.toArray(l, u),
        (u += 3),
        t.toArray(l, u),
        (u += 3),
        t.toArray(l, u),
        (u += 3)
    }
    const c = new Zr()
    c.setAttribute('position', new Vr(o, 3)),
      c.setAttribute('color', new Vr(l, 3))
    super(c, new su({ vertexColors: !0, toneMapped: !1 })),
      (this.type = 'GridHelper')
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
class Xf extends gu {
  static {
    e(this, 'PolarGridHelper')
  }
  constructor(t = 10, e = 16, n = 8, i = 64, s = 4473924, r = 8947848) {
    ;(s = new br(s)), (r = new br(r))
    const a = [],
      o = []
    if (e > 1)
      for (let c = 0; c < e; c++) {
        const n = (c / e) * (2 * Math.PI),
          i = Math.sin(n) * t,
          l = Math.cos(n) * t
        a.push(0, 0, 0), a.push(i, 0, l)
        const h = 1 & c ? s : r
        o.push(h.r, h.g, h.b), o.push(h.r, h.g, h.b)
      }
    for (let c = 0; c < n; c++) {
      const e = 1 & c ? s : r,
        l = t - (t / n) * c
      for (let t = 0; t < i; t++) {
        let n = (t / i) * (2 * Math.PI),
          s = Math.sin(n) * l,
          r = Math.cos(n) * l
        a.push(s, 0, r),
          o.push(e.r, e.g, e.b),
          (n = ((t + 1) / i) * (2 * Math.PI)),
          (s = Math.sin(n) * l),
          (r = Math.cos(n) * l),
          a.push(s, 0, r),
          o.push(e.r, e.g, e.b)
      }
    }
    const l = new Zr()
    l.setAttribute('position', new Vr(a, 3)),
      l.setAttribute('color', new Vr(o, 3))
    super(l, new su({ vertexColors: !0, toneMapped: !1 })),
      (this.type = 'PolarGridHelper')
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
const qf = new Qi(),
  Yf = new Qi(),
  Zf = new Qi()
class Kf extends nr {
  static {
    e(this, 'DirectionalLightHelper')
  }
  constructor(t, e, n) {
    super(),
      (this.light = t),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = 'DirectionalLightHelper'),
      void 0 === e && (e = 1)
    let i = new Zr()
    i.setAttribute(
      'position',
      new Vr([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
    )
    const s = new su({ fog: !1, toneMapped: !1 })
    ;(this.lightPlane = new du(i, s)),
      this.add(this.lightPlane),
      (i = new Zr()),
      i.setAttribute('position', new Vr([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new du(i, s)),
      this.add(this.targetLine),
      this.update()
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose()
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      qf.setFromMatrixPosition(this.light.matrixWorld),
      Yf.setFromMatrixPosition(this.light.target.matrixWorld),
      Zf.subVectors(Yf, qf),
      this.lightPlane.lookAt(Yf),
      void 0 !== this.color
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(Yf),
      (this.targetLine.scale.z = Zf.length())
  }
}
const $f = new Qi(),
  Jf = new va()
class Qf extends gu {
  static {
    e(this, 'CameraHelper')
  }
  constructor(t) {
    const n = new Zr(),
      i = new su({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      s = [],
      r = [],
      a = {}
    function o(t, e) {
      l(t), l(e)
    }
    function l(t) {
      s.push(0, 0, 0),
        r.push(0, 0, 0),
        void 0 === a[t] && (a[t] = []),
        a[t].push(s.length / 3 - 1)
    }
    o('n1', 'n2'),
      o('n2', 'n4'),
      o('n4', 'n3'),
      o('n3', 'n1'),
      o('f1', 'f2'),
      o('f2', 'f4'),
      o('f4', 'f3'),
      o('f3', 'f1'),
      o('n1', 'f1'),
      o('n2', 'f2'),
      o('n3', 'f3'),
      o('n4', 'f4'),
      o('p', 'n1'),
      o('p', 'n2'),
      o('p', 'n3'),
      o('p', 'n4'),
      o('u1', 'u2'),
      o('u2', 'u3'),
      o('u3', 'u1'),
      o('c', 't'),
      o('p', 'c'),
      o('cn1', 'cn2'),
      o('cn3', 'cn4'),
      o('cf1', 'cf2'),
      o('cf3', 'cf4'),
      e(o, 'addLine'),
      e(l, 'addPoint'),
      n.setAttribute('position', new Vr(s, 3)),
      n.setAttribute('color', new Vr(r, 3)),
      super(n, i),
      (this.type = 'CameraHelper'),
      (this.camera = t),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = a),
      this.update()
    const c = new br(16755200),
      h = new br(16711680),
      u = new br(43775),
      d = new br(16777215),
      p = new br(3355443)
    this.setColors(c, h, u, d, p)
  }
  setColors(t, e, n, i, s) {
    const r = this.geometry.getAttribute('color')
    r.setXYZ(0, t.r, t.g, t.b),
      r.setXYZ(1, t.r, t.g, t.b),
      r.setXYZ(2, t.r, t.g, t.b),
      r.setXYZ(3, t.r, t.g, t.b),
      r.setXYZ(4, t.r, t.g, t.b),
      r.setXYZ(5, t.r, t.g, t.b),
      r.setXYZ(6, t.r, t.g, t.b),
      r.setXYZ(7, t.r, t.g, t.b),
      r.setXYZ(8, t.r, t.g, t.b),
      r.setXYZ(9, t.r, t.g, t.b),
      r.setXYZ(10, t.r, t.g, t.b),
      r.setXYZ(11, t.r, t.g, t.b),
      r.setXYZ(12, t.r, t.g, t.b),
      r.setXYZ(13, t.r, t.g, t.b),
      r.setXYZ(14, t.r, t.g, t.b),
      r.setXYZ(15, t.r, t.g, t.b),
      r.setXYZ(16, t.r, t.g, t.b),
      r.setXYZ(17, t.r, t.g, t.b),
      r.setXYZ(18, t.r, t.g, t.b),
      r.setXYZ(19, t.r, t.g, t.b),
      r.setXYZ(20, t.r, t.g, t.b),
      r.setXYZ(21, t.r, t.g, t.b),
      r.setXYZ(22, t.r, t.g, t.b),
      r.setXYZ(23, t.r, t.g, t.b),
      r.setXYZ(24, e.r, e.g, e.b),
      r.setXYZ(25, e.r, e.g, e.b),
      r.setXYZ(26, e.r, e.g, e.b),
      r.setXYZ(27, e.r, e.g, e.b),
      r.setXYZ(28, e.r, e.g, e.b),
      r.setXYZ(29, e.r, e.g, e.b),
      r.setXYZ(30, e.r, e.g, e.b),
      r.setXYZ(31, e.r, e.g, e.b),
      r.setXYZ(32, n.r, n.g, n.b),
      r.setXYZ(33, n.r, n.g, n.b),
      r.setXYZ(34, n.r, n.g, n.b),
      r.setXYZ(35, n.r, n.g, n.b),
      r.setXYZ(36, n.r, n.g, n.b),
      r.setXYZ(37, n.r, n.g, n.b),
      r.setXYZ(38, i.r, i.g, i.b),
      r.setXYZ(39, i.r, i.g, i.b),
      r.setXYZ(40, s.r, s.g, s.b),
      r.setXYZ(41, s.r, s.g, s.b),
      r.setXYZ(42, s.r, s.g, s.b),
      r.setXYZ(43, s.r, s.g, s.b),
      r.setXYZ(44, s.r, s.g, s.b),
      r.setXYZ(45, s.r, s.g, s.b),
      r.setXYZ(46, s.r, s.g, s.b),
      r.setXYZ(47, s.r, s.g, s.b),
      r.setXYZ(48, s.r, s.g, s.b),
      r.setXYZ(49, s.r, s.g, s.b),
      (r.needsUpdate = !0)
  }
  update() {
    const t = this.geometry,
      e = this.pointMap
    Jf.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      tg('c', e, t, Jf, 0, 0, -1),
      tg('t', e, t, Jf, 0, 0, 1),
      tg('n1', e, t, Jf, -1, -1, -1),
      tg('n2', e, t, Jf, 1, -1, -1),
      tg('n3', e, t, Jf, -1, 1, -1),
      tg('n4', e, t, Jf, 1, 1, -1),
      tg('f1', e, t, Jf, -1, -1, 1),
      tg('f2', e, t, Jf, 1, -1, 1),
      tg('f3', e, t, Jf, -1, 1, 1),
      tg('f4', e, t, Jf, 1, 1, 1),
      tg('u1', e, t, Jf, 0.7, 1.1, -1),
      tg('u2', e, t, Jf, -0.7, 1.1, -1),
      tg('u3', e, t, Jf, 0, 2, -1),
      tg('cf1', e, t, Jf, -1, 0, 1),
      tg('cf2', e, t, Jf, 1, 0, 1),
      tg('cf3', e, t, Jf, 0, -1, 1),
      tg('cf4', e, t, Jf, 0, 1, 1),
      tg('cn1', e, t, Jf, -1, 0, -1),
      tg('cn2', e, t, Jf, 1, 0, -1),
      tg('cn3', e, t, Jf, 0, -1, -1),
      tg('cn4', e, t, Jf, 0, 1, -1),
      (t.getAttribute('position').needsUpdate = !0)
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
function tg(t, e, n, i, s, r, a) {
  $f.set(s, r, a).unproject(i)
  const o = e[t]
  if (void 0 !== o) {
    const t = n.getAttribute('position')
    for (let e = 0, n = o.length; e < n; e++) t.setXYZ(o[e], $f.x, $f.y, $f.z)
  }
}
e(tg, 'setPoint')
const eg = new ns()
class ng extends gu {
  static {
    e(this, 'BoxHelper')
  }
  constructor(t, e = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7
      ]),
      i = new Float32Array(24),
      s = new Zr()
    s.setIndex(new Lr(n, 1)),
      s.setAttribute('position', new Lr(i, 3)),
      super(s, new su({ color: e, toneMapped: !1 })),
      (this.object = t),
      (this.type = 'BoxHelper'),
      (this.matrixAutoUpdate = !1),
      this.update()
  }
  update(t) {
    if (
      (void 0 !== t &&
        console.warn('THREE.BoxHelper: .update() has no longer arguments.'),
      void 0 !== this.object && eg.setFromObject(this.object),
      eg.isEmpty())
    )
      return
    const e = eg.min,
      n = eg.max,
      i = this.geometry.attributes.position,
      s = i.array
    ;(s[0] = n.x),
      (s[1] = n.y),
      (s[2] = n.z),
      (s[3] = e.x),
      (s[4] = n.y),
      (s[5] = n.z),
      (s[6] = e.x),
      (s[7] = e.y),
      (s[8] = n.z),
      (s[9] = n.x),
      (s[10] = e.y),
      (s[11] = n.z),
      (s[12] = n.x),
      (s[13] = n.y),
      (s[14] = e.z),
      (s[15] = e.x),
      (s[16] = n.y),
      (s[17] = e.z),
      (s[18] = e.x),
      (s[19] = e.y),
      (s[20] = e.z),
      (s[21] = n.x),
      (s[22] = e.y),
      (s[23] = e.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere()
  }
  setFromObject(t) {
    return (this.object = t), this.update(), this
  }
  copy(t, e) {
    return super.copy(t, e), (this.object = t.object), this
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
class ig extends gu {
  static {
    e(this, 'Box3Helper')
  }
  constructor(t, e = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7
      ]),
      i = new Zr()
    i.setIndex(new Lr(n, 1)),
      i.setAttribute(
        'position',
        new Vr(
          [
            1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1,
            -1, 1, -1, -1
          ],
          3
        )
      ),
      super(i, new su({ color: e, toneMapped: !1 })),
      (this.box = t),
      (this.type = 'Box3Helper'),
      this.geometry.computeBoundingSphere()
  }
  updateMatrixWorld(t) {
    const e = this.box
    e.isEmpty() ||
      (e.getCenter(this.position),
      e.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(t))
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
class sg extends du {
  static {
    e(this, 'PlaneHelper')
  }
  constructor(t, e = 1, n = 16776960) {
    const i = n,
      s = new Zr()
    s.setAttribute(
      'position',
      new Vr(
        [
          1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
          1, 1, 0
        ],
        3
      )
    ),
      s.computeBoundingSphere(),
      super(s, new su({ color: i, toneMapped: !1 })),
      (this.type = 'PlaneHelper'),
      (this.plane = t),
      (this.size = e)
    const r = new Zr()
    r.setAttribute(
      'position',
      new Vr([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)
    ),
      r.computeBoundingSphere(),
      this.add(
        new oa(
          r,
          new Tr({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
          })
        )
      )
  }
  updateMatrixWorld(t) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(t)
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose()
  }
}
const rg = new Qi()
let ag, og
class lg extends nr {
  static {
    e(this, 'ArrowHelper')
  }
  constructor(
    t = new Qi(0, 0, 1),
    e = new Qi(0, 0, 0),
    n = 1,
    i = 16776960,
    s = 0.2 * n,
    r = 0.2 * s
  ) {
    super(),
      (this.type = 'ArrowHelper'),
      void 0 === ag &&
        ((ag = new Zr()),
        ag.setAttribute('position', new Vr([0, 0, 0, 0, 1, 0], 3)),
        (og = new cd(0, 0.5, 1, 5, 1)),
        og.translate(0, -0.5, 0)),
      this.position.copy(e),
      (this.line = new du(ag, new su({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new oa(og, new Tr({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(t),
      this.setLength(n, s, r)
  }
  setDirection(t) {
    if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1)
    else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0)
    else {
      rg.set(t.z, 0, -t.x).normalize()
      const e = Math.acos(t.y)
      this.quaternion.setFromAxisAngle(rg, e)
    }
  }
  setLength(t, e = 0.2 * t, n = 0.2 * e) {
    this.line.scale.set(1, Math.max(1e-4, t - e), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(n, e, n),
      (this.cone.position.y = t),
      this.cone.updateMatrix()
  }
  setColor(t) {
    this.line.material.color.set(t), this.cone.material.color.set(t)
  }
  copy(t) {
    return (
      super.copy(t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
    )
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose()
  }
}
class cg extends gu {
  static {
    e(this, 'AxesHelper')
  }
  constructor(t = 1) {
    const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
      n = new Zr()
    n.setAttribute('position', new Vr(e, 3)),
      n.setAttribute(
        'color',
        new Vr([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)
      )
    super(n, new su({ vertexColors: !0, toneMapped: !1 })),
      (this.type = 'AxesHelper')
  }
  setColors(t, e, n) {
    const i = new br(),
      s = this.geometry.attributes.color.array
    return (
      i.set(t),
      i.toArray(s, 0),
      i.toArray(s, 3),
      i.set(e),
      i.toArray(s, 6),
      i.toArray(s, 9),
      i.set(n),
      i.toArray(s, 12),
      i.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    )
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
class hg {
  static {
    e(this, 'ShapePath')
  }
  constructor() {
    ;(this.type = 'ShapePath'),
      (this.color = new br()),
      (this.subPaths = []),
      (this.currentPath = null)
  }
  moveTo(t, e) {
    return (
      (this.currentPath = new rd()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(t, e),
      this
    )
  }
  lineTo(t, e) {
    return this.currentPath.lineTo(t, e), this
  }
  quadraticCurveTo(t, e, n, i) {
    return this.currentPath.quadraticCurveTo(t, e, n, i), this
  }
  bezierCurveTo(t, e, n, i, s, r) {
    return this.currentPath.bezierCurveTo(t, e, n, i, s, r), this
  }
  splineThru(t) {
    return this.currentPath.splineThru(t), this
  }
  toShapes(t) {
    function n(t) {
      const e = []
      for (let n = 0, i = t.length; n < i; n++) {
        const i = t[n],
          s = new yd()
        ;(s.curves = i.curves), e.push(s)
      }
      return e
    }
    function i(t, e) {
      const n = e.length
      let i = !1
      for (let s = n - 1, r = 0; r < n; s = r++) {
        let n = e[s],
          a = e[r],
          o = a.x - n.x,
          l = a.y - n.y
        if (Math.abs(l) > Number.EPSILON) {
          if (
            (l < 0 && ((n = e[r]), (o = -o), (a = e[s]), (l = -l)),
            t.y < n.y || t.y > a.y)
          )
            continue
          if (t.y === n.y) {
            if (t.x === n.x) return !0
          } else {
            const e = l * (t.x - n.x) - o * (t.y - n.y)
            if (0 === e) return !0
            if (e < 0) continue
            i = !i
          }
        } else {
          if (t.y !== n.y) continue
          if ((a.x <= t.x && t.x <= n.x) || (n.x <= t.x && t.x <= a.x))
            return !0
        }
      }
      return i
    }
    e(n, 'toShapesNoHoles'), e(i, 'isPointInsidePolygon')
    const s = $d.isClockWise,
      r = this.subPaths
    if (0 === r.length) return []
    let a, o, l
    const c = []
    if (1 === r.length)
      return (o = r[0]), (l = new yd()), (l.curves = o.curves), c.push(l), c
    let h = !s(r[0].getPoints())
    h = t ? !h : h
    const u = [],
      d = []
    let p,
      m,
      f = [],
      g = 0
    ;(d[g] = void 0), (f[g] = [])
    for (let e = 0, v = r.length; e < v; e++)
      (o = r[e]),
        (p = o.getPoints()),
        (a = s(p)),
        (a = t ? !a : a),
        a
          ? (!h && d[g] && g++,
            (d[g] = { s: new yd(), p: p }),
            (d[g].s.curves = o.curves),
            h && g++,
            (f[g] = []))
          : f[g].push({ h: o, p: p[0] })
    if (!d[0]) return n(r)
    if (d.length > 1) {
      let t = !1,
        e = 0
      for (let n = 0, i = d.length; n < i; n++) u[n] = []
      for (let n = 0, s = d.length; n < s; n++) {
        const s = f[n]
        for (let r = 0; r < s.length; r++) {
          const a = s[r]
          let o = !0
          for (let s = 0; s < d.length; s++)
            i(a.p, d[s].p) &&
              (n !== s && e++, o ? ((o = !1), u[s].push(a)) : (t = !0))
          o && u[n].push(a)
        }
      }
      e > 0 && !1 === t && (f = u)
    }
    for (let e = 0, v = d.length; e < v; e++) {
      ;(l = d[e].s), c.push(l), (m = f[e])
      for (let t = 0, e = m.length; t < e; t++) l.holes.push(m[t].h)
    }
    return c
  }
}
class ug extends Gn {
  static {
    e(this, 'Controls')
  }
  constructor(t, e = null) {
    super(),
      (this.object = t),
      (this.domElement = e),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null })
  }
  connect() {}
  disconnect() {}
  dispose() {}
  update() {}
}
class dg extends qi {
  static {
    e(this, 'WebGLMultipleRenderTargets')
  }
  constructor(t = 1, e = 1, n = 1, i = {}) {
    console.warn(
      'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'
    ),
      super(t, e, { ...i, count: n }),
      (this.isWebGLMultipleRenderTargets = !0)
  }
  get texture() {
    return this.textures
  }
}
'undefined' != typeof __THREE_DEVTOOLS__ &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent('register', { detail: { revision: Tt } })
  ),
  'undefined' != typeof window &&
    (window.__THREE__
      ? console.warn('WARNING: Multiple instances of Three.js being imported.')
      : (window.__THREE__ = Tt))
const pg = { type: 'change' },
  mg = { type: 'start' },
  fg = { type: 'end' },
  gg = new Cs(),
  vg = new Ra(),
  yg = Math.cos(70 * gi.DEG2RAD),
  _g = new Qi(),
  xg = 2 * Math.PI,
  bg = -1,
  wg = 0,
  Mg = 1,
  Sg = 2,
  Tg = 3,
  Eg = 4,
  Ag = 5,
  Cg = 6,
  Rg = 1e-6
class Pg extends ug {
  static {
    e(this, 'OrbitControls')
  }
  constructor(t, e = null) {
    super(t, e),
      (this.state = bg),
      (this.enabled = !0),
      (this.target = new Qi()),
      (this.cursor = new Qi()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minTargetRadius = 0),
      (this.maxTargetRadius = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.zoomToCursor = !1),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = {
        LEFT: 'ArrowLeft',
        UP: 'ArrowUp',
        RIGHT: 'ArrowRight',
        BOTTOM: 'ArrowDown'
      }),
      (this.mouseButtons = { LEFT: Et, MIDDLE: At, RIGHT: Ct }),
      (this.touches = { ONE: Rt, TWO: It }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this._lastPosition = new Qi()),
      (this._lastQuaternion = new Ji()),
      (this._lastTargetPosition = new Qi()),
      (this._quat = new Ji().setFromUnitVectors(t.up, new Qi(0, 1, 0))),
      (this._quatInverse = this._quat.clone().invert()),
      (this._spherical = new Tf()),
      (this._sphericalDelta = new Tf()),
      (this._scale = 1),
      (this._panOffset = new Qi()),
      (this._rotateStart = new vi()),
      (this._rotateEnd = new vi()),
      (this._rotateDelta = new vi()),
      (this._panStart = new vi()),
      (this._panEnd = new vi()),
      (this._panDelta = new vi()),
      (this._dollyStart = new vi()),
      (this._dollyEnd = new vi()),
      (this._dollyDelta = new vi()),
      (this._dollyDirection = new Qi()),
      (this._mouse = new vi()),
      (this._performCursorZoom = !1),
      (this._pointers = []),
      (this._pointerPositions = {}),
      (this._controlActive = !1),
      (this._onPointerMove = Lg.bind(this)),
      (this._onPointerDown = Ig.bind(this)),
      (this._onPointerUp = Dg.bind(this)),
      (this._onContextMenu = zg.bind(this)),
      (this._onMouseWheel = Ug.bind(this)),
      (this._onKeyDown = Bg.bind(this)),
      (this._onTouchStart = Og.bind(this)),
      (this._onTouchMove = Fg.bind(this)),
      (this._onMouseDown = kg.bind(this)),
      (this._onMouseMove = Ng.bind(this)),
      (this._interceptControlDown = Vg.bind(this)),
      (this._interceptControlUp = Hg.bind(this)),
      null !== this.domElement && this.connect(),
      this.update()
  }
  connect() {
    this.domElement.addEventListener('pointerdown', this._onPointerDown),
      this.domElement.addEventListener('pointercancel', this._onPointerUp),
      this.domElement.addEventListener('contextmenu', this._onContextMenu),
      this.domElement.addEventListener('wheel', this._onMouseWheel, {
        passive: !1
      })
    this.domElement
      .getRootNode()
      .addEventListener('keydown', this._interceptControlDown, {
        passive: !0,
        capture: !0
      }),
      (this.domElement.style.touchAction = 'none')
  }
  disconnect() {
    this.domElement.removeEventListener('pointerdown', this._onPointerDown),
      this.domElement.removeEventListener('pointermove', this._onPointerMove),
      this.domElement.removeEventListener('pointerup', this._onPointerUp),
      this.domElement.removeEventListener('pointercancel', this._onPointerUp),
      this.domElement.removeEventListener('wheel', this._onMouseWheel),
      this.domElement.removeEventListener('contextmenu', this._onContextMenu),
      this.stopListenToKeyEvents()
    this.domElement
      .getRootNode()
      .removeEventListener('keydown', this._interceptControlDown, {
        capture: !0
      }),
      (this.domElement.style.touchAction = 'auto')
  }
  dispose() {
    this.disconnect()
  }
  getPolarAngle() {
    return this._spherical.phi
  }
  getAzimuthalAngle() {
    return this._spherical.theta
  }
  getDistance() {
    return this.object.position.distanceTo(this.target)
  }
  listenToKeyEvents(t) {
    t.addEventListener('keydown', this._onKeyDown),
      (this._domElementKeyEvents = t)
  }
  stopListenToKeyEvents() {
    null !== this._domElementKeyEvents &&
      (this._domElementKeyEvents.removeEventListener(
        'keydown',
        this._onKeyDown
      ),
      (this._domElementKeyEvents = null))
  }
  saveState() {
    this.target0.copy(this.target),
      this.position0.copy(this.object.position),
      (this.zoom0 = this.object.zoom)
  }
  reset() {
    this.target.copy(this.target0),
      this.object.position.copy(this.position0),
      (this.object.zoom = this.zoom0),
      this.object.updateProjectionMatrix(),
      this.dispatchEvent(pg),
      this.update(),
      (this.state = bg)
  }
  update(t = null) {
    const e = this.object.position
    _g.copy(e).sub(this.target),
      _g.applyQuaternion(this._quat),
      this._spherical.setFromVector3(_g),
      this.autoRotate &&
        this.state === bg &&
        this._rotateLeft(this._getAutoRotationAngle(t)),
      this.enableDamping
        ? ((this._spherical.theta +=
            this._sphericalDelta.theta * this.dampingFactor),
          (this._spherical.phi +=
            this._sphericalDelta.phi * this.dampingFactor))
        : ((this._spherical.theta += this._sphericalDelta.theta),
          (this._spherical.phi += this._sphericalDelta.phi))
    let n = this.minAzimuthAngle,
      i = this.maxAzimuthAngle
    isFinite(n) &&
      isFinite(i) &&
      (n < -Math.PI ? (n += xg) : n > Math.PI && (n -= xg),
      i < -Math.PI ? (i += xg) : i > Math.PI && (i -= xg),
      (this._spherical.theta =
        n <= i
          ? Math.max(n, Math.min(i, this._spherical.theta))
          : this._spherical.theta > (n + i) / 2
            ? Math.max(n, this._spherical.theta)
            : Math.min(i, this._spherical.theta))),
      (this._spherical.phi = Math.max(
        this.minPolarAngle,
        Math.min(this.maxPolarAngle, this._spherical.phi)
      )),
      this._spherical.makeSafe(),
      !0 === this.enableDamping
        ? this.target.addScaledVector(this._panOffset, this.dampingFactor)
        : this.target.add(this._panOffset),
      this.target.sub(this.cursor),
      this.target.clampLength(this.minTargetRadius, this.maxTargetRadius),
      this.target.add(this.cursor)
    let s = !1
    if (
      (this.zoomToCursor && this._performCursorZoom) ||
      this.object.isOrthographicCamera
    )
      this._spherical.radius = this._clampDistance(this._spherical.radius)
    else {
      const t = this._spherical.radius
      ;(this._spherical.radius = this._clampDistance(
        this._spherical.radius * this._scale
      )),
        (s = t != this._spherical.radius)
    }
    if (
      (_g.setFromSpherical(this._spherical),
      _g.applyQuaternion(this._quatInverse),
      e.copy(this.target).add(_g),
      this.object.lookAt(this.target),
      !0 === this.enableDamping
        ? ((this._sphericalDelta.theta *= 1 - this.dampingFactor),
          (this._sphericalDelta.phi *= 1 - this.dampingFactor),
          this._panOffset.multiplyScalar(1 - this.dampingFactor))
        : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)),
      this.zoomToCursor && this._performCursorZoom)
    ) {
      let t = null
      if (this.object.isPerspectiveCamera) {
        const e = _g.length()
        t = this._clampDistance(e * this._scale)
        const n = e - t
        this.object.position.addScaledVector(this._dollyDirection, n),
          this.object.updateMatrixWorld(),
          (s = !!n)
      } else if (this.object.isOrthographicCamera) {
        const e = new Qi(this._mouse.x, this._mouse.y, 0)
        e.unproject(this.object)
        const n = this.object.zoom
        ;(this.object.zoom = Math.max(
          this.minZoom,
          Math.min(this.maxZoom, this.object.zoom / this._scale)
        )),
          this.object.updateProjectionMatrix(),
          (s = n !== this.object.zoom)
        const i = new Qi(this._mouse.x, this._mouse.y, 0)
        i.unproject(this.object),
          this.object.position.sub(i).add(e),
          this.object.updateMatrixWorld(),
          (t = _g.length())
      } else
        console.warn(
          'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.'
        ),
          (this.zoomToCursor = !1)
      null !== t &&
        (this.screenSpacePanning
          ? this.target
              .set(0, 0, -1)
              .transformDirection(this.object.matrix)
              .multiplyScalar(t)
              .add(this.object.position)
          : (gg.origin.copy(this.object.position),
            gg.direction.set(0, 0, -1).transformDirection(this.object.matrix),
            Math.abs(this.object.up.dot(gg.direction)) < yg
              ? this.object.lookAt(this.target)
              : (vg.setFromNormalAndCoplanarPoint(this.object.up, this.target),
                gg.intersectPlane(vg, this.target))))
    } else if (this.object.isOrthographicCamera) {
      const t = this.object.zoom
      ;(this.object.zoom = Math.max(
        this.minZoom,
        Math.min(this.maxZoom, this.object.zoom / this._scale)
      )),
        t !== this.object.zoom &&
          (this.object.updateProjectionMatrix(), (s = !0))
    }
    return (
      (this._scale = 1),
      (this._performCursorZoom = !1),
      !!(
        s ||
        this._lastPosition.distanceToSquared(this.object.position) > Rg ||
        8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > Rg ||
        this._lastTargetPosition.distanceToSquared(this.target) > Rg
      ) &&
        (this.dispatchEvent(pg),
        this._lastPosition.copy(this.object.position),
        this._lastQuaternion.copy(this.object.quaternion),
        this._lastTargetPosition.copy(this.target),
        !0)
    )
  }
  _getAutoRotationAngle(t) {
    return null !== t
      ? (xg / 60) * this.autoRotateSpeed * t
      : (xg / 60 / 60) * this.autoRotateSpeed
  }
  _getZoomScale(t) {
    const e = Math.abs(0.01 * t)
    return Math.pow(0.95, this.zoomSpeed * e)
  }
  _rotateLeft(t) {
    this._sphericalDelta.theta -= t
  }
  _rotateUp(t) {
    this._sphericalDelta.phi -= t
  }
  _panLeft(t, e) {
    _g.setFromMatrixColumn(e, 0), _g.multiplyScalar(-t), this._panOffset.add(_g)
  }
  _panUp(t, e) {
    !0 === this.screenSpacePanning
      ? _g.setFromMatrixColumn(e, 1)
      : (_g.setFromMatrixColumn(e, 0), _g.crossVectors(this.object.up, _g)),
      _g.multiplyScalar(t),
      this._panOffset.add(_g)
  }
  _pan(t, e) {
    const n = this.domElement
    if (this.object.isPerspectiveCamera) {
      const i = this.object.position
      _g.copy(i).sub(this.target)
      let s = _g.length()
      ;(s *= Math.tan(((this.object.fov / 2) * Math.PI) / 180)),
        this._panLeft((2 * t * s) / n.clientHeight, this.object.matrix),
        this._panUp((2 * e * s) / n.clientHeight, this.object.matrix)
    } else
      this.object.isOrthographicCamera
        ? (this._panLeft(
            (t * (this.object.right - this.object.left)) /
              this.object.zoom /
              n.clientWidth,
            this.object.matrix
          ),
          this._panUp(
            (e * (this.object.top - this.object.bottom)) /
              this.object.zoom /
              n.clientHeight,
            this.object.matrix
          ))
        : (console.warn(
            'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.'
          ),
          (this.enablePan = !1))
  }
  _dollyOut(t) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera
      ? (this._scale /= t)
      : (console.warn(
          'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
        ),
        (this.enableZoom = !1))
  }
  _dollyIn(t) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera
      ? (this._scale *= t)
      : (console.warn(
          'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
        ),
        (this.enableZoom = !1))
  }
  _updateZoomParameters(t, e) {
    if (!this.zoomToCursor) return
    this._performCursorZoom = !0
    const n = this.domElement.getBoundingClientRect(),
      i = t - n.left,
      s = e - n.top,
      r = n.width,
      a = n.height
    ;(this._mouse.x = (i / r) * 2 - 1),
      (this._mouse.y = (-s / a) * 2 + 1),
      this._dollyDirection
        .set(this._mouse.x, this._mouse.y, 1)
        .unproject(this.object)
        .sub(this.object.position)
        .normalize()
  }
  _clampDistance(t) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, t))
  }
  _handleMouseDownRotate(t) {
    this._rotateStart.set(t.clientX, t.clientY)
  }
  _handleMouseDownDolly(t) {
    this._updateZoomParameters(t.clientX, t.clientX),
      this._dollyStart.set(t.clientX, t.clientY)
  }
  _handleMouseDownPan(t) {
    this._panStart.set(t.clientX, t.clientY)
  }
  _handleMouseMoveRotate(t) {
    this._rotateEnd.set(t.clientX, t.clientY),
      this._rotateDelta
        .subVectors(this._rotateEnd, this._rotateStart)
        .multiplyScalar(this.rotateSpeed)
    const e = this.domElement
    this._rotateLeft((xg * this._rotateDelta.x) / e.clientHeight),
      this._rotateUp((xg * this._rotateDelta.y) / e.clientHeight),
      this._rotateStart.copy(this._rotateEnd),
      this.update()
  }
  _handleMouseMoveDolly(t) {
    this._dollyEnd.set(t.clientX, t.clientY),
      this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart),
      this._dollyDelta.y > 0
        ? this._dollyOut(this._getZoomScale(this._dollyDelta.y))
        : this._dollyDelta.y < 0 &&
          this._dollyIn(this._getZoomScale(this._dollyDelta.y)),
      this._dollyStart.copy(this._dollyEnd),
      this.update()
  }
  _handleMouseMovePan(t) {
    this._panEnd.set(t.clientX, t.clientY),
      this._panDelta
        .subVectors(this._panEnd, this._panStart)
        .multiplyScalar(this.panSpeed),
      this._pan(this._panDelta.x, this._panDelta.y),
      this._panStart.copy(this._panEnd),
      this.update()
  }
  _handleMouseWheel(t) {
    this._updateZoomParameters(t.clientX, t.clientY),
      t.deltaY < 0
        ? this._dollyIn(this._getZoomScale(t.deltaY))
        : t.deltaY > 0 && this._dollyOut(this._getZoomScale(t.deltaY)),
      this.update()
  }
  _handleKeyDown(t) {
    let e = !1
    switch (t.code) {
      case this.keys.UP:
        t.ctrlKey || t.metaKey || t.shiftKey
          ? this._rotateUp(
              (xg * this.rotateSpeed) / this.domElement.clientHeight
            )
          : this._pan(0, this.keyPanSpeed),
          (e = !0)
        break
      case this.keys.BOTTOM:
        t.ctrlKey || t.metaKey || t.shiftKey
          ? this._rotateUp(
              (-xg * this.rotateSpeed) / this.domElement.clientHeight
            )
          : this._pan(0, -this.keyPanSpeed),
          (e = !0)
        break
      case this.keys.LEFT:
        t.ctrlKey || t.metaKey || t.shiftKey
          ? this._rotateLeft(
              (xg * this.rotateSpeed) / this.domElement.clientHeight
            )
          : this._pan(this.keyPanSpeed, 0),
          (e = !0)
        break
      case this.keys.RIGHT:
        t.ctrlKey || t.metaKey || t.shiftKey
          ? this._rotateLeft(
              (-xg * this.rotateSpeed) / this.domElement.clientHeight
            )
          : this._pan(-this.keyPanSpeed, 0),
          (e = !0)
    }
    e && (t.preventDefault(), this.update())
  }
  _handleTouchStartRotate(t) {
    if (1 === this._pointers.length) this._rotateStart.set(t.pageX, t.pageY)
    else {
      const e = this._getSecondPointerPosition(t),
        n = 0.5 * (t.pageX + e.x),
        i = 0.5 * (t.pageY + e.y)
      this._rotateStart.set(n, i)
    }
  }
  _handleTouchStartPan(t) {
    if (1 === this._pointers.length) this._panStart.set(t.pageX, t.pageY)
    else {
      const e = this._getSecondPointerPosition(t),
        n = 0.5 * (t.pageX + e.x),
        i = 0.5 * (t.pageY + e.y)
      this._panStart.set(n, i)
    }
  }
  _handleTouchStartDolly(t) {
    const e = this._getSecondPointerPosition(t),
      n = t.pageX - e.x,
      i = t.pageY - e.y,
      s = Math.sqrt(n * n + i * i)
    this._dollyStart.set(0, s)
  }
  _handleTouchStartDollyPan(t) {
    this.enableZoom && this._handleTouchStartDolly(t),
      this.enablePan && this._handleTouchStartPan(t)
  }
  _handleTouchStartDollyRotate(t) {
    this.enableZoom && this._handleTouchStartDolly(t),
      this.enableRotate && this._handleTouchStartRotate(t)
  }
  _handleTouchMoveRotate(t) {
    if (1 == this._pointers.length) this._rotateEnd.set(t.pageX, t.pageY)
    else {
      const e = this._getSecondPointerPosition(t),
        n = 0.5 * (t.pageX + e.x),
        i = 0.5 * (t.pageY + e.y)
      this._rotateEnd.set(n, i)
    }
    this._rotateDelta
      .subVectors(this._rotateEnd, this._rotateStart)
      .multiplyScalar(this.rotateSpeed)
    const e = this.domElement
    this._rotateLeft((xg * this._rotateDelta.x) / e.clientHeight),
      this._rotateUp((xg * this._rotateDelta.y) / e.clientHeight),
      this._rotateStart.copy(this._rotateEnd)
  }
  _handleTouchMovePan(t) {
    if (1 === this._pointers.length) this._panEnd.set(t.pageX, t.pageY)
    else {
      const e = this._getSecondPointerPosition(t),
        n = 0.5 * (t.pageX + e.x),
        i = 0.5 * (t.pageY + e.y)
      this._panEnd.set(n, i)
    }
    this._panDelta
      .subVectors(this._panEnd, this._panStart)
      .multiplyScalar(this.panSpeed),
      this._pan(this._panDelta.x, this._panDelta.y),
      this._panStart.copy(this._panEnd)
  }
  _handleTouchMoveDolly(t) {
    const e = this._getSecondPointerPosition(t),
      n = t.pageX - e.x,
      i = t.pageY - e.y,
      s = Math.sqrt(n * n + i * i)
    this._dollyEnd.set(0, s),
      this._dollyDelta.set(
        0,
        Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)
      ),
      this._dollyOut(this._dollyDelta.y),
      this._dollyStart.copy(this._dollyEnd)
    const r = 0.5 * (t.pageX + e.x),
      a = 0.5 * (t.pageY + e.y)
    this._updateZoomParameters(r, a)
  }
  _handleTouchMoveDollyPan(t) {
    this.enableZoom && this._handleTouchMoveDolly(t),
      this.enablePan && this._handleTouchMovePan(t)
  }
  _handleTouchMoveDollyRotate(t) {
    this.enableZoom && this._handleTouchMoveDolly(t),
      this.enableRotate && this._handleTouchMoveRotate(t)
  }
  _addPointer(t) {
    this._pointers.push(t.pointerId)
  }
  _removePointer(t) {
    delete this._pointerPositions[t.pointerId]
    for (let e = 0; e < this._pointers.length; e++)
      if (this._pointers[e] == t.pointerId)
        return void this._pointers.splice(e, 1)
  }
  _isTrackingPointer(t) {
    for (let e = 0; e < this._pointers.length; e++)
      if (this._pointers[e] == t.pointerId) return !0
    return !1
  }
  _trackPointer(t) {
    let e = this._pointerPositions[t.pointerId]
    void 0 === e && ((e = new vi()), (this._pointerPositions[t.pointerId] = e)),
      e.set(t.pageX, t.pageY)
  }
  _getSecondPointerPosition(t) {
    const e =
      t.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0]
    return this._pointerPositions[e]
  }
  _customWheelEvent(t) {
    const e = t.deltaMode,
      n = { clientX: t.clientX, clientY: t.clientY, deltaY: t.deltaY }
    switch (e) {
      case 1:
        n.deltaY *= 16
        break
      case 2:
        n.deltaY *= 100
    }
    return t.ctrlKey && !this._controlActive && (n.deltaY *= 10), n
  }
}
function Ig(t) {
  !1 !== this.enabled &&
    (0 === this._pointers.length &&
      (this.domElement.setPointerCapture(t.pointerId),
      this.domElement.addEventListener('pointermove', this._onPointerMove),
      this.domElement.addEventListener('pointerup', this._onPointerUp)),
    this._isTrackingPointer(t) ||
      (this._addPointer(t),
      'touch' === t.pointerType ? this._onTouchStart(t) : this._onMouseDown(t)))
}
function Lg(t) {
  !1 !== this.enabled &&
    ('touch' === t.pointerType ? this._onTouchMove(t) : this._onMouseMove(t))
}
function Dg(t) {
  switch ((this._removePointer(t), this._pointers.length)) {
    case 0:
      this.domElement.releasePointerCapture(t.pointerId),
        this.domElement.removeEventListener('pointermove', this._onPointerMove),
        this.domElement.removeEventListener('pointerup', this._onPointerUp),
        this.dispatchEvent(fg),
        (this.state = bg)
      break
    case 1:
      const e = this._pointers[0],
        n = this._pointerPositions[e]
      this._onTouchStart({ pointerId: e, pageX: n.x, pageY: n.y })
  }
}
function kg(t) {
  let e
  switch (t.button) {
    case 0:
      e = this.mouseButtons.LEFT
      break
    case 1:
      e = this.mouseButtons.MIDDLE
      break
    case 2:
      e = this.mouseButtons.RIGHT
      break
    default:
      e = -1
  }
  switch (e) {
    case At:
      if (!1 === this.enableZoom) return
      this._handleMouseDownDolly(t), (this.state = Mg)
      break
    case Et:
      if (t.ctrlKey || t.metaKey || t.shiftKey) {
        if (!1 === this.enablePan) return
        this._handleMouseDownPan(t), (this.state = Sg)
      } else {
        if (!1 === this.enableRotate) return
        this._handleMouseDownRotate(t), (this.state = wg)
      }
      break
    case Ct:
      if (t.ctrlKey || t.metaKey || t.shiftKey) {
        if (!1 === this.enableRotate) return
        this._handleMouseDownRotate(t), (this.state = wg)
      } else {
        if (!1 === this.enablePan) return
        this._handleMouseDownPan(t), (this.state = Sg)
      }
      break
    default:
      this.state = bg
  }
  this.state !== bg && this.dispatchEvent(mg)
}
function Ng(t) {
  switch (this.state) {
    case wg:
      if (!1 === this.enableRotate) return
      this._handleMouseMoveRotate(t)
      break
    case Mg:
      if (!1 === this.enableZoom) return
      this._handleMouseMoveDolly(t)
      break
    case Sg:
      if (!1 === this.enablePan) return
      this._handleMouseMovePan(t)
  }
}
function Ug(t) {
  !1 !== this.enabled &&
    !1 !== this.enableZoom &&
    this.state === bg &&
    (t.preventDefault(),
    this.dispatchEvent(mg),
    this._handleMouseWheel(this._customWheelEvent(t)),
    this.dispatchEvent(fg))
}
function Bg(t) {
  !1 !== this.enabled && !1 !== this.enablePan && this._handleKeyDown(t)
}
function Og(t) {
  switch ((this._trackPointer(t), this._pointers.length)) {
    case 1:
      switch (this.touches.ONE) {
        case Rt:
          if (!1 === this.enableRotate) return
          this._handleTouchStartRotate(t), (this.state = Tg)
          break
        case Pt:
          if (!1 === this.enablePan) return
          this._handleTouchStartPan(t), (this.state = Eg)
          break
        default:
          this.state = bg
      }
      break
    case 2:
      switch (this.touches.TWO) {
        case It:
          if (!1 === this.enableZoom && !1 === this.enablePan) return
          this._handleTouchStartDollyPan(t), (this.state = Ag)
          break
        case Lt:
          if (!1 === this.enableZoom && !1 === this.enableRotate) return
          this._handleTouchStartDollyRotate(t), (this.state = Cg)
          break
        default:
          this.state = bg
      }
      break
    default:
      this.state = bg
  }
  this.state !== bg && this.dispatchEvent(mg)
}
function Fg(t) {
  switch ((this._trackPointer(t), this.state)) {
    case Tg:
      if (!1 === this.enableRotate) return
      this._handleTouchMoveRotate(t), this.update()
      break
    case Eg:
      if (!1 === this.enablePan) return
      this._handleTouchMovePan(t), this.update()
      break
    case Ag:
      if (!1 === this.enableZoom && !1 === this.enablePan) return
      this._handleTouchMoveDollyPan(t), this.update()
      break
    case Cg:
      if (!1 === this.enableZoom && !1 === this.enableRotate) return
      this._handleTouchMoveDollyRotate(t), this.update()
      break
    default:
      this.state = bg
  }
}
function zg(t) {
  !1 !== this.enabled && t.preventDefault()
}
function Vg(t) {
  if ('Control' === t.key) {
    this._controlActive = !0
    this.domElement
      .getRootNode()
      .addEventListener('keyup', this._interceptControlUp, {
        passive: !0,
        capture: !0
      })
  }
}
function Hg(t) {
  if ('Control' === t.key) {
    this._controlActive = !1
    this.domElement
      .getRootNode()
      .removeEventListener('keyup', this._interceptControlUp, {
        passive: !0,
        capture: !0
      })
  }
}
function Gg(t) {
  let e,
    n,
    i,
    s = -1,
    r = 0
  for (let c = 0; c < t.length; ++c) {
    const a = t[c]
    if ((void 0 === e && (e = a.array.constructor), e !== a.array.constructor))
      return (
        console.error(
          'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.'
        ),
        null
      )
    if ((void 0 === n && (n = a.itemSize), n !== a.itemSize))
      return (
        console.error(
          'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.'
        ),
        null
      )
    if ((void 0 === i && (i = a.normalized), i !== a.normalized))
      return (
        console.error(
          'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.'
        ),
        null
      )
    if ((-1 === s && (s = a.gpuType), s !== a.gpuType))
      return (
        console.error(
          'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.'
        ),
        null
      )
    r += a.count * n
  }
  const a = new e(r),
    o = new Lr(a, n, i)
  let l = 0
  for (let c = 0; c < t.length; ++c) {
    const e = t[c]
    if (e.isInterleavedBufferAttribute) {
      const t = l / n
      for (let i = 0, s = e.count; i < s; i++)
        for (let r = 0; r < n; r++) {
          const n = e.getComponent(i, r)
          o.setComponent(i + t, r, n)
        }
    } else a.set(e.array, l)
    l += e.count * n
  }
  return void 0 !== s && (o.gpuType = s), o
}
function Wg(t) {
  const e = t.data.array.constructor,
    n = t.count,
    i = t.itemSize,
    s = t.normalized,
    r = new e(n * i)
  let a
  a = t.isInstancedInterleavedBufferAttribute
    ? new Ih(r, i, s, t.meshPerAttribute)
    : new Lr(r, i, s)
  for (let o = 0; o < n; o++)
    a.setX(o, t.getX(o)),
      i >= 2 && a.setY(o, t.getY(o)),
      i >= 3 && a.setZ(o, t.getZ(o)),
      i >= 4 && a.setW(o, t.getW(o))
  return a
}
function jg(t, e) {
  if (0 === e)
    return (
      console.warn(
        'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.'
      ),
      t
    )
  if (2 === e || 1 === e) {
    let n = t.getIndex()
    if (null === n) {
      const e = [],
        i = t.getAttribute('position')
      if (void 0 === i)
        return (
          console.error(
            'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.'
          ),
          t
        )
      for (let t = 0; t < i.count; t++) e.push(t)
      t.setIndex(e), (n = t.getIndex())
    }
    const i = n.count - 2,
      s = []
    if (2 === e)
      for (let t = 1; t <= i; t++)
        s.push(n.getX(0)), s.push(n.getX(t)), s.push(n.getX(t + 1))
    else
      for (let t = 0; t < i; t++)
        t % 2 == 0
          ? (s.push(n.getX(t)), s.push(n.getX(t + 1)), s.push(n.getX(t + 2)))
          : (s.push(n.getX(t + 2)), s.push(n.getX(t + 1)), s.push(n.getX(t)))
    s.length / 3 !== i &&
      console.error(
        'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.'
      )
    const r = t.clone()
    return r.setIndex(s), r.clearGroups(), r
  }
  return (
    console.error(
      'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:',
      e
    ),
    t
  )
}
e(Ig, 'onPointerDown'),
  e(Lg, 'onPointerMove'),
  e(Dg, 'onPointerUp'),
  e(kg, 'onMouseDown'),
  e(Ng, 'onMouseMove'),
  e(Ug, 'onMouseWheel'),
  e(Bg, 'onKeyDown'),
  e(Og, 'onTouchStart'),
  e(Fg, 'onTouchMove'),
  e(zg, 'onContextMenu'),
  e(Vg, 'interceptControlDown'),
  e(Hg, 'interceptControlUp'),
  e(function (t, n, i = !0) {
    if (!n || !n.isReady)
      throw new Error(
        'BufferGeometryUtils: Initialized MikkTSpace library required.'
      )
    if (
      !t.hasAttribute('position') ||
      !t.hasAttribute('normal') ||
      !t.hasAttribute('uv')
    )
      throw new Error(
        'BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.'
      )
    function s(t) {
      if (t.normalized || t.isInterleavedBufferAttribute) {
        const e = new Float32Array(t.count * t.itemSize)
        for (let n = 0, i = 0; n < t.count; n++)
          (e[i++] = t.getX(n)),
            (e[i++] = t.getY(n)),
            t.itemSize > 2 && (e[i++] = t.getZ(n))
        return e
      }
      return t.array instanceof Float32Array
        ? t.array
        : new Float32Array(t.array)
    }
    e(s, 'getAttributeArray')
    const r = t.index ? t.toNonIndexed() : t,
      a = n.generateTangents(
        s(r.attributes.position),
        s(r.attributes.normal),
        s(r.attributes.uv)
      )
    if (i) for (let e = 3; e < a.length; e += 4) a[e] *= -1
    return r.setAttribute('tangent', new Lr(a, 4)), t !== r && t.copy(r), t
  }, 'computeMikkTSpaceTangents'),
  e(function (t, e = !1) {
    const n = null !== t[0].index,
      i = new Set(Object.keys(t[0].attributes)),
      s = new Set(Object.keys(t[0].morphAttributes)),
      r = {},
      a = {},
      o = t[0].morphTargetsRelative,
      l = new Zr()
    let c = 0
    for (let h = 0; h < t.length; ++h) {
      const u = t[h]
      let d = 0
      if (n !== (null !== u.index))
        return (
          console.error(
            'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' +
              h +
              '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.'
          ),
          null
        )
      for (const t in u.attributes) {
        if (!i.has(t))
          return (
            console.error(
              'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' +
                h +
                '. All geometries must have compatible attributes; make sure "' +
                t +
                '" attribute exists among all geometries, or in none of them.'
            ),
            null
          )
        void 0 === r[t] && (r[t] = []), r[t].push(u.attributes[t]), d++
      }
      if (d !== i.size)
        return (
          console.error(
            'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' +
              h +
              '. Make sure all geometries have the same number of attributes.'
          ),
          null
        )
      if (o !== u.morphTargetsRelative)
        return (
          console.error(
            'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' +
              h +
              '. .morphTargetsRelative must be consistent throughout all geometries.'
          ),
          null
        )
      for (const t in u.morphAttributes) {
        if (!s.has(t))
          return (
            console.error(
              'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' +
                h +
                '.  .morphAttributes must be consistent throughout all geometries.'
            ),
            null
          )
        void 0 === a[t] && (a[t] = []), a[t].push(u.morphAttributes[t])
      }
      if (e) {
        let t
        if (n) t = u.index.count
        else {
          if (void 0 === u.attributes.position)
            return (
              console.error(
                'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' +
                  h +
                  '. The geometry must have either an index or a position attribute'
              ),
              null
            )
          t = u.attributes.position.count
        }
        l.addGroup(c, t, h), (c += t)
      }
    }
    if (n) {
      let e = 0
      const n = []
      for (let i = 0; i < t.length; ++i) {
        const s = t[i].index
        for (let t = 0; t < s.count; ++t) n.push(s.getX(t) + e)
        e += t[i].attributes.position.count
      }
      l.setIndex(n)
    }
    for (const h in r) {
      const t = Gg(r[h])
      if (!t)
        return (
          console.error(
            'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' +
              h +
              ' attribute.'
          ),
          null
        )
      l.setAttribute(h, t)
    }
    for (const h in a) {
      const t = a[h][0].length
      if (0 === t) break
      ;(l.morphAttributes = l.morphAttributes || {}),
        (l.morphAttributes[h] = [])
      for (let e = 0; e < t; ++e) {
        const t = []
        for (let i = 0; i < a[h].length; ++i) t.push(a[h][i][e])
        const n = Gg(t)
        if (!n)
          return (
            console.error(
              'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' +
                h +
                ' morphAttribute.'
            ),
            null
          )
        l.morphAttributes[h].push(n)
      }
    }
    return l
  }, 'mergeGeometries'),
  e(Gg, 'mergeAttributes'),
  e(function (t) {
    return t.isInstancedInterleavedBufferAttribute ||
      t.isInterleavedBufferAttribute
      ? Wg(t)
      : t.isInstancedBufferAttribute
        ? new Ih().copy(t)
        : new Lr().copy(t)
  }, 'deepCloneAttribute'),
  e(function (t) {
    let e,
      n = 0,
      i = 0
    for (let c = 0, h = t.length; c < h; ++c) {
      const s = t[c]
      if (
        (void 0 === e && (e = s.array.constructor), e !== s.array.constructor)
      )
        return (
          console.error(
            'AttributeBuffers of different types cannot be interleaved'
          ),
          null
        )
      ;(n += s.array.length), (i += s.itemSize)
    }
    const s = new Yc(new e(n), i)
    let r = 0
    const a = [],
      o = ['getX', 'getY', 'getZ', 'getW'],
      l = ['setX', 'setY', 'setZ', 'setW']
    for (let c = 0, h = t.length; c < h; c++) {
      const e = t[c],
        n = e.itemSize,
        i = e.count,
        h = new Kc(s, n, r, e.normalized)
      a.push(h), (r += n)
      for (let t = 0; t < i; t++)
        for (let i = 0; i < n; i++) h[l[i]](t, e[o[i]](t))
    }
    return a
  }, 'interleaveAttributes'),
  e(Wg, 'deinterleaveAttribute'),
  e(function (t) {
    const e = t.attributes,
      n = t.morphTargets,
      i = new Map()
    for (const s in e) {
      const t = e[s]
      t.isInterleavedBufferAttribute &&
        (i.has(t) || i.set(t, Wg(t)), (e[s] = i.get(t)))
    }
    for (const s in n) {
      const t = n[s]
      t.isInterleavedBufferAttribute &&
        (i.has(t) || i.set(t, Wg(t)), (n[s] = i.get(t)))
    }
  }, 'deinterleaveGeometry'),
  e(function (t) {
    let e = 0
    for (const i in t.attributes) {
      const n = t.getAttribute(i)
      e += n.count * n.itemSize * n.array.BYTES_PER_ELEMENT
    }
    const n = t.getIndex()
    return (e += n ? n.count * n.itemSize * n.array.BYTES_PER_ELEMENT : 0), e
  }, 'estimateBytesUsed'),
  e(function (t, e = 1e-4) {
    e = Math.max(e, Number.EPSILON)
    const n = {},
      i = t.getIndex(),
      s = t.getAttribute('position'),
      r = i ? i.count : s.count
    let a = 0
    const o = Object.keys(t.attributes),
      l = {},
      c = {},
      h = [],
      u = ['getX', 'getY', 'getZ', 'getW'],
      d = ['setX', 'setY', 'setZ', 'setW']
    for (let y = 0, _ = o.length; y < _; y++) {
      const e = o[y],
        n = t.attributes[e]
      l[e] = new n.constructor(
        new n.array.constructor(n.count * n.itemSize),
        n.itemSize,
        n.normalized
      )
      const i = t.morphAttributes[e]
      i &&
        (c[e] || (c[e] = []),
        i.forEach((t, n) => {
          const i = new t.array.constructor(t.count * t.itemSize)
          c[e][n] = new t.constructor(i, t.itemSize, t.normalized)
        }))
    }
    const p = 0.5 * e,
      m = Math.log10(1 / e),
      f = Math.pow(10, m),
      g = p * f
    for (let y = 0; y < r; y++) {
      const e = i ? i.getX(y) : y
      let s = ''
      for (let n = 0, i = o.length; n < i; n++) {
        const i = o[n],
          r = t.getAttribute(i),
          a = r.itemSize
        for (let t = 0; t < a; t++) s += ~~(r[u[t]](e) * f + g) + ','
      }
      if (s in n) h.push(n[s])
      else {
        for (let n = 0, i = o.length; n < i; n++) {
          const i = o[n],
            s = t.getAttribute(i),
            r = t.morphAttributes[i],
            h = s.itemSize,
            p = l[i],
            m = c[i]
          for (let t = 0; t < h; t++) {
            const n = u[t],
              i = d[t]
            if ((p[i](a, s[n](e)), r))
              for (let t = 0, s = r.length; t < s; t++) m[t][i](a, r[t][n](e))
          }
        }
        ;(n[s] = a), h.push(a), a++
      }
    }
    const v = t.clone()
    for (const y in t.attributes) {
      const t = l[y]
      if (
        (v.setAttribute(
          y,
          new t.constructor(
            t.array.slice(0, a * t.itemSize),
            t.itemSize,
            t.normalized
          )
        ),
        y in c)
      )
        for (let e = 0; e < c[y].length; e++) {
          const t = c[y][e]
          v.morphAttributes[y][e] = new t.constructor(
            t.array.slice(0, a * t.itemSize),
            t.itemSize,
            t.normalized
          )
        }
    }
    return v.setIndex(h), v
  }, 'mergeVertices'),
  e(jg, 'toTrianglesDrawMode'),
  e(function (t) {
    const n = new Qi(),
      i = new Qi(),
      s = new Qi(),
      r = new Qi(),
      a = new Qi(),
      o = new Qi(),
      l = new Qi(),
      c = new Qi(),
      h = new Qi()
    function u(t, e, u, d, p, m, f, g) {
      n.fromBufferAttribute(e, p),
        i.fromBufferAttribute(e, m),
        s.fromBufferAttribute(e, f)
      const v = t.morphTargetInfluences
      if (u && v) {
        l.set(0, 0, 0), c.set(0, 0, 0), h.set(0, 0, 0)
        for (let t = 0, e = u.length; t < e; t++) {
          const e = v[t],
            g = u[t]
          0 !== e &&
            (r.fromBufferAttribute(g, p),
            a.fromBufferAttribute(g, m),
            o.fromBufferAttribute(g, f),
            d
              ? (l.addScaledVector(r, e),
                c.addScaledVector(a, e),
                h.addScaledVector(o, e))
              : (l.addScaledVector(r.sub(n), e),
                c.addScaledVector(a.sub(i), e),
                h.addScaledVector(o.sub(s), e)))
        }
        n.add(l), i.add(c), s.add(h)
      }
      t.isSkinnedMesh &&
        (t.applyBoneTransform(p, n),
        t.applyBoneTransform(m, i),
        t.applyBoneTransform(f, s)),
        (g[3 * p + 0] = n.x),
        (g[3 * p + 1] = n.y),
        (g[3 * p + 2] = n.z),
        (g[3 * m + 0] = i.x),
        (g[3 * m + 1] = i.y),
        (g[3 * m + 2] = i.z),
        (g[3 * f + 0] = s.x),
        (g[3 * f + 1] = s.y),
        (g[3 * f + 2] = s.z)
    }
    e(u, '_calculateMorphedAttributeData')
    const d = t.geometry,
      p = t.material
    let m, f, g
    const v = d.index,
      y = d.attributes.position,
      _ = d.morphAttributes.position,
      x = d.morphTargetsRelative,
      b = d.attributes.normal,
      w = d.morphAttributes.position,
      M = d.groups,
      S = d.drawRange
    let T, E, A, C, R, P, I
    const L = new Float32Array(y.count * y.itemSize),
      D = new Float32Array(b.count * b.itemSize)
    if (null !== v)
      if (Array.isArray(p))
        for (T = 0, A = M.length; T < A; T++)
          for (
            R = M[T],
              P = Math.max(R.start, S.start),
              I = Math.min(R.start + R.count, S.start + S.count),
              E = P,
              C = I;
            E < C;
            E += 3
          )
            (m = v.getX(E)),
              (f = v.getX(E + 1)),
              (g = v.getX(E + 2)),
              u(t, y, _, x, m, f, g, L),
              u(t, b, w, x, m, f, g, D)
      else
        for (
          P = Math.max(0, S.start),
            I = Math.min(v.count, S.start + S.count),
            T = P,
            A = I;
          T < A;
          T += 3
        )
          (m = v.getX(T)),
            (f = v.getX(T + 1)),
            (g = v.getX(T + 2)),
            u(t, y, _, x, m, f, g, L),
            u(t, b, w, x, m, f, g, D)
    else if (Array.isArray(p))
      for (T = 0, A = M.length; T < A; T++)
        for (
          R = M[T],
            P = Math.max(R.start, S.start),
            I = Math.min(R.start + R.count, S.start + S.count),
            E = P,
            C = I;
          E < C;
          E += 3
        )
          (m = E),
            (f = E + 1),
            (g = E + 2),
            u(t, y, _, x, m, f, g, L),
            u(t, b, w, x, m, f, g, D)
    else
      for (
        P = Math.max(0, S.start),
          I = Math.min(y.count, S.start + S.count),
          T = P,
          A = I;
        T < A;
        T += 3
      )
        (m = T),
          (f = T + 1),
          (g = T + 2),
          u(t, y, _, x, m, f, g, L),
          u(t, b, w, x, m, f, g, D)
    return {
      positionAttribute: y,
      normalAttribute: b,
      morphedPositionAttribute: new Vr(L, 3),
      morphedNormalAttribute: new Vr(D, 3)
    }
  }, 'computeMorphedAttributes'),
  e(function (t) {
    if (0 === t.groups.length)
      return (
        console.warn(
          'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.'
        ),
        t
      )
    let e = t.groups
    if (
      ((e = e.sort((t, e) =>
        t.materialIndex !== e.materialIndex
          ? t.materialIndex - e.materialIndex
          : t.start - e.start
      )),
      null === t.getIndex())
    ) {
      const e = t.getAttribute('position'),
        n = []
      for (let t = 0; t < e.count; t += 3) n.push(t, t + 1, t + 2)
      t.setIndex(n)
    }
    const n = t.getIndex(),
      i = []
    for (let a = 0; a < e.length; a++) {
      const t = e[a],
        s = t.start,
        r = s + t.count
      for (let e = s; e < r; e++) i.push(n.getX(e))
    }
    t.dispose(), t.setIndex(i)
    let s = 0
    for (let a = 0; a < e.length; a++) {
      const t = e[a]
      ;(t.start = s), (s += t.count)
    }
    let r = e[0]
    t.groups = [r]
    for (let a = 1; a < e.length; a++) {
      const n = e[a]
      r.materialIndex === n.materialIndex
        ? (r.count += n.count)
        : ((r = n), t.groups.push(r))
    }
    return t
  }, 'mergeGroups'),
  e(function (t, n = Math.PI / 3) {
    const i = Math.cos(n),
      s = 100 * (1 + 1e-10),
      r = [new Qi(), new Qi(), new Qi()],
      a = new Qi(),
      o = new Qi(),
      l = new Qi(),
      c = new Qi()
    function h(t) {
      return `${~~(t.x * s)},${~~(t.y * s)},${~~(t.z * s)}`
    }
    e(h, 'hashVertex')
    const u = t.index ? t.toNonIndexed() : t,
      d = u.attributes.position,
      p = {}
    for (let e = 0, g = d.count / 3; e < g; e++) {
      const t = 3 * e,
        n = r[0].fromBufferAttribute(d, t + 0),
        i = r[1].fromBufferAttribute(d, t + 1),
        s = r[2].fromBufferAttribute(d, t + 2)
      a.subVectors(s, i), o.subVectors(n, i)
      const l = new Qi().crossVectors(a, o).normalize()
      for (let e = 0; e < 3; e++) {
        const t = h(r[e])
        t in p || (p[t] = []), p[t].push(l)
      }
    }
    const m = new Float32Array(3 * d.count),
      f = new Lr(m, 3, !1)
    for (let e = 0, g = d.count / 3; e < g; e++) {
      const t = 3 * e,
        n = r[0].fromBufferAttribute(d, t + 0),
        s = r[1].fromBufferAttribute(d, t + 1),
        u = r[2].fromBufferAttribute(d, t + 2)
      a.subVectors(u, s), o.subVectors(n, s), l.crossVectors(a, o).normalize()
      for (let e = 0; e < 3; e++) {
        const n = p[h(r[e])]
        c.set(0, 0, 0)
        for (let t = 0, e = n.length; t < e; t++) {
          const e = n[t]
          l.dot(e) > i && c.add(e)
        }
        c.normalize(), f.setXYZ(t + e, c.x, c.y, c.z)
      }
    }
    return u.setAttribute('normal', f), u
  }, 'toCreasedNormals')
class Xg extends $p {
  static {
    e(this, 'GLTFLoader')
  }
  constructor(t) {
    super(t),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new Jg(t)
      }),
      this.register(function (t) {
        return new Qg(t)
      }),
      this.register(function (t) {
        return new lv(t)
      }),
      this.register(function (t) {
        return new cv(t)
      }),
      this.register(function (t) {
        return new hv(t)
      }),
      this.register(function (t) {
        return new ev(t)
      }),
      this.register(function (t) {
        return new nv(t)
      }),
      this.register(function (t) {
        return new iv(t)
      }),
      this.register(function (t) {
        return new sv(t)
      }),
      this.register(function (t) {
        return new $g(t)
      }),
      this.register(function (t) {
        return new rv(t)
      }),
      this.register(function (t) {
        return new tv(t)
      }),
      this.register(function (t) {
        return new ov(t)
      }),
      this.register(function (t) {
        return new av(t)
      }),
      this.register(function (t) {
        return new Zg(t)
      }),
      this.register(function (t) {
        return new uv(t)
      }),
      this.register(function (t) {
        return new dv(t)
      })
  }
  load(t, n, i, s) {
    const r = this
    let a
    if ('' !== this.resourcePath) a = this.resourcePath
    else if ('' !== this.path) {
      const e = Am.extractUrlBase(t)
      a = Am.resolveURL(e, this.path)
    } else a = Am.extractUrlBase(t)
    this.manager.itemStart(t)
    const o = e(function (e) {
        s ? s(e) : console.error(e),
          r.manager.itemError(t),
          r.manager.itemEnd(t)
      }, '_onError'),
      l = new tm(this.manager)
    l.setPath(this.path),
      l.setResponseType('arraybuffer'),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        t,
        function (e) {
          try {
            r.parse(
              e,
              a,
              function (e) {
                n(e), r.manager.itemEnd(t)
              },
              o
            )
          } catch (i) {
            o(i)
          }
        },
        i,
        o
      )
  }
  setDRACOLoader(t) {
    return (this.dracoLoader = t), this
  }
  setKTX2Loader(t) {
    return (this.ktx2Loader = t), this
  }
  setMeshoptDecoder(t) {
    return (this.meshoptDecoder = t), this
  }
  register(t) {
    return (
      -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t),
      this
    )
  }
  unregister(t) {
    return (
      -1 !== this.pluginCallbacks.indexOf(t) &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
      this
    )
  }
  parse(t, e, n, i) {
    let s
    const r = {},
      a = {},
      o = new TextDecoder()
    if ('string' == typeof t) s = JSON.parse(t)
    else if (t instanceof ArrayBuffer) {
      if (o.decode(new Uint8Array(t, 0, 4)) === pv) {
        try {
          r[Yg.KHR_BINARY_GLTF] = new gv(t)
        } catch (c) {
          return void (i && i(c))
        }
        s = JSON.parse(r[Yg.KHR_BINARY_GLTF].content)
      } else s = JSON.parse(o.decode(t))
    } else s = t
    if (void 0 === s.asset || s.asset.version[0] < 2)
      return void (
        i &&
        i(
          new Error(
            'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'
          )
        )
      )
    const l = new Wv(s, {
      path: e || this.resourcePath || '',
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    })
    l.fileLoader.setRequestHeader(this.requestHeader)
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const t = this.pluginCallbacks[h](l)
      t.name ||
        console.error('THREE.GLTFLoader: Invalid plugin found: missing name'),
        (a[t.name] = t),
        (r[t.name] = !0)
    }
    if (s.extensionsUsed)
      for (let h = 0; h < s.extensionsUsed.length; ++h) {
        const t = s.extensionsUsed[h],
          e = s.extensionsRequired || []
        switch (t) {
          case Yg.KHR_MATERIALS_UNLIT:
            r[t] = new Kg()
            break
          case Yg.KHR_DRACO_MESH_COMPRESSION:
            r[t] = new vv(s, this.dracoLoader)
            break
          case Yg.KHR_TEXTURE_TRANSFORM:
            r[t] = new yv()
            break
          case Yg.KHR_MESH_QUANTIZATION:
            r[t] = new _v()
            break
          default:
            e.indexOf(t) >= 0 &&
              void 0 === a[t] &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
        }
      }
    l.setExtensions(r), l.setPlugins(a), l.parse(n, i)
  }
  parseAsync(t, e) {
    const n = this
    return new Promise(function (i, s) {
      n.parse(t, e, i, s)
    })
  }
}
function qg() {
  let t = {}
  return {
    get: e(function (e) {
      return t[e]
    }, 'get'),
    add: e(function (e, n) {
      t[e] = n
    }, 'add'),
    remove: e(function (e) {
      delete t[e]
    }, 'remove'),
    removeAll: e(function () {
      t = {}
    }, 'removeAll')
  }
}
e(qg, 'GLTFRegistry')
const Yg = {
  KHR_BINARY_GLTF: 'KHR_binary_glTF',
  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
  KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',
  KHR_MATERIALS_IOR: 'KHR_materials_ior',
  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
  EXT_MATERIALS_BUMP: 'EXT_materials_bump',
  EXT_TEXTURE_WEBP: 'EXT_texture_webp',
  EXT_TEXTURE_AVIF: 'EXT_texture_avif',
  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'
}
class Zg {
  static {
    e(this, 'GLTFLightsExtension')
  }
  constructor(t) {
    ;(this.parser = t),
      (this.name = Yg.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} })
  }
  _markDefs() {
    const t = this.parser,
      e = this.parser.json.nodes || []
    for (let n = 0, i = e.length; n < i; n++) {
      const i = e[n]
      i.extensions &&
        i.extensions[this.name] &&
        void 0 !== i.extensions[this.name].light &&
        t._addNodeRef(this.cache, i.extensions[this.name].light)
    }
  }
  _loadLight(t) {
    const e = this.parser,
      n = 'light:' + t
    let i = e.cache.get(n)
    if (i) return i
    const s = e.json,
      r = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[t]
    let a
    const o = new br(16777215)
    void 0 !== r.color && o.setRGB(r.color[0], r.color[1], r.color[2], An)
    const l = void 0 !== r.range ? r.range : 0
    switch (r.type) {
      case 'directional':
        ;(a = new bm(o)), a.target.position.set(0, 0, -1), a.add(a.target)
        break
      case 'point':
        ;(a = new _m(o)), (a.distance = l)
        break
      case 'spot':
        ;(a = new mm(o)),
          (a.distance = l),
          (r.spot = r.spot || {}),
          (r.spot.innerConeAngle =
            void 0 !== r.spot.innerConeAngle ? r.spot.innerConeAngle : 0),
          (r.spot.outerConeAngle =
            void 0 !== r.spot.outerConeAngle
              ? r.spot.outerConeAngle
              : Math.PI / 4),
          (a.angle = r.spot.outerConeAngle),
          (a.penumbra = 1 - r.spot.innerConeAngle / r.spot.outerConeAngle),
          a.target.position.set(0, 0, -1),
          a.add(a.target)
        break
      default:
        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + r.type)
    }
    return (
      a.position.set(0, 0, 0),
      (a.decay = 2),
      Uv(a, r),
      void 0 !== r.intensity && (a.intensity = r.intensity),
      (a.name = e.createUniqueName(r.name || 'light_' + t)),
      (i = Promise.resolve(a)),
      e.cache.add(n, i),
      i
    )
  }
  getDependency(t, e) {
    if ('light' === t) return this._loadLight(e)
  }
  createNodeAttachment(t) {
    const e = this,
      n = this.parser,
      i = n.json.nodes[t],
      s = ((i.extensions && i.extensions[this.name]) || {}).light
    return void 0 === s
      ? null
      : this._loadLight(s).then(function (t) {
          return n._getNodeRef(e.cache, s, t)
        })
  }
}
class Kg {
  static {
    e(this, 'GLTFMaterialsUnlitExtension')
  }
  constructor() {
    this.name = Yg.KHR_MATERIALS_UNLIT
  }
  getMaterialType() {
    return Tr
  }
  extendParams(t, e, n) {
    const i = []
    ;(t.color = new br(1, 1, 1)), (t.opacity = 1)
    const s = e.pbrMetallicRoughness
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const e = s.baseColorFactor
        t.color.setRGB(e[0], e[1], e[2], An), (t.opacity = e[3])
      }
      void 0 !== s.baseColorTexture &&
        i.push(n.assignTexture(t, 'map', s.baseColorTexture, En))
    }
    return Promise.all(i)
  }
}
class $g {
  static {
    e(this, 'GLTFMaterialsEmissiveStrengthExtension')
  }
  constructor(t) {
    ;(this.parser = t), (this.name = Yg.KHR_MATERIALS_EMISSIVE_STRENGTH)
  }
  extendMaterialParams(t, e) {
    const n = this.parser.json.materials[t]
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve()
    const i = n.extensions[this.name].emissiveStrength
    return void 0 !== i && (e.emissiveIntensity = i), Promise.resolve()
  }
}
class Jg {
  static {
    e(this, 'GLTFMaterialsClearcoatExtension')
  }
  constructor(t) {
    ;(this.parser = t), (this.name = Yg.KHR_MATERIALS_CLEARCOAT)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? _p : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const s = [],
      r = i.extensions[this.name]
    if (
      (void 0 !== r.clearcoatFactor && (e.clearcoat = r.clearcoatFactor),
      void 0 !== r.clearcoatTexture &&
        s.push(n.assignTexture(e, 'clearcoatMap', r.clearcoatTexture)),
      void 0 !== r.clearcoatRoughnessFactor &&
        (e.clearcoatRoughness = r.clearcoatRoughnessFactor),
      void 0 !== r.clearcoatRoughnessTexture &&
        s.push(
          n.assignTexture(
            e,
            'clearcoatRoughnessMap',
            r.clearcoatRoughnessTexture
          )
        ),
      void 0 !== r.clearcoatNormalTexture &&
        (s.push(
          n.assignTexture(e, 'clearcoatNormalMap', r.clearcoatNormalTexture)
        ),
        void 0 !== r.clearcoatNormalTexture.scale))
    ) {
      const t = r.clearcoatNormalTexture.scale
      e.clearcoatNormalScale = new vi(t, t)
    }
    return Promise.all(s)
  }
}
class Qg {
  static {
    e(this, 'GLTFMaterialsDispersionExtension')
  }
  constructor(t) {
    ;(this.parser = t), (this.name = Yg.KHR_MATERIALS_DISPERSION)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? _p : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser.json.materials[t]
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve()
    const i = n.extensions[this.name]
    return (
      (e.dispersion = void 0 !== i.dispersion ? i.dispersion : 0),
      Promise.resolve()
    )
  }
}
class tv {
  static {
    e(this, 'GLTFMaterialsIridescenceExtension')
  }
  constructor(t) {
    ;(this.parser = t), (this.name = Yg.KHR_MATERIALS_IRIDESCENCE)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? _p : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const s = [],
      r = i.extensions[this.name]
    return (
      void 0 !== r.iridescenceFactor && (e.iridescence = r.iridescenceFactor),
      void 0 !== r.iridescenceTexture &&
        s.push(n.assignTexture(e, 'iridescenceMap', r.iridescenceTexture)),
      void 0 !== r.iridescenceIor && (e.iridescenceIOR = r.iridescenceIor),
      void 0 === e.iridescenceThicknessRange &&
        (e.iridescenceThicknessRange = [100, 400]),
      void 0 !== r.iridescenceThicknessMinimum &&
        (e.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum),
      void 0 !== r.iridescenceThicknessMaximum &&
        (e.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum),
      void 0 !== r.iridescenceThicknessTexture &&
        s.push(
          n.assignTexture(
            e,
            'iridescenceThicknessMap',
            r.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    )
  }
}
class ev {
  static {
    e(this, 'GLTFMaterialsSheenExtension')
  }
  constructor(t) {
    ;(this.parser = t), (this.name = Yg.KHR_MATERIALS_SHEEN)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? _p : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const s = []
    ;(e.sheenColor = new br(0, 0, 0)), (e.sheenRoughness = 0), (e.sheen = 1)
    const r = i.extensions[this.name]
    if (void 0 !== r.sheenColorFactor) {
      const t = r.sheenColorFactor
      e.sheenColor.setRGB(t[0], t[1], t[2], An)
    }
    return (
      void 0 !== r.sheenRoughnessFactor &&
        (e.sheenRoughness = r.sheenRoughnessFactor),
      void 0 !== r.sheenColorTexture &&
        s.push(n.assignTexture(e, 'sheenColorMap', r.sheenColorTexture, En)),
      void 0 !== r.sheenRoughnessTexture &&
        s.push(
          n.assignTexture(e, 'sheenRoughnessMap', r.sheenRoughnessTexture)
        ),
      Promise.all(s)
    )
  }
}
class nv {
  static {
    e(this, 'GLTFMaterialsTransmissionExtension')
  }
  constructor(t) {
    ;(this.parser = t), (this.name = Yg.KHR_MATERIALS_TRANSMISSION)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? _p : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const s = [],
      r = i.extensions[this.name]
    return (
      void 0 !== r.transmissionFactor &&
        (e.transmission = r.transmissionFactor),
      void 0 !== r.transmissionTexture &&
        s.push(n.assignTexture(e, 'transmissionMap', r.transmissionTexture)),
      Promise.all(s)
    )
  }
}
class iv {
  static {
    e(this, 'GLTFMaterialsVolumeExtension')
  }
  constructor(t) {
    ;(this.parser = t), (this.name = Yg.KHR_MATERIALS_VOLUME)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? _p : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const s = [],
      r = i.extensions[this.name]
    ;(e.thickness = void 0 !== r.thicknessFactor ? r.thicknessFactor : 0),
      void 0 !== r.thicknessTexture &&
        s.push(n.assignTexture(e, 'thicknessMap', r.thicknessTexture)),
      (e.attenuationDistance = r.attenuationDistance || 1 / 0)
    const a = r.attenuationColor || [1, 1, 1]
    return (
      (e.attenuationColor = new br().setRGB(a[0], a[1], a[2], An)),
      Promise.all(s)
    )
  }
}
class sv {
  static {
    e(this, 'GLTFMaterialsIorExtension')
  }
  constructor(t) {
    ;(this.parser = t), (this.name = Yg.KHR_MATERIALS_IOR)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? _p : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser.json.materials[t]
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve()
    const i = n.extensions[this.name]
    return (e.ior = void 0 !== i.ior ? i.ior : 1.5), Promise.resolve()
  }
}
class rv {
  static {
    e(this, 'GLTFMaterialsSpecularExtension')
  }
  constructor(t) {
    ;(this.parser = t), (this.name = Yg.KHR_MATERIALS_SPECULAR)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? _p : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const s = [],
      r = i.extensions[this.name]
    ;(e.specularIntensity = void 0 !== r.specularFactor ? r.specularFactor : 1),
      void 0 !== r.specularTexture &&
        s.push(n.assignTexture(e, 'specularIntensityMap', r.specularTexture))
    const a = r.specularColorFactor || [1, 1, 1]
    return (
      (e.specularColor = new br().setRGB(a[0], a[1], a[2], An)),
      void 0 !== r.specularColorTexture &&
        s.push(
          n.assignTexture(e, 'specularColorMap', r.specularColorTexture, En)
        ),
      Promise.all(s)
    )
  }
}
class av {
  static {
    e(this, 'GLTFMaterialsBumpExtension')
  }
  constructor(t) {
    ;(this.parser = t), (this.name = Yg.EXT_MATERIALS_BUMP)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? _p : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const s = [],
      r = i.extensions[this.name]
    return (
      (e.bumpScale = void 0 !== r.bumpFactor ? r.bumpFactor : 1),
      void 0 !== r.bumpTexture &&
        s.push(n.assignTexture(e, 'bumpMap', r.bumpTexture)),
      Promise.all(s)
    )
  }
}
class ov {
  static {
    e(this, 'GLTFMaterialsAnisotropyExtension')
  }
  constructor(t) {
    ;(this.parser = t), (this.name = Yg.KHR_MATERIALS_ANISOTROPY)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? _p : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const s = [],
      r = i.extensions[this.name]
    return (
      void 0 !== r.anisotropyStrength && (e.anisotropy = r.anisotropyStrength),
      void 0 !== r.anisotropyRotation &&
        (e.anisotropyRotation = r.anisotropyRotation),
      void 0 !== r.anisotropyTexture &&
        s.push(n.assignTexture(e, 'anisotropyMap', r.anisotropyTexture)),
      Promise.all(s)
    )
  }
}
class lv {
  static {
    e(this, 'GLTFTextureBasisUExtension')
  }
  constructor(t) {
    ;(this.parser = t), (this.name = Yg.KHR_TEXTURE_BASISU)
  }
  loadTexture(t) {
    const e = this.parser,
      n = e.json,
      i = n.textures[t]
    if (!i.extensions || !i.extensions[this.name]) return null
    const s = i.extensions[this.name],
      r = e.options.ktx2Loader
    if (!r) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures'
        )
      return null
    }
    return e.loadTextureImage(t, s.source, r)
  }
}
class cv {
  static {
    e(this, 'GLTFTextureWebPExtension')
  }
  constructor(t) {
    ;(this.parser = t),
      (this.name = Yg.EXT_TEXTURE_WEBP),
      (this.isSupported = null)
  }
  loadTexture(t) {
    const e = this.name,
      n = this.parser,
      i = n.json,
      s = i.textures[t]
    if (!s.extensions || !s.extensions[e]) return null
    const r = s.extensions[e],
      a = i.images[r.source]
    let o = n.textureLoader
    if (a.uri) {
      const t = n.options.manager.getHandler(a.uri)
      null !== t && (o = t)
    }
    return this.detectSupport().then(function (s) {
      if (s) return n.loadTextureImage(t, r.source, o)
      if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
        throw new Error(
          'THREE.GLTFLoader: WebP required by asset but unsupported.'
        )
      return n.loadTexture(t)
    })
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (t) {
          const e = new Image()
          ;(e.src =
            'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
            (e.onload = e.onerror =
              function () {
                t(1 === e.height)
              })
        })),
      this.isSupported
    )
  }
}
class hv {
  static {
    e(this, 'GLTFTextureAVIFExtension')
  }
  constructor(t) {
    ;(this.parser = t),
      (this.name = Yg.EXT_TEXTURE_AVIF),
      (this.isSupported = null)
  }
  loadTexture(t) {
    const e = this.name,
      n = this.parser,
      i = n.json,
      s = i.textures[t]
    if (!s.extensions || !s.extensions[e]) return null
    const r = s.extensions[e],
      a = i.images[r.source]
    let o = n.textureLoader
    if (a.uri) {
      const t = n.options.manager.getHandler(a.uri)
      null !== t && (o = t)
    }
    return this.detectSupport().then(function (s) {
      if (s) return n.loadTextureImage(t, r.source, o)
      if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
        throw new Error(
          'THREE.GLTFLoader: AVIF required by asset but unsupported.'
        )
      return n.loadTexture(t)
    })
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (t) {
          const e = new Image()
          ;(e.src =
            'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='),
            (e.onload = e.onerror =
              function () {
                t(1 === e.height)
              })
        })),
      this.isSupported
    )
  }
}
class uv {
  static {
    e(this, 'GLTFMeshoptCompression')
  }
  constructor(t) {
    ;(this.name = Yg.EXT_MESHOPT_COMPRESSION), (this.parser = t)
  }
  loadBufferView(t) {
    const e = this.parser.json,
      n = e.bufferViews[t]
    if (n.extensions && n.extensions[this.name]) {
      const t = n.extensions[this.name],
        i = this.parser.getDependency('buffer', t.buffer),
        s = this.parser.options.meshoptDecoder
      if (!s || !s.supported) {
        if (
          e.extensionsRequired &&
          e.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files'
          )
        return null
      }
      return i.then(function (e) {
        const n = t.byteOffset || 0,
          i = t.byteLength || 0,
          r = t.count,
          a = t.byteStride,
          o = new Uint8Array(e, n, i)
        return s.decodeGltfBufferAsync
          ? s
              .decodeGltfBufferAsync(r, a, o, t.mode, t.filter)
              .then(function (t) {
                return t.buffer
              })
          : s.ready.then(function () {
              const e = new ArrayBuffer(r * a)
              return (
                s.decodeGltfBuffer(
                  new Uint8Array(e),
                  r,
                  a,
                  o,
                  t.mode,
                  t.filter
                ),
                e
              )
            })
      })
    }
    return null
  }
}
class dv {
  static {
    e(this, 'GLTFMeshGpuInstancing')
  }
  constructor(t) {
    ;(this.name = Yg.EXT_MESH_GPU_INSTANCING), (this.parser = t)
  }
  createNodeMesh(t) {
    const e = this.parser.json,
      n = e.nodes[t]
    if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
      return null
    const i = e.meshes[n.mesh]
    for (const o of i.primitives)
      if (
        o.mode !== Mv.TRIANGLES &&
        o.mode !== Mv.TRIANGLE_STRIP &&
        o.mode !== Mv.TRIANGLE_FAN &&
        void 0 !== o.mode
      )
        return null
    const s = n.extensions[this.name].attributes,
      r = [],
      a = {}
    for (const o in s)
      r.push(
        this.parser
          .getDependency('accessor', s[o])
          .then((t) => ((a[o] = t), a[o]))
      )
    return r.length < 1
      ? null
      : (r.push(this.parser.createNodeMesh(t)),
        Promise.all(r).then((t) => {
          const e = t.pop(),
            n = e.isGroup ? e.children : [e],
            i = t[0].count,
            s = []
          for (const r of n) {
            const t = new Rs(),
              e = new Qi(),
              n = new Ji(),
              o = new Qi(1, 1, 1),
              l = new Fh(r.geometry, r.material, i)
            for (let s = 0; s < i; s++)
              a.TRANSLATION && e.fromBufferAttribute(a.TRANSLATION, s),
                a.ROTATION && n.fromBufferAttribute(a.ROTATION, s),
                a.SCALE && o.fromBufferAttribute(a.SCALE, s),
                l.setMatrixAt(s, t.compose(e, n, o))
            for (const i in a)
              if ('_COLOR_0' === i) {
                const t = a[i]
                l.instanceColor = new Ih(t.array, t.itemSize, t.normalized)
              } else
                'TRANSLATION' !== i &&
                  'ROTATION' !== i &&
                  'SCALE' !== i &&
                  r.geometry.setAttribute(i, a[i])
            nr.prototype.copy.call(l, r),
              this.parser.assignFinalMaterial(l),
              s.push(l)
          }
          return e.isGroup ? (e.clear(), e.add(...s), e) : s[0]
        }))
  }
}
const pv = 'glTF',
  mv = 1313821514,
  fv = 5130562
class gv {
  static {
    e(this, 'GLTFBinaryExtension')
  }
  constructor(t) {
    ;(this.name = Yg.KHR_BINARY_GLTF), (this.content = null), (this.body = null)
    const e = new DataView(t, 0, 12),
      n = new TextDecoder()
    if (
      ((this.header = {
        magic: n.decode(new Uint8Array(t.slice(0, 4))),
        version: e.getUint32(4, !0),
        length: e.getUint32(8, !0)
      }),
      this.header.magic !== pv)
    )
      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')
    if (this.header.version < 2)
      throw new Error('THREE.GLTFLoader: Legacy binary file detected.')
    const i = this.header.length - 12,
      s = new DataView(t, 12)
    let r = 0
    for (; r < i; ) {
      const e = s.getUint32(r, !0)
      r += 4
      const i = s.getUint32(r, !0)
      if (((r += 4), i === mv)) {
        const i = new Uint8Array(t, 12 + r, e)
        this.content = n.decode(i)
      } else if (i === fv) {
        const n = 12 + r
        this.body = t.slice(n, n + e)
      }
      r += e
    }
    if (null === this.content)
      throw new Error('THREE.GLTFLoader: JSON content not found.')
  }
}
class vv {
  static {
    e(this, 'GLTFDracoMeshCompressionExtension')
  }
  constructor(t, e) {
    if (!e)
      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')
    ;(this.name = Yg.KHR_DRACO_MESH_COMPRESSION),
      (this.json = t),
      (this.dracoLoader = e),
      this.dracoLoader.preload()
  }
  decodePrimitive(t, e) {
    const n = this.json,
      i = this.dracoLoader,
      s = t.extensions[this.name].bufferView,
      r = t.extensions[this.name].attributes,
      a = {},
      o = {},
      l = {}
    for (const c in r) {
      const t = Cv[c] || c.toLowerCase()
      a[t] = r[c]
    }
    for (const c in t.attributes) {
      const e = Cv[c] || c.toLowerCase()
      if (void 0 !== r[c]) {
        const i = n.accessors[t.attributes[c]],
          s = Sv[i.componentType]
        ;(l[e] = s.name), (o[e] = !0 === i.normalized)
      }
    }
    return e.getDependency('bufferView', s).then(function (t) {
      return new Promise(function (e, n) {
        i.decodeDracoFile(
          t,
          function (t) {
            for (const e in t.attributes) {
              const n = t.attributes[e],
                i = o[e]
              void 0 !== i && (n.normalized = i)
            }
            e(t)
          },
          a,
          l,
          An,
          n
        )
      })
    })
  }
}
class yv {
  static {
    e(this, 'GLTFTextureTransformExtension')
  }
  constructor() {
    this.name = Yg.KHR_TEXTURE_TRANSFORM
  }
  extendTexture(t, e) {
    return (void 0 !== e.texCoord && e.texCoord !== t.channel) ||
      void 0 !== e.offset ||
      void 0 !== e.rotation ||
      void 0 !== e.scale
      ? ((t = t.clone()),
        void 0 !== e.texCoord && (t.channel = e.texCoord),
        void 0 !== e.offset && t.offset.fromArray(e.offset),
        void 0 !== e.rotation && (t.rotation = e.rotation),
        void 0 !== e.scale && t.repeat.fromArray(e.scale),
        (t.needsUpdate = !0),
        t)
      : t
  }
}
class _v {
  static {
    e(this, 'GLTFMeshQuantizationExtension')
  }
  constructor() {
    this.name = Yg.KHR_MESH_QUANTIZATION
  }
}
class xv extends Dp {
  static {
    e(this, 'GLTFCubicSplineInterpolant')
  }
  constructor(t, e, n, i) {
    super(t, e, n, i)
  }
  copySampleValue_(t) {
    const e = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      s = t * i * 3 + i
    for (let r = 0; r !== i; r++) e[r] = n[s + r]
    return e
  }
  interpolate_(t, e, n, i) {
    const s = this.resultBuffer,
      r = this.sampleValues,
      a = this.valueSize,
      o = 2 * a,
      l = 3 * a,
      c = i - e,
      h = (n - e) / c,
      u = h * h,
      d = u * h,
      p = t * l,
      m = p - l,
      f = -2 * d + 3 * u,
      g = d - u,
      v = 1 - f,
      y = g - u + h
    for (let _ = 0; _ !== a; _++) {
      const t = r[m + _ + a],
        e = r[m + _ + o] * c,
        n = r[p + _ + a],
        i = r[p + _] * c
      s[_] = v * t + y * e + f * n + g * i
    }
    return s
  }
}
const bv = new Ji()
class wv extends xv {
  static {
    e(this, 'GLTFCubicSplineQuaternionInterpolant')
  }
  interpolate_(t, e, n, i) {
    const s = super.interpolate_(t, e, n, i)
    return bv.fromArray(s).normalize().toArray(s), s
  }
}
const Mv = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
  },
  Sv = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  },
  Tv = { 9728: ve, 9729: xe, 9984: ye, 9985: be, 9986: _e, 9987: we },
  Ev = { 33071: fe, 33648: ge, 10497: me },
  Av = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  Cv = {
    POSITION: 'position',
    NORMAL: 'normal',
    TANGENT: 'tangent',
    TEXCOORD_0: 'uv',
    TEXCOORD_1: 'uv1',
    TEXCOORD_2: 'uv2',
    TEXCOORD_3: 'uv3',
    COLOR_0: 'color',
    WEIGHTS_0: 'skinWeight',
    JOINTS_0: 'skinIndex'
  },
  Rv = {
    scale: 'scale',
    translation: 'position',
    rotation: 'quaternion',
    weights: 'morphTargetInfluences'
  },
  Pv = { CUBICSPLINE: void 0, LINEAR: yn, STEP: vn },
  Iv = 'OPAQUE',
  Lv = 'MASK',
  Dv = 'BLEND'
function kv(t) {
  return (
    void 0 === t.DefaultMaterial &&
      (t.DefaultMaterial = new yp({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: 0
      })),
    t.DefaultMaterial
  )
}
function Nv(t, e, n) {
  for (const i in n.extensions)
    void 0 === t[i] &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[i] = n.extensions[i]))
}
function Uv(t, e) {
  void 0 !== e.extras &&
    ('object' == typeof e.extras
      ? Object.assign(t.userData, e.extras)
      : console.warn(
          'THREE.GLTFLoader: Ignoring primitive type .extras, ' + e.extras
        ))
}
function Bv(t, e, n) {
  let i = !1,
    s = !1,
    r = !1
  for (let c = 0, h = e.length; c < h; c++) {
    const t = e[c]
    if (
      (void 0 !== t.POSITION && (i = !0),
      void 0 !== t.NORMAL && (s = !0),
      void 0 !== t.COLOR_0 && (r = !0),
      i && s && r)
    )
      break
  }
  if (!i && !s && !r) return Promise.resolve(t)
  const a = [],
    o = [],
    l = []
  for (let c = 0, h = e.length; c < h; c++) {
    const h = e[c]
    if (i) {
      const e =
        void 0 !== h.POSITION
          ? n.getDependency('accessor', h.POSITION)
          : t.attributes.position
      a.push(e)
    }
    if (s) {
      const e =
        void 0 !== h.NORMAL
          ? n.getDependency('accessor', h.NORMAL)
          : t.attributes.normal
      o.push(e)
    }
    if (r) {
      const e =
        void 0 !== h.COLOR_0
          ? n.getDependency('accessor', h.COLOR_0)
          : t.attributes.color
      l.push(e)
    }
  }
  return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then(
    function (e) {
      const n = e[0],
        a = e[1],
        o = e[2]
      return (
        i && (t.morphAttributes.position = n),
        s && (t.morphAttributes.normal = a),
        r && (t.morphAttributes.color = o),
        (t.morphTargetsRelative = !0),
        t
      )
    }
  )
}
function Ov(t, e) {
  if ((t.updateMorphTargets(), void 0 !== e.weights))
    for (let n = 0, i = e.weights.length; n < i; n++)
      t.morphTargetInfluences[n] = e.weights[n]
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const n = e.extras.targetNames
    if (t.morphTargetInfluences.length === n.length) {
      t.morphTargetDictionary = {}
      for (let e = 0, i = n.length; e < i; e++)
        t.morphTargetDictionary[n[e]] = e
    } else
      console.warn(
        'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.'
      )
  }
}
function Fv(t) {
  let e
  const n = t.extensions && t.extensions[Yg.KHR_DRACO_MESH_COMPRESSION]
  if (
    ((e = n
      ? 'draco:' + n.bufferView + ':' + n.indices + ':' + zv(n.attributes)
      : t.indices + ':' + zv(t.attributes) + ':' + t.mode),
    void 0 !== t.targets)
  )
    for (let i = 0, s = t.targets.length; i < s; i++)
      e += ':' + zv(t.targets[i])
  return e
}
function zv(t) {
  let e = ''
  const n = Object.keys(t).sort()
  for (let i = 0, s = n.length; i < s; i++) e += n[i] + ':' + t[n[i]] + ';'
  return e
}
function Vv(t) {
  switch (t) {
    case Int8Array:
      return 1 / 127
    case Uint8Array:
      return 1 / 255
    case Int16Array:
      return 1 / 32767
    case Uint16Array:
      return 1 / 65535
    default:
      throw new Error(
        'THREE.GLTFLoader: Unsupported normalized accessor component type.'
      )
  }
}
function Hv(t) {
  return t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/)
    ? 'image/jpeg'
    : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/)
      ? 'image/webp'
      : t.search(/\.ktx2($|\?)/i) > 0 || 0 === t.search(/^data\:image\/ktx2/)
        ? 'image/ktx2'
        : 'image/png'
}
e(kv, 'createDefaultMaterial'),
  e(Nv, 'addUnknownExtensionsToUserData'),
  e(Uv, 'assignExtrasToUserData'),
  e(Bv, 'addMorphTargets'),
  e(Ov, 'updateMorphTargets'),
  e(Fv, 'createPrimitiveKey'),
  e(zv, 'createAttributesKey'),
  e(Vv, 'getNormalizedComponentScale'),
  e(Hv, 'getImageURIMimeType')
const Gv = new Rs()
class Wv {
  static {
    e(this, 'GLTFParser')
  }
  constructor(t = {}, e = {}) {
    ;(this.json = t),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = e),
      (this.cache = new qg()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {})
    let n = !1,
      i = -1,
      s = !1,
      r = -1
    if ('undefined' != typeof navigator) {
      const t = navigator.userAgent
      n = !0 === /^((?!chrome|android).)*safari/i.test(t)
      const e = t.match(/Version\/(\d+)/)
      ;(i = n && e ? parseInt(e[1], 10) : -1),
        (s = t.indexOf('Firefox') > -1),
        (r = s ? t.match(/Firefox\/([0-9]+)\./)[1] : -1)
    }
    'undefined' == typeof createImageBitmap || (n && i < 17) || (s && r < 98)
      ? (this.textureLoader = new am(this.options.manager))
      : (this.textureLoader = new km(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new tm(this.options.manager)),
      this.fileLoader.setResponseType('arraybuffer'),
      'use-credentials' === this.options.crossOrigin &&
        this.fileLoader.setWithCredentials(!0)
  }
  setExtensions(t) {
    this.extensions = t
  }
  setPlugins(t) {
    this.plugins = t
  }
  parse(t, e) {
    const n = this,
      i = this.json,
      s = this.extensions
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (t) {
        return t._markDefs && t._markDefs()
      }),
      Promise.all(
        this._invokeAll(function (t) {
          return t.beforeRoot && t.beforeRoot()
        })
      )
        .then(function () {
          return Promise.all([
            n.getDependencies('scene'),
            n.getDependencies('animation'),
            n.getDependencies('camera')
          ])
        })
        .then(function (e) {
          const r = {
            scene: e[0][i.scene || 0],
            scenes: e[0],
            animations: e[1],
            cameras: e[2],
            asset: i.asset,
            parser: n,
            userData: {}
          }
          return (
            Nv(s, r, i),
            Uv(r, i),
            Promise.all(
              n._invokeAll(function (t) {
                return t.afterRoot && t.afterRoot(r)
              })
            ).then(function () {
              for (const t of r.scenes) t.updateMatrixWorld()
              t(r)
            })
          )
        })
        .catch(e)
  }
  _markDefs() {
    const t = this.json.nodes || [],
      e = this.json.skins || [],
      n = this.json.meshes || []
    for (let i = 0, s = e.length; i < s; i++) {
      const n = e[i].joints
      for (let e = 0, i = n.length; e < i; e++) t[n[e]].isBone = !0
    }
    for (let i = 0, s = t.length; i < s; i++) {
      const e = t[i]
      void 0 !== e.mesh &&
        (this._addNodeRef(this.meshCache, e.mesh),
        void 0 !== e.skin && (n[e.mesh].isSkinnedMesh = !0)),
        void 0 !== e.camera && this._addNodeRef(this.cameraCache, e.camera)
    }
  }
  _addNodeRef(t, e) {
    void 0 !== e &&
      (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
  }
  _getNodeRef(t, n, i) {
    if (t.refs[n] <= 1) return i
    const s = i.clone(),
      r = e((t, e) => {
        const n = this.associations.get(t)
        null != n && this.associations.set(e, n)
        for (const [i, s] of t.children.entries()) r(s, e.children[i])
      }, 'updateMappings')
    return r(i, s), (s.name += '_instance_' + t.uses[n]++), s
  }
  _invokeOne(t) {
    const e = Object.values(this.plugins)
    e.push(this)
    for (let n = 0; n < e.length; n++) {
      const i = t(e[n])
      if (i) return i
    }
    return null
  }
  _invokeAll(t) {
    const e = Object.values(this.plugins)
    e.unshift(this)
    const n = []
    for (let i = 0; i < e.length; i++) {
      const s = t(e[i])
      s && n.push(s)
    }
    return n
  }
  getDependency(t, e) {
    const n = t + ':' + e
    let i = this.cache.get(n)
    if (!i) {
      switch (t) {
        case 'scene':
          i = this.loadScene(e)
          break
        case 'node':
          i = this._invokeOne(function (t) {
            return t.loadNode && t.loadNode(e)
          })
          break
        case 'mesh':
          i = this._invokeOne(function (t) {
            return t.loadMesh && t.loadMesh(e)
          })
          break
        case 'accessor':
          i = this.loadAccessor(e)
          break
        case 'bufferView':
          i = this._invokeOne(function (t) {
            return t.loadBufferView && t.loadBufferView(e)
          })
          break
        case 'buffer':
          i = this.loadBuffer(e)
          break
        case 'material':
          i = this._invokeOne(function (t) {
            return t.loadMaterial && t.loadMaterial(e)
          })
          break
        case 'texture':
          i = this._invokeOne(function (t) {
            return t.loadTexture && t.loadTexture(e)
          })
          break
        case 'skin':
          i = this.loadSkin(e)
          break
        case 'animation':
          i = this._invokeOne(function (t) {
            return t.loadAnimation && t.loadAnimation(e)
          })
          break
        case 'camera':
          i = this.loadCamera(e)
          break
        default:
          if (
            ((i = this._invokeOne(function (n) {
              return n != this && n.getDependency && n.getDependency(t, e)
            })),
            !i)
          )
            throw new Error('Unknown type: ' + t)
      }
      this.cache.add(n, i)
    }
    return i
  }
  getDependencies(t) {
    let e = this.cache.get(t)
    if (!e) {
      const n = this,
        i = this.json[t + ('mesh' === t ? 'es' : 's')] || []
      ;(e = Promise.all(
        i.map(function (e, i) {
          return n.getDependency(t, i)
        })
      )),
        this.cache.add(t, e)
    }
    return e
  }
  loadBuffer(t) {
    const e = this.json.buffers[t],
      n = this.fileLoader
    if (e.type && 'arraybuffer' !== e.type)
      throw new Error(
        'THREE.GLTFLoader: ' + e.type + ' buffer type is not supported.'
      )
    if (void 0 === e.uri && 0 === t)
      return Promise.resolve(this.extensions[Yg.KHR_BINARY_GLTF].body)
    const i = this.options
    return new Promise(function (t, s) {
      n.load(Am.resolveURL(e.uri, i.path), t, void 0, function () {
        s(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
      })
    })
  }
  loadBufferView(t) {
    const e = this.json.bufferViews[t]
    return this.getDependency('buffer', e.buffer).then(function (t) {
      const n = e.byteLength || 0,
        i = e.byteOffset || 0
      return t.slice(i, i + n)
    })
  }
  loadAccessor(t) {
    const e = this,
      n = this.json,
      i = this.json.accessors[t]
    if (void 0 === i.bufferView && void 0 === i.sparse) {
      const t = Av[i.type],
        e = Sv[i.componentType],
        n = !0 === i.normalized,
        s = new e(i.count * t)
      return Promise.resolve(new Lr(s, t, n))
    }
    const s = []
    return (
      void 0 !== i.bufferView
        ? s.push(this.getDependency('bufferView', i.bufferView))
        : s.push(null),
      void 0 !== i.sparse &&
        (s.push(this.getDependency('bufferView', i.sparse.indices.bufferView)),
        s.push(this.getDependency('bufferView', i.sparse.values.bufferView))),
      Promise.all(s).then(function (t) {
        const s = t[0],
          r = Av[i.type],
          a = Sv[i.componentType],
          o = a.BYTES_PER_ELEMENT,
          l = o * r,
          c = i.byteOffset || 0,
          h =
            void 0 !== i.bufferView
              ? n.bufferViews[i.bufferView].byteStride
              : void 0,
          u = !0 === i.normalized
        let d, p
        if (h && h !== l) {
          const t = Math.floor(c / h),
            n =
              'InterleavedBuffer:' +
              i.bufferView +
              ':' +
              i.componentType +
              ':' +
              t +
              ':' +
              i.count
          let l = e.cache.get(n)
          l ||
            ((d = new a(s, t * h, (i.count * h) / o)),
            (l = new Yc(d, h / o)),
            e.cache.add(n, l)),
            (p = new Kc(l, r, (c % h) / o, u))
        } else
          (d = null === s ? new a(i.count * r) : new a(s, c, i.count * r)),
            (p = new Lr(d, r, u))
        if (void 0 !== i.sparse) {
          const e = Av.SCALAR,
            n = Sv[i.sparse.indices.componentType],
            o = i.sparse.indices.byteOffset || 0,
            l = i.sparse.values.byteOffset || 0,
            c = new n(t[1], o, i.sparse.count * e),
            h = new a(t[2], l, i.sparse.count * r)
          null !== s && (p = new Lr(p.array.slice(), p.itemSize, p.normalized)),
            (p.normalized = !1)
          for (let t = 0, i = c.length; t < i; t++) {
            const e = c[t]
            if (
              (p.setX(e, h[t * r]),
              r >= 2 && p.setY(e, h[t * r + 1]),
              r >= 3 && p.setZ(e, h[t * r + 2]),
              r >= 4 && p.setW(e, h[t * r + 3]),
              r >= 5)
            )
              throw new Error(
                'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.'
              )
          }
          p.normalized = u
        }
        return p
      })
    )
  }
  loadTexture(t) {
    const e = this.json,
      n = this.options,
      i = e.textures[t].source,
      s = e.images[i]
    let r = this.textureLoader
    if (s.uri) {
      const t = n.manager.getHandler(s.uri)
      null !== t && (r = t)
    }
    return this.loadTextureImage(t, i, r)
  }
  loadTextureImage(t, e, n) {
    const i = this,
      s = this.json,
      r = s.textures[t],
      a = s.images[e],
      o = (a.uri || a.bufferView) + ':' + r.sampler
    if (this.textureCache[o]) return this.textureCache[o]
    const l = this.loadImageSource(e, n)
      .then(function (e) {
        ;(e.flipY = !1),
          (e.name = r.name || a.name || ''),
          '' === e.name &&
            'string' == typeof a.uri &&
            !1 === a.uri.startsWith('data:image/') &&
            (e.name = a.uri)
        const n = (s.samplers || {})[r.sampler] || {}
        return (
          (e.magFilter = Tv[n.magFilter] || xe),
          (e.minFilter = Tv[n.minFilter] || we),
          (e.wrapS = Ev[n.wrapS] || me),
          (e.wrapT = Ev[n.wrapT] || me),
          (e.generateMipmaps =
            !e.isCompressedTexture && e.minFilter !== ve && e.minFilter !== xe),
          i.associations.set(e, { textures: t }),
          e
        )
      })
      .catch(function () {
        return null
      })
    return (this.textureCache[o] = l), l
  }
  loadImageSource(t, n) {
    const i = this,
      s = this.json,
      r = this.options
    if (void 0 !== this.sourceCache[t])
      return this.sourceCache[t].then((t) => t.clone())
    const a = s.images[t],
      o = self.URL || self.webkitURL
    let l = a.uri || '',
      c = !1
    if (void 0 !== a.bufferView)
      l = i.getDependency('bufferView', a.bufferView).then(function (t) {
        c = !0
        const e = new Blob([t], { type: a.mimeType })
        return (l = o.createObjectURL(e)), l
      })
    else if (void 0 === a.uri)
      throw new Error(
        'THREE.GLTFLoader: Image ' + t + ' is missing URI and bufferView'
      )
    const h = Promise.resolve(l)
      .then(function (t) {
        return new Promise(function (i, s) {
          let a = i
          !0 === n.isImageBitmapLoader &&
            (a = e(function (t) {
              const e = new Wi(t)
              ;(e.needsUpdate = !0), i(e)
            }, 'onLoad')),
            n.load(Am.resolveURL(t, r.path), a, void 0, s)
        })
      })
      .then(function (t) {
        return (
          !0 === c && o.revokeObjectURL(l),
          Uv(t, a),
          (t.userData.mimeType = a.mimeType || Hv(a.uri)),
          t
        )
      })
      .catch(function (t) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), t)
      })
    return (this.sourceCache[t] = h), h
  }
  assignTexture(t, e, n, i) {
    const s = this
    return this.getDependency('texture', n.index).then(function (r) {
      if (!r) return null
      if (
        (void 0 !== n.texCoord &&
          n.texCoord > 0 &&
          ((r = r.clone()).channel = n.texCoord),
        s.extensions[Yg.KHR_TEXTURE_TRANSFORM])
      ) {
        const t =
          void 0 !== n.extensions
            ? n.extensions[Yg.KHR_TEXTURE_TRANSFORM]
            : void 0
        if (t) {
          const e = s.associations.get(r)
          ;(r = s.extensions[Yg.KHR_TEXTURE_TRANSFORM].extendTexture(r, t)),
            s.associations.set(r, e)
        }
      }
      return void 0 !== i && (r.colorSpace = i), (t[e] = r), r
    })
  }
  assignFinalMaterial(t) {
    const e = t.geometry
    let n = t.material
    const i = void 0 === e.attributes.tangent,
      s = void 0 !== e.attributes.color,
      r = void 0 === e.attributes.normal
    if (t.isPoints) {
      const t = 'PointsMaterial:' + n.uuid
      let e = this.cache.get(t)
      e ||
        ((e = new yu()),
        Sr.prototype.copy.call(e, n),
        e.color.copy(n.color),
        (e.map = n.map),
        (e.sizeAttenuation = !1),
        this.cache.add(t, e)),
        (n = e)
    } else if (t.isLine) {
      const t = 'LineBasicMaterial:' + n.uuid
      let e = this.cache.get(t)
      e ||
        ((e = new su()),
        Sr.prototype.copy.call(e, n),
        e.color.copy(n.color),
        (e.map = n.map),
        this.cache.add(t, e)),
        (n = e)
    }
    if (i || s || r) {
      let t = 'ClonedMaterial:' + n.uuid + ':'
      i && (t += 'derivative-tangents:'),
        s && (t += 'vertex-colors:'),
        r && (t += 'flat-shading:')
      let e = this.cache.get(t)
      e ||
        ((e = n.clone()),
        s && (e.vertexColors = !0),
        r && (e.flatShading = !0),
        i &&
          (e.normalScale && (e.normalScale.y *= -1),
          e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
        this.cache.add(t, e),
        this.associations.set(e, this.associations.get(n))),
        (n = e)
    }
    t.material = n
  }
  getMaterialType() {
    return yp
  }
  loadMaterial(t) {
    const e = this,
      n = this.json,
      i = this.extensions,
      s = n.materials[t]
    let r
    const a = {},
      o = []
    if ((s.extensions || {})[Yg.KHR_MATERIALS_UNLIT]) {
      const t = i[Yg.KHR_MATERIALS_UNLIT]
      ;(r = t.getMaterialType()), o.push(t.extendParams(a, s, e))
    } else {
      const n = s.pbrMetallicRoughness || {}
      if (
        ((a.color = new br(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(n.baseColorFactor))
      ) {
        const t = n.baseColorFactor
        a.color.setRGB(t[0], t[1], t[2], An), (a.opacity = t[3])
      }
      void 0 !== n.baseColorTexture &&
        o.push(e.assignTexture(a, 'map', n.baseColorTexture, En)),
        (a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1),
        (a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
        void 0 !== n.metallicRoughnessTexture &&
          (o.push(
            e.assignTexture(a, 'metalnessMap', n.metallicRoughnessTexture)
          ),
          o.push(
            e.assignTexture(a, 'roughnessMap', n.metallicRoughnessTexture)
          )),
        (r = this._invokeOne(function (e) {
          return e.getMaterialType && e.getMaterialType(t)
        })),
        o.push(
          Promise.all(
            this._invokeAll(function (e) {
              return e.extendMaterialParams && e.extendMaterialParams(t, a)
            })
          )
        )
    }
    !0 === s.doubleSided && (a.side = 2)
    const l = s.alphaMode || Iv
    if (
      (l === Dv
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          l === Lv &&
            (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
      void 0 !== s.normalTexture &&
        r !== Tr &&
        (o.push(e.assignTexture(a, 'normalMap', s.normalTexture)),
        (a.normalScale = new vi(1, 1)),
        void 0 !== s.normalTexture.scale))
    ) {
      const t = s.normalTexture.scale
      a.normalScale.set(t, t)
    }
    if (
      (void 0 !== s.occlusionTexture &&
        r !== Tr &&
        (o.push(e.assignTexture(a, 'aoMap', s.occlusionTexture)),
        void 0 !== s.occlusionTexture.strength &&
          (a.aoMapIntensity = s.occlusionTexture.strength)),
      void 0 !== s.emissiveFactor && r !== Tr)
    ) {
      const t = s.emissiveFactor
      a.emissive = new br().setRGB(t[0], t[1], t[2], An)
    }
    return (
      void 0 !== s.emissiveTexture &&
        r !== Tr &&
        o.push(e.assignTexture(a, 'emissiveMap', s.emissiveTexture, En)),
      Promise.all(o).then(function () {
        const n = new r(a)
        return (
          s.name && (n.name = s.name),
          Uv(n, s),
          e.associations.set(n, { materials: t }),
          s.extensions && Nv(i, n, s),
          n
        )
      })
    )
  }
  createUniqueName(t) {
    const e = uf.sanitizeNodeName(t || '')
    return e in this.nodeNamesUsed
      ? e + '_' + ++this.nodeNamesUsed[e]
      : ((this.nodeNamesUsed[e] = 0), e)
  }
  loadGeometries(t) {
    const n = this,
      i = this.extensions,
      s = this.primitiveCache
    function r(t) {
      return i[Yg.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(t, n)
        .then(function (e) {
          return Xv(e, t, n)
        })
    }
    e(r, 'createDracoPrimitive')
    const a = []
    for (let e = 0, o = t.length; e < o; e++) {
      const i = t[e],
        o = Fv(i),
        l = s[o]
      if (l) a.push(l.promise)
      else {
        let t
        ;(t =
          i.extensions && i.extensions[Yg.KHR_DRACO_MESH_COMPRESSION]
            ? r(i)
            : Xv(new Zr(), i, n)),
          (s[o] = { primitive: i, promise: t }),
          a.push(t)
      }
    }
    return Promise.all(a)
  }
  loadMesh(t) {
    const e = this,
      n = this.json,
      i = this.extensions,
      s = n.meshes[t],
      r = s.primitives,
      a = []
    for (let o = 0, l = r.length; o < l; o++) {
      const t =
        void 0 === r[o].material
          ? kv(this.cache)
          : this.getDependency('material', r[o].material)
      a.push(t)
    }
    return (
      a.push(e.loadGeometries(r)),
      Promise.all(a).then(function (n) {
        const a = n.slice(0, n.length - 1),
          o = n[n.length - 1],
          l = []
        for (let h = 0, u = o.length; h < u; h++) {
          const n = o[h],
            c = r[h]
          let u
          const d = a[h]
          if (
            c.mode === Mv.TRIANGLES ||
            c.mode === Mv.TRIANGLE_STRIP ||
            c.mode === Mv.TRIANGLE_FAN ||
            void 0 === c.mode
          )
            (u = !0 === s.isSkinnedMesh ? new Th(n, d) : new oa(n, d)),
              !0 === u.isSkinnedMesh && u.normalizeSkinWeights(),
              c.mode === Mv.TRIANGLE_STRIP
                ? (u.geometry = jg(u.geometry, 1))
                : c.mode === Mv.TRIANGLE_FAN && (u.geometry = jg(u.geometry, 2))
          else if (c.mode === Mv.LINES) u = new gu(n, d)
          else if (c.mode === Mv.LINE_STRIP) u = new du(n, d)
          else if (c.mode === Mv.LINE_LOOP) u = new vu(n, d)
          else {
            if (c.mode !== Mv.POINTS)
              throw new Error(
                'THREE.GLTFLoader: Primitive mode unsupported: ' + c.mode
              )
            u = new Mu(n, d)
          }
          Object.keys(u.geometry.morphAttributes).length > 0 && Ov(u, s),
            (u.name = e.createUniqueName(s.name || 'mesh_' + t)),
            Uv(u, s),
            c.extensions && Nv(i, u, c),
            e.assignFinalMaterial(u),
            l.push(u)
        }
        for (let i = 0, s = l.length; i < s; i++)
          e.associations.set(l[i], { meshes: t, primitives: i })
        if (1 === l.length) return s.extensions && Nv(i, l[0], s), l[0]
        const c = new Nc()
        s.extensions && Nv(i, c, s), e.associations.set(c, { meshes: t })
        for (let t = 0, e = l.length; t < e; t++) c.add(l[t])
        return c
      })
    )
  }
  loadCamera(t) {
    let e
    const n = this.json.cameras[t],
      i = n[n.type]
    if (i)
      return (
        'perspective' === n.type
          ? (e = new ba(
              gi.radToDeg(i.yfov),
              i.aspectRatio || 1,
              i.znear || 1,
              i.zfar || 2e6
            ))
          : 'orthographic' === n.type &&
            (e = new Ya(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
        n.name && (e.name = this.createUniqueName(n.name)),
        Uv(e, n),
        Promise.resolve(e)
      )
    console.warn('THREE.GLTFLoader: Missing camera parameters.')
  }
  loadSkin(t) {
    const e = this.json.skins[t],
      n = []
    for (let i = 0, s = e.joints.length; i < s; i++)
      n.push(this._loadNodeShallow(e.joints[i]))
    return (
      void 0 !== e.inverseBindMatrices
        ? n.push(this.getDependency('accessor', e.inverseBindMatrices))
        : n.push(null),
      Promise.all(n).then(function (t) {
        const n = t.pop(),
          i = t,
          s = [],
          r = []
        for (let a = 0, o = i.length; a < o; a++) {
          const t = i[a]
          if (t) {
            s.push(t)
            const e = new Rs()
            null !== n && e.fromArray(n.array, 16 * a), r.push(e)
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              e.joints[a]
            )
        }
        return new Ph(s, r)
      })
    )
  }
  loadAnimation(t) {
    const e = this.json,
      n = this,
      i = e.animations[t],
      s = i.name ? i.name : 'animation_' + t,
      r = [],
      a = [],
      o = [],
      l = [],
      c = []
    for (let h = 0, u = i.channels.length; h < u; h++) {
      const t = i.channels[h],
        e = i.samplers[t.sampler],
        n = t.target,
        s = n.node,
        u = void 0 !== i.parameters ? i.parameters[e.input] : e.input,
        d = void 0 !== i.parameters ? i.parameters[e.output] : e.output
      void 0 !== n.node &&
        (r.push(this.getDependency('node', s)),
        a.push(this.getDependency('accessor', u)),
        o.push(this.getDependency('accessor', d)),
        l.push(e),
        c.push(n))
    }
    return Promise.all([
      Promise.all(r),
      Promise.all(a),
      Promise.all(o),
      Promise.all(l),
      Promise.all(c)
    ]).then(function (t) {
      const e = t[0],
        i = t[1],
        r = t[2],
        a = t[3],
        o = t[4],
        l = []
      for (let s = 0, c = e.length; s < c; s++) {
        const t = e[s],
          c = i[s],
          h = r[s],
          u = a[s],
          d = o[s]
        if (void 0 === t) continue
        t.updateMatrix && t.updateMatrix()
        const p = n._createAnimationTracks(t, c, h, u, d)
        if (p) for (let e = 0; e < p.length; e++) l.push(p[e])
      }
      return new jp(s, void 0, l)
    })
  }
  createNodeMesh(t) {
    const e = this.json,
      n = this,
      i = e.nodes[t]
    return void 0 === i.mesh
      ? null
      : n.getDependency('mesh', i.mesh).then(function (t) {
          const e = n._getNodeRef(n.meshCache, i.mesh, t)
          return (
            void 0 !== i.weights &&
              e.traverse(function (t) {
                if (t.isMesh)
                  for (let e = 0, n = i.weights.length; e < n; e++)
                    t.morphTargetInfluences[e] = i.weights[e]
              }),
            e
          )
        })
  }
  loadNode(t) {
    const e = this,
      n = this.json.nodes[t],
      i = e._loadNodeShallow(t),
      s = [],
      r = n.children || []
    for (let o = 0, l = r.length; o < l; o++)
      s.push(e.getDependency('node', r[o]))
    const a =
      void 0 === n.skin
        ? Promise.resolve(null)
        : e.getDependency('skin', n.skin)
    return Promise.all([i, Promise.all(s), a]).then(function (t) {
      const e = t[0],
        n = t[1],
        i = t[2]
      null !== i &&
        e.traverse(function (t) {
          t.isSkinnedMesh && t.bind(i, Gv)
        })
      for (let s = 0, r = n.length; s < r; s++) e.add(n[s])
      return e
    })
  }
  _loadNodeShallow(t) {
    const e = this.json,
      n = this.extensions,
      i = this
    if (void 0 !== this.nodeCache[t]) return this.nodeCache[t]
    const s = e.nodes[t],
      r = s.name ? i.createUniqueName(s.name) : '',
      a = [],
      o = i._invokeOne(function (e) {
        return e.createNodeMesh && e.createNodeMesh(t)
      })
    return (
      o && a.push(o),
      void 0 !== s.camera &&
        a.push(
          i.getDependency('camera', s.camera).then(function (t) {
            return i._getNodeRef(i.cameraCache, s.camera, t)
          })
        ),
      i
        ._invokeAll(function (e) {
          return e.createNodeAttachment && e.createNodeAttachment(t)
        })
        .forEach(function (t) {
          a.push(t)
        }),
      (this.nodeCache[t] = Promise.all(a).then(function (e) {
        let a
        if (
          ((a =
            !0 === s.isBone
              ? new Eh()
              : e.length > 1
                ? new Nc()
                : 1 === e.length
                  ? e[0]
                  : new nr()),
          a !== e[0])
        )
          for (let t = 0, n = e.length; t < n; t++) a.add(e[t])
        if (
          (s.name && ((a.userData.name = s.name), (a.name = r)),
          Uv(a, s),
          s.extensions && Nv(n, a, s),
          void 0 !== s.matrix)
        ) {
          const t = new Rs()
          t.fromArray(s.matrix), a.applyMatrix4(t)
        } else
          void 0 !== s.translation && a.position.fromArray(s.translation),
            void 0 !== s.rotation && a.quaternion.fromArray(s.rotation),
            void 0 !== s.scale && a.scale.fromArray(s.scale)
        return (
          i.associations.has(a) || i.associations.set(a, {}),
          (i.associations.get(a).nodes = t),
          a
        )
      })),
      this.nodeCache[t]
    )
  }
  loadScene(t) {
    const n = this.extensions,
      i = this.json.scenes[t],
      s = this,
      r = new Nc()
    i.name && (r.name = s.createUniqueName(i.name)),
      Uv(r, i),
      i.extensions && Nv(n, r, i)
    const a = i.nodes || [],
      o = []
    for (let e = 0, l = a.length; e < l; e++)
      o.push(s.getDependency('node', a[e]))
    return Promise.all(o).then(function (t) {
      for (let e = 0, i = t.length; e < i; e++) r.add(t[e])
      const n = e((t) => {
        const e = new Map()
        for (const [n, i] of s.associations)
          (n instanceof Sr || n instanceof Wi) && e.set(n, i)
        return (
          t.traverse((t) => {
            const n = s.associations.get(t)
            null != n && e.set(t, n)
          }),
          e
        )
      }, 'reduceAssociations')
      return (s.associations = n(r)), r
    })
  }
  _createAnimationTracks(t, e, n, i, s) {
    const r = [],
      a = t.name ? t.name : t.uuid,
      o = []
    let l
    switch (
      (Rv[s.path] === Rv.weights
        ? t.traverse(function (t) {
            t.morphTargetInfluences && o.push(t.name ? t.name : t.uuid)
          })
        : o.push(a),
      Rv[s.path])
    ) {
      case Rv.weights:
        l = zp
        break
      case Rv.rotation:
        l = Hp
        break
      case Rv.position:
      case Rv.scale:
        l = Wp
        break
      default:
        if (1 === n.itemSize) l = zp
        else l = Wp
    }
    const c = void 0 !== i.interpolation ? Pv[i.interpolation] : yn,
      h = this._getArrayFromAccessor(n)
    for (let u = 0, d = o.length; u < d; u++) {
      const t = new l(o[u] + '.' + Rv[s.path], e.array, h, c)
      'CUBICSPLINE' === i.interpolation &&
        this._createCubicSplineTrackInterpolant(t),
        r.push(t)
    }
    return r
  }
  _getArrayFromAccessor(t) {
    let e = t.array
    if (t.normalized) {
      const t = Vv(e.constructor),
        n = new Float32Array(e.length)
      for (let i = 0, s = e.length; i < s; i++) n[i] = e[i] * t
      e = n
    }
    return e
  }
  _createCubicSplineTrackInterpolant(t) {
    ;(t.createInterpolant = e(function (t) {
      return new (this instanceof Hp ? wv : xv)(
        this.times,
        this.values,
        this.getValueSize() / 3,
        t
      )
    }, 'InterpolantFactoryMethodGLTFCubicSpline')),
      (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0)
  }
}
function jv(t, e, n) {
  const i = e.attributes,
    s = new ns()
  if (void 0 === i.POSITION) return
  {
    const t = n.json.accessors[i.POSITION],
      e = t.min,
      r = t.max
    if (void 0 === e || void 0 === r)
      return void console.warn(
        'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.'
      )
    if (
      (s.set(new Qi(e[0], e[1], e[2]), new Qi(r[0], r[1], r[2])), t.normalized)
    ) {
      const e = Vv(Sv[t.componentType])
      s.min.multiplyScalar(e), s.max.multiplyScalar(e)
    }
  }
  const r = e.targets
  if (void 0 !== r) {
    const t = new Qi(),
      e = new Qi()
    for (let i = 0, s = r.length; i < s; i++) {
      const s = r[i]
      if (void 0 !== s.POSITION) {
        const i = n.json.accessors[s.POSITION],
          r = i.min,
          a = i.max
        if (void 0 !== r && void 0 !== a) {
          if (
            (e.setX(Math.max(Math.abs(r[0]), Math.abs(a[0]))),
            e.setY(Math.max(Math.abs(r[1]), Math.abs(a[1]))),
            e.setZ(Math.max(Math.abs(r[2]), Math.abs(a[2]))),
            i.normalized)
          ) {
            const t = Vv(Sv[i.componentType])
            e.multiplyScalar(t)
          }
          t.max(e)
        } else
          console.warn(
            'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.'
          )
      }
    }
    s.expandByVector(t)
  }
  t.boundingBox = s
  const a = new xs()
  s.getCenter(a.center),
    (a.radius = s.min.distanceTo(s.max) / 2),
    (t.boundingSphere = a)
}
function Xv(t, n, i) {
  const s = n.attributes,
    r = []
  function a(e, n) {
    return i.getDependency('accessor', e).then(function (e) {
      t.setAttribute(n, e)
    })
  }
  e(a, 'assignAttributeAccessor')
  for (const e in s) {
    const n = Cv[e] || e.toLowerCase()
    n in t.attributes || r.push(a(s[e], n))
  }
  if (void 0 !== n.indices && !t.index) {
    const e = i.getDependency('accessor', n.indices).then(function (e) {
      t.setIndex(e)
    })
    r.push(e)
  }
  return (
    Pi.workingColorSpace !== An &&
      'COLOR_0' in s &&
      console.warn(
        `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Pi.workingColorSpace}" not supported.`
      ),
    Uv(t, n),
    jv(t, n, i),
    Promise.all(r).then(function () {
      return void 0 !== n.targets ? Bv(t, n.targets, i) : t
    })
  )
}
e(jv, 'computeBounds'), e(Xv, 'addPrimitiveAttributes')
const qv = /^[og]\s*(.+)?/,
  Yv = /^mtllib /,
  Zv = /^usemtl /,
  Kv = /^usemap /,
  $v = /\s+/,
  Jv = new Qi(),
  Qv = new Qi(),
  ty = new Qi(),
  ey = new Qi(),
  ny = new Qi(),
  iy = new br()
function sy() {
  const t = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: e(function (t, n) {
      if (this.object && !1 === this.object.fromDeclaration)
        return (
          (this.object.name = t), void (this.object.fromDeclaration = !1 !== n)
        )
      const i =
        this.object && 'function' == typeof this.object.currentMaterial
          ? this.object.currentMaterial()
          : void 0
      if (
        (this.object &&
          'function' == typeof this.object._finalize &&
          this.object._finalize(!0),
        (this.object = {
          name: t || '',
          fromDeclaration: !1 !== n,
          geometry: {
            vertices: [],
            normals: [],
            colors: [],
            uvs: [],
            hasUVIndices: !1
          },
          materials: [],
          smooth: !0,
          startMaterial: e(function (t, n) {
            const i = this._finalize(!1)
            i &&
              (i.inherited || i.groupCount <= 0) &&
              this.materials.splice(i.index, 1)
            const s = {
              index: this.materials.length,
              name: t || '',
              mtllib: Array.isArray(n) && n.length > 0 ? n[n.length - 1] : '',
              smooth: void 0 !== i ? i.smooth : this.smooth,
              groupStart: void 0 !== i ? i.groupEnd : 0,
              groupEnd: -1,
              groupCount: -1,
              inherited: !1,
              clone: e(function (t) {
                const e = {
                  index: 'number' == typeof t ? t : this.index,
                  name: this.name,
                  mtllib: this.mtllib,
                  smooth: this.smooth,
                  groupStart: 0,
                  groupEnd: -1,
                  groupCount: -1,
                  inherited: !1
                }
                return (e.clone = this.clone.bind(e)), e
              }, 'clone')
            }
            return this.materials.push(s), s
          }, 'startMaterial'),
          currentMaterial: e(function () {
            if (this.materials.length > 0)
              return this.materials[this.materials.length - 1]
          }, 'currentMaterial'),
          _finalize: e(function (t) {
            const e = this.currentMaterial()
            if (
              (e &&
                -1 === e.groupEnd &&
                ((e.groupEnd = this.geometry.vertices.length / 3),
                (e.groupCount = e.groupEnd - e.groupStart),
                (e.inherited = !1)),
              t && this.materials.length > 1)
            )
              for (let n = this.materials.length - 1; n >= 0; n--)
                this.materials[n].groupCount <= 0 && this.materials.splice(n, 1)
            return (
              t &&
                0 === this.materials.length &&
                this.materials.push({ name: '', smooth: this.smooth }),
              e
            )
          }, '_finalize')
        }),
        i && i.name && 'function' == typeof i.clone)
      ) {
        const t = i.clone(0)
        ;(t.inherited = !0), this.object.materials.push(t)
      }
      this.objects.push(this.object)
    }, 'startObject'),
    finalize: e(function () {
      this.object &&
        'function' == typeof this.object._finalize &&
        this.object._finalize(!0)
    }, 'finalize'),
    parseVertexIndex: e(function (t, e) {
      const n = parseInt(t, 10)
      return 3 * (n >= 0 ? n - 1 : n + e / 3)
    }, 'parseVertexIndex'),
    parseNormalIndex: e(function (t, e) {
      const n = parseInt(t, 10)
      return 3 * (n >= 0 ? n - 1 : n + e / 3)
    }, 'parseNormalIndex'),
    parseUVIndex: e(function (t, e) {
      const n = parseInt(t, 10)
      return 2 * (n >= 0 ? n - 1 : n + e / 2)
    }, 'parseUVIndex'),
    addVertex: e(function (t, e, n) {
      const i = this.vertices,
        s = this.object.geometry.vertices
      s.push(i[t + 0], i[t + 1], i[t + 2]),
        s.push(i[e + 0], i[e + 1], i[e + 2]),
        s.push(i[n + 0], i[n + 1], i[n + 2])
    }, 'addVertex'),
    addVertexPoint: e(function (t) {
      const e = this.vertices
      this.object.geometry.vertices.push(e[t + 0], e[t + 1], e[t + 2])
    }, 'addVertexPoint'),
    addVertexLine: e(function (t) {
      const e = this.vertices
      this.object.geometry.vertices.push(e[t + 0], e[t + 1], e[t + 2])
    }, 'addVertexLine'),
    addNormal: e(function (t, e, n) {
      const i = this.normals,
        s = this.object.geometry.normals
      s.push(i[t + 0], i[t + 1], i[t + 2]),
        s.push(i[e + 0], i[e + 1], i[e + 2]),
        s.push(i[n + 0], i[n + 1], i[n + 2])
    }, 'addNormal'),
    addFaceNormal: e(function (t, e, n) {
      const i = this.vertices,
        s = this.object.geometry.normals
      Jv.fromArray(i, t),
        Qv.fromArray(i, e),
        ty.fromArray(i, n),
        ny.subVectors(ty, Qv),
        ey.subVectors(Jv, Qv),
        ny.cross(ey),
        ny.normalize(),
        s.push(ny.x, ny.y, ny.z),
        s.push(ny.x, ny.y, ny.z),
        s.push(ny.x, ny.y, ny.z)
    }, 'addFaceNormal'),
    addColor: e(function (t, e, n) {
      const i = this.colors,
        s = this.object.geometry.colors
      void 0 !== i[t] && s.push(i[t + 0], i[t + 1], i[t + 2]),
        void 0 !== i[e] && s.push(i[e + 0], i[e + 1], i[e + 2]),
        void 0 !== i[n] && s.push(i[n + 0], i[n + 1], i[n + 2])
    }, 'addColor'),
    addUV: e(function (t, e, n) {
      const i = this.uvs,
        s = this.object.geometry.uvs
      s.push(i[t + 0], i[t + 1]),
        s.push(i[e + 0], i[e + 1]),
        s.push(i[n + 0], i[n + 1])
    }, 'addUV'),
    addDefaultUV: e(function () {
      const t = this.object.geometry.uvs
      t.push(0, 0), t.push(0, 0), t.push(0, 0)
    }, 'addDefaultUV'),
    addUVLine: e(function (t) {
      const e = this.uvs
      this.object.geometry.uvs.push(e[t + 0], e[t + 1])
    }, 'addUVLine'),
    addFace: e(function (t, e, n, i, s, r, a, o, l) {
      const c = this.vertices.length
      let h = this.parseVertexIndex(t, c),
        u = this.parseVertexIndex(e, c),
        d = this.parseVertexIndex(n, c)
      if (
        (this.addVertex(h, u, d),
        this.addColor(h, u, d),
        void 0 !== a && '' !== a)
      ) {
        const t = this.normals.length
        ;(h = this.parseNormalIndex(a, t)),
          (u = this.parseNormalIndex(o, t)),
          (d = this.parseNormalIndex(l, t)),
          this.addNormal(h, u, d)
      } else this.addFaceNormal(h, u, d)
      if (void 0 !== i && '' !== i) {
        const t = this.uvs.length
        ;(h = this.parseUVIndex(i, t)),
          (u = this.parseUVIndex(s, t)),
          (d = this.parseUVIndex(r, t)),
          this.addUV(h, u, d),
          (this.object.geometry.hasUVIndices = !0)
      } else this.addDefaultUV()
    }, 'addFace'),
    addPointGeometry: e(function (t) {
      this.object.geometry.type = 'Points'
      const e = this.vertices.length
      for (let n = 0, i = t.length; n < i; n++) {
        const i = this.parseVertexIndex(t[n], e)
        this.addVertexPoint(i), this.addColor(i)
      }
    }, 'addPointGeometry'),
    addLineGeometry: e(function (t, e) {
      this.object.geometry.type = 'Line'
      const n = this.vertices.length,
        i = this.uvs.length
      for (let s = 0, r = t.length; s < r; s++)
        this.addVertexLine(this.parseVertexIndex(t[s], n))
      for (let s = 0, r = e.length; s < r; s++)
        this.addUVLine(this.parseUVIndex(e[s], i))
    }, 'addLineGeometry')
  }
  return t.startObject('', !1), t
}
e(sy, 'ParserState')
class ry extends $p {
  static {
    e(this, 'OBJLoader')
  }
  constructor(t) {
    super(t), (this.materials = null)
  }
  load(t, e, n, i) {
    const s = this,
      r = new tm(this.manager)
    r.setPath(this.path),
      r.setRequestHeader(this.requestHeader),
      r.setWithCredentials(this.withCredentials),
      r.load(
        t,
        function (n) {
          try {
            e(s.parse(n))
          } catch (r) {
            i ? i(r) : console.error(r), s.manager.itemError(t)
          }
        },
        n,
        i
      )
  }
  setMaterials(t) {
    return (this.materials = t), this
  }
  parse(t) {
    const e = new sy()
    ;-1 !== t.indexOf('\r\n') && (t = t.replace(/\r\n/g, '\n')),
      -1 !== t.indexOf('\\\n') && (t = t.replace(/\\\n/g, ''))
    const n = t.split('\n')
    let i = []
    for (let r = 0, a = n.length; r < a; r++) {
      const t = n[r].trimStart()
      if (0 === t.length) continue
      const s = t.charAt(0)
      if ('#' !== s)
        if ('v' === s) {
          const n = t.split($v)
          switch (n[0]) {
            case 'v':
              e.vertices.push(
                parseFloat(n[1]),
                parseFloat(n[2]),
                parseFloat(n[3])
              ),
                n.length >= 7
                  ? (iy.setRGB(
                      parseFloat(n[4]),
                      parseFloat(n[5]),
                      parseFloat(n[6]),
                      En
                    ),
                    e.colors.push(iy.r, iy.g, iy.b))
                  : e.colors.push(void 0, void 0, void 0)
              break
            case 'vn':
              e.normals.push(
                parseFloat(n[1]),
                parseFloat(n[2]),
                parseFloat(n[3])
              )
              break
            case 'vt':
              e.uvs.push(parseFloat(n[1]), parseFloat(n[2]))
          }
        } else if ('f' === s) {
          const n = t.slice(1).trim().split($v),
            i = []
          for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t]
            if (e.length > 0) {
              const t = e.split('/')
              i.push(t)
            }
          }
          const s = i[0]
          for (let t = 1, r = i.length - 1; t < r; t++) {
            const n = i[t],
              r = i[t + 1]
            e.addFace(s[0], n[0], r[0], s[1], n[1], r[1], s[2], n[2], r[2])
          }
        } else if ('l' === s) {
          const n = t.substring(1).trim().split(' ')
          let i = []
          const s = []
          if (-1 === t.indexOf('/')) i = n
          else
            for (let t = 0, e = n.length; t < e; t++) {
              const e = n[t].split('/')
              '' !== e[0] && i.push(e[0]), '' !== e[1] && s.push(e[1])
            }
          e.addLineGeometry(i, s)
        } else if ('p' === s) {
          const n = t.slice(1).trim().split(' ')
          e.addPointGeometry(n)
        } else if (null !== (i = qv.exec(t))) {
          const t = (' ' + i[0].slice(1).trim()).slice(1)
          e.startObject(t)
        } else if (Zv.test(t))
          e.object.startMaterial(t.substring(7).trim(), e.materialLibraries)
        else if (Yv.test(t)) e.materialLibraries.push(t.substring(7).trim())
        else if (Kv.test(t))
          console.warn(
            'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.'
          )
        else if ('s' === s) {
          if (((i = t.split(' ')), i.length > 1)) {
            const t = i[1].trim().toLowerCase()
            e.object.smooth = '0' !== t && 'off' !== t
          } else e.object.smooth = !0
          const n = e.object.currentMaterial()
          n && (n.smooth = e.object.smooth)
        } else {
          if ('\0' === t) continue
          console.warn('THREE.OBJLoader: Unexpected line: "' + t + '"')
        }
    }
    e.finalize()
    const s = new Nc()
    s.materialLibraries = [].concat(e.materialLibraries)
    if (
      !0 ===
      !(1 === e.objects.length && 0 === e.objects[0].geometry.vertices.length)
    )
      for (let r = 0, a = e.objects.length; r < a; r++) {
        const t = e.objects[r],
          n = t.geometry,
          i = t.materials,
          a = 'Line' === n.type,
          o = 'Points' === n.type
        let l = !1
        if (0 === n.vertices.length) continue
        const c = new Zr()
        c.setAttribute('position', new Vr(n.vertices, 3)),
          n.normals.length > 0 &&
            c.setAttribute('normal', new Vr(n.normals, 3)),
          n.colors.length > 0 &&
            ((l = !0), c.setAttribute('color', new Vr(n.colors, 3))),
          !0 === n.hasUVIndices && c.setAttribute('uv', new Vr(n.uvs, 2))
        const h = []
        for (let s = 0, r = i.length; s < r; s++) {
          const t = i[s],
            n = t.name + '_' + t.smooth + '_' + l
          let r = e.materials[n]
          if (null !== this.materials)
            if (
              ((r = this.materials.create(t.name)), !a || !r || r instanceof su)
            ) {
              if (o && r && !(r instanceof yu)) {
                const t = new yu({ size: 10, sizeAttenuation: !1 })
                Sr.prototype.copy.call(t, r),
                  t.color.copy(r.color),
                  (t.map = r.map),
                  (r = t)
              }
            } else {
              const t = new su()
              Sr.prototype.copy.call(t, r), t.color.copy(r.color), (r = t)
            }
          void 0 === r &&
            ((r = a
              ? new su()
              : o
                ? new yu({ size: 1, sizeAttenuation: !1 })
                : new xp()),
            (r.name = t.name),
            (r.flatShading = !t.smooth),
            (r.vertexColors = l),
            (e.materials[n] = r)),
            h.push(r)
        }
        let u
        if (h.length > 1) {
          for (let t = 0, e = i.length; t < e; t++) {
            const e = i[t]
            c.addGroup(e.groupStart, e.groupCount, t)
          }
          u = a ? new gu(c, h) : o ? new Mu(c, h) : new oa(c, h)
        } else u = a ? new gu(c, h[0]) : o ? new Mu(c, h[0]) : new oa(c, h[0])
        ;(u.name = t.name), s.add(u)
      }
    else if (e.vertices.length > 0) {
      const t = new yu({ size: 1, sizeAttenuation: !1 }),
        n = new Zr()
      n.setAttribute('position', new Vr(e.vertices, 3)),
        e.colors.length > 0 &&
          void 0 !== e.colors[0] &&
          (n.setAttribute('color', new Vr(e.colors, 3)), (t.vertexColors = !0))
      const i = new Mu(n, t)
      s.add(i)
    }
    return s
  }
}
class ay extends $p {
  static {
    e(this, 'MTLLoader')
  }
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    const s = this,
      r = '' === this.path ? Am.extractUrlBase(t) : this.path,
      a = new tm(this.manager)
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        t,
        function (n) {
          try {
            e(s.parse(n, r))
          } catch (a) {
            i ? i(a) : console.error(a), s.manager.itemError(t)
          }
        },
        n,
        i
      )
  }
  setMaterialOptions(t) {
    return (this.materialOptions = t), this
  }
  parse(t, e) {
    const n = t.split('\n')
    let i = {}
    const s = /\s+/,
      r = {}
    for (let o = 0; o < n.length; o++) {
      let t = n[o]
      if (((t = t.trim()), 0 === t.length || '#' === t.charAt(0))) continue
      const e = t.indexOf(' ')
      let a = e >= 0 ? t.substring(0, e) : t
      a = a.toLowerCase()
      let l = e >= 0 ? t.substring(e + 1) : ''
      if (((l = l.trim()), 'newmtl' === a)) (i = { name: l }), (r[l] = i)
      else if ('ka' === a || 'kd' === a || 'ks' === a || 'ke' === a) {
        const t = l.split(s, 3)
        i[a] = [parseFloat(t[0]), parseFloat(t[1]), parseFloat(t[2])]
      } else i[a] = l
    }
    const a = new oy(this.resourcePath || e, this.materialOptions)
    return (
      a.setCrossOrigin(this.crossOrigin),
      a.setManager(this.manager),
      a.setMaterials(r),
      a
    )
  }
}
class oy {
  static {
    e(this, 'MaterialCreator')
  }
  constructor(t = '', e = {}) {
    ;(this.baseUrl = t),
      (this.options = e),
      (this.materialsInfo = {}),
      (this.materials = {}),
      (this.materialsArray = []),
      (this.nameLookup = {}),
      (this.crossOrigin = 'anonymous'),
      (this.side = void 0 !== this.options.side ? this.options.side : 0),
      (this.wrap = void 0 !== this.options.wrap ? this.options.wrap : me)
  }
  setCrossOrigin(t) {
    return (this.crossOrigin = t), this
  }
  setManager(t) {
    this.manager = t
  }
  setMaterials(t) {
    ;(this.materialsInfo = this.convert(t)),
      (this.materials = {}),
      (this.materialsArray = []),
      (this.nameLookup = {})
  }
  convert(t) {
    if (!this.options) return t
    const e = {}
    for (const n in t) {
      const i = t[n],
        s = {}
      e[n] = s
      for (const t in i) {
        let e = !0,
          n = i[t]
        const r = t.toLowerCase()
        switch (r) {
          case 'kd':
          case 'ka':
          case 'ks':
            this.options &&
              this.options.normalizeRGB &&
              (n = [n[0] / 255, n[1] / 255, n[2] / 255]),
              this.options &&
                this.options.ignoreZeroRGBs &&
                0 === n[0] &&
                0 === n[1] &&
                0 === n[2] &&
                (e = !1)
        }
        e && (s[r] = n)
      }
    }
    return e
  }
  preload() {
    for (const t in this.materialsInfo) this.create(t)
  }
  getIndex(t) {
    return this.nameLookup[t]
  }
  getAsArray() {
    let t = 0
    for (const e in this.materialsInfo)
      (this.materialsArray[t] = this.create(e)), (this.nameLookup[e] = t), t++
    return this.materialsArray
  }
  create(t) {
    return (
      void 0 === this.materials[t] && this.createMaterial_(t), this.materials[t]
    )
  }
  createMaterial_(t) {
    const n = this,
      i = this.materialsInfo[t],
      s = { name: t, side: this.side }
    function r(t, e) {
      return 'string' != typeof e || '' === e
        ? ''
        : /^https?:\/\//i.test(e)
          ? e
          : t + e
    }
    function a(t, e) {
      if (s[t]) return
      const i = n.getTextureParams(e, s),
        a = n.loadTexture(r(n.baseUrl, i.url))
      a.repeat.copy(i.scale),
        a.offset.copy(i.offset),
        (a.wrapS = n.wrap),
        (a.wrapT = n.wrap),
        ('map' !== t && 'emissiveMap' !== t) || (a.colorSpace = En),
        (s[t] = a)
    }
    e(r, 'resolveURL'), e(a, 'setMapForType')
    for (const e in i) {
      const t = i[e]
      let n
      if ('' !== t)
        switch (e.toLowerCase()) {
          case 'kd':
            s.color = Pi.toWorkingColorSpace(new br().fromArray(t), En)
            break
          case 'ks':
            s.specular = Pi.toWorkingColorSpace(new br().fromArray(t), En)
            break
          case 'ke':
            s.emissive = Pi.toWorkingColorSpace(new br().fromArray(t), En)
            break
          case 'map_kd':
            a('map', t)
            break
          case 'map_ks':
            a('specularMap', t)
            break
          case 'map_ke':
            a('emissiveMap', t)
            break
          case 'norm':
            a('normalMap', t)
            break
          case 'map_bump':
          case 'bump':
            a('bumpMap', t)
            break
          case 'map_d':
            a('alphaMap', t), (s.transparent = !0)
            break
          case 'ns':
            s.shininess = parseFloat(t)
            break
          case 'd':
            ;(n = parseFloat(t)),
              n < 1 && ((s.opacity = n), (s.transparent = !0))
            break
          case 'tr':
            ;(n = parseFloat(t)),
              this.options && this.options.invertTrProperty && (n = 1 - n),
              n > 0 && ((s.opacity = 1 - n), (s.transparent = !0))
        }
    }
    return (this.materials[t] = new xp(s)), this.materials[t]
  }
  getTextureParams(t, e) {
    const n = { scale: new vi(1, 1), offset: new vi(0, 0) },
      i = t.split(/\s+/)
    let s
    return (
      (s = i.indexOf('-bm')),
      s >= 0 && ((e.bumpScale = parseFloat(i[s + 1])), i.splice(s, 2)),
      (s = i.indexOf('-s')),
      s >= 0 &&
        (n.scale.set(parseFloat(i[s + 1]), parseFloat(i[s + 2])),
        i.splice(s, 4)),
      (s = i.indexOf('-o')),
      s >= 0 &&
        (n.offset.set(parseFloat(i[s + 1]), parseFloat(i[s + 2])),
        i.splice(s, 4)),
      (n.url = i.join(' ').trim()),
      n
    )
  }
  loadTexture(t, e, n, i, s) {
    const r = void 0 !== this.manager ? this.manager : Kp
    let a = r.getHandler(t)
    null === a && (a = new am(r)),
      a.setCrossOrigin && a.setCrossOrigin(this.crossOrigin)
    const o = a.load(t, n, i, s)
    return void 0 !== e && (o.mapping = e), o
  }
}
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/ var ly = {},
  cy = e(function (t, e, n, i, s) {
    var r = new Worker(
      ly[e] ||
        (ly[e] = URL.createObjectURL(
          new Blob(
            [
              t +
                ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
            ],
            { type: 'text/javascript' }
          )
        ))
    )
    return (
      (r.onmessage = function (t) {
        var e = t.data,
          n = e.$e$
        if (n) {
          var i = new Error(n[0])
          ;(i.code = n[1]), (i.stack = n[2]), s(i, null)
        } else s(null, e)
      }),
      r.postMessage(n, i),
      r
    )
  }, 'wk'),
  hy = Uint8Array,
  uy = Uint16Array,
  dy = Int32Array,
  py = new hy([
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 0, 0, 0, 0
  ]),
  my = new hy([
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13, 0, 0
  ]),
  fy = new hy([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
  ]),
  gy = e(function (t, e) {
    for (var n = new uy(31), i = 0; i < 31; ++i) n[i] = e += 1 << t[i - 1]
    var s = new dy(n[30])
    for (i = 1; i < 30; ++i)
      for (var r = n[i]; r < n[i + 1]; ++r) s[r] = ((r - n[i]) << 5) | i
    return { b: n, r: s }
  }, 'freb'),
  vy = gy(py, 2),
  yy = vy.b,
  _y = vy.r
;(yy[28] = 258), (_y[258] = 28)
for (
  var xy = gy(my, 0), by = xy.b, wy = xy.r, My = new uy(32768), Sy = 0;
  Sy < 32768;
  ++Sy
) {
  var Ty = ((43690 & Sy) >> 1) | ((21845 & Sy) << 1)
  ;(Ty =
    ((61680 & (Ty = ((52428 & Ty) >> 2) | ((13107 & Ty) << 2))) >> 4) |
    ((3855 & Ty) << 4)),
    (My[Sy] = (((65280 & Ty) >> 8) | ((255 & Ty) << 8)) >> 1)
}
var Ey = e(function (t, e, n) {
    for (var i = t.length, s = 0, r = new uy(e); s < i; ++s)
      t[s] && ++r[t[s] - 1]
    var a,
      o = new uy(e)
    for (s = 1; s < e; ++s) o[s] = (o[s - 1] + r[s - 1]) << 1
    if (n) {
      a = new uy(1 << e)
      var l = 15 - e
      for (s = 0; s < i; ++s)
        if (t[s])
          for (
            var c = (s << 4) | t[s],
              h = e - t[s],
              u = o[t[s] - 1]++ << h,
              d = u | ((1 << h) - 1);
            u <= d;
            ++u
          )
            a[My[u] >> l] = c
    } else
      for (a = new uy(i), s = 0; s < i; ++s)
        t[s] && (a[s] = My[o[t[s] - 1]++] >> (15 - t[s]))
    return a
  }, 'hMap'),
  Ay = new hy(288)
for (Sy = 0; Sy < 144; ++Sy) Ay[Sy] = 8
for (Sy = 144; Sy < 256; ++Sy) Ay[Sy] = 9
for (Sy = 256; Sy < 280; ++Sy) Ay[Sy] = 7
for (Sy = 280; Sy < 288; ++Sy) Ay[Sy] = 8
var Cy = new hy(32)
for (Sy = 0; Sy < 32; ++Sy) Cy[Sy] = 5
var Ry = Ey(Ay, 9, 0),
  Py = Ey(Ay, 9, 1),
  Iy = Ey(Cy, 5, 0),
  Ly = Ey(Cy, 5, 1),
  Dy = e(function (t) {
    for (var e = t[0], n = 1; n < t.length; ++n) t[n] > e && (e = t[n])
    return e
  }, 'max'),
  ky = e(function (t, e, n) {
    var i = (e / 8) | 0
    return ((t[i] | (t[i + 1] << 8)) >> (7 & e)) & n
  }, 'bits'),
  Ny = e(function (t, e) {
    var n = (e / 8) | 0
    return (t[n] | (t[n + 1] << 8) | (t[n + 2] << 16)) >> (7 & e)
  }, 'bits16'),
  Uy = e(function (t) {
    return ((t + 7) / 8) | 0
  }, 'shft'),
  By = e(function (t, e, n) {
    return (
      (null == e || e < 0) && (e = 0),
      (null == n || n > t.length) && (n = t.length),
      new hy(t.subarray(e, n))
    )
  }, 'slc'),
  Oy = [
    'unexpected EOF',
    'invalid block type',
    'invalid length/literal',
    'invalid distance',
    'stream finished',
    'no stream handler',
    ,
    'no callback',
    'invalid UTF-8 data',
    'extra field too long',
    'date not in range 1980-2099',
    'filename too long',
    'stream finishing',
    'invalid zip data'
  ],
  Fy = e(function (t, e, n) {
    var i = new Error(e || Oy[t])
    if (
      ((i.code = t),
      Error.captureStackTrace && Error.captureStackTrace(i, Fy),
      !n)
    )
      throw i
    return i
  }, 'err'),
  zy = e(function (t, n, i, s) {
    var r = t.length,
      a = s ? s.length : 0
    if (!r || (n.f && !n.l)) return i || new hy(0)
    var o = !i,
      l = o || 2 != n.i,
      c = n.i
    o && (i = new hy(3 * r))
    var h = e(function (t) {
        var e = i.length
        if (t > e) {
          var n = new hy(Math.max(2 * e, t))
          n.set(i), (i = n)
        }
      }, 'cbuf'),
      u = n.f || 0,
      d = n.p || 0,
      p = n.b || 0,
      m = n.l,
      f = n.d,
      g = n.m,
      v = n.n,
      y = 8 * r
    do {
      if (!m) {
        u = ky(t, d, 1)
        var _ = ky(t, d + 1, 3)
        if (((d += 3), !_)) {
          var x = t[(I = Uy(d) + 4) - 4] | (t[I - 3] << 8),
            b = I + x
          if (b > r) {
            c && Fy(0)
            break
          }
          l && h(p + x),
            i.set(t.subarray(I, b), p),
            (n.b = p += x),
            (n.p = d = 8 * b),
            (n.f = u)
          continue
        }
        if (1 == _) (m = Py), (f = Ly), (g = 9), (v = 5)
        else if (2 == _) {
          var w = ky(t, d, 31) + 257,
            M = ky(t, d + 10, 15) + 4,
            S = w + ky(t, d + 5, 31) + 1
          d += 14
          for (var T = new hy(S), E = new hy(19), A = 0; A < M; ++A)
            E[fy[A]] = ky(t, d + 3 * A, 7)
          d += 3 * M
          var C = Dy(E),
            R = (1 << C) - 1,
            P = Ey(E, C, 1)
          for (A = 0; A < S; ) {
            var I,
              L = P[ky(t, d, R)]
            if (((d += 15 & L), (I = L >> 4) < 16)) T[A++] = I
            else {
              var D = 0,
                k = 0
              for (
                16 == I
                  ? ((k = 3 + ky(t, d, 3)), (d += 2), (D = T[A - 1]))
                  : 17 == I
                    ? ((k = 3 + ky(t, d, 7)), (d += 3))
                    : 18 == I && ((k = 11 + ky(t, d, 127)), (d += 7));
                k--;

              )
                T[A++] = D
            }
          }
          var N = T.subarray(0, w),
            U = T.subarray(w)
          ;(g = Dy(N)), (v = Dy(U)), (m = Ey(N, g, 1)), (f = Ey(U, v, 1))
        } else Fy(1)
        if (d > y) {
          c && Fy(0)
          break
        }
      }
      l && h(p + 131072)
      for (var B = (1 << g) - 1, O = (1 << v) - 1, F = d; ; F = d) {
        var z = (D = m[Ny(t, d) & B]) >> 4
        if ((d += 15 & D) > y) {
          c && Fy(0)
          break
        }
        if ((D || Fy(2), z < 256)) i[p++] = z
        else {
          if (256 == z) {
            ;(F = d), (m = null)
            break
          }
          var V = z - 254
          if (z > 264) {
            var H = py[(A = z - 257)]
            ;(V = ky(t, d, (1 << H) - 1) + yy[A]), (d += H)
          }
          var G = f[Ny(t, d) & O],
            W = G >> 4
          G || Fy(3), (d += 15 & G)
          U = by[W]
          if (W > 3) {
            H = my[W]
            ;(U += Ny(t, d) & ((1 << H) - 1)), (d += H)
          }
          if (d > y) {
            c && Fy(0)
            break
          }
          l && h(p + 131072)
          var j = p + V
          if (p < U) {
            var X = a - U,
              q = Math.min(U, j)
            for (X + p < 0 && Fy(3); p < q; ++p) i[p] = s[X + p]
          }
          for (; p < j; ++p) i[p] = i[p - U]
        }
      }
      ;(n.l = m),
        (n.p = F),
        (n.b = p),
        (n.f = u),
        m && ((u = 1), (n.m = g), (n.d = f), (n.n = v))
    } while (!u)
    return p != i.length && o ? By(i, 0, p) : i.subarray(0, p)
  }, 'inflt'),
  Vy = e(function (t, e, n) {
    n <<= 7 & e
    var i = (e / 8) | 0
    ;(t[i] |= n), (t[i + 1] |= n >> 8)
  }, 'wbits'),
  Hy = e(function (t, e, n) {
    n <<= 7 & e
    var i = (e / 8) | 0
    ;(t[i] |= n), (t[i + 1] |= n >> 8), (t[i + 2] |= n >> 16)
  }, 'wbits16'),
  Gy = e(function (t, e) {
    for (var n = [], i = 0; i < t.length; ++i) t[i] && n.push({ s: i, f: t[i] })
    var s = n.length,
      r = n.slice()
    if (!s) return { t: Ky, l: 0 }
    if (1 == s) {
      var a = new hy(n[0].s + 1)
      return (a[n[0].s] = 1), { t: a, l: 1 }
    }
    n.sort(function (t, e) {
      return t.f - e.f
    }),
      n.push({ s: -1, f: 25001 })
    var o = n[0],
      l = n[1],
      c = 0,
      h = 1,
      u = 2
    for (n[0] = { s: -1, f: o.f + l.f, l: o, r: l }; h != s - 1; )
      (o = n[n[c].f < n[u].f ? c++ : u++]),
        (l = n[c != h && n[c].f < n[u].f ? c++ : u++]),
        (n[h++] = { s: -1, f: o.f + l.f, l: o, r: l })
    var d = r[0].s
    for (i = 1; i < s; ++i) r[i].s > d && (d = r[i].s)
    var p = new uy(d + 1),
      m = Wy(n[h - 1], p, 0)
    if (m > e) {
      i = 0
      var f = 0,
        g = m - e,
        v = 1 << g
      for (
        r.sort(function (t, e) {
          return p[e.s] - p[t.s] || t.f - e.f
        });
        i < s;
        ++i
      ) {
        var y = r[i].s
        if (!(p[y] > e)) break
        ;(f += v - (1 << (m - p[y]))), (p[y] = e)
      }
      for (f >>= g; f > 0; ) {
        var _ = r[i].s
        p[_] < e ? (f -= 1 << (e - p[_]++ - 1)) : ++i
      }
      for (; i >= 0 && f; --i) {
        var x = r[i].s
        p[x] == e && (--p[x], ++f)
      }
      m = e
    }
    return { t: new hy(p), l: m }
  }, 'hTree'),
  Wy = e(function (t, e, n) {
    return -1 == t.s
      ? Math.max(Wy(t.l, e, n + 1), Wy(t.r, e, n + 1))
      : (e[t.s] = n)
  }, 'ln'),
  jy = e(function (t) {
    for (var n = t.length; n && !t[--n]; );
    for (
      var i = new uy(++n),
        s = 0,
        r = t[0],
        a = 1,
        o = e(function (t) {
          i[s++] = t
        }, 'w'),
        l = 1;
      l <= n;
      ++l
    )
      if (t[l] == r && l != n) ++a
      else {
        if (!r && a > 2) {
          for (; a > 138; a -= 138) o(32754)
          a > 2 &&
            (o(a > 10 ? ((a - 11) << 5) | 28690 : ((a - 3) << 5) | 12305),
            (a = 0))
        } else if (a > 3) {
          for (o(r), --a; a > 6; a -= 6) o(8304)
          a > 2 && (o(((a - 3) << 5) | 8208), (a = 0))
        }
        for (; a--; ) o(r)
        ;(a = 1), (r = t[l])
      }
    return { c: i.subarray(0, s), n: n }
  }, 'lc'),
  Xy = e(function (t, e) {
    for (var n = 0, i = 0; i < e.length; ++i) n += t[i] * e[i]
    return n
  }, 'clen'),
  qy = e(function (t, e, n) {
    var i = n.length,
      s = Uy(e + 2)
    ;(t[s] = 255 & i),
      (t[s + 1] = i >> 8),
      (t[s + 2] = 255 ^ t[s]),
      (t[s + 3] = 255 ^ t[s + 1])
    for (var r = 0; r < i; ++r) t[s + r + 4] = n[r]
    return 8 * (s + 4 + i)
  }, 'wfblk'),
  Yy = e(function (t, e, n, i, s, r, a, o, l, c, h) {
    Vy(e, h++, n), ++s[256]
    for (
      var u = Gy(s, 15),
        d = u.t,
        p = u.l,
        m = Gy(r, 15),
        f = m.t,
        g = m.l,
        v = jy(d),
        y = v.c,
        _ = v.n,
        x = jy(f),
        b = x.c,
        w = x.n,
        M = new uy(19),
        S = 0;
      S < y.length;
      ++S
    )
      ++M[31 & y[S]]
    for (S = 0; S < b.length; ++S) ++M[31 & b[S]]
    for (
      var T = Gy(M, 7), E = T.t, A = T.l, C = 19;
      C > 4 && !E[fy[C - 1]];
      --C
    );
    var R,
      P,
      I,
      L,
      D = (c + 5) << 3,
      k = Xy(s, Ay) + Xy(r, Cy) + a,
      N =
        Xy(s, d) +
        Xy(r, f) +
        a +
        14 +
        3 * C +
        Xy(M, E) +
        2 * M[16] +
        3 * M[17] +
        7 * M[18]
    if (l >= 0 && D <= k && D <= N) return qy(e, h, t.subarray(l, l + c))
    if ((Vy(e, h, 1 + (N < k)), (h += 2), N < k)) {
      ;(R = Ey(d, p, 0)), (P = d), (I = Ey(f, g, 0)), (L = f)
      var U = Ey(E, A, 0)
      Vy(e, h, _ - 257), Vy(e, h + 5, w - 1), Vy(e, h + 10, C - 4), (h += 14)
      for (S = 0; S < C; ++S) Vy(e, h + 3 * S, E[fy[S]])
      h += 3 * C
      for (var B = [y, b], O = 0; O < 2; ++O) {
        var F = B[O]
        for (S = 0; S < F.length; ++S) {
          var z = 31 & F[S]
          Vy(e, h, U[z]),
            (h += E[z]),
            z > 15 && (Vy(e, h, (F[S] >> 5) & 127), (h += F[S] >> 12))
        }
      }
    } else (R = Ry), (P = Ay), (I = Iy), (L = Cy)
    for (S = 0; S < o; ++S) {
      var V = i[S]
      if (V > 255) {
        Hy(e, h, R[(z = (V >> 18) & 31) + 257]),
          (h += P[z + 257]),
          z > 7 && (Vy(e, h, (V >> 23) & 31), (h += py[z]))
        var H = 31 & V
        Hy(e, h, I[H]),
          (h += L[H]),
          H > 3 && (Hy(e, h, (V >> 5) & 8191), (h += my[H]))
      } else Hy(e, h, R[V]), (h += P[V])
    }
    return Hy(e, h, R[256]), h + P[256]
  }, 'wblk'),
  Zy = new dy([
    65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632
  ]),
  Ky = new hy(0),
  $y = e(function (t, n, i, s, r, a) {
    var o = a.z || t.length,
      l = new hy(s + o + 5 * (1 + Math.ceil(o / 7e3)) + r),
      c = l.subarray(s, l.length - r),
      h = a.l,
      u = 7 & (a.r || 0)
    if (n) {
      u && (c[0] = a.r >> 3)
      for (
        var d = Zy[n - 1],
          p = d >> 13,
          m = 8191 & d,
          f = (1 << i) - 1,
          g = a.p || new uy(32768),
          v = a.h || new uy(f + 1),
          y = Math.ceil(i / 3),
          _ = 2 * y,
          x = e(function (e) {
            return (t[e] ^ (t[e + 1] << y) ^ (t[e + 2] << _)) & f
          }, 'hsh'),
          b = new dy(25e3),
          w = new uy(288),
          M = new uy(32),
          S = 0,
          T = 0,
          E = a.i || 0,
          A = 0,
          C = a.w || 0,
          R = 0;
        E + 2 < o;
        ++E
      ) {
        var P = x(E),
          I = 32767 & E,
          L = v[P]
        if (((g[I] = L), (v[P] = I), C <= E)) {
          var D = o - E
          if ((S > 7e3 || A > 24576) && (D > 423 || !h)) {
            ;(u = Yy(t, c, 0, b, w, M, T, A, R, E - R, u)),
              (A = S = T = 0),
              (R = E)
            for (var k = 0; k < 286; ++k) w[k] = 0
            for (k = 0; k < 30; ++k) M[k] = 0
          }
          var N = 2,
            U = 0,
            B = m,
            O = (I - L) & 32767
          if (D > 2 && P == x(E - O))
            for (
              var F = Math.min(p, D) - 1,
                z = Math.min(32767, E),
                V = Math.min(258, D);
              O <= z && --B && I != L;

            ) {
              if (t[E + N] == t[E + N - O]) {
                for (var H = 0; H < V && t[E + H] == t[E + H - O]; ++H);
                if (H > N) {
                  if (((N = H), (U = O), H > F)) break
                  var G = Math.min(O, H - 2),
                    W = 0
                  for (k = 0; k < G; ++k) {
                    var j = (E - O + k) & 32767,
                      X = (j - g[j]) & 32767
                    X > W && ((W = X), (L = j))
                  }
                }
              }
              O += ((I = L) - (L = g[I])) & 32767
            }
          if (U) {
            b[A++] = 268435456 | (_y[N] << 18) | wy[U]
            var q = 31 & _y[N],
              Y = 31 & wy[U]
            ;(T += py[q] + my[Y]), ++w[257 + q], ++M[Y], (C = E + N), ++S
          } else (b[A++] = t[E]), ++w[t[E]]
        }
      }
      for (E = Math.max(E, C); E < o; ++E) (b[A++] = t[E]), ++w[t[E]]
      ;(u = Yy(t, c, h, b, w, M, T, A, R, E - R, u)),
        h ||
          ((a.r = (7 & u) | (c[(u / 8) | 0] << 3)),
          (u -= 7),
          (a.h = v),
          (a.p = g),
          (a.i = E),
          (a.w = C))
    } else {
      for (E = a.w || 0; E < o + h; E += 65535) {
        var Z = E + 65535
        Z >= o && ((c[(u / 8) | 0] = h), (Z = o)),
          (u = qy(c, u + 1, t.subarray(E, Z)))
      }
      a.i = o
    }
    return By(l, 0, s + Uy(u) + r)
  }, 'dflt'),
  Jy = (function () {
    for (var t = new Int32Array(256), e = 0; e < 256; ++e) {
      for (var n = e, i = 9; --i; ) n = (1 & n && -306674912) ^ (n >>> 1)
      t[e] = n
    }
    return t
  })(),
  Qy = e(function () {
    var t = -1
    return {
      p: e(function (e) {
        for (var n = t, i = 0; i < e.length; ++i)
          n = Jy[(255 & n) ^ e[i]] ^ (n >>> 8)
        t = n
      }, 'p'),
      d: e(function () {
        return ~t
      }, 'd')
    }
  }, 'crc'),
  t_ = e(function () {
    var t = 1,
      n = 0
    return {
      p: e(function (e) {
        for (var i = t, s = n, r = 0 | e.length, a = 0; a != r; ) {
          for (var o = Math.min(a + 2655, r); a < o; ++a) s += i += e[a]
          ;(i = (65535 & i) + 15 * (i >> 16)),
            (s = (65535 & s) + 15 * (s >> 16))
        }
        ;(t = i), (n = s)
      }, 'p'),
      d: e(function () {
        return (
          ((255 & (t %= 65521)) << 24) |
          ((65280 & t) << 8) |
          ((255 & (n %= 65521)) << 8) |
          (n >> 8)
        )
      }, 'd')
    }
  }, 'adler'),
  e_ = e(function (t, e, n, i, s) {
    if (!s && ((s = { l: 1 }), e.dictionary)) {
      var r = e.dictionary.subarray(-32768),
        a = new hy(r.length + t.length)
      a.set(r), a.set(t, r.length), (t = a), (s.w = r.length)
    }
    return $y(
      t,
      null == e.level ? 6 : e.level,
      null == e.mem
        ? s.l
          ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t.length))))
          : 20
        : 12 + e.mem,
      n,
      i,
      s
    )
  }, 'dopt'),
  n_ = e(function (t, e) {
    var n = {}
    for (var i in t) n[i] = t[i]
    for (var i in e) n[i] = e[i]
    return n
  }, 'mrg'),
  i_ = e(function (t, e, n) {
    for (
      var i = t(),
        s = t.toString(),
        r = s
          .slice(s.indexOf('[') + 1, s.lastIndexOf(']'))
          .replace(/\s+/g, '')
          .split(','),
        a = 0;
      a < i.length;
      ++a
    ) {
      var o = i[a],
        l = r[a]
      if ('function' == typeof o) {
        e += ';' + l + '='
        var c = o.toString()
        if (o.prototype)
          if (-1 != c.indexOf('[native code]')) {
            var h = c.indexOf(' ', 8) + 1
            e += c.slice(h, c.indexOf('(', h))
          } else
            for (var u in ((e += c), o.prototype))
              e += ';' + l + '.prototype.' + u + '=' + o.prototype[u].toString()
        else e += c
      } else n[l] = o
    }
    return e
  }, 'wcln'),
  s_ = [],
  r_ = e(function (t) {
    var e = []
    for (var n in t)
      t[n].buffer && e.push((t[n] = new t[n].constructor(t[n])).buffer)
    return e
  }, 'cbfs'),
  a_ = e(function (t, e, n, i) {
    if (!s_[n]) {
      for (var s = '', r = {}, a = t.length - 1, o = 0; o < a; ++o)
        s = i_(t[o], s, r)
      s_[n] = { c: i_(t[a], s, r), e: r }
    }
    var l = n_({}, s_[n].e)
    return cy(
      s_[n].c +
        ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' +
        e.toString() +
        '}',
      n,
      l,
      r_(l),
      i
    )
  }, 'wrkr'),
  o_ = e(function () {
    return [
      hy,
      uy,
      dy,
      py,
      my,
      fy,
      yy,
      by,
      Py,
      Ly,
      My,
      Oy,
      Ey,
      Dy,
      ky,
      Ny,
      Uy,
      By,
      Fy,
      zy,
      P_,
      p_,
      m_
    ]
  }, 'bInflt'),
  l_ = e(function () {
    return [
      hy,
      uy,
      dy,
      py,
      my,
      fy,
      _y,
      wy,
      Ry,
      Ay,
      Iy,
      Cy,
      My,
      Zy,
      Ky,
      Ey,
      Vy,
      Hy,
      Gy,
      Wy,
      jy,
      Xy,
      qy,
      Yy,
      Uy,
      By,
      $y,
      e_,
      C_,
      p_
    ]
  }, 'bDflt'),
  c_ = e(function () {
    return [x_, M_, __, Qy, Jy]
  }, 'gze'),
  h_ = e(function () {
    return [b_, w_]
  }, 'guze'),
  u_ = e(function () {
    return [S_, __, t_]
  }, 'zle'),
  d_ = e(function () {
    return [T_]
  }, 'zule'),
  p_ = e(function (t) {
    return postMessage(t, [t.buffer])
  }, 'pbf'),
  m_ = e(function (t) {
    return t && { out: t.size && new hy(t.size), dictionary: t.dictionary }
  }, 'gopt'),
  f_ = e(function (t, e, n, i, s, r) {
    var a = a_(n, i, s, function (t, e) {
      a.terminate(), r(t, e)
    })
    return (
      a.postMessage([t, e], e.consume ? [t.buffer] : []),
      function () {
        a.terminate()
      }
    )
  }, 'cbify'),
  g_ = e(function (t, e) {
    return t[e] | (t[e + 1] << 8)
  }, 'b2'),
  v_ = e(function (t, e) {
    return (t[e] | (t[e + 1] << 8) | (t[e + 2] << 16) | (t[e + 3] << 24)) >>> 0
  }, 'b4'),
  y_ = e(function (t, e) {
    return v_(t, e) + 4294967296 * v_(t, e + 4)
  }, 'b8'),
  __ = e(function (t, e, n) {
    for (; n; ++e) (t[e] = n), (n >>>= 8)
  }, 'wbytes'),
  x_ = e(function (t, e) {
    var n = e.filename
    if (
      ((t[0] = 31),
      (t[1] = 139),
      (t[2] = 8),
      (t[8] = e.level < 2 ? 4 : 9 == e.level ? 2 : 0),
      (t[9] = 3),
      0 != e.mtime &&
        __(t, 4, Math.floor(new Date(e.mtime || Date.now()) / 1e3)),
      n)
    ) {
      t[3] = 8
      for (var i = 0; i <= n.length; ++i) t[i + 10] = n.charCodeAt(i)
    }
  }, 'gzh'),
  b_ = e(function (t) {
    ;(31 == t[0] && 139 == t[1] && 8 == t[2]) || Fy(6, 'invalid gzip data')
    var e = t[3],
      n = 10
    4 & e && (n += 2 + (t[10] | (t[11] << 8)))
    for (var i = ((e >> 3) & 1) + ((e >> 4) & 1); i > 0; i -= !t[n++]);
    return n + (2 & e)
  }, 'gzs'),
  w_ = e(function (t) {
    var e = t.length
    return (
      (t[e - 4] | (t[e - 3] << 8) | (t[e - 2] << 16) | (t[e - 1] << 24)) >>> 0
    )
  }, 'gzl'),
  M_ = e(function (t) {
    return 10 + (t.filename ? t.filename.length + 1 : 0)
  }, 'gzhl'),
  S_ = e(function (t, e) {
    var n = e.level,
      i = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2
    if (
      ((t[0] = 120),
      (t[1] = (i << 6) | (e.dictionary && 32)),
      (t[1] |= 31 - (((t[0] << 8) | t[1]) % 31)),
      e.dictionary)
    ) {
      var s = t_()
      s.p(e.dictionary), __(t, 2, s.d())
    }
  }, 'zlh'),
  T_ = e(function (t, e) {
    return (
      (8 != (15 & t[0]) || t[0] >> 4 > 7 || ((t[0] << 8) | t[1]) % 31) &&
        Fy(6, 'invalid zlib data'),
      ((t[1] >> 5) & 1) == +!e &&
        Fy(
          6,
          'invalid zlib data: ' +
            (32 & t[1] ? 'need' : 'unexpected') +
            ' dictionary'
        ),
      2 + ((t[1] >> 3) & 4)
    )
  }, 'zls')
function E_(t, e) {
  return 'function' == typeof t && ((e = t), (t = {})), (this.ondata = e), t
}
e(E_, 'StrmOpt')
function A_(t, e, n) {
  return (
    n || ((n = e), (e = {})),
    'function' != typeof n && Fy(7),
    f_(
      t,
      e,
      [l_],
      function (t) {
        return p_(C_(t.data[0], t.data[1]))
      },
      0,
      n
    )
  )
}
function C_(t, e) {
  return e_(t, e || {}, 0, 0)
}
e(A_, 'deflate'), e(C_, 'deflateSync')
function R_(t, e, n) {
  return (
    n || ((n = e), (e = {})),
    'function' != typeof n && Fy(7),
    f_(
      t,
      e,
      [o_],
      function (t) {
        return p_(P_(t.data[0], m_(t.data[1])))
      },
      1,
      n
    )
  )
}
function P_(t, e) {
  return zy(t, { i: 2 }, e && e.out, e && e.dictionary)
}
e(R_, 'inflate'), e(P_, 'inflateSync')
function I_(t, e) {
  e || (e = {})
  var n = Qy(),
    i = t.length
  n.p(t)
  var s = e_(t, e, M_(e), 8),
    r = s.length
  return x_(s, e), __(s, r - 8, n.d()), __(s, r - 4, i), s
}
e(function (t, e, n) {
  return (
    n || ((n = e), (e = {})),
    'function' != typeof n && Fy(7),
    f_(
      t,
      e,
      [
        l_,
        c_,
        function () {
          return [I_]
        }
      ],
      function (t) {
        return p_(I_(t.data[0], t.data[1]))
      },
      2,
      n
    )
  )
}, 'gzip'),
  e(I_, 'gzipSync')
function L_(t, e, n) {
  return (
    n || ((n = e), (e = {})),
    'function' != typeof n && Fy(7),
    f_(
      t,
      e,
      [
        o_,
        h_,
        function () {
          return [D_]
        }
      ],
      function (t) {
        return p_(D_(t.data[0], t.data[1]))
      },
      3,
      n
    )
  )
}
function D_(t, e) {
  var n = b_(t)
  return (
    n + 8 > t.length && Fy(6, 'invalid gzip data'),
    zy(
      t.subarray(n, -8),
      { i: 2 },
      (e && e.out) || new hy(w_(t)),
      e && e.dictionary
    )
  )
}
e(L_, 'gunzip'), e(D_, 'gunzipSync')
function k_(t, e) {
  e || (e = {})
  var n = t_()
  n.p(t)
  var i = e_(t, e, e.dictionary ? 6 : 2, 4)
  return S_(i, e), __(i, i.length - 4, n.d()), i
}
e(function (t, e, n) {
  return (
    n || ((n = e), (e = {})),
    'function' != typeof n && Fy(7),
    f_(
      t,
      e,
      [
        l_,
        u_,
        function () {
          return [k_]
        }
      ],
      function (t) {
        return p_(k_(t.data[0], t.data[1]))
      },
      4,
      n
    )
  )
}, 'zlib'),
  e(k_, 'zlibSync')
function N_(t, e, n) {
  return (
    n || ((n = e), (e = {})),
    'function' != typeof n && Fy(7),
    f_(
      t,
      e,
      [
        o_,
        d_,
        function () {
          return [U_]
        }
      ],
      function (t) {
        return p_(U_(t.data[0], m_(t.data[1])))
      },
      5,
      n
    )
  )
}
function U_(t, e) {
  return zy(
    t.subarray(T_(t, e && e.dictionary), -4),
    { i: 2 },
    e && e.out,
    e && e.dictionary
  )
}
e(N_, 'unzlib'), e(U_, 'unzlibSync')
e(function (t, e, n) {
  return (
    n || ((n = e), (e = {})),
    'function' != typeof n && Fy(7),
    31 == t[0] && 139 == t[1] && 8 == t[2]
      ? L_(t, e, n)
      : 8 != (15 & t[0]) || t[0] >> 4 > 7 || ((t[0] << 8) | t[1]) % 31
        ? R_(t, e, n)
        : N_(t, e, n)
  )
}, 'decompress'),
  e(function (t, e) {
    return 31 == t[0] && 139 == t[1] && 8 == t[2]
      ? D_(t, e)
      : 8 != (15 & t[0]) || t[0] >> 4 > 7 || ((t[0] << 8) | t[1]) % 31
        ? P_(t, e)
        : U_(t, e)
  }, 'decompressSync')
var B_ = e(function (t, e, n, i) {
    for (var s in t) {
      var r = t[s],
        a = e + s,
        o = i
      Array.isArray(r) && ((o = n_(i, r[1])), (r = r[0])),
        r instanceof hy
          ? (n[a] = [r, o])
          : ((n[(a += '/')] = [new hy(0), o]), B_(r, a, n, i))
    }
  }, 'fltn'),
  O_ = 'undefined' != typeof TextEncoder && new TextEncoder(),
  F_ = 'undefined' != typeof TextDecoder && new TextDecoder()
try {
  F_.decode(Ky, { stream: !0 })
} catch (zx) {}
var z_ = e(function (t) {
  for (var e = '', n = 0; ; ) {
    var i = t[n++],
      s = (i > 127) + (i > 223) + (i > 239)
    if (n + s > t.length) return { s: e, r: By(t, n - 1) }
    s
      ? 3 == s
        ? ((i =
            (((15 & i) << 18) |
              ((63 & t[n++]) << 12) |
              ((63 & t[n++]) << 6) |
              (63 & t[n++])) -
            65536),
          (e += String.fromCharCode(55296 | (i >> 10), 56320 | (1023 & i))))
        : (e +=
            1 & s
              ? String.fromCharCode(((31 & i) << 6) | (63 & t[n++]))
              : String.fromCharCode(
                  ((15 & i) << 12) | ((63 & t[n++]) << 6) | (63 & t[n++])
                ))
      : (e += String.fromCharCode(i))
  }
}, 'dutf8')
function V_(t, n) {
  if (n) {
    for (var i = new hy(t.length), s = 0; s < t.length; ++s)
      i[s] = t.charCodeAt(s)
    return i
  }
  if (O_) return O_.encode(t)
  var r = t.length,
    a = new hy(t.length + (t.length >> 1)),
    o = 0,
    l = e(function (t) {
      a[o++] = t
    }, 'w')
  for (s = 0; s < r; ++s) {
    if (o + 5 > a.length) {
      var c = new hy(o + 8 + ((r - s) << 1))
      c.set(a), (a = c)
    }
    var h = t.charCodeAt(s)
    h < 128 || n
      ? l(h)
      : h < 2048
        ? (l(192 | (h >> 6)), l(128 | (63 & h)))
        : h > 55295 && h < 57344
          ? (l(
              240 |
                ((h = (65536 + (1047552 & h)) | (1023 & t.charCodeAt(++s))) >>
                  18)
            ),
            l(128 | ((h >> 12) & 63)),
            l(128 | ((h >> 6) & 63)),
            l(128 | (63 & h)))
          : (l(224 | (h >> 12)), l(128 | ((h >> 6) & 63)), l(128 | (63 & h)))
  }
  return By(a, 0, o)
}
function H_(t, e) {
  if (e) {
    for (var n = '', i = 0; i < t.length; i += 16384)
      n += String.fromCharCode.apply(null, t.subarray(i, i + 16384))
    return n
  }
  if (F_) return F_.decode(t)
  var s = z_(t),
    r = s.s
  return (n = s.r).length && Fy(8), r
}
e(V_, 'strToU8'), e(H_, 'strFromU8')
var G_ = e(function (t, e) {
    return e + 30 + g_(t, e + 26) + g_(t, e + 28)
  }, 'slzh'),
  W_ = e(function (t, e, n) {
    var i = g_(t, e + 28),
      s = H_(t.subarray(e + 46, e + 46 + i), !(2048 & g_(t, e + 8))),
      r = e + 46 + i,
      a = v_(t, e + 20),
      o = n && 4294967295 == a ? j_(t, r) : [a, v_(t, e + 24), v_(t, e + 42)],
      l = o[0],
      c = o[1],
      h = o[2]
    return [g_(t, e + 10), l, c, s, r + g_(t, e + 30) + g_(t, e + 32), h]
  }, 'zh'),
  j_ = e(function (t, e) {
    for (; 1 != g_(t, e); e += 4 + g_(t, e + 2));
    return [y_(t, e + 12), y_(t, e + 4), y_(t, e + 20)]
  }, 'z64e'),
  X_ = e(function (t) {
    var e = 0
    if (t)
      for (var n in t) {
        var i = t[n].length
        i > 65535 && Fy(9), (e += i + 4)
      }
    return e
  }, 'exfl'),
  q_ = e(function (t, e, n, i, s, r, a, o) {
    var l = i.length,
      c = n.extra,
      h = o && o.length,
      u = X_(c)
    __(t, e, null != a ? 33639248 : 67324752),
      (e += 4),
      null != a && ((t[e++] = 20), (t[e++] = n.os)),
      (t[e] = 20),
      (e += 2),
      (t[e++] = (n.flag << 1) | (r < 0 && 8)),
      (t[e++] = s && 8),
      (t[e++] = 255 & n.compression),
      (t[e++] = n.compression >> 8)
    var d = new Date(null == n.mtime ? Date.now() : n.mtime),
      p = d.getFullYear() - 1980
    if (
      ((p < 0 || p > 119) && Fy(10),
      __(
        t,
        e,
        (p << 25) |
          ((d.getMonth() + 1) << 21) |
          (d.getDate() << 16) |
          (d.getHours() << 11) |
          (d.getMinutes() << 5) |
          (d.getSeconds() >> 1)
      ),
      (e += 4),
      -1 != r &&
        (__(t, e, n.crc),
        __(t, e + 4, r < 0 ? -r - 2 : r),
        __(t, e + 8, n.size)),
      __(t, e + 12, l),
      __(t, e + 14, u),
      (e += 16),
      null != a &&
        (__(t, e, h), __(t, e + 6, n.attrs), __(t, e + 10, a), (e += 14)),
      t.set(i, e),
      (e += l),
      u)
    )
      for (var m in c) {
        var f = c[m],
          g = f.length
        __(t, e, +m), __(t, e + 2, g), t.set(f, e + 4), (e += 4 + g)
      }
    return h && (t.set(o, e), (e += h)), e
  }, 'wzh'),
  Y_ = e(function (t, e, n, i, s) {
    __(t, e, 101010256),
      __(t, e + 8, n),
      __(t, e + 10, n),
      __(t, e + 12, i),
      __(t, e + 16, s)
  }, 'wzf')
e(function (t, n, i) {
  i || ((i = n), (n = {})), 'function' != typeof i && Fy(7)
  var s = {}
  B_(t, '', s, n)
  var r = Object.keys(s),
    a = r.length,
    o = 0,
    l = 0,
    c = a,
    h = new Array(a),
    u = [],
    d = e(function () {
      for (var t = 0; t < u.length; ++t) u[t]()
    }, 'tAll'),
    p = e(function (t, e) {
      Z_(function () {
        i(t, e)
      })
    }, 'cbd')
  Z_(function () {
    p = i
  })
  var m = e(function () {
    var t = new hy(l + 22),
      e = o,
      n = l - o
    l = 0
    for (var i = 0; i < c; ++i) {
      var s = h[i]
      try {
        var r = s.c.length
        q_(t, l, s, s.f, s.u, r)
        var a = 30 + s.f.length + X_(s.extra),
          u = l + a
        t.set(s.c, u),
          q_(t, o, s, s.f, s.u, r, l, s.m),
          (o += 16 + a + (s.m ? s.m.length : 0)),
          (l = u + r)
      } catch (zx) {
        return p(zx, null)
      }
    }
    Y_(t, o, h.length, n, e), p(null, t)
  }, 'cbf')
  a || m()
  for (
    var f = e(function (t) {
        var n = r[t],
          i = s[n],
          c = i[0],
          f = i[1],
          g = Qy(),
          v = c.length
        g.p(c)
        var y = V_(n),
          _ = y.length,
          x = f.comment,
          b = x && V_(x),
          w = b && b.length,
          M = X_(f.extra),
          S = 0 == f.level ? 0 : 8,
          T = e(function (e, i) {
            if (e) d(), p(e, null)
            else {
              var s = i.length
              ;(h[t] = n_(f, {
                size: v,
                crc: g.d(),
                c: i,
                f: y,
                m: b,
                u: _ != n.length || (b && x.length != w),
                compression: S
              })),
                (o += 30 + _ + M + s),
                (l += 76 + 2 * (_ + M) + (w || 0) + s),
                --a || m()
            }
          }, 'cbl')
        if ((_ > 65535 && T(Fy(11, 0, 1), null), S))
          if (v < 16e4)
            try {
              T(null, C_(c, f))
            } catch (zx) {
              T(zx, null)
            }
          else u.push(A_(c, f, T))
        else T(null, c)
      }, '_loop_1'),
      g = 0;
    g < c;
    ++g
  )
    f(g)
  return d
}, 'zip'),
  e(function (t, e) {
    e || (e = {})
    var n = {},
      i = []
    B_(t, '', n, e)
    var s = 0,
      r = 0
    for (var a in n) {
      var o = n[a],
        l = o[0],
        c = o[1],
        h = 0 == c.level ? 0 : 8,
        u = (M = V_(a)).length,
        d = c.comment,
        p = d && V_(d),
        m = p && p.length,
        f = X_(c.extra)
      u > 65535 && Fy(11)
      var g = h ? C_(l, c) : l,
        v = g.length,
        y = Qy()
      y.p(l),
        i.push(
          n_(c, {
            size: l.length,
            crc: y.d(),
            c: g,
            f: M,
            m: p,
            u: u != a.length || (p && d.length != m),
            o: s,
            compression: h
          })
        ),
        (s += 30 + u + f + v),
        (r += 76 + 2 * (u + f) + (m || 0) + v)
    }
    for (var _ = new hy(r + 22), x = s, b = r - s, w = 0; w < i.length; ++w) {
      var M = i[w]
      q_(_, M.o, M, M.f, M.u, M.c.length)
      var S = 30 + M.f.length + X_(M.extra)
      _.set(M.c, M.o + S),
        q_(_, s, M, M.f, M.u, M.c.length, M.o, M.m),
        (s += 16 + S + (M.m ? M.m.length : 0))
    }
    return Y_(_, s, i.length, b, x), _
  }, 'zipSync')
var Z_ =
  'function' == typeof queueMicrotask
    ? queueMicrotask
    : 'function' == typeof setTimeout
      ? setTimeout
      : function (t) {
          t()
        }
function K_(t, e, n) {
  const i = n.length - t - 1
  if (e >= n[i]) return i - 1
  if (e <= n[t]) return t
  let s = t,
    r = i,
    a = Math.floor((s + r) / 2)
  for (; e < n[a] || e >= n[a + 1]; )
    e < n[a] ? (r = a) : (s = a), (a = Math.floor((s + r) / 2))
  return a
}
function $_(t, e, n, i) {
  const s = [],
    r = [],
    a = []
  s[0] = 1
  for (let o = 1; o <= n; ++o) {
    ;(r[o] = e - i[t + 1 - o]), (a[o] = i[t + o] - e)
    let n = 0
    for (let t = 0; t < o; ++t) {
      const e = a[t + 1],
        i = r[o - t],
        l = s[t] / (e + i)
      ;(s[t] = n + e * l), (n = i * l)
    }
    s[o] = n
  }
  return s
}
function J_(t, e, n, i) {
  const s = K_(t, i, e),
    r = $_(s, i, t, e),
    a = new ji(0, 0, 0, 0)
  for (let o = 0; o <= t; ++o) {
    const e = n[s - t + o],
      i = r[o],
      l = e.w * i
    ;(a.x += e.x * l), (a.y += e.y * l), (a.z += e.z * l), (a.w += e.w * i)
  }
  return a
}
function Q_(t, e, n, i, s) {
  const r = []
  for (let u = 0; u <= n; ++u) r[u] = 0
  const a = []
  for (let u = 0; u <= i; ++u) a[u] = r.slice(0)
  const o = []
  for (let u = 0; u <= n; ++u) o[u] = r.slice(0)
  o[0][0] = 1
  const l = r.slice(0),
    c = r.slice(0)
  for (let u = 1; u <= n; ++u) {
    ;(l[u] = e - s[t + 1 - u]), (c[u] = s[t + u] - e)
    let n = 0
    for (let t = 0; t < u; ++t) {
      const e = c[t + 1],
        i = l[u - t]
      o[u][t] = e + i
      const s = o[t][u - 1] / o[u][t]
      ;(o[t][u] = n + e * s), (n = i * s)
    }
    o[u][u] = n
  }
  for (let u = 0; u <= n; ++u) a[0][u] = o[u][n]
  for (let u = 0; u <= n; ++u) {
    let t = 0,
      e = 1
    const s = []
    for (let i = 0; i <= n; ++i) s[i] = r.slice(0)
    s[0][0] = 1
    for (let r = 1; r <= i; ++r) {
      let i = 0
      const l = u - r,
        c = n - r
      u >= r && ((s[e][0] = s[t][0] / o[c + 1][l]), (i = s[e][0] * o[l][c]))
      const h = u - 1 <= c ? r - 1 : n - u
      for (let n = l >= -1 ? 1 : -l; n <= h; ++n)
        (s[e][n] = (s[t][n] - s[t][n - 1]) / o[c + 1][l + n]),
          (i += s[e][n] * o[l + n][c])
      u <= c &&
        ((s[e][r] = -s[t][r - 1] / o[c + 1][u]), (i += s[e][r] * o[u][c])),
        (a[r][u] = i)
      const d = t
      ;(t = e), (e = d)
    }
  }
  let h = n
  for (let u = 1; u <= i; ++u) {
    for (let t = 0; t <= n; ++t) a[u][t] *= h
    h *= n - u
  }
  return a
}
function tx(t, e, n, i, s) {
  const r = s < t ? s : t,
    a = [],
    o = K_(t, i, e),
    l = Q_(o, i, t, r, e),
    c = []
  for (let h = 0; h < n.length; ++h) {
    const t = n[h].clone(),
      e = t.w
    ;(t.x *= e), (t.y *= e), (t.z *= e), (c[h] = t)
  }
  for (let h = 0; h <= r; ++h) {
    const e = c[o - t].clone().multiplyScalar(l[h][0])
    for (let n = 1; n <= t; ++n)
      e.add(c[o - t + n].clone().multiplyScalar(l[h][n]))
    a[h] = e
  }
  for (let h = r + 1; h <= s + 1; ++h) a[h] = new ji(0, 0, 0)
  return a
}
function ex(t, e) {
  let n = 1
  for (let s = 2; s <= t; ++s) n *= s
  let i = 1
  for (let s = 2; s <= e; ++s) i *= s
  for (let s = 2; s <= t - e; ++s) i *= s
  return n / i
}
function nx(t) {
  const e = t.length,
    n = [],
    i = []
  for (let r = 0; r < e; ++r) {
    const e = t[r]
    ;(n[r] = new Qi(e.x, e.y, e.z)), (i[r] = e.w)
  }
  const s = []
  for (let r = 0; r < e; ++r) {
    const t = n[r].clone()
    for (let e = 1; e <= r; ++e)
      t.sub(s[r - e].clone().multiplyScalar(ex(r, e) * i[e]))
    s[r] = t.divideScalar(i[0])
  }
  return s
}
function ix(t, e, n, i, s) {
  return nx(tx(t, e, n, i, s))
}
e(function (t, n, i) {
  i || ((i = n), (n = {})), 'function' != typeof i && Fy(7)
  var s = [],
    r = e(function () {
      for (var t = 0; t < s.length; ++t) s[t]()
    }, 'tAll'),
    a = {},
    o = e(function (t, e) {
      Z_(function () {
        i(t, e)
      })
    }, 'cbd')
  Z_(function () {
    o = i
  })
  for (var l = t.length - 22; 101010256 != v_(t, l); --l)
    if (!l || t.length - l > 65558) return o(Fy(13, 0, 1), null), r
  var c = g_(t, l + 8)
  if (c) {
    var h = c,
      u = v_(t, l + 16),
      d = 4294967295 == u || 65535 == h
    if (d) {
      var p = v_(t, l - 12)
      ;(d = 101075792 == v_(t, p)) &&
        ((h = c = v_(t, p + 32)), (u = v_(t, p + 48)))
    }
    for (
      var m = n && n.filter,
        f = e(function (n) {
          var i = W_(t, u, d),
            l = i[0],
            h = i[1],
            p = i[2],
            f = i[3],
            g = i[4],
            v = i[5],
            y = G_(t, v)
          u = g
          var _ = e(function (t, e) {
            t ? (r(), o(t, null)) : (e && (a[f] = e), --c || o(null, a))
          }, 'cbl')
          if (!m || m({ name: f, size: h, originalSize: p, compression: l }))
            if (l)
              if (8 == l) {
                var x = t.subarray(y, y + h)
                if (p < 524288 || h > 0.8 * p)
                  try {
                    _(null, P_(x, { out: new hy(p) }))
                  } catch (b) {
                    _(b, null)
                  }
                else s.push(R_(x, { size: p }, _))
              } else _(Fy(14, 'unknown compression type ' + l, 1), null)
            else _(null, By(t, y, y + h))
          else _(null, null)
        }, '_loop_3'),
        g = 0;
      g < h;
      ++g
    )
      f(g)
  } else o(null, {})
  return r
}, 'unzip'),
  e(function (t, e) {
    for (var n = {}, i = t.length - 22; 101010256 != v_(t, i); --i)
      (!i || t.length - i > 65558) && Fy(13)
    var s = g_(t, i + 8)
    if (!s) return {}
    var r = v_(t, i + 16),
      a = 4294967295 == r || 65535 == s
    if (a) {
      var o = v_(t, i - 12)
      ;(a = 101075792 == v_(t, o)) && ((s = v_(t, o + 32)), (r = v_(t, o + 48)))
    }
    for (var l = e && e.filter, c = 0; c < s; ++c) {
      var h = W_(t, r, a),
        u = h[0],
        d = h[1],
        p = h[2],
        m = h[3],
        f = h[4],
        g = h[5],
        v = G_(t, g)
      ;(r = f),
        (l && !l({ name: m, size: d, originalSize: p, compression: u })) ||
          (u
            ? 8 == u
              ? (n[m] = P_(t.subarray(v, v + d), { out: new hy(p) }))
              : Fy(14, 'unknown compression type ' + u)
            : (n[m] = By(t, v, v + d)))
    }
    return n
  }, 'unzipSync'),
  e(K_, 'findSpan'),
  e($_, 'calcBasisFunctions'),
  e(J_, 'calcBSplinePoint'),
  e(Q_, 'calcBasisFunctionDerivatives'),
  e(tx, 'calcBSplineDerivatives'),
  e(ex, 'calcKoverI'),
  e(nx, 'calcRationalCurveDerivatives'),
  e(ix, 'calcNURBSDerivatives'),
  e(function (t, e, n, i, s, r, a, o) {
    const l = K_(t, r, n),
      c = K_(e, a, i),
      h = $_(l, r, t, n),
      u = $_(c, a, e, i),
      d = []
    for (let m = 0; m <= e; ++m) {
      d[m] = new ji(0, 0, 0, 0)
      for (let n = 0; n <= t; ++n) {
        const i = s[l - t + n][c - e + m].clone(),
          r = i.w
        ;(i.x *= r), (i.y *= r), (i.z *= r), d[m].add(i.multiplyScalar(h[n]))
      }
    }
    const p = new ji(0, 0, 0, 0)
    for (let m = 0; m <= e; ++m) p.add(d[m].multiplyScalar(u[m]))
    p.divideScalar(p.w), o.set(p.x, p.y, p.z)
  }, 'calcSurfacePoint'),
  e(function (t, e, n, i, s, r, a, o, l, c, h) {
    const u = K_(t, o, i),
      d = K_(e, l, s),
      p = K_(n, c, r),
      m = $_(u, o, t, i),
      f = $_(d, l, e, s),
      g = $_(p, c, n, r),
      v = []
    for (let _ = 0; _ <= n; ++_) {
      v[_] = []
      for (let i = 0; i <= e; ++i) {
        v[_][i] = new ji(0, 0, 0, 0)
        for (let s = 0; s <= t; ++s) {
          const r = a[u - t + s][d - e + i][p - n + _].clone(),
            o = r.w
          ;(r.x *= o),
            (r.y *= o),
            (r.z *= o),
            v[_][i].add(r.multiplyScalar(m[s]))
        }
      }
    }
    const y = new ji(0, 0, 0, 0)
    for (let _ = 0; _ <= n; ++_)
      for (let t = 0; t <= e; ++t)
        y.add(v[_][t].multiplyScalar(g[_]).multiplyScalar(f[t]))
    y.divideScalar(y.w), h.set(y.x, y.y, y.z)
  }, 'calcVolumePoint')
class sx extends Iu {
  static {
    e(this, 'NURBSCurve')
  }
  constructor(t, e, n, i, s) {
    super()
    const r = e ? e.length - 1 : 0,
      a = n ? n.length : 0
    ;(this.degree = t),
      (this.knots = e),
      (this.controlPoints = []),
      (this.startKnot = i || 0),
      (this.endKnot = s || r)
    for (let o = 0; o < a; ++o) {
      const t = n[o]
      this.controlPoints[o] = new ji(t.x, t.y, t.z, t.w)
    }
  }
  getPoint(t, e = new Qi()) {
    const n = e,
      i =
        this.knots[this.startKnot] +
        t * (this.knots[this.endKnot] - this.knots[this.startKnot]),
      s = J_(this.degree, this.knots, this.controlPoints, i)
    return 1 !== s.w && s.divideScalar(s.w), n.set(s.x, s.y, s.z)
  }
  getTangent(t, e = new Qi()) {
    const n = e,
      i =
        this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]),
      s = ix(this.degree, this.knots, this.controlPoints, i, 1)
    return n.copy(s[1]).normalize(), n
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.degree = this.degree),
      (t.knots = [...this.knots]),
      (t.controlPoints = this.controlPoints.map((t) => t.toArray())),
      (t.startKnot = this.startKnot),
      (t.endKnot = this.endKnot),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      (this.degree = t.degree),
      (this.knots = [...t.knots]),
      (this.controlPoints = t.controlPoints.map(
        (t) => new ji(t[0], t[1], t[2], t[3])
      )),
      (this.startKnot = t.startKnot),
      (this.endKnot = t.endKnot),
      this
    )
  }
}
let rx, ax, ox
class lx extends $p {
  static {
    e(this, 'FBXLoader')
  }
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    const s = this,
      r = '' === s.path ? Am.extractUrlBase(t) : s.path,
      a = new tm(this.manager)
    a.setPath(s.path),
      a.setResponseType('arraybuffer'),
      a.setRequestHeader(s.requestHeader),
      a.setWithCredentials(s.withCredentials),
      a.load(
        t,
        function (n) {
          try {
            e(s.parse(n, r))
          } catch (zx) {
            i ? i(zx) : console.error(zx), s.manager.itemError(t)
          }
        },
        n,
        i
      )
  }
  parse(t, e) {
    if (gx(t)) rx = new px().parse(t)
    else {
      const e = Ax(t)
      if (!vx(e)) throw new Error('THREE.FBXLoader: Unknown format.')
      if (yx(e) < 7e3)
        throw new Error(
          'THREE.FBXLoader: FBX version not supported, FileVersion: ' + yx(e)
        )
      rx = new dx().parse(e)
    }
    const n = new am(this.manager)
      .setPath(this.resourcePath || e)
      .setCrossOrigin(this.crossOrigin)
    return new cx(n, this.manager).parse(rx)
  }
}
class cx {
  static {
    e(this, 'FBXTreeParser')
  }
  constructor(t, e) {
    ;(this.textureLoader = t), (this.manager = e)
  }
  parse() {
    ax = this.parseConnections()
    const t = this.parseImages(),
      e = this.parseTextures(t),
      n = this.parseMaterials(e),
      i = this.parseDeformers(),
      s = new hx().parse(i)
    return this.parseScene(i, s, n), ox
  }
  parseConnections() {
    const t = new Map()
    if ('Connections' in rx) {
      rx.Connections.connections.forEach(function (e) {
        const n = e[0],
          i = e[1],
          s = e[2]
        t.has(n) || t.set(n, { parents: [], children: [] })
        const r = { ID: i, relationship: s }
        t.get(n).parents.push(r),
          t.has(i) || t.set(i, { parents: [], children: [] })
        const a = { ID: n, relationship: s }
        t.get(i).children.push(a)
      })
    }
    return t
  }
  parseImages() {
    const t = {},
      e = {}
    if ('Video' in rx.Objects) {
      const n = rx.Objects.Video
      for (const i in n) {
        const s = n[i]
        if (
          ((t[parseInt(i)] = s.RelativeFilename || s.Filename), 'Content' in s)
        ) {
          const t =
              s.Content instanceof ArrayBuffer && s.Content.byteLength > 0,
            r = 'string' == typeof s.Content && '' !== s.Content
          if (t || r) {
            const t = this.parseImage(n[i])
            e[s.RelativeFilename || s.Filename] = t
          }
        }
      }
    }
    for (const n in t) {
      const i = t[n]
      void 0 !== e[i] ? (t[n] = e[i]) : (t[n] = t[n].split('\\').pop())
    }
    return t
  }
  parseImage(t) {
    const e = t.Content,
      n = t.RelativeFilename || t.Filename,
      i = n.slice(n.lastIndexOf('.') + 1).toLowerCase()
    let s
    switch (i) {
      case 'bmp':
        s = 'image/bmp'
        break
      case 'jpg':
      case 'jpeg':
        s = 'image/jpeg'
        break
      case 'png':
        s = 'image/png'
        break
      case 'tif':
        s = 'image/tiff'
        break
      case 'tga':
        null === this.manager.getHandler('.tga') &&
          console.warn('FBXLoader: TGA loader not found, skipping ', n),
          (s = 'image/tga')
        break
      default:
        return void console.warn(
          'FBXLoader: Image type "' + i + '" is not supported.'
        )
    }
    if ('string' == typeof e) return 'data:' + s + ';base64,' + e
    {
      const t = new Uint8Array(e)
      return window.URL.createObjectURL(new Blob([t], { type: s }))
    }
  }
  parseTextures(t) {
    const e = new Map()
    if ('Texture' in rx.Objects) {
      const n = rx.Objects.Texture
      for (const i in n) {
        const s = this.parseTexture(n[i], t)
        e.set(parseInt(i), s)
      }
    }
    return e
  }
  parseTexture(t, e) {
    const n = this.loadTexture(t, e)
    ;(n.ID = t.id), (n.name = t.attrName)
    const i = t.WrapModeU,
      s = t.WrapModeV,
      r = void 0 !== i ? i.value : 0,
      a = void 0 !== s ? s.value : 0
    if (
      ((n.wrapS = 0 === r ? me : fe),
      (n.wrapT = 0 === a ? me : fe),
      'Scaling' in t)
    ) {
      const e = t.Scaling.value
      ;(n.repeat.x = e[0]), (n.repeat.y = e[1])
    }
    if ('Translation' in t) {
      const e = t.Translation.value
      ;(n.offset.x = e[0]), (n.offset.y = e[1])
    }
    return n
  }
  loadTexture(t, e) {
    const n = new Set(['tga', 'tif', 'tiff', 'exr', 'dds', 'hdr', 'ktx2']),
      i = t.FileName.split('.').pop().toLowerCase(),
      s = n.has(i) ? this.manager.getHandler(`.${i}`) : this.textureLoader
    if (!s)
      return (
        console.warn(
          `FBXLoader: ${i.toUpperCase()} loader not found, creating placeholder texture for`,
          t.RelativeFilename
        ),
        new Wi()
      )
    const r = s.path
    r || s.setPath(this.textureLoader.path)
    const a = ax.get(t.id).children
    let o
    void 0 !== a &&
      a.length > 0 &&
      void 0 !== e[a[0].ID] &&
      ((o = e[a[0].ID]),
      (0 !== o.indexOf('blob:') && 0 !== o.indexOf('data:')) ||
        s.setPath(void 0))
    const l = s.load(o)
    return s.setPath(r), l
  }
  parseMaterials(t) {
    const e = new Map()
    if ('Material' in rx.Objects) {
      const n = rx.Objects.Material
      for (const i in n) {
        const s = this.parseMaterial(n[i], t)
        null !== s && e.set(parseInt(i), s)
      }
    }
    return e
  }
  parseMaterial(t, e) {
    const n = t.id,
      i = t.attrName
    let s = t.ShadingModel
    if (('object' == typeof s && (s = s.value), !ax.has(n))) return null
    const r = this.parseParameters(t, e, n)
    let a
    switch (s.toLowerCase()) {
      case 'phong':
        a = new xp()
        break
      case 'lambert':
        a = new Mp()
        break
      default:
        console.warn(
          'THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',
          s
        ),
          (a = new xp())
    }
    return a.setValues(r), (a.name = i), a
  }
  parseParameters(t, e, n) {
    const i = {}
    t.BumpFactor && (i.bumpScale = t.BumpFactor.value),
      t.Diffuse
        ? (i.color = Pi.toWorkingColorSpace(
            new br().fromArray(t.Diffuse.value),
            En
          ))
        : !t.DiffuseColor ||
          ('Color' !== t.DiffuseColor.type &&
            'ColorRGB' !== t.DiffuseColor.type) ||
          (i.color = Pi.toWorkingColorSpace(
            new br().fromArray(t.DiffuseColor.value),
            En
          )),
      t.DisplacementFactor &&
        (i.displacementScale = t.DisplacementFactor.value),
      t.Emissive
        ? (i.emissive = Pi.toWorkingColorSpace(
            new br().fromArray(t.Emissive.value),
            En
          ))
        : !t.EmissiveColor ||
          ('Color' !== t.EmissiveColor.type &&
            'ColorRGB' !== t.EmissiveColor.type) ||
          (i.emissive = Pi.toWorkingColorSpace(
            new br().fromArray(t.EmissiveColor.value),
            En
          )),
      t.EmissiveFactor &&
        (i.emissiveIntensity = parseFloat(t.EmissiveFactor.value)),
      (i.opacity =
        1 -
        (t.TransparencyFactor ? parseFloat(t.TransparencyFactor.value) : 0)),
      (1 !== i.opacity && 0 !== i.opacity) ||
        ((i.opacity = t.Opacity ? parseFloat(t.Opacity.value) : null),
        null === i.opacity &&
          (i.opacity =
            1 -
            (t.TransparentColor
              ? parseFloat(t.TransparentColor.value[0])
              : 0))),
      i.opacity < 1 && (i.transparent = !0),
      t.ReflectionFactor && (i.reflectivity = t.ReflectionFactor.value),
      t.Shininess && (i.shininess = t.Shininess.value),
      t.Specular
        ? (i.specular = Pi.toWorkingColorSpace(
            new br().fromArray(t.Specular.value),
            En
          ))
        : t.SpecularColor &&
          'Color' === t.SpecularColor.type &&
          (i.specular = Pi.toWorkingColorSpace(
            new br().fromArray(t.SpecularColor.value),
            En
          ))
    const s = this
    return (
      ax.get(n).children.forEach(function (t) {
        const n = t.relationship
        switch (n) {
          case 'Bump':
            i.bumpMap = s.getTexture(e, t.ID)
            break
          case 'Maya|TEX_ao_map':
            i.aoMap = s.getTexture(e, t.ID)
            break
          case 'DiffuseColor':
          case 'Maya|TEX_color_map':
            ;(i.map = s.getTexture(e, t.ID)),
              void 0 !== i.map && (i.map.colorSpace = En)
            break
          case 'DisplacementColor':
            i.displacementMap = s.getTexture(e, t.ID)
            break
          case 'EmissiveColor':
            ;(i.emissiveMap = s.getTexture(e, t.ID)),
              void 0 !== i.emissiveMap && (i.emissiveMap.colorSpace = En)
            break
          case 'NormalMap':
          case 'Maya|TEX_normal_map':
            i.normalMap = s.getTexture(e, t.ID)
            break
          case 'ReflectionColor':
            ;(i.envMap = s.getTexture(e, t.ID)),
              void 0 !== i.envMap &&
                ((i.envMap.mapping = ue), (i.envMap.colorSpace = En))
            break
          case 'SpecularColor':
            ;(i.specularMap = s.getTexture(e, t.ID)),
              void 0 !== i.specularMap && (i.specularMap.colorSpace = En)
            break
          case 'TransparentColor':
          case 'TransparencyFactor':
            ;(i.alphaMap = s.getTexture(e, t.ID)), (i.transparent = !0)
            break
          default:
            console.warn(
              'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.',
              n
            )
        }
      }),
      i
    )
  }
  getTexture(t, e) {
    return (
      'LayeredTexture' in rx.Objects &&
        e in rx.Objects.LayeredTexture &&
        (console.warn(
          'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.'
        ),
        (e = ax.get(e).children[0].ID)),
      t.get(e)
    )
  }
  parseDeformers() {
    const t = {},
      e = {}
    if ('Deformer' in rx.Objects) {
      const n = rx.Objects.Deformer
      for (const i in n) {
        const s = n[i],
          r = ax.get(parseInt(i))
        if ('Skin' === s.attrType) {
          const e = this.parseSkeleton(r, n)
          ;(e.ID = i),
            r.parents.length > 1 &&
              console.warn(
                'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.'
              ),
            (e.geometryID = r.parents[0].ID),
            (t[i] = e)
        } else if ('BlendShape' === s.attrType) {
          const t = { id: i }
          ;(t.rawTargets = this.parseMorphTargets(r, n)),
            (t.id = i),
            r.parents.length > 1 &&
              console.warn(
                'THREE.FBXLoader: morph target attached to more than one geometry is not supported.'
              ),
            (e[i] = t)
        }
      }
    }
    return { skeletons: t, morphTargets: e }
  }
  parseSkeleton(t, e) {
    const n = []
    return (
      t.children.forEach(function (t) {
        const i = e[t.ID]
        if ('Cluster' !== i.attrType) return
        const s = {
          ID: t.ID,
          indices: [],
          weights: [],
          transformLink: new Rs().fromArray(i.TransformLink.a)
        }
        'Indexes' in i &&
          ((s.indices = i.Indexes.a), (s.weights = i.Weights.a)),
          n.push(s)
      }),
      { rawBones: n, bones: [] }
    )
  }
  parseMorphTargets(t, e) {
    const n = []
    for (let i = 0; i < t.children.length; i++) {
      const s = t.children[i],
        r = e[s.ID],
        a = {
          name: r.attrName,
          initialWeight: r.DeformPercent,
          id: r.id,
          fullWeights: r.FullWeights.a
        }
      if ('BlendShapeChannel' !== r.attrType) return
      ;(a.geoID = ax.get(parseInt(s.ID)).children.filter(function (t) {
        return void 0 === t.relationship
      })[0].ID),
        n.push(a)
    }
    return n
  }
  parseScene(t, e, n) {
    ox = new Nc()
    const i = this.parseModels(t.skeletons, e, n),
      s = rx.Objects.Model,
      r = this
    i.forEach(function (t) {
      const e = s[t.ID]
      r.setLookAtProperties(t, e)
      ax.get(t.ID).parents.forEach(function (e) {
        const n = i.get(e.ID)
        void 0 !== n && n.add(t)
      }),
        null === t.parent && ox.add(t)
    }),
      this.bindSkeleton(t.skeletons, e, i),
      this.addGlobalSceneSettings(),
      ox.traverse(function (t) {
        if (t.userData.transformData) {
          t.parent &&
            ((t.userData.transformData.parentMatrix = t.parent.matrix),
            (t.userData.transformData.parentMatrixWorld = t.parent.matrixWorld))
          const e = Sx(t.userData.transformData)
          t.applyMatrix4(e), t.updateWorldMatrix()
        }
      })
    const a = new ux().parse()
    1 === ox.children.length &&
      ox.children[0].isGroup &&
      ((ox.children[0].animations = a), (ox = ox.children[0])),
      (ox.animations = a)
  }
  parseModels(t, e, n) {
    const i = new Map(),
      s = rx.Objects.Model
    for (const r in s) {
      const a = parseInt(r),
        o = s[r],
        l = ax.get(a)
      let c = this.buildSkeleton(l, t, a, o.attrName)
      if (!c) {
        switch (o.attrType) {
          case 'Camera':
            c = this.createCamera(l)
            break
          case 'Light':
            c = this.createLight(l)
            break
          case 'Mesh':
            c = this.createMesh(l, e, n)
            break
          case 'NurbsCurve':
            c = this.createCurve(l, e)
            break
          case 'LimbNode':
          case 'Root':
            c = new Eh()
            break
          default:
            c = new Nc()
        }
        ;(c.name = o.attrName ? uf.sanitizeNodeName(o.attrName) : ''),
          (c.userData.originalName = o.attrName),
          (c.ID = a)
      }
      this.getTransformData(c, o), i.set(a, c)
    }
    return i
  }
  buildSkeleton(t, e, n, i) {
    let s = null
    return (
      t.parents.forEach(function (t) {
        for (const r in e) {
          const a = e[r]
          a.rawBones.forEach(function (e, r) {
            if (e.ID === t.ID) {
              const t = s
              ;(s = new Eh()),
                s.matrixWorld.copy(e.transformLink),
                (s.name = i ? uf.sanitizeNodeName(i) : ''),
                (s.userData.originalName = i),
                (s.ID = n),
                (a.bones[r] = s),
                null !== t && s.add(t)
            }
          })
        }
      }),
      s
    )
  }
  createCamera(t) {
    let e, n
    if (
      (t.children.forEach(function (t) {
        const e = rx.Objects.NodeAttribute[t.ID]
        void 0 !== e && (n = e)
      }),
      void 0 === n)
    )
      e = new nr()
    else {
      let t = 0
      void 0 !== n.CameraProjectionType &&
        1 === n.CameraProjectionType.value &&
        (t = 1)
      let i = 1
      void 0 !== n.NearPlane && (i = n.NearPlane.value / 1e3)
      let s = 1e3
      void 0 !== n.FarPlane && (s = n.FarPlane.value / 1e3)
      let r = window.innerWidth,
        a = window.innerHeight
      void 0 !== n.AspectWidth &&
        void 0 !== n.AspectHeight &&
        ((r = n.AspectWidth.value), (a = n.AspectHeight.value))
      const o = r / a
      let l = 45
      void 0 !== n.FieldOfView && (l = n.FieldOfView.value)
      const c = n.FocalLength ? n.FocalLength.value : null
      switch (t) {
        case 0:
          ;(e = new ba(l, o, i, s)), null !== c && e.setFocalLength(c)
          break
        case 1:
          console.warn(
            'THREE.FBXLoader: Orthographic cameras not supported yet.'
          ),
            (e = new nr())
          break
        default:
          console.warn('THREE.FBXLoader: Unknown camera type ' + t + '.'),
            (e = new nr())
      }
    }
    return e
  }
  createLight(t) {
    let e, n
    if (
      (t.children.forEach(function (t) {
        const e = rx.Objects.NodeAttribute[t.ID]
        void 0 !== e && (n = e)
      }),
      void 0 === n)
    )
      e = new nr()
    else {
      let t
      t = void 0 === n.LightType ? 0 : n.LightType.value
      let i = 16777215
      void 0 !== n.Color &&
        (i = Pi.toWorkingColorSpace(new br().fromArray(n.Color.value), En))
      let s = void 0 === n.Intensity ? 1 : n.Intensity.value / 100
      void 0 !== n.CastLightOnObject &&
        0 === n.CastLightOnObject.value &&
        (s = 0)
      let r = 0
      void 0 !== n.FarAttenuationEnd &&
        (r =
          void 0 !== n.EnableFarAttenuation &&
          0 === n.EnableFarAttenuation.value
            ? 0
            : n.FarAttenuationEnd.value)
      const a = 1
      switch (t) {
        case 0:
          e = new _m(i, s, r, a)
          break
        case 1:
          e = new bm(i, s)
          break
        case 2:
          let t = Math.PI / 3
          void 0 !== n.InnerAngle && (t = gi.degToRad(n.InnerAngle.value))
          let o = 0
          void 0 !== n.OuterAngle &&
            ((o = gi.degToRad(n.OuterAngle.value)), (o = Math.max(o, 1))),
            (e = new mm(i, s, r, t, o, a))
          break
        default:
          console.warn(
            'THREE.FBXLoader: Unknown light type ' +
              n.LightType.value +
              ', defaulting to a PointLight.'
          ),
            (e = new _m(i, s))
      }
      void 0 !== n.CastShadows &&
        1 === n.CastShadows.value &&
        (e.castShadow = !0)
    }
    return e
  }
  createMesh(t, e, n) {
    let i,
      s = null,
      r = null
    const a = []
    return (
      t.children.forEach(function (t) {
        e.has(t.ID) && (s = e.get(t.ID)), n.has(t.ID) && a.push(n.get(t.ID))
      }),
      a.length > 1
        ? (r = a)
        : a.length > 0
          ? (r = a[0])
          : ((r = new xp({ name: $p.DEFAULT_MATERIAL_NAME, color: 13421772 })),
            a.push(r)),
      'color' in s.attributes &&
        a.forEach(function (t) {
          t.vertexColors = !0
        }),
      s.FBX_Deformer
        ? ((i = new Th(s, r)), i.normalizeSkinWeights())
        : (i = new oa(s, r)),
      i
    )
  }
  createCurve(t, e) {
    const n = t.children.reduce(function (t, n) {
        return e.has(n.ID) && (t = e.get(n.ID)), t
      }, null),
      i = new su({
        name: $p.DEFAULT_MATERIAL_NAME,
        color: 3342591,
        linewidth: 1
      })
    return new du(n, i)
  }
  getTransformData(t, e) {
    const n = {}
    'InheritType' in e && (n.inheritType = parseInt(e.InheritType.value)),
      (n.eulerOrder = Tx('RotationOrder' in e ? e.RotationOrder.value : 0)),
      'Lcl_Translation' in e && (n.translation = e.Lcl_Translation.value),
      'PreRotation' in e && (n.preRotation = e.PreRotation.value),
      'Lcl_Rotation' in e && (n.rotation = e.Lcl_Rotation.value),
      'PostRotation' in e && (n.postRotation = e.PostRotation.value),
      'Lcl_Scaling' in e && (n.scale = e.Lcl_Scaling.value),
      'ScalingOffset' in e && (n.scalingOffset = e.ScalingOffset.value),
      'ScalingPivot' in e && (n.scalingPivot = e.ScalingPivot.value),
      'RotationOffset' in e && (n.rotationOffset = e.RotationOffset.value),
      'RotationPivot' in e && (n.rotationPivot = e.RotationPivot.value),
      (t.userData.transformData = n)
  }
  setLookAtProperties(t, e) {
    if ('LookAtProperty' in e) {
      ax.get(t.ID).children.forEach(function (e) {
        if ('LookAtProperty' === e.relationship) {
          const n = rx.Objects.Model[e.ID]
          if ('Lcl_Translation' in n) {
            const e = n.Lcl_Translation.value
            void 0 !== t.target
              ? (t.target.position.fromArray(e), ox.add(t.target))
              : t.lookAt(new Qi().fromArray(e))
          }
        }
      })
    }
  }
  bindSkeleton(t, e, n) {
    const i = this.parsePoseNodes()
    for (const s in t) {
      const r = t[s]
      ax.get(parseInt(r.ID)).parents.forEach(function (t) {
        if (e.has(t.ID)) {
          const e = t.ID
          ax.get(e).parents.forEach(function (t) {
            if (n.has(t.ID)) {
              n.get(t.ID).bind(new Ph(r.bones), i[t.ID])
            }
          })
        }
      })
    }
  }
  parsePoseNodes() {
    const t = {}
    if ('Pose' in rx.Objects) {
      const e = rx.Objects.Pose
      for (const n in e)
        if ('BindPose' === e[n].attrType && e[n].NbPoseNodes > 0) {
          const i = e[n].PoseNode
          Array.isArray(i)
            ? i.forEach(function (e) {
                t[e.Node] = new Rs().fromArray(e.Matrix.a)
              })
            : (t[i.Node] = new Rs().fromArray(i.Matrix.a))
        }
    }
    return t
  }
  addGlobalSceneSettings() {
    if ('GlobalSettings' in rx) {
      if ('AmbientColor' in rx.GlobalSettings) {
        const t = rx.GlobalSettings.AmbientColor.value,
          e = t[0],
          n = t[1],
          i = t[2]
        if (0 !== e || 0 !== n || 0 !== i) {
          const t = new br().setRGB(e, n, i, En)
          ox.add(new wm(t, 1))
        }
      }
      'UnitScaleFactor' in rx.GlobalSettings &&
        (ox.userData.unitScaleFactor = rx.GlobalSettings.UnitScaleFactor.value)
    }
  }
}
class hx {
  static {
    e(this, 'GeometryParser')
  }
  constructor() {
    this.negativeMaterialIndices = !1
  }
  parse(t) {
    const e = new Map()
    if ('Geometry' in rx.Objects) {
      const n = rx.Objects.Geometry
      for (const i in n) {
        const s = ax.get(parseInt(i)),
          r = this.parseGeometry(s, n[i], t)
        e.set(parseInt(i), r)
      }
    }
    return (
      !0 === this.negativeMaterialIndices &&
        console.warn(
          'THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.'
        ),
      e
    )
  }
  parseGeometry(t, e, n) {
    switch (e.attrType) {
      case 'Mesh':
        return this.parseMeshGeometry(t, e, n)
      case 'NurbsCurve':
        return this.parseNurbsGeometry(e)
    }
  }
  parseMeshGeometry(t, e, n) {
    const i = n.skeletons,
      s = [],
      r = t.parents.map(function (t) {
        return rx.Objects.Model[t.ID]
      })
    if (0 === r.length) return
    const a = t.children.reduce(function (t, e) {
      return void 0 !== i[e.ID] && (t = i[e.ID]), t
    }, null)
    t.children.forEach(function (t) {
      void 0 !== n.morphTargets[t.ID] && s.push(n.morphTargets[t.ID])
    })
    const o = r[0],
      l = {}
    'RotationOrder' in o && (l.eulerOrder = Tx(o.RotationOrder.value)),
      'InheritType' in o && (l.inheritType = parseInt(o.InheritType.value)),
      'GeometricTranslation' in o &&
        (l.translation = o.GeometricTranslation.value),
      'GeometricRotation' in o && (l.rotation = o.GeometricRotation.value),
      'GeometricScaling' in o && (l.scale = o.GeometricScaling.value)
    const c = Sx(l)
    return this.genGeometry(e, a, s, c)
  }
  genGeometry(t, e, n, i) {
    const s = new Zr()
    t.attrName && (s.name = t.attrName)
    const r = this.parseGeoNode(t, e),
      a = this.genBuffers(r),
      o = new Vr(a.vertex, 3)
    if (
      (o.applyMatrix4(i),
      s.setAttribute('position', o),
      a.colors.length > 0 && s.setAttribute('color', new Vr(a.colors, 3)),
      e &&
        (s.setAttribute('skinIndex', new Br(a.weightsIndices, 4)),
        s.setAttribute('skinWeight', new Vr(a.vertexWeights, 4)),
        (s.FBX_Deformer = e)),
      a.normal.length > 0)
    ) {
      const t = new yi().getNormalMatrix(i),
        e = new Vr(a.normal, 3)
      e.applyNormalMatrix(t), s.setAttribute('normal', e)
    }
    if (
      (a.uvs.forEach(function (t, e) {
        const n = 0 === e ? 'uv' : `uv${e}`
        s.setAttribute(n, new Vr(a.uvs[e], 2))
      }),
      r.material && 'AllSame' !== r.material.mappingType)
    ) {
      let t = a.materialIndex[0],
        e = 0
      if (
        (a.materialIndex.forEach(function (n, i) {
          n !== t && (s.addGroup(e, i - e, t), (t = n), (e = i))
        }),
        s.groups.length > 0)
      ) {
        const e = s.groups[s.groups.length - 1],
          n = e.start + e.count
        n !== a.materialIndex.length &&
          s.addGroup(n, a.materialIndex.length - n, t)
      }
      0 === s.groups.length &&
        s.addGroup(0, a.materialIndex.length, a.materialIndex[0])
    }
    return this.addMorphTargets(s, t, n, i), s
  }
  parseGeoNode(t, e) {
    const n = {}
    if (
      ((n.vertexPositions = void 0 !== t.Vertices ? t.Vertices.a : []),
      (n.vertexIndices =
        void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : []),
      t.LayerElementColor &&
        (n.color = this.parseVertexColors(t.LayerElementColor[0])),
      t.LayerElementMaterial &&
        (n.material = this.parseMaterialIndices(t.LayerElementMaterial[0])),
      t.LayerElementNormal &&
        (n.normal = this.parseNormals(t.LayerElementNormal[0])),
      t.LayerElementUV)
    ) {
      n.uv = []
      let e = 0
      for (; t.LayerElementUV[e]; )
        t.LayerElementUV[e].UV && n.uv.push(this.parseUVs(t.LayerElementUV[e])),
          e++
    }
    return (
      (n.weightTable = {}),
      null !== e &&
        ((n.skeleton = e),
        e.rawBones.forEach(function (t, e) {
          t.indices.forEach(function (i, s) {
            void 0 === n.weightTable[i] && (n.weightTable[i] = []),
              n.weightTable[i].push({ id: e, weight: t.weights[s] })
          })
        })),
      n
    )
  }
  genBuffers(t) {
    const e = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    }
    let n = 0,
      i = 0,
      s = !1,
      r = [],
      a = [],
      o = [],
      l = [],
      c = [],
      h = []
    const u = this
    return (
      t.vertexIndices.forEach(function (d, p) {
        let m,
          f = !1
        d < 0 && ((d = ~d), (f = !0))
        let g = [],
          v = []
        if ((r.push(3 * d, 3 * d + 1, 3 * d + 2), t.color)) {
          const e = bx(p, n, d, t.color)
          o.push(e[0], e[1], e[2])
        }
        if (t.skeleton) {
          if (
            (void 0 !== t.weightTable[d] &&
              t.weightTable[d].forEach(function (t) {
                v.push(t.weight), g.push(t.id)
              }),
            v.length > 4)
          ) {
            s ||
              (console.warn(
                'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.'
              ),
              (s = !0))
            const t = [0, 0, 0, 0],
              e = [0, 0, 0, 0]
            v.forEach(function (n, i) {
              let s = n,
                r = g[i]
              e.forEach(function (e, n, i) {
                if (s > e) {
                  ;(i[n] = s), (s = e)
                  const a = t[n]
                  ;(t[n] = r), (r = a)
                }
              })
            }),
              (g = t),
              (v = e)
          }
          for (; v.length < 4; ) v.push(0), g.push(0)
          for (let t = 0; t < 4; ++t) c.push(v[t]), h.push(g[t])
        }
        if (t.normal) {
          const e = bx(p, n, d, t.normal)
          a.push(e[0], e[1], e[2])
        }
        t.material &&
          'AllSame' !== t.material.mappingType &&
          ((m = bx(p, n, d, t.material)[0]),
          m < 0 && ((u.negativeMaterialIndices = !0), (m = 0))),
          t.uv &&
            t.uv.forEach(function (t, e) {
              const i = bx(p, n, d, t)
              void 0 === l[e] && (l[e] = []), l[e].push(i[0]), l[e].push(i[1])
            }),
          i++,
          f &&
            (u.genFace(e, t, r, m, a, o, l, c, h, i),
            n++,
            (i = 0),
            (r = []),
            (a = []),
            (o = []),
            (l = []),
            (c = []),
            (h = []))
      }),
      e
    )
  }
  getNormalNewell(t) {
    const e = new Qi(0, 0, 0)
    for (let n = 0; n < t.length; n++) {
      const i = t[n],
        s = t[(n + 1) % t.length]
      ;(e.x += (i.y - s.y) * (i.z + s.z)),
        (e.y += (i.z - s.z) * (i.x + s.x)),
        (e.z += (i.x - s.x) * (i.y + s.y))
    }
    return e.normalize(), e
  }
  getNormalTangentAndBitangent(t) {
    const e = this.getNormalNewell(t),
      n = (Math.abs(e.z) > 0.5 ? new Qi(0, 1, 0) : new Qi(0, 0, 1))
        .cross(e)
        .normalize(),
      i = e.clone().cross(n).normalize()
    return { normal: e, tangent: n, bitangent: i }
  }
  flattenVertex(t, e, n) {
    return new vi(t.dot(e), t.dot(n))
  }
  genFace(t, e, n, i, s, r, a, o, l, c) {
    let h
    if (c > 3) {
      const t = [],
        i = e.baseVertexPositions || e.vertexPositions
      for (let e = 0; e < n.length; e += 3)
        t.push(new Qi(i[n[e]], i[n[e + 1]], i[n[e + 2]]))
      const { tangent: s, bitangent: r } = this.getNormalTangentAndBitangent(t),
        a = []
      for (const e of t) a.push(this.flattenVertex(e, s, r))
      h = $d.triangulateShape(a, [])
    } else h = [[0, 1, 2]]
    for (const [u, d, p] of h)
      t.vertex.push(e.vertexPositions[n[3 * u]]),
        t.vertex.push(e.vertexPositions[n[3 * u + 1]]),
        t.vertex.push(e.vertexPositions[n[3 * u + 2]]),
        t.vertex.push(e.vertexPositions[n[3 * d]]),
        t.vertex.push(e.vertexPositions[n[3 * d + 1]]),
        t.vertex.push(e.vertexPositions[n[3 * d + 2]]),
        t.vertex.push(e.vertexPositions[n[3 * p]]),
        t.vertex.push(e.vertexPositions[n[3 * p + 1]]),
        t.vertex.push(e.vertexPositions[n[3 * p + 2]]),
        e.skeleton &&
          (t.vertexWeights.push(o[4 * u]),
          t.vertexWeights.push(o[4 * u + 1]),
          t.vertexWeights.push(o[4 * u + 2]),
          t.vertexWeights.push(o[4 * u + 3]),
          t.vertexWeights.push(o[4 * d]),
          t.vertexWeights.push(o[4 * d + 1]),
          t.vertexWeights.push(o[4 * d + 2]),
          t.vertexWeights.push(o[4 * d + 3]),
          t.vertexWeights.push(o[4 * p]),
          t.vertexWeights.push(o[4 * p + 1]),
          t.vertexWeights.push(o[4 * p + 2]),
          t.vertexWeights.push(o[4 * p + 3]),
          t.weightsIndices.push(l[4 * u]),
          t.weightsIndices.push(l[4 * u + 1]),
          t.weightsIndices.push(l[4 * u + 2]),
          t.weightsIndices.push(l[4 * u + 3]),
          t.weightsIndices.push(l[4 * d]),
          t.weightsIndices.push(l[4 * d + 1]),
          t.weightsIndices.push(l[4 * d + 2]),
          t.weightsIndices.push(l[4 * d + 3]),
          t.weightsIndices.push(l[4 * p]),
          t.weightsIndices.push(l[4 * p + 1]),
          t.weightsIndices.push(l[4 * p + 2]),
          t.weightsIndices.push(l[4 * p + 3])),
        e.color &&
          (t.colors.push(r[3 * u]),
          t.colors.push(r[3 * u + 1]),
          t.colors.push(r[3 * u + 2]),
          t.colors.push(r[3 * d]),
          t.colors.push(r[3 * d + 1]),
          t.colors.push(r[3 * d + 2]),
          t.colors.push(r[3 * p]),
          t.colors.push(r[3 * p + 1]),
          t.colors.push(r[3 * p + 2])),
        e.material &&
          'AllSame' !== e.material.mappingType &&
          (t.materialIndex.push(i),
          t.materialIndex.push(i),
          t.materialIndex.push(i)),
        e.normal &&
          (t.normal.push(s[3 * u]),
          t.normal.push(s[3 * u + 1]),
          t.normal.push(s[3 * u + 2]),
          t.normal.push(s[3 * d]),
          t.normal.push(s[3 * d + 1]),
          t.normal.push(s[3 * d + 2]),
          t.normal.push(s[3 * p]),
          t.normal.push(s[3 * p + 1]),
          t.normal.push(s[3 * p + 2])),
        e.uv &&
          e.uv.forEach(function (e, n) {
            void 0 === t.uvs[n] && (t.uvs[n] = []),
              t.uvs[n].push(a[n][2 * u]),
              t.uvs[n].push(a[n][2 * u + 1]),
              t.uvs[n].push(a[n][2 * d]),
              t.uvs[n].push(a[n][2 * d + 1]),
              t.uvs[n].push(a[n][2 * p]),
              t.uvs[n].push(a[n][2 * p + 1])
          })
  }
  addMorphTargets(t, e, n, i) {
    if (0 === n.length) return
    ;(t.morphTargetsRelative = !0), (t.morphAttributes.position = [])
    const s = this
    n.forEach(function (n) {
      n.rawTargets.forEach(function (n) {
        const r = rx.Objects.Geometry[n.geoID]
        void 0 !== r && s.genMorphGeometry(t, e, r, i, n.name)
      })
    })
  }
  genMorphGeometry(t, e, n, i, s) {
    const r = void 0 !== e.Vertices ? e.Vertices.a : [],
      a = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [],
      o = void 0 !== n.Vertices ? n.Vertices.a : [],
      l = void 0 !== n.Indexes ? n.Indexes.a : [],
      c = 3 * t.attributes.position.count,
      h = new Float32Array(c)
    for (let m = 0; m < l.length; m++) {
      const t = 3 * l[m]
      ;(h[t] = o[3 * m]), (h[t + 1] = o[3 * m + 1]), (h[t + 2] = o[3 * m + 2])
    }
    const u = { vertexIndices: a, vertexPositions: h, baseVertexPositions: r },
      d = this.genBuffers(u),
      p = new Vr(d.vertex, 3)
    ;(p.name = s || n.attrName),
      p.applyMatrix4(i),
      t.morphAttributes.position.push(p)
  }
  parseNormals(t) {
    const e = t.MappingInformationType,
      n = t.ReferenceInformationType,
      i = t.Normals.a
    let s = []
    return (
      'IndexToDirect' === n &&
        ('NormalIndex' in t
          ? (s = t.NormalIndex.a)
          : 'NormalsIndex' in t && (s = t.NormalsIndex.a)),
      { dataSize: 3, buffer: i, indices: s, mappingType: e, referenceType: n }
    )
  }
  parseUVs(t) {
    const e = t.MappingInformationType,
      n = t.ReferenceInformationType,
      i = t.UV.a
    let s = []
    return (
      'IndexToDirect' === n && (s = t.UVIndex.a),
      { dataSize: 2, buffer: i, indices: s, mappingType: e, referenceType: n }
    )
  }
  parseVertexColors(t) {
    const e = t.MappingInformationType,
      n = t.ReferenceInformationType,
      i = t.Colors.a
    let s = []
    'IndexToDirect' === n && (s = t.ColorIndex.a)
    for (let r = 0, a = new br(); r < i.length; r += 4)
      a.fromArray(i, r), Pi.toWorkingColorSpace(a, En), a.toArray(i, r)
    return {
      dataSize: 4,
      buffer: i,
      indices: s,
      mappingType: e,
      referenceType: n
    }
  }
  parseMaterialIndices(t) {
    const e = t.MappingInformationType,
      n = t.ReferenceInformationType
    if ('NoMappingInformation' === e)
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: 'AllSame',
        referenceType: n
      }
    const i = t.Materials.a,
      s = []
    for (let r = 0; r < i.length; ++r) s.push(r)
    return {
      dataSize: 1,
      buffer: i,
      indices: s,
      mappingType: e,
      referenceType: n
    }
  }
  parseNurbsGeometry(t) {
    const e = parseInt(t.Order)
    if (isNaN(e))
      return (
        console.error(
          'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s',
          t.Order,
          t.id
        ),
        new Zr()
      )
    const n = e - 1,
      i = t.KnotVector.a,
      s = [],
      r = t.Points.a
    for (let c = 0, h = r.length; c < h; c += 4)
      s.push(new ji().fromArray(r, c))
    let a, o
    if ('Closed' === t.Form) s.push(s[0])
    else if ('Periodic' === t.Form) {
      ;(a = n), (o = i.length - 1 - a)
      for (let t = 0; t < n; ++t) s.push(s[t])
    }
    const l = new sx(n, i, s, a, o).getPoints(12 * s.length)
    return new Zr().setFromPoints(l)
  }
}
class ux {
  static {
    e(this, 'AnimationParser')
  }
  parse() {
    const t = [],
      e = this.parseClips()
    if (void 0 !== e)
      for (const n in e) {
        const i = e[n],
          s = this.addClip(i)
        t.push(s)
      }
    return t
  }
  parseClips() {
    if (void 0 === rx.Objects.AnimationCurve) return
    const t = this.parseAnimationCurveNodes()
    this.parseAnimationCurves(t)
    const e = this.parseAnimationLayers(t)
    return this.parseAnimStacks(e)
  }
  parseAnimationCurveNodes() {
    const t = rx.Objects.AnimationCurveNode,
      e = new Map()
    for (const n in t) {
      const i = t[n]
      if (null !== i.attrName.match(/S|R|T|DeformPercent/)) {
        const t = { id: i.id, attr: i.attrName, curves: {} }
        e.set(t.id, t)
      }
    }
    return e
  }
  parseAnimationCurves(t) {
    const e = rx.Objects.AnimationCurve
    for (const n in e) {
      const i = {
          id: e[n].id,
          times: e[n].KeyTime.a.map(_x),
          values: e[n].KeyValueFloat.a
        },
        s = ax.get(i.id)
      if (void 0 !== s) {
        const e = s.parents[0].ID,
          n = s.parents[0].relationship
        n.match(/X/)
          ? (t.get(e).curves.x = i)
          : n.match(/Y/)
            ? (t.get(e).curves.y = i)
            : n.match(/Z/)
              ? (t.get(e).curves.z = i)
              : n.match(/DeformPercent/) &&
                t.has(e) &&
                (t.get(e).curves.morph = i)
      }
    }
  }
  parseAnimationLayers(t) {
    const e = rx.Objects.AnimationLayer,
      n = new Map()
    for (const i in e) {
      const e = [],
        s = ax.get(parseInt(i))
      if (void 0 !== s) {
        s.children.forEach(function (n, i) {
          if (t.has(n.ID)) {
            const s = t.get(n.ID)
            if (
              void 0 !== s.curves.x ||
              void 0 !== s.curves.y ||
              void 0 !== s.curves.z
            ) {
              if (void 0 === e[i]) {
                const t = ax.get(n.ID).parents.filter(function (t) {
                  return void 0 !== t.relationship
                })[0].ID
                if (void 0 !== t) {
                  const s = rx.Objects.Model[t.toString()]
                  if (void 0 === s)
                    return void console.warn(
                      'THREE.FBXLoader: Encountered a unused curve.',
                      n
                    )
                  const r = {
                    modelName: s.attrName
                      ? uf.sanitizeNodeName(s.attrName)
                      : '',
                    ID: s.id,
                    initialPosition: [0, 0, 0],
                    initialRotation: [0, 0, 0],
                    initialScale: [1, 1, 1]
                  }
                  ox.traverse(function (t) {
                    t.ID === s.id &&
                      ((r.transform = t.matrix),
                      t.userData.transformData &&
                        (r.eulerOrder = t.userData.transformData.eulerOrder))
                  }),
                    r.transform || (r.transform = new Rs()),
                    'PreRotation' in s && (r.preRotation = s.PreRotation.value),
                    'PostRotation' in s &&
                      (r.postRotation = s.PostRotation.value),
                    (e[i] = r)
                }
              }
              e[i] && (e[i][s.attr] = s)
            } else if (void 0 !== s.curves.morph) {
              if (void 0 === e[i]) {
                const t = ax.get(n.ID).parents.filter(function (t) {
                    return void 0 !== t.relationship
                  })[0].ID,
                  s = ax.get(t).parents[0].ID,
                  r = ax.get(s).parents[0].ID,
                  a = ax.get(r).parents[0].ID,
                  o = rx.Objects.Model[a],
                  l = {
                    modelName: o.attrName
                      ? uf.sanitizeNodeName(o.attrName)
                      : '',
                    morphName: rx.Objects.Deformer[t].attrName
                  }
                e[i] = l
              }
              e[i][s.attr] = s
            }
          }
        }),
          n.set(parseInt(i), e)
      }
    }
    return n
  }
  parseAnimStacks(t) {
    const e = rx.Objects.AnimationStack,
      n = {}
    for (const i in e) {
      const s = ax.get(parseInt(i)).children
      s.length > 1 &&
        console.warn(
          'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.'
        )
      const r = t.get(s[0].ID)
      n[i] = { name: e[i].attrName, layer: r }
    }
    return n
  }
  addClip(t) {
    let e = []
    const n = this
    return (
      t.layer.forEach(function (t) {
        e = e.concat(n.generateTracks(t))
      }),
      new jp(t.name, -1, e)
    )
  }
  generateTracks(t) {
    const e = []
    let n = new Qi(),
      i = new Qi()
    if (
      (t.transform && t.transform.decompose(n, new Ji(), i),
      (n = n.toArray()),
      (i = i.toArray()),
      void 0 !== t.T && Object.keys(t.T.curves).length > 0)
    ) {
      const i = this.generateVectorTrack(t.modelName, t.T.curves, n, 'position')
      void 0 !== i && e.push(i)
    }
    if (void 0 !== t.R && Object.keys(t.R.curves).length > 0) {
      const n = this.generateRotationTrack(
        t.modelName,
        t.R.curves,
        t.preRotation,
        t.postRotation,
        t.eulerOrder
      )
      void 0 !== n && e.push(n)
    }
    if (void 0 !== t.S && Object.keys(t.S.curves).length > 0) {
      const n = this.generateVectorTrack(t.modelName, t.S.curves, i, 'scale')
      void 0 !== n && e.push(n)
    }
    if (void 0 !== t.DeformPercent) {
      const n = this.generateMorphTrack(t)
      void 0 !== n && e.push(n)
    }
    return e
  }
  generateVectorTrack(t, e, n, i) {
    const s = this.getTimesForAllAxes(e),
      r = this.getKeyframeTrackValues(s, e, n)
    return new Wp(t + '.' + i, s, r)
  }
  generateRotationTrack(t, e, n, i, s) {
    let r, a
    if (void 0 !== e.x && void 0 !== e.y && void 0 !== e.z) {
      const t = this.interpolateRotations(e.x, e.y, e.z, s)
      ;(r = t[0]), (a = t[1])
    }
    const o = Tx(0)
    void 0 !== n &&
      ((n = n.map(gi.degToRad)).push(o),
      (n = new Fs().fromArray(n)),
      (n = new Ji().setFromEuler(n))),
      void 0 !== i &&
        ((i = i.map(gi.degToRad)).push(o),
        (i = new Fs().fromArray(i)),
        (i = new Ji().setFromEuler(i).invert()))
    const l = new Ji(),
      c = new Fs(),
      h = []
    if (!a || !r) return new Hp(t + '.quaternion', [0], [0])
    for (let u = 0; u < a.length; u += 3) {
      if (
        (c.set(a[u], a[u + 1], a[u + 2], s),
        l.setFromEuler(c),
        void 0 !== n && l.premultiply(n),
        void 0 !== i && l.multiply(i),
        u > 2)
      ) {
        new Ji().fromArray(h, ((u - 3) / 3) * 4).dot(l) < 0 &&
          l.set(-l.x, -l.y, -l.z, -l.w)
      }
      l.toArray(h, (u / 3) * 4)
    }
    return new Hp(t + '.quaternion', r, h)
  }
  generateMorphTrack(t) {
    const e = t.DeformPercent.curves.morph,
      n = e.values.map(function (t) {
        return t / 100
      }),
      i = ox.getObjectByName(t.modelName).morphTargetDictionary[t.morphName]
    return new zp(t.modelName + '.morphTargetInfluences[' + i + ']', e.times, n)
  }
  getTimesForAllAxes(t) {
    let e = []
    if (
      (void 0 !== t.x && (e = e.concat(t.x.times)),
      void 0 !== t.y && (e = e.concat(t.y.times)),
      void 0 !== t.z && (e = e.concat(t.z.times)),
      (e = e.sort(function (t, e) {
        return t - e
      })),
      e.length > 1)
    ) {
      let t = 1,
        n = e[0]
      for (let i = 1; i < e.length; i++) {
        const s = e[i]
        s !== n && ((e[t] = s), (n = s), t++)
      }
      e = e.slice(0, t)
    }
    return e
  }
  getKeyframeTrackValues(t, e, n) {
    const i = n,
      s = []
    let r = -1,
      a = -1,
      o = -1
    return (
      t.forEach(function (t) {
        if (
          (e.x && (r = e.x.times.indexOf(t)),
          e.y && (a = e.y.times.indexOf(t)),
          e.z && (o = e.z.times.indexOf(t)),
          -1 !== r)
        ) {
          const t = e.x.values[r]
          s.push(t), (i[0] = t)
        } else s.push(i[0])
        if (-1 !== a) {
          const t = e.y.values[a]
          s.push(t), (i[1] = t)
        } else s.push(i[1])
        if (-1 !== o) {
          const t = e.z.values[o]
          s.push(t), (i[2] = t)
        } else s.push(i[2])
      }),
      s
    )
  }
  interpolateRotations(t, e, n, i) {
    const s = [],
      r = []
    s.push(t.times[0]),
      r.push(gi.degToRad(t.values[0])),
      r.push(gi.degToRad(e.values[0])),
      r.push(gi.degToRad(n.values[0]))
    for (let a = 1; a < t.values.length; a++) {
      const o = [t.values[a - 1], e.values[a - 1], n.values[a - 1]]
      if (isNaN(o[0]) || isNaN(o[1]) || isNaN(o[2])) continue
      const l = o.map(gi.degToRad),
        c = [t.values[a], e.values[a], n.values[a]]
      if (isNaN(c[0]) || isNaN(c[1]) || isNaN(c[2])) continue
      const h = c.map(gi.degToRad),
        u = [c[0] - o[0], c[1] - o[1], c[2] - o[2]],
        d = [Math.abs(u[0]), Math.abs(u[1]), Math.abs(u[2])]
      if (d[0] >= 180 || d[1] >= 180 || d[2] >= 180) {
        const e = Math.max(...d) / 180,
          n = new Fs(...l, i),
          o = new Fs(...h, i),
          c = new Ji().setFromEuler(n),
          u = new Ji().setFromEuler(o)
        c.dot(u) && u.set(-u.x, -u.y, -u.z, -u.w)
        const p = t.times[a - 1],
          m = t.times[a] - p,
          f = new Ji(),
          g = new Fs()
        for (let t = 0; t < 1; t += 1 / e)
          f.copy(c.clone().slerp(u.clone(), t)),
            s.push(p + t * m),
            g.setFromQuaternion(f, i),
            r.push(g.x),
            r.push(g.y),
            r.push(g.z)
      } else
        s.push(t.times[a]),
          r.push(gi.degToRad(t.values[a])),
          r.push(gi.degToRad(e.values[a])),
          r.push(gi.degToRad(n.values[a]))
    }
    return [s, r]
  }
}
class dx {
  static {
    e(this, 'TextParser')
  }
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2]
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1]
  }
  getCurrentProp() {
    return this.currentProp
  }
  pushStack(t) {
    this.nodeStack.push(t), (this.currentIndent += 1)
  }
  popStack() {
    this.nodeStack.pop(), (this.currentIndent -= 1)
  }
  setCurrentProp(t, e) {
    ;(this.currentProp = t), (this.currentPropName = e)
  }
  parse(t) {
    ;(this.currentIndent = 0),
      (this.allNodes = new fx()),
      (this.nodeStack = []),
      (this.currentProp = []),
      (this.currentPropName = '')
    const e = this,
      n = t.split(/[\r\n]+/)
    return (
      n.forEach(function (t, i) {
        const s = t.match(/^[\s\t]*;/),
          r = t.match(/^[\s\t]*$/)
        if (s || r) return
        const a = t.match('^\\t{' + e.currentIndent + '}(\\w+):(.*){', ''),
          o = t.match('^\\t{' + e.currentIndent + '}(\\w+):[\\s\\t\\r\\n](.*)'),
          l = t.match('^\\t{' + (e.currentIndent - 1) + '}}')
        a
          ? e.parseNodeBegin(t, a)
          : o
            ? e.parseNodeProperty(t, o, n[++i])
            : l
              ? e.popStack()
              : t.match(/^[^\s\t}]/) && e.parseNodePropertyContinued(t)
      }),
      this.allNodes
    )
  }
  parseNodeBegin(t, e) {
    const n = e[1].trim().replace(/^"/, '').replace(/"$/, ''),
      i = e[2].split(',').map(function (t) {
        return t.trim().replace(/^"/, '').replace(/"$/, '')
      }),
      s = { name: n },
      r = this.parseNodeAttr(i),
      a = this.getCurrentNode()
    0 === this.currentIndent
      ? this.allNodes.add(n, s)
      : n in a
        ? ('PoseNode' === n
            ? a.PoseNode.push(s)
            : void 0 !== a[n].id && ((a[n] = {}), (a[n][a[n].id] = a[n])),
          '' !== r.id && (a[n][r.id] = s))
        : 'number' == typeof r.id
          ? ((a[n] = {}), (a[n][r.id] = s))
          : 'Properties70' !== n && (a[n] = 'PoseNode' === n ? [s] : s),
      'number' == typeof r.id && (s.id = r.id),
      '' !== r.name && (s.attrName = r.name),
      '' !== r.type && (s.attrType = r.type),
      this.pushStack(s)
  }
  parseNodeAttr(t) {
    let e = t[0]
    '' !== t[0] && ((e = parseInt(t[0])), isNaN(e) && (e = t[0]))
    let n = '',
      i = ''
    return (
      t.length > 1 && ((n = t[1].replace(/^(\w+)::/, '')), (i = t[2])),
      { id: e, name: n, type: i }
    )
  }
  parseNodeProperty(t, e, n) {
    let i = e[1].replace(/^"/, '').replace(/"$/, '').trim(),
      s = e[2].replace(/^"/, '').replace(/"$/, '').trim()
    'Content' === i &&
      ',' === s &&
      (s = n.replace(/"/g, '').replace(/,$/, '').trim())
    const r = this.getCurrentNode()
    if ('Properties70' !== r.name) {
      if ('C' === i) {
        const t = s.split(',').slice(1),
          e = parseInt(t[0]),
          n = parseInt(t[1])
        let a = s.split(',').slice(3)
        ;(a = a.map(function (t) {
          return t.trim().replace(/^"/, '')
        })),
          (i = 'connections'),
          (s = [e, n]),
          Cx(s, a),
          void 0 === r[i] && (r[i] = [])
      }
      'Node' === i && (r.id = s),
        i in r && Array.isArray(r[i])
          ? r[i].push(s)
          : 'a' !== i
            ? (r[i] = s)
            : (r.a = s),
        this.setCurrentProp(r, i),
        'a' === i && ',' !== s.slice(-1) && (r.a = Ex(s))
    } else this.parseNodeSpecialProperty(t, i, s)
  }
  parseNodePropertyContinued(t) {
    const e = this.getCurrentNode()
    ;(e.a += t), ',' !== t.slice(-1) && (e.a = Ex(e.a))
  }
  parseNodeSpecialProperty(t, e, n) {
    const i = n.split('",').map(function (t) {
        return t.trim().replace(/^\"/, '').replace(/\s/, '_')
      }),
      s = i[0],
      r = i[1],
      a = i[2],
      o = i[3]
    let l = i[4]
    switch (r) {
      case 'int':
      case 'enum':
      case 'bool':
      case 'ULongLong':
      case 'double':
      case 'Number':
      case 'FieldOfView':
        l = parseFloat(l)
        break
      case 'Color':
      case 'ColorRGB':
      case 'Vector3D':
      case 'Lcl_Translation':
      case 'Lcl_Rotation':
      case 'Lcl_Scaling':
        l = Ex(l)
    }
    ;(this.getPrevNode()[s] = { type: r, type2: a, flag: o, value: l }),
      this.setCurrentProp(this.getPrevNode(), s)
  }
}
class px {
  static {
    e(this, 'BinaryParser')
  }
  parse(t) {
    const e = new mx(t)
    e.skip(23)
    const n = e.getUint32()
    if (n < 6400)
      throw new Error(
        'THREE.FBXLoader: FBX version not supported, FileVersion: ' + n
      )
    const i = new fx()
    for (; !this.endOfContent(e); ) {
      const t = this.parseNode(e, n)
      null !== t && i.add(t.name, t)
    }
    return i
  }
  endOfContent(t) {
    return t.size() % 16 == 0
      ? ((t.getOffset() + 160 + 16) & -16) >= t.size()
      : t.getOffset() + 160 + 16 >= t.size()
  }
  parseNode(t, e) {
    const n = {},
      i = e >= 7500 ? t.getUint64() : t.getUint32(),
      s = e >= 7500 ? t.getUint64() : t.getUint32()
    e >= 7500 ? t.getUint64() : t.getUint32()
    const r = t.getUint8(),
      a = t.getString(r)
    if (0 === i) return null
    const o = []
    for (let u = 0; u < s; u++) o.push(this.parseProperty(t))
    const l = o.length > 0 ? o[0] : '',
      c = o.length > 1 ? o[1] : '',
      h = o.length > 2 ? o[2] : ''
    for (
      n.singleProperty = 1 === s && t.getOffset() === i;
      i > t.getOffset();

    ) {
      const i = this.parseNode(t, e)
      null !== i && this.parseSubNode(a, n, i)
    }
    return (
      (n.propertyList = o),
      'number' == typeof l && (n.id = l),
      '' !== c && (n.attrName = c),
      '' !== h && (n.attrType = h),
      '' !== a && (n.name = a),
      n
    )
  }
  parseSubNode(t, e, n) {
    if (!0 === n.singleProperty) {
      const t = n.propertyList[0]
      Array.isArray(t) ? ((e[n.name] = n), (n.a = t)) : (e[n.name] = t)
    } else if ('Connections' === t && 'C' === n.name) {
      const t = []
      n.propertyList.forEach(function (e, n) {
        0 !== n && t.push(e)
      }),
        void 0 === e.connections && (e.connections = []),
        e.connections.push(t)
    } else if ('Properties70' === n.name) {
      Object.keys(n).forEach(function (t) {
        e[t] = n[t]
      })
    } else if ('Properties70' === t && 'P' === n.name) {
      let t = n.propertyList[0],
        i = n.propertyList[1]
      const s = n.propertyList[2],
        r = n.propertyList[3]
      let a
      0 === t.indexOf('Lcl ') && (t = t.replace('Lcl ', 'Lcl_')),
        0 === i.indexOf('Lcl ') && (i = i.replace('Lcl ', 'Lcl_')),
        (a =
          'Color' === i ||
          'ColorRGB' === i ||
          'Vector' === i ||
          'Vector3D' === i ||
          0 === i.indexOf('Lcl_')
            ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]]
            : n.propertyList[4]),
        (e[t] = { type: i, type2: s, flag: r, value: a })
    } else
      void 0 === e[n.name]
        ? 'number' == typeof n.id
          ? ((e[n.name] = {}), (e[n.name][n.id] = n))
          : (e[n.name] = n)
        : 'PoseNode' === n.name
          ? (Array.isArray(e[n.name]) || (e[n.name] = [e[n.name]]),
            e[n.name].push(n))
          : void 0 === e[n.name][n.id] && (e[n.name][n.id] = n)
  }
  parseProperty(t) {
    const e = t.getString(1)
    let n
    switch (e) {
      case 'C':
        return t.getBoolean()
      case 'D':
        return t.getFloat64()
      case 'F':
        return t.getFloat32()
      case 'I':
        return t.getInt32()
      case 'L':
        return t.getInt64()
      case 'R':
        return (n = t.getUint32()), t.getArrayBuffer(n)
      case 'S':
        return (n = t.getUint32()), t.getString(n)
      case 'Y':
        return t.getInt16()
      case 'b':
      case 'c':
      case 'd':
      case 'f':
      case 'i':
      case 'l':
        const i = t.getUint32(),
          s = t.getUint32(),
          r = t.getUint32()
        if (0 === s)
          switch (e) {
            case 'b':
            case 'c':
              return t.getBooleanArray(i)
            case 'd':
              return t.getFloat64Array(i)
            case 'f':
              return t.getFloat32Array(i)
            case 'i':
              return t.getInt32Array(i)
            case 'l':
              return t.getInt64Array(i)
          }
        const a = U_(new Uint8Array(t.getArrayBuffer(r))),
          o = new mx(a.buffer)
        switch (e) {
          case 'b':
          case 'c':
            return o.getBooleanArray(i)
          case 'd':
            return o.getFloat64Array(i)
          case 'f':
            return o.getFloat32Array(i)
          case 'i':
            return o.getInt32Array(i)
          case 'l':
            return o.getInt64Array(i)
        }
        break
      default:
        throw new Error('THREE.FBXLoader: Unknown property type ' + e)
    }
  }
}
class mx {
  static {
    e(this, 'BinaryReader')
  }
  constructor(t, e) {
    ;(this.dv = new DataView(t)),
      (this.offset = 0),
      (this.littleEndian = void 0 === e || e),
      (this._textDecoder = new TextDecoder())
  }
  getOffset() {
    return this.offset
  }
  size() {
    return this.dv.buffer.byteLength
  }
  skip(t) {
    this.offset += t
  }
  getBoolean() {
    return !(1 & ~this.getUint8())
  }
  getBooleanArray(t) {
    const e = []
    for (let n = 0; n < t; n++) e.push(this.getBoolean())
    return e
  }
  getUint8() {
    const t = this.dv.getUint8(this.offset)
    return (this.offset += 1), t
  }
  getInt16() {
    const t = this.dv.getInt16(this.offset, this.littleEndian)
    return (this.offset += 2), t
  }
  getInt32() {
    const t = this.dv.getInt32(this.offset, this.littleEndian)
    return (this.offset += 4), t
  }
  getInt32Array(t) {
    const e = []
    for (let n = 0; n < t; n++) e.push(this.getInt32())
    return e
  }
  getUint32() {
    const t = this.dv.getUint32(this.offset, this.littleEndian)
    return (this.offset += 4), t
  }
  getInt64() {
    let t, e
    return (
      this.littleEndian
        ? ((t = this.getUint32()), (e = this.getUint32()))
        : ((e = this.getUint32()), (t = this.getUint32())),
      2147483648 & e
        ? ((e = 4294967295 & ~e),
          (t = 4294967295 & ~t),
          4294967295 === t && (e = (e + 1) & 4294967295),
          (t = (t + 1) & 4294967295),
          -(4294967296 * e + t))
        : 4294967296 * e + t
    )
  }
  getInt64Array(t) {
    const e = []
    for (let n = 0; n < t; n++) e.push(this.getInt64())
    return e
  }
  getUint64() {
    let t, e
    return (
      this.littleEndian
        ? ((t = this.getUint32()), (e = this.getUint32()))
        : ((e = this.getUint32()), (t = this.getUint32())),
      4294967296 * e + t
    )
  }
  getFloat32() {
    const t = this.dv.getFloat32(this.offset, this.littleEndian)
    return (this.offset += 4), t
  }
  getFloat32Array(t) {
    const e = []
    for (let n = 0; n < t; n++) e.push(this.getFloat32())
    return e
  }
  getFloat64() {
    const t = this.dv.getFloat64(this.offset, this.littleEndian)
    return (this.offset += 8), t
  }
  getFloat64Array(t) {
    const e = []
    for (let n = 0; n < t; n++) e.push(this.getFloat64())
    return e
  }
  getArrayBuffer(t) {
    const e = this.dv.buffer.slice(this.offset, this.offset + t)
    return (this.offset += t), e
  }
  getString(t) {
    const e = this.offset
    let n = new Uint8Array(this.dv.buffer, e, t)
    this.skip(t)
    const i = n.indexOf(0)
    return (
      i >= 0 && (n = new Uint8Array(this.dv.buffer, e, i)),
      this._textDecoder.decode(n)
    )
  }
}
class fx {
  static {
    e(this, 'FBXTree')
  }
  add(t, e) {
    this[t] = e
  }
}
function gx(t) {
  const e = 'Kaydara FBX Binary  \0'
  return t.byteLength >= 21 && e === Ax(t, 0, 21)
}
function vx(t) {
  const n = [
    'K',
    'a',
    'y',
    'd',
    'a',
    'r',
    'a',
    '\\',
    'F',
    'B',
    'X',
    '\\',
    'B',
    'i',
    'n',
    'a',
    'r',
    'y',
    '\\',
    '\\'
  ]
  let i = 0
  function s(e) {
    const n = t[e - 1]
    return (t = t.slice(i + e)), i++, n
  }
  e(s, 'read')
  for (let e = 0; e < n.length; ++e) {
    if (s(1) === n[e]) return !1
  }
  return !0
}
function yx(t) {
  const e = t.match(/FBXVersion: (\d+)/)
  if (e) {
    return parseInt(e[1])
  }
  throw new Error(
    'THREE.FBXLoader: Cannot find the version number for the file given.'
  )
}
function _x(t) {
  return t / 46186158e3
}
e(gx, 'isFbxFormatBinary'),
  e(vx, 'isFbxFormatASCII'),
  e(yx, 'getFbxVersion'),
  e(_x, 'convertFBXTimeToSeconds')
const xx = []
function bx(t, e, n, i) {
  let s
  switch (i.mappingType) {
    case 'ByPolygonVertex':
      s = t
      break
    case 'ByPolygon':
      s = e
      break
    case 'ByVertice':
      s = n
      break
    case 'AllSame':
      s = i.indices[0]
      break
    default:
      console.warn(
        'THREE.FBXLoader: unknown attribute mapping type ' + i.mappingType
      )
  }
  'IndexToDirect' === i.referenceType && (s = i.indices[s])
  const r = s * i.dataSize,
    a = r + i.dataSize
  return Rx(xx, i.buffer, r, a)
}
e(bx, 'getData')
const wx = new Fs(),
  Mx = new Qi()
function Sx(t) {
  const e = new Rs(),
    n = new Rs(),
    i = new Rs(),
    s = new Rs(),
    r = new Rs(),
    a = new Rs(),
    o = new Rs(),
    l = new Rs(),
    c = new Rs(),
    h = new Rs(),
    u = new Rs(),
    d = new Rs(),
    p = t.inheritType ? t.inheritType : 0
  t.translation && e.setPosition(Mx.fromArray(t.translation))
  const m = Tx(0)
  if (t.preRotation) {
    const e = t.preRotation.map(gi.degToRad)
    e.push(m), n.makeRotationFromEuler(wx.fromArray(e))
  }
  if (t.rotation) {
    const e = t.rotation.map(gi.degToRad)
    e.push(t.eulerOrder || m), i.makeRotationFromEuler(wx.fromArray(e))
  }
  if (t.postRotation) {
    const e = t.postRotation.map(gi.degToRad)
    e.push(m), s.makeRotationFromEuler(wx.fromArray(e)), s.invert()
  }
  t.scale && r.scale(Mx.fromArray(t.scale)),
    t.scalingOffset && o.setPosition(Mx.fromArray(t.scalingOffset)),
    t.scalingPivot && a.setPosition(Mx.fromArray(t.scalingPivot)),
    t.rotationOffset && l.setPosition(Mx.fromArray(t.rotationOffset)),
    t.rotationPivot && c.setPosition(Mx.fromArray(t.rotationPivot)),
    t.parentMatrixWorld && (u.copy(t.parentMatrix), h.copy(t.parentMatrixWorld))
  const f = n.clone().multiply(i).multiply(s),
    g = new Rs()
  g.extractRotation(h)
  const v = new Rs()
  v.copyPosition(h)
  const y = v.clone().invert().multiply(h),
    _ = g.clone().invert().multiply(y),
    x = r,
    b = new Rs()
  if (0 === p) b.copy(g).multiply(f).multiply(_).multiply(x)
  else if (1 === p) b.copy(g).multiply(_).multiply(f).multiply(x)
  else {
    const t = new Rs().scale(new Qi().setFromMatrixScale(u)).clone().invert(),
      e = _.clone().multiply(t)
    b.copy(g).multiply(f).multiply(e).multiply(x)
  }
  const w = c.clone().invert(),
    M = a.clone().invert()
  let S = e
    .clone()
    .multiply(l)
    .multiply(c)
    .multiply(n)
    .multiply(i)
    .multiply(s)
    .multiply(w)
    .multiply(o)
    .multiply(a)
    .multiply(r)
    .multiply(M)
  const T = new Rs().copyPosition(S),
    E = h.clone().multiply(T)
  return (
    d.copyPosition(E), (S = d.clone().multiply(b)), S.premultiply(h.invert()), S
  )
}
function Tx(t) {
  const e = ['ZYX', 'YZX', 'XZY', 'ZXY', 'YXZ', 'XYZ']
  return 6 === (t = t || 0)
    ? (console.warn(
        'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.'
      ),
      e[0])
    : e[t]
}
function Ex(t) {
  return t.split(',').map(function (t) {
    return parseFloat(t)
  })
}
function Ax(t, e, n) {
  return (
    void 0 === e && (e = 0),
    void 0 === n && (n = t.byteLength),
    new TextDecoder().decode(new Uint8Array(t, e, n))
  )
}
function Cx(t, e) {
  for (let n = 0, i = t.length, s = e.length; n < s; n++, i++) t[i] = e[n]
}
function Rx(t, e, n, i) {
  for (let s = n, r = 0; s < i; s++, r++) t[r] = e[s]
  return t
}
e(Sx, 'generateTransform'),
  e(Tx, 'getEulerOrder'),
  e(Ex, 'parseNumberArray'),
  e(Ax, 'convertArrayBufferToString'),
  e(Cx, 'append'),
  e(Rx, 'slice')
class Px extends $p {
  static {
    e(this, 'STLLoader')
  }
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    const s = this,
      r = new tm(this.manager)
    r.setPath(this.path),
      r.setResponseType('arraybuffer'),
      r.setRequestHeader(this.requestHeader),
      r.setWithCredentials(this.withCredentials),
      r.load(
        t,
        function (n) {
          try {
            e(s.parse(n))
          } catch (zx) {
            i ? i(zx) : console.error(zx), s.manager.itemError(t)
          }
        },
        n,
        i
      )
  }
  parse(t) {
    function n(t) {
      const e = new DataView(t)
      if (84 + 50 * e.getUint32(80, !0) === e.byteLength) return !0
      const n = [115, 111, 108, 105, 100]
      for (let s = 0; s < 5; s++) if (i(n, e, s)) return !1
      return !0
    }
    function i(t, e, n) {
      for (let i = 0, s = t.length; i < s; i++)
        if (t[i] !== e.getUint8(n + i)) return !1
      return !0
    }
    function s(t) {
      const e = new DataView(t),
        n = e.getUint32(80, !0)
      let i,
        s,
        r,
        a,
        o,
        l,
        c,
        h,
        u = !1
      for (let g = 0; g < 70; g++)
        1129270351 == e.getUint32(g, !1) &&
          82 == e.getUint8(g + 4) &&
          61 == e.getUint8(g + 5) &&
          ((u = !0),
          (a = new Float32Array(3 * n * 3)),
          (o = e.getUint8(g + 6) / 255),
          (l = e.getUint8(g + 7) / 255),
          (c = e.getUint8(g + 8) / 255),
          (h = e.getUint8(g + 9) / 255))
      const d = new Zr(),
        p = new Float32Array(3 * n * 3),
        m = new Float32Array(3 * n * 3),
        f = new br()
      for (let g = 0; g < n; g++) {
        const t = 84 + 50 * g,
          n = e.getFloat32(t, !0),
          h = e.getFloat32(t + 4, !0),
          d = e.getFloat32(t + 8, !0)
        if (u) {
          const n = e.getUint16(t + 48, !0)
          32768 & n
            ? ((i = o), (s = l), (r = c))
            : ((i = (31 & n) / 31),
              (s = ((n >> 5) & 31) / 31),
              (r = ((n >> 10) & 31) / 31))
        }
        for (let o = 1; o <= 3; o++) {
          const l = t + 12 * o,
            c = 3 * g * 3 + 3 * (o - 1)
          ;(p[c] = e.getFloat32(l, !0)),
            (p[c + 1] = e.getFloat32(l + 4, !0)),
            (p[c + 2] = e.getFloat32(l + 8, !0)),
            (m[c] = n),
            (m[c + 1] = h),
            (m[c + 2] = d),
            u &&
              (f.setRGB(i, s, r, En),
              (a[c] = f.r),
              (a[c + 1] = f.g),
              (a[c + 2] = f.b))
        }
      }
      return (
        d.setAttribute('position', new Lr(p, 3)),
        d.setAttribute('normal', new Lr(m, 3)),
        u &&
          (d.setAttribute('color', new Lr(a, 3)),
          (d.hasColors = !0),
          (d.alpha = h)),
        d
      )
    }
    function r(t) {
      const e = new Zr(),
        n = /solid([\s\S]*?)endsolid/g,
        i = /facet([\s\S]*?)endfacet/g,
        s = /solid\s(.+)/
      let r = 0
      const a = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source,
        o = new RegExp('vertex' + a + a + a, 'g'),
        l = new RegExp('normal' + a + a + a, 'g'),
        c = [],
        h = [],
        u = [],
        d = new Qi()
      let p,
        m = 0,
        f = 0,
        g = 0
      for (; null !== (p = n.exec(t)); ) {
        f = g
        const t = p[0],
          n = null !== (p = s.exec(t)) ? p[1] : ''
        for (u.push(n); null !== (p = i.exec(t)); ) {
          let t = 0,
            e = 0
          const n = p[0]
          for (; null !== (p = l.exec(n)); )
            (d.x = parseFloat(p[1])),
              (d.y = parseFloat(p[2])),
              (d.z = parseFloat(p[3])),
              e++
          for (; null !== (p = o.exec(n)); )
            c.push(parseFloat(p[1]), parseFloat(p[2]), parseFloat(p[3])),
              h.push(d.x, d.y, d.z),
              t++,
              g++
          1 !== e &&
            console.error(
              "THREE.STLLoader: Something isn't right with the normal of face number " +
                r
            ),
            3 !== t &&
              console.error(
                "THREE.STLLoader: Something isn't right with the vertices of face number " +
                  r
              ),
            r++
        }
        const a = f,
          v = g - f
        ;(e.userData.groupNames = u), e.addGroup(a, v, m), m++
      }
      return (
        e.setAttribute('position', new Vr(c, 3)),
        e.setAttribute('normal', new Vr(h, 3)),
        e
      )
    }
    function a(t) {
      return 'string' != typeof t ? new TextDecoder().decode(t) : t
    }
    function o(t) {
      if ('string' == typeof t) {
        const e = new Uint8Array(t.length)
        for (let n = 0; n < t.length; n++) e[n] = 255 & t.charCodeAt(n)
        return e.buffer || e
      }
      return t
    }
    e(n, 'isBinary'),
      e(i, 'matchDataViewAt'),
      e(s, 'parseBinary'),
      e(r, 'parseASCII'),
      e(a, 'ensureString'),
      e(o, 'ensureBinary')
    const l = o(t)
    return n(l) ? s(l) : r(a(t))
  }
}
async function Ix(t, e, n) {
  let i
  try {
    const r = new FormData()
    r.append('image', e), r.append('subfolder', '3d')
    const a = await p.fetchApi('/upload/image', { method: 'POST', body: r })
    if (200 === a.status) {
      const r = await a.json()
      let o = r.name
      r.subfolder && (o = r.subfolder + '/' + o), (i = o)
      const l = p.apiURL(Nx(...kx(o), 'input'))
      await t.loadModel(l, e.name)
      const c = e.name.split('.').pop()?.toLowerCase()
      if ('obj' === c && n?.files)
        try {
          const t = Array.from(n.files).find((t) =>
            t.name.toLowerCase().endsWith('.mtl')
          )
          if (t) {
            const e = new FormData()
            e.append('image', t),
              e.append('subfolder', '3d'),
              await p.fetchApi('/upload/image', { method: 'POST', body: e })
          }
        } catch (s) {
          console.warn('Failed to upload MTL file:', s)
        }
    } else c().addAlert(a.status + ' - ' + a.statusText)
  } catch (r) {
    console.error('Upload error:', r),
      c().addAlert(r instanceof Error ? r.message : 'Upload failed')
  }
  return i
}
e(Ix, 'uploadFile')
class Lx {
  static {
    e(this, 'Load3d')
  }
  scene
  perspectiveCamera
  orthographicCamera
  activeCamera
  renderer
  controls
  gltfLoader
  objLoader
  mtlLoader
  fbxLoader
  stlLoader
  currentModel = null
  originalModel = null
  node
  animationFrameId = null
  gridHelper
  lights = []
  clock
  normalMaterial
  standardMaterial
  wireframeMaterial
  depthMaterial
  originalMaterials = new WeakMap()
  materialMode = 'original'
  currentUpDirection = 'original'
  originalRotation = null
  constructor(t) {
    ;(this.scene = new qc()),
      (this.perspectiveCamera = new ba(75, 1, 0.1, 1e3)),
      this.perspectiveCamera.position.set(5, 5, 5)
    ;(this.orthographicCamera = new Ya(-5, 5, 5, -5, 0.1, 1e3)),
      this.orthographicCamera.position.set(5, 5, 5),
      (this.activeCamera = this.perspectiveCamera),
      this.perspectiveCamera.lookAt(0, 0, 0),
      this.orthographicCamera.lookAt(0, 0, 0),
      (this.renderer = new Wc({ antialias: !0 })),
      this.renderer.setSize(300, 300),
      this.renderer.setClearColor(2631720)
    const e = this.renderer.domElement
    t.appendChild(e),
      (this.controls = new Pg(this.activeCamera, this.renderer.domElement)),
      (this.controls.enableDamping = !0),
      (this.gltfLoader = new Xg()),
      (this.objLoader = new ry()),
      (this.mtlLoader = new ay()),
      (this.fbxLoader = new lx()),
      (this.stlLoader = new Px()),
      (this.clock = new Hm()),
      this.setupLights(),
      (this.gridHelper = new jf(10, 10)),
      this.gridHelper.position.set(0, 0, 0),
      this.scene.add(this.gridHelper),
      (this.normalMaterial = new wp({
        flatShading: !1,
        side: 2,
        normalScale: new vi(1, 1),
        transparent: !1,
        opacity: 1
      })),
      (this.wireframeMaterial = new Tr({
        color: 16777215,
        wireframe: !0,
        transparent: !1,
        opacity: 1
      })),
      (this.depthMaterial = new wc({ depthPacking: Sn, side: 2 })),
      (this.standardMaterial = this.createSTLMaterial()),
      this.animate(),
      this.handleResize(),
      this.startAnimation()
  }
  getCameraState() {
    const t = this.getCurrentCameraType()
    return {
      position: this.activeCamera.position.clone(),
      target: this.controls.target.clone(),
      zoom: (this.activeCamera, this.activeCamera.zoom),
      cameraType: t
    }
  }
  setCameraState(t) {
    this.activeCamera !==
      ('perspective' === t.cameraType
        ? this.perspectiveCamera
        : this.orthographicCamera) && this.toggleCamera(t.cameraType),
      this.activeCamera.position.copy(t.position),
      this.controls.target.copy(t.target),
      (this.activeCamera instanceof Ya || this.activeCamera instanceof ba) &&
        ((this.activeCamera.zoom = t.zoom),
        this.activeCamera.updateProjectionMatrix()),
      this.controls.update()
  }
  setUpDirection(t) {
    if (this.currentModel) {
      switch (
        (!this.originalRotation &&
          this.currentModel.rotation &&
          (this.originalRotation = this.currentModel.rotation.clone()),
        (this.currentUpDirection = t),
        this.originalRotation &&
          this.currentModel.rotation.copy(this.originalRotation),
        t)
      ) {
        case 'original':
        case '+y':
          break
        case '-x':
          this.currentModel.rotation.z = Math.PI / 2
          break
        case '+x':
          this.currentModel.rotation.z = -Math.PI / 2
          break
        case '-y':
          this.currentModel.rotation.x = Math.PI
          break
        case '-z':
          this.currentModel.rotation.x = Math.PI / 2
          break
        case '+z':
          this.currentModel.rotation.x = -Math.PI / 2
      }
      this.renderer.render(this.scene, this.activeCamera)
    }
  }
  setMaterialMode(t) {
    ;(this.materialMode = t),
      this.currentModel &&
        ((this.renderer.outputColorSpace = 'depth' === t ? An : En),
        this.currentModel.traverse((e) => {
          if (e instanceof oa)
            switch (t) {
              case 'depth':
                this.originalMaterials.has(e) ||
                  this.originalMaterials.set(e, e.material)
                const t = new wc({ depthPacking: Sn, side: 2 })
                ;(t.onBeforeCompile = (t) => {
                  ;(t.uniforms.cameraType = {
                    value: this.activeCamera instanceof Ya ? 1 : 0
                  }),
                    (t.fragmentShader = `\n                  uniform float cameraType;\n                  ${t.fragmentShader}\n                `),
                    (t.fragmentShader = t.fragmentShader.replace(
                      /gl_FragColor\s*=\s*vec4\(\s*vec3\(\s*1.0\s*-\s*fragCoordZ\s*\)\s*,\s*opacity\s*\)\s*;/,
                      '\n                    float depth = 1.0 - fragCoordZ;\n                    if (cameraType > 0.5) {\n                      depth = pow(depth, 400.0);\n                    } else {\n                      depth = pow(depth, 0.6);\n                    }\n                    gl_FragColor = vec4(vec3(depth), opacity);\n                  '
                    ))
                }),
                  (t.customProgramCacheKey = () =>
                    this.activeCamera instanceof Ya ? 'ortho' : 'persp'),
                  (e.material = t)
                break
              case 'normal':
                this.originalMaterials.has(e) ||
                  this.originalMaterials.set(e, e.material),
                  (e.material = new wp({
                    flatShading: !1,
                    side: 2,
                    normalScale: new vi(1, 1),
                    transparent: !1,
                    opacity: 1
                  })),
                  e.geometry.computeVertexNormals()
                break
              case 'wireframe':
                this.originalMaterials.has(e) ||
                  this.originalMaterials.set(e, e.material),
                  (e.material = new Tr({
                    color: 16777215,
                    wireframe: !0,
                    transparent: !1,
                    opacity: 1
                  }))
                break
              case 'original':
                const n = this.originalMaterials.get(e)
                e.material = n || this.standardMaterial
            }
        }),
        this.renderer.render(this.scene, this.activeCamera))
  }
  setupLights() {
    const t = new wm(16777215, 0.5)
    this.scene.add(t), this.lights.push(t)
    const e = new bm(16777215, 0.8)
    e.position.set(0, 10, 10), this.scene.add(e), this.lights.push(e)
    const n = new bm(16777215, 0.5)
    n.position.set(0, 10, -10), this.scene.add(n), this.lights.push(n)
    const i = new bm(16777215, 0.3)
    i.position.set(-10, 0, 0), this.scene.add(i), this.lights.push(i)
    const s = new bm(16777215, 0.3)
    s.position.set(10, 0, 0), this.scene.add(s), this.lights.push(s)
    const r = new bm(16777215, 0.2)
    r.position.set(0, -10, 0), this.scene.add(r), this.lights.push(r)
  }
  toggleCamera(t) {
    const e = this.activeCamera,
      n = e.position.clone(),
      i = e.rotation.clone(),
      s = this.controls.target.clone()
    if (t) {
      if (
        ((this.activeCamera =
          'perspective' === t
            ? this.perspectiveCamera
            : this.orthographicCamera),
        e === this.activeCamera)
      )
        return
    } else
      this.activeCamera =
        e === this.perspectiveCamera
          ? this.orthographicCamera
          : this.perspectiveCamera
    this.activeCamera.position.copy(n),
      this.activeCamera.rotation.copy(i),
      'depth' === this.materialMode &&
        e !== this.activeCamera &&
        this.setMaterialMode('depth'),
      (this.controls.object = this.activeCamera),
      this.controls.target.copy(s),
      this.controls.update(),
      this.handleResize()
  }
  getCurrentCameraType() {
    return this.activeCamera === this.perspectiveCamera
      ? 'perspective'
      : 'orthographic'
  }
  toggleGrid(t) {
    this.gridHelper && (this.gridHelper.visible = t)
  }
  setLightIntensity(t) {
    this.lights.forEach((e) => {
      e instanceof bm
        ? e === this.lights[1]
          ? (e.intensity = 0.8 * t)
          : e === this.lights[2]
            ? (e.intensity = 0.5 * t)
            : e === this.lights[5]
              ? (e.intensity = 0.2 * t)
              : (e.intensity = 0.3 * t)
        : e instanceof wm && (e.intensity = 0.5 * t)
    })
  }
  startAnimation() {
    const t = e(() => {
      ;(this.animationFrameId = requestAnimationFrame(t)),
        this.controls.update(),
        this.renderer.render(this.scene, this.activeCamera)
    }, 'animate')
    t()
  }
  clearModel() {
    const t = []
    this.scene.traverse((e) => {
      e === this.gridHelper ||
        this.lights.includes(e) ||
        e === this.perspectiveCamera ||
        e === this.orthographicCamera ||
        t.push(e)
    }),
      t.forEach((t) => {
        t.parent && t.parent !== this.scene
          ? t.parent.remove(t)
          : this.scene.remove(t),
          t instanceof oa &&
            (t.geometry?.dispose(),
            Array.isArray(t.material)
              ? t.material.forEach((t) => t.dispose())
              : t.material?.dispose())
      }),
      this.resetScene()
  }
  resetScene() {
    ;(this.currentModel = null), (this.originalRotation = null)
    const t = 10
    this.perspectiveCamera.position.set(t, t, t),
      this.orthographicCamera.position.set(t, t, t),
      this.perspectiveCamera.lookAt(0, 0, 0),
      this.orthographicCamera.lookAt(0, 0, 0)
    const e = this.renderer.domElement.width / this.renderer.domElement.height
    ;(this.orthographicCamera.left = (-10 * e) / 2),
      (this.orthographicCamera.right = (10 * e) / 2),
      (this.orthographicCamera.top = 5),
      (this.orthographicCamera.bottom = -5),
      this.perspectiveCamera.updateProjectionMatrix(),
      this.orthographicCamera.updateProjectionMatrix(),
      this.controls.target.set(0, 0, 0),
      this.controls.update(),
      this.renderer.render(this.scene, this.activeCamera),
      (this.materialMode = 'original'),
      (this.originalMaterials = new WeakMap()),
      (this.renderer.outputColorSpace = En)
  }
  remove() {
    null !== this.animationFrameId &&
      cancelAnimationFrame(this.animationFrameId),
      this.controls.dispose(),
      this.renderer.dispose(),
      this.renderer.domElement.remove(),
      this.scene.clear()
  }
  async loadModelInternal(t, e) {
    let n = null
    switch (e) {
      case 'stl':
        const e = await this.stlLoader.loadAsync(t)
        ;(this.originalModel = e), e.computeVertexNormals()
        const i = new oa(e, this.standardMaterial),
          s = new Nc()
        s.add(i), (n = s)
        break
      case 'fbx':
        const r = await this.fbxLoader.loadAsync(t)
        ;(this.originalModel = r),
          (n = r),
          r.traverse((t) => {
            t instanceof oa && this.originalMaterials.set(t, t.material)
          })
        break
      case 'obj':
        if ('original' === this.materialMode) {
          const e = t.replace(/\.obj([^.]*$)/, '.mtl$1')
          try {
            const t = await this.mtlLoader.loadAsync(e)
            t.preload(), this.objLoader.setMaterials(t)
          } catch (zx) {
            console.log(
              'No MTL file found or error loading it, continuing without materials'
            )
          }
        }
        ;(n = await this.objLoader.loadAsync(t)),
          n.traverse((t) => {
            t instanceof oa && this.originalMaterials.set(t, t.material)
          })
        break
      case 'gltf':
      case 'glb':
        const a = await this.gltfLoader.loadAsync(t)
        ;(this.originalModel = a),
          (n = a.scene),
          a.scene.traverse((t) => {
            t instanceof oa &&
              (t.geometry.computeVertexNormals(),
              this.originalMaterials.set(t, t.material))
          })
    }
    return n
  }
  async loadModel(t, e) {
    try {
      let n
      if ((this.clearModel(), e)) n = e.split('.').pop()?.toLowerCase()
      else {
        const e = new URLSearchParams(t.split('?')[1]).get('filename')
        n = e?.split('.').pop()?.toLowerCase()
      }
      if (!n) return void c().addAlert('Could not determine file type')
      let i = await this.loadModelInternal(t, n)
      i && ((this.currentModel = i), await this.setupModel(i))
    } catch (n) {
      console.error('Error loading model:', n)
    }
  }
  async setupModel(t) {
    const e = new ns().setFromObject(t),
      n = e.getSize(new Qi()),
      i = e.getCenter(new Qi()),
      s = 5 / Math.max(n.x, n.y, n.z)
    t.scale.multiplyScalar(s),
      e.setFromObject(t),
      e.getCenter(i),
      e.getSize(n),
      t.position.set(-i.x, -e.min.y, -i.z),
      this.scene.add(t),
      'original' !== this.materialMode &&
        this.setMaterialMode(this.materialMode),
      'original' !== this.currentUpDirection &&
        this.setUpDirection(this.currentUpDirection),
      await this.setupCamera(n)
  }
  async setupCamera(t) {
    const e = 2 * Math.max(t.x, t.z),
      n = 2 * t.y
    if (
      (this.perspectiveCamera.position.set(e, n, e),
      this.orthographicCamera.position.set(e, n, e),
      this.activeCamera === this.perspectiveCamera)
    )
      this.perspectiveCamera.lookAt(0, t.y / 2, 0),
        this.perspectiveCamera.updateProjectionMatrix()
    else {
      const e = 2 * Math.max(t.x, t.y, t.z),
        n = this.renderer.domElement.width / this.renderer.domElement.height
      ;(this.orthographicCamera.left = (-e * n) / 2),
        (this.orthographicCamera.right = (e * n) / 2),
        (this.orthographicCamera.top = e / 2),
        (this.orthographicCamera.bottom = -e / 2),
        this.orthographicCamera.lookAt(0, t.y / 2, 0),
        this.orthographicCamera.updateProjectionMatrix()
    }
    this.controls.target.set(0, t.y / 2, 0),
      this.controls.update(),
      (this.renderer.outputColorSpace = En),
      (this.renderer.toneMapping = 4),
      (this.renderer.toneMappingExposure = 1),
      this.handleResize()
  }
  handleResize() {
    const t = this.renderer?.domElement?.parentElement
    if (!t) return void console.warn('Parent element not found')
    const e = t?.clientWidth,
      n = t?.clientHeight
    if (this.activeCamera === this.perspectiveCamera)
      (this.perspectiveCamera.aspect = e / n),
        this.perspectiveCamera.updateProjectionMatrix()
    else {
      const t = 10,
        i = e / n
      ;(this.orthographicCamera.left = (-t * i) / 2),
        (this.orthographicCamera.right = (t * i) / 2),
        (this.orthographicCamera.top = t / 2),
        (this.orthographicCamera.bottom = -t / 2),
        this.orthographicCamera.updateProjectionMatrix()
    }
    this.renderer.setSize(e, n)
  }
  animate = e(() => {
    requestAnimationFrame(this.animate),
      this.controls.update(),
      this.renderer.render(this.scene, this.activeCamera)
  }, 'animate')
  captureScene(t, e) {
    return new Promise((n, i) => {
      try {
        const i = this.renderer.domElement.width,
          s = this.renderer.domElement.height
        if (
          (this.renderer.setSize(t, e),
          this.activeCamera === this.perspectiveCamera)
        )
          (this.perspectiveCamera.aspect = t / e),
            this.perspectiveCamera.updateProjectionMatrix()
        else {
          const n = 10,
            i = t / e
          ;(this.orthographicCamera.left = (-n * i) / 2),
            (this.orthographicCamera.right = (n * i) / 2),
            (this.orthographicCamera.top = n / 2),
            (this.orthographicCamera.bottom = -n / 2),
            this.orthographicCamera.updateProjectionMatrix()
        }
        this.renderer.render(this.scene, this.activeCamera)
        const r = this.renderer.domElement.toDataURL('image/png')
        this.renderer.setSize(i, s), this.handleResize(), n(r)
      } catch (s) {
        i(s)
      }
    })
  }
  createSTLMaterial() {
    return new yp({
      color: 8421504,
      metalness: 0.1,
      roughness: 0.8,
      flatShading: !1,
      side: 2
    })
  }
  setViewPosition(t) {
    const e = new ns()
    let n = new Qi(),
      i = new Qi()
    this.currentModel &&
      (e.setFromObject(this.currentModel), e.getCenter(n), e.getSize(i))
    const s = 2 * Math.max(i.x, i.y, i.z)
    switch (t) {
      case 'front':
        this.activeCamera.position.set(0, 0, s)
        break
      case 'top':
        this.activeCamera.position.set(0, s, 0)
        break
      case 'right':
        this.activeCamera.position.set(s, 0, 0)
        break
      case 'isometric':
        this.activeCamera.position.set(s, s, s)
    }
    this.activeCamera.lookAt(n),
      this.controls.target.copy(n),
      this.controls.update()
  }
  setBackgroundColor(t) {
    this.renderer.setClearColor(new br(t)),
      this.renderer.render(this.scene, this.activeCamera)
  }
}
class Dx extends Lx {
  static {
    e(this, 'Load3dAnimation')
  }
  currentAnimation = null
  animationActions = []
  animationClips = []
  selectedAnimationIndex = 0
  isAnimationPlaying = !1
  animationSpeed = 1
  constructor(t) {
    super(t)
  }
  async setupModel(t) {
    await super.setupModel(t),
      this.currentAnimation &&
        (this.currentAnimation.stopAllAction(), (this.animationActions = []))
    let e = []
    t.animations?.length > 0
      ? (e = t.animations)
      : this.originalModel &&
        'animations' in this.originalModel &&
        (e = this.originalModel.animations),
      e.length > 0 &&
        ((this.animationClips = e),
        'Scene' === t.type
          ? (this.currentAnimation = new ff(t))
          : (this.currentAnimation = new ff(this.currentModel)),
        this.animationClips.length > 0 && this.updateSelectedAnimation(0))
  }
  setAnimationSpeed(t) {
    ;(this.animationSpeed = t),
      this.animationActions.forEach((e) => {
        e.setEffectiveTimeScale(t)
      })
  }
  updateSelectedAnimation(t) {
    if (
      !this.currentAnimation ||
      !this.animationClips ||
      t >= this.animationClips.length
    )
      return void console.warn('Invalid animation update request')
    this.animationActions.forEach((t) => {
      t.stop()
    }),
      this.currentAnimation.stopAllAction(),
      (this.animationActions = []),
      (this.selectedAnimationIndex = t)
    const e = this.animationClips[t],
      n = this.currentAnimation.clipAction(e)
    n.setEffectiveTimeScale(this.animationSpeed),
      n.reset(),
      (n.clampWhenFinished = !1),
      (n.loop = 2201),
      this.isAnimationPlaying ? n.play() : (n.play(), (n.paused = !0)),
      (this.animationActions = [n])
  }
  clearModel() {
    this.currentAnimation &&
      (this.animationActions.forEach((t) => {
        t.stop()
      }),
      (this.currentAnimation = null)),
      (this.animationActions = []),
      (this.animationClips = []),
      (this.selectedAnimationIndex = 0),
      (this.isAnimationPlaying = !1),
      (this.animationSpeed = 1),
      super.clearModel()
  }
  getAnimationNames() {
    return this.animationClips.map((t, e) => t.name || `Animation ${e + 1}`)
  }
  toggleAnimation(t) {
    this.currentAnimation && 0 !== this.animationActions.length
      ? ((this.isAnimationPlaying = t ?? !this.isAnimationPlaying),
        this.animationActions.forEach((t) => {
          this.isAnimationPlaying
            ? ((t.paused = !1),
              (0 !== t.time && t.time !== t.getClip().duration) || t.reset())
            : (t.paused = !0)
        }))
      : console.warn('No animation to toggle')
  }
  animate = e(() => {
    if (
      (requestAnimationFrame(this.animate),
      this.currentAnimation && this.isAnimationPlaying)
    ) {
      const t = this.clock.getDelta()
      this.currentAnimation.update(t)
    }
    this.controls.update(), this.renderer.render(this.scene, this.activeCamera)
  }, 'animate')
}
function kx(t) {
  const e = t.lastIndexOf('/')
  return -1 === e ? ['', t] : [t.substring(0, e), t.substring(e + 1)]
}
function Nx(t, e, n = 'input') {
  return `/view?${['filename=' + encodeURIComponent(e), 'type=' + n, 'subfolder=' + t, r.getRandParam().substring(1)].join('&')}`
}
e(kx, 'splitFilePath'), e(Nx, 'getResourceURL')
const Ux =
    'display: flex;\n    flex-direction: column;\n    background: transparent;\n    flex: 1;\n    position: relative;\n    overflow: hidden;',
  Bx =
    'display: flex;\n    width: 100% !important;\n    height: 100% !important;',
  Ox = new Map()
function Fx(t, n, i, s, r, a, o, l, c, h, u, d) {
  const m = e(() => {
    let e = !0
    return async (i) => {
      if (!i) return
      const s = i,
        r = p.apiURL(Nx(...kx(s), n))
      if (
        (await t.loadModel(r, s),
        t.setMaterialMode(o.value),
        t.setUpDirection(h.value),
        d && d(t),
        e && u && 'object' == typeof u)
      ) {
        try {
          t.setCameraState(u)
        } catch (a) {
          console.warn('Failed to restore camera state:', a)
        }
        e = !1
      }
    }
  }, 'createModelUpdateHandler')()
  i.value && m(i.value),
    (i.callback = m),
    t.toggleGrid(s.value),
    (s.callback = (e) => {
      t.toggleGrid(e)
    }),
    t.toggleCamera(r.value),
    (r.callback = (e) => {
      t.toggleCamera(e)
    }),
    (a.callback = (e) => {
      t.setViewPosition(e)
    }),
    (o.callback = (e) => {
      t.setMaterialMode(e)
    }),
    t.setMaterialMode(o.value),
    t.setBackgroundColor(l.value),
    (l.callback = (e) => {
      t.setBackgroundColor(e)
    }),
    t.setLightIntensity(c.value),
    (c.callback = (e) => {
      t.setLightIntensity(e)
    }),
    (h.callback = (e) => {
      t.setUpDirection(e)
    }),
    t.setUpDirection(h.value)
}
e(Fx, 'configureLoad3D'),
  r.registerExtension({
    name: 'Comfy.Load3D',
    getCustomWidgets: (t) => ({
      LOAD_3D(e, n) {
        let i = t.graph._nodes.filter((t) => 'Load3D' == t.type)
        e.addProperty('Camera Info', '')
        const s = document.createElement('div')
        ;(s.id = `comfy-load-3d-${i.length}`), s.classList.add('comfy-load-3d')
        const r = new Lx(s)
        Ox.set(s.id, r),
          (e.onResize = function () {
            r && r.handleResize()
          })
        const a = e.onRemoved
        ;(e.onRemoved = function () {
          r && r.remove(), Ox.delete(s.id), a?.apply(this, [])
        }),
          (e.onDrawBackground = function () {
            r.renderer.domElement.hidden = this.flags.collapsed ?? !1
          })
        const o = document.createElement('input')
        return (
          (o.type = 'file'),
          (o.accept = '.gltf,.glb,.obj,.mtl,.fbx,.stl'),
          (o.style.display = 'none'),
          (o.onchange = async () => {
            if (o.files?.length) {
              const t = e.widgets?.find((t) => 'model_file' === t.name),
                n = await Ix(r, o.files[0], o).catch((t) => {
                  console.error('File upload failed:', t),
                    c().addAlert('File upload failed')
                })
              n &&
                t &&
                (t.options?.values?.includes(n) || t.options?.values?.push(n),
                (t.value = n))
            }
          }),
          e.addWidget('button', 'upload 3d model', 'upload3dmodel', () => {
            o.click()
          }),
          e.addWidget('button', 'clear', 'clear', () => {
            r.clearModel()
            const t = e.widgets?.find((t) => 'model_file' === t.name)
            t && (t.value = '')
          }),
          { widget: e.addDOMWidget(n, 'LOAD_3D', s) }
        )
      }
    }),
    init() {
      const t = document.createElement('style')
      ;(t.innerText = `\n        .comfy-load-3d {\n          ${Ux}\n        }\n        \n        .comfy-load-3d canvas {\n          ${Bx}\n        }\n      `),
        document.head.appendChild(t)
    },
    async nodeCreated(t) {
      if ('Load3D' !== t.constructor.comfyClass) return
      const [e, n] = t.size
      t.setSize([Math.max(e, 300), Math.max(n, 600)]), await Vue.nextTick()
      const i = t.widgets.find((t) => 'image' === t.name),
        s = i.element,
        r = Ox.get(s.id),
        a = t.widgets.find((t) => 'model_file' === t.name),
        o = t.widgets.find((t) => 'show_grid' === t.name),
        l = t.widgets.find((t) => 'camera_type' === t.name),
        h = t.widgets.find((t) => 'view' === t.name),
        u = t.widgets.find((t) => 'material' === t.name),
        d = t.widgets.find((t) => 'bg_color' === t.name),
        m = t.widgets.find((t) => 'light_intensity' === t.name),
        f = t.widgets.find((t) => 'up_direction' === t.name)
      let g
      try {
        const e = t.properties['Camera Info']
        e && 'string' == typeof e && '' !== e.trim() && (g = JSON.parse(e))
      } catch (_) {
        console.warn('Failed to parse camera state:', _), (g = void 0)
      }
      Fx(r, 'input', a, o, l, h, u, d, m, f, g)
      const v = t.widgets.find((t) => 'width' === t.name),
        y = t.widgets.find((t) => 'height' === t.name)
      i.serializeValue = async () => {
        t.properties['Camera Info'] = JSON.stringify(r.getCameraState())
        const e = await r.captureScene(v.value, y.value),
          n = await fetch(e).then((t) => t.blob()),
          i = `scene_${Date.now()}.png`,
          s = new File([n], i),
          a = new FormData()
        a.append('image', s),
          a.append('subfolder', 'threed'),
          a.append('type', 'temp')
        const o = await p.fetchApi('/upload/image', { method: 'POST', body: a })
        if (200 !== o.status) {
          const t = `Error uploading scene capture: ${o.status} - ${o.statusText}`
          throw (c().addAlert(t), new Error(t))
        }
        return `threed/${(await o.json()).name} [temp]`
      }
    }
  }),
  r.registerExtension({
    name: 'Comfy.Load3DAnimation',
    getCustomWidgets: (t) => ({
      LOAD_3D_ANIMATION(e, n) {
        let i = t.graph._nodes.filter((t) => 'Load3DAnimation' == t.type)
        e.addProperty('Camera Info', '')
        const s = document.createElement('div')
        ;(s.id = `comfy-load-3d-animation-${i.length}`),
          s.classList.add('comfy-load-3d-animation')
        const r = new Dx(s)
        Ox.set(s.id, r),
          (e.onResize = function () {
            r && r.handleResize()
          })
        const a = e.onRemoved
        ;(e.onRemoved = function () {
          r && r.remove(), Ox.delete(s.id), a?.apply(this, [])
        }),
          (e.onDrawBackground = function () {
            r.renderer.domElement.hidden = this.flags.collapsed ?? !1
          })
        const o = document.createElement('input')
        ;(o.type = 'file'),
          (o.accept = '.fbx,glb,gltf'),
          (o.style.display = 'none'),
          (o.onchange = async () => {
            if (o.files?.length) {
              const t = e.widgets?.find((t) => 'model_file' === t.name),
                n = await Ix(r, o.files[0], o).catch((t) => {
                  console.error('File upload failed:', t),
                    c().addAlert('File upload failed')
                })
              n &&
                t &&
                (t.options?.values?.includes(n) || t.options?.values?.push(n),
                (t.value = n))
            }
          }),
          e.addWidget('button', 'upload 3d model', 'upload3dmodel', () => {
            o.click()
          }),
          e.addWidget('button', 'clear', 'clear', () => {
            r.clearModel()
            const t = e.widgets?.find((t) => 'model_file' === t.name)
            t && (t.value = '')
            const n = e.widgets?.find((t) => 'animation' === t.name)
            n && ((n.options.values = []), (n.value = ''))
            const i = e.widgets?.find((t) => 'animation_speed' === t.name)
            i && (i.value = '1')
          }),
          e.addWidget(
            'button',
            'Play/Pause Animation',
            'toggle_animation',
            () => {
              r.toggleAnimation()
            }
          )
        return (
          (e.addWidget('combo', 'animation', '', () => '', {
            values: []
          }).callback = (t) => {
            const e = r.getAnimationNames().indexOf(t)
            if (-1 !== e) {
              const t = r.isAnimationPlaying
              t && r.toggleAnimation(!1),
                r.updateSelectedAnimation(e),
                t && r.toggleAnimation(!0)
            }
          }),
          { widget: e.addDOMWidget(n, 'LOAD_3D_ANIMATION', s) }
        )
      }
    }),
    init() {
      const t = document.createElement('style')
      ;(t.innerText = `\n        .comfy-load-3d-animation {\n          ${Ux}\n        }\n        \n        .comfy-load-3d-animation canvas {\n          ${Bx}\n        }\n      `),
        document.head.appendChild(t)
    },
    async nodeCreated(t) {
      if ('Load3DAnimation' !== t.constructor.comfyClass) return
      const [e, n] = t.size
      t.setSize([Math.max(e, 300), Math.max(n, 700)]), await Vue.nextTick()
      const i = t.widgets.find((t) => 'image' === t.name),
        s = i.element,
        r = Ox.get(s.id),
        a = t.widgets.find((t) => 'model_file' === t.name),
        o = t.widgets.find((t) => 'show_grid' === t.name),
        l = t.widgets.find((t) => 'camera_type' === t.name),
        h = t.widgets.find((t) => 'view' === t.name),
        u = t.widgets.find((t) => 'material' === t.name),
        d = t.widgets.find((t) => 'bg_color' === t.name),
        m = t.widgets.find((t) => 'light_intensity' === t.name),
        f = t.widgets.find((t) => 'up_direction' === t.name)
      let g
      t.widgets.find((t) => 'animation_speed' === t.name).callback = (t) => {
        const e = Ox.get(s.id)
        e && e.setAnimationSpeed(parseFloat(t))
      }
      try {
        const e = t.properties['Camera Info']
        e && 'string' == typeof e && '' !== e.trim() && (g = JSON.parse(e))
      } catch (_) {
        console.warn('Failed to parse camera state:', _), (g = void 0)
      }
      Fx(r, 'input', a, o, l, h, u, d, m, f, g, (e) => {
        const n = e.getAnimationNames(),
          i = t.widgets.find((t) => 'animation' === t.name)
        ;(i.options.values = n), n.length && (i.value = n[0])
      })
      const v = t.widgets.find((t) => 'width' === t.name),
        y = t.widgets.find((t) => 'height' === t.name)
      i.serializeValue = async () => {
        ;(t.properties['Camera Info'] = JSON.stringify(r.getCameraState())),
          r.toggleAnimation(!1)
        const e = await r.captureScene(v.value, y.value),
          n = await fetch(e).then((t) => t.blob()),
          i = `scene_${Date.now()}.png`,
          s = new File([n], i),
          a = new FormData()
        a.append('image', s),
          a.append('subfolder', 'threed'),
          a.append('type', 'temp')
        const o = await p.fetchApi('/upload/image', { method: 'POST', body: a })
        if (200 !== o.status) {
          const t = `Error uploading scene capture: ${o.status} - ${o.statusText}`
          throw (c().addAlert(t), new Error(t))
        }
        return `threed/${(await o.json()).name} [temp]`
      }
    }
  }),
  r.registerExtension({
    name: 'Comfy.Preview3D',
    getCustomWidgets: (t) => ({
      PREVIEW_3D(e, n) {
        let i = t.graph._nodes.filter((t) => 'Preview3D' == t.type)
        const s = document.createElement('div')
        ;(s.id = `comfy-preview-3d-${i.length}`),
          s.classList.add('comfy-preview-3d')
        const r = new Lx(s)
        Ox.set(s.id, r),
          (e.onResize = function () {
            r && r.handleResize()
          })
        const a = e.onRemoved
        return (
          (e.onRemoved = function () {
            r && r.remove(), Ox.delete(s.id), a?.apply(this, [])
          }),
          (e.onDrawBackground = function () {
            r.renderer.domElement.hidden = this.flags.collapsed ?? !1
          }),
          { widget: e.addDOMWidget(n, 'PREVIEW_3D', s) }
        )
      }
    }),
    init() {
      const t = document.createElement('style')
      ;(t.innerText = `\n        .comfy-preview-3d {\n          ${Ux}\n        }\n        \n        .comfy-preview-3d canvas {\n          ${Bx}\n        }\n      `),
        document.head.appendChild(t)
    },
    async nodeCreated(t) {
      if ('Preview3D' !== t.constructor.comfyClass) return
      const [e, n] = t.size
      t.setSize([Math.max(e, 300), Math.max(n, 550)]), await Vue.nextTick()
      const i = t.widgets.find((t) => 'image' === t.name).element
      Fx(
        Ox.get(i.id),
        'output',
        t.widgets.find((t) => 'model_file' === t.name),
        t.widgets.find((t) => 'show_grid' === t.name),
        t.widgets.find((t) => 'camera_type' === t.name),
        t.widgets.find((t) => 'view' === t.name),
        t.widgets.find((t) => 'material' === t.name),
        t.widgets.find((t) => 'bg_color' === t.name),
        t.widgets.find((t) => 'light_intensity' === t.name),
        t.widgets.find((t) => 'up_direction' === t.name)
      )
    }
  })
