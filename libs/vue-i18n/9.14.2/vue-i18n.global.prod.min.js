var VueI18n = (function (e, x) {
  'use strict'
  const M = 'undefined' != typeof window,
    a = (e, t = !1) => (t ? Symbol.for(e) : Symbol(e)),
    m = (e, t, n) =>
      ((e) =>
        JSON.stringify(e)
          .replace(/\u2028/g, '\\u2028')
          .replace(/\u2029/g, '\\u2029')
          .replace(/\u0027/g, '\\u0027'))({ l: e, k: t, s: n }),
    w = (e) => 'number' == typeof e && isFinite(e),
    f = (e) => '[object Date]' === v(e),
    U = (e) => '[object RegExp]' === v(e),
    W = (e) => K(e) && 0 === Object.keys(e).length,
    H = Object.assign,
    r = Object.create,
    $ = (e = null) => r(e)
  function I(e) {
    return e
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;')
  }
  const o = Object.prototype.hasOwnProperty
  function V(e, t) {
    return o.call(e, t)
  }
  const j = Array.isArray,
    X = (e) => 'function' == typeof e,
    G = (e) => 'string' == typeof e,
    Y = (e) => 'boolean' == typeof e,
    B = (e) => null !== e && 'object' == typeof e,
    s = (e) => B(e) && X(e.then) && X(e.catch),
    _ = Object.prototype.toString,
    v = (e) => _.call(e),
    K = (e) => {
      if (!B(e)) return !1
      e = Object.getPrototypeOf(e)
      return null === e || e.constructor === Object
    }
  function g(e, r = '') {
    return e.reduce((e, t, n) => (0 === n ? e + t : e + r + t), '')
  }
  function E(e) {
    let t = e
    return () => ++t
  }
  function re(e, t) {
    'undefined' != typeof console &&
      (console.warn('[intlify] ' + e), t && console.warn(t.stack))
  }
  const l = (e) => !B(e) || j(e)
  function z(t, n) {
    if (l(t) || l(n)) throw new Error('Invalid value')
    const r = [{ src: t, des: n }]
    for (; r.length; ) {
      const { src: t, des: n } = r.pop()
      Object.keys(t).forEach((e) => {
        '__proto__' !== e &&
          (B(t[e]) && !B(n[e]) && (n[e] = Array.isArray(t[e]) ? [] : $()),
          l(n[e]) || l(t[e]) ? (n[e] = t[e]) : r.push({ src: t[e], des: n[e] }))
      })
    }
  }
  const b = { USE_MODULO_SYNTAX: 1, __EXTEND_POINT__: 2 },
    R = {
      EXPECTED_TOKEN: 1,
      INVALID_TOKEN_IN_PLACEHOLDER: 2,
      UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
      UNKNOWN_ESCAPE_SEQUENCE: 4,
      INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
      UNBALANCED_CLOSING_BRACE: 6,
      UNTERMINATED_CLOSING_BRACE: 7,
      EMPTY_PLACEHOLDER: 8,
      NOT_ALLOW_NEST_PLACEHOLDER: 9,
      INVALID_LINKED_FORMAT: 10,
      MUST_HAVE_MESSAGES_IN_PLURAL: 11,
      UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
      UNEXPECTED_EMPTY_LINKED_KEY: 13,
      UNEXPECTED_LEXICAL_ANALYSIS: 14,
      UNHANDLED_CODEGEN_NODE_TYPE: 15,
      UNHANDLED_MINIFIER_NODE_TYPE: 16,
      __EXTEND_POINT__: 17
    }
  function k(e) {
    throw e
  }
  const F = ' ',
    S = '\n',
    h = String.fromCharCode(8232),
    L = String.fromCharCode(8233)
  function ae(e) {
    const t = e
    let n = 0,
      r = 1,
      a = 1,
      l = 0
    const o = (e) => '\r' === t[e] && t[e + 1] === S,
      s = (e) => t[e] === L,
      c = (e) => t[e] === h,
      i = (e) => (o(e) || s(e) || c(e) ? S : t[e])
    function u() {
      return (
        (l = 0),
        (e = n),
        (o(e) || ((e) => t[e] === S)(e) || s(e) || c(e)) && (r++, (a = 0)),
        o(n) && n++,
        n++,
        a++,
        t[n]
      )
      var e
    }
    return {
      index: () => n,
      line: () => r,
      column: () => a,
      peekOffset: () => l,
      charAt: i,
      currentChar: () => i(n),
      currentPeek: () => i(n + l),
      next: u,
      peek: function () {
        return o(n + l) && l++, l++, t[n + l]
      },
      reset: function () {
        ;(n = 0), (r = 1), (a = 1), (l = 0)
      },
      resetPeek: function (e = 0) {
        l = e
      },
      skipToPeek: function () {
        for (var e = n + l; e !== n; ) u()
        l = 0
      }
    }
  }
  const D = void 0
  function N(e, t = {}) {
    const a = !1 !== t.location,
      l = ae(e),
      o = () => l.index(),
      s = () => {
        return { line: l.line(), column: l.column(), offset: l.index() }
      },
      n = s(),
      r = o(),
      c = {
        currentType: 14,
        offset: r,
        startLoc: n,
        endLoc: n,
        lastType: 14,
        lastOffset: r,
        lastStartLoc: n,
        lastEndLoc: n,
        braceNest: 0,
        inLinked: !1,
        text: ''
      },
      {} = t
    function i(e, t, n) {
      e.endLoc = s()
      const r = { type: (e.currentType = t) }
      return (
        a &&
          (r.loc = (function (e, t, n) {
            const r = { start: e, end: t }
            return null != n && (r.source = n), r
          })(e.startLoc, e.endLoc)),
        null != n && (r.value = n),
        r
      )
    }
    const u = (e) => i(e, 14)
    function f(e, t) {
      return e.currentChar() === t ? (e.next(), t) : (R.EXPECTED_TOKEN, s(), '')
    }
    function m(e) {
      let t = ''
      for (; e.currentPeek() === F || e.currentPeek() === S; )
        (t += e.currentPeek()), e.peek()
      return t
    }
    function _(e) {
      m(e)
      e.skipToPeek()
    }
    function p(e) {
      if (e === D) return !1
      e = e.charCodeAt(0)
      return (97 <= e && e <= 122) || (65 <= e && e <= 90) || 95 === e
    }
    function d(e) {
      m(e)
      var t = '|' === e.currentPeek()
      return e.resetPeek(), t
    }
    function v(a, e = !0) {
      const l = (e = !1, t = '', n = !1) => {
          var r = a.currentPeek()
          return '{' === r
            ? '%' !== t && e
            : '@' !== r && r
              ? '%' === r
                ? (a.peek(), l(e, '%', !0))
                : '|' === r
                  ? !('%' !== t && !n && (t === F || t === S))
                  : r === F
                    ? (a.peek(), l(!0, F, n))
                    : r !== S || (a.peek(), l(!0, S, n))
              : '%' === t || e
        },
        t = l()
      return e && a.resetPeek(), t
    }
    function g(e, t) {
      var n = e.currentChar()
      return n === D ? D : t(n) ? (e.next(), n) : null
    }
    function E(e) {
      e = e.charCodeAt(0)
      return (
        (97 <= e && e <= 122) ||
        (65 <= e && e <= 90) ||
        (48 <= e && e <= 57) ||
        95 === e ||
        36 === e
      )
    }
    function b(e) {
      e = e.charCodeAt(0)
      return (
        (97 <= e && e <= 122) ||
        (65 <= e && e <= 90) ||
        (48 <= e && e <= 57) ||
        95 === e ||
        36 === e ||
        45 === e
      )
    }
    function k(e) {
      e = e.charCodeAt(0)
      return 48 <= e && e <= 57
    }
    function h(e) {
      e = e.charCodeAt(0)
      return (
        (48 <= e && e <= 57) || (65 <= e && e <= 70) || (97 <= e && e <= 102)
      )
    }
    function L(e) {
      let t = '',
        n = ''
      for (; (t = g(e, k)); ) n += t
      return n
    }
    function N(e) {
      let t = ''
      for (;;) {
        var n = e.currentChar()
        if ('{' === n || '}' === n || '@' === n || '|' === n || !n) break
        if ('%' === n) {
          if (!v(e)) break
          ;(t += n), e.next()
        } else if (n === F || n === S)
          if (v(e)) (t += n), e.next()
          else {
            if (d(e)) break
            ;(t += n), e.next()
          }
        else (t += n), e.next()
      }
      return t
    }
    function T(e) {
      return "'" !== e && e !== S
    }
    function y(t, n, r) {
      f(t, n)
      let a = ''
      for (let e = 0; e < r; e++) {
        const n = g(t, h)
        if (!n) {
          R.INVALID_UNICODE_ESCAPE_SEQUENCE, s(), t.currentChar()
          break
        }
        a += n
      }
      return '\\' + n + a
    }
    function I(e) {
      return '{' !== e && '}' !== e && e !== F && e !== S
    }
    function C(e) {
      _(e)
      var t = f(e, '|')
      return _(e), t
    }
    function O(e, n) {
      let t = null
      switch (e.currentChar()) {
        case '{':
          return (
            1 <= n.braceNest && (R.NOT_ALLOW_NEST_PLACEHOLDER, s()),
            e.next(),
            (t = i(n, 2, '{')),
            _(e),
            n.braceNest++,
            t
          )
        case '}':
          return (
            0 < n.braceNest &&
              2 === n.currentType &&
              (R.EMPTY_PLACEHOLDER, s()),
            e.next(),
            (t = i(n, 3, '}')),
            n.braceNest--,
            0 < n.braceNest && _(e),
            n.inLinked && 0 === n.braceNest && (n.inLinked = !1),
            t
          )
        case '@':
          return (
            0 < n.braceNest && (R.UNTERMINATED_CLOSING_BRACE, s()),
            (t = P(e, n) || u(n)),
            (n.braceNest = 0),
            t
          )
        default:
          var r,
            a = !0
          if (d(e))
            return (
              0 < n.braceNest && (R.UNTERMINATED_CLOSING_BRACE, s()),
              (t = i(n, 1, C(e))),
              (n.braceNest = 0),
              (n.inLinked = !1),
              t
            )
          if (
            0 < n.braceNest &&
            (5 === n.currentType || 6 === n.currentType || 7 === n.currentType)
          )
            return R.UNTERMINATED_CLOSING_BRACE, s(), (n.braceNest = 0), A(e, n)
          if (
            (r = (function (e) {
              var t = n['currentType']
              if (2 !== t) return !1
              m(e)
              t = p(e.currentPeek())
              return e.resetPeek(), t
            })(e))
          )
            return (
              (t = i(
                n,
                5,
                (function (e) {
                  _(e)
                  let t = '',
                    n = ''
                  for (; (t = g(e, b)); ) n += t
                  return (
                    e.currentChar() === D &&
                      (R.UNTERMINATED_CLOSING_BRACE, s()),
                    n
                  )
                })(e)
              )),
              _(e),
              t
            )
          if (
            ((l = e),
            (a =
              2 === (o = (o = n).currentType) &&
              (m(l),
              (o = (function (e) {
                if (e === D) return !1
                e = e.charCodeAt(0)
                return 48 <= e && e <= 57
              })('-' === l.currentPeek() ? l.peek() : l.currentPeek())),
              l.resetPeek(),
              o)))
          )
            return (
              (t = i(
                n,
                6,
                (function (e) {
                  _(e)
                  let t = ''
                  return (
                    '-' === e.currentChar()
                      ? (e.next(), (t += '-' + L(e)))
                      : (t += L(e)),
                    e.currentChar() === D &&
                      (R.UNTERMINATED_CLOSING_BRACE, s()),
                    t
                  )
                })(e)
              )),
              _(e),
              t
            )
          if (
            (l = (function (e) {
              var t = n['currentType']
              if (2 !== t) return !1
              m(e)
              t = "'" === e.currentPeek()
              return e.resetPeek(), t
            })(e))
          )
            return (
              (t = i(
                n,
                7,
                (function (e) {
                  _(e), f(e, "'")
                  let t,
                    n = ''
                  for (; (t = g(e, T)); )
                    n +=
                      '\\' === t
                        ? (function (e) {
                            var t = e.currentChar()
                            switch (t) {
                              case '\\':
                              case "'":
                                return e.next(), '\\' + t
                              case 'u':
                                return y(e, t, 4)
                              case 'U':
                                return y(e, t, 6)
                              default:
                                return R.UNKNOWN_ESCAPE_SEQUENCE, s(), ''
                            }
                          })(e)
                        : t
                  var r = e.currentChar()
                  return (
                    r === S || r === D
                      ? (R.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER,
                        s(),
                        r === S && (e.next(), f(e, "'")))
                      : f(e, "'"),
                    n
                  )
                })(e)
              )),
              _(e),
              t
            )
          if (r || a || l) break
          return (
            (t = i(
              n,
              13,
              (function (e) {
                _(e)
                let t,
                  n = ''
                for (; (t = g(e, I)); ) n += t
                return n
              })(e)
            )),
            R.INVALID_TOKEN_IN_PLACEHOLDER,
            s(),
            t.value,
            _(e),
            t
          )
      }
      var l, o
      return t
    }
    function P(e, a) {
      var t = a['currentType']
      let n = null
      var r = e.currentChar()
      switch (
        ((8 !== t && 9 !== t && 12 !== t && 10 !== t) ||
          (r !== S && r !== F) ||
          (R.INVALID_LINKED_FORMAT, s()),
        r)
      ) {
        case '@':
          return e.next(), (n = i(a, 8, '@')), (a.inLinked = !0), n
        case '.':
          return _(e), e.next(), i(a, 9, '.')
        case ':':
          return _(e), e.next(), i(a, 10, ':')
        default:
          return d(e)
            ? ((n = i(a, 1, C(e))), (a.braceNest = 0), (a.inLinked = !1), n)
            : (function (e) {
                  var t = a['currentType']
                  if (8 === t)
                    return m(e), (t = '.' === e.currentPeek()), e.resetPeek(), t
                })(e) ||
                (function (e) {
                  var t = a['currentType']
                  if (8 === t || 12 === t)
                    return m(e), (t = ':' === e.currentPeek()), e.resetPeek(), t
                })(e)
              ? (_(e), P(e, a))
              : (function (e) {
                    var t = a['currentType']
                    if (9 === t)
                      return m(e), (t = p(e.currentPeek())), e.resetPeek(), t
                  })(e)
                ? (_(e),
                  i(
                    a,
                    12,
                    (function (e) {
                      let t = '',
                        n = ''
                      for (; (t = g(e, E)); ) n += t
                      return n
                    })(e)
                  ))
                : (function (t) {
                      var e = a['currentType']
                      if (10 === e) {
                        const n = () => {
                            var e = t.currentPeek()
                            return '{' === e
                              ? p(t.peek())
                              : !(
                                  '@' === e ||
                                  '%' === e ||
                                  '|' === e ||
                                  ':' === e ||
                                  '.' === e ||
                                  e === F ||
                                  !e
                                ) && (e === S ? (t.peek(), n()) : v(t, !1))
                          },
                          r = n()
                        return t.resetPeek(), r
                      }
                    })(e)
                  ? (_(e),
                    '{' === r
                      ? O(e, a) || n
                      : i(
                          a,
                          11,
                          (function (n) {
                            const r = (e) => {
                              var t = n.currentChar()
                              return '{' === t ||
                                '%' === t ||
                                '@' === t ||
                                '|' === t ||
                                '(' === t ||
                                ')' === t ||
                                !t ||
                                t === F
                                ? e
                                : ((e += t), n.next(), r(e))
                            }
                            return r('')
                          })(e)
                        ))
                  : (8 === t && (R.INVALID_LINKED_FORMAT, s()),
                    (a.braceNest = 0),
                    (a.inLinked = !1),
                    A(e, a))
      }
    }
    function A(e, t) {
      let n = { type: 14 }
      if (0 < t.braceNest) return O(e, t) || u(t)
      if (t.inLinked) return P(e, t) || u(t)
      switch (e.currentChar()) {
        case '{':
          return O(e, t) || u(t)
        case '}':
          return R.UNBALANCED_CLOSING_BRACE, s(), e.next(), i(t, 3, '}')
        case '@':
          return P(e, t) || u(t)
        default:
          if (d(e))
            return (n = i(t, 1, C(e))), (t.braceNest = 0), (t.inLinked = !1), n
          ;(l = m((r = e))),
            (a = '%' === r.currentPeek() && '{' === r.peek()),
            r.resetPeek()
          var { isModulo: r, hasSpace: a } = {
            isModulo: a,
            hasSpace: 0 < l.length
          }
          if (r)
            return a
              ? i(t, 0, N(e))
              : i(
                  t,
                  4,
                  (_((l = e)),
                  '%' !== l.currentChar() && (R.EXPECTED_TOKEN, s()),
                  l.next(),
                  '%')
                )
          if (v(e)) return i(t, 0, N(e))
      }
      var l
      return n
    }
    return {
      nextToken: function () {
        var { currentType: e, offset: t, startLoc: n, endLoc: r } = c
        return (
          (c.lastType = e),
          (c.lastOffset = t),
          (c.lastStartLoc = n),
          (c.lastEndLoc = r),
          (c.offset = o()),
          (c.startLoc = s()),
          l.currentChar() === D ? i(c, 14) : A(l, c)
        )
      },
      currentOffset: o,
      currentPosition: s,
      context: () => c
    }
  }
  const T = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g
  function y(e, t, n) {
    switch (e) {
      case '\\\\':
        return '\\'
      case "\\'":
        return "'"
      default: {
        const e = parseInt(t || n, 16)
        return e <= 55295 || 57344 <= e ? String.fromCodePoint(e) : 'ï¿½'
      }
    }
  }
  function C(a = {}) {
    const l = !1 !== a.location,
      {} = a
    function u(e, t, n) {
      const r = { type: e }
      return (
        l && ((r.start = t), (r.end = t), (r.loc = { start: n, end: n })), r
      )
    }
    function f(e, t, n, r) {
      r && (e.type = r), l && ((e.end = t), e.loc && (e.loc.end = n))
    }
    function o(e, t) {
      const n = e.context(),
        r = u(3, n.offset, n.startLoc)
      return (r.value = t), f(r, e.currentOffset(), e.currentPosition()), r
    }
    function s(e, t) {
      const n = e.context(),
        { lastOffset: r, lastStartLoc: a } = n,
        l = u(5, r, a)
      return (
        (l.index = parseInt(t, 10)),
        e.nextToken(),
        f(l, e.currentOffset(), e.currentPosition()),
        l
      )
    }
    function c(e, t, n) {
      const r = e.context(),
        { lastOffset: a, lastStartLoc: l } = r,
        o = u(4, a, l)
      return (
        (o.key = t),
        !0 === n && (o.modulo = !0),
        e.nextToken(),
        f(o, e.currentOffset(), e.currentPosition()),
        o
      )
    }
    function i(e, t) {
      const n = e.context(),
        { lastOffset: r, lastStartLoc: a } = n,
        l = u(9, r, a)
      return (
        (l.value = t.replace(T, y)),
        e.nextToken(),
        f(l, e.currentOffset(), e.currentPosition()),
        l
      )
    }
    function m(e) {
      const t = e.context(),
        n = u(6, t.offset, t.startLoc)
      let r = e.nextToken()
      if (9 === r.type) {
        const t = (function (e) {
          const t = e.nextToken(),
            n = e.context(),
            { lastOffset: r, lastStartLoc: a } = n,
            l = u(8, r, a)
          return 12 !== t.type
            ? (R.UNEXPECTED_EMPTY_LINKED_MODIFIER,
              n.lastStartLoc,
              (l.value = ''),
              f(l, r, a),
              { nextConsumeToken: t, node: l })
            : (null == t.value &&
                (R.UNEXPECTED_LEXICAL_ANALYSIS, n.lastStartLoc, p(t)),
              (l.value = t.value || ''),
              f(l, e.currentOffset(), e.currentPosition()),
              { node: l })
        })(e)
        ;(n.modifier = t.node), (r = t.nextConsumeToken || e.nextToken())
      }
      switch (
        (10 !== r.type && (R.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, p(r)),
        (r = 2 === (r = e.nextToken()).type ? e.nextToken() : r).type)
      ) {
        case 11:
          null == r.value &&
            (R.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, p(r)),
            (n.key = (function (e, t) {
              const n = e.context(),
                r = u(7, n.offset, n.startLoc)
              return (
                (r.value = t), f(r, e.currentOffset(), e.currentPosition()), r
              )
            })(e, r.value || ''))
          break
        case 5:
          null == r.value &&
            (R.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, p(r)),
            (n.key = c(e, r.value || ''))
          break
        case 6:
          null == r.value &&
            (R.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, p(r)),
            (n.key = s(e, r.value || ''))
          break
        case 7:
          null == r.value &&
            (R.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, p(r)),
            (n.key = i(e, r.value || ''))
          break
        default: {
          R.UNEXPECTED_EMPTY_LINKED_KEY, t.lastStartLoc
          const a = e.context(),
            s = u(7, a.offset, a.startLoc)
          return (
            (s.value = ''),
            f(s, a.offset, a.startLoc),
            (n.key = s),
            f(n, a.offset, a.startLoc),
            { nextConsumeToken: r, node: n }
          )
        }
      }
      return f(n, e.currentOffset(), e.currentPosition()), { node: n }
    }
    function _(e) {
      const t = e.context(),
        n = u(
          2,
          1 === t.currentType ? e.currentOffset() : t.offset,
          1 === t.currentType ? t.endLoc : t.startLoc
        )
      n.items = []
      let r = null,
        a = null
      do {
        const u = r || e.nextToken()
        switch (((r = null), u.type)) {
          case 0:
            null == u.value &&
              (R.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, p(u)),
              n.items.push(o(e, u.value || ''))
            break
          case 6:
            null == u.value &&
              (R.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, p(u)),
              n.items.push(s(e, u.value || ''))
            break
          case 4:
            a = !0
            break
          case 5:
            null == u.value &&
              (R.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, p(u)),
              n.items.push(c(e, u.value || '', !!a)),
              a && (b.USE_MODULO_SYNTAX, t.lastStartLoc, p(u), (a = null))
            break
          case 7:
            null == u.value &&
              (R.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, p(u)),
              n.items.push(i(e, u.value || ''))
            break
          case 8: {
            const t = m(e)
            n.items.push(t.node), (r = t.nextConsumeToken || null)
            break
          }
        }
      } while (14 !== t.currentType && 1 !== t.currentType)
      return (
        f(
          n,
          1 === t.currentType ? t.lastOffset : e.currentOffset(),
          1 === t.currentType ? t.lastEndLoc : e.currentPosition()
        ),
        n
      )
    }
    return {
      parse: function (e) {
        const t = N(e, H({}, a)),
          n = t.context(),
          r = u(0, n.offset, n.startLoc)
        return (
          l && r.loc && (r.loc.source = e),
          (r.body = (function (t) {
            var { offset: n, startLoc: r } = (s = t.context()),
              a = _(t)
            if (14 === s.currentType) return a
            {
              var l = t,
                o = n,
                s = r,
                t = a,
                c = l.context()
              let e = 0 === t.items.length
              const i = u(1, o, s)
              ;(i.cases = []), i.cases.push(t)
              do {
                const o = _(l)
                ;(e = e || 0 === o.items.length), i.cases.push(o)
              } while (14 !== c.currentType)
              return f(i, l.currentOffset(), l.currentPosition()), i
            }
          })(t)),
          a.onCacheKey && (r.cacheKey = a.onCacheKey(e)),
          14 !== n.currentType &&
            (R.UNEXPECTED_LEXICAL_ANALYSIS, n.lastStartLoc, e[n.offset]),
          f(r, t.currentOffset(), t.currentPosition()),
          r
        )
      }
    }
  }
  function p(e) {
    if (14 !== e.type) {
      const t = (e.value || '').replace(/\r?\n/gu, '\\n')
      10 < t.length ? t.slice(0, 9) : t
    }
  }
  function O(t, n) {
    for (let e = 0; e < t.length; e++) P(t[e], n)
  }
  function P(e, t) {
    switch (e.type) {
      case 1:
        O(e.cases, t), t.helper('plural')
        break
      case 2:
        O(e.items, t)
        break
      case 6:
        P(e.key, t), t.helper('linked'), t.helper('type')
        break
      case 5:
        t.helper('interpolate'), t.helper('list')
        break
      case 4:
        t.helper('interpolate'), t.helper('named')
    }
  }
  function A(t) {
    if (1 === t.items.length) {
      const e = t.items[0]
      ;(3 !== e.type && 9 !== e.type) || ((t.static = e.value), delete e.value)
    } else {
      const r = []
      for (let e = 0; e < t.items.length; e++) {
        var n = t.items[e]
        if (3 !== n.type && 9 !== n.type) break
        if (null == n.value) break
        r.push(n.value)
      }
      if (r.length === t.items.length) {
        t.static = g(r)
        for (let e = 0; e < t.items.length; e++) {
          const a = t.items[e]
          ;(3 !== a.type && 9 !== a.type) || delete a.value
        }
      }
    }
  }
  const le = (e, t = {}) => {
    const n = G(t.mode) ? t.mode : 'normal',
      r = G(t.filename) ? t.filename : 'message.intl',
      a = !!t.sourceMap,
      l =
        null != t.breakLineCode ? t.breakLineCode : 'arrow' === n ? ';' : '\n',
      o = t.needIndent || 'arrow' !== n,
      s = e.helpers || [],
      c = (function (e, t) {
        const { filename: n, breakLineCode: r, needIndent: a } = t,
          l = !1 !== t.location,
          o = {
            filename: n,
            code: '',
            column: 1,
            line: 1,
            offset: 0,
            map: void 0,
            breakLineCode: r,
            needIndent: a,
            indentLevel: 0
          }
        function s(e, t) {
          o.code += e
        }
        function c(e, t = !0) {
          t = t ? r : ''
          s(a ? t + '  '.repeat(e) : t)
        }
        return (
          l && e.loc && (o.source = e.loc.source),
          {
            context: () => o,
            push: s,
            indent: function (e = !0) {
              var t = ++o.indentLevel
              e && c(t)
            },
            deindent: function (e = !0) {
              var t = --o.indentLevel
              e && c(t)
            },
            newline: function () {
              c(o.indentLevel)
            },
            helper: (e) => '_' + e,
            needIndent: () => o.needIndent
          }
        )
      })(e, {
        mode: n,
        filename: r,
        sourceMap: a,
        breakLineCode: l,
        needIndent: o
      }),
      { code: i, map: u } =
        (c.push('normal' === n ? 'function __msg__ (ctx) {' : '(ctx) => {'),
        c.indent(o),
        0 < s.length &&
          (c.push(
            `const { ${g(
              s.map((e) => e + ': _' + e),
              ', '
            )} } = ctx`
          ),
          c.newline()),
        c.push('return '),
        (function t(e, n) {
          const r = e.helper
          switch (n.type) {
            case 0:
              ;(f = e), n.body ? t(f, n.body) : f.push('null')
              break
            case 1:
              {
                var a = e,
                  l = n
                const { helper: m, needIndent: _ } = a
                if (1 < l.cases.length) {
                  a.push(m('plural') + '(['), a.indent(_())
                  var o = l.cases.length
                  for (let e = 0; e < o && (t(a, l.cases[e]), e !== o - 1); e++)
                    a.push(', ')
                  a.deindent(_()), a.push('])')
                }
              }
              break
            case 2:
              {
                var s = e,
                  c = n
                const { helper: p, needIndent: d } = s
                s.push(p('normalize') + '(['), s.indent(d())
                var i = c.items.length
                for (let e = 0; e < i && (t(s, c.items[e]), e !== i - 1); e++)
                  s.push(', ')
                s.deindent(d()), s.push('])')
              }
              break
            case 6:
              {
                var u = n
                const v = (f = e).helper
                f.push(v('linked') + '('),
                  t(f, u.key),
                  u.modifier
                    ? (f.push(', '), t(f, u.modifier), f.push(', _type'))
                    : f.push(', undefined, _type'),
                  f.push(')')
              }
              break
            case 8:
            case 7:
            case 9:
            case 3:
              e.push(JSON.stringify(n.value), n)
              break
            case 5:
              e.push(`${r('interpolate')}(${r('list')}(${n.index}))`, n)
              break
            case 4:
              e.push(
                `${r('interpolate')}(${r('named')}(${JSON.stringify(n.key)}))`,
                n
              )
          }
          var f
        })(c, e),
        c.deindent(o),
        c.push('}'),
        delete e.helpers,
        c.context())
    return { ast: e, code: i, map: u ? u.toJSON() : void 0 }
  }
  function oe(e, t = {}) {
    var t = H({}, t),
      n = !!t.jit,
      r = !!t.minify,
      a = null == t.optimize || t.optimize,
      e = C(t).parse(e)
    {
      if (n) {
        if (a) {
          const l = e.body
          2 === l.type ? A(l) : l.cases.forEach((e) => A(e))
        }
        return (
          r &&
            (function t(e) {
              switch (((e.t = e.type), e.type)) {
                case 0: {
                  const n = e
                  t(n.body), (n.b = n.body), delete n.body
                  break
                }
                case 1: {
                  const r = e,
                    a = r.cases
                  for (let e = 0; e < a.length; e++) t(a[e])
                  ;(r.c = a), delete r.cases
                  break
                }
                case 2: {
                  const l = e,
                    o = l.items
                  for (let e = 0; e < o.length; e++) t(o[e])
                  ;(l.i = o),
                    delete l.items,
                    l.static && ((l.s = l.static), delete l.static)
                  break
                }
                case 3:
                case 9:
                case 8:
                case 7: {
                  const s = e
                  s.value && ((s.v = s.value), delete s.value)
                  break
                }
                case 6: {
                  const c = e
                  t(c.key),
                    (c.k = c.key),
                    delete c.key,
                    c.modifier &&
                      (t(c.modifier), (c.m = c.modifier), delete c.modifier)
                  break
                }
                case 5: {
                  const i = e
                  ;(i.i = i.index), delete i.index
                  break
                }
                case 4: {
                  const u = e
                  ;(u.k = u.key), delete u.key
                  break
                }
              }
              delete e.type
            })(e),
          { ast: e, code: '' }
        )
      }
      {
        const o = (function (e) {
          const t = { ast: e, helpers: new Set() }
          return { context: () => t, helper: (e) => (t.helpers.add(e), e) }
        })((n = e))
        o.helper('normalize'),
          n.body && P(n.body, o),
          (a = o.context()),
          (n.helpers = Array.from(a.helpers))
      }
      return le(e, t)
    }
  }
  const d = [],
    se =
      ((d[0] = { w: [0], i: [3, 0], '[': [4], o: [7] }),
      (d[1] = { w: [1], '.': [2], '[': [4], o: [7] }),
      (d[2] = { w: [2], i: [3, 0], 0: [3, 0] }),
      (d[3] = {
        i: [3, 0],
        0: [3, 0],
        w: [1, 1],
        '.': [2, 1],
        '[': [4, 1],
        o: [7, 1]
      }),
      (d[4] = {
        "'": [5, 0],
        '"': [6, 0],
        '[': [4, 2],
        ']': [1, 3],
        o: 8,
        l: [4, 0]
      }),
      (d[5] = { "'": [4, 0], o: 8, l: [5, 0] }),
      (d[6] = { '"': [4, 0], o: 8, l: [6, 0] }),
      /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/)
  const ce = new Map()
  const ie = (e) => e,
    ue = (e) => '',
    fe = (e) => (0 === e.length ? '' : g(e)),
    me = (e) =>
      null == e
        ? ''
        : j(e) || (K(e) && e.toString === _)
          ? JSON.stringify(e, null, 2)
          : String(e)
  function _e(e, t) {
    return (
      (e = Math.abs(e)),
      2 === t ? (!e || 1 < e ? 1 : 0) : e ? Math.min(e, 2) : 0
    )
  }
  function pe(o = {}) {
    const e = o.locale,
      t =
        ((s = o),
        (c = w(s.pluralIndex) ? s.pluralIndex : -1),
        s.named && (w(s.named.count) || w(s.named.n))
          ? w(s.named.count)
            ? s.named.count
            : w(s.named.n)
              ? s.named.n
              : c
          : c),
      n =
        B(o.pluralRules) && G(e) && X(o.pluralRules[e]) ? o.pluralRules[e] : _e,
      r = B(o.pluralRules) && G(e) && X(o.pluralRules[e]) ? _e : void 0,
      a = o.list || [],
      l = o.named || $()
    var s, c
    function i(e) {
      return (
        (X(o.messages) ? o.messages(e) : !!B(o.messages) && o.messages[e]) ||
        (o.parent ? o.parent.message(e) : ue)
      )
    }
    w(o.pluralIndex) &&
      ((s = t), (c = l).count || (c.count = s), c.n || (c.n = s))
    const u =
        K(o.processor) && X(o.processor.normalize) ? o.processor.normalize : fe,
      f =
        K(o.processor) && X(o.processor.interpolate)
          ? o.processor.interpolate
          : me,
      m = {
        list: (e) => a[e],
        named: (e) => l[e],
        plural: (e) => e[n(t, e.length, r)],
        linked: (e, ...t) => {
          var [n, r] = t
          let a = 'text',
            l = ''
          1 === t.length
            ? B(n)
              ? ((l = n.modifier || l), (a = n.type || a))
              : G(n) && (l = n || l)
            : 2 === t.length && (G(n) && (l = n || l), G(r) && (a = r || a))
          ;(t = i(e)(m)), (n = 'vnode' === a && j(t) && l ? t[0] : t)
          return l ? ((r = l), (o.modifiers ? o.modifiers[r] : ie)(n, a)) : n
        },
        message: i,
        type: K(o.processor) && G(o.processor.type) ? o.processor.type : 'text',
        interpolate: f,
        normalize: u,
        values: H($(), a, l)
      }
    return m
  }
  const de = R.__EXTEND_POINT__,
    t = E(de),
    c = {
      INVALID_ARGUMENT: de,
      INVALID_DATE_ARGUMENT: t(),
      INVALID_ISO_DATE_ARGUMENT: t(),
      NOT_SUPPORT_NON_STRING_MESSAGE: t(),
      NOT_SUPPORT_LOCALE_PROMISE_VALUE: t(),
      NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: t(),
      NOT_SUPPORT_LOCALE_TYPE: t(),
      __EXTEND_POINT__: t()
    }
  function ve(e, t) {
    return null != t.locale ? Ee(t.locale) : Ee(e.locale)
  }
  let ge
  function Ee(e) {
    if (G(e)) return e
    if (X(e)) {
      if (e.resolvedOnce && null != ge) return ge
      if ('Function' !== e.constructor.name)
        throw Error(c.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION)
      e = e()
      if (s(e)) throw Error(c.NOT_SUPPORT_LOCALE_PROMISE_VALUE)
      return (ge = e)
    }
    throw Error(c.NOT_SUPPORT_LOCALE_TYPE)
  }
  function be(e, t, n) {
    return [
      ...new Set([n, ...(j(t) ? t : B(t) ? Object.keys(t) : G(t) ? [t] : [n])])
    ]
  }
  function ke(t, n, r) {
    const a = G(r) ? r : Q,
      l = t
    l.__localeChainCache || (l.__localeChainCache = new Map())
    let o = l.__localeChainCache.get(a)
    if (!o) {
      o = []
      let e = [r]
      for (; j(e); ) e = he(o, e, n)
      t = j(n) || !K(n) ? n : n.default || null
      ;(e = G(t) ? [t] : t),
        j(e) && he(o, e, !1),
        l.__localeChainCache.set(a, o)
    }
    return o
  }
  function he(t, n, r) {
    let a = !0
    for (let e = 0; e < n.length && Y(a); e++) {
      var l = n[e]
      G(l) &&
        (a = (function (e, t, n) {
          let r
          const a = t.split('-')
          for (
            ;
            (r = (function (e, t, n) {
              let r = !1
              !e.includes(t) &&
                ((r = !0), t) &&
                ((r = '!' !== t[t.length - 1]),
                (t = t.replace(/!/g, '')),
                e.push(t),
                (j(n) || K(n)) && n[t] && (r = n[t]))
              return r
            })(e, a.join('-'), n)),
              a.splice(-1, 1),
              a.length && !0 === r;

          );
          return r
        })(t, n[e], r))
    }
    return a
  }
  const Le = '9.14.2',
    J = -1,
    Q = 'en-US',
    Ne = '',
    Te = (e) => '' + e.charAt(0).toLocaleUpperCase() + e.substr(1)
  let ye,
    Ie,
    Ce,
    Oe = null
  const Pe = (e) => {
      Oe = e
    },
    Ae = () => Oe
  let Re = 0
  const Fe = (e) => ({ [e]: $() })
  function Se(e, t, n, r, a) {
    const l = e['missing']
    if (null === l) return t
    {
      const r = l(e, n, t, a)
      return G(r) ? r : t
    }
  }
  function q(e, t, n) {
    ;(e.__localeChainCache = new Map()), e.localeFallbacker(e, n, t)
  }
  function De(r) {
    return (e) => {
      var n = e,
        t = r,
        e = i(t, Me)
      if (null == e) throw u(0)
      if (1 !== $e(e)) return xe(n, e)
      {
        const t = i(e, we, [])
        return n.plural(t.reduce((e, t) => [...e, xe(n, t)], []))
      }
    }
  }
  const Me = ['b', 'body'],
    we = ['c', 'cases']
  function xe(n, e) {
    const t = i(e, Ue)
    if (null != t) return 'text' === n.type ? t : n.normalize([t])
    {
      const t = i(e, We, []).reduce(
        (e, t) => [
          ...e,
          (function e(t, n) {
            const r = $e(n)
            switch (r) {
              case 3:
              case 9:
              case 7:
              case 8:
                return je(n, r)
              case 4: {
                const a = n
                if (V(a, 'k') && a.k) return t.interpolate(t.named(a.k))
                if (V(a, 'key') && a.key) return t.interpolate(t.named(a.key))
                throw u(r)
              }
              case 5: {
                const l = n
                if (V(l, 'i') && w(l.i)) return t.interpolate(t.list(l.i))
                if (V(l, 'index') && w(l.index))
                  return t.interpolate(t.list(l.index))
                throw u(r)
              }
              case 6: {
                const r = n,
                  o = (function (e) {
                    return i(e, Xe)
                  })(r),
                  s = (function (e) {
                    const t = i(e, Ge)
                    if (t) return t
                    throw u(6)
                  })(r)
                return t.linked(e(t, s), o ? e(t, o) : void 0, t.type)
              }
              default:
                throw new Error('unhandled node on format message part: ' + r)
            }
          })(n, t)
        ],
        []
      )
      return n.normalize(t)
    }
  }
  const Ue = ['s', 'static'],
    We = ['i', 'items']
  const He = ['t', 'type']
  function $e(e) {
    return i(e, He)
  }
  const Ve = ['v', 'value']
  function je(e, t) {
    e = i(e, Ve)
    if (e) return e
    throw u(t)
  }
  const Xe = ['m', 'modifier'],
    Ge = ['k', 'key']
  function i(t, n, r) {
    for (let e = 0; e < n.length; e++) {
      const r = n[e]
      if (V(t, r) && null != t[r]) return t[r]
    }
    return r
  }
  function u(e) {
    return new Error('unhandled node type: ' + e)
  }
  const Ye = (e) => e
  let Be = $()
  function Z(e) {
    return B(e) && 0 === $e(e) && (V(e, 'b') || V(e, 'body'))
  }
  const Ke = () => '',
    ee = (e) => X(e)
  function ze(e, ...t) {
    const {
        fallbackFormat: n,
        postTranslation: r,
        unresolving: a,
        messageCompiler: l,
        fallbackLocale: o,
        messages: s
      } = e,
      [c, i] = qe(...t),
      u = (Y(i.missingWarn) ? i : e).missingWarn,
      f = (Y(i.fallbackWarn) ? i : e).fallbackWarn,
      m = (Y(i.escapeParameter) ? i : e).escapeParameter,
      _ = !!i.resolvedMessage,
      p =
        G(i.default) || Y(i.default)
          ? Y(i.default)
            ? l
              ? c
              : () => c
            : i.default
          : n
            ? l
              ? c
              : () => c
            : '',
      d = n || '' !== p,
      v = ve(e, i)
    var g
    m &&
      ((g = i),
      j(g.list)
        ? (g.list = g.list.map((e) => (G(e) ? I(e) : e)))
        : B(g.named) &&
          Object.keys(g.named).forEach((e) => {
            G(g.named[e]) && (g.named[e] = I(g.named[e]))
          }))
    let [E, b, k] = _ ? [c, v, s[v] || $()] : Je(e, c, v, o),
      h = E,
      L = c
    if (
      (_ || G(h) || Z(h) || ee(h) || (d && ((h = p), (L = h))),
      !(_ || ((G(h) || Z(h) || ee(h)) && G(b))))
    )
      return a ? J : c
    let N = !1
    t = ee(h)
      ? h
      : Qe(e, c, b, h, L, () => {
          N = !0
        })
    if (N) return h
    const T = (function (r, a, e, t) {
        const {
            modifiers: n,
            pluralRules: l,
            messageResolver: o,
            fallbackLocale: s,
            fallbackWarn: c,
            missingWarn: i,
            fallbackContext: u
          } = r,
          f = {
            locale: a,
            modifiers: n,
            pluralRules: l,
            messages: (t) => {
              let n = o(e, t)
              if (null == n && u) {
                const [, , r] = Je(u, t, a, s, c, i)
                n = o(r, t)
              }
              if (G(n) || Z(n)) {
                let e = !1
                t = Qe(r, t, a, n, t, () => {
                  e = !0
                })
                return e ? Ke : t
              }
              return ee(n) ? n : Ke
            }
          }
        return (
          r.processor && (f.processor = r.processor),
          t.list && (f.list = t.list),
          t.named && (f.named = t.named),
          w(t.plural) && (f.pluralIndex = t.plural),
          f
        )
      })(e, b, k, i),
      y = t(pe(T))
    return r ? r(y, c) : y
  }
  function Je(t, n, r, e) {
    const { messages: a, messageResolver: l, localeFallbacker: o } = t,
      s = o(t, e, r)
    let c,
      i = $(),
      u = null
    for (
      let e = 0;
      e < s.length &&
      ((c = s[e]),
      (i = a[c] || $()),
      null === (u = l(i, n)) && (u = i[n]),
      !(G(u) || Z(u) || ee(u)));
      e++
    )
      if (
        !(function (t, n) {
          var r,
            a = n.indexOf(t)
          if (-1 !== a)
            for (let e = a + 1; e < n.length; e++)
              if (t !== (r = n[e]) && t.split('-')[0] === r.split('-')[0])
                return 1
        })(c, s)
      ) {
        const r = Se(t, n, c, 0, 'translate')
        r !== n && (u = r)
      }
    return [u, c, i]
  }
  function Qe(e, t, n, r, a, l) {
    const { messageCompiler: o, warnHtmlMessage: s } = e
    if (ee(r)) {
      const e = r
      return (e.locale = e.locale || n), (e.key = e.key || t), e
    }
    if (null == o) {
      const e = () => r
      return (e.locale = n), (e.key = t), e
    }
    const c = o(
      r,
      ((f = l),
      {
        locale: (i = n),
        key: (u = a),
        warnHtmlMessage: s,
        onError: (e) => {
          throw (f && f(e), e)
        },
        onCacheKey: (e) => m(i, u, e)
      })
    )
    var i, u, f
    return (c.locale = n), (c.key = t), (c.source = r), c
  }
  function qe(...e) {
    const [t, n, r] = e,
      a = $()
    if (!(G(t) || w(t) || ee(t) || Z(t))) throw Error(c.INVALID_ARGUMENT)
    e = w(t) ? String(t) : (ee(t), t)
    return (
      w(n)
        ? (a.plural = n)
        : G(n)
          ? (a.default = n)
          : K(n) && !W(n)
            ? (a.named = n)
            : j(n) && (a.list = n),
      w(r) ? (a.plural = r) : G(r) ? (a.default = r) : K(r) && H(a, r),
      [e, a]
    )
  }
  function Ze(t, ...e) {
    const {
        datetimeFormats: n,
        unresolving: r,
        fallbackLocale: a,
        localeFallbacker: l
      } = t,
      o = t['__datetimeFormatters'],
      [s, c, i, u] = tt(...e)
    ;(Y(i.missingWarn) ? i : t).missingWarn,
      (Y(i.fallbackWarn) ? i : t).fallbackWarn
    var e = !!i.part,
      f = ve(t, i),
      m = l(t, a, f)
    if (!G(s) || '' === s) return new Intl.DateTimeFormat(f, u).format(c)
    let _,
      p,
      d = null
    for (
      let e = 0;
      e < m.length && ((p = n[(_ = m[e])] || {}), (d = p[s]), !K(d));
      e++
    )
      Se(t, s, _, 0, 'datetime format')
    if (!K(d) || !G(_)) return r ? J : s
    let v = _ + '__' + s,
      g = (W(u) || (v = v + '__' + JSON.stringify(u)), o.get(v))
    return (
      g || ((g = new Intl.DateTimeFormat(_, H({}, d, u))), o.set(v, g)),
      e ? g.formatToParts(c) : g.format(c)
    )
  }
  const et = [
    'localeMatcher',
    'weekday',
    'era',
    'year',
    'month',
    'day',
    'hour',
    'minute',
    'second',
    'timeZoneName',
    'formatMatcher',
    'hour12',
    'timeZone',
    'dateStyle',
    'timeStyle',
    'calendar',
    'dayPeriod',
    'numberingSystem',
    'hourCycle',
    'fractionalSecondDigits'
  ]
  function tt(...e) {
    const [t, n, r, a] = e,
      l = $()
    let o,
      s = $()
    if (G(t)) {
      const e = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/)
      if (!e) throw Error(c.INVALID_ISO_DATE_ARGUMENT)
      const n = e[3]
        ? e[3].trim().startsWith('T')
          ? '' + e[1].trim() + e[3].trim()
          : e[1].trim() + 'T' + e[3].trim()
        : e[1].trim()
      o = new Date(n)
      try {
        o.toISOString()
      } catch (e) {
        throw Error(c.INVALID_ISO_DATE_ARGUMENT)
      }
    } else if (f(t)) {
      if (isNaN(t.getTime())) throw Error(c.INVALID_DATE_ARGUMENT)
      o = t
    } else {
      if (!w(t)) throw Error(c.INVALID_ARGUMENT)
      o = t
    }
    return (
      G(n)
        ? (l.key = n)
        : K(n) &&
          Object.keys(n).forEach((e) => {
            et.includes(e) ? (s[e] = n[e]) : (l[e] = n[e])
          }),
      G(r) ? (l.locale = r) : K(r) && (s = r),
      K(a) && (s = a),
      [l.key || '', o, l, s]
    )
  }
  function nt(e, t, n) {
    const r = e
    for (const a in n) {
      const e = t + '__' + a
      r.__datetimeFormatters.has(e) && r.__datetimeFormatters.delete(e)
    }
  }
  function rt(t, ...e) {
    const {
        numberFormats: n,
        unresolving: r,
        fallbackLocale: a,
        localeFallbacker: l
      } = t,
      o = t['__numberFormatters'],
      [s, c, i, u] = lt(...e)
    ;(Y(i.missingWarn) ? i : t).missingWarn,
      (Y(i.fallbackWarn) ? i : t).fallbackWarn
    var e = !!i.part,
      f = ve(t, i),
      m = l(t, a, f)
    if (!G(s) || '' === s) return new Intl.NumberFormat(f, u).format(c)
    let _,
      p,
      d = null
    for (
      let e = 0;
      e < m.length && ((p = n[(_ = m[e])] || {}), (d = p[s]), !K(d));
      e++
    )
      Se(t, s, _, 0, 'number format')
    if (!K(d) || !G(_)) return r ? J : s
    let v = _ + '__' + s,
      g = (W(u) || (v = v + '__' + JSON.stringify(u)), o.get(v))
    return (
      g || ((g = new Intl.NumberFormat(_, H({}, d, u))), o.set(v, g)),
      e ? g.formatToParts(c) : g.format(c)
    )
  }
  const at = [
    'localeMatcher',
    'style',
    'currency',
    'currencyDisplay',
    'currencySign',
    'useGrouping',
    'minimumIntegerDigits',
    'minimumFractionDigits',
    'maximumFractionDigits',
    'minimumSignificantDigits',
    'maximumSignificantDigits',
    'compactDisplay',
    'notation',
    'signDisplay',
    'unit',
    'unitDisplay',
    'roundingMode',
    'roundingPriority',
    'roundingIncrement',
    'trailingZeroDisplay'
  ]
  function lt(...e) {
    const [t, n, r, a] = e,
      l = $()
    let o = $()
    if (!w(t)) throw Error(c.INVALID_ARGUMENT)
    e = t
    return (
      G(n)
        ? (l.key = n)
        : K(n) &&
          Object.keys(n).forEach((e) => {
            at.includes(e) ? (o[e] = n[e]) : (l[e] = n[e])
          }),
      G(r) ? (l.locale = r) : K(r) && (o = r),
      K(a) && (o = a),
      [l.key || '', e, l, o]
    )
  }
  function ot(e, t, n) {
    const r = e
    for (const a in n) {
      const e = t + '__' + a
      r.__numberFormatters.has(e) && r.__numberFormatters.delete(e)
    }
  }
  const st = '9.14.2',
    ct = c.__EXTEND_POINT__,
    n = E(ct),
    te = {
      UNEXPECTED_RETURN_TYPE: ct,
      INVALID_ARGUMENT: n(),
      MUST_BE_CALL_SETUP_TOP: n(),
      NOT_INSTALLED: n(),
      NOT_AVAILABLE_IN_LEGACY_MODE: n(),
      REQUIRED_VALUE: n(),
      INVALID_VALUE: n(),
      CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: n(),
      NOT_INSTALLED_WITH_PROVIDE: n(),
      UNEXPECTED_ERROR: n(),
      NOT_COMPATIBLE_LEGACY_VUE_I18N: n(),
      BRIDGE_SUPPORT_VUE_2_ONLY: n(),
      MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: n(),
      NOT_AVAILABLE_COMPOSITION_IN_LEGACY: n(),
      __EXTEND_POINT__: n()
    },
    it = a('__translateVNode'),
    ut = a('__datetimeParts'),
    ft = a('__numberParts'),
    mt = a('__setPluralRules'),
    _t = a('__injectWithOption'),
    pt = a('__dispose')
  function ne(e) {
    if (B(e))
      for (const l in e)
        if (V(e, l))
          if (l.includes('.')) {
            var r = l.split('.'),
              a = r.length - 1
            let t = e,
              n = !1
            for (let e = 0; e < a; e++) {
              if ((r[e] in t || (t[r[e]] = $()), !B(t[r[e]]))) {
                n = !0
                break
              }
              t = t[r[e]]
            }
            n || ((t[r[a]] = e[l]), delete e[l]), B(t[r[a]]) && ne(t[r[a]])
          } else B(e[l]) && ne(e[l])
  }
  function dt(e, t) {
    const { messages: n, __i18n: r, messageResolver: a, flatJson: l } = t,
      o = K(n) ? n : j(r) ? $() : { [e]: $() }
    if (
      (j(r) &&
        r.forEach((e) => {
          var t, n
          'locale' in e && 'resource' in e
            ? (({ locale: t, resource: n } = e),
              t ? ((o[t] = o[t] || $()), z(n, o[t])) : z(n, o))
            : G(e) && z(JSON.parse(e), o)
        }),
      null == a && l)
    )
      for (const s in o) V(o, s) && ne(o[s])
    return o
  }
  function vt(t, n, e) {
    let r = B(n.messages) ? n.messages : $()
    '__i18nGlobal' in e &&
      (r = dt(t.locale.value, { messages: r, __i18n: e.__i18nGlobal }))
    const a = Object.keys(r)
    if (
      (a.length &&
        a.forEach((e) => {
          t.mergeLocaleMessage(e, r[e])
        }),
      B(n.datetimeFormats))
    ) {
      const e = Object.keys(n.datetimeFormats)
      e.length &&
        e.forEach((e) => {
          t.mergeDateTimeFormat(e, n.datetimeFormats[e])
        })
    }
    if (B(n.numberFormats)) {
      const e = Object.keys(n.numberFormats)
      e.length &&
        e.forEach((e) => {
          t.mergeNumberFormat(e, n.numberFormats[e])
        })
    }
  }
  function gt(e) {
    return x.createVNode(x.Text, null, e, 0)
  }
  const Et = () => [],
    bt = () => !1
  let kt = 0
  function ht(a) {
    return (e, t, n, r) => a(t, n, x.getCurrentInstance() || void 0, r)
  }
  function Lt(n = {}) {
    const { __root: s, __injectWithOption: e } = n,
      c = void 0 === s,
      a = n.flatJson,
      t = M ? x.ref : x.shallowRef,
      r = !!n.translateExistCompatible
    let l = !Y(n.inheritLocale) || n.inheritLocale
    const i = t(s && l ? s.locale.value : G(n.locale) ? n.locale : Q),
      u = t(
        s && l
          ? s.fallbackLocale.value
          : G(n.fallbackLocale) ||
              j(n.fallbackLocale) ||
              K(n.fallbackLocale) ||
              !1 === n.fallbackLocale
            ? n.fallbackLocale
            : i.value
      ),
      f = t(dt(i.value, n)),
      m = t(K(n.datetimeFormats) ? n.datetimeFormats : { [i.value]: {} }),
      _ = t(K(n.numberFormats) ? n.numberFormats : { [i.value]: {} })
    let o = s
        ? s.missingWarn
        : (!Y(n.missingWarn) && !U(n.missingWarn)) || n.missingWarn,
      p = s
        ? s.fallbackWarn
        : (!Y(n.fallbackWarn) && !U(n.fallbackWarn)) || n.fallbackWarn,
      d = s ? s.fallbackRoot : !Y(n.fallbackRoot) || n.fallbackRoot,
      v = !!n.fallbackFormat,
      g = X(n.missing) ? n.missing : null,
      E = X(n.missing) ? ht(n.missing) : null,
      b = X(n.postTranslation) ? n.postTranslation : null,
      k = s ? s.warnHtmlMessage : !Y(n.warnHtmlMessage) || n.warnHtmlMessage,
      h = !!n.escapeParameter
    const L = s ? s.modifiers : K(n.modifiers) ? n.modifiers : {}
    let N,
      T = n.pluralRules || (s && s.pluralRules)
    q(
      (N = (() => {
        c && Pe(null)
        const e = {
          version: st,
          locale: i.value,
          fallbackLocale: u.value,
          messages: f.value,
          modifiers: L,
          pluralRules: T,
          missing: null === E ? void 0 : E,
          missingWarn: o,
          fallbackWarn: p,
          fallbackFormat: v,
          unresolving: !0,
          postTranslation: null === b ? void 0 : b,
          warnHtmlMessage: k,
          escapeParameter: h,
          messageResolver: n.messageResolver,
          messageCompiler: n.messageCompiler,
          __meta: { framework: 'vue' }
        }
        ;(e.datetimeFormats = m.value),
          (e.numberFormats = _.value),
          (e.__datetimeFormatters = K(N) ? N.__datetimeFormatters : void 0),
          (e.__numberFormatters = K(N) ? N.__numberFormatters : void 0)
        var t = (function (e = {}) {
          var t = X(e.onWarn) ? e.onWarn : re,
            n = G(e.version) ? e.version : Le,
            r = G(e.locale) || X(e.locale) ? e.locale : Q,
            a = X(r) ? Q : r,
            l =
              j(e.fallbackLocale) ||
              K(e.fallbackLocale) ||
              G(e.fallbackLocale) ||
              !1 === e.fallbackLocale
                ? e.fallbackLocale
                : a,
            o = K(e.messages) ? e.messages : Fe(a),
            s = K(e.datetimeFormats) ? e.datetimeFormats : Fe(a),
            a = K(e.numberFormats) ? e.numberFormats : Fe(a),
            c = H($(), e.modifiers, {
              upper: (e, t) =>
                'text' === t && G(e)
                  ? e.toUpperCase()
                  : 'vnode' === t && B(e) && '__v_isVNode' in e
                    ? e.children.toUpperCase()
                    : e,
              lower: (e, t) =>
                'text' === t && G(e)
                  ? e.toLowerCase()
                  : 'vnode' === t && B(e) && '__v_isVNode' in e
                    ? e.children.toLowerCase()
                    : e,
              capitalize: (e, t) =>
                'text' === t && G(e)
                  ? Te(e)
                  : 'vnode' === t && B(e) && '__v_isVNode' in e
                    ? Te(e.children)
                    : e
            }),
            i = e.pluralRules || $(),
            u = X(e.missing) ? e.missing : null,
            f = (!Y(e.missingWarn) && !U(e.missingWarn)) || e.missingWarn,
            m = (!Y(e.fallbackWarn) && !U(e.fallbackWarn)) || e.fallbackWarn,
            _ = !!e.fallbackFormat,
            p = !!e.unresolving,
            d = X(e.postTranslation) ? e.postTranslation : null,
            v = K(e.processor) ? e.processor : null,
            g = !Y(e.warnHtmlMessage) || e.warnHtmlMessage,
            E = !!e.escapeParameter,
            b = X(e.messageCompiler) ? e.messageCompiler : ye,
            k = X(e.messageResolver) ? e.messageResolver : Ie,
            h = X(e.localeFallbacker) ? e.localeFallbacker : Ce || be,
            L = B(e.fallbackContext) ? e.fallbackContext : void 0,
            N = B(e.__datetimeFormatters) ? e.__datetimeFormatters : new Map(),
            T = B(e.__numberFormatters) ? e.__numberFormatters : new Map(),
            e = B(e.__meta) ? e.__meta : {}
          const y = {
            version: n,
            cid: ++Re,
            locale: r,
            fallbackLocale: l,
            messages: o,
            modifiers: c,
            pluralRules: i,
            missing: u,
            missingWarn: f,
            fallbackWarn: m,
            fallbackFormat: _,
            unresolving: p,
            postTranslation: d,
            processor: v,
            warnHtmlMessage: g,
            escapeParameter: E,
            messageCompiler: b,
            messageResolver: k,
            localeFallbacker: h,
            fallbackContext: L,
            onWarn: t,
            __meta: e
          }
          return (
            (y.datetimeFormats = s),
            (y.numberFormats = a),
            (y.__datetimeFormatters = N),
            (y.__numberFormatters = T),
            y
          )
        })(e)
        return c && Pe(t), t
      })()),
      i.value,
      u.value
    )
    var y = x.computed({
        get: () => i.value,
        set: (e) => {
          ;(i.value = e), (N.locale = i.value)
        }
      }),
      I = x.computed({
        get: () => u.value,
        set: (e) => {
          ;(u.value = e), (N.fallbackLocale = u.value), q(N, i.value, e)
        }
      }),
      C = x.computed(() => f.value),
      O = x.computed(() => m.value),
      P = x.computed(() => _.value)
    const A = (e, t, n, r, a, l) => {
      let o
      i.value, u.value, f.value, m.value, _.value
      try {
        c || (N.fallbackContext = s ? Ae() : void 0), (o = e(N))
      } finally {
        c || (N.fallbackContext = void 0)
      }
      if (
        ('translate exists' !== n && w(o) && o === J) ||
        ('translate exists' === n && !o)
      ) {
        const [e, n] = t()
        return s && d ? r(s) : a(e)
      }
      if (l(o)) return o
      throw Error(te.UNEXPECTED_RETURN_TYPE)
    }
    function R(...t) {
      return A(
        (e) => Reflect.apply(ze, null, [e, ...t]),
        () => qe(...t),
        'translate',
        (e) => Reflect.apply(e.t, e, [...t]),
        (e) => e,
        (e) => G(e)
      )
    }
    const F = {
      normalize: function (e) {
        return e.map((e) => (G(e) || w(e) || Y(e) ? gt(String(e)) : e))
      },
      interpolate: (e) => e,
      type: 'vnode'
    }
    function S(e) {
      return f.value[e] || {}
    }
    kt++,
      s &&
        M &&
        (x.watch(s.locale, (e) => {
          l && ((i.value = e), (N.locale = e), q(N, i.value, u.value))
        }),
        x.watch(s.fallbackLocale, (e) => {
          l && ((u.value = e), (N.fallbackLocale = e), q(N, i.value, u.value))
        }))
    const D = {
      id: kt,
      locale: y,
      fallbackLocale: I,
      get inheritLocale() {
        return l
      },
      set inheritLocale(e) {
        ;(l = e) &&
          s &&
          ((i.value = s.locale.value),
          (u.value = s.fallbackLocale.value),
          q(N, i.value, u.value))
      },
      get availableLocales() {
        return Object.keys(f.value).sort()
      },
      messages: C,
      get modifiers() {
        return L
      },
      get pluralRules() {
        return T || {}
      },
      get isGlobal() {
        return c
      },
      get missingWarn() {
        return o
      },
      set missingWarn(e) {
        ;(o = e), (N.missingWarn = o)
      },
      get fallbackWarn() {
        return p
      },
      set fallbackWarn(e) {
        ;(p = e), (N.fallbackWarn = p)
      },
      get fallbackRoot() {
        return d
      },
      set fallbackRoot(e) {
        d = e
      },
      get fallbackFormat() {
        return v
      },
      set fallbackFormat(e) {
        ;(v = e), (N.fallbackFormat = v)
      },
      get warnHtmlMessage() {
        return k
      },
      set warnHtmlMessage(e) {
        ;(k = e), (N.warnHtmlMessage = e)
      },
      get escapeParameter() {
        return h
      },
      set escapeParameter(e) {
        ;(h = e), (N.escapeParameter = e)
      },
      t: R,
      getLocaleMessage: S,
      setLocaleMessage: function (e, t) {
        if (a) {
          var n = { [e]: t }
          for (const e in n) V(n, e) && ne(n[e])
          t = n[e]
        }
        ;(f.value[e] = t), (N.messages = f.value)
      },
      mergeLocaleMessage: function (e, t) {
        f.value[e] = f.value[e] || {}
        var n = { [e]: t }
        if (a) for (const r in n) V(n, r) && ne(n[r])
        z((t = n[e]), f.value[e]), (N.messages = f.value)
      },
      getPostTranslationHandler: function () {
        return X(b) ? b : null
      },
      setPostTranslationHandler: function (e) {
        ;(b = e), (N.postTranslation = e)
      },
      getMissingHandler: function () {
        return g
      },
      setMissingHandler: function (e) {
        null !== e && (E = ht(e)), (g = e), (N.missing = E)
      },
      [mt]: function (e) {
        ;(T = e), (N.pluralRules = T)
      }
    }
    return (
      (D.datetimeFormats = O),
      (D.numberFormats = P),
      (D.rt = function (...e) {
        var [e, t, n] = e
        if (n && !B(n)) throw Error(te.INVALID_ARGUMENT)
        return R(e, t, H({ resolvedMessage: !0 }, n || {}))
      }),
      (D.te = function (t, n) {
        return A(
          () => {
            if (!t) return !1
            var e = S(G(n) ? n : i.value),
              e = N.messageResolver(e, t)
            return r ? null != e : Z(e) || ee(e) || G(e)
          },
          () => [t],
          'translate exists',
          (e) => Reflect.apply(e.te, e, [t, n]),
          bt,
          (e) => Y(e)
        )
      }),
      (D.tm = function (e) {
        var t = (function (t) {
          let n = null
          var r = ke(N, u.value, i.value)
          for (let e = 0; e < r.length; e++) {
            var a = f.value[r[e]] || {},
              a = N.messageResolver(a, t)
            if (null != a) {
              n = a
              break
            }
          }
          return n
        })(e)
        return null != t ? t : (s && s.tm(e)) || {}
      }),
      (D.d = function (...t) {
        return A(
          (e) => Reflect.apply(Ze, null, [e, ...t]),
          () => tt(...t),
          'datetime format',
          (e) => Reflect.apply(e.d, e, [...t]),
          () => Ne,
          (e) => G(e)
        )
      }),
      (D.n = function (...t) {
        return A(
          (e) => Reflect.apply(rt, null, [e, ...t]),
          () => lt(...t),
          'number format',
          (e) => Reflect.apply(e.n, e, [...t]),
          () => Ne,
          (e) => G(e)
        )
      }),
      (D.getDateTimeFormat = function (e) {
        return m.value[e] || {}
      }),
      (D.setDateTimeFormat = function (e, t) {
        ;(m.value[e] = t), (N.datetimeFormats = m.value), nt(N, e, t)
      }),
      (D.mergeDateTimeFormat = function (e, t) {
        ;(m.value[e] = H(m.value[e] || {}, t)),
          (N.datetimeFormats = m.value),
          nt(N, e, t)
      }),
      (D.getNumberFormat = function (e) {
        return _.value[e] || {}
      }),
      (D.setNumberFormat = function (e, t) {
        ;(_.value[e] = t), (N.numberFormats = _.value), ot(N, e, t)
      }),
      (D.mergeNumberFormat = function (e, t) {
        ;(_.value[e] = H(_.value[e] || {}, t)),
          (N.numberFormats = _.value),
          ot(N, e, t)
      }),
      (D[_t] = e),
      (D[it] = function (...r) {
        return A(
          (e) => {
            let t
            const n = e
            try {
              ;(n.processor = F), (t = Reflect.apply(ze, null, [n, ...r]))
            } finally {
              n.processor = null
            }
            return t
          },
          () => qe(...r),
          'translate',
          (e) => e[it](...r),
          (e) => [gt(e)],
          (e) => j(e)
        )
      }),
      (D[ut] = function (...t) {
        return A(
          (e) => Reflect.apply(Ze, null, [e, ...t]),
          () => tt(...t),
          'datetime format',
          (e) => e[ut](...t),
          Et,
          (e) => G(e) || j(e)
        )
      }),
      (D[ft] = function (...t) {
        return A(
          (e) => Reflect.apply(rt, null, [e, ...t]),
          () => lt(...t),
          'number format',
          (e) => e[ft](...t),
          Et,
          (e) => G(e) || j(e)
        )
      }),
      D
    )
  }
  function Nt(e = {}, s) {
    {
      const s = Lt(
          (function (e) {
            const r = G(e.locale) ? e.locale : Q,
              t =
                G(e.fallbackLocale) ||
                j(e.fallbackLocale) ||
                K(e.fallbackLocale) ||
                !1 === e.fallbackLocale
                  ? e.fallbackLocale
                  : r,
              n = X(e.missing) ? e.missing : void 0,
              a =
                (!Y(e.silentTranslationWarn) && !U(e.silentTranslationWarn)) ||
                !e.silentTranslationWarn,
              l =
                (!Y(e.silentFallbackWarn) && !U(e.silentFallbackWarn)) ||
                !e.silentFallbackWarn,
              o = !Y(e.fallbackRoot) || e.fallbackRoot,
              s = !!e.formatFallbackMessages,
              c = K(e.modifiers) ? e.modifiers : {},
              i = e.pluralizationRules,
              u = X(e.postTranslation) ? e.postTranslation : void 0,
              f = !G(e.warnHtmlInMessage) || 'off' !== e.warnHtmlInMessage,
              m = !!e.escapeParameterHtml,
              _ = !Y(e.sync) || e.sync
            let p = e.messages
            if (K(e.sharedMessages)) {
              const r = e.sharedMessages
              p = Object.keys(r).reduce((e, t) => {
                var n = e[t] || (e[t] = {})
                return H(n, r[t]), e
              }, p || {})
            }
            var { __i18n: d, __root: v, __injectWithOption: g } = e,
              E = e.datetimeFormats,
              b = e.numberFormats,
              k = e.flatJson,
              h = e.translateExistCompatible
            return {
              locale: r,
              fallbackLocale: t,
              messages: p,
              flatJson: k,
              datetimeFormats: E,
              numberFormats: b,
              missing: n,
              missingWarn: a,
              fallbackWarn: l,
              fallbackRoot: o,
              fallbackFormat: s,
              modifiers: c,
              pluralRules: i,
              postTranslation: u,
              warnHtmlMessage: f,
              escapeParameter: m,
              messageResolver: e.messageResolver,
              inheritLocale: _,
              translateExistCompatible: h,
              __i18n: d,
              __root: v,
              __injectWithOption: g
            }
          })(e)
        ),
        t = e['__extender'],
        n = {
          id: s.id,
          get locale() {
            return s.locale.value
          },
          set locale(e) {
            s.locale.value = e
          },
          get fallbackLocale() {
            return s.fallbackLocale.value
          },
          set fallbackLocale(e) {
            s.fallbackLocale.value = e
          },
          get messages() {
            return s.messages.value
          },
          get datetimeFormats() {
            return s.datetimeFormats.value
          },
          get numberFormats() {
            return s.numberFormats.value
          },
          get availableLocales() {
            return s.availableLocales
          },
          get formatter() {
            return { interpolate: () => [] }
          },
          set formatter(e) {},
          get missing() {
            return s.getMissingHandler()
          },
          set missing(e) {
            s.setMissingHandler(e)
          },
          get silentTranslationWarn() {
            return Y(s.missingWarn) ? !s.missingWarn : s.missingWarn
          },
          set silentTranslationWarn(e) {
            s.missingWarn = Y(e) ? !e : e
          },
          get silentFallbackWarn() {
            return Y(s.fallbackWarn) ? !s.fallbackWarn : s.fallbackWarn
          },
          set silentFallbackWarn(e) {
            s.fallbackWarn = Y(e) ? !e : e
          },
          get modifiers() {
            return s.modifiers
          },
          get formatFallbackMessages() {
            return s.fallbackFormat
          },
          set formatFallbackMessages(e) {
            s.fallbackFormat = e
          },
          get postTranslation() {
            return s.getPostTranslationHandler()
          },
          set postTranslation(e) {
            s.setPostTranslationHandler(e)
          },
          get sync() {
            return s.inheritLocale
          },
          set sync(e) {
            s.inheritLocale = e
          },
          get warnHtmlInMessage() {
            return s.warnHtmlMessage ? 'warn' : 'off'
          },
          set warnHtmlInMessage(e) {
            s.warnHtmlMessage = 'off' !== e
          },
          get escapeParameterHtml() {
            return s.escapeParameter
          },
          set escapeParameterHtml(e) {
            s.escapeParameter = e
          },
          get preserveDirectiveContent() {
            return !0
          },
          set preserveDirectiveContent(e) {},
          get pluralizationRules() {
            return s.pluralRules || {}
          },
          __composer: s,
          t(...e) {
            const [t, n, r] = e,
              a = {}
            let l = null,
              o = null
            if (!G(t)) throw Error(te.INVALID_ARGUMENT)
            e = t
            return (
              G(n) ? (a.locale = n) : j(n) ? (l = n) : K(n) && (o = n),
              j(r) ? (l = r) : K(r) && (o = r),
              Reflect.apply(s.t, s, [e, l || o || {}, a])
            )
          },
          rt: (...e) => Reflect.apply(s.rt, s, [...e]),
          tc(...e) {
            const [t, n, r] = e,
              a = { plural: 1 }
            let l = null,
              o = null
            if (!G(t)) throw Error(te.INVALID_ARGUMENT)
            e = t
            return (
              G(n)
                ? (a.locale = n)
                : w(n)
                  ? (a.plural = n)
                  : j(n)
                    ? (l = n)
                    : K(n) && (o = n),
              G(r) ? (a.locale = r) : j(r) ? (l = r) : K(r) && (o = r),
              Reflect.apply(s.t, s, [e, l || o || {}, a])
            )
          },
          te: (e, t) => s.te(e, t),
          tm: (e) => s.tm(e),
          getLocaleMessage: (e) => s.getLocaleMessage(e),
          setLocaleMessage(e, t) {
            s.setLocaleMessage(e, t)
          },
          mergeLocaleMessage(e, t) {
            s.mergeLocaleMessage(e, t)
          },
          d: (...e) => Reflect.apply(s.d, s, [...e]),
          getDateTimeFormat: (e) => s.getDateTimeFormat(e),
          setDateTimeFormat(e, t) {
            s.setDateTimeFormat(e, t)
          },
          mergeDateTimeFormat(e, t) {
            s.mergeDateTimeFormat(e, t)
          },
          n: (...e) => Reflect.apply(s.n, s, [...e]),
          getNumberFormat: (e) => s.getNumberFormat(e),
          setNumberFormat(e, t) {
            s.setNumberFormat(e, t)
          },
          mergeNumberFormat(e, t) {
            s.mergeNumberFormat(e, t)
          },
          getChoiceIndex: (e, t) => -1
        }
      return (n.__extender = t), n
    }
  }
  var Tt = {
    tag: { type: [String, Object] },
    locale: { type: String },
    scope: {
      type: String,
      validator: (e) => 'parent' === e || 'global' === e,
      default: 'parent'
    },
    i18n: { type: Object }
  }
  function yt() {
    return x.Fragment
  }
  const It = x.defineComponent({
      name: 'i18n-t',
      props: H(
        {
          keypath: { type: String, required: !0 },
          plural: {
            type: [Number, String],
            validator: (e) => w(e) || !isNaN(e)
          }
        },
        Tt
      ),
      setup(o, s) {
        const { slots: c, attrs: i } = s,
          u = o.i18n || Ut({ useScope: o.scope, __useComponent: !0 })
        return () => {
          const e = Object.keys(c).filter((e) => '_' !== e),
            t = $()
          o.locale && (t.locale = o.locale),
            void 0 !== o.plural &&
              (t.plural = G(o.plural) ? +o.plural : o.plural)
          ;[r, n] = [s['slots'], e]
          var r,
            n =
              1 === n.length && 'default' === n[0]
                ? (r.default ? r.default() : []).reduce(
                    (e, t) => [
                      ...e,
                      ...(t.type === x.Fragment ? t.children : [t])
                    ],
                    []
                  )
                : n.reduce((e, t) => {
                    const n = r[t]
                    return n && (e[t] = n()), e
                  }, $()),
            n = u[it](o.keypath, n, t),
            a = H($(), i),
            l = G(o.tag) || B(o.tag) ? o.tag : yt()
          return x.h(l, a, n)
        }
      }
    }),
    Ct = It
  function Ot(o, e, s, c) {
    const { slots: i, attrs: u } = e
    return () => {
      const e = { part: !0 }
      let t = $()
      o.locale && (e.locale = o.locale),
        G(o.format)
          ? (e.key = o.format)
          : B(o.format) &&
            (G(o.format.key) && (e.key = o.format.key),
            (t = Object.keys(o.format).reduce(
              (e, t) => (s.includes(t) ? H($(), e, { [t]: o.format[t] }) : e),
              $()
            )))
      const l = c(o.value, e, t)
      let n = [e.key]
      j(l)
        ? (n = l.map((e, t) => {
            const n = i[e.type],
              r = n ? n({ [e.type]: e.value, index: t, parts: l }) : [e.value]
            var a
            return j((a = r)) && !G(a[0]) && (r[0].key = e.type + '-' + t), r
          }))
        : G(l) && (n = [l])
      var r = H($(), u),
        a = G(o.tag) || B(o.tag) ? o.tag : yt()
      return x.h(a, r, n)
    }
  }
  const Pt = x.defineComponent({
      name: 'i18n-n',
      props: H(
        {
          value: { type: Number, required: !0 },
          format: { type: [String, Object] }
        },
        Tt
      ),
      setup(e, t) {
        const n = e.i18n || Ut({ useScope: e.scope, __useComponent: !0 })
        return Ot(e, t, at, (...e) => n[ft](...e))
      }
    }),
    At = Pt,
    Rt = x.defineComponent({
      name: 'i18n-d',
      props: H(
        {
          value: { type: [Number, Date], required: !0 },
          format: { type: [String, Object] }
        },
        Tt
      ),
      setup(e, t) {
        const n = e.i18n || Ut({ useScope: e.scope, __useComponent: !0 })
        return Ot(e, t, et, (...e) => n[ut](...e))
      }
    }),
    Ft = Rt
  function St(a) {
    const l = (e) => {
      var { instance: e, value: t } = e
      if (!e || !e.$) throw Error(te.UNEXPECTED_ERROR)
      ;(e = (function (e, t) {
        const n = e
        if ('composition' === e.mode) return n.__getInstance(t) || e.global
        t = n.__getInstance(t)
        return (null != t ? t : e.global).__composer
      })(a, e.$)),
        (t = Dt(t))
      return [Reflect.apply(e.t, e, [...Mt(t)]), e]
    }
    return {
      created: (e, t) => {
        var [n, r] = l(t)
        M &&
          a.global === r &&
          (e.__i18nWatcher = x.watch(r.locale, () => {
            t.instance && t.instance.$forceUpdate()
          })),
          (e.__composer = r),
          (e.textContent = n)
      },
      unmounted: (e) => {
        M &&
          e.__i18nWatcher &&
          (e.__i18nWatcher(),
          (e.__i18nWatcher = void 0),
          delete e.__i18nWatcher),
          e.__composer && ((e.__composer = void 0), delete e.__composer)
      },
      beforeUpdate: (e, { value: t }) => {
        var n
        e.__composer &&
          ((n = e.__composer),
          (t = Dt(t)),
          (e.textContent = Reflect.apply(n.t, n, [...Mt(t)])))
      },
      getSSRProps: (e) => {
        var [e] = l(e)
        return { textContent: e }
      }
    }
  }
  function Dt(e) {
    if (G(e)) return { path: e }
    if (K(e)) {
      if ('path' in e) return e
      throw Error(te.REQUIRED_VALUE, 'path')
    }
    throw Error(te.INVALID_VALUE)
  }
  function Mt(e) {
    const { path: t, locale: n, args: r, choice: a, plural: l } = e,
      o = {},
      s = r || {}
    return (
      G(n) && (o.locale = n),
      w(a) && (o.plural = a),
      w(l) && (o.plural = l),
      [t, s, o]
    )
  }
  function wt(t, n) {
    ;(t.locale = n.locale || t.locale),
      (t.fallbackLocale = n.fallbackLocale || t.fallbackLocale),
      (t.missing = n.missing || t.missing),
      (t.silentTranslationWarn =
        n.silentTranslationWarn || t.silentFallbackWarn),
      (t.silentFallbackWarn = n.silentFallbackWarn || t.silentFallbackWarn),
      (t.formatFallbackMessages =
        n.formatFallbackMessages || t.formatFallbackMessages),
      (t.postTranslation = n.postTranslation || t.postTranslation),
      (t.warnHtmlInMessage = n.warnHtmlInMessage || t.warnHtmlInMessage),
      (t.escapeParameterHtml = n.escapeParameterHtml || t.escapeParameterHtml),
      (t.sync = n.sync || t.sync),
      t.__composer[mt](n.pluralizationRules || t.pluralizationRules)
    const r = dt(t.locale, { messages: n.messages, __i18n: n.__i18n })
    return (
      Object.keys(r).forEach((e) => t.mergeLocaleMessage(e, r[e])),
      n.datetimeFormats &&
        Object.keys(n.datetimeFormats).forEach((e) =>
          t.mergeDateTimeFormat(e, n.datetimeFormats[e])
        ),
      n.numberFormats &&
        Object.keys(n.numberFormats).forEach((e) =>
          t.mergeNumberFormat(e, n.numberFormats[e])
        ),
      t
    )
  }
  const xt = a('global-vue-i18n')
  function Ut(t = {}) {
    var n,
      r,
      a,
      l = x.getCurrentInstance()
    if (null == l) throw Error(te.MUST_BE_CALL_SETUP_TOP)
    if (
      !l.isCE &&
      null != l.appContext.app &&
      !l.appContext.app.__VUE_I18N_SYMBOL__
    )
      throw Error(te.NOT_INSTALLED)
    const o = (function (e) {
        var t = x.inject(e.isCE ? xt : e.appContext.app.__VUE_I18N_SYMBOL__)
        if (t) return t
        throw (function (e) {
          {
            var [e, t, n = {}] = [e, null, void 0]
            const r = n['domain'],
              a = new SyntaxError(String(e))
            return (a.code = e), t && (a.location = t), (a.domain = r), a
          }
        })(e.isCE ? te.NOT_INSTALLED_WITH_PROVIDE : te.UNEXPECTED_ERROR)
      })(l),
      s = 'composition' === (m = o).mode ? m.global : m.global.__composer,
      e = l.type,
      c =
        ((m = t),
        (f = e),
        W(m) ? ('__i18n' in f ? 'local' : 'global') : m.useScope || 'local')
    if ('legacy' === o.mode && !t.__useComponent) {
      if (o.allowComposition) {
        var [i, u, f, m = {}] = [l, c, s, t]
        const E = 'local' === u,
          b = x.shallowRef(null)
        if (E && i.proxy && !i.proxy.$options.i18n && !i.proxy.$options.__i18n)
          throw Error(te.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION)
        const k = Y(m.inheritLocale) ? m.inheritLocale : !G(m.locale),
          h = x.ref(!E || k ? f.locale.value : G(m.locale) ? m.locale : Q),
          L = x.ref(
            !E || k
              ? f.fallbackLocale.value
              : G(m.fallbackLocale) ||
                  j(m.fallbackLocale) ||
                  K(m.fallbackLocale) ||
                  !1 === m.fallbackLocale
                ? m.fallbackLocale
                : h.value
          ),
          N = x.ref(dt(h.value, m)),
          T = x.ref(
            K(m.datetimeFormats) ? m.datetimeFormats : { [h.value]: {} }
          ),
          y = x.ref(K(m.numberFormats) ? m.numberFormats : { [h.value]: {} }),
          I = E
            ? f.missingWarn
            : (!Y(m.missingWarn) && !U(m.missingWarn)) || m.missingWarn,
          C = E
            ? f.fallbackWarn
            : (!Y(m.fallbackWarn) && !U(m.fallbackWarn)) || m.fallbackWarn,
          O = E ? f.fallbackRoot : !Y(m.fallbackRoot) || m.fallbackRoot,
          P = !!m.fallbackFormat,
          A = X(m.missing) ? m.missing : null,
          R = X(m.postTranslation) ? m.postTranslation : null,
          F = E
            ? f.warnHtmlMessage
            : !Y(m.warnHtmlMessage) || m.warnHtmlMessage,
          S = !!m.escapeParameter,
          D = E ? f.modifiers : K(m.modifiers) ? m.modifiers : {},
          M = m.pluralRules || (E && f.pluralRules)
        var m = x.computed({
            get: () => (b.value ? b.value.locale : h).value,
            set: (e) => {
              b.value && (b.value.locale.value = e), (h.value = e)
            }
          }),
          f = x.computed({
            get: () => (b.value ? b.value.fallbackLocale : L).value,
            set: (e) => {
              b.value && (b.value.fallbackLocale.value = e), (L.value = e)
            }
          }),
          _ = x.computed(() => (b.value ? b.value.messages : N).value),
          p = x.computed(() => T.value),
          w = x.computed(() => y.value)
        function d(e) {
          return h.value, L.value, N.value, T.value, y.value, e()
        }
        m = {
          get id() {
            return b.value ? b.value.id : -1
          },
          locale: m,
          fallbackLocale: f,
          messages: _,
          datetimeFormats: p,
          numberFormats: w,
          get inheritLocale() {
            return b.value ? b.value.inheritLocale : k
          },
          set inheritLocale(e) {
            b.value && (b.value.inheritLocale = e)
          },
          get availableLocales() {
            return b.value ? b.value.availableLocales : Object.keys(N.value)
          },
          get modifiers() {
            return b.value ? b.value.modifiers : D
          },
          get pluralRules() {
            return b.value ? b.value.pluralRules : M
          },
          get isGlobal() {
            return !!b.value && b.value.isGlobal
          },
          get missingWarn() {
            return b.value ? b.value.missingWarn : I
          },
          set missingWarn(e) {
            b.value && (b.value.missingWarn = e)
          },
          get fallbackWarn() {
            return b.value ? b.value.fallbackWarn : C
          },
          set fallbackWarn(e) {
            b.value && (b.value.missingWarn = e)
          },
          get fallbackRoot() {
            return b.value ? b.value.fallbackRoot : O
          },
          set fallbackRoot(e) {
            b.value && (b.value.fallbackRoot = e)
          },
          get fallbackFormat() {
            return b.value ? b.value.fallbackFormat : P
          },
          set fallbackFormat(e) {
            b.value && (b.value.fallbackFormat = e)
          },
          get warnHtmlMessage() {
            return b.value ? b.value.warnHtmlMessage : F
          },
          set warnHtmlMessage(e) {
            b.value && (b.value.warnHtmlMessage = e)
          },
          get escapeParameter() {
            return b.value ? b.value.escapeParameter : S
          },
          set escapeParameter(e) {
            b.value && (b.value.escapeParameter = e)
          },
          t: function (...e) {
            return b.value
              ? d(() => Reflect.apply(b.value.t, null, [...e]))
              : d(() => '')
          },
          getPostTranslationHandler: function () {
            return b.value ? b.value.getPostTranslationHandler() : R
          },
          setPostTranslationHandler: function (e) {
            b.value && b.value.setPostTranslationHandler(e)
          },
          getMissingHandler: function () {
            return b.value ? b.value.getMissingHandler() : A
          },
          setMissingHandler: function (e) {
            b.value && b.value.setMissingHandler(e)
          },
          rt: function (...e) {
            return b.value ? Reflect.apply(b.value.rt, null, [...e]) : ''
          },
          d: function (...e) {
            return b.value
              ? d(() => Reflect.apply(b.value.d, null, [...e]))
              : d(() => '')
          },
          n: function (...e) {
            return b.value
              ? d(() => Reflect.apply(b.value.n, null, [...e]))
              : d(() => '')
          },
          tm: function (e) {
            return b.value ? b.value.tm(e) : {}
          },
          te: function (e, t) {
            return !!b.value && b.value.te(e, t)
          },
          getLocaleMessage: function (e) {
            return b.value ? b.value.getLocaleMessage(e) : {}
          },
          setLocaleMessage: function (e, t) {
            b.value && (b.value.setLocaleMessage(e, t), (N.value[e] = t))
          },
          mergeLocaleMessage: function (e, t) {
            b.value && b.value.mergeLocaleMessage(e, t)
          },
          getDateTimeFormat: function (e) {
            return b.value ? b.value.getDateTimeFormat(e) : {}
          },
          setDateTimeFormat: function (e, t) {
            b.value && (b.value.setDateTimeFormat(e, t), (T.value[e] = t))
          },
          mergeDateTimeFormat: function (e, t) {
            b.value && b.value.mergeDateTimeFormat(e, t)
          },
          getNumberFormat: function (e) {
            return b.value ? b.value.getNumberFormat(e) : {}
          },
          setNumberFormat: function (e, t) {
            b.value && (b.value.setNumberFormat(e, t), (y.value[e] = t))
          },
          mergeNumberFormat: function (e, t) {
            b.value && b.value.mergeNumberFormat(e, t)
          }
        }
        return (
          x.onBeforeMount(() => {
            if (null == i.proxy || null == i.proxy.$i18n)
              throw Error(te.NOT_AVAILABLE_COMPOSITION_IN_LEGACY)
            var t,
              e = (b.value = i.proxy.$i18n.__composer)
            'global' === u
              ? ((h.value = e.locale.value),
                (L.value = e.fallbackLocale.value),
                (N.value = e.messages.value),
                (T.value = e.datetimeFormats.value),
                (y.value = e.numberFormats.value))
              : E &&
                (((t = e).locale.value = h.value),
                (t.fallbackLocale.value = L.value),
                Object.keys(N.value).forEach((e) => {
                  t.mergeLocaleMessage(e, N.value[e])
                }),
                Object.keys(T.value).forEach((e) => {
                  t.mergeDateTimeFormat(e, T.value[e])
                }),
                Object.keys(y.value).forEach((e) => {
                  t.mergeNumberFormat(e, y.value[e])
                }),
                (t.escapeParameter = S),
                (t.fallbackFormat = P),
                (t.fallbackRoot = O),
                (t.fallbackWarn = C),
                (t.missingWarn = I),
                (t.warnHtmlMessage = F))
          }),
          m
        )
        return
      }
      throw Error(te.NOT_AVAILABLE_IN_LEGACY_MODE)
    }
    if ('global' === c) return vt(s, t, e), s
    if ('parent' === c) {
      let e = (function (e, t, n = !1) {
        let r = null
        var a,
          l = t.root
        ;[t, a = !1] = [t, n]
        let o = null == t ? null : (a && t.vnode.ctx) || t.parent
        for (; null != o; ) {
          const t = e
          if ('composition' === e.mode) r = t.__getInstance(o)
          else {
            const e = t.__getInstance(o)
            null != e && ((r = e.__composer), n && r && !r[_t] && (r = null))
          }
          if (null != r) break
          if (l === o) break
          o = o.parent
        }
        return r
      })(o, l, t.__useComponent)
      return (e = null == e ? s : e)
    }
    const v = o
    let g = v.__getInstance(l)
    if (null == g) {
      const o = H({}, t)
      '__i18n' in e && (o.__i18n = e.__i18n),
        s && (o.__root = s),
        (g = Lt(o)),
        v.__composerExtend && (g[pt] = v.__composerExtend(g)),
        (n = v),
        (r = l),
        (a = g),
        x.onMounted(() => {}, r),
        x.onUnmounted(() => {
          const e = a,
            t = (n.__deleteInstance(r), e[pt])
          t && (t(), delete e[pt])
        }, r),
        v.__setInstance(l, g)
    }
    return g
  }
  const Wt = ['locale', 'fallbackLocale', 'availableLocales'],
    Ht = ['t', 'rt', 'd', 'n', 'tm', 'te']
  return (
    (ye = function (e, t) {
      if (G(e)) {
        Y(t.warnHtmlMessage) && t.warnHtmlMessage
        var n = (t.onCacheKey || Ye)(e),
          r = Be[n]
        if (r) return r
        var { ast: r, detectError: t } = (function (e, t) {
            let n = !1
            const r = t.onError || k
            return (
              (t.onError = (e) => {
                ;(n = !0), r(e)
              }),
              { ...oe(e, t), detectError: n }
            )
          })(e, { ...t, location: !1, jit: !0 }),
          r = De(r)
        return t ? r : (Be[n] = r)
      }
      {
        const t = e.cacheKey
        return t ? Be[t] || (Be[t] = De(e)) : De(e)
      }
    }),
    (Ie = function (e, t) {
      if (!B(e)) return null
      let n = ce.get(t)
      if (
        (n ||
          ((n = (function (e) {
            const t = []
            let n,
              r,
              a,
              l,
              o,
              s,
              c,
              i = -1,
              u = 0,
              f = 0
            const m = []
            for (
              m[0] = () => {
                void 0 === r ? (r = a) : (r += a)
              },
                m[1] = () => {
                  void 0 !== r && (t.push(r), (r = void 0))
                },
                m[2] = () => {
                  m[0](), f++
                },
                m[3] = () => {
                  if (!(0 < f))
                    return (
                      void (f = 0) !== r &&
                      !1 !==
                        (r =
                          ((e = r),
                          (n = e.trim()),
                          ('0' !== e.charAt(0) || !isNaN(parseInt(e))) &&
                            ((e = n),
                            se.test(e)
                              ? (t = (e = n).charCodeAt(0)) !==
                                  e.charCodeAt(e.length - 1) ||
                                (34 !== t && 39 !== t)
                                ? e
                                : e.slice(1, -1)
                              : '*' + n))) &&
                      void m[1]()
                    )
                  var e, t, n
                  f--, (u = 4), m[0]()
                };
              null !== u;

            )
              if (
                (i++,
                '\\' !== (n = e[i]) ||
                  ((_ = void 0),
                  (_ = e[i + 1]),
                  !((5 === u && "'" === _) || (6 === u && '"' === _)) ||
                    (i++, (a = '\\' + _), m[0](), 0)))
              ) {
                if (
                  ((l = (function (e) {
                    if (null == e) return 'o'
                    switch (e.charCodeAt(0)) {
                      case 91:
                      case 93:
                      case 46:
                      case 34:
                      case 39:
                        return e
                      case 95:
                      case 36:
                      case 45:
                        return 'i'
                      case 9:
                      case 10:
                      case 13:
                      case 160:
                      case 65279:
                      case 8232:
                      case 8233:
                        return 'w'
                    }
                    return 'i'
                  })(n)),
                  8 === (o = (c = d[u])[l] || c.l || 8))
                )
                  return
                if (
                  ((u = o[0]),
                  void 0 !== o[1] && (s = m[o[1]]) && ((a = n), !1 === s()))
                )
                  return
                if (7 === u) return t
              }
            var _
          })(t)) &&
            ce.set(t, n)),
        !n)
      )
        return null
      var r = n.length
      let a = e,
        l = 0
      for (; l < r; ) {
        const e = a[n[l]]
        if (void 0 === e) return null
        if (X(a)) return null
        ;(a = e), l++
      }
      return a
    }),
    (Ce = ke),
    (e.DatetimeFormat = Rt),
    (e.I18nD = Ft),
    (e.I18nInjectionKey = xt),
    (e.I18nN = At),
    (e.I18nT = Ct),
    (e.NumberFormat = Pt),
    (e.Translation = It),
    (e.VERSION = st),
    (e.castToVueI18n = (e) => {
      if ('__VUE_I18N_BRIDGE__' in e) return e
      throw Error(te.NOT_COMPATIBLE_LEGACY_VUE_I18N)
    }),
    (e.createI18n = function (u = {}, e) {
      const f = !Y(u.legacy) || u.legacy,
        m = !Y(u.globalInjection) || u.globalInjection,
        t = !f || !!u.allowComposition,
        n = new Map(),
        [r, _] = (function (e, t) {
          const n = x.effectScope()
          {
            const x = t ? n.run(() => Nt(e)) : n.run(() => Lt(e))
            if (null == x) throw Error(te.UNEXPECTED_ERROR)
            return [n, x]
          }
        })(u, f),
        p = a('')
      {
        const u = {
          get mode() {
            return f ? 'legacy' : 'composition'
          },
          get allowComposition() {
            return t
          },
          async install(e, ...t) {
            if (
              ((e.__VUE_I18N_SYMBOL__ = p),
              e.provide(e.__VUE_I18N_SYMBOL__, u),
              K(t[0]))
            ) {
              const x = t[0]
              ;(u.__composerExtend = x.__composerExtend),
                (u.__vueI18nExtend = x.__vueI18nExtend)
            }
            let n = null
            var r, a, l, o, s, c
            !f &&
              m &&
              (n = (function (n, r) {
                const a = Object.create(null)
                Wt.forEach((e) => {
                  const t = Object.getOwnPropertyDescriptor(r, e)
                  if (!t) throw Error(te.UNEXPECTED_ERROR)
                  var n = x.isRef(t.value)
                    ? {
                        get: () => t.value.value,
                        set(e) {
                          t.value.value = e
                        }
                      }
                    : { get: () => t.get && t.get() }
                  Object.defineProperty(a, e, n)
                }),
                  (n.config.globalProperties.$i18n = a),
                  Ht.forEach((e) => {
                    var t = Object.getOwnPropertyDescriptor(r, e)
                    if (!t || !t.value) throw Error(te.UNEXPECTED_ERROR)
                    Object.defineProperty(n.config.globalProperties, '$' + e, t)
                  })
                return () => {
                  delete n.config.globalProperties.$i18n,
                    Ht.forEach((e) => {
                      delete n.config.globalProperties['$' + e]
                    })
                }
              })(e, u.global)),
              ([o, t, ...s] = [e, u, ...t]),
              (s = K(s[0]) ? s[0] : {}),
              (c = !!s.useI18nComponentName),
              (Y(s.globalInstall) && !s.globalInstall) ||
                ([c ? 'i18n' : It.name, 'I18nT'].forEach((e) =>
                  o.component(e, It)
                ),
                [Pt.name, 'I18nN'].forEach((e) => o.component(e, Pt)),
                [Rt.name, 'I18nD'].forEach((e) => o.component(e, Rt))),
              o.directive('t', St(t)),
              f &&
                e.mixin(
                  ((r = _),
                  (a = _.__composer),
                  (l = u),
                  {
                    beforeCreate() {
                      var e = x.getCurrentInstance()
                      if (!e) throw Error(te.UNEXPECTED_ERROR)
                      var t = this.$options
                      if (t.i18n) {
                        const x = t.i18n
                        if (
                          (t.__i18n && (x.__i18n = t.__i18n),
                          (x.__root = a),
                          this === this.$root)
                        )
                          this.$i18n = wt(r, x)
                        else {
                          ;(x.__injectWithOption = !0),
                            (x.__extender = l.__vueI18nExtend),
                            (this.$i18n = Nt(x))
                          const r = this.$i18n
                          r.__extender &&
                            (r.__disposer = r.__extender(this.$i18n))
                        }
                      } else if (t.__i18n)
                        if (this === this.$root) this.$i18n = wt(r, t)
                        else {
                          this.$i18n = Nt({
                            __i18n: t.__i18n,
                            __injectWithOption: !0,
                            __extender: l.__vueI18nExtend,
                            __root: a
                          })
                          const r = this.$i18n
                          r.__extender &&
                            (r.__disposer = r.__extender(this.$i18n))
                        }
                      else this.$i18n = r
                      t.__i18nGlobal && vt(a, t, t),
                        (this.$t = (...e) => this.$i18n.t(...e)),
                        (this.$rt = (...e) => this.$i18n.rt(...e)),
                        (this.$tc = (...e) => this.$i18n.tc(...e)),
                        (this.$te = (e, t) => this.$i18n.te(e, t)),
                        (this.$d = (...e) => this.$i18n.d(...e)),
                        (this.$n = (...e) => this.$i18n.n(...e)),
                        (this.$tm = (e) => this.$i18n.tm(e)),
                        l.__setInstance(e, this.$i18n)
                    },
                    mounted() {},
                    unmounted() {
                      var e = x.getCurrentInstance()
                      if (!e) throw Error(te.UNEXPECTED_ERROR)
                      const t = this.$i18n
                      delete this.$t,
                        delete this.$rt,
                        delete this.$tc,
                        delete this.$te,
                        delete this.$d,
                        delete this.$n,
                        delete this.$tm,
                        t.__disposer &&
                          (t.__disposer(),
                          delete t.__disposer,
                          delete t.__extender),
                        l.__deleteInstance(e),
                        delete this.$i18n
                    }
                  })
                )
            const i = e.unmount
            e.unmount = () => {
              n && n(), u.dispose(), i()
            }
          },
          get global() {
            return _
          },
          dispose() {
            r.stop()
          },
          __instances: n,
          __getInstance: function (e) {
            return n.get(e) || null
          },
          __setInstance: function (e, t) {
            n.set(e, t)
          },
          __deleteInstance: function (e) {
            n.delete(e)
          }
        }
        return u
      }
    }),
    (e.useI18n = Ut),
    (e.vTDirective = St),
    e
  )
})({}, Vue)
