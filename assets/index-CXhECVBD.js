const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      './KeybindingPanel-DUoRw5XE.js',
      './index-rSmOOw8G.js',
      './index-DcTOE_QK.js',
      './KeybindingPanel-_a_pWHzU.css',
      './ExtensionPanel-DSAkKiE9.js',
      './ServerConfigPanel-B_24-2Tt.js',
      './serverConfigStore-DaXaAdcO.js',
      './index-Ceqa5QT-.js',
      './widgetInputs-rxCYoFG8.js',
      './index-BdBzDNmk.css',
      './GraphView-Cbaje2Ve.js',
      './GraphView-CuKvAVuD.css',
      './ServerStartView-COVLDBH3.js',
      './ServerStartView-CpTdwiW7.css',
      './InstallView-CBV93Gts.js',
      './InstallView-CLkCBnl8.css',
      './WelcomeView-chN3jxAd.js',
      './WelcomeView-D8dN2QhR.css'
    ])
) => i.map((i) => d[i])
var __defProp2 = Object.defineProperty,
  __name = (e, t) => __defProp2(e, 'name', { value: t, configurable: !0 })
__name(function () {
  const e = document.createElement('link').relList
  if (!(e && e.supports && e.supports('modulepreload'))) {
    for (const e of document.querySelectorAll('link[rel="modulepreload"]')) n(e)
    new MutationObserver((e) => {
      for (const t of e)
        if ('childList' === t.type)
          for (const e of t.addedNodes)
            'LINK' === e.tagName && 'modulepreload' === e.rel && n(e)
    }).observe(document, { childList: !0, subtree: !0 }),
      __name(t, 'getFetchOpts'),
      __name(n, 'processPreload')
  }
  function t(e) {
    const t = {}
    return (
      e.integrity && (t.integrity = e.integrity),
      e.referrerPolicy && (t.referrerPolicy = e.referrerPolicy),
      'use-credentials' === e.crossOrigin
        ? (t.credentials = 'include')
        : 'anonymous' === e.crossOrigin
          ? (t.credentials = 'omit')
          : (t.credentials = 'same-origin'),
      t
    )
  }
  function n(e) {
    if (e.ep) return
    e.ep = !0
    const n = t(e)
    fetch(e.href, n)
  }
}, 'polyfill')()
const config = { app_title: 'ComfyUI', app_version: '1.5.8' }
/**
 * @vue/shared v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/*! #__NO_SIDE_EFFECTS__ */ function makeMap(e) {
  const t = Object.create(null)
  for (const n of e.split(',')) t[n] = 1
  return (e) => e in t
}
__name(makeMap, 'makeMap')
const EMPTY_OBJ = {},
  EMPTY_ARR = [],
  NOOP = __name(() => {}, 'NOOP'),
  NO = __name(() => !1, 'NO'),
  isOn = __name(
    (e) =>
      111 === e.charCodeAt(0) &&
      110 === e.charCodeAt(1) &&
      (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
    'isOn'
  ),
  isModelListener = __name((e) => e.startsWith('onUpdate:'), 'isModelListener'),
  extend$1 = Object.assign,
  remove$1 = __name((e, t) => {
    const n = e.indexOf(t)
    n > -1 && e.splice(n, 1)
  }, 'remove$1'),
  hasOwnProperty$2 = Object.prototype.hasOwnProperty,
  hasOwn$2 = __name((e, t) => hasOwnProperty$2.call(e, t), 'hasOwn$2'),
  isArray$3 = Array.isArray,
  isMap = __name((e) => '[object Map]' === toTypeString(e), 'isMap'),
  isSet = __name((e) => '[object Set]' === toTypeString(e), 'isSet'),
  isDate$2 = __name((e) => '[object Date]' === toTypeString(e), 'isDate$2'),
  isRegExp$1 = __name(
    (e) => '[object RegExp]' === toTypeString(e),
    'isRegExp$1'
  ),
  isFunction$3 = __name((e) => 'function' == typeof e, 'isFunction$3'),
  isString$3 = __name((e) => 'string' == typeof e, 'isString$3'),
  isSymbol = __name((e) => 'symbol' == typeof e, 'isSymbol'),
  isObject$4 = __name((e) => null !== e && 'object' == typeof e, 'isObject$4'),
  isPromise = __name(
    (e) =>
      (isObject$4(e) || isFunction$3(e)) &&
      isFunction$3(e.then) &&
      isFunction$3(e.catch),
    'isPromise'
  ),
  objectToString = Object.prototype.toString,
  toTypeString = __name((e) => objectToString.call(e), 'toTypeString'),
  toRawType = __name((e) => toTypeString(e).slice(8, -1), 'toRawType'),
  isPlainObject$2 = __name(
    (e) => '[object Object]' === toTypeString(e),
    'isPlainObject$2'
  ),
  isIntegerKey = __name(
    (e) =>
      isString$3(e) &&
      'NaN' !== e &&
      '-' !== e[0] &&
      '' + parseInt(e, 10) === e,
    'isIntegerKey'
  ),
  isReservedProp = makeMap(
    ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'
  ),
  isBuiltInDirective = makeMap(
    'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'
  ),
  cacheStringFunction$1 = __name((e) => {
    const t = Object.create(null)
    return (n) => t[n] || (t[n] = e(n))
  }, 'cacheStringFunction$1'),
  camelizeRE$1 = /-(\w)/g,
  camelize$1 = cacheStringFunction$1((e) =>
    e.replace(camelizeRE$1, (e, t) => (t ? t.toUpperCase() : ''))
  ),
  hyphenateRE$1 = /\B([A-Z])/g,
  hyphenate$1 = cacheStringFunction$1((e) =>
    e.replace(hyphenateRE$1, '-$1').toLowerCase()
  ),
  capitalize = cacheStringFunction$1(
    (e) => e.charAt(0).toUpperCase() + e.slice(1)
  ),
  toHandlerKey = cacheStringFunction$1((e) => (e ? `on${capitalize(e)}` : '')),
  hasChanged = __name((e, t) => !Object.is(e, t), 'hasChanged'),
  invokeArrayFns = __name((e, ...t) => {
    for (let n = 0; n < e.length; n++) e[n](...t)
  }, 'invokeArrayFns'),
  def = __name((e, t, n, o = !1) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      writable: o,
      value: n
    })
  }, 'def'),
  looseToNumber = __name((e) => {
    const t = parseFloat(e)
    return isNaN(t) ? e : t
  }, 'looseToNumber'),
  toNumber = __name((e) => {
    const t = isString$3(e) ? Number(e) : NaN
    return isNaN(t) ? e : t
  }, 'toNumber')
let _globalThis
const getGlobalThis = __name(
    () =>
      _globalThis ||
      (_globalThis =
        'undefined' != typeof globalThis
          ? globalThis
          : 'undefined' != typeof self
            ? self
            : 'undefined' != typeof window
              ? window
              : 'undefined' != typeof global
                ? global
                : {}),
    'getGlobalThis'
  ),
  identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/
function genPropsAccessExp(e) {
  return identRE.test(e) ? `__props.${e}` : `__props[${JSON.stringify(e)}]`
}
function genCacheKey(e, t) {
  return (
    e + JSON.stringify(t, (e, t) => ('function' == typeof t ? t.toString() : t))
  )
}
__name(genPropsAccessExp, 'genPropsAccessExp'),
  __name(genCacheKey, 'genCacheKey')
const PatchFlags = {
    TEXT: 1,
    1: 'TEXT',
    CLASS: 2,
    2: 'CLASS',
    STYLE: 4,
    4: 'STYLE',
    PROPS: 8,
    8: 'PROPS',
    FULL_PROPS: 16,
    16: 'FULL_PROPS',
    NEED_HYDRATION: 32,
    32: 'NEED_HYDRATION',
    STABLE_FRAGMENT: 64,
    64: 'STABLE_FRAGMENT',
    KEYED_FRAGMENT: 128,
    128: 'KEYED_FRAGMENT',
    UNKEYED_FRAGMENT: 256,
    256: 'UNKEYED_FRAGMENT',
    NEED_PATCH: 512,
    512: 'NEED_PATCH',
    DYNAMIC_SLOTS: 1024,
    1024: 'DYNAMIC_SLOTS',
    DEV_ROOT_FRAGMENT: 2048,
    2048: 'DEV_ROOT_FRAGMENT',
    CACHED: -1,
    '-1': 'CACHED',
    BAIL: -2,
    '-2': 'BAIL'
  },
  PatchFlagNames = {
    1: 'TEXT',
    2: 'CLASS',
    4: 'STYLE',
    8: 'PROPS',
    16: 'FULL_PROPS',
    32: 'NEED_HYDRATION',
    64: 'STABLE_FRAGMENT',
    128: 'KEYED_FRAGMENT',
    256: 'UNKEYED_FRAGMENT',
    512: 'NEED_PATCH',
    1024: 'DYNAMIC_SLOTS',
    2048: 'DEV_ROOT_FRAGMENT',
    [-1]: 'HOISTED',
    [-2]: 'BAIL'
  },
  ShapeFlags = {
    ELEMENT: 1,
    1: 'ELEMENT',
    FUNCTIONAL_COMPONENT: 2,
    2: 'FUNCTIONAL_COMPONENT',
    STATEFUL_COMPONENT: 4,
    4: 'STATEFUL_COMPONENT',
    TEXT_CHILDREN: 8,
    8: 'TEXT_CHILDREN',
    ARRAY_CHILDREN: 16,
    16: 'ARRAY_CHILDREN',
    SLOTS_CHILDREN: 32,
    32: 'SLOTS_CHILDREN',
    TELEPORT: 64,
    64: 'TELEPORT',
    SUSPENSE: 128,
    128: 'SUSPENSE',
    COMPONENT_SHOULD_KEEP_ALIVE: 256,
    256: 'COMPONENT_SHOULD_KEEP_ALIVE',
    COMPONENT_KEPT_ALIVE: 512,
    512: 'COMPONENT_KEPT_ALIVE',
    COMPONENT: 6,
    6: 'COMPONENT'
  },
  SlotFlags = {
    STABLE: 1,
    1: 'STABLE',
    DYNAMIC: 2,
    2: 'DYNAMIC',
    FORWARDED: 3,
    3: 'FORWARDED'
  },
  slotFlagsText = { 1: 'STABLE', 2: 'DYNAMIC', 3: 'FORWARDED' },
  GLOBALS_ALLOWED =
    'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol',
  isGloballyAllowed = makeMap(GLOBALS_ALLOWED),
  isGloballyWhitelisted = isGloballyAllowed,
  range = 2
function generateCodeFrame(e, t = 0, n = e.length) {
  if (
    (t = Math.max(0, Math.min(t, e.length))) >
    (n = Math.max(0, Math.min(n, e.length)))
  )
    return ''
  let o = e.split(/(\r?\n)/)
  const i = o.filter((e, t) => t % 2 == 1)
  o = o.filter((e, t) => t % 2 == 0)
  let r = 0
  const a = []
  for (let s = 0; s < o.length; s++)
    if (((r += o[s].length + ((i[s] && i[s].length) || 0)), r >= t)) {
      for (let e = s - range; e <= s + range || n > r; e++) {
        if (e < 0 || e >= o.length) continue
        const l = e + 1
        a.push(`${l}${' '.repeat(Math.max(3 - String(l).length, 0))}|  ${o[e]}`)
        const c = o[e].length,
          d = (i[e] && i[e].length) || 0
        if (e === s) {
          const e = t - (r - (c + d)),
            o = Math.max(1, n > r ? c - e : n - t)
          a.push('   |  ' + ' '.repeat(e) + '^'.repeat(o))
        } else if (e > s) {
          if (n > r) {
            const e = Math.max(Math.min(n - r, c), 1)
            a.push('   |  ' + '^'.repeat(e))
          }
          r += c + d
        }
      }
      break
    }
  return a.join('\n')
}
function normalizeStyle(e) {
  if (isArray$3(e)) {
    const t = {}
    for (let n = 0; n < e.length; n++) {
      const o = e[n],
        i = isString$3(o) ? parseStringStyle(o) : normalizeStyle(o)
      if (i) for (const e in i) t[e] = i[e]
    }
    return t
  }
  if (isString$3(e) || isObject$4(e)) return e
}
__name(generateCodeFrame, 'generateCodeFrame'),
  __name(normalizeStyle, 'normalizeStyle')
const listDelimiterRE = /;(?![^(]*\))/g,
  propertyDelimiterRE = /:([^]+)/,
  styleCommentRE = /\/\*[^]*?\*\//g
function parseStringStyle(e) {
  const t = {}
  return (
    e
      .replace(styleCommentRE, '')
      .split(listDelimiterRE)
      .forEach((e) => {
        if (e) {
          const n = e.split(propertyDelimiterRE)
          n.length > 1 && (t[n[0].trim()] = n[1].trim())
        }
      }),
    t
  )
}
function stringifyStyle(e) {
  if (!e) return ''
  if (isString$3(e)) return e
  let t = ''
  for (const n in e) {
    const o = e[n]
    if (isString$3(o) || 'number' == typeof o) {
      t += `${n.startsWith('--') ? n : hyphenate$1(n)}:${o};`
    }
  }
  return t
}
function normalizeClass(e) {
  let t = ''
  if (isString$3(e)) t = e
  else if (isArray$3(e))
    for (let n = 0; n < e.length; n++) {
      const o = normalizeClass(e[n])
      o && (t += o + ' ')
    }
  else if (isObject$4(e)) for (const n in e) e[n] && (t += n + ' ')
  return t.trim()
}
function normalizeProps(e) {
  if (!e) return null
  let { class: t, style: n } = e
  return (
    t && !isString$3(t) && (e.class = normalizeClass(t)),
    n && (e.style = normalizeStyle(n)),
    e
  )
}
__name(parseStringStyle, 'parseStringStyle'),
  __name(stringifyStyle, 'stringifyStyle'),
  __name(normalizeClass, 'normalizeClass'),
  __name(normalizeProps, 'normalizeProps')
const HTML_TAGS =
    'html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot',
  SVG_TAGS =
    'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view',
  MATH_TAGS =
    'annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics',
  VOID_TAGS =
    'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr',
  isHTMLTag = makeMap(HTML_TAGS),
  isSVGTag = makeMap(SVG_TAGS),
  isMathMLTag = makeMap(MATH_TAGS),
  isVoidTag = makeMap(VOID_TAGS),
  specialBooleanAttrs =
    'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
  isSpecialBooleanAttr = makeMap(specialBooleanAttrs),
  isBooleanAttr = makeMap(
    specialBooleanAttrs +
      ',async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected'
  )
function includeBooleanAttr(e) {
  return !!e || '' === e
}
__name(includeBooleanAttr, 'includeBooleanAttr')
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/,
  attrValidationCache = {}
function isSSRSafeAttrName(e) {
  if (attrValidationCache.hasOwnProperty(e)) return attrValidationCache[e]
  const t = unsafeAttrCharRE.test(e)
  return (
    t && console.error(`unsafe attribute name: ${e}`),
    (attrValidationCache[e] = !t)
  )
}
__name(isSSRSafeAttrName, 'isSSRSafeAttrName')
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  isKnownHtmlAttr = makeMap(
    'accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap'
  ),
  isKnownSvgAttr = makeMap(
    'xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan'
  ),
  isKnownMathMLAttr = makeMap(
    'accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns'
  )
function isRenderableAttrValue(e) {
  if (null == e) return !1
  const t = typeof e
  return 'string' === t || 'number' === t || 'boolean' === t
}
__name(isRenderableAttrValue, 'isRenderableAttrValue')
const escapeRE = /["'&<>]/
function escapeHtml(e) {
  const t = '' + e,
    n = escapeRE.exec(t)
  if (!n) return t
  let o,
    i,
    r = '',
    a = 0
  for (i = n.index; i < t.length; i++) {
    switch (t.charCodeAt(i)) {
      case 34:
        o = '&quot;'
        break
      case 38:
        o = '&amp;'
        break
      case 39:
        o = '&#39;'
        break
      case 60:
        o = '&lt;'
        break
      case 62:
        o = '&gt;'
        break
      default:
        continue
    }
    a !== i && (r += t.slice(a, i)), (a = i + 1), (r += o)
  }
  return a !== i ? r + t.slice(a, i) : r
}
__name(escapeHtml, 'escapeHtml')
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g
function escapeHtmlComment(e) {
  return e.replace(commentStripRE, '')
}
__name(escapeHtmlComment, 'escapeHtmlComment')
const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g
function getEscapedCssVarName(e, t) {
  return e.replace(cssVarNameEscapeSymbolsRE, (e) =>
    t ? ('"' === e ? '\\\\\\"' : `\\\\${e}`) : `\\${e}`
  )
}
function looseCompareArrays(e, t) {
  if (e.length !== t.length) return !1
  let n = !0
  for (let o = 0; n && o < e.length; o++) n = looseEqual(e[o], t[o])
  return n
}
function looseEqual(e, t) {
  if (e === t) return !0
  let n = isDate$2(e),
    o = isDate$2(t)
  if (n || o) return !(!n || !o) && e.getTime() === t.getTime()
  if (((n = isSymbol(e)), (o = isSymbol(t)), n || o)) return e === t
  if (((n = isArray$3(e)), (o = isArray$3(t)), n || o))
    return !(!n || !o) && looseCompareArrays(e, t)
  if (((n = isObject$4(e)), (o = isObject$4(t)), n || o)) {
    if (!n || !o) return !1
    if (Object.keys(e).length !== Object.keys(t).length) return !1
    for (const n in e) {
      const o = e.hasOwnProperty(n),
        i = t.hasOwnProperty(n)
      if ((o && !i) || (!o && i) || !looseEqual(e[n], t[n])) return !1
    }
  }
  return String(e) === String(t)
}
function looseIndexOf(e, t) {
  return e.findIndex((e) => looseEqual(e, t))
}
__name(getEscapedCssVarName, 'getEscapedCssVarName'),
  __name(looseCompareArrays, 'looseCompareArrays'),
  __name(looseEqual, 'looseEqual'),
  __name(looseIndexOf, 'looseIndexOf')
const isRef$1 = __name((e) => !(!e || !0 !== e.__v_isRef), 'isRef$1'),
  toDisplayString = __name(
    (e) =>
      isString$3(e)
        ? e
        : null == e
          ? ''
          : isArray$3(e) ||
              (isObject$4(e) &&
                (e.toString === objectToString || !isFunction$3(e.toString)))
            ? isRef$1(e)
              ? toDisplayString(e.value)
              : JSON.stringify(e, replacer, 2)
            : String(e),
    'toDisplayString'
  ),
  replacer = __name(
    (e, t) =>
      isRef$1(t)
        ? replacer(e, t.value)
        : isMap(t)
          ? {
              [`Map(${t.size})`]: [...t.entries()].reduce(
                (e, [t, n], o) => ((e[stringifySymbol(t, o) + ' =>'] = n), e),
                {}
              )
            }
          : isSet(t)
            ? {
                [`Set(${t.size})`]: [...t.values()].map((e) =>
                  stringifySymbol(e)
                )
              }
            : isSymbol(t)
              ? stringifySymbol(t)
              : !isObject$4(t) || isArray$3(t) || isPlainObject$2(t)
                ? t
                : String(t),
    'replacer'
  ),
  stringifySymbol = __name((e, t = '') => {
    var n
    return isSymbol(e) ? `Symbol(${null != (n = e.description) ? n : t})` : e
  }, 'stringifySymbol')
/**
 * @vue/reactivity v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
function warn$2(e, ...t) {
  console.warn(`[Vue warn] ${e}`, ...t)
}
let activeEffectScope, activeSub
__name(warn$2, 'warn$2')
class EffectScope {
  static {
    __name(this, 'EffectScope')
  }
  constructor(e = !1) {
    ;(this.detached = e),
      (this._active = !0),
      (this.effects = []),
      (this.cleanups = []),
      (this._isPaused = !1),
      (this.parent = activeEffectScope),
      !e &&
        activeEffectScope &&
        (this.index =
          (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1)
  }
  get active() {
    return this._active
  }
  pause() {
    if (this._active) {
      let e, t
      if (((this._isPaused = !0), this.scopes))
        for (e = 0, t = this.scopes.length; e < t; e++) this.scopes[e].pause()
      for (e = 0, t = this.effects.length; e < t; e++) this.effects[e].pause()
    }
  }
  resume() {
    if (this._active && this._isPaused) {
      let e, t
      if (((this._isPaused = !1), this.scopes))
        for (e = 0, t = this.scopes.length; e < t; e++) this.scopes[e].resume()
      for (e = 0, t = this.effects.length; e < t; e++) this.effects[e].resume()
    }
  }
  run(e) {
    if (this._active) {
      const t = activeEffectScope
      try {
        return (activeEffectScope = this), e()
      } finally {
        activeEffectScope = t
      }
    } else 0
  }
  on() {
    activeEffectScope = this
  }
  off() {
    activeEffectScope = this.parent
  }
  stop(e) {
    if (this._active) {
      let t, n
      for (this._active = !1, t = 0, n = this.effects.length; t < n; t++)
        this.effects[t].stop()
      for (this.effects.length = 0, t = 0, n = this.cleanups.length; t < n; t++)
        this.cleanups[t]()
      if (((this.cleanups.length = 0), this.scopes)) {
        for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].stop(!0)
        this.scopes.length = 0
      }
      if (!this.detached && this.parent && !e) {
        const e = this.parent.scopes.pop()
        e &&
          e !== this &&
          ((this.parent.scopes[this.index] = e), (e.index = this.index))
      }
      this.parent = void 0
    }
  }
}
function effectScope(e) {
  return new EffectScope(e)
}
function getCurrentScope() {
  return activeEffectScope
}
function onScopeDispose(e, t = !1) {
  activeEffectScope && activeEffectScope.cleanups.push(e)
}
__name(effectScope, 'effectScope'),
  __name(getCurrentScope, 'getCurrentScope'),
  __name(onScopeDispose, 'onScopeDispose')
const EffectFlags = {
    ACTIVE: 1,
    1: 'ACTIVE',
    RUNNING: 2,
    2: 'RUNNING',
    TRACKING: 4,
    4: 'TRACKING',
    NOTIFIED: 8,
    8: 'NOTIFIED',
    DIRTY: 16,
    16: 'DIRTY',
    ALLOW_RECURSE: 32,
    32: 'ALLOW_RECURSE',
    PAUSED: 64,
    64: 'PAUSED'
  },
  pausedQueueEffects = new WeakSet()
class ReactiveEffect {
  static {
    __name(this, 'ReactiveEffect')
  }
  constructor(e) {
    ;(this.fn = e),
      (this.deps = void 0),
      (this.depsTail = void 0),
      (this.flags = 5),
      (this.next = void 0),
      (this.cleanup = void 0),
      (this.scheduler = void 0),
      activeEffectScope &&
        activeEffectScope.active &&
        activeEffectScope.effects.push(this)
  }
  pause() {
    this.flags |= 64
  }
  resume() {
    64 & this.flags &&
      ((this.flags &= -65),
      pausedQueueEffects.has(this) &&
        (pausedQueueEffects.delete(this), this.trigger()))
  }
  notify() {
    ;(2 & this.flags && !(32 & this.flags)) || 8 & this.flags || batch(this)
  }
  run() {
    if (!(1 & this.flags)) return this.fn()
    ;(this.flags |= 2), cleanupEffect(this), prepareDeps(this)
    const e = activeSub,
      t = shouldTrack
    ;(activeSub = this), (shouldTrack = !0)
    try {
      return this.fn()
    } finally {
      0,
        cleanupDeps(this),
        (activeSub = e),
        (shouldTrack = t),
        (this.flags &= -3)
    }
  }
  stop() {
    if (1 & this.flags) {
      for (let e = this.deps; e; e = e.nextDep) removeSub(e)
      ;(this.deps = this.depsTail = void 0),
        cleanupEffect(this),
        this.onStop && this.onStop(),
        (this.flags &= -2)
    }
  }
  trigger() {
    64 & this.flags
      ? pausedQueueEffects.add(this)
      : this.scheduler
        ? this.scheduler()
        : this.runIfDirty()
  }
  runIfDirty() {
    isDirty$1(this) && this.run()
  }
  get dirty() {
    return isDirty$1(this)
  }
}
let batchDepth = 0,
  batchedSub,
  batchedComputed
function batch(e, t = !1) {
  if (((e.flags |= 8), t))
    return (e.next = batchedComputed), void (batchedComputed = e)
  ;(e.next = batchedSub), (batchedSub = e)
}
function startBatch() {
  batchDepth++
}
function endBatch() {
  if (--batchDepth > 0) return
  if (batchedComputed) {
    let e = batchedComputed
    for (batchedComputed = void 0; e; ) {
      const t = e.next
      ;(e.next = void 0), (e.flags &= -9), (e = t)
    }
  }
  let e
  for (; batchedSub; ) {
    let n = batchedSub
    for (batchedSub = void 0; n; ) {
      const o = n.next
      if (((n.next = void 0), (n.flags &= -9), 1 & n.flags))
        try {
          n.trigger()
        } catch (t) {
          e || (e = t)
        }
      n = o
    }
  }
  if (e) throw e
}
function prepareDeps(e) {
  for (let t = e.deps; t; t = t.nextDep)
    (t.version = -1),
      (t.prevActiveLink = t.dep.activeLink),
      (t.dep.activeLink = t)
}
function cleanupDeps(e) {
  let t,
    n = e.depsTail,
    o = n
  for (; o; ) {
    const e = o.prevDep
    ;-1 === o.version
      ? (o === n && (n = e), removeSub(o), removeDep(o))
      : (t = o),
      (o.dep.activeLink = o.prevActiveLink),
      (o.prevActiveLink = void 0),
      (o = e)
  }
  ;(e.deps = t), (e.depsTail = n)
}
function isDirty$1(e) {
  for (let t = e.deps; t; t = t.nextDep)
    if (
      t.dep.version !== t.version ||
      (t.dep.computed &&
        (refreshComputed(t.dep.computed) || t.dep.version !== t.version))
    )
      return !0
  return !!e._dirty
}
function refreshComputed(e) {
  if (4 & e.flags && !(16 & e.flags)) return
  if (((e.flags &= -17), e.globalVersion === globalVersion)) return
  e.globalVersion = globalVersion
  const t = e.dep
  if (((e.flags |= 2), t.version > 0 && !e.isSSR && e.deps && !isDirty$1(e)))
    return void (e.flags &= -3)
  const n = activeSub,
    o = shouldTrack
  ;(activeSub = e), (shouldTrack = !0)
  try {
    prepareDeps(e)
    const n = e.fn(e._value)
    ;(0 === t.version || hasChanged(n, e._value)) &&
      ((e._value = n), t.version++)
  } catch (i) {
    throw (t.version++, i)
  } finally {
    ;(activeSub = n), (shouldTrack = o), cleanupDeps(e), (e.flags &= -3)
  }
}
function removeSub(e, t = !1) {
  const { dep: n, prevSub: o, nextSub: i } = e
  if (
    (o && ((o.nextSub = i), (e.prevSub = void 0)),
    i && ((i.prevSub = o), (e.nextSub = void 0)),
    n.subs === e && ((n.subs = o), !o && n.computed))
  ) {
    n.computed.flags &= -5
    for (let e = n.computed.deps; e; e = e.nextDep) removeSub(e, !0)
  }
  t || --n.sc || !n.map || n.map.delete(n.key)
}
function removeDep(e) {
  const { prevDep: t, nextDep: n } = e
  t && ((t.nextDep = n), (e.prevDep = void 0)),
    n && ((n.prevDep = t), (e.nextDep = void 0))
}
function effect(e, t) {
  e.effect instanceof ReactiveEffect && (e = e.effect.fn)
  const n = new ReactiveEffect(e)
  t && extend$1(n, t)
  try {
    n.run()
  } catch (i) {
    throw (n.stop(), i)
  }
  const o = n.run.bind(n)
  return (o.effect = n), o
}
function stop(e) {
  e.effect.stop()
}
__name(batch, 'batch'),
  __name(startBatch, 'startBatch'),
  __name(endBatch, 'endBatch'),
  __name(prepareDeps, 'prepareDeps'),
  __name(cleanupDeps, 'cleanupDeps'),
  __name(isDirty$1, 'isDirty$1'),
  __name(refreshComputed, 'refreshComputed'),
  __name(removeSub, 'removeSub'),
  __name(removeDep, 'removeDep'),
  __name(effect, 'effect'),
  __name(stop, 'stop')
let shouldTrack = !0
const trackStack = []
function pauseTracking() {
  trackStack.push(shouldTrack), (shouldTrack = !1)
}
function enableTracking() {
  trackStack.push(shouldTrack), (shouldTrack = !0)
}
function resetTracking() {
  const e = trackStack.pop()
  shouldTrack = void 0 === e || e
}
function onEffectCleanup(e, t = !1) {
  activeSub instanceof ReactiveEffect && (activeSub.cleanup = e)
}
function cleanupEffect(e) {
  const { cleanup: t } = e
  if (((e.cleanup = void 0), t)) {
    const e = activeSub
    activeSub = void 0
    try {
      t()
    } finally {
      activeSub = e
    }
  }
}
__name(pauseTracking, 'pauseTracking'),
  __name(enableTracking, 'enableTracking'),
  __name(resetTracking, 'resetTracking'),
  __name(onEffectCleanup, 'onEffectCleanup'),
  __name(cleanupEffect, 'cleanupEffect')
let globalVersion = 0
class Link {
  static {
    __name(this, 'Link')
  }
  constructor(e, t) {
    ;(this.sub = e),
      (this.dep = t),
      (this.version = t.version),
      (this.nextDep =
        this.prevDep =
        this.nextSub =
        this.prevSub =
        this.prevActiveLink =
          void 0)
  }
}
class Dep {
  static {
    __name(this, 'Dep')
  }
  constructor(e) {
    ;(this.computed = e),
      (this.version = 0),
      (this.activeLink = void 0),
      (this.subs = void 0),
      (this.map = void 0),
      (this.key = void 0),
      (this.sc = 0)
  }
  track(e) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) return
    let t = this.activeLink
    if (void 0 === t || t.sub !== activeSub)
      (t = this.activeLink = new Link(activeSub, this)),
        activeSub.deps
          ? ((t.prevDep = activeSub.depsTail),
            (activeSub.depsTail.nextDep = t),
            (activeSub.depsTail = t))
          : (activeSub.deps = activeSub.depsTail = t),
        addSub(t)
    else if (-1 === t.version && ((t.version = this.version), t.nextDep)) {
      const e = t.nextDep
      ;(e.prevDep = t.prevDep),
        t.prevDep && (t.prevDep.nextDep = e),
        (t.prevDep = activeSub.depsTail),
        (t.nextDep = void 0),
        (activeSub.depsTail.nextDep = t),
        (activeSub.depsTail = t),
        activeSub.deps === t && (activeSub.deps = e)
    }
    return t
  }
  trigger(e) {
    this.version++, globalVersion++, this.notify(e)
  }
  notify(e) {
    startBatch()
    try {
      0
      for (let e = this.subs; e; e = e.prevSub)
        e.sub.notify() && e.sub.dep.notify()
    } finally {
      endBatch()
    }
  }
}
function addSub(e) {
  if ((e.dep.sc++, 4 & e.sub.flags)) {
    const t = e.dep.computed
    if (t && !e.dep.subs) {
      t.flags |= 20
      for (let e = t.deps; e; e = e.nextDep) addSub(e)
    }
    const n = e.dep.subs
    n !== e && ((e.prevSub = n), n && (n.nextSub = e)), (e.dep.subs = e)
  }
}
__name(addSub, 'addSub')
const targetMap = new WeakMap(),
  ITERATE_KEY = Symbol(''),
  MAP_KEY_ITERATE_KEY = Symbol(''),
  ARRAY_ITERATE_KEY = Symbol('')
function track(e, t, n) {
  if (shouldTrack && activeSub) {
    let t = targetMap.get(e)
    t || targetMap.set(e, (t = new Map()))
    let o = t.get(n)
    o || (t.set(n, (o = new Dep())), (o.map = t), (o.key = n)), o.track()
  }
}
function trigger(e, t, n, o, i, r) {
  const a = targetMap.get(e)
  if (!a) return void globalVersion++
  const s = __name((e) => {
    e && e.trigger()
  }, 'run')
  if ((startBatch(), 'clear' === t)) a.forEach(s)
  else {
    const i = isArray$3(e),
      r = i && isIntegerKey(n)
    if (i && 'length' === n) {
      const e = Number(o)
      a.forEach((t, n) => {
        ;('length' === n ||
          n === ARRAY_ITERATE_KEY ||
          (!isSymbol(n) && n >= e)) &&
          s(t)
      })
    } else
      switch (
        ((void 0 !== n || a.has(void 0)) && s(a.get(n)),
        r && s(a.get(ARRAY_ITERATE_KEY)),
        t)
      ) {
        case 'add':
          i
            ? r && s(a.get('length'))
            : (s(a.get(ITERATE_KEY)), isMap(e) && s(a.get(MAP_KEY_ITERATE_KEY)))
          break
        case 'delete':
          i ||
            (s(a.get(ITERATE_KEY)), isMap(e) && s(a.get(MAP_KEY_ITERATE_KEY)))
          break
        case 'set':
          isMap(e) && s(a.get(ITERATE_KEY))
      }
  }
  endBatch()
}
function getDepFromReactive(e, t) {
  const n = targetMap.get(e)
  return n && n.get(t)
}
function reactiveReadArray(e) {
  const t = toRaw(e)
  return t === e
    ? t
    : (track(t, 'iterate', ARRAY_ITERATE_KEY),
      isShallow(e) ? t : t.map(toReactive$1))
}
function shallowReadArray(e) {
  return track((e = toRaw(e)), 'iterate', ARRAY_ITERATE_KEY), e
}
__name(track, 'track'),
  __name(trigger, 'trigger'),
  __name(getDepFromReactive, 'getDepFromReactive'),
  __name(reactiveReadArray, 'reactiveReadArray'),
  __name(shallowReadArray, 'shallowReadArray')
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive$1)
  },
  concat(...e) {
    return reactiveReadArray(this).concat(
      ...e.map((e) => (isArray$3(e) ? reactiveReadArray(e) : e))
    )
  },
  entries() {
    return iterator(this, 'entries', (e) => ((e[1] = toReactive$1(e[1])), e))
  },
  every(e, t) {
    return apply(this, 'every', e, t, void 0, arguments)
  },
  filter(e, t) {
    return apply(this, 'filter', e, t, (e) => e.map(toReactive$1), arguments)
  },
  find(e, t) {
    return apply(this, 'find', e, t, toReactive$1, arguments)
  },
  findIndex(e, t) {
    return apply(this, 'findIndex', e, t, void 0, arguments)
  },
  findLast(e, t) {
    return apply(this, 'findLast', e, t, toReactive$1, arguments)
  },
  findLastIndex(e, t) {
    return apply(this, 'findLastIndex', e, t, void 0, arguments)
  },
  forEach(e, t) {
    return apply(this, 'forEach', e, t, void 0, arguments)
  },
  includes(...e) {
    return searchProxy(this, 'includes', e)
  },
  indexOf(...e) {
    return searchProxy(this, 'indexOf', e)
  },
  join(e) {
    return reactiveReadArray(this).join(e)
  },
  lastIndexOf(...e) {
    return searchProxy(this, 'lastIndexOf', e)
  },
  map(e, t) {
    return apply(this, 'map', e, t, void 0, arguments)
  },
  pop() {
    return noTracking(this, 'pop')
  },
  push(...e) {
    return noTracking(this, 'push', e)
  },
  reduce(e, ...t) {
    return reduce(this, 'reduce', e, t)
  },
  reduceRight(e, ...t) {
    return reduce(this, 'reduceRight', e, t)
  },
  shift() {
    return noTracking(this, 'shift')
  },
  some(e, t) {
    return apply(this, 'some', e, t, void 0, arguments)
  },
  splice(...e) {
    return noTracking(this, 'splice', e)
  },
  toReversed() {
    return reactiveReadArray(this).toReversed()
  },
  toSorted(e) {
    return reactiveReadArray(this).toSorted(e)
  },
  toSpliced(...e) {
    return reactiveReadArray(this).toSpliced(...e)
  },
  unshift(...e) {
    return noTracking(this, 'unshift', e)
  },
  values() {
    return iterator(this, 'values', toReactive$1)
  }
}
function iterator(e, t, n) {
  const o = shallowReadArray(e),
    i = o[t]()
  return (
    o === e ||
      isShallow(e) ||
      ((i._next = i.next),
      (i.next = () => {
        const e = i._next()
        return e.value && (e.value = n(e.value)), e
      })),
    i
  )
}
__name(iterator, 'iterator')
const arrayProto = Array.prototype
function apply(e, t, n, o, i, r) {
  const a = shallowReadArray(e),
    s = a !== e && !isShallow(e),
    l = a[t]
  if (l !== arrayProto[t]) {
    const t = l.apply(e, r)
    return s ? toReactive$1(t) : t
  }
  let c = n
  a !== e &&
    (s
      ? (c = __name(function (t, o) {
          return n.call(this, toReactive$1(t), o, e)
        }, 'wrappedFn'))
      : n.length > 2 &&
        (c = __name(function (t, o) {
          return n.call(this, t, o, e)
        }, 'wrappedFn')))
  const d = l.call(a, c, o)
  return s && i ? i(d) : d
}
function reduce(e, t, n, o) {
  const i = shallowReadArray(e)
  let r = n
  return (
    i !== e &&
      (isShallow(e)
        ? n.length > 3 &&
          (r = __name(function (t, o, i) {
            return n.call(this, t, o, i, e)
          }, 'wrappedFn'))
        : (r = __name(function (t, o, i) {
            return n.call(this, t, toReactive$1(o), i, e)
          }, 'wrappedFn'))),
    i[t](r, ...o)
  )
}
function searchProxy(e, t, n) {
  const o = toRaw(e)
  track(o, 'iterate', ARRAY_ITERATE_KEY)
  const i = o[t](...n)
  return (-1 !== i && !1 !== i) || !isProxy(n[0])
    ? i
    : ((n[0] = toRaw(n[0])), o[t](...n))
}
function noTracking(e, t, n = []) {
  pauseTracking(), startBatch()
  const o = toRaw(e)[t].apply(e, n)
  return endBatch(), resetTracking(), o
}
__name(apply, 'apply'),
  __name(reduce, 'reduce'),
  __name(searchProxy, 'searchProxy'),
  __name(noTracking, 'noTracking')
const isNonTrackableKeys = makeMap('__proto__,__v_isRef,__isVue'),
  builtInSymbols = new Set(
    Object.getOwnPropertyNames(Symbol)
      .filter((e) => 'arguments' !== e && 'caller' !== e)
      .map((e) => Symbol[e])
      .filter(isSymbol)
  )
function hasOwnProperty$1(e) {
  isSymbol(e) || (e = String(e))
  const t = toRaw(this)
  return track(t, 'has', e), t.hasOwnProperty(e)
}
__name(hasOwnProperty$1, 'hasOwnProperty$1')
class BaseReactiveHandler {
  static {
    __name(this, 'BaseReactiveHandler')
  }
  constructor(e = !1, t = !1) {
    ;(this._isReadonly = e), (this._isShallow = t)
  }
  get(e, t, n) {
    if ('__v_skip' === t) return e.__v_skip
    const o = this._isReadonly,
      i = this._isShallow
    if ('__v_isReactive' === t) return !o
    if ('__v_isReadonly' === t) return o
    if ('__v_isShallow' === t) return i
    if ('__v_raw' === t)
      return n ===
        (o
          ? i
            ? shallowReadonlyMap
            : readonlyMap
          : i
            ? shallowReactiveMap
            : reactiveMap
        ).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n)
        ? e
        : void 0
    const r = isArray$3(e)
    if (!o) {
      let e
      if (r && (e = arrayInstrumentations[t])) return e
      if ('hasOwnProperty' === t) return hasOwnProperty$1
    }
    const a = Reflect.get(e, t, isRef(e) ? e : n)
    return (isSymbol(t) ? builtInSymbols.has(t) : isNonTrackableKeys(t))
      ? a
      : (o || track(e, 'get', t),
        i
          ? a
          : isRef(a)
            ? r && isIntegerKey(t)
              ? a
              : a.value
            : isObject$4(a)
              ? o
                ? readonly(a)
                : reactive(a)
              : a)
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  static {
    __name(this, 'MutableReactiveHandler')
  }
  constructor(e = !1) {
    super(!1, e)
  }
  set(e, t, n, o) {
    let i = e[t]
    if (!this._isShallow) {
      const t = isReadonly(i)
      if (
        (isShallow(n) || isReadonly(n) || ((i = toRaw(i)), (n = toRaw(n))),
        !isArray$3(e) && isRef(i) && !isRef(n))
      )
        return !t && ((i.value = n), !0)
    }
    const r =
        isArray$3(e) && isIntegerKey(t) ? Number(t) < e.length : hasOwn$2(e, t),
      a = Reflect.set(e, t, n, isRef(e) ? e : o)
    return (
      e === toRaw(o) &&
        (r
          ? hasChanged(n, i) && trigger(e, 'set', t, n, i)
          : trigger(e, 'add', t, n)),
      a
    )
  }
  deleteProperty(e, t) {
    const n = hasOwn$2(e, t),
      o = e[t],
      i = Reflect.deleteProperty(e, t)
    return i && n && trigger(e, 'delete', t, void 0, o), i
  }
  has(e, t) {
    const n = Reflect.has(e, t)
    return (isSymbol(t) && builtInSymbols.has(t)) || track(e, 'has', t), n
  }
  ownKeys(e) {
    return (
      track(e, 'iterate', isArray$3(e) ? 'length' : ITERATE_KEY),
      Reflect.ownKeys(e)
    )
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  static {
    __name(this, 'ReadonlyReactiveHandler')
  }
  constructor(e = !1) {
    super(!0, e)
  }
  set(e, t) {
    return !0
  }
  deleteProperty(e, t) {
    return !0
  }
}
const mutableHandlers = new MutableReactiveHandler(),
  readonlyHandlers = new ReadonlyReactiveHandler(),
  shallowReactiveHandlers = new MutableReactiveHandler(!0),
  shallowReadonlyHandlers = new ReadonlyReactiveHandler(!0),
  toShallow = __name((e) => e, 'toShallow'),
  getProto = __name((e) => Reflect.getPrototypeOf(e), 'getProto')
function createIterableMethod(e, t, n) {
  return function (...o) {
    const i = this.__v_raw,
      r = toRaw(i),
      a = isMap(r),
      s = 'entries' === e || (e === Symbol.iterator && a),
      l = 'keys' === e && a,
      c = i[e](...o),
      d = n ? toShallow : t ? toReadonly : toReactive$1
    return (
      !t && track(r, 'iterate', l ? MAP_KEY_ITERATE_KEY : ITERATE_KEY),
      {
        next() {
          const { value: e, done: t } = c.next()
          return t
            ? { value: e, done: t }
            : { value: s ? [d(e[0]), d(e[1])] : d(e), done: t }
        },
        [Symbol.iterator]() {
          return this
        }
      }
    )
  }
}
function createReadonlyMethod(e) {
  return function (...t) {
    return 'delete' !== e && ('clear' === e ? void 0 : this)
  }
}
function createInstrumentations(e, t) {
  const n = {
    get(n) {
      const o = this.__v_raw,
        i = toRaw(o),
        r = toRaw(n)
      e || (hasChanged(n, r) && track(i, 'get', n), track(i, 'get', r))
      const { has: a } = getProto(i),
        s = t ? toShallow : e ? toReadonly : toReactive$1
      return a.call(i, n)
        ? s(o.get(n))
        : a.call(i, r)
          ? s(o.get(r))
          : void (o !== i && o.get(n))
    },
    get size() {
      const t = this.__v_raw
      return (
        !e && track(toRaw(t), 'iterate', ITERATE_KEY), Reflect.get(t, 'size', t)
      )
    },
    has(t) {
      const n = this.__v_raw,
        o = toRaw(n),
        i = toRaw(t)
      return (
        e || (hasChanged(t, i) && track(o, 'has', t), track(o, 'has', i)),
        t === i ? n.has(t) : n.has(t) || n.has(i)
      )
    },
    forEach(n, o) {
      const i = this,
        r = i.__v_raw,
        a = toRaw(r),
        s = t ? toShallow : e ? toReadonly : toReactive$1
      return (
        !e && track(a, 'iterate', ITERATE_KEY),
        r.forEach((e, t) => n.call(o, s(e), s(t), i))
      )
    }
  }
  extend$1(
    n,
    e
      ? {
          add: createReadonlyMethod('add'),
          set: createReadonlyMethod('set'),
          delete: createReadonlyMethod('delete'),
          clear: createReadonlyMethod('clear')
        }
      : {
          add(e) {
            t || isShallow(e) || isReadonly(e) || (e = toRaw(e))
            const n = toRaw(this)
            return (
              getProto(n).has.call(n, e) || (n.add(e), trigger(n, 'add', e, e)),
              this
            )
          },
          set(e, n) {
            t || isShallow(n) || isReadonly(n) || (n = toRaw(n))
            const o = toRaw(this),
              { has: i, get: r } = getProto(o)
            let a = i.call(o, e)
            a || ((e = toRaw(e)), (a = i.call(o, e)))
            const s = r.call(o, e)
            return (
              o.set(e, n),
              a
                ? hasChanged(n, s) && trigger(o, 'set', e, n, s)
                : trigger(o, 'add', e, n),
              this
            )
          },
          delete(e) {
            const t = toRaw(this),
              { has: n, get: o } = getProto(t)
            let i = n.call(t, e)
            i || ((e = toRaw(e)), (i = n.call(t, e)))
            const r = o ? o.call(t, e) : void 0,
              a = t.delete(e)
            return i && trigger(t, 'delete', e, void 0, r), a
          },
          clear() {
            const e = toRaw(this),
              t = 0 !== e.size,
              n = e.clear()
            return t && trigger(e, 'clear', void 0, void 0, undefined), n
          }
        }
  )
  return (
    ['keys', 'values', 'entries', Symbol.iterator].forEach((o) => {
      n[o] = createIterableMethod(o, e, t)
    }),
    n
  )
}
function createInstrumentationGetter(e, t) {
  const n = createInstrumentations(e, t)
  return (t, o, i) =>
    '__v_isReactive' === o
      ? !e
      : '__v_isReadonly' === o
        ? e
        : '__v_raw' === o
          ? t
          : Reflect.get(hasOwn$2(n, o) && o in t ? n : t, o, i)
}
__name(createIterableMethod, 'createIterableMethod'),
  __name(createReadonlyMethod, 'createReadonlyMethod'),
  __name(createInstrumentations, 'createInstrumentations'),
  __name(createInstrumentationGetter, 'createInstrumentationGetter')
const mutableCollectionHandlers = { get: createInstrumentationGetter(!1, !1) },
  shallowCollectionHandlers = { get: createInstrumentationGetter(!1, !0) },
  readonlyCollectionHandlers = { get: createInstrumentationGetter(!0, !1) },
  shallowReadonlyCollectionHandlers = {
    get: createInstrumentationGetter(!0, !0)
  }
function checkIdentityKeys(e, t, n) {
  const o = toRaw(n)
  if (o !== n && t.call(e, o)) {
    const t = toRawType(e)
    warn$2(
      `Reactive ${t} contains both the raw and reactive versions of the same object${'Map' === t ? ' as keys' : ''}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    )
  }
}
__name(checkIdentityKeys, 'checkIdentityKeys')
const reactiveMap = new WeakMap(),
  shallowReactiveMap = new WeakMap(),
  readonlyMap = new WeakMap(),
  shallowReadonlyMap = new WeakMap()
function targetTypeMap(e) {
  switch (e) {
    case 'Object':
    case 'Array':
      return 1
    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2
    default:
      return 0
  }
}
function getTargetType(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : targetTypeMap(toRawType(e))
}
function reactive(e) {
  return isReadonly(e)
    ? e
    : createReactiveObject(
        e,
        !1,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      )
}
function shallowReactive(e) {
  return createReactiveObject(
    e,
    !1,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  )
}
function readonly(e) {
  return createReactiveObject(
    e,
    !0,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  )
}
function shallowReadonly(e) {
  return createReactiveObject(
    e,
    !0,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  )
}
function createReactiveObject(e, t, n, o, i) {
  if (!isObject$4(e)) return e
  if (e.__v_raw && (!t || !e.__v_isReactive)) return e
  const r = i.get(e)
  if (r) return r
  const a = getTargetType(e)
  if (0 === a) return e
  const s = new Proxy(e, 2 === a ? o : n)
  return i.set(e, s), s
}
function isReactive(e) {
  return isReadonly(e) ? isReactive(e.__v_raw) : !(!e || !e.__v_isReactive)
}
function isReadonly(e) {
  return !(!e || !e.__v_isReadonly)
}
function isShallow(e) {
  return !(!e || !e.__v_isShallow)
}
function isProxy(e) {
  return !!e && !!e.__v_raw
}
function toRaw(e) {
  const t = e && e.__v_raw
  return t ? toRaw(t) : e
}
function markRaw(e) {
  return (
    !hasOwn$2(e, '__v_skip') &&
      Object.isExtensible(e) &&
      def(e, '__v_skip', !0),
    e
  )
}
__name(targetTypeMap, 'targetTypeMap'),
  __name(getTargetType, 'getTargetType'),
  __name(reactive, 'reactive'),
  __name(shallowReactive, 'shallowReactive'),
  __name(readonly, 'readonly'),
  __name(shallowReadonly, 'shallowReadonly'),
  __name(createReactiveObject, 'createReactiveObject'),
  __name(isReactive, 'isReactive'),
  __name(isReadonly, 'isReadonly'),
  __name(isShallow, 'isShallow'),
  __name(isProxy, 'isProxy'),
  __name(toRaw, 'toRaw'),
  __name(markRaw, 'markRaw')
const toReactive$1 = __name(
    (e) => (isObject$4(e) ? reactive(e) : e),
    'toReactive$1'
  ),
  toReadonly = __name((e) => (isObject$4(e) ? readonly(e) : e), 'toReadonly')
function isRef(e) {
  return !!e && !0 === e.__v_isRef
}
function ref(e) {
  return createRef(e, !1)
}
function shallowRef(e) {
  return createRef(e, !0)
}
function createRef(e, t) {
  return isRef(e) ? e : new RefImpl(e, t)
}
__name(isRef, 'isRef'),
  __name(ref, 'ref'),
  __name(shallowRef, 'shallowRef'),
  __name(createRef, 'createRef')
class RefImpl {
  static {
    __name(this, 'RefImpl')
  }
  constructor(e, t) {
    ;(this.dep = new Dep()),
      (this.__v_isRef = !0),
      (this.__v_isShallow = !1),
      (this._rawValue = t ? e : toRaw(e)),
      (this._value = t ? e : toReactive$1(e)),
      (this.__v_isShallow = t)
  }
  get value() {
    return this.dep.track(), this._value
  }
  set value(e) {
    const t = this._rawValue,
      n = this.__v_isShallow || isShallow(e) || isReadonly(e)
    ;(e = n ? e : toRaw(e)),
      hasChanged(e, t) &&
        ((this._rawValue = e),
        (this._value = n ? e : toReactive$1(e)),
        this.dep.trigger())
  }
}
function triggerRef(e) {
  e.dep && e.dep.trigger()
}
function unref(e) {
  return isRef(e) ? e.value : e
}
function toValue$3(e) {
  return isFunction$3(e) ? e() : unref(e)
}
__name(triggerRef, 'triggerRef'),
  __name(unref, 'unref'),
  __name(toValue$3, 'toValue$3')
const shallowUnwrapHandlers = {
  get: __name(
    (e, t, n) => ('__v_raw' === t ? e : unref(Reflect.get(e, t, n))),
    'get'
  ),
  set: __name((e, t, n, o) => {
    const i = e[t]
    return isRef(i) && !isRef(n) ? ((i.value = n), !0) : Reflect.set(e, t, n, o)
  }, 'set')
}
function proxyRefs(e) {
  return isReactive(e) ? e : new Proxy(e, shallowUnwrapHandlers)
}
__name(proxyRefs, 'proxyRefs')
class CustomRefImpl {
  static {
    __name(this, 'CustomRefImpl')
  }
  constructor(e) {
    ;(this.__v_isRef = !0), (this._value = void 0)
    const t = (this.dep = new Dep()),
      { get: n, set: o } = e(t.track.bind(t), t.trigger.bind(t))
    ;(this._get = n), (this._set = o)
  }
  get value() {
    return (this._value = this._get())
  }
  set value(e) {
    this._set(e)
  }
}
function customRef(e) {
  return new CustomRefImpl(e)
}
function toRefs$1(e) {
  const t = isArray$3(e) ? new Array(e.length) : {}
  for (const n in e) t[n] = propertyToRef(e, n)
  return t
}
__name(customRef, 'customRef'), __name(toRefs$1, 'toRefs$1')
class ObjectRefImpl {
  static {
    __name(this, 'ObjectRefImpl')
  }
  constructor(e, t, n) {
    ;(this._object = e),
      (this._key = t),
      (this._defaultValue = n),
      (this.__v_isRef = !0),
      (this._value = void 0)
  }
  get value() {
    const e = this._object[this._key]
    return (this._value = void 0 === e ? this._defaultValue : e)
  }
  set value(e) {
    this._object[this._key] = e
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key)
  }
}
class GetterRefImpl {
  static {
    __name(this, 'GetterRefImpl')
  }
  constructor(e) {
    ;(this._getter = e),
      (this.__v_isRef = !0),
      (this.__v_isReadonly = !0),
      (this._value = void 0)
  }
  get value() {
    return (this._value = this._getter())
  }
}
function toRef$1(e, t, n) {
  return isRef(e)
    ? e
    : isFunction$3(e)
      ? new GetterRefImpl(e)
      : isObject$4(e) && arguments.length > 1
        ? propertyToRef(e, t, n)
        : ref(e)
}
function propertyToRef(e, t, n) {
  const o = e[t]
  return isRef(o) ? o : new ObjectRefImpl(e, t, n)
}
__name(toRef$1, 'toRef$1'), __name(propertyToRef, 'propertyToRef')
class ComputedRefImpl {
  static {
    __name(this, 'ComputedRefImpl')
  }
  constructor(e, t, n) {
    ;(this.fn = e),
      (this.setter = t),
      (this._value = void 0),
      (this.dep = new Dep(this)),
      (this.__v_isRef = !0),
      (this.deps = void 0),
      (this.depsTail = void 0),
      (this.flags = 16),
      (this.globalVersion = globalVersion - 1),
      (this.next = void 0),
      (this.effect = this),
      (this.__v_isReadonly = !t),
      (this.isSSR = n)
  }
  notify() {
    if (((this.flags |= 16), !(8 & this.flags || activeSub === this)))
      return batch(this, !0), !0
  }
  get value() {
    const e = this.dep.track()
    return (
      refreshComputed(this), e && (e.version = this.dep.version), this._value
    )
  }
  set value(e) {
    this.setter && this.setter(e)
  }
}
function computed$1(e, t, n = !1) {
  let o, i
  isFunction$3(e) ? (o = e) : ((o = e.get), (i = e.set))
  const r = new ComputedRefImpl(o, i, n)
  return r
}
__name(computed$1, 'computed$1')
const TrackOpTypes = { GET: 'get', HAS: 'has', ITERATE: 'iterate' },
  TriggerOpTypes = { SET: 'set', ADD: 'add', DELETE: 'delete', CLEAR: 'clear' },
  ReactiveFlags = {
    SKIP: '__v_skip',
    IS_REACTIVE: '__v_isReactive',
    IS_READONLY: '__v_isReadonly',
    IS_SHALLOW: '__v_isShallow',
    RAW: '__v_raw',
    IS_REF: '__v_isRef'
  },
  WatchErrorCodes = {
    WATCH_GETTER: 2,
    2: 'WATCH_GETTER',
    WATCH_CALLBACK: 3,
    3: 'WATCH_CALLBACK',
    WATCH_CLEANUP: 4,
    4: 'WATCH_CLEANUP'
  },
  INITIAL_WATCHER_VALUE = {},
  cleanupMap = new WeakMap()
let activeWatcher
function getCurrentWatcher() {
  return activeWatcher
}
function onWatcherCleanup(e, t = !1, n = activeWatcher) {
  if (n) {
    let t = cleanupMap.get(n)
    t || cleanupMap.set(n, (t = [])), t.push(e)
  } else 0
}
function watch$1(e, t, n = EMPTY_OBJ) {
  const {
      immediate: o,
      deep: i,
      once: r,
      scheduler: a,
      augmentJob: s,
      call: l
    } = n,
    c = __name(
      (e) =>
        i
          ? e
          : isShallow(e) || !1 === i || 0 === i
            ? traverse(e, 1)
            : traverse(e),
      'reactiveGetter'
    )
  let d,
    u,
    p,
    h,
    m = !1,
    f = !1
  if (
    (isRef(e)
      ? ((u = __name(() => e.value, 'getter')), (m = isShallow(e)))
      : isReactive(e)
        ? ((u = __name(() => c(e), 'getter')), (m = !0))
        : isArray$3(e)
          ? ((f = !0),
            (m = e.some((e) => isReactive(e) || isShallow(e))),
            (u = __name(
              () =>
                e.map((e) =>
                  isRef(e)
                    ? e.value
                    : isReactive(e)
                      ? c(e)
                      : isFunction$3(e)
                        ? l
                          ? l(e, 2)
                          : e()
                        : void 0
                ),
              'getter'
            )))
          : (u = isFunction$3(e)
              ? t
                ? l
                  ? () => l(e, 2)
                  : e
                : __name(() => {
                    if (p) {
                      pauseTracking()
                      try {
                        p()
                      } finally {
                        resetTracking()
                      }
                    }
                    const t = activeWatcher
                    activeWatcher = d
                    try {
                      return l ? l(e, 3, [h]) : e(h)
                    } finally {
                      activeWatcher = t
                    }
                  }, 'getter')
              : NOOP),
    t && i)
  ) {
    const e = u,
      t = !0 === i ? 1 / 0 : i
    u = __name(() => traverse(e(), t), 'getter')
  }
  const _ = getCurrentScope(),
    g = __name(() => {
      d.stop(), _ && _.active && remove$1(_.effects, d)
    }, 'watchHandle')
  if (r && t) {
    const e = t
    t = __name((...t) => {
      e(...t), g()
    }, 'cb')
  }
  let v = f
    ? new Array(e.length).fill(INITIAL_WATCHER_VALUE)
    : INITIAL_WATCHER_VALUE
  const y = __name((e) => {
    if (1 & d.flags && (d.dirty || e))
      if (t) {
        const e = d.run()
        if (
          i ||
          m ||
          (f ? e.some((e, t) => hasChanged(e, v[t])) : hasChanged(e, v))
        ) {
          p && p()
          const n = activeWatcher
          activeWatcher = d
          try {
            const n = [
              e,
              v === INITIAL_WATCHER_VALUE
                ? void 0
                : f && v[0] === INITIAL_WATCHER_VALUE
                  ? []
                  : v,
              h
            ]
            l ? l(t, 3, n) : t(...n), (v = e)
          } finally {
            activeWatcher = n
          }
        }
      } else d.run()
  }, 'job')
  return (
    s && s(y),
    (d = new ReactiveEffect(u)),
    (d.scheduler = a ? () => a(y, !1) : y),
    (h = __name((e) => onWatcherCleanup(e, !1, d), 'boundCleanup')),
    (p = d.onStop =
      () => {
        const e = cleanupMap.get(d)
        if (e) {
          if (l) l(e, 4)
          else for (const t of e) t()
          cleanupMap.delete(d)
        }
      }),
    t ? (o ? y(!0) : (v = d.run())) : a ? a(y.bind(null, !0), !0) : d.run(),
    (g.pause = d.pause.bind(d)),
    (g.resume = d.resume.bind(d)),
    (g.stop = g),
    g
  )
}
function traverse(e, t = 1 / 0, n) {
  if (t <= 0 || !isObject$4(e) || e.__v_skip) return e
  if ((n = n || new Set()).has(e)) return e
  if ((n.add(e), t--, isRef(e))) traverse(e.value, t, n)
  else if (isArray$3(e)) for (let o = 0; o < e.length; o++) traverse(e[o], t, n)
  else if (isSet(e) || isMap(e))
    e.forEach((e) => {
      traverse(e, t, n)
    })
  else if (isPlainObject$2(e)) {
    for (const o in e) traverse(e[o], t, n)
    for (const o of Object.getOwnPropertySymbols(e))
      Object.prototype.propertyIsEnumerable.call(e, o) && traverse(e[o], t, n)
  }
  return e
}
__name(getCurrentWatcher, 'getCurrentWatcher'),
  __name(onWatcherCleanup, 'onWatcherCleanup'),
  __name(watch$1, 'watch$1'),
  __name(traverse, 'traverse')
/**
 * @vue/runtime-core v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const stack = []
function pushWarningContext(e) {
  stack.push(e)
}
function popWarningContext() {
  stack.pop()
}
__name(pushWarningContext, 'pushWarningContext'),
  __name(popWarningContext, 'popWarningContext')
let isWarning = !1
function warn$1(e, ...t) {
  if (isWarning) return
  ;(isWarning = !0), pauseTracking()
  const n = stack.length ? stack[stack.length - 1].component : null,
    o = n && n.appContext.config.warnHandler,
    i = getComponentTrace()
  if (o)
    callWithErrorHandling(o, n, 11, [
      e +
        t
          .map((e) => {
            var t, n
            return null != (n = null == (t = e.toString) ? void 0 : t.call(e))
              ? n
              : JSON.stringify(e)
          })
          .join(''),
      n && n.proxy,
      i
        .map(({ vnode: e }) => `at <${formatComponentName(n, e.type)}>`)
        .join('\n'),
      i
    ])
  else {
    const n = [`[Vue warn]: ${e}`, ...t]
    i.length && n.push('\n', ...formatTrace(i)), console.warn(...n)
  }
  resetTracking(), (isWarning = !1)
}
function getComponentTrace() {
  let e = stack[stack.length - 1]
  if (!e) return []
  const t = []
  for (; e; ) {
    const n = t[0]
    n && n.vnode === e
      ? n.recurseCount++
      : t.push({ vnode: e, recurseCount: 0 })
    const o = e.component && e.component.parent
    e = o && o.vnode
  }
  return t
}
function formatTrace(e) {
  const t = []
  return (
    e.forEach((e, n) => {
      t.push(...(0 === n ? [] : ['\n']), ...formatTraceEntry(e))
    }),
    t
  )
}
function formatTraceEntry({ vnode: e, recurseCount: t }) {
  const n = t > 0 ? `... (${t} recursive calls)` : '',
    o = !!e.component && null == e.component.parent,
    i = ` at <${formatComponentName(e.component, e.type, o)}`,
    r = '>' + n
  return e.props ? [i, ...formatProps(e.props), r] : [i + r]
}
function formatProps(e) {
  const t = [],
    n = Object.keys(e)
  return (
    n.slice(0, 3).forEach((n) => {
      t.push(...formatProp(n, e[n]))
    }),
    n.length > 3 && t.push(' ...'),
    t
  )
}
function formatProp(e, t, n) {
  return isString$3(t)
    ? ((t = JSON.stringify(t)), n ? t : [`${e}=${t}`])
    : 'number' == typeof t || 'boolean' == typeof t || null == t
      ? n
        ? t
        : [`${e}=${t}`]
      : isRef(t)
        ? ((t = formatProp(e, toRaw(t.value), !0)),
          n ? t : [`${e}=Ref<`, t, '>'])
        : isFunction$3(t)
          ? [`${e}=fn${t.name ? `<${t.name}>` : ''}`]
          : ((t = toRaw(t)), n ? t : [`${e}=`, t])
}
function assertNumber(e, t) {}
__name(warn$1, 'warn$1'),
  __name(getComponentTrace, 'getComponentTrace'),
  __name(formatTrace, 'formatTrace'),
  __name(formatTraceEntry, 'formatTraceEntry'),
  __name(formatProps, 'formatProps'),
  __name(formatProp, 'formatProp'),
  __name(assertNumber, 'assertNumber')
const ErrorCodes = {
    SETUP_FUNCTION: 0,
    0: 'SETUP_FUNCTION',
    RENDER_FUNCTION: 1,
    1: 'RENDER_FUNCTION',
    NATIVE_EVENT_HANDLER: 5,
    5: 'NATIVE_EVENT_HANDLER',
    COMPONENT_EVENT_HANDLER: 6,
    6: 'COMPONENT_EVENT_HANDLER',
    VNODE_HOOK: 7,
    7: 'VNODE_HOOK',
    DIRECTIVE_HOOK: 8,
    8: 'DIRECTIVE_HOOK',
    TRANSITION_HOOK: 9,
    9: 'TRANSITION_HOOK',
    APP_ERROR_HANDLER: 10,
    10: 'APP_ERROR_HANDLER',
    APP_WARN_HANDLER: 11,
    11: 'APP_WARN_HANDLER',
    FUNCTION_REF: 12,
    12: 'FUNCTION_REF',
    ASYNC_COMPONENT_LOADER: 13,
    13: 'ASYNC_COMPONENT_LOADER',
    SCHEDULER: 14,
    14: 'SCHEDULER',
    COMPONENT_UPDATE: 15,
    15: 'COMPONENT_UPDATE',
    APP_UNMOUNT_CLEANUP: 16,
    16: 'APP_UNMOUNT_CLEANUP'
  },
  ErrorTypeStrings$1 = {
    sp: 'serverPrefetch hook',
    bc: 'beforeCreate hook',
    c: 'created hook',
    bm: 'beforeMount hook',
    m: 'mounted hook',
    bu: 'beforeUpdate hook',
    u: 'updated',
    bum: 'beforeUnmount hook',
    um: 'unmounted hook',
    a: 'activated hook',
    da: 'deactivated hook',
    ec: 'errorCaptured hook',
    rtc: 'renderTracked hook',
    rtg: 'renderTriggered hook',
    0: 'setup function',
    1: 'render function',
    2: 'watcher getter',
    3: 'watcher callback',
    4: 'watcher cleanup function',
    5: 'native event handler',
    6: 'component event handler',
    7: 'vnode hook',
    8: 'directive hook',
    9: 'transition hook',
    10: 'app errorHandler',
    11: 'app warnHandler',
    12: 'ref function',
    13: 'async component loader',
    14: 'scheduler flush',
    15: 'component update',
    16: 'app unmount cleanup function'
  }
function callWithErrorHandling(e, t, n, o) {
  try {
    return o ? e(...o) : e()
  } catch (i) {
    handleError(i, t, n)
  }
}
function callWithAsyncErrorHandling(e, t, n, o) {
  if (isFunction$3(e)) {
    const i = callWithErrorHandling(e, t, n, o)
    return (
      i &&
        isPromise(i) &&
        i.catch((e) => {
          handleError(e, t, n)
        }),
      i
    )
  }
  if (isArray$3(e)) {
    const i = []
    for (let r = 0; r < e.length; r++)
      i.push(callWithAsyncErrorHandling(e[r], t, n, o))
    return i
  }
}
function handleError(e, t, n, o = !0) {
  const i = t ? t.vnode : null,
    { errorHandler: r, throwUnhandledErrorInProduction: a } =
      (t && t.appContext.config) || EMPTY_OBJ
  if (t) {
    let o = t.parent
    const i = t.proxy,
      a = `https://vuejs.org/error-reference/#runtime-${n}`
    for (; o; ) {
      const t = o.ec
      if (t) for (let n = 0; n < t.length; n++) if (!1 === t[n](e, i, a)) return
      o = o.parent
    }
    if (r)
      return (
        pauseTracking(),
        callWithErrorHandling(r, null, 10, [e, i, a]),
        void resetTracking()
      )
  }
  logError(e, n, i, o, a)
}
function logError(e, t, n, o = !0, i = !1) {
  if (i) throw e
  console.error(e)
}
__name(callWithErrorHandling, 'callWithErrorHandling'),
  __name(callWithAsyncErrorHandling, 'callWithAsyncErrorHandling'),
  __name(handleError, 'handleError'),
  __name(logError, 'logError')
const queue = []
let flushIndex = -1
const pendingPostFlushCbs = []
let activePostFlushCbs = null,
  postFlushIndex = 0
const resolvedPromise = Promise.resolve()
let currentFlushPromise = null
const RECURSION_LIMIT = 100
function nextTick(e) {
  const t = currentFlushPromise || resolvedPromise
  return e ? t.then(this ? e.bind(this) : e) : t
}
function findInsertionIndex(e) {
  let t = flushIndex + 1,
    n = queue.length
  for (; t < n; ) {
    const o = (t + n) >>> 1,
      i = queue[o],
      r = getId(i)
    r < e || (r === e && 2 & i.flags) ? (t = o + 1) : (n = o)
  }
  return t
}
function queueJob(e) {
  if (!(1 & e.flags)) {
    const t = getId(e),
      n = queue[queue.length - 1]
    !n || (!(2 & e.flags) && t >= getId(n))
      ? queue.push(e)
      : queue.splice(findInsertionIndex(t), 0, e),
      (e.flags |= 1),
      queueFlush()
  }
}
function queueFlush() {
  currentFlushPromise || (currentFlushPromise = resolvedPromise.then(flushJobs))
}
function queuePostFlushCb(e) {
  isArray$3(e)
    ? pendingPostFlushCbs.push(...e)
    : activePostFlushCbs && -1 === e.id
      ? activePostFlushCbs.splice(postFlushIndex + 1, 0, e)
      : 1 & e.flags || (pendingPostFlushCbs.push(e), (e.flags |= 1)),
    queueFlush()
}
function flushPreFlushCbs(e, t, n = flushIndex + 1) {
  for (0; n < queue.length; n++) {
    const t = queue[n]
    if (t && 2 & t.flags) {
      if (e && t.id !== e.uid) continue
      0,
        queue.splice(n, 1),
        n--,
        4 & t.flags && (t.flags &= -2),
        t(),
        4 & t.flags || (t.flags &= -2)
    }
  }
}
function flushPostFlushCbs(e) {
  if (pendingPostFlushCbs.length) {
    const e = [...new Set(pendingPostFlushCbs)].sort(
      (e, t) => getId(e) - getId(t)
    )
    if (((pendingPostFlushCbs.length = 0), activePostFlushCbs))
      return void activePostFlushCbs.push(...e)
    for (
      activePostFlushCbs = e, postFlushIndex = 0;
      postFlushIndex < activePostFlushCbs.length;
      postFlushIndex++
    ) {
      const e = activePostFlushCbs[postFlushIndex]
      0, 4 & e.flags && (e.flags &= -2), 8 & e.flags || e(), (e.flags &= -2)
    }
    ;(activePostFlushCbs = null), (postFlushIndex = 0)
  }
}
__name(nextTick, 'nextTick'),
  __name(findInsertionIndex, 'findInsertionIndex'),
  __name(queueJob, 'queueJob'),
  __name(queueFlush, 'queueFlush'),
  __name(queuePostFlushCb, 'queuePostFlushCb'),
  __name(flushPreFlushCbs, 'flushPreFlushCbs'),
  __name(flushPostFlushCbs, 'flushPostFlushCbs')
const getId = __name(
  (e) => (null == e.id ? (2 & e.flags ? -1 : 1 / 0) : e.id),
  'getId'
)
function flushJobs(e) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const e = queue[flushIndex]
      !e ||
        8 & e.flags ||
        (4 & e.flags && (e.flags &= -2),
        callWithErrorHandling(e, e.i, e.i ? 15 : 14),
        4 & e.flags || (e.flags &= -2))
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const e = queue[flushIndex]
      e && (e.flags &= -2)
    }
    ;(flushIndex = -1),
      (queue.length = 0),
      flushPostFlushCbs(e),
      (currentFlushPromise = null),
      (queue.length || pendingPostFlushCbs.length) && flushJobs(e)
  }
}
function checkRecursiveUpdates(e, t) {
  const n = e.get(t) || 0
  if (n > RECURSION_LIMIT) {
    const e = t.i,
      n = e && getComponentName(e.type)
    return (
      handleError(
        `Maximum recursive updates exceeded${n ? ` in component <${n}>` : ''}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      ),
      !0
    )
  }
  return e.set(t, n + 1), !1
}
__name(flushJobs, 'flushJobs'),
  __name(checkRecursiveUpdates, 'checkRecursiveUpdates')
let isHmrUpdating = !1
const hmrDirtyComponents = new Map()
const map = new Map()
function registerHMR(e) {
  const t = e.type.__hmrId
  let n = map.get(t)
  n || (createRecord(t, e.type), (n = map.get(t))), n.instances.add(e)
}
function unregisterHMR(e) {
  map.get(e.type.__hmrId).instances.delete(e)
}
function createRecord(e, t) {
  return (
    !map.has(e) &&
    (map.set(e, {
      initialDef: normalizeClassComponent(t),
      instances: new Set()
    }),
    !0)
  )
}
function normalizeClassComponent(e) {
  return isClassComponent(e) ? e.__vccOpts : e
}
function rerender(e, t) {
  const n = map.get(e)
  n &&
    ((n.initialDef.render = t),
    [...n.instances].forEach((e) => {
      t && ((e.render = t), (normalizeClassComponent(e.type).render = t)),
        (e.renderCache = []),
        (isHmrUpdating = !0),
        e.update(),
        (isHmrUpdating = !1)
    }))
}
function reload(e, t) {
  const n = map.get(e)
  if (!n) return
  ;(t = normalizeClassComponent(t)), updateComponentDef(n.initialDef, t)
  const o = [...n.instances]
  for (let i = 0; i < o.length; i++) {
    const e = o[i],
      r = normalizeClassComponent(e.type)
    let a = hmrDirtyComponents.get(r)
    a ||
      (r !== n.initialDef && updateComponentDef(r, t),
      hmrDirtyComponents.set(r, (a = new Set()))),
      a.add(e),
      e.appContext.propsCache.delete(e.type),
      e.appContext.emitsCache.delete(e.type),
      e.appContext.optionsCache.delete(e.type),
      e.ceReload
        ? (a.add(e), e.ceReload(t.styles), a.delete(e))
        : e.parent
          ? queueJob(() => {
              ;(isHmrUpdating = !0),
                e.parent.update(),
                (isHmrUpdating = !1),
                a.delete(e)
            })
          : e.appContext.reload
            ? e.appContext.reload()
            : 'undefined' != typeof window
              ? window.location.reload()
              : console.warn(
                  '[HMR] Root or manually mounted instance modified. Full reload required.'
                ),
      e.root.ce && e !== e.root && e.root.ce._removeChildStyle(r)
  }
  queuePostFlushCb(() => {
    hmrDirtyComponents.clear()
  })
}
function updateComponentDef(e, t) {
  extend$1(e, t)
  for (const n in e) '__file' === n || n in t || delete e[n]
}
function tryWrap(e) {
  return (t, n) => {
    try {
      return e(t, n)
    } catch (o) {
      console.error(o),
        console.warn(
          '[HMR] Something went wrong during Vue component hot-reload. Full reload required.'
        )
    }
  }
}
let devtools$1
__name(registerHMR, 'registerHMR'),
  __name(unregisterHMR, 'unregisterHMR'),
  __name(createRecord, 'createRecord'),
  __name(normalizeClassComponent, 'normalizeClassComponent'),
  __name(rerender, 'rerender'),
  __name(reload, 'reload'),
  __name(updateComponentDef, 'updateComponentDef'),
  __name(tryWrap, 'tryWrap')
let buffer = [],
  devtoolsNotInstalled = !1
function emit$1(e, ...t) {
  devtools$1
    ? devtools$1.emit(e, ...t)
    : devtoolsNotInstalled || buffer.push({ event: e, args: t })
}
function setDevtoolsHook$1(e, t) {
  var n, o
  if (((devtools$1 = e), devtools$1))
    (devtools$1.enabled = !0),
      buffer.forEach(({ event: e, args: t }) => devtools$1.emit(e, ...t)),
      (buffer = [])
  else if (
    'undefined' != typeof window &&
    window.HTMLElement &&
    !(null == (o = null == (n = window.navigator) ? void 0 : n.userAgent)
      ? void 0
      : o.includes('jsdom'))
  ) {
    ;(t.__VUE_DEVTOOLS_HOOK_REPLAY__ =
      t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((e) => {
      setDevtoolsHook$1(e, t)
    }),
      setTimeout(() => {
        devtools$1 ||
          ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null),
          (devtoolsNotInstalled = !0),
          (buffer = []))
      }, 3e3)
  } else (devtoolsNotInstalled = !0), (buffer = [])
}
function devtoolsInitApp(e, t) {
  emit$1('app:init', e, t, {
    Fragment: Fragment,
    Text: Text$1,
    Comment: Comment,
    Static: Static
  })
}
function devtoolsUnmountApp(e) {
  emit$1('app:unmount', e)
}
__name(emit$1, 'emit$1'),
  __name(setDevtoolsHook$1, 'setDevtoolsHook$1'),
  __name(devtoolsInitApp, 'devtoolsInitApp'),
  __name(devtoolsUnmountApp, 'devtoolsUnmountApp')
const devtoolsComponentAdded = createDevtoolsComponentHook('component:added'),
  devtoolsComponentUpdated = createDevtoolsComponentHook('component:updated'),
  _devtoolsComponentRemoved = createDevtoolsComponentHook('component:removed'),
  devtoolsComponentRemoved = __name((e) => {
    devtools$1 &&
      'function' == typeof devtools$1.cleanupBuffer &&
      !devtools$1.cleanupBuffer(e) &&
      _devtoolsComponentRemoved(e)
  }, 'devtoolsComponentRemoved')
/*! #__NO_SIDE_EFFECTS__ */
function createDevtoolsComponentHook(e) {
  return (t) => {
    emit$1(e, t.appContext.app, t.uid, t.parent ? t.parent.uid : void 0, t)
  }
}
__name(createDevtoolsComponentHook, 'createDevtoolsComponentHook')
const devtoolsPerfStart = createDevtoolsPerformanceHook('perf:start'),
  devtoolsPerfEnd = createDevtoolsPerformanceHook('perf:end')
function createDevtoolsPerformanceHook(e) {
  return (t, n, o) => {
    emit$1(e, t.appContext.app, t.uid, t, n, o)
  }
}
function devtoolsComponentEmit(e, t, n) {
  emit$1('component:emit', e.appContext.app, e, t, n)
}
__name(createDevtoolsPerformanceHook, 'createDevtoolsPerformanceHook'),
  __name(devtoolsComponentEmit, 'devtoolsComponentEmit')
let currentRenderingInstance = null,
  currentScopeId = null
function setCurrentRenderingInstance(e) {
  const t = currentRenderingInstance
  return (
    (currentRenderingInstance = e),
    (currentScopeId = (e && e.type.__scopeId) || null),
    t
  )
}
function pushScopeId(e) {
  currentScopeId = e
}
function popScopeId() {
  currentScopeId = null
}
__name(setCurrentRenderingInstance, 'setCurrentRenderingInstance'),
  __name(pushScopeId, 'pushScopeId'),
  __name(popScopeId, 'popScopeId')
const withScopeId = __name((e) => withCtx, 'withScopeId')
function withCtx(e, t = currentRenderingInstance, n) {
  if (!t) return e
  if (e._n) return e
  const o = __name((...n) => {
    o._d && setBlockTracking(-1)
    const i = setCurrentRenderingInstance(t)
    let r
    try {
      r = e(...n)
    } finally {
      setCurrentRenderingInstance(i), o._d && setBlockTracking(1)
    }
    return r
  }, 'renderFnWithContext')
  return (o._n = !0), (o._c = !0), (o._d = !0), o
}
function validateDirectiveName(e) {
  isBuiltInDirective(e) &&
    warn$1('Do not use built-in directive ids as custom directive id: ' + e)
}
function withDirectives(e, t) {
  if (null === currentRenderingInstance) return e
  const n = getComponentPublicInstance(currentRenderingInstance),
    o = e.dirs || (e.dirs = [])
  for (let i = 0; i < t.length; i++) {
    let [e, r, a, s = EMPTY_OBJ] = t[i]
    e &&
      (isFunction$3(e) && (e = { mounted: e, updated: e }),
      e.deep && traverse(r),
      o.push({
        dir: e,
        instance: n,
        value: r,
        oldValue: void 0,
        arg: a,
        modifiers: s
      }))
  }
  return e
}
function invokeDirectiveHook(e, t, n, o) {
  const i = e.dirs,
    r = t && t.dirs
  for (let a = 0; a < i.length; a++) {
    const s = i[a]
    r && (s.oldValue = r[a].value)
    let l = s.dir[o]
    l &&
      (pauseTracking(),
      callWithAsyncErrorHandling(l, n, 8, [e.el, s, e, t]),
      resetTracking())
  }
}
__name(withCtx, 'withCtx'),
  __name(validateDirectiveName, 'validateDirectiveName'),
  __name(withDirectives, 'withDirectives'),
  __name(invokeDirectiveHook, 'invokeDirectiveHook')
const TeleportEndKey = Symbol('_vte'),
  isTeleport = __name((e) => e.__isTeleport, 'isTeleport'),
  isTeleportDisabled = __name(
    (e) => e && (e.disabled || '' === e.disabled),
    'isTeleportDisabled'
  ),
  isTeleportDeferred = __name(
    (e) => e && (e.defer || '' === e.defer),
    'isTeleportDeferred'
  ),
  isTargetSVG = __name(
    (e) => 'undefined' != typeof SVGElement && e instanceof SVGElement,
    'isTargetSVG'
  ),
  isTargetMathML = __name(
    (e) => 'function' == typeof MathMLElement && e instanceof MathMLElement,
    'isTargetMathML'
  ),
  resolveTarget = __name((e, t) => {
    const n = e && e.to
    if (isString$3(n)) {
      if (t) {
        return t(n)
      }
      return null
    }
    return n
  }, 'resolveTarget'),
  TeleportImpl = {
    name: 'Teleport',
    __isTeleport: !0,
    process(e, t, n, o, i, r, a, s, l, c) {
      const {
          mc: d,
          pc: u,
          pbc: p,
          o: { insert: h, querySelector: m, createText: f, createComment: _ }
        } = c,
        g = isTeleportDisabled(t.props)
      let { shapeFlag: v, children: y, dynamicChildren: b } = t
      if (null == e) {
        const e = (t.el = f('')),
          c = (t.anchor = f(''))
        h(e, n, o), h(c, n, o)
        const u = __name((e, t) => {
            16 & v &&
              (i && i.isCE && (i.ce._teleportTarget = e),
              d(y, e, t, i, r, a, s, l))
          }, 'mount'),
          p = __name(() => {
            const e = (t.target = resolveTarget(t.props, m)),
              n = prepareAnchor(e, t, f, h)
            e &&
              ('svg' !== a && isTargetSVG(e)
                ? (a = 'svg')
                : 'mathml' !== a && isTargetMathML(e) && (a = 'mathml'),
              g || (u(e, n), updateCssVars(t, !1)))
          }, 'mountToTarget')
        g && (u(n, c), updateCssVars(t, !0)),
          isTeleportDeferred(t.props)
            ? queuePostRenderEffect(() => {
                p(), (t.el.__isMounted = !0)
              }, r)
            : p()
      } else {
        if (isTeleportDeferred(t.props) && !e.el.__isMounted)
          return void queuePostRenderEffect(() => {
            TeleportImpl.process(e, t, n, o, i, r, a, s, l, c),
              delete e.el.__isMounted
          }, r)
        ;(t.el = e.el), (t.targetStart = e.targetStart)
        const d = (t.anchor = e.anchor),
          h = (t.target = e.target),
          f = (t.targetAnchor = e.targetAnchor),
          _ = isTeleportDisabled(e.props),
          v = _ ? n : h,
          y = _ ? d : f
        if (
          ('svg' === a || isTargetSVG(h)
            ? (a = 'svg')
            : ('mathml' === a || isTargetMathML(h)) && (a = 'mathml'),
          b
            ? (p(e.dynamicChildren, b, v, i, r, a, s),
              traverseStaticChildren(e, t, !0))
            : l || u(e, t, v, y, i, r, a, s, !1),
          g)
        )
          _
            ? t.props &&
              e.props &&
              t.props.to !== e.props.to &&
              (t.props.to = e.props.to)
            : moveTeleport(t, n, d, c, 1)
        else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
          const e = (t.target = resolveTarget(t.props, m))
          e && moveTeleport(t, e, null, c, 0)
        } else _ && moveTeleport(t, h, f, c, 1)
        updateCssVars(t, g)
      }
    },
    remove(e, t, n, { um: o, o: { remove: i } }, r) {
      const {
        shapeFlag: a,
        children: s,
        anchor: l,
        targetStart: c,
        targetAnchor: d,
        target: u,
        props: p
      } = e
      if ((u && (i(c), i(d)), r && i(l), 16 & a)) {
        const e = r || !isTeleportDisabled(p)
        for (let i = 0; i < s.length; i++) {
          const r = s[i]
          o(r, t, n, e, !!r.dynamicChildren)
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  }
function moveTeleport(e, t, n, { o: { insert: o }, m: i }, r = 2) {
  0 === r && o(e.targetAnchor, t, n)
  const { el: a, anchor: s, shapeFlag: l, children: c, props: d } = e,
    u = 2 === r
  if ((u && o(a, t, n), (!u || isTeleportDisabled(d)) && 16 & l))
    for (let p = 0; p < c.length; p++) i(c[p], t, n, 2)
  u && o(s, t, n)
}
function hydrateTeleport(
  e,
  t,
  n,
  o,
  i,
  r,
  {
    o: {
      nextSibling: a,
      parentNode: s,
      querySelector: l,
      insert: c,
      createText: d
    }
  },
  u
) {
  const p = (t.target = resolveTarget(t.props, l))
  if (p) {
    const l = isTeleportDisabled(t.props),
      h = p._lpa || p.firstChild
    if (16 & t.shapeFlag)
      if (l)
        (t.anchor = u(a(e), t, s(e), n, o, i, r)),
          (t.targetStart = h),
          (t.targetAnchor = h && a(h))
      else {
        t.anchor = a(e)
        let s = h
        for (; s; ) {
          if (s && 8 === s.nodeType)
            if ('teleport start anchor' === s.data) t.targetStart = s
            else if ('teleport anchor' === s.data) {
              ;(t.targetAnchor = s),
                (p._lpa = t.targetAnchor && a(t.targetAnchor))
              break
            }
          s = a(s)
        }
        t.targetAnchor || prepareAnchor(p, t, d, c),
          u(h && a(h), t, p, n, o, i, r)
      }
    updateCssVars(t, l)
  }
  return t.anchor && a(t.anchor)
}
__name(moveTeleport, 'moveTeleport'), __name(hydrateTeleport, 'hydrateTeleport')
const Teleport = TeleportImpl
function updateCssVars(e, t) {
  const n = e.ctx
  if (n && n.ut) {
    let o, i
    for (
      t
        ? ((o = e.el), (i = e.anchor))
        : ((o = e.targetStart), (i = e.targetAnchor));
      o && o !== i;

    )
      1 === o.nodeType && o.setAttribute('data-v-owner', n.uid),
        (o = o.nextSibling)
    n.ut()
  }
}
function prepareAnchor(e, t, n, o) {
  const i = (t.targetStart = n('')),
    r = (t.targetAnchor = n(''))
  return (i[TeleportEndKey] = r), e && (o(i, e), o(r, e)), r
}
__name(updateCssVars, 'updateCssVars'), __name(prepareAnchor, 'prepareAnchor')
const leaveCbKey = Symbol('_leaveCb'),
  enterCbKey$1 = Symbol('_enterCb')
function useTransitionState() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: new Map()
  }
  return (
    onMounted(() => {
      e.isMounted = !0
    }),
    onBeforeUnmount(() => {
      e.isUnmounting = !0
    }),
    e
  )
}
__name(useTransitionState, 'useTransitionState')
const TransitionHookValidator = [Function, Array],
  BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  recursiveGetSubtree = __name((e) => {
    const t = e.subTree
    return t.component ? recursiveGetSubtree(t.component) : t
  }, 'recursiveGetSubtree'),
  BaseTransitionImpl = {
    name: 'BaseTransition',
    props: BaseTransitionPropsValidators,
    setup(e, { slots: t }) {
      const n = getCurrentInstance(),
        o = useTransitionState()
      return () => {
        const i = t.default && getTransitionRawChildren(t.default(), !0)
        if (!i || !i.length) return
        const r = findNonCommentChild(i),
          a = toRaw(e),
          { mode: s } = a
        if (o.isLeaving) return emptyPlaceholder(r)
        const l = getInnerChild$1(r)
        if (!l) return emptyPlaceholder(r)
        let c = resolveTransitionHooks(l, a, o, n, (e) => (c = e))
        l.type !== Comment && setTransitionHooks(l, c)
        let d = n.subTree && getInnerChild$1(n.subTree)
        if (
          d &&
          d.type !== Comment &&
          !isSameVNodeType(l, d) &&
          recursiveGetSubtree(n).type !== Comment
        ) {
          let e = resolveTransitionHooks(d, a, o, n)
          if ((setTransitionHooks(d, e), 'out-in' === s && l.type !== Comment))
            return (
              (o.isLeaving = !0),
              (e.afterLeave = () => {
                ;(o.isLeaving = !1),
                  8 & n.job.flags || n.update(),
                  delete e.afterLeave,
                  (d = void 0)
              }),
              emptyPlaceholder(r)
            )
          'in-out' === s && l.type !== Comment
            ? (e.delayLeave = (e, t, n) => {
                ;(getLeavingNodesForType(o, d)[String(d.key)] = d),
                  (e[leaveCbKey] = () => {
                    t(),
                      (e[leaveCbKey] = void 0),
                      delete c.delayedLeave,
                      (d = void 0)
                  }),
                  (c.delayedLeave = () => {
                    n(), delete c.delayedLeave, (d = void 0)
                  })
              })
            : (d = void 0)
        } else d && (d = void 0)
        return r
      }
    }
  }
function findNonCommentChild(e) {
  let t = e[0]
  if (e.length > 1) {
    let n = !1
    for (const o of e)
      if (o.type !== Comment) {
        0, (t = o), (n = !0)
        break
      }
  }
  return t
}
__name(findNonCommentChild, 'findNonCommentChild')
const BaseTransition = BaseTransitionImpl
function getLeavingNodesForType(e, t) {
  const { leavingVNodes: n } = e
  let o = n.get(t.type)
  return o || ((o = Object.create(null)), n.set(t.type, o)), o
}
function resolveTransitionHooks(e, t, n, o, i) {
  const {
      appear: r,
      mode: a,
      persisted: s = !1,
      onBeforeEnter: l,
      onEnter: c,
      onAfterEnter: d,
      onEnterCancelled: u,
      onBeforeLeave: p,
      onLeave: h,
      onAfterLeave: m,
      onLeaveCancelled: f,
      onBeforeAppear: _,
      onAppear: g,
      onAfterAppear: v,
      onAppearCancelled: y
    } = t,
    b = String(e.key),
    S = getLeavingNodesForType(n, e),
    C = __name((e, t) => {
      e && callWithAsyncErrorHandling(e, o, 9, t)
    }, 'callHook2'),
    w = __name((e, t) => {
      const n = t[1]
      C(e, t),
        isArray$3(e)
          ? e.every((e) => e.length <= 1) && n()
          : e.length <= 1 && n()
    }, 'callAsyncHook'),
    k = {
      mode: a,
      persisted: s,
      beforeEnter(t) {
        let o = l
        if (!n.isMounted) {
          if (!r) return
          o = _ || l
        }
        t[leaveCbKey] && t[leaveCbKey](!0)
        const i = S[b]
        i && isSameVNodeType(e, i) && i.el[leaveCbKey] && i.el[leaveCbKey](),
          C(o, [t])
      },
      enter(e) {
        let t = c,
          o = d,
          i = u
        if (!n.isMounted) {
          if (!r) return
          ;(t = g || c), (o = v || d), (i = y || u)
        }
        let a = !1
        const s = (e[enterCbKey$1] = (t) => {
          a ||
            ((a = !0),
            C(t ? i : o, [e]),
            k.delayedLeave && k.delayedLeave(),
            (e[enterCbKey$1] = void 0))
        })
        t ? w(t, [e, s]) : s()
      },
      leave(t, o) {
        const i = String(e.key)
        if ((t[enterCbKey$1] && t[enterCbKey$1](!0), n.isUnmounting)) return o()
        C(p, [t])
        let r = !1
        const a = (t[leaveCbKey] = (n) => {
          r ||
            ((r = !0),
            o(),
            C(n ? f : m, [t]),
            (t[leaveCbKey] = void 0),
            S[i] === e && delete S[i])
        })
        ;(S[i] = e), h ? w(h, [t, a]) : a()
      },
      clone(e) {
        const r = resolveTransitionHooks(e, t, n, o, i)
        return i && i(r), r
      }
    }
  return k
}
function emptyPlaceholder(e) {
  if (isKeepAlive(e)) return ((e = cloneVNode(e)).children = null), e
}
function getInnerChild$1(e) {
  if (!isKeepAlive(e))
    return isTeleport(e.type) && e.children
      ? findNonCommentChild(e.children)
      : e
  const { shapeFlag: t, children: n } = e
  if (n) {
    if (16 & t) return n[0]
    if (32 & t && isFunction$3(n.default)) return n.default()
  }
}
function setTransitionHooks(e, t) {
  6 & e.shapeFlag && e.component
    ? ((e.transition = t), setTransitionHooks(e.component.subTree, t))
    : 128 & e.shapeFlag
      ? ((e.ssContent.transition = t.clone(e.ssContent)),
        (e.ssFallback.transition = t.clone(e.ssFallback)))
      : (e.transition = t)
}
function getTransitionRawChildren(e, t = !1, n) {
  let o = [],
    i = 0
  for (let r = 0; r < e.length; r++) {
    let a = e[r]
    const s = null == n ? a.key : String(n) + String(null != a.key ? a.key : r)
    a.type === Fragment
      ? (128 & a.patchFlag && i++,
        (o = o.concat(getTransitionRawChildren(a.children, t, s))))
      : (t || a.type !== Comment) &&
        o.push(null != s ? cloneVNode(a, { key: s }) : a)
  }
  if (i > 1) for (let r = 0; r < o.length; r++) o[r].patchFlag = -2
  return o
}
/*! #__NO_SIDE_EFFECTS__ */
function defineComponent(e, t) {
  return isFunction$3(e)
    ? (() => extend$1({ name: e.name }, t, { setup: e }))()
    : e
}
function useId() {
  const e = getCurrentInstance()
  return e
    ? (e.appContext.config.idPrefix || 'v') + '-' + e.ids[0] + e.ids[1]++
    : ''
}
function markAsyncBoundary(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + '-', 0, 0]
}
__name(getLeavingNodesForType, 'getLeavingNodesForType'),
  __name(resolveTransitionHooks, 'resolveTransitionHooks'),
  __name(emptyPlaceholder, 'emptyPlaceholder'),
  __name(getInnerChild$1, 'getInnerChild$1'),
  __name(setTransitionHooks, 'setTransitionHooks'),
  __name(getTransitionRawChildren, 'getTransitionRawChildren'),
  __name(defineComponent, 'defineComponent'),
  __name(useId, 'useId'),
  __name(markAsyncBoundary, 'markAsyncBoundary')
const knownTemplateRefs = new WeakSet()
function useTemplateRef(e) {
  const t = getCurrentInstance(),
    n = shallowRef(null)
  if (t) {
    const o = t.refs === EMPTY_OBJ ? (t.refs = {}) : t.refs
    Object.defineProperty(o, e, {
      enumerable: !0,
      get: __name(() => n.value, 'get'),
      set: __name((e) => (n.value = e), 'set')
    })
  } else 0
  return n
}
function setRef(e, t, n, o, i = !1) {
  if (isArray$3(e))
    return void e.forEach((e, r) =>
      setRef(e, t && (isArray$3(t) ? t[r] : t), n, o, i)
    )
  if (isAsyncWrapper(o) && !i)
    return void (
      512 & o.shapeFlag &&
      o.type.__asyncResolved &&
      o.component.subTree.component &&
      setRef(e, t, n, o.component.subTree)
    )
  const r = 4 & o.shapeFlag ? getComponentPublicInstance(o.component) : o.el,
    a = i ? null : r,
    { i: s, r: l } = e
  const c = t && t.r,
    d = s.refs === EMPTY_OBJ ? (s.refs = {}) : s.refs,
    u = s.setupState,
    p = toRaw(u),
    h = u === EMPTY_OBJ ? () => !1 : (e) => hasOwn$2(p, e)
  if (
    (null != c &&
      c !== l &&
      (isString$3(c)
        ? ((d[c] = null), h(c) && (u[c] = null))
        : isRef(c) && (c.value = null)),
    isFunction$3(l))
  )
    callWithErrorHandling(l, s, 12, [a, d])
  else {
    const t = isString$3(l),
      o = isRef(l)
    if (t || o) {
      const s = __name(() => {
        if (e.f) {
          const n = t ? (h(l) ? u[l] : d[l]) : l.value
          i
            ? isArray$3(n) && remove$1(n, r)
            : isArray$3(n)
              ? n.includes(r) || n.push(r)
              : t
                ? ((d[l] = [r]), h(l) && (u[l] = d[l]))
                : ((l.value = [r]), e.k && (d[e.k] = l.value))
        } else
          t
            ? ((d[l] = a), h(l) && (u[l] = a))
            : o && ((l.value = a), e.k && (d[e.k] = a))
      }, 'doSet')
      a ? ((s.id = -1), queuePostRenderEffect(s, n)) : s()
    } else 0
  }
}
__name(useTemplateRef, 'useTemplateRef'), __name(setRef, 'setRef')
let hasLoggedMismatchError = !1
const logMismatchError = __name(() => {
    hasLoggedMismatchError ||
      (console.error('Hydration completed but contains mismatches.'),
      (hasLoggedMismatchError = !0))
  }, 'logMismatchError'),
  isSVGContainer = __name(
    (e) => e.namespaceURI.includes('svg') && 'foreignObject' !== e.tagName,
    'isSVGContainer'
  ),
  isMathMLContainer = __name(
    (e) => e.namespaceURI.includes('MathML'),
    'isMathMLContainer'
  ),
  getContainerType = __name((e) => {
    if (1 === e.nodeType)
      return isSVGContainer(e)
        ? 'svg'
        : isMathMLContainer(e)
          ? 'mathml'
          : void 0
  }, 'getContainerType'),
  isComment = __name((e) => 8 === e.nodeType, 'isComment')
function createHydrationFunctions(e) {
  const {
      mt: t,
      p: n,
      o: {
        patchProp: o,
        createText: i,
        nextSibling: r,
        parentNode: a,
        remove: s,
        insert: l,
        createComment: c
      }
    } = e,
    d = __name((e, t) => {
      if (!t.hasChildNodes())
        return n(null, e, t), flushPostFlushCbs(), void (t._vnode = e)
      u(t.firstChild, e, null, null, null), flushPostFlushCbs(), (t._vnode = e)
    }, 'hydrate'),
    u = __name((n, o, s, c, d, y = !1) => {
      y = y || !!o.dynamicChildren
      const b = isComment(n) && '[' === n.data,
        S = __name(() => f(n, o, s, c, d, b), 'onMismatch'),
        { type: C, ref: w, shapeFlag: k, patchFlag: x } = o
      let E = n.nodeType
      ;(o.el = n), -2 === x && ((y = !1), (o.dynamicChildren = null))
      let I = null
      switch (C) {
        case Text$1:
          3 !== E
            ? '' === o.children
              ? (l((o.el = i('')), a(n), n), (I = n))
              : (I = S())
            : (n.data !== o.children &&
                (logMismatchError(), (n.data = o.children)),
              (I = r(n)))
          break
        case Comment:
          v(n)
            ? ((I = r(n)), g((o.el = n.content.firstChild), n, s))
            : (I = 8 !== E || b ? S() : r(n))
          break
        case Static:
          if ((b && (E = (n = r(n)).nodeType), 1 === E || 3 === E)) {
            I = n
            const e = !o.children.length
            for (let t = 0; t < o.staticCount; t++)
              e && (o.children += 1 === I.nodeType ? I.outerHTML : I.data),
                t === o.staticCount - 1 && (o.anchor = I),
                (I = r(I))
            return b ? r(I) : I
          }
          S()
          break
        case Fragment:
          I = b ? m(n, o, s, c, d, y) : S()
          break
        default:
          if (1 & k)
            I =
              (1 === E && o.type.toLowerCase() === n.tagName.toLowerCase()) ||
              v(n)
                ? p(n, o, s, c, d, y)
                : S()
          else if (6 & k) {
            o.slotScopeIds = d
            const e = a(n)
            if (
              ((I = b
                ? _(n)
                : isComment(n) && 'teleport start' === n.data
                  ? _(n, n.data, 'teleport end')
                  : r(n)),
              t(o, e, null, s, c, getContainerType(e), y),
              isAsyncWrapper(o) && !o.type.__asyncResolved)
            ) {
              let t
              b
                ? ((t = createVNode(Fragment)),
                  (t.anchor = I ? I.previousSibling : e.lastChild))
                : (t =
                    3 === n.nodeType
                      ? createTextVNode('')
                      : createVNode('div')),
                (t.el = n),
                (o.component.subTree = t)
            }
          } else
            64 & k
              ? (I = 8 !== E ? S() : o.type.hydrate(n, o, s, c, d, y, e, h))
              : 128 & k &&
                (I = o.type.hydrate(
                  n,
                  o,
                  s,
                  c,
                  getContainerType(a(n)),
                  d,
                  y,
                  e,
                  u
                ))
      }
      return null != w && setRef(w, null, c, o), I
    }, 'hydrateNode'),
    p = __name((e, t, n, i, r, a) => {
      a = a || !!t.dynamicChildren
      const {
          type: l,
          props: c,
          patchFlag: d,
          shapeFlag: u,
          dirs: p,
          transition: m
        } = t,
        f = 'input' === l || 'option' === l
      if (f || -1 !== d) {
        p && invokeDirectiveHook(t, null, n, 'created')
        let l,
          _ = !1
        if (v(e)) {
          _ =
            needTransition(null, m) &&
            n &&
            n.vnode.props &&
            n.vnode.props.appear
          const o = e.content.firstChild
          _ && m.beforeEnter(o), g(o, e, n), (t.el = e = o)
        }
        if (16 & u && (!c || (!c.innerHTML && !c.textContent))) {
          let o = h(e.firstChild, t, e, n, i, r, a)
          for (; o; ) {
            isMismatchAllowed(e, 1) || logMismatchError()
            const t = o
            ;(o = o.nextSibling), s(t)
          }
        } else if (8 & u) {
          let n = t.children
          '\n' !== n[0] ||
            ('PRE' !== e.tagName && 'TEXTAREA' !== e.tagName) ||
            (n = n.slice(1)),
            e.textContent !== n &&
              (isMismatchAllowed(e, 0) || logMismatchError(),
              (e.textContent = t.children))
        }
        if (c)
          if (f || !a || 48 & d) {
            const t = e.tagName.includes('-')
            for (const i in c)
              ((f && (i.endsWith('value') || 'indeterminate' === i)) ||
                (isOn(i) && !isReservedProp(i)) ||
                '.' === i[0] ||
                t) &&
                o(e, i, null, c[i], void 0, n)
          } else if (c.onClick) o(e, 'onClick', null, c.onClick, void 0, n)
          else if (4 & d && isReactive(c.style))
            for (const e in c.style) c.style[e]
        ;(l = c && c.onVnodeBeforeMount) && invokeVNodeHook(l, n, t),
          p && invokeDirectiveHook(t, null, n, 'beforeMount'),
          ((l = c && c.onVnodeMounted) || p || _) &&
            queueEffectWithSuspense(() => {
              l && invokeVNodeHook(l, n, t),
                _ && m.enter(e),
                p && invokeDirectiveHook(t, null, n, 'mounted')
            }, i)
      }
      return e.nextSibling
    }, 'hydrateElement'),
    h = __name((e, t, o, a, s, c, d) => {
      d = d || !!t.dynamicChildren
      const p = t.children,
        h = p.length
      for (let m = 0; m < h; m++) {
        const t = d ? p[m] : (p[m] = normalizeVNode(p[m])),
          f = t.type === Text$1
        e
          ? (f &&
              !d &&
              m + 1 < h &&
              normalizeVNode(p[m + 1]).type === Text$1 &&
              (l(i(e.data.slice(t.children.length)), o, r(e)),
              (e.data = t.children)),
            (e = u(e, t, a, s, c, d)))
          : f && !t.children
            ? l((t.el = i('')), o)
            : (isMismatchAllowed(o, 1) || logMismatchError(),
              n(null, t, o, null, a, s, getContainerType(o), c))
      }
      return e
    }, 'hydrateChildren'),
    m = __name((e, t, n, o, i, s) => {
      const { slotScopeIds: d } = t
      d && (i = i ? i.concat(d) : d)
      const u = a(e),
        p = h(r(e), t, u, n, o, i, s)
      return p && isComment(p) && ']' === p.data
        ? r((t.anchor = p))
        : (logMismatchError(), l((t.anchor = c(']')), u, p), p)
    }, 'hydrateFragment'),
    f = __name((e, t, o, i, l, c) => {
      if (
        (isMismatchAllowed(e.parentElement, 1) || logMismatchError(),
        (t.el = null),
        c)
      ) {
        const t = _(e)
        for (;;) {
          const n = r(e)
          if (!n || n === t) break
          s(n)
        }
      }
      const d = r(e),
        u = a(e)
      return (
        s(e),
        n(null, t, u, d, o, i, getContainerType(u), l),
        o && ((o.vnode.el = t.el), updateHOCHostEl(o, t.el)),
        d
      )
    }, 'handleMismatch'),
    _ = __name((e, t = '[', n = ']') => {
      let o = 0
      for (; e; )
        if ((e = r(e)) && isComment(e) && (e.data === t && o++, e.data === n)) {
          if (0 === o) return r(e)
          o--
        }
      return e
    }, 'locateClosingAnchor'),
    g = __name((e, t, n) => {
      const o = t.parentNode
      o && o.replaceChild(e, t)
      let i = n
      for (; i; )
        i.vnode.el === t && (i.vnode.el = i.subTree.el = e), (i = i.parent)
    }, 'replaceNode'),
    v = __name(
      (e) => 1 === e.nodeType && 'TEMPLATE' === e.tagName,
      'isTemplateNode'
    )
  return [d, u]
}
function propHasMismatch(e, t, n, o, i) {
  let r, a, s, l
  if ('class' === t)
    (s = e.getAttribute('class')),
      (l = normalizeClass(n)),
      isSetEqual(toClassSet(s || ''), toClassSet(l)) || ((r = 2), (a = 'class'))
  else if ('style' === t) {
    ;(s = e.getAttribute('style') || ''),
      (l = isString$3(n) ? n : stringifyStyle(normalizeStyle(n)))
    const t = toStyleMap(s),
      c = toStyleMap(l)
    if (o.dirs)
      for (const { dir: e, value: n } of o.dirs)
        'show' !== e.name || n || c.set('display', 'none')
    i && resolveCssVars(i, o, c), isMapEqual(t, c) || ((r = 3), (a = 'style'))
  } else
    ((e instanceof SVGElement && isKnownSvgAttr(t)) ||
      (e instanceof HTMLElement && (isBooleanAttr(t) || isKnownHtmlAttr(t)))) &&
      (isBooleanAttr(t)
        ? ((s = e.hasAttribute(t)), (l = includeBooleanAttr(n)))
        : null == n
          ? ((s = e.hasAttribute(t)), (l = !1))
          : ((s = e.hasAttribute(t)
              ? e.getAttribute(t)
              : 'value' === t && 'TEXTAREA' === e.tagName && e.value),
            (l = !!isRenderableAttrValue(n) && String(n))),
      s !== l && ((r = 4), (a = t)))
  if (null != r && !isMismatchAllowed(e, r)) {
    const t = __name(
      (e) => (!1 === e ? '(not rendered)' : `${a}="${e}"`),
      'format'
    )
    return (
      warn$1(
        `Hydration ${MismatchTypeString[r]} mismatch on`,
        e,
        `\n  - rendered on server: ${t(s)}\n  - expected on client: ${t(l)}\n  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.\n  You should fix the source of the mismatch.`
      ),
      !0
    )
  }
  return !1
}
function toClassSet(e) {
  return new Set(e.trim().split(/\s+/))
}
function isSetEqual(e, t) {
  if (e.size !== t.size) return !1
  for (const n of e) if (!t.has(n)) return !1
  return !0
}
function toStyleMap(e) {
  const t = new Map()
  for (const n of e.split(';')) {
    let [e, o] = n.split(':')
    ;(e = e.trim()), (o = o && o.trim()), e && o && t.set(e, o)
  }
  return t
}
function isMapEqual(e, t) {
  if (e.size !== t.size) return !1
  for (const [n, o] of e) if (o !== t.get(n)) return !1
  return !0
}
function resolveCssVars(e, t, n) {
  const o = e.subTree
  if (
    e.getCssVars &&
    (t === o || (o && o.type === Fragment && o.children.includes(t)))
  ) {
    const t = e.getCssVars()
    for (const e in t) n.set(`--${getEscapedCssVarName(e, !1)}`, String(t[e]))
  }
  t === o && e.parent && resolveCssVars(e.parent, e.vnode, n)
}
__name(createHydrationFunctions, 'createHydrationFunctions'),
  __name(propHasMismatch, 'propHasMismatch'),
  __name(toClassSet, 'toClassSet'),
  __name(isSetEqual, 'isSetEqual'),
  __name(toStyleMap, 'toStyleMap'),
  __name(isMapEqual, 'isMapEqual'),
  __name(resolveCssVars, 'resolveCssVars')
const allowMismatchAttr = 'data-allow-mismatch',
  MismatchTypeString = {
    0: 'text',
    1: 'children',
    2: 'class',
    3: 'style',
    4: 'attribute'
  }
function isMismatchAllowed(e, t) {
  if (0 === t || 1 === t)
    for (; e && !e.hasAttribute(allowMismatchAttr); ) e = e.parentElement
  const n = e && e.getAttribute(allowMismatchAttr)
  if (null == n) return !1
  if ('' === n) return !0
  {
    const e = n.split(',')
    return (
      !(0 !== t || !e.includes('children')) ||
      n.split(',').includes(MismatchTypeString[t])
    )
  }
}
__name(isMismatchAllowed, 'isMismatchAllowed')
const requestIdleCallback$1 =
    getGlobalThis().requestIdleCallback || ((e) => setTimeout(e, 1)),
  cancelIdleCallback$1 =
    getGlobalThis().cancelIdleCallback || ((e) => clearTimeout(e)),
  hydrateOnIdle = __name(
    (e = 1e4) =>
      (t) => {
        const n = requestIdleCallback$1(t, { timeout: e })
        return () => cancelIdleCallback$1(n)
      },
    'hydrateOnIdle'
  )
function elementIsVisibleInViewport(e) {
  const { top: t, left: n, bottom: o, right: i } = e.getBoundingClientRect(),
    { innerHeight: r, innerWidth: a } = window
  return (
    ((t > 0 && t < r) || (o > 0 && o < r)) &&
    ((n > 0 && n < a) || (i > 0 && i < a))
  )
}
__name(elementIsVisibleInViewport, 'elementIsVisibleInViewport')
const hydrateOnVisible = __name(
    (e) => (t, n) => {
      const o = new IntersectionObserver((e) => {
        for (const n of e)
          if (n.isIntersecting) {
            o.disconnect(), t()
            break
          }
      }, e)
      return (
        n((e) => {
          if (e instanceof Element)
            return elementIsVisibleInViewport(e)
              ? (t(), o.disconnect(), !1)
              : void o.observe(e)
        }),
        () => o.disconnect()
      )
    },
    'hydrateOnVisible'
  ),
  hydrateOnMediaQuery = __name(
    (e) => (t) => {
      if (e) {
        const n = matchMedia(e)
        if (!n.matches)
          return (
            n.addEventListener('change', t, { once: !0 }),
            () => n.removeEventListener('change', t)
          )
        t()
      }
    },
    'hydrateOnMediaQuery'
  ),
  hydrateOnInteraction = __name(
    (e = []) =>
      (t, n) => {
        isString$3(e) && (e = [e])
        let o = !1
        const i = __name((e) => {
            o ||
              ((o = !0),
              r(),
              t(),
              e.target.dispatchEvent(new e.constructor(e.type, e)))
          }, 'doHydrate'),
          r = __name(() => {
            n((t) => {
              for (const n of e) t.removeEventListener(n, i)
            })
          }, 'teardown')
        return (
          n((t) => {
            for (const n of e) t.addEventListener(n, i, { once: !0 })
          }),
          r
        )
      },
    'hydrateOnInteraction'
  )
function forEachElement(e, t) {
  if (isComment(e) && '[' === e.data) {
    let n = 1,
      o = e.nextSibling
    for (; o; ) {
      if (1 === o.nodeType) {
        if (!1 === t(o)) break
      } else if (isComment(o))
        if (']' === o.data) {
          if (0 == --n) break
        } else '[' === o.data && n++
      o = o.nextSibling
    }
  } else t(e)
}
__name(forEachElement, 'forEachElement')
const isAsyncWrapper = __name((e) => !!e.type.__asyncLoader, 'isAsyncWrapper')
/*! #__NO_SIDE_EFFECTS__ */ function defineAsyncComponent(e) {
  isFunction$3(e) && (e = { loader: e })
  const {
    loader: t,
    loadingComponent: n,
    errorComponent: o,
    delay: i = 200,
    hydrate: r,
    timeout: a,
    suspensible: s = !0,
    onError: l
  } = e
  let c,
    d = null,
    u = 0
  const p = __name(() => (u++, (d = null), h()), 'retry'),
    h = __name(() => {
      let e
      return (
        d ||
        (e = d =
          t()
            .catch((e) => {
              if (((e = e instanceof Error ? e : new Error(String(e))), l))
                return new Promise((t, n) => {
                  l(
                    e,
                    __name(() => t(p()), 'userRetry'),
                    __name(() => n(e), 'userFail'),
                    u + 1
                  )
                })
              throw e
            })
            .then((t) =>
              e !== d && d
                ? d
                : (t &&
                    (t.__esModule || 'Module' === t[Symbol.toStringTag]) &&
                    (t = t.default),
                  (c = t),
                  t)
            ))
      )
    }, 'load')
  return defineComponent({
    name: 'AsyncComponentWrapper',
    __asyncLoader: h,
    __asyncHydrate(e, t, n) {
      const o = r
        ? () => {
            const o = r(n, (t) => forEachElement(e, t))
            o && (t.bum || (t.bum = [])).push(o)
          }
        : n
      c ? o() : h().then(() => !t.isUnmounted && o())
    },
    get __asyncResolved() {
      return c
    },
    setup() {
      const e = currentInstance
      if ((markAsyncBoundary(e), c)) return () => createInnerComp(c, e)
      const t = __name((t) => {
        ;(d = null), handleError(t, e, 13, !o)
      }, 'onError')
      if ((s && e.suspense) || isInSSRComponentSetup)
        return h()
          .then((t) => () => createInnerComp(t, e))
          .catch((e) => (t(e), () => (o ? createVNode(o, { error: e }) : null)))
      const r = ref(!1),
        l = ref(),
        u = ref(!!i)
      return (
        i &&
          setTimeout(() => {
            u.value = !1
          }, i),
        null != a &&
          setTimeout(() => {
            if (!r.value && !l.value) {
              const e = new Error(`Async component timed out after ${a}ms.`)
              t(e), (l.value = e)
            }
          }, a),
        h()
          .then(() => {
            ;(r.value = !0),
              e.parent && isKeepAlive(e.parent.vnode) && e.parent.update()
          })
          .catch((e) => {
            t(e), (l.value = e)
          }),
        () =>
          r.value && c
            ? createInnerComp(c, e)
            : l.value && o
              ? createVNode(o, { error: l.value })
              : n && !u.value
                ? createVNode(n)
                : void 0
      )
    }
  })
}
function createInnerComp(e, t) {
  const { ref: n, props: o, children: i, ce: r } = t.vnode,
    a = createVNode(e, o, i)
  return (a.ref = n), (a.ce = r), delete t.vnode.ce, a
}
__name(defineAsyncComponent, 'defineAsyncComponent'),
  __name(createInnerComp, 'createInnerComp')
const isKeepAlive = __name((e) => e.type.__isKeepAlive, 'isKeepAlive'),
  KeepAliveImpl = {
    name: 'KeepAlive',
    __isKeepAlive: !0,
    props: {
      include: [String, RegExp, Array],
      exclude: [String, RegExp, Array],
      max: [String, Number]
    },
    setup(e, { slots: t }) {
      const n = getCurrentInstance(),
        o = n.ctx
      if (!o.renderer)
        return () => {
          const e = t.default && t.default()
          return e && 1 === e.length ? e[0] : e
        }
      const i = new Map(),
        r = new Set()
      let a = null
      const s = n.suspense,
        {
          renderer: {
            p: l,
            m: c,
            um: d,
            o: { createElement: u }
          }
        } = o,
        p = u('div')
      function h(e) {
        resetShapeFlag(e), d(e, n, s, !0)
      }
      function m(e) {
        i.forEach((t, n) => {
          const o = getComponentName(t.type)
          o && !e(o) && f(n)
        })
      }
      function f(e) {
        const t = i.get(e)
        !t || (a && isSameVNodeType(t, a)) ? a && resetShapeFlag(a) : h(t),
          i.delete(e),
          r.delete(e)
      }
      ;(o.activate = (e, t, n, o, i) => {
        const r = e.component
        c(e, t, n, 0, s),
          l(r.vnode, e, t, n, r, s, o, e.slotScopeIds, i),
          queuePostRenderEffect(() => {
            ;(r.isDeactivated = !1), r.a && invokeArrayFns(r.a)
            const t = e.props && e.props.onVnodeMounted
            t && invokeVNodeHook(t, r.parent, e)
          }, s)
      }),
        (o.deactivate = (e) => {
          const t = e.component
          invalidateMount(t.m),
            invalidateMount(t.a),
            c(e, p, null, 1, s),
            queuePostRenderEffect(() => {
              t.da && invokeArrayFns(t.da)
              const n = e.props && e.props.onVnodeUnmounted
              n && invokeVNodeHook(n, t.parent, e), (t.isDeactivated = !0)
            }, s)
        }),
        __name(h, 'unmount'),
        __name(m, 'pruneCache'),
        __name(f, 'pruneCacheEntry'),
        watch(
          () => [e.include, e.exclude],
          ([e, t]) => {
            e && m((t) => matches(e, t)), t && m((e) => !matches(t, e))
          },
          { flush: 'post', deep: !0 }
        )
      let _ = null
      const g = __name(() => {
        null != _ &&
          (isSuspense(n.subTree.type)
            ? queuePostRenderEffect(() => {
                i.set(_, getInnerChild(n.subTree))
              }, n.subTree.suspense)
            : i.set(_, getInnerChild(n.subTree)))
      }, 'cacheSubtree')
      return (
        onMounted(g),
        onUpdated(g),
        onBeforeUnmount(() => {
          i.forEach((e) => {
            const { subTree: t, suspense: o } = n,
              i = getInnerChild(t)
            if (e.type !== i.type || e.key !== i.key) h(e)
            else {
              resetShapeFlag(i)
              const e = i.component.da
              e && queuePostRenderEffect(e, o)
            }
          })
        }),
        () => {
          if (((_ = null), !t.default)) return (a = null)
          const n = t.default(),
            o = n[0]
          if (n.length > 1) return (a = null), n
          if (!(isVNode(o) && (4 & o.shapeFlag || 128 & o.shapeFlag)))
            return (a = null), o
          let s = getInnerChild(o)
          if (s.type === Comment) return (a = null), s
          const l = s.type,
            c = getComponentName(
              isAsyncWrapper(s) ? s.type.__asyncResolved || {} : l
            ),
            { include: d, exclude: u, max: p } = e
          if ((d && (!c || !matches(d, c))) || (u && c && matches(u, c)))
            return (s.shapeFlag &= -257), (a = s), o
          const h = null == s.key ? l : s.key,
            m = i.get(h)
          return (
            s.el &&
              ((s = cloneVNode(s)), 128 & o.shapeFlag && (o.ssContent = s)),
            (_ = h),
            m
              ? ((s.el = m.el),
                (s.component = m.component),
                s.transition && setTransitionHooks(s, s.transition),
                (s.shapeFlag |= 512),
                r.delete(h),
                r.add(h))
              : (r.add(h),
                p && r.size > parseInt(p, 10) && f(r.values().next().value)),
            (s.shapeFlag |= 256),
            (a = s),
            isSuspense(o.type) ? o : s
          )
        }
      )
    }
  },
  KeepAlive = KeepAliveImpl
function matches(e, t) {
  return isArray$3(e)
    ? e.some((e) => matches(e, t))
    : isString$3(e)
      ? e.split(',').includes(t)
      : !!isRegExp$1(e) && ((e.lastIndex = 0), e.test(t))
}
function onActivated(e, t) {
  registerKeepAliveHook(e, 'a', t)
}
function onDeactivated(e, t) {
  registerKeepAliveHook(e, 'da', t)
}
function registerKeepAliveHook(e, t, n = currentInstance) {
  const o =
    e.__wdc ||
    (e.__wdc = () => {
      let t = n
      for (; t; ) {
        if (t.isDeactivated) return
        t = t.parent
      }
      return e()
    })
  if ((injectHook(t, o, n), n)) {
    let e = n.parent
    for (; e && e.parent; )
      isKeepAlive(e.parent.vnode) && injectToKeepAliveRoot(o, t, n, e),
        (e = e.parent)
  }
}
function injectToKeepAliveRoot(e, t, n, o) {
  const i = injectHook(t, e, o, !0)
  onUnmounted(() => {
    remove$1(o[t], i)
  }, n)
}
function resetShapeFlag(e) {
  ;(e.shapeFlag &= -257), (e.shapeFlag &= -513)
}
function getInnerChild(e) {
  return 128 & e.shapeFlag ? e.ssContent : e
}
function injectHook(e, t, n = currentInstance, o = !1) {
  if (n) {
    const i = n[e] || (n[e] = []),
      r =
        t.__weh ||
        (t.__weh = (...o) => {
          pauseTracking()
          const i = setCurrentInstance(n),
            r = callWithAsyncErrorHandling(t, n, e, o)
          return i(), resetTracking(), r
        })
    return o ? i.unshift(r) : i.push(r), r
  }
}
__name(matches, 'matches'),
  __name(onActivated, 'onActivated'),
  __name(onDeactivated, 'onDeactivated'),
  __name(registerKeepAliveHook, 'registerKeepAliveHook'),
  __name(injectToKeepAliveRoot, 'injectToKeepAliveRoot'),
  __name(resetShapeFlag, 'resetShapeFlag'),
  __name(getInnerChild, 'getInnerChild'),
  __name(injectHook, 'injectHook')
const createHook = __name(
    (e) =>
      (t, n = currentInstance) => {
        ;(isInSSRComponentSetup && 'sp' !== e) ||
          injectHook(e, (...e) => t(...e), n)
      },
    'createHook'
  ),
  onBeforeMount = createHook('bm'),
  onMounted = createHook('m'),
  onBeforeUpdate = createHook('bu'),
  onUpdated = createHook('u'),
  onBeforeUnmount = createHook('bum'),
  onUnmounted = createHook('um'),
  onServerPrefetch = createHook('sp'),
  onRenderTriggered = createHook('rtg'),
  onRenderTracked = createHook('rtc')
function onErrorCaptured(e, t = currentInstance) {
  injectHook('ec', e, t)
}
__name(onErrorCaptured, 'onErrorCaptured')
const COMPONENTS = 'components',
  DIRECTIVES = 'directives'
function resolveComponent(e, t) {
  return resolveAsset(COMPONENTS, e, !0, t) || e
}
__name(resolveComponent, 'resolveComponent')
const NULL_DYNAMIC_COMPONENT = Symbol.for('v-ndc')
function resolveDynamicComponent(e) {
  return isString$3(e)
    ? resolveAsset(COMPONENTS, e, !1) || e
    : e || NULL_DYNAMIC_COMPONENT
}
function resolveDirective(e) {
  return resolveAsset(DIRECTIVES, e)
}
function resolveAsset(e, t, n = !0, o = !1) {
  const i = currentRenderingInstance || currentInstance
  if (i) {
    const n = i.type
    if (e === COMPONENTS) {
      const e = getComponentName(n, !1)
      if (
        e &&
        (e === t || e === camelize$1(t) || e === capitalize(camelize$1(t)))
      )
        return n
    }
    const r = resolve$1(i[e] || n[e], t) || resolve$1(i.appContext[e], t)
    return !r && o ? n : r
  }
}
function resolve$1(e, t) {
  return e && (e[t] || e[camelize$1(t)] || e[capitalize(camelize$1(t))])
}
function renderList(e, t, n, o) {
  let i
  const r = n && n[o],
    a = isArray$3(e)
  if (a || isString$3(e)) {
    let n = !1
    a && isReactive(e) && ((n = !isShallow(e)), (e = shallowReadArray(e))),
      (i = new Array(e.length))
    for (let o = 0, a = e.length; o < a; o++)
      i[o] = t(n ? toReactive$1(e[o]) : e[o], o, void 0, r && r[o])
  } else if ('number' == typeof e) {
    0, (i = new Array(e))
    for (let n = 0; n < e; n++) i[n] = t(n + 1, n, void 0, r && r[n])
  } else if (isObject$4(e))
    if (e[Symbol.iterator])
      i = Array.from(e, (e, n) => t(e, n, void 0, r && r[n]))
    else {
      const n = Object.keys(e)
      i = new Array(n.length)
      for (let o = 0, a = n.length; o < a; o++) {
        const a = n[o]
        i[o] = t(e[a], a, o, r && r[o])
      }
    }
  else i = []
  return n && (n[o] = i), i
}
function createSlots(e, t) {
  for (let n = 0; n < t.length; n++) {
    const o = t[n]
    if (isArray$3(o)) for (let t = 0; t < o.length; t++) e[o[t].name] = o[t].fn
    else
      o &&
        (e[o.name] = o.key
          ? (...e) => {
              const t = o.fn(...e)
              return t && (t.key = o.key), t
            }
          : o.fn)
  }
  return e
}
function renderSlot(e, t, n = {}, o, i) {
  if (
    currentRenderingInstance.ce ||
    (currentRenderingInstance.parent &&
      isAsyncWrapper(currentRenderingInstance.parent) &&
      currentRenderingInstance.parent.ce)
  )
    return (
      'default' !== t && (n.name = t),
      openBlock(),
      createBlock(Fragment, null, [createVNode('slot', n, o && o())], 64)
    )
  let r = e[t]
  r && r._c && (r._d = !1), openBlock()
  const a = r && ensureValidVNode(r(n)),
    s = n.key || (a && a.key),
    l = createBlock(
      Fragment,
      { key: (s && !isSymbol(s) ? s : `_${t}`) + (!a && o ? '_fb' : '') },
      a || (o ? o() : []),
      a && 1 === e._ ? 64 : -2
    )
  return (
    !i && l.scopeId && (l.slotScopeIds = [l.scopeId + '-s']),
    r && r._c && (r._d = !0),
    l
  )
}
function ensureValidVNode(e) {
  return e.some(
    (e) =>
      !isVNode(e) ||
      (e.type !== Comment &&
        !(e.type === Fragment && !ensureValidVNode(e.children)))
  )
    ? e
    : null
}
function toHandlers(e, t) {
  const n = {}
  for (const o in e)
    n[t && /[A-Z]/.test(o) ? `on:${o}` : toHandlerKey(o)] = e[o]
  return n
}
__name(resolveDynamicComponent, 'resolveDynamicComponent'),
  __name(resolveDirective, 'resolveDirective'),
  __name(resolveAsset, 'resolveAsset'),
  __name(resolve$1, 'resolve$1'),
  __name(renderList, 'renderList'),
  __name(createSlots, 'createSlots'),
  __name(renderSlot, 'renderSlot'),
  __name(ensureValidVNode, 'ensureValidVNode'),
  __name(toHandlers, 'toHandlers')
const getPublicInstance = __name(
    (e) =>
      e
        ? isStatefulComponent(e)
          ? getComponentPublicInstance(e)
          : getPublicInstance(e.parent)
        : null,
    'getPublicInstance'
  ),
  publicPropertiesMap = extend$1(Object.create(null), {
    $: __name((e) => e, '$'),
    $el: __name((e) => e.vnode.el, '$el'),
    $data: __name((e) => e.data, '$data'),
    $props: __name((e) => e.props, '$props'),
    $attrs: __name((e) => e.attrs, '$attrs'),
    $slots: __name((e) => e.slots, '$slots'),
    $refs: __name((e) => e.refs, '$refs'),
    $parent: __name((e) => getPublicInstance(e.parent), '$parent'),
    $root: __name((e) => getPublicInstance(e.root), '$root'),
    $host: __name((e) => e.ce, '$host'),
    $emit: __name((e) => e.emit, '$emit'),
    $options: __name((e) => resolveMergedOptions(e), '$options'),
    $forceUpdate: __name(
      (e) =>
        e.f ||
        (e.f = () => {
          queueJob(e.update)
        }),
      '$forceUpdate'
    ),
    $nextTick: __name(
      (e) => e.n || (e.n = nextTick.bind(e.proxy)),
      '$nextTick'
    ),
    $watch: __name((e) => instanceWatch.bind(e), '$watch')
  }),
  isReservedPrefix = __name((e) => '_' === e || '$' === e, 'isReservedPrefix'),
  hasSetupBinding = __name(
    (e, t) => e !== EMPTY_OBJ && !e.__isScriptSetup && hasOwn$2(e, t),
    'hasSetupBinding'
  ),
  PublicInstanceProxyHandlers = {
    get({ _: e }, t) {
      if ('__v_skip' === t) return !0
      const {
        ctx: n,
        setupState: o,
        data: i,
        props: r,
        accessCache: a,
        type: s,
        appContext: l
      } = e
      let c
      if ('$' !== t[0]) {
        const s = a[t]
        if (void 0 !== s)
          switch (s) {
            case 1:
              return o[t]
            case 2:
              return i[t]
            case 4:
              return n[t]
            case 3:
              return r[t]
          }
        else {
          if (hasSetupBinding(o, t)) return (a[t] = 1), o[t]
          if (i !== EMPTY_OBJ && hasOwn$2(i, t)) return (a[t] = 2), i[t]
          if ((c = e.propsOptions[0]) && hasOwn$2(c, t)) return (a[t] = 3), r[t]
          if (n !== EMPTY_OBJ && hasOwn$2(n, t)) return (a[t] = 4), n[t]
          shouldCacheAccess && (a[t] = 0)
        }
      }
      const d = publicPropertiesMap[t]
      let u, p
      return d
        ? ('$attrs' === t && track(e.attrs, 'get', ''), d(e))
        : (u = s.__cssModules) && (u = u[t])
          ? u
          : n !== EMPTY_OBJ && hasOwn$2(n, t)
            ? ((a[t] = 4), n[t])
            : ((p = l.config.globalProperties), hasOwn$2(p, t) ? p[t] : void 0)
    },
    set({ _: e }, t, n) {
      const { data: o, setupState: i, ctx: r } = e
      return hasSetupBinding(i, t)
        ? ((i[t] = n), !0)
        : o !== EMPTY_OBJ && hasOwn$2(o, t)
          ? ((o[t] = n), !0)
          : !hasOwn$2(e.props, t) &&
            ('$' !== t[0] || !(t.slice(1) in e)) &&
            ((r[t] = n), !0)
    },
    has(
      {
        _: {
          data: e,
          setupState: t,
          accessCache: n,
          ctx: o,
          appContext: i,
          propsOptions: r
        }
      },
      a
    ) {
      let s
      return (
        !!n[a] ||
        (e !== EMPTY_OBJ && hasOwn$2(e, a)) ||
        hasSetupBinding(t, a) ||
        ((s = r[0]) && hasOwn$2(s, a)) ||
        hasOwn$2(o, a) ||
        hasOwn$2(publicPropertiesMap, a) ||
        hasOwn$2(i.config.globalProperties, a)
      )
    },
    defineProperty(e, t, n) {
      return (
        null != n.get
          ? (e._.accessCache[t] = 0)
          : hasOwn$2(n, 'value') && this.set(e, t, n.value, null),
        Reflect.defineProperty(e, t, n)
      )
    }
  }
const RuntimeCompiledPublicInstanceProxyHandlers = extend$1(
  {},
  PublicInstanceProxyHandlers,
  {
    get(e, t) {
      if (t !== Symbol.unscopables)
        return PublicInstanceProxyHandlers.get(e, t, e)
    },
    has: (e, t) => '_' !== t[0] && !isGloballyAllowed(t)
  }
)
function createDevRenderContext(e) {
  const t = {}
  return (
    Object.defineProperty(t, '_', {
      configurable: !0,
      enumerable: !1,
      get: __name(() => e, 'get')
    }),
    Object.keys(publicPropertiesMap).forEach((n) => {
      Object.defineProperty(t, n, {
        configurable: !0,
        enumerable: !1,
        get: __name(() => publicPropertiesMap[n](e), 'get'),
        set: NOOP
      })
    }),
    t
  )
}
function exposePropsOnRenderContext(e) {
  const {
    ctx: t,
    propsOptions: [n]
  } = e
  n &&
    Object.keys(n).forEach((n) => {
      Object.defineProperty(t, n, {
        enumerable: !0,
        configurable: !0,
        get: __name(() => e.props[n], 'get'),
        set: NOOP
      })
    })
}
function exposeSetupStateOnRenderContext(e) {
  const { ctx: t, setupState: n } = e
  Object.keys(toRaw(n)).forEach((e) => {
    if (!n.__isScriptSetup) {
      if (isReservedPrefix(e[0]))
        return void warn$1(
          `setup() return property ${JSON.stringify(e)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        )
      Object.defineProperty(t, e, {
        enumerable: !0,
        configurable: !0,
        get: __name(() => n[e], 'get'),
        set: NOOP
      })
    }
  })
}
__name(createDevRenderContext, 'createDevRenderContext'),
  __name(exposePropsOnRenderContext, 'exposePropsOnRenderContext'),
  __name(exposeSetupStateOnRenderContext, 'exposeSetupStateOnRenderContext')
const warnRuntimeUsage = __name(
  (e) =>
    warn$1(
      `${e}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
    ),
  'warnRuntimeUsage'
)
function defineProps() {
  return null
}
function defineEmits() {
  return null
}
function defineExpose(e) {
  0
}
function defineOptions(e) {
  0
}
function defineSlots() {
  return null
}
function defineModel() {
  0
}
function withDefaults(e, t) {
  return null
}
function useSlots() {
  return getContext().slots
}
function useAttrs() {
  return getContext().attrs
}
function getContext() {
  const e = getCurrentInstance()
  return e.setupContext || (e.setupContext = createSetupContext(e))
}
function normalizePropsOrEmits(e) {
  return isArray$3(e) ? e.reduce((e, t) => ((e[t] = null), e), {}) : e
}
function mergeDefaults(e, t) {
  const n = normalizePropsOrEmits(e)
  for (const o in t) {
    if (o.startsWith('__skip')) continue
    let e = n[o]
    e
      ? isArray$3(e) || isFunction$3(e)
        ? (e = n[o] = { type: e, default: t[o] })
        : (e.default = t[o])
      : null === e && (e = n[o] = { default: t[o] }),
      e && t[`__skip_${o}`] && (e.skipFactory = !0)
  }
  return n
}
function mergeModels(e, t) {
  return e && t
    ? isArray$3(e) && isArray$3(t)
      ? e.concat(t)
      : extend$1({}, normalizePropsOrEmits(e), normalizePropsOrEmits(t))
    : e || t
}
function createPropsRestProxy(e, t) {
  const n = {}
  for (const o in e)
    t.includes(o) ||
      Object.defineProperty(n, o, {
        enumerable: !0,
        get: __name(() => e[o], 'get')
      })
  return n
}
function withAsyncContext(e) {
  const t = getCurrentInstance()
  let n = e()
  return (
    unsetCurrentInstance(),
    isPromise(n) &&
      (n = n.catch((e) => {
        throw (setCurrentInstance(t), e)
      })),
    [n, () => setCurrentInstance(t)]
  )
}
function createDuplicateChecker() {
  const e = Object.create(null)
  return (t, n) => {
    e[n]
      ? warn$1(`${t} property "${n}" is already defined in ${e[n]}.`)
      : (e[n] = t)
  }
}
__name(defineProps, 'defineProps'),
  __name(defineEmits, 'defineEmits'),
  __name(defineExpose, 'defineExpose'),
  __name(defineOptions, 'defineOptions'),
  __name(defineSlots, 'defineSlots'),
  __name(defineModel, 'defineModel'),
  __name(withDefaults, 'withDefaults'),
  __name(useSlots, 'useSlots'),
  __name(useAttrs, 'useAttrs'),
  __name(getContext, 'getContext'),
  __name(normalizePropsOrEmits, 'normalizePropsOrEmits'),
  __name(mergeDefaults, 'mergeDefaults'),
  __name(mergeModels, 'mergeModels'),
  __name(createPropsRestProxy, 'createPropsRestProxy'),
  __name(withAsyncContext, 'withAsyncContext'),
  __name(createDuplicateChecker, 'createDuplicateChecker')
let shouldCacheAccess = !0
function applyOptions(e) {
  const t = resolveMergedOptions(e),
    n = e.proxy,
    o = e.ctx
  ;(shouldCacheAccess = !1),
    t.beforeCreate && callHook$1(t.beforeCreate, e, 'bc')
  const {
      data: i,
      computed: r,
      methods: a,
      watch: s,
      provide: l,
      inject: c,
      created: d,
      beforeMount: u,
      mounted: p,
      beforeUpdate: h,
      updated: m,
      activated: f,
      deactivated: _,
      beforeDestroy: g,
      beforeUnmount: v,
      destroyed: y,
      unmounted: b,
      render: S,
      renderTracked: C,
      renderTriggered: w,
      errorCaptured: k,
      serverPrefetch: x,
      expose: E,
      inheritAttrs: I,
      components: T,
      directives: $,
      filters: L
    } = t,
    A = null
  if ((c && resolveInjections(c, o, A), a))
    for (const P in a) {
      const e = a[P]
      isFunction$3(e) && (o[P] = e.bind(n))
    }
  if (i) {
    0
    const t = i.call(n, n)
    0, isObject$4(t) && (e.data = reactive(t))
  }
  if (((shouldCacheAccess = !0), r))
    for (const P in r) {
      const e = r[P],
        t = isFunction$3(e)
          ? e.bind(n, n)
          : isFunction$3(e.get)
            ? e.get.bind(n, n)
            : NOOP
      0
      const i = !isFunction$3(e) && isFunction$3(e.set) ? e.set.bind(n) : NOOP,
        a = computed({ get: t, set: i })
      Object.defineProperty(o, P, {
        enumerable: !0,
        configurable: !0,
        get: __name(() => a.value, 'get'),
        set: __name((e) => (a.value = e), 'set')
      })
    }
  if (s) for (const P in s) createWatcher(s[P], o, n, P)
  if (l) {
    const e = isFunction$3(l) ? l.call(n) : l
    Reflect.ownKeys(e).forEach((t) => {
      provide(t, e[t])
    })
  }
  function O(e, t) {
    isArray$3(t) ? t.forEach((t) => e(t.bind(n))) : t && e(t.bind(n))
  }
  if (
    (d && callHook$1(d, e, 'c'),
    __name(O, 'registerLifecycleHook'),
    O(onBeforeMount, u),
    O(onMounted, p),
    O(onBeforeUpdate, h),
    O(onUpdated, m),
    O(onActivated, f),
    O(onDeactivated, _),
    O(onErrorCaptured, k),
    O(onRenderTracked, C),
    O(onRenderTriggered, w),
    O(onBeforeUnmount, v),
    O(onUnmounted, b),
    O(onServerPrefetch, x),
    isArray$3(E))
  )
    if (E.length) {
      const t = e.exposed || (e.exposed = {})
      E.forEach((e) => {
        Object.defineProperty(t, e, {
          get: __name(() => n[e], 'get'),
          set: __name((t) => (n[e] = t), 'set')
        })
      })
    } else e.exposed || (e.exposed = {})
  S && e.render === NOOP && (e.render = S),
    null != I && (e.inheritAttrs = I),
    T && (e.components = T),
    $ && (e.directives = $),
    x && markAsyncBoundary(e)
}
function resolveInjections(e, t, n = NOOP) {
  isArray$3(e) && (e = normalizeInject(e))
  for (const o in e) {
    const n = e[o]
    let i
    ;(i = isObject$4(n)
      ? 'default' in n
        ? inject(n.from || o, n.default, !0)
        : inject(n.from || o)
      : inject(n)),
      isRef(i)
        ? Object.defineProperty(t, o, {
            enumerable: !0,
            configurable: !0,
            get: __name(() => i.value, 'get'),
            set: __name((e) => (i.value = e), 'set')
          })
        : (t[o] = i)
  }
}
function callHook$1(e, t, n) {
  callWithAsyncErrorHandling(
    isArray$3(e) ? e.map((e) => e.bind(t.proxy)) : e.bind(t.proxy),
    t,
    n
  )
}
function createWatcher(e, t, n, o) {
  let i = o.includes('.') ? createPathGetter(n, o) : () => n[o]
  if (isString$3(e)) {
    const n = t[e]
    isFunction$3(n) && watch(i, n)
  } else if (isFunction$3(e)) watch(i, e.bind(n))
  else if (isObject$4(e))
    if (isArray$3(e)) e.forEach((e) => createWatcher(e, t, n, o))
    else {
      const o = isFunction$3(e.handler) ? e.handler.bind(n) : t[e.handler]
      isFunction$3(o) && watch(i, o, e)
    }
  else 0
}
function resolveMergedOptions(e) {
  const t = e.type,
    { mixins: n, extends: o } = t,
    {
      mixins: i,
      optionsCache: r,
      config: { optionMergeStrategies: a }
    } = e.appContext,
    s = r.get(t)
  let l
  return (
    s
      ? (l = s)
      : i.length || n || o
        ? ((l = {}),
          i.length && i.forEach((e) => mergeOptions(l, e, a, !0)),
          mergeOptions(l, t, a))
        : (l = t),
    isObject$4(t) && r.set(t, l),
    l
  )
}
function mergeOptions(e, t, n, o = !1) {
  const { mixins: i, extends: r } = t
  r && mergeOptions(e, r, n, !0),
    i && i.forEach((t) => mergeOptions(e, t, n, !0))
  for (const a in t)
    if (o && 'expose' === a);
    else {
      const o = internalOptionMergeStrats[a] || (n && n[a])
      e[a] = o ? o(e[a], t[a]) : t[a]
    }
  return e
}
__name(applyOptions, 'applyOptions'),
  __name(resolveInjections, 'resolveInjections'),
  __name(callHook$1, 'callHook$1'),
  __name(createWatcher, 'createWatcher'),
  __name(resolveMergedOptions, 'resolveMergedOptions'),
  __name(mergeOptions, 'mergeOptions')
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
}
function mergeDataFn(e, t) {
  return t
    ? e
      ? __name(function () {
          return extend$1(
            isFunction$3(e) ? e.call(this, this) : e,
            isFunction$3(t) ? t.call(this, this) : t
          )
        }, 'mergedDataFn')
      : t
    : e
}
function mergeInject(e, t) {
  return mergeObjectOptions(normalizeInject(e), normalizeInject(t))
}
function normalizeInject(e) {
  if (isArray$3(e)) {
    const t = {}
    for (let n = 0; n < e.length; n++) t[e[n]] = e[n]
    return t
  }
  return e
}
function mergeAsArray(e, t) {
  return e ? [...new Set([].concat(e, t))] : t
}
function mergeObjectOptions(e, t) {
  return e ? extend$1(Object.create(null), e, t) : t
}
function mergeEmitsOrPropsOptions(e, t) {
  return e
    ? isArray$3(e) && isArray$3(t)
      ? [...new Set([...e, ...t])]
      : extend$1(
          Object.create(null),
          normalizePropsOrEmits(e),
          normalizePropsOrEmits(null != t ? t : {})
        )
    : t
}
function mergeWatchOptions(e, t) {
  if (!e) return t
  if (!t) return e
  const n = extend$1(Object.create(null), e)
  for (const o in t) n[o] = mergeAsArray(e[o], t[o])
  return n
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap()
  }
}
__name(mergeDataFn, 'mergeDataFn'),
  __name(mergeInject, 'mergeInject'),
  __name(normalizeInject, 'normalizeInject'),
  __name(mergeAsArray, 'mergeAsArray'),
  __name(mergeObjectOptions, 'mergeObjectOptions'),
  __name(mergeEmitsOrPropsOptions, 'mergeEmitsOrPropsOptions'),
  __name(mergeWatchOptions, 'mergeWatchOptions'),
  __name(createAppContext, 'createAppContext')
let uid$1 = 0
function createAppAPI(e, t) {
  return __name(function (n, o = null) {
    isFunction$3(n) || (n = extend$1({}, n)),
      null == o || isObject$4(o) || (o = null)
    const i = createAppContext(),
      r = new WeakSet(),
      a = []
    let s = !1
    const l = (i.app = {
      _uid: uid$1++,
      _component: n,
      _props: o,
      _container: null,
      _context: i,
      _instance: null,
      version: version,
      get config() {
        return i.config
      },
      set config(e) {
        0
      },
      use: (e, ...t) => (
        r.has(e) ||
          (e && isFunction$3(e.install)
            ? (r.add(e), e.install(l, ...t))
            : isFunction$3(e) && (r.add(e), e(l, ...t))),
        l
      ),
      mixin: (e) => (i.mixins.includes(e) || i.mixins.push(e), l),
      component: (e, t) => (t ? ((i.components[e] = t), l) : i.components[e]),
      directive: (e, t) => (t ? ((i.directives[e] = t), l) : i.directives[e]),
      mount(r, a, c) {
        if (!s) {
          0
          const d = l._ceVNode || createVNode(n, o)
          return (
            (d.appContext = i),
            !0 === c ? (c = 'svg') : !1 === c && (c = void 0),
            a && t ? t(d, r) : e(d, r, c),
            (s = !0),
            (l._container = r),
            (r.__vue_app__ = l),
            getComponentPublicInstance(d.component)
          )
        }
      },
      onUnmount(e) {
        a.push(e)
      },
      unmount() {
        s &&
          (callWithAsyncErrorHandling(a, l._instance, 16),
          e(null, l._container),
          delete l._container.__vue_app__)
      },
      provide: (e, t) => ((i.provides[e] = t), l),
      runWithContext(e) {
        const t = currentApp
        currentApp = l
        try {
          return e()
        } finally {
          currentApp = t
        }
      }
    })
    return l
  }, 'createApp')
}
__name(createAppAPI, 'createAppAPI')
let currentApp = null
function provide(e, t) {
  if (currentInstance) {
    let n = currentInstance.provides
    const o = currentInstance.parent && currentInstance.parent.provides
    o === n && (n = currentInstance.provides = Object.create(o)), (n[e] = t)
  } else 0
}
function inject(e, t, n = !1) {
  const o = currentInstance || currentRenderingInstance
  if (o || currentApp) {
    const i = currentApp
      ? currentApp._context.provides
      : o
        ? null == o.parent
          ? o.vnode.appContext && o.vnode.appContext.provides
          : o.parent.provides
        : void 0
    if (i && e in i) return i[e]
    if (arguments.length > 1)
      return n && isFunction$3(t) ? t.call(o && o.proxy) : t
  } else 0
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp)
}
__name(provide, 'provide'),
  __name(inject, 'inject'),
  __name(hasInjectionContext, 'hasInjectionContext')
const internalObjectProto = {},
  createInternalObject = __name(
    () => Object.create(internalObjectProto),
    'createInternalObject'
  ),
  isInternalObject = __name(
    (e) => Object.getPrototypeOf(e) === internalObjectProto,
    'isInternalObject'
  )
function initProps(e, t, n, o = !1) {
  const i = {},
    r = createInternalObject()
  ;(e.propsDefaults = Object.create(null)), setFullProps(e, t, i, r)
  for (const a in e.propsOptions[0]) a in i || (i[a] = void 0)
  n
    ? (e.props = o ? i : shallowReactive(i))
    : e.type.props
      ? (e.props = i)
      : (e.props = r),
    (e.attrs = r)
}
function isInHmrContext(e) {
  for (; e; ) {
    if (e.type.__hmrId) return !0
    e = e.parent
  }
}
function updateProps(e, t, n, o) {
  const {
      props: i,
      attrs: r,
      vnode: { patchFlag: a }
    } = e,
    s = toRaw(i),
    [l] = e.propsOptions
  let c = !1
  if (!(o || a > 0) || 16 & a) {
    let o
    setFullProps(e, t, i, r) && (c = !0)
    for (const r in s)
      (t &&
        (hasOwn$2(t, r) || ((o = hyphenate$1(r)) !== r && hasOwn$2(t, o)))) ||
        (l
          ? !n ||
            (void 0 === n[r] && void 0 === n[o]) ||
            (i[r] = resolvePropValue(l, s, r, void 0, e, !0))
          : delete i[r])
    if (r !== s)
      for (const e in r) (t && hasOwn$2(t, e)) || (delete r[e], (c = !0))
  } else if (8 & a) {
    const n = e.vnode.dynamicProps
    for (let o = 0; o < n.length; o++) {
      let a = n[o]
      if (isEmitListener(e.emitsOptions, a)) continue
      const d = t[a]
      if (l)
        if (hasOwn$2(r, a)) d !== r[a] && ((r[a] = d), (c = !0))
        else {
          const t = camelize$1(a)
          i[t] = resolvePropValue(l, s, t, d, e, !1)
        }
      else d !== r[a] && ((r[a] = d), (c = !0))
    }
  }
  c && trigger(e.attrs, 'set', '')
}
function setFullProps(e, t, n, o) {
  const [i, r] = e.propsOptions
  let a,
    s = !1
  if (t)
    for (let l in t) {
      if (isReservedProp(l)) continue
      const c = t[l]
      let d
      i && hasOwn$2(i, (d = camelize$1(l)))
        ? r && r.includes(d)
          ? ((a || (a = {}))[d] = c)
          : (n[d] = c)
        : isEmitListener(e.emitsOptions, l) ||
          (l in o && c === o[l]) ||
          ((o[l] = c), (s = !0))
    }
  if (r) {
    const t = toRaw(n),
      o = a || EMPTY_OBJ
    for (let a = 0; a < r.length; a++) {
      const s = r[a]
      n[s] = resolvePropValue(i, t, s, o[s], e, !hasOwn$2(o, s))
    }
  }
  return s
}
function resolvePropValue(e, t, n, o, i, r) {
  const a = e[n]
  if (null != a) {
    const e = hasOwn$2(a, 'default')
    if (e && void 0 === o) {
      const e = a.default
      if (a.type !== Function && !a.skipFactory && isFunction$3(e)) {
        const { propsDefaults: r } = i
        if (n in r) o = r[n]
        else {
          const a = setCurrentInstance(i)
          ;(o = r[n] = e.call(null, t)), a()
        }
      } else o = e
      i.ce && i.ce._setProp(n, o)
    }
    a[0] &&
      (r && !e
        ? (o = !1)
        : !a[1] || ('' !== o && o !== hyphenate$1(n)) || (o = !0))
  }
  return o
}
__name(initProps, 'initProps'),
  __name(isInHmrContext, 'isInHmrContext'),
  __name(updateProps, 'updateProps'),
  __name(setFullProps, 'setFullProps'),
  __name(resolvePropValue, 'resolvePropValue')
const mixinPropsCache = new WeakMap()
function normalizePropsOptions(e, t, n = !1) {
  const o = n ? mixinPropsCache : t.propsCache,
    i = o.get(e)
  if (i) return i
  const r = e.props,
    a = {},
    s = []
  let l = !1
  if (!isFunction$3(e)) {
    const o = __name((e) => {
      l = !0
      const [n, o] = normalizePropsOptions(e, t, !0)
      extend$1(a, n), o && s.push(...o)
    }, 'extendProps')
    !n && t.mixins.length && t.mixins.forEach(o),
      e.extends && o(e.extends),
      e.mixins && e.mixins.forEach(o)
  }
  if (!r && !l) return isObject$4(e) && o.set(e, EMPTY_ARR), EMPTY_ARR
  if (isArray$3(r))
    for (let d = 0; d < r.length; d++) {
      0
      const e = camelize$1(r[d])
      validatePropName(e) && (a[e] = EMPTY_OBJ)
    }
  else if (r) {
    0
    for (const e in r) {
      const t = camelize$1(e)
      if (validatePropName(t)) {
        const n = r[e],
          o = (a[t] =
            isArray$3(n) || isFunction$3(n) ? { type: n } : extend$1({}, n)),
          i = o.type
        let l = !1,
          c = !0
        if (isArray$3(i))
          for (let e = 0; e < i.length; ++e) {
            const t = i[e],
              n = isFunction$3(t) && t.name
            if ('Boolean' === n) {
              l = !0
              break
            }
            'String' === n && (c = !1)
          }
        else l = isFunction$3(i) && 'Boolean' === i.name
        ;(o[0] = l), (o[1] = c), (l || hasOwn$2(o, 'default')) && s.push(t)
      }
    }
  }
  const c = [a, s]
  return isObject$4(e) && o.set(e, c), c
}
function validatePropName(e) {
  return '$' !== e[0] && !isReservedProp(e)
}
function getType(e) {
  if (null === e) return 'null'
  if ('function' == typeof e) return e.name || ''
  if ('object' == typeof e) {
    return (e.constructor && e.constructor.name) || ''
  }
  return ''
}
function validateProps(e, t, n) {
  const o = toRaw(t),
    i = n.propsOptions[0],
    r = Object.keys(e).map((e) => camelize$1(e))
  for (const a in i) {
    let e = i[a]
    null != e && validateProp(a, o[a], e, o, !r.includes(a))
  }
}
function validateProp(e, t, n, o, i) {
  const { type: r, required: a, validator: s, skipCheck: l } = n
  if (a && i) warn$1('Missing required prop: "' + e + '"')
  else if (null != t || a) {
    if (null != r && !0 !== r && !l) {
      let n = !1
      const o = isArray$3(r) ? r : [r],
        i = []
      for (let e = 0; e < o.length && !n; e++) {
        const { valid: r, expectedType: a } = assertType(t, o[e])
        i.push(a || ''), (n = r)
      }
      if (!n) return void warn$1(getInvalidTypeMessage(e, t, i))
    }
    s &&
      !s(t, o) &&
      warn$1(
        'Invalid prop: custom validator check failed for prop "' + e + '".'
      )
  }
}
__name(normalizePropsOptions, 'normalizePropsOptions'),
  __name(validatePropName, 'validatePropName'),
  __name(getType, 'getType'),
  __name(validateProps, 'validateProps'),
  __name(validateProp, 'validateProp')
const isSimpleType = makeMap('String,Number,Boolean,Function,Symbol,BigInt')
function assertType(e, t) {
  let n
  const o = getType(t)
  if ('null' === o) n = null === e
  else if (isSimpleType(o)) {
    const i = typeof e
    ;(n = i === o.toLowerCase()), n || 'object' !== i || (n = e instanceof t)
  } else
    n =
      'Object' === o
        ? isObject$4(e)
        : 'Array' === o
          ? isArray$3(e)
          : e instanceof t
  return { valid: n, expectedType: o }
}
function getInvalidTypeMessage(e, t, n) {
  if (0 === n.length)
    return `Prop type [] for prop "${e}" won't match anything. Did you mean to use type Array instead?`
  let o = `Invalid prop: type check failed for prop "${e}". Expected ${n.map(capitalize).join(' | ')}`
  const i = n[0],
    r = toRawType(t),
    a = styleValue(t, i),
    s = styleValue(t, r)
  return (
    1 === n.length &&
      isExplicable(i) &&
      !isBoolean$2(i, r) &&
      (o += ` with value ${a}`),
    (o += `, got ${r} `),
    isExplicable(r) && (o += `with value ${s}.`),
    o
  )
}
function styleValue(e, t) {
  return 'String' === t ? `"${e}"` : 'Number' === t ? `${Number(e)}` : `${e}`
}
function isExplicable(e) {
  return ['string', 'number', 'boolean'].some((t) => e.toLowerCase() === t)
}
function isBoolean$2(...e) {
  return e.some((e) => 'boolean' === e.toLowerCase())
}
__name(assertType, 'assertType'),
  __name(getInvalidTypeMessage, 'getInvalidTypeMessage'),
  __name(styleValue, 'styleValue'),
  __name(isExplicable, 'isExplicable'),
  __name(isBoolean$2, 'isBoolean$2')
const isInternalKey = __name(
    (e) => '_' === e[0] || '$stable' === e,
    'isInternalKey'
  ),
  normalizeSlotValue = __name(
    (e) => (isArray$3(e) ? e.map(normalizeVNode) : [normalizeVNode(e)]),
    'normalizeSlotValue'
  ),
  normalizeSlot = __name((e, t, n) => {
    if (t._n) return t
    const o = withCtx((...e) => normalizeSlotValue(t(...e)), n)
    return (o._c = !1), o
  }, 'normalizeSlot'),
  normalizeObjectSlots = __name((e, t, n) => {
    const o = e._ctx
    for (const i in e) {
      if (isInternalKey(i)) continue
      const n = e[i]
      if (isFunction$3(n)) t[i] = normalizeSlot(i, n, o)
      else if (null != n) {
        0
        const e = normalizeSlotValue(n)
        t[i] = () => e
      }
    }
  }, 'normalizeObjectSlots'),
  normalizeVNodeSlots = __name((e, t) => {
    const n = normalizeSlotValue(t)
    e.slots.default = () => n
  }, 'normalizeVNodeSlots'),
  assignSlots = __name((e, t, n) => {
    for (const o in t) (n || '_' !== o) && (e[o] = t[o])
  }, 'assignSlots'),
  initSlots = __name((e, t, n) => {
    const o = (e.slots = createInternalObject())
    if (32 & e.vnode.shapeFlag) {
      const e = t._
      e
        ? (assignSlots(o, t, n), n && def(o, '_', e, !0))
        : normalizeObjectSlots(t, o)
    } else t && normalizeVNodeSlots(e, t)
  }, 'initSlots'),
  updateSlots = __name((e, t, n) => {
    const { vnode: o, slots: i } = e
    let r = !0,
      a = EMPTY_OBJ
    if (32 & o.shapeFlag) {
      const e = t._
      e
        ? n && 1 === e
          ? (r = !1)
          : assignSlots(i, t, n)
        : ((r = !t.$stable), normalizeObjectSlots(t, i)),
        (a = t)
    } else t && (normalizeVNodeSlots(e, t), (a = { default: 1 }))
    if (r) for (const s in i) isInternalKey(s) || null != a[s] || delete i[s]
  }, 'updateSlots')
let supported$1, perf$1
function startMeasure(e, t) {
  e.appContext.config.performance &&
    isSupported() &&
    perf$1.mark(`vue-${t}-${e.uid}`)
}
function endMeasure(e, t) {
  if (e.appContext.config.performance && isSupported()) {
    const n = `vue-${t}-${e.uid}`,
      o = n + ':end'
    perf$1.mark(o),
      perf$1.measure(`<${formatComponentName(e, e.type)}> ${t}`, n, o),
      perf$1.clearMarks(n),
      perf$1.clearMarks(o)
  }
}
function isSupported() {
  return (
    void 0 !== supported$1 ||
      ('undefined' != typeof window && window.performance
        ? ((supported$1 = !0), (perf$1 = window.performance))
        : (supported$1 = !1)),
    supported$1
  )
}
function initFeatureFlags() {}
__name(startMeasure, 'startMeasure'),
  __name(endMeasure, 'endMeasure'),
  __name(isSupported, 'isSupported'),
  __name(initFeatureFlags, 'initFeatureFlags')
const queuePostRenderEffect = queueEffectWithSuspense
function createRenderer(e) {
  return baseCreateRenderer(e)
}
function createHydrationRenderer(e) {
  return baseCreateRenderer(e, createHydrationFunctions)
}
function baseCreateRenderer(e, t) {
  initFeatureFlags()
  const n = getGlobalThis()
  n.__VUE__ = !0
  const {
      insert: o,
      remove: i,
      patchProp: r,
      createElement: a,
      createText: s,
      createComment: l,
      setText: c,
      setElementText: d,
      parentNode: u,
      nextSibling: p,
      setScopeId: h = NOOP,
      insertStaticContent: m
    } = e,
    f = __name(
      (
        e,
        t,
        n,
        o = null,
        i = null,
        r = null,
        a = void 0,
        s = null,
        l = !!t.dynamicChildren
      ) => {
        if (e === t) return
        e && !isSameVNodeType(e, t) && ((o = j(e)), M(e, i, r, !0), (e = null)),
          -2 === t.patchFlag && ((l = !1), (t.dynamicChildren = null))
        const { type: c, ref: d, shapeFlag: u } = t
        switch (c) {
          case Text$1:
            _(e, t, n, o)
            break
          case Comment:
            g(e, t, n, o)
            break
          case Static:
            null == e && v(t, n, o, a)
            break
          case Fragment:
            T(e, t, n, o, i, r, a, s, l)
            break
          default:
            1 & u
              ? S(e, t, n, o, i, r, a, s, l)
              : 6 & u
                ? $(e, t, n, o, i, r, a, s, l)
                : (64 & u || 128 & u) && c.process(e, t, n, o, i, r, a, s, l, W)
        }
        null != d && i && setRef(d, e && e.ref, r, t || e, !t)
      },
      'patch'
    ),
    _ = __name((e, t, n, i) => {
      if (null == e) o((t.el = s(t.children)), n, i)
      else {
        const n = (t.el = e.el)
        t.children !== e.children && c(n, t.children)
      }
    }, 'processText'),
    g = __name((e, t, n, i) => {
      null == e ? o((t.el = l(t.children || '')), n, i) : (t.el = e.el)
    }, 'processCommentNode'),
    v = __name((e, t, n, o) => {
      ;[e.el, e.anchor] = m(e.children, t, n, o, e.el, e.anchor)
    }, 'mountStaticNode'),
    y = __name(({ el: e, anchor: t }, n, i) => {
      let r
      for (; e && e !== t; ) (r = p(e)), o(e, n, i), (e = r)
      o(t, n, i)
    }, 'moveStaticNode'),
    b = __name(({ el: e, anchor: t }) => {
      let n
      for (; e && e !== t; ) (n = p(e)), i(e), (e = n)
      i(t)
    }, 'removeStaticNode'),
    S = __name((e, t, n, o, i, r, a, s, l) => {
      'svg' === t.type ? (a = 'svg') : 'math' === t.type && (a = 'mathml'),
        null == e ? C(t, n, o, i, r, a, s, l) : x(e, t, i, r, a, s, l)
    }, 'processElement'),
    C = __name((e, t, n, i, s, l, c, u) => {
      let p, h
      const { props: m, shapeFlag: f, transition: _, dirs: g } = e
      if (
        ((p = e.el = a(e.type, l, m && m.is, m)),
        8 & f
          ? d(p, e.children)
          : 16 & f &&
            k(e.children, p, null, i, s, resolveChildrenNamespace(e, l), c, u),
        g && invokeDirectiveHook(e, null, i, 'created'),
        w(p, e, e.scopeId, c, i),
        m)
      ) {
        for (const e in m)
          'value' === e || isReservedProp(e) || r(p, e, null, m[e], l, i)
        'value' in m && r(p, 'value', null, m.value, l),
          (h = m.onVnodeBeforeMount) && invokeVNodeHook(h, i, e)
      }
      g && invokeDirectiveHook(e, null, i, 'beforeMount')
      const v = needTransition(s, _)
      v && _.beforeEnter(p),
        o(p, t, n),
        ((h = m && m.onVnodeMounted) || v || g) &&
          queuePostRenderEffect(() => {
            h && invokeVNodeHook(h, i, e),
              v && _.enter(p),
              g && invokeDirectiveHook(e, null, i, 'mounted')
          }, s)
    }, 'mountElement'),
    w = __name((e, t, n, o, i) => {
      if ((n && h(e, n), o)) for (let r = 0; r < o.length; r++) h(e, o[r])
      if (i) {
        let n = i.subTree
        if (
          t === n ||
          (isSuspense(n.type) && (n.ssContent === t || n.ssFallback === t))
        ) {
          const t = i.vnode
          w(e, t, t.scopeId, t.slotScopeIds, i.parent)
        }
      }
    }, 'setScopeId'),
    k = __name((e, t, n, o, i, r, a, s, l = 0) => {
      for (let c = l; c < e.length; c++) {
        const l = (e[c] = s ? cloneIfMounted(e[c]) : normalizeVNode(e[c]))
        f(null, l, t, n, o, i, r, a, s)
      }
    }, 'mountChildren'),
    x = __name((e, t, n, o, i, a, s) => {
      const l = (t.el = e.el)
      let { patchFlag: c, dynamicChildren: u, dirs: p } = t
      c |= 16 & e.patchFlag
      const h = e.props || EMPTY_OBJ,
        m = t.props || EMPTY_OBJ
      let f
      if (
        (n && toggleRecurse(n, !1),
        (f = m.onVnodeBeforeUpdate) && invokeVNodeHook(f, n, t, e),
        p && invokeDirectiveHook(t, e, n, 'beforeUpdate'),
        n && toggleRecurse(n, !0),
        ((h.innerHTML && null == m.innerHTML) ||
          (h.textContent && null == m.textContent)) &&
          d(l, ''),
        u
          ? E(e.dynamicChildren, u, l, n, o, resolveChildrenNamespace(t, i), a)
          : s || V(e, t, l, null, n, o, resolveChildrenNamespace(t, i), a, !1),
        c > 0)
      ) {
        if (16 & c) I(l, h, m, n, i)
        else if (
          (2 & c && h.class !== m.class && r(l, 'class', null, m.class, i),
          4 & c && r(l, 'style', h.style, m.style, i),
          8 & c)
        ) {
          const e = t.dynamicProps
          for (let t = 0; t < e.length; t++) {
            const o = e[t],
              a = h[o],
              s = m[o]
            ;(s === a && 'value' !== o) || r(l, o, a, s, i, n)
          }
        }
        1 & c && e.children !== t.children && d(l, t.children)
      } else s || null != u || I(l, h, m, n, i)
      ;((f = m.onVnodeUpdated) || p) &&
        queuePostRenderEffect(() => {
          f && invokeVNodeHook(f, n, t, e),
            p && invokeDirectiveHook(t, e, n, 'updated')
        }, o)
    }, 'patchElement'),
    E = __name((e, t, n, o, i, r, a) => {
      for (let s = 0; s < t.length; s++) {
        const l = e[s],
          c = t[s],
          d =
            l.el &&
            (l.type === Fragment || !isSameVNodeType(l, c) || 70 & l.shapeFlag)
              ? u(l.el)
              : n
        f(l, c, d, null, o, i, r, a, !0)
      }
    }, 'patchBlockChildren'),
    I = __name((e, t, n, o, i) => {
      if (t !== n) {
        if (t !== EMPTY_OBJ)
          for (const a in t)
            isReservedProp(a) || a in n || r(e, a, t[a], null, i, o)
        for (const a in n) {
          if (isReservedProp(a)) continue
          const s = n[a],
            l = t[a]
          s !== l && 'value' !== a && r(e, a, l, s, i, o)
        }
        'value' in n && r(e, 'value', t.value, n.value, i)
      }
    }, 'patchProps'),
    T = __name((e, t, n, i, r, a, l, c, d) => {
      const u = (t.el = e ? e.el : s('')),
        p = (t.anchor = e ? e.anchor : s(''))
      let { patchFlag: h, dynamicChildren: m, slotScopeIds: f } = t
      f && (c = c ? c.concat(f) : f),
        null == e
          ? (o(u, n, i), o(p, n, i), k(t.children || [], n, p, r, a, l, c, d))
          : h > 0 && 64 & h && m && e.dynamicChildren
            ? (E(e.dynamicChildren, m, n, r, a, l, c),
              (null != t.key || (r && t === r.subTree)) &&
                traverseStaticChildren(e, t, !0))
            : V(e, t, n, p, r, a, l, c, d)
    }, 'processFragment'),
    $ = __name((e, t, n, o, i, r, a, s, l) => {
      ;(t.slotScopeIds = s),
        null == e
          ? 512 & t.shapeFlag
            ? i.ctx.activate(t, n, o, a, l)
            : L(t, n, o, i, r, a, l)
          : A(e, t, l)
    }, 'processComponent'),
    L = __name((e, t, n, o, i, r, a) => {
      const s = (e.component = createComponentInstance(e, o, i))
      if (
        (isKeepAlive(e) && (s.ctx.renderer = W),
        setupComponent(s, !1, a),
        s.asyncDep)
      ) {
        if ((i && i.registerDep(s, O, a), !e.el)) {
          const e = (s.subTree = createVNode(Comment))
          g(null, e, t, n)
        }
      } else O(s, e, t, n, i, r, a)
    }, 'mountComponent'),
    A = __name((e, t, n) => {
      const o = (t.component = e.component)
      if (shouldUpdateComponent(e, t, n)) {
        if (o.asyncDep && !o.asyncResolved) return void P(o, t, n)
        ;(o.next = t), o.update()
      } else (t.el = e.el), (o.vnode = t)
    }, 'updateComponent'),
    O = __name((e, t, n, o, i, r, a) => {
      const s = __name(() => {
        if (e.isMounted) {
          let { next: t, bu: n, u: o, parent: l, vnode: c } = e
          {
            const n = locateNonHydratedAsyncRoot(e)
            if (n)
              return (
                t && ((t.el = c.el), P(e, t, a)),
                void n.asyncDep.then(() => {
                  e.isUnmounted || s()
                })
              )
          }
          let d,
            p = t
          0,
            toggleRecurse(e, !1),
            t ? ((t.el = c.el), P(e, t, a)) : (t = c),
            n && invokeArrayFns(n),
            (d = t.props && t.props.onVnodeBeforeUpdate) &&
              invokeVNodeHook(d, l, t, c),
            toggleRecurse(e, !0)
          const h = renderComponentRoot(e)
          0
          const m = e.subTree
          ;(e.subTree = h),
            f(m, h, u(m.el), j(m), e, i, r),
            (t.el = h.el),
            null === p && updateHOCHostEl(e, h.el),
            o && queuePostRenderEffect(o, i),
            (d = t.props && t.props.onVnodeUpdated) &&
              queuePostRenderEffect(() => invokeVNodeHook(d, l, t, c), i)
        } else {
          let a
          const { el: s, props: l } = t,
            { bm: c, m: d, parent: u, root: p, type: h } = e,
            m = isAsyncWrapper(t)
          if (
            (toggleRecurse(e, !1),
            c && invokeArrayFns(c),
            !m && (a = l && l.onVnodeBeforeMount) && invokeVNodeHook(a, u, t),
            toggleRecurse(e, !0),
            s && Z)
          ) {
            const t = __name(() => {
              ;(e.subTree = renderComponentRoot(e)), Z(s, e.subTree, e, i, null)
            }, 'hydrateSubTree')
            m && h.__asyncHydrate ? h.__asyncHydrate(s, e, t) : t()
          } else {
            p.ce && p.ce._injectChildStyle(h)
            const a = (e.subTree = renderComponentRoot(e))
            0, f(null, a, n, o, e, i, r), (t.el = a.el)
          }
          if (
            (d && queuePostRenderEffect(d, i),
            !m && (a = l && l.onVnodeMounted))
          ) {
            const e = t
            queuePostRenderEffect(() => invokeVNodeHook(a, u, e), i)
          }
          ;(256 & t.shapeFlag ||
            (u && isAsyncWrapper(u.vnode) && 256 & u.vnode.shapeFlag)) &&
            e.a &&
            queuePostRenderEffect(e.a, i),
            (e.isMounted = !0),
            (t = n = o = null)
        }
      }, 'componentUpdateFn')
      e.scope.on()
      const l = (e.effect = new ReactiveEffect(s))
      e.scope.off()
      const c = (e.update = l.run.bind(l)),
        d = (e.job = l.runIfDirty.bind(l))
      ;(d.i = e),
        (d.id = e.uid),
        (l.scheduler = () => queueJob(d)),
        toggleRecurse(e, !0),
        c()
    }, 'setupRenderEffect'),
    P = __name((e, t, n) => {
      t.component = e
      const o = e.vnode.props
      ;(e.vnode = t),
        (e.next = null),
        updateProps(e, t.props, o, n),
        updateSlots(e, t.children, n),
        pauseTracking(),
        flushPreFlushCbs(e),
        resetTracking()
    }, 'updateComponentPreRender'),
    V = __name((e, t, n, o, i, r, a, s, l = !1) => {
      const c = e && e.children,
        u = e ? e.shapeFlag : 0,
        p = t.children,
        { patchFlag: h, shapeFlag: m } = t
      if (h > 0) {
        if (128 & h) return void R(c, p, n, o, i, r, a, s, l)
        if (256 & h) return void D(c, p, n, o, i, r, a, s, l)
      }
      8 & m
        ? (16 & u && H(c, i, r), p !== c && d(n, p))
        : 16 & u
          ? 16 & m
            ? R(c, p, n, o, i, r, a, s, l)
            : H(c, i, r, !0)
          : (8 & u && d(n, ''), 16 & m && k(p, n, o, i, r, a, s, l))
    }, 'patchChildren'),
    D = __name((e, t, n, o, i, r, a, s, l) => {
      t = t || EMPTY_ARR
      const c = (e = e || EMPTY_ARR).length,
        d = t.length,
        u = Math.min(c, d)
      let p
      for (p = 0; p < u; p++) {
        const o = (t[p] = l ? cloneIfMounted(t[p]) : normalizeVNode(t[p]))
        f(e[p], o, n, null, i, r, a, s, l)
      }
      c > d ? H(e, i, r, !0, !1, u) : k(t, n, o, i, r, a, s, l, u)
    }, 'patchUnkeyedChildren'),
    R = __name((e, t, n, o, i, r, a, s, l) => {
      let c = 0
      const d = t.length
      let u = e.length - 1,
        p = d - 1
      for (; c <= u && c <= p; ) {
        const o = e[c],
          d = (t[c] = l ? cloneIfMounted(t[c]) : normalizeVNode(t[c]))
        if (!isSameVNodeType(o, d)) break
        f(o, d, n, null, i, r, a, s, l), c++
      }
      for (; c <= u && c <= p; ) {
        const o = e[u],
          c = (t[p] = l ? cloneIfMounted(t[p]) : normalizeVNode(t[p]))
        if (!isSameVNodeType(o, c)) break
        f(o, c, n, null, i, r, a, s, l), u--, p--
      }
      if (c > u) {
        if (c <= p) {
          const e = p + 1,
            u = e < d ? t[e].el : o
          for (; c <= p; )
            f(
              null,
              (t[c] = l ? cloneIfMounted(t[c]) : normalizeVNode(t[c])),
              n,
              u,
              i,
              r,
              a,
              s,
              l
            ),
              c++
        }
      } else if (c > p) for (; c <= u; ) M(e[c], i, r, !0), c++
      else {
        const h = c,
          m = c,
          _ = new Map()
        for (c = m; c <= p; c++) {
          const e = (t[c] = l ? cloneIfMounted(t[c]) : normalizeVNode(t[c]))
          null != e.key && _.set(e.key, c)
        }
        let g,
          v = 0
        const y = p - m + 1
        let b = !1,
          S = 0
        const C = new Array(y)
        for (c = 0; c < y; c++) C[c] = 0
        for (c = h; c <= u; c++) {
          const o = e[c]
          if (v >= y) {
            M(o, i, r, !0)
            continue
          }
          let d
          if (null != o.key) d = _.get(o.key)
          else
            for (g = m; g <= p; g++)
              if (0 === C[g - m] && isSameVNodeType(o, t[g])) {
                d = g
                break
              }
          void 0 === d
            ? M(o, i, r, !0)
            : ((C[d - m] = c + 1),
              d >= S ? (S = d) : (b = !0),
              f(o, t[d], n, null, i, r, a, s, l),
              v++)
        }
        const w = b ? getSequence(C) : EMPTY_ARR
        for (g = w.length - 1, c = y - 1; c >= 0; c--) {
          const e = m + c,
            u = t[e],
            p = e + 1 < d ? t[e + 1].el : o
          0 === C[c]
            ? f(null, u, n, p, i, r, a, s, l)
            : b && (g < 0 || c !== w[g] ? N(u, n, p, 2) : g--)
        }
      }
    }, 'patchKeyedChildren'),
    N = __name((e, t, n, i, r = null) => {
      const { el: a, type: s, transition: l, children: c, shapeFlag: d } = e
      if (6 & d) return void N(e.component.subTree, t, n, i)
      if (128 & d) return void e.suspense.move(t, n, i)
      if (64 & d) return void s.move(e, t, n, W)
      if (s === Fragment) {
        o(a, t, n)
        for (let e = 0; e < c.length; e++) N(c[e], t, n, i)
        return void o(e.anchor, t, n)
      }
      if (s === Static) return void y(e, t, n)
      if (2 !== i && 1 & d && l)
        if (0 === i)
          l.beforeEnter(a),
            o(a, t, n),
            queuePostRenderEffect(() => l.enter(a), r)
        else {
          const { leave: e, delayLeave: i, afterLeave: r } = l,
            s = __name(() => o(a, t, n), 'remove22'),
            c = __name(() => {
              e(a, () => {
                s(), r && r()
              })
            }, 'performLeave')
          i ? i(a, s, c) : c()
        }
      else o(a, t, n)
    }, 'move'),
    M = __name((e, t, n, o = !1, i = !1) => {
      const {
        type: r,
        props: a,
        ref: s,
        children: l,
        dynamicChildren: c,
        shapeFlag: d,
        patchFlag: u,
        dirs: p,
        cacheIndex: h
      } = e
      if (
        (-2 === u && (i = !1),
        null != s && setRef(s, null, n, e, !0),
        null != h && (t.renderCache[h] = void 0),
        256 & d)
      )
        return void t.ctx.deactivate(e)
      const m = 1 & d && p,
        f = !isAsyncWrapper(e)
      let _
      if (
        (f && (_ = a && a.onVnodeBeforeUnmount) && invokeVNodeHook(_, t, e),
        6 & d)
      )
        z(e.component, n, o)
      else {
        if (128 & d) return void e.suspense.unmount(n, o)
        m && invokeDirectiveHook(e, null, t, 'beforeUnmount'),
          64 & d
            ? e.type.remove(e, t, n, W, o)
            : c && !c.hasOnce && (r !== Fragment || (u > 0 && 64 & u))
              ? H(c, t, n, !1, !0)
              : ((r === Fragment && 384 & u) || (!i && 16 & d)) && H(l, t, n),
          o && B(e)
      }
      ;((f && (_ = a && a.onVnodeUnmounted)) || m) &&
        queuePostRenderEffect(() => {
          _ && invokeVNodeHook(_, t, e),
            m && invokeDirectiveHook(e, null, t, 'unmounted')
        }, n)
    }, 'unmount'),
    B = __name((e) => {
      const { type: t, el: n, anchor: o, transition: r } = e
      if (t === Fragment) return void F(n, o)
      if (t === Static) return void b(e)
      const a = __name(() => {
        i(n), r && !r.persisted && r.afterLeave && r.afterLeave()
      }, 'performRemove')
      if (1 & e.shapeFlag && r && !r.persisted) {
        const { leave: t, delayLeave: o } = r,
          i = __name(() => t(n, a), 'performLeave')
        o ? o(e.el, a, i) : i()
      } else a()
    }, 'remove2'),
    F = __name((e, t) => {
      let n
      for (; e !== t; ) (n = p(e)), i(e), (e = n)
      i(t)
    }, 'removeFragment'),
    z = __name((e, t, n) => {
      const { bum: o, scope: i, job: r, subTree: a, um: s, m: l, a: c } = e
      invalidateMount(l),
        invalidateMount(c),
        o && invokeArrayFns(o),
        i.stop(),
        r && ((r.flags |= 8), M(a, e, t, n)),
        s && queuePostRenderEffect(s, t),
        queuePostRenderEffect(() => {
          e.isUnmounted = !0
        }, t),
        t &&
          t.pendingBranch &&
          !t.isUnmounted &&
          e.asyncDep &&
          !e.asyncResolved &&
          e.suspenseId === t.pendingId &&
          (t.deps--, 0 === t.deps && t.resolve())
    }, 'unmountComponent'),
    H = __name((e, t, n, o = !1, i = !1, r = 0) => {
      for (let a = r; a < e.length; a++) M(e[a], t, n, o, i)
    }, 'unmountChildren'),
    j = __name((e) => {
      if (6 & e.shapeFlag) return j(e.component.subTree)
      if (128 & e.shapeFlag) return e.suspense.next()
      const t = p(e.anchor || e.el),
        n = t && t[TeleportEndKey]
      return n ? p(n) : t
    }, 'getNextHostNode')
  let U = !1
  const G = __name((e, t, n) => {
      null == e
        ? t._vnode && M(t._vnode, null, null, !0)
        : f(t._vnode || null, e, t, null, null, null, n),
        (t._vnode = e),
        U || ((U = !0), flushPreFlushCbs(), flushPostFlushCbs(), (U = !1))
    }, 'render'),
    W = { p: f, um: M, m: N, r: B, mt: L, mc: k, pc: V, pbc: E, n: j, o: e }
  let K, Z
  return (
    t && ([K, Z] = t(W)),
    { render: G, hydrate: K, createApp: createAppAPI(G, K) }
  )
}
function resolveChildrenNamespace({ type: e, props: t }, n) {
  return ('svg' === n && 'foreignObject' === e) ||
    ('mathml' === n &&
      'annotation-xml' === e &&
      t &&
      t.encoding &&
      t.encoding.includes('html'))
    ? void 0
    : n
}
function toggleRecurse({ effect: e, job: t }, n) {
  n ? ((e.flags |= 32), (t.flags |= 4)) : ((e.flags &= -33), (t.flags &= -5))
}
function needTransition(e, t) {
  return (!e || (e && !e.pendingBranch)) && t && !t.persisted
}
function traverseStaticChildren(e, t, n = !1) {
  const o = e.children,
    i = t.children
  if (isArray$3(o) && isArray$3(i))
    for (let r = 0; r < o.length; r++) {
      const e = o[r]
      let t = i[r]
      1 & t.shapeFlag &&
        !t.dynamicChildren &&
        ((t.patchFlag <= 0 || 32 === t.patchFlag) &&
          ((t = i[r] = cloneIfMounted(i[r])), (t.el = e.el)),
        n || -2 === t.patchFlag || traverseStaticChildren(e, t)),
        t.type === Text$1 && (t.el = e.el)
    }
}
function getSequence(e) {
  const t = e.slice(),
    n = [0]
  let o, i, r, a, s
  const l = e.length
  for (o = 0; o < l; o++) {
    const l = e[o]
    if (0 !== l) {
      if (((i = n[n.length - 1]), e[i] < l)) {
        ;(t[o] = i), n.push(o)
        continue
      }
      for (r = 0, a = n.length - 1; r < a; )
        (s = (r + a) >> 1), e[n[s]] < l ? (r = s + 1) : (a = s)
      l < e[n[r]] && (r > 0 && (t[o] = n[r - 1]), (n[r] = o))
    }
  }
  for (r = n.length, a = n[r - 1]; r-- > 0; ) (n[r] = a), (a = t[a])
  return n
}
function locateNonHydratedAsyncRoot(e) {
  const t = e.subTree.component
  if (t)
    return t.asyncDep && !t.asyncResolved ? t : locateNonHydratedAsyncRoot(t)
}
function invalidateMount(e) {
  if (e) for (let t = 0; t < e.length; t++) e[t].flags |= 8
}
__name(createRenderer, 'createRenderer'),
  __name(createHydrationRenderer, 'createHydrationRenderer'),
  __name(baseCreateRenderer, 'baseCreateRenderer'),
  __name(resolveChildrenNamespace, 'resolveChildrenNamespace'),
  __name(toggleRecurse, 'toggleRecurse'),
  __name(needTransition, 'needTransition'),
  __name(traverseStaticChildren, 'traverseStaticChildren'),
  __name(getSequence, 'getSequence'),
  __name(locateNonHydratedAsyncRoot, 'locateNonHydratedAsyncRoot'),
  __name(invalidateMount, 'invalidateMount')
const ssrContextKey = Symbol.for('v-scx'),
  useSSRContext = __name(() => {
    {
      const e = inject(ssrContextKey)
      return e
    }
  }, 'useSSRContext')
function watchEffect(e, t) {
  return doWatch(e, null, t)
}
function watchPostEffect(e, t) {
  return doWatch(e, null, { flush: 'post' })
}
function watchSyncEffect(e, t) {
  return doWatch(e, null, { flush: 'sync' })
}
function watch(e, t, n) {
  return doWatch(e, t, n)
}
function doWatch(e, t, n = EMPTY_OBJ) {
  const { immediate: o, deep: i, flush: r, once: a } = n
  const s = extend$1({}, n)
  const l = (t && o) || (!t && 'post' !== r)
  let c
  if (isInSSRComponentSetup)
    if ('sync' === r) {
      const e = useSSRContext()
      c = e.__watcherHandles || (e.__watcherHandles = [])
    } else if (!l) {
      const e = __name(() => {}, 'watchStopHandle')
      return (e.stop = NOOP), (e.resume = NOOP), (e.pause = NOOP), e
    }
  const d = currentInstance
  s.call = (e, t, n) => callWithAsyncErrorHandling(e, d, t, n)
  let u = !1
  'post' === r
    ? (s.scheduler = (e) => {
        queuePostRenderEffect(e, d && d.suspense)
      })
    : 'sync' !== r &&
      ((u = !0),
      (s.scheduler = (e, t) => {
        t ? e() : queueJob(e)
      })),
    (s.augmentJob = (e) => {
      t && (e.flags |= 4),
        u && ((e.flags |= 2), d && ((e.id = d.uid), (e.i = d)))
    })
  const p = watch$1(e, t, s)
  return isInSSRComponentSetup && (c ? c.push(p) : l && p()), p
}
function instanceWatch(e, t, n) {
  const o = this.proxy,
    i = isString$3(e)
      ? e.includes('.')
        ? createPathGetter(o, e)
        : () => o[e]
      : e.bind(o, o)
  let r
  isFunction$3(t) ? (r = t) : ((r = t.handler), (n = t))
  const a = setCurrentInstance(this),
    s = doWatch(i, r.bind(o), n)
  return a(), s
}
function createPathGetter(e, t) {
  const n = t.split('.')
  return () => {
    let t = e
    for (let e = 0; e < n.length && t; e++) t = t[n[e]]
    return t
  }
}
function useModel(e, t, n = EMPTY_OBJ) {
  const o = getCurrentInstance()
  const i = camelize$1(t)
  const r = hyphenate$1(t),
    a = getModelModifiers(e, i),
    s = customRef((a, s) => {
      let l,
        c,
        d = EMPTY_OBJ
      return (
        watchSyncEffect(() => {
          const t = e[i]
          hasChanged(l, t) && ((l = t), s())
        }),
        {
          get: () => (a(), n.get ? n.get(l) : l),
          set(e) {
            const a = n.set ? n.set(e) : e
            if (!(hasChanged(a, l) || (d !== EMPTY_OBJ && hasChanged(e, d))))
              return
            const u = o.vnode.props
            ;(u &&
              (t in u || i in u || r in u) &&
              (`onUpdate:${t}` in u ||
                `onUpdate:${i}` in u ||
                `onUpdate:${r}` in u)) ||
              ((l = e), s()),
              o.emit(`update:${t}`, a),
              hasChanged(e, a) && hasChanged(e, d) && !hasChanged(a, c) && s(),
              (d = e),
              (c = a)
          }
        }
      )
    })
  return (
    (s[Symbol.iterator] = () => {
      let e = 0
      return {
        next: () =>
          e < 2 ? { value: e++ ? a || EMPTY_OBJ : s, done: !1 } : { done: !0 }
      }
    }),
    s
  )
}
__name(watchEffect, 'watchEffect'),
  __name(watchPostEffect, 'watchPostEffect'),
  __name(watchSyncEffect, 'watchSyncEffect'),
  __name(watch, 'watch'),
  __name(doWatch, 'doWatch'),
  __name(instanceWatch, 'instanceWatch'),
  __name(createPathGetter, 'createPathGetter'),
  __name(useModel, 'useModel')
const getModelModifiers = __name(
  (e, t) =>
    'modelValue' === t || 'model-value' === t
      ? e.modelModifiers
      : e[`${t}Modifiers`] ||
        e[`${camelize$1(t)}Modifiers`] ||
        e[`${hyphenate$1(t)}Modifiers`],
  'getModelModifiers'
)
function emit(e, t, ...n) {
  if (e.isUnmounted) return
  const o = e.vnode.props || EMPTY_OBJ
  let i = n
  const r = t.startsWith('update:'),
    a = r && getModelModifiers(o, t.slice(7))
  let s
  a &&
    (a.trim && (i = n.map((e) => (isString$3(e) ? e.trim() : e))),
    a.number && (i = n.map(looseToNumber)))
  let l = o[(s = toHandlerKey(t))] || o[(s = toHandlerKey(camelize$1(t)))]
  !l && r && (l = o[(s = toHandlerKey(hyphenate$1(t)))]),
    l && callWithAsyncErrorHandling(l, e, 6, i)
  const c = o[s + 'Once']
  if (c) {
    if (e.emitted) {
      if (e.emitted[s]) return
    } else e.emitted = {}
    ;(e.emitted[s] = !0), callWithAsyncErrorHandling(c, e, 6, i)
  }
}
function normalizeEmitsOptions(e, t, n = !1) {
  const o = t.emitsCache,
    i = o.get(e)
  if (void 0 !== i) return i
  const r = e.emits
  let a = {},
    s = !1
  if (!isFunction$3(e)) {
    const o = __name((e) => {
      const n = normalizeEmitsOptions(e, t, !0)
      n && ((s = !0), extend$1(a, n))
    }, 'extendEmits')
    !n && t.mixins.length && t.mixins.forEach(o),
      e.extends && o(e.extends),
      e.mixins && e.mixins.forEach(o)
  }
  return r || s
    ? (isArray$3(r) ? r.forEach((e) => (a[e] = null)) : extend$1(a, r),
      isObject$4(e) && o.set(e, a),
      a)
    : (isObject$4(e) && o.set(e, null), null)
}
function isEmitListener(e, t) {
  return (
    !(!e || !isOn(t)) &&
    ((t = t.slice(2).replace(/Once$/, '')),
    hasOwn$2(e, t[0].toLowerCase() + t.slice(1)) ||
      hasOwn$2(e, hyphenate$1(t)) ||
      hasOwn$2(e, t))
  )
}
__name(emit, 'emit'),
  __name(normalizeEmitsOptions, 'normalizeEmitsOptions'),
  __name(isEmitListener, 'isEmitListener')
let accessedAttrs = !1
function markAttrsAccessed() {
  accessedAttrs = !0
}
function renderComponentRoot(e) {
  const {
      type: t,
      vnode: n,
      proxy: o,
      withProxy: i,
      propsOptions: [r],
      slots: a,
      attrs: s,
      emit: l,
      render: c,
      renderCache: d,
      props: u,
      data: p,
      setupState: h,
      ctx: m,
      inheritAttrs: f
    } = e,
    _ = setCurrentRenderingInstance(e)
  let g, v
  try {
    if (4 & n.shapeFlag) {
      const e = i || o,
        t = e
      ;(g = normalizeVNode(c.call(t, e, d, u, h, p, m))), (v = s)
    } else {
      const e = t
      0,
        (g = normalizeVNode(
          e.length > 1 ? e(u, { attrs: s, slots: a, emit: l }) : e(u, null)
        )),
        (v = t.props ? s : getFunctionalFallthrough(s))
    }
  } catch (b) {
    ;(blockStack.length = 0), handleError(b, e, 1), (g = createVNode(Comment))
  }
  let y = g
  if (v && !1 !== f) {
    const e = Object.keys(v),
      { shapeFlag: t } = y
    e.length &&
      7 & t &&
      (r && e.some(isModelListener) && (v = filterModelListeners(v, r)),
      (y = cloneVNode(y, v, !1, !0)))
  }
  return (
    n.dirs &&
      ((y = cloneVNode(y, null, !1, !0)),
      (y.dirs = y.dirs ? y.dirs.concat(n.dirs) : n.dirs)),
    n.transition && setTransitionHooks(y, n.transition),
    (g = y),
    setCurrentRenderingInstance(_),
    g
  )
}
__name(markAttrsAccessed, 'markAttrsAccessed'),
  __name(renderComponentRoot, 'renderComponentRoot')
const getChildRoot = __name((e) => {
  const t = e.children,
    n = e.dynamicChildren,
    o = filterSingleRoot(t, !1)
  if (!o) return [e, void 0]
  const i = t.indexOf(o),
    r = n ? n.indexOf(o) : -1,
    a = __name((o) => {
      ;(t[i] = o),
        n &&
          (r > -1
            ? (n[r] = o)
            : o.patchFlag > 0 && (e.dynamicChildren = [...n, o]))
    }, 'setRoot')
  return [normalizeVNode(o), a]
}, 'getChildRoot')
function filterSingleRoot(e, t = !0) {
  let n
  for (let o = 0; o < e.length; o++) {
    const t = e[o]
    if (!isVNode(t)) return
    if (t.type !== Comment || 'v-if' === t.children) {
      if (n) return
      n = t
    }
  }
  return n
}
__name(filterSingleRoot, 'filterSingleRoot')
const getFunctionalFallthrough = __name((e) => {
    let t
    for (const n in e)
      ('class' === n || 'style' === n || isOn(n)) && ((t || (t = {}))[n] = e[n])
    return t
  }, 'getFunctionalFallthrough'),
  filterModelListeners = __name((e, t) => {
    const n = {}
    for (const o in e) (isModelListener(o) && o.slice(9) in t) || (n[o] = e[o])
    return n
  }, 'filterModelListeners'),
  isElementRoot = __name(
    (e) => 7 & e.shapeFlag || e.type === Comment,
    'isElementRoot'
  )
function shouldUpdateComponent(e, t, n) {
  const { props: o, children: i, component: r } = e,
    { props: a, children: s, patchFlag: l } = t,
    c = r.emitsOptions
  if (t.dirs || t.transition) return !0
  if (!(n && l >= 0))
    return (
      !((!i && !s) || (s && s.$stable)) ||
      (o !== a && (o ? !a || hasPropsChanged(o, a, c) : !!a))
    )
  if (1024 & l) return !0
  if (16 & l) return o ? hasPropsChanged(o, a, c) : !!a
  if (8 & l) {
    const e = t.dynamicProps
    for (let t = 0; t < e.length; t++) {
      const n = e[t]
      if (a[n] !== o[n] && !isEmitListener(c, n)) return !0
    }
  }
  return !1
}
function hasPropsChanged(e, t, n) {
  const o = Object.keys(t)
  if (o.length !== Object.keys(e).length) return !0
  for (let i = 0; i < o.length; i++) {
    const r = o[i]
    if (t[r] !== e[r] && !isEmitListener(n, r)) return !0
  }
  return !1
}
function updateHOCHostEl({ vnode: e, parent: t }, n) {
  for (; t; ) {
    const o = t.subTree
    if ((o.suspense && o.suspense.activeBranch === e && (o.el = e.el), o !== e))
      break
    ;((e = t.vnode).el = n), (t = t.parent)
  }
}
__name(shouldUpdateComponent, 'shouldUpdateComponent'),
  __name(hasPropsChanged, 'hasPropsChanged'),
  __name(updateHOCHostEl, 'updateHOCHostEl')
const isSuspense = __name((e) => e.__isSuspense, 'isSuspense')
let suspenseId = 0
const SuspenseImpl = {
    name: 'Suspense',
    __isSuspense: !0,
    process(e, t, n, o, i, r, a, s, l, c) {
      if (null == e) mountSuspense(t, n, o, i, r, a, s, l, c)
      else {
        if (r && r.deps > 0 && !e.suspense.isInFallback)
          return (
            (t.suspense = e.suspense),
            (t.suspense.vnode = t),
            void (t.el = e.el)
          )
        patchSuspense(e, t, n, o, i, a, s, l, c)
      }
    },
    hydrate: hydrateSuspense,
    normalize: normalizeSuspenseChildren
  },
  Suspense = SuspenseImpl
function triggerEvent(e, t) {
  const n = e.props && e.props[t]
  isFunction$3(n) && n()
}
function mountSuspense(e, t, n, o, i, r, a, s, l) {
  const {
      p: c,
      o: { createElement: d }
    } = l,
    u = d('div'),
    p = (e.suspense = createSuspenseBoundary(e, i, o, t, u, n, r, a, s, l))
  c(null, (p.pendingBranch = e.ssContent), u, null, o, p, r, a),
    p.deps > 0
      ? (triggerEvent(e, 'onPending'),
        triggerEvent(e, 'onFallback'),
        c(null, e.ssFallback, t, n, o, null, r, a),
        setActiveBranch(p, e.ssFallback))
      : p.resolve(!1, !0)
}
function patchSuspense(
  e,
  t,
  n,
  o,
  i,
  r,
  a,
  s,
  { p: l, um: c, o: { createElement: d } }
) {
  const u = (t.suspense = e.suspense)
  ;(u.vnode = t), (t.el = e.el)
  const p = t.ssContent,
    h = t.ssFallback,
    { activeBranch: m, pendingBranch: f, isInFallback: _, isHydrating: g } = u
  if (f)
    (u.pendingBranch = p),
      isSameVNodeType(p, f)
        ? (l(f, p, u.hiddenContainer, null, i, u, r, a, s),
          u.deps <= 0
            ? u.resolve()
            : _ &&
              (g || (l(m, h, n, o, i, null, r, a, s), setActiveBranch(u, h))))
        : ((u.pendingId = suspenseId++),
          g ? ((u.isHydrating = !1), (u.activeBranch = f)) : c(f, i, u),
          (u.deps = 0),
          (u.effects.length = 0),
          (u.hiddenContainer = d('div')),
          _
            ? (l(null, p, u.hiddenContainer, null, i, u, r, a, s),
              u.deps <= 0
                ? u.resolve()
                : (l(m, h, n, o, i, null, r, a, s), setActiveBranch(u, h)))
            : m && isSameVNodeType(p, m)
              ? (l(m, p, n, o, i, u, r, a, s), u.resolve(!0))
              : (l(null, p, u.hiddenContainer, null, i, u, r, a, s),
                u.deps <= 0 && u.resolve()))
  else if (m && isSameVNodeType(p, m))
    l(m, p, n, o, i, u, r, a, s), setActiveBranch(u, p)
  else if (
    (triggerEvent(t, 'onPending'),
    (u.pendingBranch = p),
    512 & p.shapeFlag
      ? (u.pendingId = p.component.suspenseId)
      : (u.pendingId = suspenseId++),
    l(null, p, u.hiddenContainer, null, i, u, r, a, s),
    u.deps <= 0)
  )
    u.resolve()
  else {
    const { timeout: e, pendingId: t } = u
    e > 0
      ? setTimeout(() => {
          u.pendingId === t && u.fallback(h)
        }, e)
      : 0 === e && u.fallback(h)
  }
}
__name(triggerEvent, 'triggerEvent'),
  __name(mountSuspense, 'mountSuspense'),
  __name(patchSuspense, 'patchSuspense')
let hasWarned = !1
function createSuspenseBoundary(e, t, n, o, i, r, a, s, l, c, d = !1) {
  const {
    p: u,
    m: p,
    um: h,
    n: m,
    o: { parentNode: f, remove: _ }
  } = c
  let g
  const v = isVNodeSuspensible(e)
  v && t && t.pendingBranch && ((g = t.pendingId), t.deps++)
  const y = e.props ? toNumber(e.props.timeout) : void 0
  const b = r,
    S = {
      vnode: e,
      parent: t,
      parentComponent: n,
      namespace: a,
      container: o,
      hiddenContainer: i,
      deps: 0,
      pendingId: suspenseId++,
      timeout: 'number' == typeof y ? y : -1,
      activeBranch: null,
      pendingBranch: null,
      isInFallback: !d,
      isHydrating: d,
      isUnmounted: !1,
      effects: [],
      resolve(e = !1, n = !1) {
        const {
          vnode: o,
          activeBranch: i,
          pendingBranch: a,
          pendingId: s,
          effects: l,
          parentComponent: c,
          container: d
        } = S
        let u = !1
        S.isHydrating
          ? (S.isHydrating = !1)
          : e ||
            ((u = i && a.transition && 'out-in' === a.transition.mode),
            u &&
              (i.transition.afterLeave = () => {
                s === S.pendingId &&
                  (p(a, d, r === b ? m(i) : r, 0), queuePostFlushCb(l))
              }),
            i && (f(i.el) === d && (r = m(i)), h(i, c, S, !0)),
            u || p(a, d, r, 0)),
          setActiveBranch(S, a),
          (S.pendingBranch = null),
          (S.isInFallback = !1)
        let _ = S.parent,
          y = !1
        for (; _; ) {
          if (_.pendingBranch) {
            _.effects.push(...l), (y = !0)
            break
          }
          _ = _.parent
        }
        y || u || queuePostFlushCb(l),
          (S.effects = []),
          v &&
            t &&
            t.pendingBranch &&
            g === t.pendingId &&
            (t.deps--, 0 !== t.deps || n || t.resolve()),
          triggerEvent(o, 'onResolve')
      },
      fallback(e) {
        if (!S.pendingBranch) return
        const {
          vnode: t,
          activeBranch: n,
          parentComponent: o,
          container: i,
          namespace: r
        } = S
        triggerEvent(t, 'onFallback')
        const a = m(n),
          c = __name(() => {
            S.isInFallback &&
              (u(null, e, i, a, o, null, r, s, l), setActiveBranch(S, e))
          }, 'mountFallback'),
          d = e.transition && 'out-in' === e.transition.mode
        d && (n.transition.afterLeave = c),
          (S.isInFallback = !0),
          h(n, o, null, !0),
          d || c()
      },
      move(e, t, n) {
        S.activeBranch && p(S.activeBranch, e, t, n), (S.container = e)
      },
      next: () => S.activeBranch && m(S.activeBranch),
      registerDep(e, t, n) {
        const o = !!S.pendingBranch
        o && S.deps++
        const i = e.vnode.el
        e.asyncDep
          .catch((t) => {
            handleError(t, e, 0)
          })
          .then((r) => {
            if (e.isUnmounted || S.isUnmounted || S.pendingId !== e.suspenseId)
              return
            e.asyncResolved = !0
            const { vnode: s } = e
            handleSetupResult(e, r, !1), i && (s.el = i)
            const l = !i && e.subTree.el
            t(e, s, f(i || e.subTree.el), i ? null : m(e.subTree), S, a, n),
              l && _(l),
              updateHOCHostEl(e, s.el),
              o && 0 == --S.deps && S.resolve()
          })
      },
      unmount(e, t) {
        ;(S.isUnmounted = !0),
          S.activeBranch && h(S.activeBranch, n, e, t),
          S.pendingBranch && h(S.pendingBranch, n, e, t)
      }
    }
  return S
}
function hydrateSuspense(e, t, n, o, i, r, a, s, l) {
  const c = (t.suspense = createSuspenseBoundary(
      t,
      o,
      n,
      e.parentNode,
      document.createElement('div'),
      null,
      i,
      r,
      a,
      s,
      !0
    )),
    d = l(e, (c.pendingBranch = t.ssContent), n, c, r, a)
  return 0 === c.deps && c.resolve(!1, !0), d
}
function normalizeSuspenseChildren(e) {
  const { shapeFlag: t, children: n } = e,
    o = 32 & t
  ;(e.ssContent = normalizeSuspenseSlot(o ? n.default : n)),
    (e.ssFallback = o
      ? normalizeSuspenseSlot(n.fallback)
      : createVNode(Comment))
}
function normalizeSuspenseSlot(e) {
  let t
  if (isFunction$3(e)) {
    const n = isBlockTreeEnabled && e._c
    n && ((e._d = !1), openBlock()),
      (e = e()),
      n && ((e._d = !0), (t = currentBlock), closeBlock())
  }
  if (isArray$3(e)) {
    const t = filterSingleRoot(e)
    0, (e = t)
  }
  return (
    (e = normalizeVNode(e)),
    t && !e.dynamicChildren && (e.dynamicChildren = t.filter((t) => t !== e)),
    e
  )
}
function queueEffectWithSuspense(e, t) {
  t && t.pendingBranch
    ? isArray$3(e)
      ? t.effects.push(...e)
      : t.effects.push(e)
    : queuePostFlushCb(e)
}
function setActiveBranch(e, t) {
  e.activeBranch = t
  const { vnode: n, parentComponent: o } = e
  let i = t.el
  for (; !i && t.component; ) i = (t = t.component.subTree).el
  ;(n.el = i), o && o.subTree === n && ((o.vnode.el = i), updateHOCHostEl(o, i))
}
function isVNodeSuspensible(e) {
  const t = e.props && e.props.suspensible
  return null != t && !1 !== t
}
__name(createSuspenseBoundary, 'createSuspenseBoundary'),
  __name(hydrateSuspense, 'hydrateSuspense'),
  __name(normalizeSuspenseChildren, 'normalizeSuspenseChildren'),
  __name(normalizeSuspenseSlot, 'normalizeSuspenseSlot'),
  __name(queueEffectWithSuspense, 'queueEffectWithSuspense'),
  __name(setActiveBranch, 'setActiveBranch'),
  __name(isVNodeSuspensible, 'isVNodeSuspensible')
const Fragment = Symbol.for('v-fgt'),
  Text$1 = Symbol.for('v-txt'),
  Comment = Symbol.for('v-cmt'),
  Static = Symbol.for('v-stc'),
  blockStack = []
let currentBlock = null
function openBlock(e = !1) {
  blockStack.push((currentBlock = e ? null : []))
}
function closeBlock() {
  blockStack.pop(), (currentBlock = blockStack[blockStack.length - 1] || null)
}
__name(openBlock, 'openBlock'), __name(closeBlock, 'closeBlock')
let isBlockTreeEnabled = 1,
  vnodeArgsTransformer
function setBlockTracking(e, t = !1) {
  ;(isBlockTreeEnabled += e),
    e < 0 && currentBlock && t && (currentBlock.hasOnce = !0)
}
function setupBlock(e) {
  return (
    (e.dynamicChildren =
      isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null),
    closeBlock(),
    isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(e),
    e
  )
}
function createElementBlock(e, t, n, o, i, r) {
  return setupBlock(createBaseVNode(e, t, n, o, i, r, !0))
}
function createBlock(e, t, n, o, i) {
  return setupBlock(createVNode(e, t, n, o, i, !0))
}
function isVNode(e) {
  return !!e && !0 === e.__v_isVNode
}
function isSameVNodeType(e, t) {
  return e.type === t.type && e.key === t.key
}
function transformVNodeArgs(e) {
  vnodeArgsTransformer = e
}
__name(setBlockTracking, 'setBlockTracking'),
  __name(setupBlock, 'setupBlock'),
  __name(createElementBlock, 'createElementBlock'),
  __name(createBlock, 'createBlock'),
  __name(isVNode, 'isVNode'),
  __name(isSameVNodeType, 'isSameVNodeType'),
  __name(transformVNodeArgs, 'transformVNodeArgs')
const createVNodeWithArgsTransform = __name(
    (...e) =>
      _createVNode(
        ...(vnodeArgsTransformer
          ? vnodeArgsTransformer(e, currentRenderingInstance)
          : e)
      ),
    'createVNodeWithArgsTransform'
  ),
  normalizeKey = __name(({ key: e }) => (null != e ? e : null), 'normalizeKey'),
  normalizeRef = __name(
    ({ ref: e, ref_key: t, ref_for: n }) => (
      'number' == typeof e && (e = '' + e),
      null != e
        ? isString$3(e) || isRef(e) || isFunction$3(e)
          ? { i: currentRenderingInstance, r: e, k: t, f: !!n }
          : e
        : null
    ),
    'normalizeRef'
  )
function createBaseVNode(
  e,
  t = null,
  n = null,
  o = 0,
  i = null,
  r = e === Fragment ? 0 : 1,
  a = !1,
  s = !1
) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && normalizeKey(t),
    ref: t && normalizeRef(t),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: r,
    patchFlag: o,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  }
  return (
    s
      ? (normalizeChildren(l, n), 128 & r && e.normalize(l))
      : n && (l.shapeFlag |= isString$3(n) ? 8 : 16),
    isBlockTreeEnabled > 0 &&
      !a &&
      currentBlock &&
      (l.patchFlag > 0 || 6 & r) &&
      32 !== l.patchFlag &&
      currentBlock.push(l),
    l
  )
}
__name(createBaseVNode, 'createBaseVNode')
const createVNode = _createVNode
function _createVNode(e, t = null, n = null, o = 0, i = null, r = !1) {
  if (((e && e !== NULL_DYNAMIC_COMPONENT) || (e = Comment), isVNode(e))) {
    const o = cloneVNode(e, t, !0)
    return (
      n && normalizeChildren(o, n),
      isBlockTreeEnabled > 0 &&
        !r &&
        currentBlock &&
        (6 & o.shapeFlag
          ? (currentBlock[currentBlock.indexOf(e)] = o)
          : currentBlock.push(o)),
      (o.patchFlag = -2),
      o
    )
  }
  if ((isClassComponent(e) && (e = e.__vccOpts), t)) {
    t = guardReactiveProps(t)
    let { class: e, style: n } = t
    e && !isString$3(e) && (t.class = normalizeClass(e)),
      isObject$4(n) &&
        (isProxy(n) && !isArray$3(n) && (n = extend$1({}, n)),
        (t.style = normalizeStyle(n)))
  }
  return createBaseVNode(
    e,
    t,
    n,
    o,
    i,
    isString$3(e)
      ? 1
      : isSuspense(e)
        ? 128
        : isTeleport(e)
          ? 64
          : isObject$4(e)
            ? 4
            : isFunction$3(e)
              ? 2
              : 0,
    r,
    !0
  )
}
function guardReactiveProps(e) {
  return e ? (isProxy(e) || isInternalObject(e) ? extend$1({}, e) : e) : null
}
function cloneVNode(e, t, n = !1, o = !1) {
  const { props: i, ref: r, patchFlag: a, children: s, transition: l } = e,
    c = t ? mergeProps$1(i || {}, t) : i,
    d = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e.type,
      props: c,
      key: c && normalizeKey(c),
      ref:
        t && t.ref
          ? n && r
            ? isArray$3(r)
              ? r.concat(normalizeRef(t))
              : [r, normalizeRef(t)]
            : normalizeRef(t)
          : r,
      scopeId: e.scopeId,
      slotScopeIds: e.slotScopeIds,
      children: s,
      target: e.target,
      targetStart: e.targetStart,
      targetAnchor: e.targetAnchor,
      staticCount: e.staticCount,
      shapeFlag: e.shapeFlag,
      patchFlag: t && e.type !== Fragment ? (-1 === a ? 16 : 16 | a) : a,
      dynamicProps: e.dynamicProps,
      dynamicChildren: e.dynamicChildren,
      appContext: e.appContext,
      dirs: e.dirs,
      transition: l,
      component: e.component,
      suspense: e.suspense,
      ssContent: e.ssContent && cloneVNode(e.ssContent),
      ssFallback: e.ssFallback && cloneVNode(e.ssFallback),
      el: e.el,
      anchor: e.anchor,
      ctx: e.ctx,
      ce: e.ce
    }
  return l && o && setTransitionHooks(d, l.clone(d)), d
}
function deepCloneVNode(e) {
  const t = cloneVNode(e)
  return (
    isArray$3(e.children) && (t.children = e.children.map(deepCloneVNode)), t
  )
}
function createTextVNode(e = ' ', t = 0) {
  return createVNode(Text$1, null, e, t)
}
function createStaticVNode(e, t) {
  const n = createVNode(Static, null, e)
  return (n.staticCount = t), n
}
function createCommentVNode(e = '', t = !1) {
  return t
    ? (openBlock(), createBlock(Comment, null, e))
    : createVNode(Comment, null, e)
}
function normalizeVNode(e) {
  return null == e || 'boolean' == typeof e
    ? createVNode(Comment)
    : isArray$3(e)
      ? createVNode(Fragment, null, e.slice())
      : isVNode(e)
        ? cloneIfMounted(e)
        : createVNode(Text$1, null, String(e))
}
function cloneIfMounted(e) {
  return (null === e.el && -1 !== e.patchFlag) || e.memo ? e : cloneVNode(e)
}
function normalizeChildren(e, t) {
  let n = 0
  const { shapeFlag: o } = e
  if (null == t) t = null
  else if (isArray$3(t)) n = 16
  else if ('object' == typeof t) {
    if (65 & o) {
      const n = t.default
      return void (
        n &&
        (n._c && (n._d = !1), normalizeChildren(e, n()), n._c && (n._d = !0))
      )
    }
    {
      n = 32
      const o = t._
      o || isInternalObject(t)
        ? 3 === o &&
          currentRenderingInstance &&
          (1 === currentRenderingInstance.slots._
            ? (t._ = 1)
            : ((t._ = 2), (e.patchFlag |= 1024)))
        : (t._ctx = currentRenderingInstance)
    }
  } else
    isFunction$3(t)
      ? ((t = { default: t, _ctx: currentRenderingInstance }), (n = 32))
      : ((t = String(t)),
        64 & o ? ((n = 16), (t = [createTextVNode(t)])) : (n = 8))
  ;(e.children = t), (e.shapeFlag |= n)
}
function mergeProps$1(...e) {
  const t = {}
  for (let n = 0; n < e.length; n++) {
    const o = e[n]
    for (const e in o)
      if ('class' === e)
        t.class !== o.class && (t.class = normalizeClass([t.class, o.class]))
      else if ('style' === e) t.style = normalizeStyle([t.style, o.style])
      else if (isOn(e)) {
        const n = t[e],
          i = o[e]
        !i ||
          n === i ||
          (isArray$3(n) && n.includes(i)) ||
          (t[e] = n ? [].concat(n, i) : i)
      } else '' !== e && (t[e] = o[e])
  }
  return t
}
function invokeVNodeHook(e, t, n, o = null) {
  callWithAsyncErrorHandling(e, t, 7, [n, o])
}
__name(_createVNode, '_createVNode'),
  __name(guardReactiveProps, 'guardReactiveProps'),
  __name(cloneVNode, 'cloneVNode'),
  __name(deepCloneVNode, 'deepCloneVNode'),
  __name(createTextVNode, 'createTextVNode'),
  __name(createStaticVNode, 'createStaticVNode'),
  __name(createCommentVNode, 'createCommentVNode'),
  __name(normalizeVNode, 'normalizeVNode'),
  __name(cloneIfMounted, 'cloneIfMounted'),
  __name(normalizeChildren, 'normalizeChildren'),
  __name(mergeProps$1, 'mergeProps$1'),
  __name(invokeVNodeHook, 'invokeVNodeHook')
const emptyAppContext = createAppContext()
let uid = 0
function createComponentInstance(e, t, n) {
  const o = e.type,
    i = (t ? t.appContext : e.appContext) || emptyAppContext,
    r = {
      uid: uid++,
      vnode: e,
      type: o,
      parent: t,
      appContext: i,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      job: null,
      scope: new EffectScope(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: t ? t.provides : Object.create(i.provides),
      ids: t ? t.ids : ['', 0, 0],
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: normalizePropsOptions(o, i),
      emitsOptions: normalizeEmitsOptions(o, i),
      emit: null,
      emitted: null,
      propsDefaults: EMPTY_OBJ,
      inheritAttrs: o.inheritAttrs,
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      suspense: n,
      suspenseId: n ? n.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    }
  return (
    (r.ctx = { _: r }),
    (r.root = t ? t.root : r),
    (r.emit = emit.bind(null, r)),
    e.ce && e.ce(r),
    r
  )
}
__name(createComponentInstance, 'createComponentInstance')
let currentInstance = null
const getCurrentInstance = __name(
  () => currentInstance || currentRenderingInstance,
  'getCurrentInstance'
)
let internalSetCurrentInstance, setInSSRSetupState
{
  const e = getGlobalThis(),
    t = __name((t, n) => {
      let o
      return (
        (o = e[t]) || (o = e[t] = []),
        o.push(n),
        (e) => {
          o.length > 1 ? o.forEach((t) => t(e)) : o[0](e)
        }
      )
    }, 'registerGlobalSetter')
  ;(internalSetCurrentInstance = t(
    '__VUE_INSTANCE_SETTERS__',
    (e) => (currentInstance = e)
  )),
    (setInSSRSetupState = t(
      '__VUE_SSR_SETTERS__',
      (e) => (isInSSRComponentSetup = e)
    ))
}
const setCurrentInstance = __name((e) => {
    const t = currentInstance
    return (
      internalSetCurrentInstance(e),
      e.scope.on(),
      () => {
        e.scope.off(), internalSetCurrentInstance(t)
      }
    )
  }, 'setCurrentInstance'),
  unsetCurrentInstance = __name(() => {
    currentInstance && currentInstance.scope.off(),
      internalSetCurrentInstance(null)
  }, 'unsetCurrentInstance'),
  isBuiltInTag = makeMap('slot,component')
function validateComponentName(e, { isNativeTag: t }) {
  ;(isBuiltInTag(e) || t(e)) &&
    warn$1(
      'Do not use built-in or reserved HTML elements as component id: ' + e
    )
}
function isStatefulComponent(e) {
  return 4 & e.vnode.shapeFlag
}
__name(validateComponentName, 'validateComponentName'),
  __name(isStatefulComponent, 'isStatefulComponent')
let isInSSRComponentSetup = !1,
  compile$1,
  installWithProxy
function setupComponent(e, t = !1, n = !1) {
  t && setInSSRSetupState(t)
  const { props: o, children: i } = e.vnode,
    r = isStatefulComponent(e)
  initProps(e, o, r, t), initSlots(e, i, n)
  const a = r ? setupStatefulComponent(e, t) : void 0
  return t && setInSSRSetupState(!1), a
}
function setupStatefulComponent(e, t) {
  const n = e.type
  ;(e.accessCache = Object.create(null)),
    (e.proxy = new Proxy(e.ctx, PublicInstanceProxyHandlers))
  const { setup: o } = n
  if (o) {
    pauseTracking()
    const n = (e.setupContext = o.length > 1 ? createSetupContext(e) : null),
      i = setCurrentInstance(e),
      r = callWithErrorHandling(o, e, 0, [e.props, n]),
      a = isPromise(r)
    if (
      (resetTracking(),
      i(),
      (!a && !e.sp) || isAsyncWrapper(e) || markAsyncBoundary(e),
      a)
    ) {
      if ((r.then(unsetCurrentInstance, unsetCurrentInstance), t))
        return r
          .then((n) => {
            handleSetupResult(e, n, t)
          })
          .catch((t) => {
            handleError(t, e, 0)
          })
      e.asyncDep = r
    } else handleSetupResult(e, r, t)
  } else finishComponentSetup(e, t)
}
function handleSetupResult(e, t, n) {
  isFunction$3(t)
    ? e.type.__ssrInlineRender
      ? (e.ssrRender = t)
      : (e.render = t)
    : isObject$4(t) && (e.setupState = proxyRefs(t)),
    finishComponentSetup(e, n)
}
function registerRuntimeCompiler(e) {
  ;(compile$1 = e),
    (installWithProxy = __name((e) => {
      e.render._rc &&
        (e.withProxy = new Proxy(
          e.ctx,
          RuntimeCompiledPublicInstanceProxyHandlers
        ))
    }, 'installWithProxy'))
}
__name(setupComponent, 'setupComponent'),
  __name(setupStatefulComponent, 'setupStatefulComponent'),
  __name(handleSetupResult, 'handleSetupResult'),
  __name(registerRuntimeCompiler, 'registerRuntimeCompiler')
const isRuntimeOnly = __name(() => !compile$1, 'isRuntimeOnly')
function finishComponentSetup(e, t, n) {
  const o = e.type
  if (!e.render) {
    if (!t && compile$1 && !o.render) {
      const t = o.template || resolveMergedOptions(e).template
      if (t) {
        0
        const { isCustomElement: n, compilerOptions: i } = e.appContext.config,
          { delimiters: r, compilerOptions: a } = o,
          s = extend$1(extend$1({ isCustomElement: n, delimiters: r }, i), a)
        o.render = compile$1(t, s)
      }
    }
    ;(e.render = o.render || NOOP), installWithProxy && installWithProxy(e)
  }
  {
    const t = setCurrentInstance(e)
    pauseTracking()
    try {
      applyOptions(e)
    } finally {
      resetTracking(), t()
    }
  }
}
__name(finishComponentSetup, 'finishComponentSetup')
const attrsProxyHandlers = { get: (e, t) => (track(e, 'get', ''), e[t]) }
function getSlotsProxy(e) {
  return new Proxy(e.slots, {
    get: (t, n) => (track(e, 'get', '$slots'), t[n])
  })
}
function createSetupContext(e) {
  const t = __name((t) => {
    e.exposed = t || {}
  }, 'expose')
  return {
    attrs: new Proxy(e.attrs, attrsProxyHandlers),
    slots: e.slots,
    emit: e.emit,
    expose: t
  }
}
function getComponentPublicInstance(e) {
  return e.exposed
    ? e.exposeProxy ||
        (e.exposeProxy = new Proxy(proxyRefs(markRaw(e.exposed)), {
          get: (t, n) =>
            n in t
              ? t[n]
              : n in publicPropertiesMap
                ? publicPropertiesMap[n](e)
                : void 0,
          has: (e, t) => t in e || t in publicPropertiesMap
        }))
    : e.proxy
}
__name(getSlotsProxy, 'getSlotsProxy'),
  __name(createSetupContext, 'createSetupContext'),
  __name(getComponentPublicInstance, 'getComponentPublicInstance')
const classifyRE = /(?:^|[-_])(\w)/g,
  classify = __name(
    (e) => e.replace(classifyRE, (e) => e.toUpperCase()).replace(/[-_]/g, ''),
    'classify'
  )
function getComponentName(e, t = !0) {
  return isFunction$3(e) ? e.displayName || e.name : e.name || (t && e.__name)
}
function formatComponentName(e, t, n = !1) {
  let o = getComponentName(t)
  if (!o && t.__file) {
    const e = t.__file.match(/([^/\\]+)\.\w+$/)
    e && (o = e[1])
  }
  if (!o && e && e.parent) {
    const n = __name((e) => {
      for (const n in e) if (e[n] === t) return n
    }, 'inferFromRegistry')
    o =
      n(e.components || e.parent.type.components) || n(e.appContext.components)
  }
  return o ? classify(o) : n ? 'App' : 'Anonymous'
}
function isClassComponent(e) {
  return isFunction$3(e) && '__vccOpts' in e
}
__name(getComponentName, 'getComponentName'),
  __name(formatComponentName, 'formatComponentName'),
  __name(isClassComponent, 'isClassComponent')
const computed = __name((e, t) => {
  const n = computed$1(e, t, isInSSRComponentSetup)
  return n
}, 'computed')
function h(e, t, n) {
  const o = arguments.length
  return 2 === o
    ? isObject$4(t) && !isArray$3(t)
      ? isVNode(t)
        ? createVNode(e, null, [t])
        : createVNode(e, t)
      : createVNode(e, null, t)
    : (o > 3
        ? (n = Array.prototype.slice.call(arguments, 2))
        : 3 === o && isVNode(n) && (n = [n]),
      createVNode(e, t, n))
}
function initCustomFormatter() {
  return void 0
}
function withMemo(e, t, n, o) {
  const i = n[o]
  if (i && isMemoSame(i, e)) return i
  const r = t()
  return (r.memo = e.slice()), (r.cacheIndex = o), (n[o] = r)
}
function isMemoSame(e, t) {
  const n = e.memo
  if (n.length != t.length) return !1
  for (let o = 0; o < n.length; o++) if (hasChanged(n[o], t[o])) return !1
  return isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(e), !0
}
__name(h, 'h'),
  __name(initCustomFormatter, 'initCustomFormatter'),
  __name(withMemo, 'withMemo'),
  __name(isMemoSame, 'isMemoSame')
const version = '3.5.13',
  warn = NOOP,
  ErrorTypeStrings = ErrorTypeStrings$1,
  devtools = devtools$1,
  setDevtoolsHook = setDevtoolsHook$1,
  _ssrUtils = {
    createComponentInstance: createComponentInstance,
    setupComponent: setupComponent,
    renderComponentRoot: renderComponentRoot,
    setCurrentRenderingInstance: setCurrentRenderingInstance,
    isVNode: isVNode,
    normalizeVNode: normalizeVNode,
    getComponentPublicInstance: getComponentPublicInstance,
    ensureValidVNode: ensureValidVNode,
    pushWarningContext: pushWarningContext,
    popWarningContext: popWarningContext
  },
  ssrUtils = _ssrUtils,
  resolveFilter = null,
  compatUtils = null,
  DeprecationTypes = null
/**
 * @vue/runtime-dom v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let policy
const tt = 'undefined' != typeof window && window.trustedTypes
if (tt)
  try {
    policy = tt.createPolicy('vue', {
      createHTML: __name((e) => e, 'createHTML')
    })
  } catch (e2) {}
const unsafeToTrustedHTML = policy ? (e) => policy.createHTML(e) : (e) => e,
  svgNS = 'http://www.w3.org/2000/svg',
  mathmlNS = 'http://www.w3.org/1998/Math/MathML',
  doc = 'undefined' != typeof document ? document : null,
  templateContainer = doc && doc.createElement('template'),
  nodeOps = {
    insert: __name((e, t, n) => {
      t.insertBefore(e, n || null)
    }, 'insert'),
    remove: __name((e) => {
      const t = e.parentNode
      t && t.removeChild(e)
    }, 'remove'),
    createElement: __name((e, t, n, o) => {
      const i =
        'svg' === t
          ? doc.createElementNS(svgNS, e)
          : 'mathml' === t
            ? doc.createElementNS(mathmlNS, e)
            : n
              ? doc.createElement(e, { is: n })
              : doc.createElement(e)
      return (
        'select' === e &&
          o &&
          null != o.multiple &&
          i.setAttribute('multiple', o.multiple),
        i
      )
    }, 'createElement'),
    createText: __name((e) => doc.createTextNode(e), 'createText'),
    createComment: __name((e) => doc.createComment(e), 'createComment'),
    setText: __name((e, t) => {
      e.nodeValue = t
    }, 'setText'),
    setElementText: __name((e, t) => {
      e.textContent = t
    }, 'setElementText'),
    parentNode: __name((e) => e.parentNode, 'parentNode'),
    nextSibling: __name((e) => e.nextSibling, 'nextSibling'),
    querySelector: __name((e) => doc.querySelector(e), 'querySelector'),
    setScopeId(e, t) {
      e.setAttribute(t, '')
    },
    insertStaticContent(e, t, n, o, i, r) {
      const a = n ? n.previousSibling : t.lastChild
      if (i && (i === r || i.nextSibling))
        for (
          ;
          t.insertBefore(i.cloneNode(!0), n), i !== r && (i = i.nextSibling);

        );
      else {
        templateContainer.innerHTML = unsafeToTrustedHTML(
          'svg' === o
            ? `<svg>${e}</svg>`
            : 'mathml' === o
              ? `<math>${e}</math>`
              : e
        )
        const i = templateContainer.content
        if ('svg' === o || 'mathml' === o) {
          const e = i.firstChild
          for (; e.firstChild; ) i.appendChild(e.firstChild)
          i.removeChild(e)
        }
        t.insertBefore(i, n)
      }
      return [
        a ? a.nextSibling : t.firstChild,
        n ? n.previousSibling : t.lastChild
      ]
    }
  },
  TRANSITION = 'transition',
  ANIMATION = 'animation',
  vtcKey = Symbol('_vtc'),
  DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: { type: Boolean, default: !0 },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  },
  TransitionPropsValidators = extend$1(
    {},
    BaseTransitionPropsValidators,
    DOMTransitionPropsValidators
  ),
  decorate$1 = __name(
    (e) => (
      (e.displayName = 'Transition'), (e.props = TransitionPropsValidators), e
    ),
    'decorate$1'
  ),
  Transition = decorate$1((e, { slots: t }) =>
    h(BaseTransition, resolveTransitionProps(e), t)
  ),
  callHook = __name((e, t = []) => {
    isArray$3(e) ? e.forEach((e) => e(...t)) : e && e(...t)
  }, 'callHook'),
  hasExplicitCallback = __name(
    (e) => !!e && (isArray$3(e) ? e.some((e) => e.length > 1) : e.length > 1),
    'hasExplicitCallback'
  )
function resolveTransitionProps(e) {
  const t = {}
  for (const T in e) T in DOMTransitionPropsValidators || (t[T] = e[T])
  if (!1 === e.css) return t
  const {
      name: n = 'v',
      type: o,
      duration: i,
      enterFromClass: r = `${n}-enter-from`,
      enterActiveClass: a = `${n}-enter-active`,
      enterToClass: s = `${n}-enter-to`,
      appearFromClass: l = r,
      appearActiveClass: c = a,
      appearToClass: d = s,
      leaveFromClass: u = `${n}-leave-from`,
      leaveActiveClass: p = `${n}-leave-active`,
      leaveToClass: h = `${n}-leave-to`
    } = e,
    m = normalizeDuration(i),
    f = m && m[0],
    _ = m && m[1],
    {
      onBeforeEnter: g,
      onEnter: v,
      onEnterCancelled: y,
      onLeave: b,
      onLeaveCancelled: S,
      onBeforeAppear: C = g,
      onAppear: w = v,
      onAppearCancelled: k = y
    } = t,
    x = __name((e, t, n, o) => {
      ;(e._enterCancelled = o),
        removeTransitionClass(e, t ? d : s),
        removeTransitionClass(e, t ? c : a),
        n && n()
    }, 'finishEnter'),
    E = __name((e, t) => {
      ;(e._isLeaving = !1),
        removeTransitionClass(e, u),
        removeTransitionClass(e, h),
        removeTransitionClass(e, p),
        t && t()
    }, 'finishLeave'),
    I = __name(
      (e) => (t, n) => {
        const i = e ? w : v,
          a = __name(() => x(t, e, n), 'resolve')
        callHook(i, [t, a]),
          nextFrame(() => {
            removeTransitionClass(t, e ? l : r),
              addTransitionClass(t, e ? d : s),
              hasExplicitCallback(i) || whenTransitionEnds(t, o, f, a)
          })
      },
      'makeEnterHook'
    )
  return extend$1(t, {
    onBeforeEnter(e) {
      callHook(g, [e]), addTransitionClass(e, r), addTransitionClass(e, a)
    },
    onBeforeAppear(e) {
      callHook(C, [e]), addTransitionClass(e, l), addTransitionClass(e, c)
    },
    onEnter: I(!1),
    onAppear: I(!0),
    onLeave(e, t) {
      e._isLeaving = !0
      const n = __name(() => E(e, t), 'resolve')
      addTransitionClass(e, u),
        e._enterCancelled
          ? (addTransitionClass(e, p), forceReflow())
          : (forceReflow(), addTransitionClass(e, p)),
        nextFrame(() => {
          e._isLeaving &&
            (removeTransitionClass(e, u),
            addTransitionClass(e, h),
            hasExplicitCallback(b) || whenTransitionEnds(e, o, _, n))
        }),
        callHook(b, [e, n])
    },
    onEnterCancelled(e) {
      x(e, !1, void 0, !0), callHook(y, [e])
    },
    onAppearCancelled(e) {
      x(e, !0, void 0, !0), callHook(k, [e])
    },
    onLeaveCancelled(e) {
      E(e), callHook(S, [e])
    }
  })
}
function normalizeDuration(e) {
  if (null == e) return null
  if (isObject$4(e)) return [NumberOf(e.enter), NumberOf(e.leave)]
  {
    const t = NumberOf(e)
    return [t, t]
  }
}
function NumberOf(e) {
  const t = toNumber(e)
  return t
}
function addTransitionClass(e, t) {
  t.split(/\s+/).forEach((t) => t && e.classList.add(t)),
    (e[vtcKey] || (e[vtcKey] = new Set())).add(t)
}
function removeTransitionClass(e, t) {
  t.split(/\s+/).forEach((t) => t && e.classList.remove(t))
  const n = e[vtcKey]
  n && (n.delete(t), n.size || (e[vtcKey] = void 0))
}
function nextFrame(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e)
  })
}
__name(resolveTransitionProps, 'resolveTransitionProps'),
  __name(normalizeDuration, 'normalizeDuration'),
  __name(NumberOf, 'NumberOf'),
  __name(addTransitionClass, 'addTransitionClass'),
  __name(removeTransitionClass, 'removeTransitionClass'),
  __name(nextFrame, 'nextFrame')
let endId = 0
function whenTransitionEnds(e, t, n, o) {
  const i = (e._endId = ++endId),
    r = __name(() => {
      i === e._endId && o()
    }, 'resolveIfNotStale')
  if (null != n) return setTimeout(r, n)
  const { type: a, timeout: s, propCount: l } = getTransitionInfo(e, t)
  if (!a) return o()
  const c = a + 'end'
  let d = 0
  const u = __name(() => {
      e.removeEventListener(c, p), r()
    }, 'end'),
    p = __name((t) => {
      t.target === e && ++d >= l && u()
    }, 'onEnd')
  setTimeout(() => {
    d < l && u()
  }, s + 1),
    e.addEventListener(c, p)
}
function getTransitionInfo(e, t) {
  const n = window.getComputedStyle(e),
    o = __name((e) => (n[e] || '').split(', '), 'getStyleProperties'),
    i = o(`${TRANSITION}Delay`),
    r = o(`${TRANSITION}Duration`),
    a = getTimeout(i, r),
    s = o(`${ANIMATION}Delay`),
    l = o(`${ANIMATION}Duration`),
    c = getTimeout(s, l)
  let d = null,
    u = 0,
    p = 0
  t === TRANSITION
    ? a > 0 && ((d = TRANSITION), (u = a), (p = r.length))
    : t === ANIMATION
      ? c > 0 && ((d = ANIMATION), (u = c), (p = l.length))
      : ((u = Math.max(a, c)),
        (d = u > 0 ? (a > c ? TRANSITION : ANIMATION) : null),
        (p = d ? (d === TRANSITION ? r.length : l.length) : 0))
  return {
    type: d,
    timeout: u,
    propCount: p,
    hasTransform:
      d === TRANSITION &&
      /\b(transform|all)(,|$)/.test(o(`${TRANSITION}Property`).toString())
  }
}
function getTimeout(e, t) {
  for (; e.length < t.length; ) e = e.concat(e)
  return Math.max(...t.map((t, n) => toMs(t) + toMs(e[n])))
}
function toMs(e) {
  return 'auto' === e ? 0 : 1e3 * Number(e.slice(0, -1).replace(',', '.'))
}
function forceReflow() {
  return document.body.offsetHeight
}
function patchClass(e, t, n) {
  const o = e[vtcKey]
  o && (t = (t ? [t, ...o] : [...o]).join(' ')),
    null == t
      ? e.removeAttribute('class')
      : n
        ? e.setAttribute('class', t)
        : (e.className = t)
}
__name(whenTransitionEnds, 'whenTransitionEnds'),
  __name(getTransitionInfo, 'getTransitionInfo'),
  __name(getTimeout, 'getTimeout'),
  __name(toMs, 'toMs'),
  __name(forceReflow, 'forceReflow'),
  __name(patchClass, 'patchClass')
const vShowOriginalDisplay = Symbol('_vod'),
  vShowHidden = Symbol('_vsh'),
  vShow = {
    beforeMount(e, { value: t }, { transition: n }) {
      ;(e[vShowOriginalDisplay] =
        'none' === e.style.display ? '' : e.style.display),
        n && t ? n.beforeEnter(e) : setDisplay(e, t)
    },
    mounted(e, { value: t }, { transition: n }) {
      n && t && n.enter(e)
    },
    updated(e, { value: t, oldValue: n }, { transition: o }) {
      !t != !n &&
        (o
          ? t
            ? (o.beforeEnter(e), setDisplay(e, !0), o.enter(e))
            : o.leave(e, () => {
                setDisplay(e, !1)
              })
          : setDisplay(e, t))
    },
    beforeUnmount(e, { value: t }) {
      setDisplay(e, t)
    }
  }
function setDisplay(e, t) {
  ;(e.style.display = t ? e[vShowOriginalDisplay] : 'none'),
    (e[vShowHidden] = !t)
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value: e }) => {
    if (!e) return { style: { display: 'none' } }
  }
}
__name(setDisplay, 'setDisplay'), __name(initVShowForSSR, 'initVShowForSSR')
const CSS_VAR_TEXT = Symbol('')
function useCssVars(e) {
  const t = getCurrentInstance()
  if (!t) return
  const n = (t.ut = (n = e(t.proxy)) => {
    Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(
      (e) => setVarsOnNode(e, n)
    )
  })
  const o = __name(() => {
    const o = e(t.proxy)
    t.ce ? setVarsOnNode(t.ce, o) : setVarsOnVNode(t.subTree, o), n(o)
  }, 'setVars')
  onBeforeUpdate(() => {
    queuePostFlushCb(o)
  }),
    onMounted(() => {
      watch(o, NOOP, { flush: 'post' })
      const e = new MutationObserver(o)
      e.observe(t.subTree.el.parentNode, { childList: !0 }),
        onUnmounted(() => e.disconnect())
    })
}
function setVarsOnVNode(e, t) {
  if (128 & e.shapeFlag) {
    const n = e.suspense
    ;(e = n.activeBranch),
      n.pendingBranch &&
        !n.isHydrating &&
        n.effects.push(() => {
          setVarsOnVNode(n.activeBranch, t)
        })
  }
  for (; e.component; ) e = e.component.subTree
  if (1 & e.shapeFlag && e.el) setVarsOnNode(e.el, t)
  else if (e.type === Fragment) e.children.forEach((e) => setVarsOnVNode(e, t))
  else if (e.type === Static) {
    let { el: n, anchor: o } = e
    for (; n && (setVarsOnNode(n, t), n !== o); ) n = n.nextSibling
  }
}
function setVarsOnNode(e, t) {
  if (1 === e.nodeType) {
    const n = e.style
    let o = ''
    for (const e in t) n.setProperty(`--${e}`, t[e]), (o += `--${e}: ${t[e]};`)
    n[CSS_VAR_TEXT] = o
  }
}
__name(useCssVars, 'useCssVars'),
  __name(setVarsOnVNode, 'setVarsOnVNode'),
  __name(setVarsOnNode, 'setVarsOnNode')
const displayRE = /(^|;)\s*display\s*:/
function patchStyle(e, t, n) {
  const o = e.style,
    i = isString$3(n)
  let r = !1
  if (n && !i) {
    if (t)
      if (isString$3(t))
        for (const e of t.split(';')) {
          const t = e.slice(0, e.indexOf(':')).trim()
          null == n[t] && setStyle(o, t, '')
        }
      else for (const e in t) null == n[e] && setStyle(o, e, '')
    for (const e in n) 'display' === e && (r = !0), setStyle(o, e, n[e])
  } else if (i) {
    if (t !== n) {
      const e = o[CSS_VAR_TEXT]
      e && (n += ';' + e), (o.cssText = n), (r = displayRE.test(n))
    }
  } else t && e.removeAttribute('style')
  vShowOriginalDisplay in e &&
    ((e[vShowOriginalDisplay] = r ? o.display : ''),
    e[vShowHidden] && (o.display = 'none'))
}
__name(patchStyle, 'patchStyle')
const semicolonRE = /[^\\];\s*$/,
  importantRE = /\s*!important$/
function setStyle(e, t, n) {
  if (isArray$3(n)) n.forEach((n) => setStyle(e, t, n))
  else if ((null == n && (n = ''), t.startsWith('--'))) e.setProperty(t, n)
  else {
    const o = autoPrefix(e, t)
    importantRE.test(n)
      ? e.setProperty(hyphenate$1(o), n.replace(importantRE, ''), 'important')
      : (e[o] = n)
  }
}
__name(setStyle, 'setStyle')
const prefixes = ['Webkit', 'Moz', 'ms'],
  prefixCache = {}
function autoPrefix(e, t) {
  const n = prefixCache[t]
  if (n) return n
  let o = camelize$1(t)
  if ('filter' !== o && o in e) return (prefixCache[t] = o)
  o = capitalize(o)
  for (let i = 0; i < prefixes.length; i++) {
    const n = prefixes[i] + o
    if (n in e) return (prefixCache[t] = n)
  }
  return t
}
__name(autoPrefix, 'autoPrefix')
const xlinkNS = 'http://www.w3.org/1999/xlink'
function patchAttr(e, t, n, o, i, r = isSpecialBooleanAttr(t)) {
  o && t.startsWith('xlink:')
    ? null == n
      ? e.removeAttributeNS(xlinkNS, t.slice(6, t.length))
      : e.setAttributeNS(xlinkNS, t, n)
    : null == n || (r && !includeBooleanAttr(n))
      ? e.removeAttribute(t)
      : e.setAttribute(t, r ? '' : isSymbol(n) ? String(n) : n)
}
function patchDOMProp(e, t, n, o, i) {
  if ('innerHTML' === t || 'textContent' === t)
    return void (
      null != n && (e[t] = 'innerHTML' === t ? unsafeToTrustedHTML(n) : n)
    )
  const r = e.tagName
  if ('value' === t && 'PROGRESS' !== r && !r.includes('-')) {
    const o = 'OPTION' === r ? e.getAttribute('value') || '' : e.value,
      i = null == n ? ('checkbox' === e.type ? 'on' : '') : String(n)
    return (
      (o === i && '_value' in e) || (e.value = i),
      null == n && e.removeAttribute(t),
      void (e._value = n)
    )
  }
  let a = !1
  if ('' === n || null == n) {
    const o = typeof e[t]
    'boolean' === o
      ? (n = includeBooleanAttr(n))
      : null == n && 'string' === o
        ? ((n = ''), (a = !0))
        : 'number' === o && ((n = 0), (a = !0))
  }
  try {
    e[t] = n
  } catch (e2) {
    0
  }
  a && e.removeAttribute(i || t)
}
function addEventListener(e, t, n, o) {
  e.addEventListener(t, n, o)
}
function removeEventListener(e, t, n, o) {
  e.removeEventListener(t, n, o)
}
__name(patchAttr, 'patchAttr'),
  __name(patchDOMProp, 'patchDOMProp'),
  __name(addEventListener, 'addEventListener'),
  __name(removeEventListener, 'removeEventListener')
const veiKey = Symbol('_vei')
function patchEvent(e, t, n, o, i = null) {
  const r = e[veiKey] || (e[veiKey] = {}),
    a = r[t]
  if (o && a) a.value = o
  else {
    const [n, s] = parseName(t)
    if (o) {
      addEventListener(e, n, (r[t] = createInvoker(o, i)), s)
    } else a && (removeEventListener(e, n, a, s), (r[t] = void 0))
  }
}
__name(patchEvent, 'patchEvent')
const optionsModifierRE = /(?:Once|Passive|Capture)$/
function parseName(e) {
  let t
  if (optionsModifierRE.test(e)) {
    let n
    for (t = {}; (n = e.match(optionsModifierRE)); )
      (e = e.slice(0, e.length - n[0].length)), (t[n[0].toLowerCase()] = !0)
  }
  return [':' === e[2] ? e.slice(3) : hyphenate$1(e.slice(2)), t]
}
__name(parseName, 'parseName')
let cachedNow = 0
const p = Promise.resolve(),
  getNow = __name(
    () =>
      cachedNow || (p.then(() => (cachedNow = 0)), (cachedNow = Date.now())),
    'getNow'
  )
function createInvoker(e, t) {
  const n = __name((e) => {
    if (e._vts) {
      if (e._vts <= n.attached) return
    } else e._vts = Date.now()
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, n.value),
      t,
      5,
      [e]
    )
  }, 'invoker')
  return (n.value = e), (n.attached = getNow()), n
}
function sanitizeEventValue(e, t) {
  return isFunction$3(e) || isArray$3(e)
    ? e
    : (warn(
        `Wrong type passed as event handler to ${t} - did you forget @ or : in front of your prop?\nExpected function or array of functions, received type ${typeof e}.`
      ),
      NOOP)
}
function patchStopImmediatePropagation(e, t) {
  if (isArray$3(t)) {
    const n = e.stopImmediatePropagation
    return (
      (e.stopImmediatePropagation = () => {
        n.call(e), (e._stopped = !0)
      }),
      t.map((e) => (t) => !t._stopped && e && e(t))
    )
  }
  return t
}
__name(createInvoker, 'createInvoker'),
  __name(sanitizeEventValue, 'sanitizeEventValue'),
  __name(patchStopImmediatePropagation, 'patchStopImmediatePropagation')
const isNativeOn = __name(
    (e) =>
      111 === e.charCodeAt(0) &&
      110 === e.charCodeAt(1) &&
      e.charCodeAt(2) > 96 &&
      e.charCodeAt(2) < 123,
    'isNativeOn'
  ),
  patchProp = __name((e, t, n, o, i, r) => {
    const a = 'svg' === i
    'class' === t
      ? patchClass(e, o, a)
      : 'style' === t
        ? patchStyle(e, n, o)
        : isOn(t)
          ? isModelListener(t) || patchEvent(e, t, n, o, r)
          : (
                '.' === t[0]
                  ? ((t = t.slice(1)), 1)
                  : '^' === t[0]
                    ? ((t = t.slice(1)), 0)
                    : shouldSetAsProp(e, t, o, a)
              )
            ? (patchDOMProp(e, t, o),
              e.tagName.includes('-') ||
                ('value' !== t && 'checked' !== t && 'selected' !== t) ||
                patchAttr(e, t, o, a, r, 'value' !== t))
            : !e._isVueCE || (!/[A-Z]/.test(t) && isString$3(o))
              ? ('true-value' === t
                  ? (e._trueValue = o)
                  : 'false-value' === t && (e._falseValue = o),
                patchAttr(e, t, o, a))
              : patchDOMProp(e, camelize$1(t), o, r, t)
  }, 'patchProp')
function shouldSetAsProp(e, t, n, o) {
  if (o)
    return (
      'innerHTML' === t ||
      'textContent' === t ||
      !!(t in e && isNativeOn(t) && isFunction$3(n))
    )
  if ('spellcheck' === t || 'draggable' === t || 'translate' === t) return !1
  if ('form' === t) return !1
  if ('list' === t && 'INPUT' === e.tagName) return !1
  if ('type' === t && 'TEXTAREA' === e.tagName) return !1
  if ('width' === t || 'height' === t) {
    const t = e.tagName
    if ('IMG' === t || 'VIDEO' === t || 'CANVAS' === t || 'SOURCE' === t)
      return !1
  }
  return (!isNativeOn(t) || !isString$3(n)) && t in e
}
__name(shouldSetAsProp, 'shouldSetAsProp')
const REMOVAL = {}
/*! #__NO_SIDE_EFFECTS__ */ function defineCustomElement(e, t, n) {
  const o = defineComponent(e, t)
  isPlainObject$2(o) && extend$1(o, t)
  class i extends VueElement {
    static {
      __name(this, 'VueCustomElement')
    }
    constructor(e) {
      super(o, e, n)
    }
  }
  return (i.def = o), i
}
__name(defineCustomElement, 'defineCustomElement')
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = __name(
    (e, t) => defineCustomElement(e, t, createSSRApp),
    'defineSSRCustomElement'
  ),
  BaseClass = 'undefined' != typeof HTMLElement ? HTMLElement : class {}
class VueElement extends BaseClass {
  static {
    __name(this, 'VueElement')
  }
  constructor(e, t = {}, n = createApp) {
    super(),
      (this._def = e),
      (this._props = t),
      (this._createApp = n),
      (this._isVueCE = !0),
      (this._instance = null),
      (this._app = null),
      (this._nonce = this._def.nonce),
      (this._connected = !1),
      (this._resolved = !1),
      (this._numberProps = null),
      (this._styleChildren = new WeakSet()),
      (this._ob = null),
      this.shadowRoot && n !== createApp
        ? (this._root = this.shadowRoot)
        : !1 !== e.shadowRoot
          ? (this.attachShadow({ mode: 'open' }),
            (this._root = this.shadowRoot))
          : (this._root = this),
      this._def.__asyncLoader || this._resolveProps(this._def)
  }
  connectedCallback() {
    if (!this.isConnected) return
    this.shadowRoot || this._parseSlots(), (this._connected = !0)
    let e = this
    for (; (e = e && (e.parentNode || e.host)); )
      if (e instanceof VueElement) {
        this._parent = e
        break
      }
    this._instance ||
      (this._resolved
        ? (this._setParent(), this._update())
        : e && e._pendingResolve
          ? (this._pendingResolve = e._pendingResolve.then(() => {
              ;(this._pendingResolve = void 0), this._resolveDef()
            }))
          : this._resolveDef())
  }
  _setParent(e = this._parent) {
    e &&
      ((this._instance.parent = e._instance),
      (this._instance.provides = e._instance.provides))
  }
  disconnectedCallback() {
    ;(this._connected = !1),
      nextTick(() => {
        this._connected ||
          (this._ob && (this._ob.disconnect(), (this._ob = null)),
          this._app && this._app.unmount(),
          this._instance && (this._instance.ce = void 0),
          (this._app = this._instance = null))
      })
  }
  _resolveDef() {
    if (this._pendingResolve) return
    for (let n = 0; n < this.attributes.length; n++)
      this._setAttr(this.attributes[n].name)
    ;(this._ob = new MutationObserver((e) => {
      for (const t of e) this._setAttr(t.attributeName)
    })),
      this._ob.observe(this, { attributes: !0 })
    const e = __name((e, t = !1) => {
        ;(this._resolved = !0), (this._pendingResolve = void 0)
        const { props: n, styles: o } = e
        let i
        if (n && !isArray$3(n))
          for (const r in n) {
            const e = n[r]
            ;(e === Number || (e && e.type === Number)) &&
              (r in this._props && (this._props[r] = toNumber(this._props[r])),
              ((i || (i = Object.create(null)))[camelize$1(r)] = !0))
          }
        ;(this._numberProps = i),
          t && this._resolveProps(e),
          this.shadowRoot && this._applyStyles(o),
          this._mount(e)
      }, 'resolve'),
      t = this._def.__asyncLoader
    t
      ? (this._pendingResolve = t().then((t) => e((this._def = t), !0)))
      : e(this._def)
  }
  _mount(e) {
    ;(this._app = this._createApp(e)),
      e.configureApp && e.configureApp(this._app),
      (this._app._ceVNode = this._createVNode()),
      this._app.mount(this._root)
    const t = this._instance && this._instance.exposed
    if (t)
      for (const n in t)
        hasOwn$2(this, n) ||
          Object.defineProperty(this, n, {
            get: __name(() => unref(t[n]), 'get')
          })
  }
  _resolveProps(e) {
    const { props: t } = e,
      n = isArray$3(t) ? t : Object.keys(t || {})
    for (const o of Object.keys(this))
      '_' !== o[0] && n.includes(o) && this._setProp(o, this[o])
    for (const o of n.map(camelize$1))
      Object.defineProperty(this, o, {
        get() {
          return this._getProp(o)
        },
        set(e) {
          this._setProp(o, e, !0, !0)
        }
      })
  }
  _setAttr(e) {
    if (e.startsWith('data-v-')) return
    const t = this.hasAttribute(e)
    let n = t ? this.getAttribute(e) : REMOVAL
    const o = camelize$1(e)
    t && this._numberProps && this._numberProps[o] && (n = toNumber(n)),
      this._setProp(o, n, !1, !0)
  }
  _getProp(e) {
    return this._props[e]
  }
  _setProp(e, t, n = !0, o = !1) {
    if (
      t !== this._props[e] &&
      (t === REMOVAL
        ? delete this._props[e]
        : ((this._props[e] = t),
          'key' === e && this._app && (this._app._ceVNode.key = t)),
      o && this._instance && this._update(),
      n)
    ) {
      const n = this._ob
      n && n.disconnect(),
        !0 === t
          ? this.setAttribute(hyphenate$1(e), '')
          : 'string' == typeof t || 'number' == typeof t
            ? this.setAttribute(hyphenate$1(e), t + '')
            : t || this.removeAttribute(hyphenate$1(e)),
        n && n.observe(this, { attributes: !0 })
    }
  }
  _update() {
    render$U(this._createVNode(), this._root)
  }
  _createVNode() {
    const e = {}
    this.shadowRoot ||
      (e.onVnodeMounted = e.onVnodeUpdated = this._renderSlots.bind(this))
    const t = createVNode(this._def, extend$1(e, this._props))
    return (
      this._instance ||
        (t.ce = (e) => {
          ;(this._instance = e), (e.ce = this), (e.isCE = !0)
          const t = __name((e, t) => {
            this.dispatchEvent(
              new CustomEvent(
                e,
                isPlainObject$2(t[0])
                  ? extend$1({ detail: t }, t[0])
                  : { detail: t }
              )
            )
          }, 'dispatch')
          ;(e.emit = (e, ...n) => {
            t(e, n), hyphenate$1(e) !== e && t(hyphenate$1(e), n)
          }),
            this._setParent()
        }),
      t
    )
  }
  _applyStyles(e, t) {
    if (!e) return
    if (t) {
      if (t === this._def || this._styleChildren.has(t)) return
      this._styleChildren.add(t)
    }
    const n = this._nonce
    for (let o = e.length - 1; o >= 0; o--) {
      const t = document.createElement('style')
      n && t.setAttribute('nonce', n),
        (t.textContent = e[o]),
        this.shadowRoot.prepend(t)
    }
  }
  _parseSlots() {
    const e = (this._slots = {})
    let t
    for (; (t = this.firstChild); ) {
      const n = (1 === t.nodeType && t.getAttribute('slot')) || 'default'
      ;(e[n] || (e[n] = [])).push(t), this.removeChild(t)
    }
  }
  _renderSlots() {
    const e = (this._teleportTarget || this).querySelectorAll('slot'),
      t = this._instance.type.__scopeId
    for (let n = 0; n < e.length; n++) {
      const o = e[n],
        i = o.getAttribute('name') || 'default',
        r = this._slots[i],
        a = o.parentNode
      if (r)
        for (const e of r) {
          if (t && 1 === e.nodeType) {
            const n = t + '-s',
              o = document.createTreeWalker(e, 1)
            let i
            for (e.setAttribute(n, ''); (i = o.nextNode()); )
              i.setAttribute(n, '')
          }
          a.insertBefore(e, o)
        }
      else for (; o.firstChild; ) a.insertBefore(o.firstChild, o)
      a.removeChild(o)
    }
  }
  _injectChildStyle(e) {
    this._applyStyles(e.styles, e)
  }
  _removeChildStyle(e) {
    0
  }
}
function useHost(e) {
  const t = getCurrentInstance(),
    n = t && t.ce
  return n || null
}
function useShadowRoot() {
  const e = useHost()
  return e && e.shadowRoot
}
function useCssModule(e = '$style') {
  {
    const t = getCurrentInstance()
    if (!t) return EMPTY_OBJ
    const n = t.type.__cssModules
    if (!n) return EMPTY_OBJ
    const o = n[e]
    return o || EMPTY_OBJ
  }
}
__name(useHost, 'useHost'),
  __name(useShadowRoot, 'useShadowRoot'),
  __name(useCssModule, 'useCssModule')
const positionMap = new WeakMap(),
  newPositionMap = new WeakMap(),
  moveCbKey = Symbol('_moveCb'),
  enterCbKey = Symbol('_enterCb'),
  decorate = __name((e) => (delete e.props.mode, e), 'decorate'),
  TransitionGroupImpl = decorate({
    name: 'TransitionGroup',
    props: extend$1({}, TransitionPropsValidators, {
      tag: String,
      moveClass: String
    }),
    setup(e, { slots: t }) {
      const n = getCurrentInstance(),
        o = useTransitionState()
      let i, r
      return (
        onUpdated(() => {
          if (!i.length) return
          const t = e.moveClass || `${e.name || 'v'}-move`
          if (!hasCSSTransform(i[0].el, n.vnode.el, t)) return
          i.forEach(callPendingCbs), i.forEach(recordPosition)
          const o = i.filter(applyTranslation)
          forceReflow(),
            o.forEach((e) => {
              const n = e.el,
                o = n.style
              addTransitionClass(n, t),
                (o.transform = o.webkitTransform = o.transitionDuration = '')
              const i = (n[moveCbKey] = (e) => {
                ;(e && e.target !== n) ||
                  (e && !/transform$/.test(e.propertyName)) ||
                  (n.removeEventListener('transitionend', i),
                  (n[moveCbKey] = null),
                  removeTransitionClass(n, t))
              })
              n.addEventListener('transitionend', i)
            })
        }),
        () => {
          const a = toRaw(e),
            s = resolveTransitionProps(a)
          let l = a.tag || Fragment
          if (((i = []), r))
            for (let e = 0; e < r.length; e++) {
              const t = r[e]
              t.el &&
                t.el instanceof Element &&
                (i.push(t),
                setTransitionHooks(t, resolveTransitionHooks(t, s, o, n)),
                positionMap.set(t, t.el.getBoundingClientRect()))
            }
          r = t.default ? getTransitionRawChildren(t.default()) : []
          for (let e = 0; e < r.length; e++) {
            const t = r[e]
            null != t.key &&
              setTransitionHooks(t, resolveTransitionHooks(t, s, o, n))
          }
          return createVNode(l, null, r)
        }
      )
    }
  }),
  TransitionGroup = TransitionGroupImpl
function callPendingCbs(e) {
  const t = e.el
  t[moveCbKey] && t[moveCbKey](), t[enterCbKey] && t[enterCbKey]()
}
function recordPosition(e) {
  newPositionMap.set(e, e.el.getBoundingClientRect())
}
function applyTranslation(e) {
  const t = positionMap.get(e),
    n = newPositionMap.get(e),
    o = t.left - n.left,
    i = t.top - n.top
  if (o || i) {
    const t = e.el.style
    return (
      (t.transform = t.webkitTransform = `translate(${o}px,${i}px)`),
      (t.transitionDuration = '0s'),
      e
    )
  }
}
function hasCSSTransform(e, t, n) {
  const o = e.cloneNode(),
    i = e[vtcKey]
  i &&
    i.forEach((e) => {
      e.split(/\s+/).forEach((e) => e && o.classList.remove(e))
    }),
    n.split(/\s+/).forEach((e) => e && o.classList.add(e)),
    (o.style.display = 'none')
  const r = 1 === t.nodeType ? t : t.parentNode
  r.appendChild(o)
  const { hasTransform: a } = getTransitionInfo(o)
  return r.removeChild(o), a
}
__name(callPendingCbs, 'callPendingCbs'),
  __name(recordPosition, 'recordPosition'),
  __name(applyTranslation, 'applyTranslation'),
  __name(hasCSSTransform, 'hasCSSTransform')
const getModelAssigner = __name((e) => {
  const t = e.props['onUpdate:modelValue'] || !1
  return isArray$3(t) ? (e) => invokeArrayFns(t, e) : t
}, 'getModelAssigner')
function onCompositionStart(e) {
  e.target.composing = !0
}
function onCompositionEnd(e) {
  const t = e.target
  t.composing && ((t.composing = !1), t.dispatchEvent(new Event('input')))
}
__name(onCompositionStart, 'onCompositionStart'),
  __name(onCompositionEnd, 'onCompositionEnd')
const assignKey = Symbol('_assign'),
  vModelText = {
    created(e, { modifiers: { lazy: t, trim: n, number: o } }, i) {
      e[assignKey] = getModelAssigner(i)
      const r = o || (i.props && 'number' === i.props.type)
      addEventListener(e, t ? 'change' : 'input', (t) => {
        if (t.target.composing) return
        let o = e.value
        n && (o = o.trim()), r && (o = looseToNumber(o)), e[assignKey](o)
      }),
        n &&
          addEventListener(e, 'change', () => {
            e.value = e.value.trim()
          }),
        t ||
          (addEventListener(e, 'compositionstart', onCompositionStart),
          addEventListener(e, 'compositionend', onCompositionEnd),
          addEventListener(e, 'change', onCompositionEnd))
    },
    mounted(e, { value: t }) {
      e.value = null == t ? '' : t
    },
    beforeUpdate(
      e,
      { value: t, oldValue: n, modifiers: { lazy: o, trim: i, number: r } },
      a
    ) {
      if (((e[assignKey] = getModelAssigner(a)), e.composing)) return
      const s = null == t ? '' : t
      if (
        ((!r && 'number' !== e.type) || /^0\d/.test(e.value)
          ? e.value
          : looseToNumber(e.value)) !== s
      ) {
        if (document.activeElement === e && 'range' !== e.type) {
          if (o && t === n) return
          if (i && e.value.trim() === s) return
        }
        e.value = s
      }
    }
  },
  vModelCheckbox = {
    deep: !0,
    created(e, t, n) {
      ;(e[assignKey] = getModelAssigner(n)),
        addEventListener(e, 'change', () => {
          const t = e._modelValue,
            n = getValue$1(e),
            o = e.checked,
            i = e[assignKey]
          if (isArray$3(t)) {
            const e = looseIndexOf(t, n),
              r = -1 !== e
            if (o && !r) i(t.concat(n))
            else if (!o && r) {
              const n = [...t]
              n.splice(e, 1), i(n)
            }
          } else if (isSet(t)) {
            const e = new Set(t)
            o ? e.add(n) : e.delete(n), i(e)
          } else i(getCheckboxValue(e, o))
        })
    },
    mounted: setChecked,
    beforeUpdate(e, t, n) {
      ;(e[assignKey] = getModelAssigner(n)), setChecked(e, t, n)
    }
  }
function setChecked(e, { value: t, oldValue: n }, o) {
  let i
  if (((e._modelValue = t), isArray$3(t)))
    i = looseIndexOf(t, o.props.value) > -1
  else if (isSet(t)) i = t.has(o.props.value)
  else {
    if (t === n) return
    i = looseEqual(t, getCheckboxValue(e, !0))
  }
  e.checked !== i && (e.checked = i)
}
__name(setChecked, 'setChecked')
const vModelRadio = {
    created(e, { value: t }, n) {
      ;(e.checked = looseEqual(t, n.props.value)),
        (e[assignKey] = getModelAssigner(n)),
        addEventListener(e, 'change', () => {
          e[assignKey](getValue$1(e))
        })
    },
    beforeUpdate(e, { value: t, oldValue: n }, o) {
      ;(e[assignKey] = getModelAssigner(o)),
        t !== n && (e.checked = looseEqual(t, o.props.value))
    }
  },
  vModelSelect = {
    deep: !0,
    created(e, { value: t, modifiers: { number: n } }, o) {
      const i = isSet(t)
      addEventListener(e, 'change', () => {
        const t = Array.prototype.filter
          .call(e.options, (e) => e.selected)
          .map((e) => (n ? looseToNumber(getValue$1(e)) : getValue$1(e)))
        e[assignKey](e.multiple ? (i ? new Set(t) : t) : t[0]),
          (e._assigning = !0),
          nextTick(() => {
            e._assigning = !1
          })
      }),
        (e[assignKey] = getModelAssigner(o))
    },
    mounted(e, { value: t }) {
      setSelected(e, t)
    },
    beforeUpdate(e, t, n) {
      e[assignKey] = getModelAssigner(n)
    },
    updated(e, { value: t }) {
      e._assigning || setSelected(e, t)
    }
  }
function setSelected(e, t) {
  const n = e.multiple,
    o = isArray$3(t)
  if (!n || o || isSet(t)) {
    for (let i = 0, r = e.options.length; i < r; i++) {
      const r = e.options[i],
        a = getValue$1(r)
      if (n)
        if (o) {
          const e = typeof a
          r.selected =
            'string' === e || 'number' === e
              ? t.some((e) => String(e) === String(a))
              : looseIndexOf(t, a) > -1
        } else r.selected = t.has(a)
      else if (looseEqual(getValue$1(r), t))
        return void (e.selectedIndex !== i && (e.selectedIndex = i))
    }
    n || -1 === e.selectedIndex || (e.selectedIndex = -1)
  }
}
function getValue$1(e) {
  return '_value' in e ? e._value : e.value
}
function getCheckboxValue(e, t) {
  const n = t ? '_trueValue' : '_falseValue'
  return n in e ? e[n] : t
}
__name(setSelected, 'setSelected'),
  __name(getValue$1, 'getValue$1'),
  __name(getCheckboxValue, 'getCheckboxValue')
const vModelDynamic = {
  created(e, t, n) {
    callModelHook(e, t, n, null, 'created')
  },
  mounted(e, t, n) {
    callModelHook(e, t, n, null, 'mounted')
  },
  beforeUpdate(e, t, n, o) {
    callModelHook(e, t, n, o, 'beforeUpdate')
  },
  updated(e, t, n, o) {
    callModelHook(e, t, n, o, 'updated')
  }
}
function resolveDynamicModel(e, t) {
  switch (e) {
    case 'SELECT':
      return vModelSelect
    case 'TEXTAREA':
      return vModelText
    default:
      switch (t) {
        case 'checkbox':
          return vModelCheckbox
        case 'radio':
          return vModelRadio
        default:
          return vModelText
      }
  }
}
function callModelHook(e, t, n, o, i) {
  const r = resolveDynamicModel(e.tagName, n.props && n.props.type)[i]
  r && r(e, t, n, o)
}
function initVModelForSSR() {
  ;(vModelText.getSSRProps = ({ value: e }) => ({ value: e })),
    (vModelRadio.getSSRProps = ({ value: e }, t) => {
      if (t.props && looseEqual(t.props.value, e)) return { checked: !0 }
    }),
    (vModelCheckbox.getSSRProps = ({ value: e }, t) => {
      if (isArray$3(e)) {
        if (t.props && looseIndexOf(e, t.props.value) > -1)
          return { checked: !0 }
      } else if (isSet(e)) {
        if (t.props && e.has(t.props.value)) return { checked: !0 }
      } else if (e) return { checked: !0 }
    }),
    (vModelDynamic.getSSRProps = (e, t) => {
      if ('string' != typeof t.type) return
      const n = resolveDynamicModel(
        t.type.toUpperCase(),
        t.props && t.props.type
      )
      return n.getSSRProps ? n.getSSRProps(e, t) : void 0
    })
}
__name(resolveDynamicModel, 'resolveDynamicModel'),
  __name(callModelHook, 'callModelHook'),
  __name(initVModelForSSR, 'initVModelForSSR')
const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'],
  modifierGuards = {
    stop: __name((e) => e.stopPropagation(), 'stop'),
    prevent: __name((e) => e.preventDefault(), 'prevent'),
    self: __name((e) => e.target !== e.currentTarget, 'self'),
    ctrl: __name((e) => !e.ctrlKey, 'ctrl'),
    shift: __name((e) => !e.shiftKey, 'shift'),
    alt: __name((e) => !e.altKey, 'alt'),
    meta: __name((e) => !e.metaKey, 'meta'),
    left: __name((e) => 'button' in e && 0 !== e.button, 'left'),
    middle: __name((e) => 'button' in e && 1 !== e.button, 'middle'),
    right: __name((e) => 'button' in e && 2 !== e.button, 'right'),
    exact: __name(
      (e, t) => systemModifiers.some((n) => e[`${n}Key`] && !t.includes(n)),
      'exact'
    )
  },
  withModifiers = __name((e, t) => {
    const n = e._withMods || (e._withMods = {}),
      o = t.join('.')
    return (
      n[o] ||
      (n[o] = (n, ...o) => {
        for (let e = 0; e < t.length; e++) {
          const o = modifierGuards[t[e]]
          if (o && o(n, t)) return
        }
        return e(n, ...o)
      })
    )
  }, 'withModifiers'),
  keyNames = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace'
  },
  withKeys = __name((e, t) => {
    const n = e._withKeys || (e._withKeys = {}),
      o = t.join('.')
    return (
      n[o] ||
      (n[o] = (n) => {
        if (!('key' in n)) return
        const o = hyphenate$1(n.key)
        return t.some((e) => e === o || keyNames[e] === o) ? e(n) : void 0
      })
    )
  }, 'withKeys'),
  rendererOptions = extend$1({ patchProp: patchProp }, nodeOps)
let renderer,
  enabledHydration = !1
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions))
}
function ensureHydrationRenderer() {
  return (
    (renderer = enabledHydration
      ? renderer
      : createHydrationRenderer(rendererOptions)),
    (enabledHydration = !0),
    renderer
  )
}
__name(ensureRenderer, 'ensureRenderer'),
  __name(ensureHydrationRenderer, 'ensureHydrationRenderer')
const render$U = __name((...e) => {
    ensureRenderer().render(...e)
  }, 'render$U'),
  hydrate = __name((...e) => {
    ensureHydrationRenderer().hydrate(...e)
  }, 'hydrate'),
  createApp = __name((...e) => {
    const t = ensureRenderer().createApp(...e)
    const { mount: n } = t
    return (
      (t.mount = (e) => {
        const o = normalizeContainer(e)
        if (!o) return
        const i = t._component
        isFunction$3(i) || i.render || i.template || (i.template = o.innerHTML),
          1 === o.nodeType && (o.textContent = '')
        const r = n(o, !1, resolveRootNamespace(o))
        return (
          o instanceof Element &&
            (o.removeAttribute('v-cloak'), o.setAttribute('data-v-app', '')),
          r
        )
      }),
      t
    )
  }, 'createApp'),
  createSSRApp = __name((...e) => {
    const t = ensureHydrationRenderer().createApp(...e)
    const { mount: n } = t
    return (
      (t.mount = (e) => {
        const t = normalizeContainer(e)
        if (t) return n(t, !0, resolveRootNamespace(t))
      }),
      t
    )
  }, 'createSSRApp')
function resolveRootNamespace(e) {
  return e instanceof SVGElement
    ? 'svg'
    : 'function' == typeof MathMLElement && e instanceof MathMLElement
      ? 'mathml'
      : void 0
}
function injectNativeTagCheck(e) {
  Object.defineProperty(e.config, 'isNativeTag', {
    value: __name(
      (e) => isHTMLTag(e) || isSVGTag(e) || isMathMLTag(e),
      'value'
    ),
    writable: !1
  })
}
function injectCompilerOptionsCheck(e) {
  if (isRuntimeOnly()) {
    const t = e.config.isCustomElement
    Object.defineProperty(e.config, 'isCustomElement', {
      get: () => t,
      set() {
        warn(
          'The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.'
        )
      }
    })
    const n = e.config.compilerOptions,
      o =
        'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc'
    Object.defineProperty(e.config, 'compilerOptions', {
      get: () => (warn(o), n),
      set() {
        warn(o)
      }
    })
  }
}
function normalizeContainer(e) {
  if (isString$3(e)) {
    return document.querySelector(e)
  }
  return e
}
__name(resolveRootNamespace, 'resolveRootNamespace'),
  __name(injectNativeTagCheck, 'injectNativeTagCheck'),
  __name(injectCompilerOptionsCheck, 'injectCompilerOptionsCheck'),
  __name(normalizeContainer, 'normalizeContainer')
let ssrDirectiveInitialized = !1
const initDirectivesForSSR = __name(() => {
  ssrDirectiveInitialized ||
    ((ssrDirectiveInitialized = !0), initVModelForSSR(), initVShowForSSR())
}, 'initDirectivesForSSR')
/**
 * vue v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function initDev() {
  initCustomFormatter()
}
__name(initDev, 'initDev')
const compile = __name(() => {
  0
}, 'compile')
var isVue2 = !1,
  isVue3 = !0,
  Vue2 = void 0
function install$4() {}
function set$1(e, t, n) {
  return Array.isArray(e)
    ? ((e.length = Math.max(e.length, t)), e.splice(t, 1, n), n)
    : ((e[t] = n), n)
}
function del(e, t) {
  Array.isArray(e) ? e.splice(t, 1) : delete e[t]
}
__name(install$4, 'install$4'), __name(set$1, 'set$1'), __name(del, 'del')
const _global_Vue = Vue
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__
}
function getTarget() {
  return 'undefined' != typeof navigator && 'undefined' != typeof window
    ? window
    : 'undefined' != typeof globalThis
      ? globalThis
      : {}
}
__name(getDevtoolsGlobalHook, 'getDevtoolsGlobalHook'),
  __name(getTarget, 'getTarget')
const isProxyAvailable = 'function' == typeof Proxy,
  HOOK_SETUP = 'devtools-plugin:setup',
  HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set'
let supported, perf, activePinia
function isPerformanceSupported() {
  var e
  return (
    void 0 !== supported ||
      ('undefined' != typeof window && window.performance
        ? ((supported = !0), (perf = window.performance))
        : 'undefined' != typeof globalThis &&
            (null === (e = globalThis.perf_hooks) || void 0 === e
              ? void 0
              : e.performance)
          ? ((supported = !0), (perf = globalThis.perf_hooks.performance))
          : (supported = !1)),
    supported
  )
}
function now$1() {
  return isPerformanceSupported() ? perf.now() : Date.now()
}
__name(isPerformanceSupported, 'isPerformanceSupported'), __name(now$1, 'now$1')
class ApiProxy {
  static {
    __name(this, 'ApiProxy')
  }
  constructor(e, t) {
    ;(this.target = null),
      (this.targetQueue = []),
      (this.onQueue = []),
      (this.plugin = e),
      (this.hook = t)
    const n = {}
    if (e.settings)
      for (const r in e.settings) {
        const t = e.settings[r]
        n[r] = t.defaultValue
      }
    const o = `__vue-devtools-plugin-settings__${e.id}`
    let i = Object.assign({}, n)
    try {
      const e = localStorage.getItem(o),
        t = JSON.parse(e)
      Object.assign(i, t)
    } catch (e2) {}
    ;(this.fallbacks = {
      getSettings: () => i,
      setSettings(e) {
        try {
          localStorage.setItem(o, JSON.stringify(e))
        } catch (e2) {}
        i = e
      },
      now: () => now$1()
    }),
      t &&
        t.on(HOOK_PLUGIN_SETTINGS_SET, (e, t) => {
          e === this.plugin.id && this.fallbacks.setSettings(t)
        }),
      (this.proxiedOn = new Proxy(
        {},
        {
          get: __name(
            (e, t) =>
              this.target
                ? this.target.on[t]
                : (...e) => {
                    this.onQueue.push({ method: t, args: e })
                  },
            'get'
          )
        }
      )),
      (this.proxiedTarget = new Proxy(
        {},
        {
          get: __name(
            (e, t) =>
              this.target
                ? this.target[t]
                : 'on' === t
                  ? this.proxiedOn
                  : Object.keys(this.fallbacks).includes(t)
                    ? (...e) => (
                        this.targetQueue.push({
                          method: t,
                          args: e,
                          resolve: __name(() => {}, 'resolve')
                        }),
                        this.fallbacks[t](...e)
                      )
                    : (...e) =>
                        new Promise((n) => {
                          this.targetQueue.push({
                            method: t,
                            args: e,
                            resolve: n
                          })
                        }),
            'get'
          )
        }
      ))
  }
  async setRealTarget(e) {
    this.target = e
    for (const t of this.onQueue) this.target.on[t.method](...t.args)
    for (const t of this.targetQueue)
      t.resolve(await this.target[t.method](...t.args))
  }
}
function setupDevtoolsPlugin(e, t) {
  const n = e,
    o = getTarget(),
    i = getDevtoolsGlobalHook(),
    r = isProxyAvailable && n.enableEarlyProxy
  if (!i || (!o.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ && r)) {
    const e = r ? new ApiProxy(n, i) : null
    ;(o.__VUE_DEVTOOLS_PLUGINS__ = o.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: t,
      proxy: e
    }),
      e && t(e.proxiedTarget)
  } else i.emit(HOOK_SETUP, e, t)
}
__name(setupDevtoolsPlugin, 'setupDevtoolsPlugin')
const setActivePinia = __name((e) => (activePinia = e), 'setActivePinia'),
  getActivePinia = __name(
    () => (hasInjectionContext() && inject(piniaSymbol)) || activePinia,
    'getActivePinia'
  ),
  piniaSymbol = Symbol()
function isPlainObject$1(e) {
  return (
    e &&
    'object' == typeof e &&
    '[object Object]' === Object.prototype.toString.call(e) &&
    'function' != typeof e.toJSON
  )
}
var MutationType, MutationType2
__name(isPlainObject$1, 'isPlainObject$1'),
  (MutationType2 = MutationType || (MutationType = {})),
  (MutationType2.direct = 'direct'),
  (MutationType2.patchObject = 'patch object'),
  (MutationType2.patchFunction = 'patch function')
const IS_CLIENT = 'undefined' != typeof window,
  _global$2 = (() =>
    'object' == typeof window && window.window === window
      ? window
      : 'object' == typeof self && self.self === self
        ? self
        : 'object' == typeof global && global.global === global
          ? global
          : 'object' == typeof globalThis
            ? globalThis
            : { HTMLElement: null })()
function bom(e, { autoBom: t = !1 } = {}) {
  return t &&
    /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(
      e.type
    )
    ? new Blob([String.fromCharCode(65279), e], { type: e.type })
    : e
}
function download$4(e, t, n) {
  const o = new XMLHttpRequest()
  o.open('GET', e),
    (o.responseType = 'blob'),
    (o.onload = function () {
      saveAs$1(o.response, t, n)
    }),
    (o.onerror = function () {
      console.error('could not download file')
    }),
    o.send()
}
function corsEnabled(e) {
  const t = new XMLHttpRequest()
  t.open('HEAD', e, !1)
  try {
    t.send()
  } catch (e2) {}
  return t.status >= 200 && t.status <= 299
}
function click(e) {
  try {
    e.dispatchEvent(new MouseEvent('click'))
  } catch (e2) {
    const n = document.createEvent('MouseEvents')
    n.initMouseEvent(
      'click',
      !0,
      !0,
      window,
      0,
      0,
      0,
      80,
      20,
      !1,
      !1,
      !1,
      !1,
      0,
      null
    ),
      e.dispatchEvent(n)
  }
}
__name(bom, 'bom'),
  __name(download$4, 'download$4'),
  __name(corsEnabled, 'corsEnabled'),
  __name(click, 'click')
const _navigator$1 =
    'object' == typeof navigator ? navigator : { userAgent: '' },
  isMacOSWebView = (() =>
    /Macintosh/.test(_navigator$1.userAgent) &&
    /AppleWebKit/.test(_navigator$1.userAgent) &&
    !/Safari/.test(_navigator$1.userAgent))(),
  saveAs$1 = IS_CLIENT
    ? 'undefined' != typeof HTMLAnchorElement &&
      'download' in HTMLAnchorElement.prototype &&
      !isMacOSWebView
      ? downloadSaveAs
      : 'msSaveOrOpenBlob' in _navigator$1
        ? msSaveAs
        : fileSaverSaveAs
    : () => {}
function downloadSaveAs(e, t = 'download', n) {
  const o = document.createElement('a')
  ;(o.download = t),
    (o.rel = 'noopener'),
    'string' == typeof e
      ? ((o.href = e),
        o.origin !== location.origin
          ? corsEnabled(o.href)
            ? download$4(e, t, n)
            : ((o.target = '_blank'), click(o))
          : click(o))
      : ((o.href = URL.createObjectURL(e)),
        setTimeout(function () {
          URL.revokeObjectURL(o.href)
        }, 4e4),
        setTimeout(function () {
          click(o)
        }, 0))
}
function msSaveAs(e, t = 'download', n) {
  if ('string' == typeof e)
    if (corsEnabled(e)) download$4(e, t, n)
    else {
      const t = document.createElement('a')
      ;(t.href = e),
        (t.target = '_blank'),
        setTimeout(function () {
          click(t)
        })
    }
  else navigator.msSaveOrOpenBlob(bom(e, n), t)
}
function fileSaverSaveAs(e, t, n, o) {
  if (
    ((o = o || open('', '_blank')) &&
      (o.document.title = o.document.body.innerText = 'downloading...'),
    'string' == typeof e)
  )
    return download$4(e, t, n)
  const i = 'application/octet-stream' === e.type,
    r =
      /constructor/i.test(String(_global$2.HTMLElement)) ||
      'safari' in _global$2,
    a = /CriOS\/[\d]+/.test(navigator.userAgent)
  if ((a || (i && r) || isMacOSWebView) && 'undefined' != typeof FileReader) {
    const t = new FileReader()
    ;(t.onloadend = function () {
      let e = t.result
      if ('string' != typeof e)
        throw ((o = null), new Error('Wrong reader.result type'))
      ;(e = a ? e : e.replace(/^data:[^;]*;/, 'data:attachment/file;')),
        o ? (o.location.href = e) : location.assign(e),
        (o = null)
    }),
      t.readAsDataURL(e)
  } else {
    const t = URL.createObjectURL(e)
    o ? o.location.assign(t) : (location.href = t),
      (o = null),
      setTimeout(function () {
        URL.revokeObjectURL(t)
      }, 4e4)
  }
}
function toastMessage(e, t) {
  const n = '🍍 ' + e
  'function' == typeof __VUE_DEVTOOLS_TOAST__
    ? __VUE_DEVTOOLS_TOAST__(n, t)
    : 'error' === t
      ? console.error(n)
      : 'warn' === t
        ? console.warn(n)
        : console.log(n)
}
function isPinia(e) {
  return '_a' in e && 'install' in e
}
function checkClipboardAccess() {
  if (!('clipboard' in navigator))
    return (
      toastMessage("Your browser doesn't support the Clipboard API", 'error'),
      !0
    )
}
function checkNotFocusedError(e) {
  return (
    !!(
      e instanceof Error &&
      e.message.toLowerCase().includes('document is not focused')
    ) &&
    (toastMessage(
      'You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.',
      'warn'
    ),
    !0)
  )
}
async function actionGlobalCopyState(e) {
  if (!checkClipboardAccess())
    try {
      await navigator.clipboard.writeText(JSON.stringify(e.state.value)),
        toastMessage('Global state copied to clipboard.')
    } catch (t) {
      if (checkNotFocusedError(t)) return
      toastMessage(
        'Failed to serialize the state. Check the console for more details.',
        'error'
      ),
        console.error(t)
    }
}
async function actionGlobalPasteState(e) {
  if (!checkClipboardAccess())
    try {
      loadStoresState(e, JSON.parse(await navigator.clipboard.readText())),
        toastMessage('Global state pasted from clipboard.')
    } catch (t) {
      if (checkNotFocusedError(t)) return
      toastMessage(
        'Failed to deserialize the state from clipboard. Check the console for more details.',
        'error'
      ),
        console.error(t)
    }
}
async function actionGlobalSaveState(e) {
  try {
    saveAs$1(
      new Blob([JSON.stringify(e.state.value)], {
        type: 'text/plain;charset=utf-8'
      }),
      'pinia-state.json'
    )
  } catch (t) {
    toastMessage(
      'Failed to export the state as JSON. Check the console for more details.',
      'error'
    ),
      console.error(t)
  }
}
let fileInput
function getFileOpener() {
  function e() {
    return new Promise((e, t) => {
      ;(fileInput.onchange = async () => {
        const t = fileInput.files
        if (!t) return e(null)
        const n = t.item(0)
        return e(n ? { text: await n.text(), file: n } : null)
      }),
        (fileInput.oncancel = () => e(null)),
        (fileInput.onerror = t),
        fileInput.click()
    })
  }
  return (
    fileInput ||
      ((fileInput = document.createElement('input')),
      (fileInput.type = 'file'),
      (fileInput.accept = '.json')),
    __name(e, 'openFile'),
    e
  )
}
async function actionGlobalOpenStateFile(e) {
  try {
    const t = getFileOpener(),
      n = await t()
    if (!n) return
    const { text: o, file: i } = n
    loadStoresState(e, JSON.parse(o)),
      toastMessage(`Global state imported from "${i.name}".`)
  } catch (t) {
    toastMessage(
      'Failed to import the state from JSON. Check the console for more details.',
      'error'
    ),
      console.error(t)
  }
}
function loadStoresState(e, t) {
  for (const n in t) {
    const o = e.state.value[n]
    o ? Object.assign(o, t[n]) : (e.state.value[n] = t[n])
  }
}
function formatDisplay(e) {
  return { _custom: { display: e } }
}
__name(downloadSaveAs, 'downloadSaveAs'),
  __name(msSaveAs, 'msSaveAs'),
  __name(fileSaverSaveAs, 'fileSaverSaveAs'),
  __name(toastMessage, 'toastMessage'),
  __name(isPinia, 'isPinia'),
  __name(checkClipboardAccess, 'checkClipboardAccess'),
  __name(checkNotFocusedError, 'checkNotFocusedError'),
  __name(actionGlobalCopyState, 'actionGlobalCopyState'),
  __name(actionGlobalPasteState, 'actionGlobalPasteState'),
  __name(actionGlobalSaveState, 'actionGlobalSaveState'),
  __name(getFileOpener, 'getFileOpener'),
  __name(actionGlobalOpenStateFile, 'actionGlobalOpenStateFile'),
  __name(loadStoresState, 'loadStoresState'),
  __name(formatDisplay, 'formatDisplay')
const PINIA_ROOT_LABEL = '🍍 Pinia (root)',
  PINIA_ROOT_ID = '_root'
function formatStoreForInspectorTree(e) {
  return isPinia(e)
    ? { id: PINIA_ROOT_ID, label: PINIA_ROOT_LABEL }
    : { id: e.$id, label: e.$id }
}
function formatStoreForInspectorState(e) {
  if (isPinia(e)) {
    const t = Array.from(e._s.keys()),
      n = e._s
    return {
      state: t.map((t) => ({ editable: !0, key: t, value: e.state.value[t] })),
      getters: t
        .filter((e) => n.get(e)._getters)
        .map((e) => {
          const t = n.get(e)
          return {
            editable: !1,
            key: e,
            value: t._getters.reduce((e, n) => ((e[n] = t[n]), e), {})
          }
        })
    }
  }
  const t = {
    state: Object.keys(e.$state).map((t) => ({
      editable: !0,
      key: t,
      value: e.$state[t]
    }))
  }
  return (
    e._getters &&
      e._getters.length &&
      (t.getters = e._getters.map((t) => ({
        editable: !1,
        key: t,
        value: e[t]
      }))),
    e._customProperties.size &&
      (t.customProperties = Array.from(e._customProperties).map((t) => ({
        editable: !0,
        key: t,
        value: e[t]
      }))),
    t
  )
}
function formatEventData(e) {
  return e
    ? Array.isArray(e)
      ? e.reduce(
          (e, t) => (
            e.keys.push(t.key),
            e.operations.push(t.type),
            (e.oldValue[t.key] = t.oldValue),
            (e.newValue[t.key] = t.newValue),
            e
          ),
          { oldValue: {}, keys: [], operations: [], newValue: {} }
        )
      : {
          operation: formatDisplay(e.type),
          key: formatDisplay(e.key),
          oldValue: e.oldValue,
          newValue: e.newValue
        }
    : {}
}
function formatMutationType(e) {
  switch (e) {
    case MutationType.direct:
      return 'mutation'
    case MutationType.patchFunction:
    case MutationType.patchObject:
      return '$patch'
    default:
      return 'unknown'
  }
}
__name(formatStoreForInspectorTree, 'formatStoreForInspectorTree'),
  __name(formatStoreForInspectorState, 'formatStoreForInspectorState'),
  __name(formatEventData, 'formatEventData'),
  __name(formatMutationType, 'formatMutationType')
let isTimelineActive = !0
const componentStateTypes = [],
  MUTATIONS_LAYER_ID = 'pinia:mutations',
  INSPECTOR_ID = 'pinia',
  { assign: assign$1 } = Object,
  getStoreType = __name((e) => '🍍 ' + e, 'getStoreType')
function registerPiniaDevtools(e, t) {
  setupDevtoolsPlugin(
    {
      id: 'dev.esm.pinia',
      label: 'Pinia 🍍',
      logo: 'https://pinia.vuejs.org/logo.svg',
      packageName: 'pinia',
      homepage: 'https://pinia.vuejs.org',
      componentStateTypes: componentStateTypes,
      app: e
    },
    (n) => {
      'function' != typeof n.now &&
        toastMessage(
          'You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.'
        ),
        n.addTimelineLayer({
          id: MUTATIONS_LAYER_ID,
          label: 'Pinia 🍍',
          color: 15064968
        }),
        n.addInspector({
          id: INSPECTOR_ID,
          label: 'Pinia 🍍',
          icon: 'storage',
          treeFilterPlaceholder: 'Search stores',
          actions: [
            {
              icon: 'content_copy',
              action: __name(() => {
                actionGlobalCopyState(t)
              }, 'action'),
              tooltip: 'Serialize and copy the state'
            },
            {
              icon: 'content_paste',
              action: __name(async () => {
                await actionGlobalPasteState(t),
                  n.sendInspectorTree(INSPECTOR_ID),
                  n.sendInspectorState(INSPECTOR_ID)
              }, 'action'),
              tooltip: 'Replace the state with the content of your clipboard'
            },
            {
              icon: 'save',
              action: __name(() => {
                actionGlobalSaveState(t)
              }, 'action'),
              tooltip: 'Save the state as a JSON file'
            },
            {
              icon: 'folder_open',
              action: __name(async () => {
                await actionGlobalOpenStateFile(t),
                  n.sendInspectorTree(INSPECTOR_ID),
                  n.sendInspectorState(INSPECTOR_ID)
              }, 'action'),
              tooltip: 'Import the state from a JSON file'
            }
          ],
          nodeActions: [
            {
              icon: 'restore',
              tooltip: 'Reset the state (with "$reset")',
              action: __name((e) => {
                const n = t._s.get(e)
                n
                  ? 'function' != typeof n.$reset
                    ? toastMessage(
                        `Cannot reset "${e}" store because it doesn't have a "$reset" method implemented.`,
                        'warn'
                      )
                    : (n.$reset(), toastMessage(`Store "${e}" reset.`))
                  : toastMessage(
                      `Cannot reset "${e}" store because it wasn't found.`,
                      'warn'
                    )
              }, 'action')
            }
          ]
        }),
        n.on.inspectComponent((e, t) => {
          const n = e.componentInstance && e.componentInstance.proxy
          if (n && n._pStores) {
            const t = e.componentInstance.proxy._pStores
            Object.values(t).forEach((t) => {
              e.instanceData.state.push({
                type: getStoreType(t.$id),
                key: 'state',
                editable: !0,
                value: t._isOptionsAPI
                  ? {
                      _custom: {
                        value: toRaw(t.$state),
                        actions: [
                          {
                            icon: 'restore',
                            tooltip: 'Reset the state of this store',
                            action: __name(() => t.$reset(), 'action')
                          }
                        ]
                      }
                    }
                  : Object.keys(t.$state).reduce(
                      (e, n) => ((e[n] = t.$state[n]), e),
                      {}
                    )
              }),
                t._getters &&
                  t._getters.length &&
                  e.instanceData.state.push({
                    type: getStoreType(t.$id),
                    key: 'getters',
                    editable: !1,
                    value: t._getters.reduce((e, n) => {
                      try {
                        e[n] = t[n]
                      } catch (o) {
                        e[n] = o
                      }
                      return e
                    }, {})
                  })
            })
          }
        }),
        n.on.getInspectorTree((n) => {
          if (n.app === e && n.inspectorId === INSPECTOR_ID) {
            let e = [t]
            ;(e = e.concat(Array.from(t._s.values()))),
              (n.rootNodes = (
                n.filter
                  ? e.filter((e) =>
                      '$id' in e
                        ? e.$id.toLowerCase().includes(n.filter.toLowerCase())
                        : PINIA_ROOT_LABEL.toLowerCase().includes(
                            n.filter.toLowerCase()
                          )
                    )
                  : e
              ).map(formatStoreForInspectorTree))
          }
        }),
        (globalThis.$pinia = t),
        n.on.getInspectorState((n) => {
          if (n.app === e && n.inspectorId === INSPECTOR_ID) {
            const e = n.nodeId === PINIA_ROOT_ID ? t : t._s.get(n.nodeId)
            if (!e) return
            e &&
              (n.nodeId !== PINIA_ROOT_ID && (globalThis.$store = toRaw(e)),
              (n.state = formatStoreForInspectorState(e)))
          }
        }),
        n.on.editInspectorState((n, o) => {
          if (n.app === e && n.inspectorId === INSPECTOR_ID) {
            const e = n.nodeId === PINIA_ROOT_ID ? t : t._s.get(n.nodeId)
            if (!e)
              return toastMessage(`store "${n.nodeId}" not found`, 'error')
            const { path: o } = n
            isPinia(e)
              ? o.unshift('state')
              : (1 === o.length &&
                  e._customProperties.has(o[0]) &&
                  !(o[0] in e.$state)) ||
                o.unshift('$state'),
              (isTimelineActive = !1),
              n.set(e, o, n.state.value),
              (isTimelineActive = !0)
          }
        }),
        n.on.editComponentState((e) => {
          if (e.type.startsWith('🍍')) {
            const n = e.type.replace(/^🍍\s*/, ''),
              o = t._s.get(n)
            if (!o) return toastMessage(`store "${n}" not found`, 'error')
            const { path: i } = e
            if ('state' !== i[0])
              return toastMessage(
                `Invalid path for store "${n}":\n${i}\nOnly state can be modified.`
              )
            ;(i[0] = '$state'),
              (isTimelineActive = !1),
              e.set(o, i, e.state.value),
              (isTimelineActive = !0)
          }
        })
    }
  )
}
function addStoreToDevtools(e, t) {
  componentStateTypes.includes(getStoreType(t.$id)) ||
    componentStateTypes.push(getStoreType(t.$id)),
    setupDevtoolsPlugin(
      {
        id: 'dev.esm.pinia',
        label: 'Pinia 🍍',
        logo: 'https://pinia.vuejs.org/logo.svg',
        packageName: 'pinia',
        homepage: 'https://pinia.vuejs.org',
        componentStateTypes: componentStateTypes,
        app: e,
        settings: {
          logStoreChanges: {
            label: 'Notify about new/deleted stores',
            type: 'boolean',
            defaultValue: !0
          }
        }
      },
      (e) => {
        const n = 'function' == typeof e.now ? e.now.bind(e) : Date.now
        t.$onAction(({ after: o, onError: i, name: r, args: a }) => {
          const s = runningActionId++
          e.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: n(),
              title: '🛫 ' + r,
              subtitle: 'start',
              data: {
                store: formatDisplay(t.$id),
                action: formatDisplay(r),
                args: a
              },
              groupId: s
            }
          }),
            o((o) => {
              ;(activeAction = void 0),
                e.addTimelineEvent({
                  layerId: MUTATIONS_LAYER_ID,
                  event: {
                    time: n(),
                    title: '🛬 ' + r,
                    subtitle: 'end',
                    data: {
                      store: formatDisplay(t.$id),
                      action: formatDisplay(r),
                      args: a,
                      result: o
                    },
                    groupId: s
                  }
                })
            }),
            i((o) => {
              ;(activeAction = void 0),
                e.addTimelineEvent({
                  layerId: MUTATIONS_LAYER_ID,
                  event: {
                    time: n(),
                    logType: 'error',
                    title: '💥 ' + r,
                    subtitle: 'end',
                    data: {
                      store: formatDisplay(t.$id),
                      action: formatDisplay(r),
                      args: a,
                      error: o
                    },
                    groupId: s
                  }
                })
            })
        }, !0),
          t._customProperties.forEach((o) => {
            watch(
              () => unref(t[o]),
              (t, i) => {
                e.notifyComponentUpdate(),
                  e.sendInspectorState(INSPECTOR_ID),
                  isTimelineActive &&
                    e.addTimelineEvent({
                      layerId: MUTATIONS_LAYER_ID,
                      event: {
                        time: n(),
                        title: 'Change',
                        subtitle: o,
                        data: { newValue: t, oldValue: i },
                        groupId: activeAction
                      }
                    })
              },
              { deep: !0 }
            )
          }),
          t.$subscribe(
            ({ events: o, type: i }, r) => {
              if (
                (e.notifyComponentUpdate(),
                e.sendInspectorState(INSPECTOR_ID),
                !isTimelineActive)
              )
                return
              const a = {
                time: n(),
                title: formatMutationType(i),
                data: assign$1(
                  { store: formatDisplay(t.$id) },
                  formatEventData(o)
                ),
                groupId: activeAction
              }
              i === MutationType.patchFunction
                ? (a.subtitle = '⤵️')
                : i === MutationType.patchObject
                  ? (a.subtitle = '🧩')
                  : o && !Array.isArray(o) && (a.subtitle = o.type),
                o &&
                  (a.data['rawEvent(s)'] = {
                    _custom: {
                      display: 'DebuggerEvent',
                      type: 'object',
                      tooltip: 'raw DebuggerEvent[]',
                      value: o
                    }
                  }),
                e.addTimelineEvent({ layerId: MUTATIONS_LAYER_ID, event: a })
            },
            { detached: !0, flush: 'sync' }
          )
        const o = t._hotUpdate
        t._hotUpdate = markRaw((i) => {
          o(i),
            e.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: {
                time: n(),
                title: '🔥 ' + t.$id,
                subtitle: 'HMR update',
                data: {
                  store: formatDisplay(t.$id),
                  info: formatDisplay('HMR update')
                }
              }
            }),
            e.notifyComponentUpdate(),
            e.sendInspectorTree(INSPECTOR_ID),
            e.sendInspectorState(INSPECTOR_ID)
        })
        const { $dispose: i } = t
        ;(t.$dispose = () => {
          i(),
            e.notifyComponentUpdate(),
            e.sendInspectorTree(INSPECTOR_ID),
            e.sendInspectorState(INSPECTOR_ID),
            e.getSettings().logStoreChanges &&
              toastMessage(`Disposed "${t.$id}" store 🗑`)
        }),
          e.notifyComponentUpdate(),
          e.sendInspectorTree(INSPECTOR_ID),
          e.sendInspectorState(INSPECTOR_ID),
          e.getSettings().logStoreChanges &&
            toastMessage(`"${t.$id}" store installed 🆕`)
      }
    )
}
__name(registerPiniaDevtools, 'registerPiniaDevtools'),
  __name(addStoreToDevtools, 'addStoreToDevtools')
let runningActionId = 0,
  activeAction
function patchActionForGrouping(e, t, n) {
  const o = t.reduce((t, n) => ((t[n] = toRaw(e)[n]), t), {})
  for (const i in o)
    e[i] = function () {
      const t = runningActionId,
        r = n
          ? new Proxy(e, {
              get: (...e) => ((activeAction = t), Reflect.get(...e)),
              set: (...e) => ((activeAction = t), Reflect.set(...e))
            })
          : e
      activeAction = t
      const a = o[i].apply(r, arguments)
      return (activeAction = void 0), a
    }
}
function devtoolsPlugin({ app: e, store: t, options: n }) {
  if (!t.$id.startsWith('__hot:')) {
    if (((t._isOptionsAPI = !!n.state), !t._p._testing)) {
      patchActionForGrouping(t, Object.keys(n.actions), t._isOptionsAPI)
      const e = t._hotUpdate
      toRaw(t)._hotUpdate = function (n) {
        e.apply(this, arguments),
          patchActionForGrouping(
            t,
            Object.keys(n._hmrPayload.actions),
            !!t._isOptionsAPI
          )
      }
    }
    addStoreToDevtools(e, t)
  }
}
function createPinia() {
  const e = effectScope(!0),
    t = e.run(() => ref({}))
  let n = [],
    o = []
  const i = markRaw({
    install(e) {
      setActivePinia(i),
        isVue2 ||
          ((i._a = e),
          e.provide(piniaSymbol, i),
          (e.config.globalProperties.$pinia = i),
          o.forEach((e) => n.push(e)),
          (o = []))
    },
    use(e) {
      return this._a || isVue2 ? n.push(e) : o.push(e), this
    },
    _p: n,
    _a: null,
    _e: e,
    _s: new Map(),
    state: t
  })
  return i
}
function disposePinia(e) {
  e._e.stop(), e._s.clear(), e._p.splice(0), (e.state.value = {}), (e._a = null)
}
__name(patchActionForGrouping, 'patchActionForGrouping'),
  __name(devtoolsPlugin, 'devtoolsPlugin'),
  __name(createPinia, 'createPinia'),
  __name(disposePinia, 'disposePinia')
const isUseStore = __name(
  (e) => 'function' == typeof e && 'string' == typeof e.$id,
  'isUseStore'
)
function patchObject(e, t) {
  for (const n in t) {
    const o = t[n]
    if (!(n in e)) continue
    const i = e[n]
    isPlainObject$1(i) && isPlainObject$1(o) && !isRef(o) && !isReactive(o)
      ? (e[n] = patchObject(i, o))
      : isVue2
        ? set$1(e, n, o)
        : (e[n] = o)
  }
  return e
}
function acceptHMRUpdate(e, t) {
  return () => {}
}
__name(patchObject, 'patchObject'), __name(acceptHMRUpdate, 'acceptHMRUpdate')
const noop$2 = __name(() => {}, 'noop$2')
function addSubscription(e, t, n, o = noop$2) {
  e.push(t)
  const i = __name(() => {
    const n = e.indexOf(t)
    n > -1 && (e.splice(n, 1), o())
  }, 'removeSubscription')
  return !n && getCurrentScope() && onScopeDispose(i), i
}
function triggerSubscriptions(e, ...t) {
  e.slice().forEach((e) => {
    e(...t)
  })
}
__name(addSubscription, 'addSubscription'),
  __name(triggerSubscriptions, 'triggerSubscriptions')
const fallbackRunWithContext = __name((e) => e(), 'fallbackRunWithContext'),
  ACTION_MARKER = Symbol(),
  ACTION_NAME = Symbol()
function mergeReactiveObjects(e, t) {
  e instanceof Map && t instanceof Map
    ? t.forEach((t, n) => e.set(n, t))
    : e instanceof Set && t instanceof Set && t.forEach(e.add, e)
  for (const n in t) {
    if (!t.hasOwnProperty(n)) continue
    const o = t[n],
      i = e[n]
    isPlainObject$1(i) &&
    isPlainObject$1(o) &&
    e.hasOwnProperty(n) &&
    !isRef(o) &&
    !isReactive(o)
      ? (e[n] = mergeReactiveObjects(i, o))
      : (e[n] = o)
  }
  return e
}
__name(mergeReactiveObjects, 'mergeReactiveObjects')
const skipHydrateSymbol = Symbol()
function skipHydrate(e) {
  return Object.defineProperty(e, skipHydrateSymbol, {})
}
function shouldHydrate(e) {
  return !isPlainObject$1(e) || !e.hasOwnProperty(skipHydrateSymbol)
}
__name(skipHydrate, 'skipHydrate'), __name(shouldHydrate, 'shouldHydrate')
const { assign: assign } = Object
function isComputed(e) {
  return !(!isRef(e) || !e.effect)
}
function createOptionsStore(e, t, n, o) {
  const { state: i, actions: r, getters: a } = t,
    s = n.state.value[e]
  let l
  function c() {
    s ||
      (isVue2
        ? set$1(n.state.value, e, i ? i() : {})
        : (n.state.value[e] = i ? i() : {}))
    const t = toRefs$1(n.state.value[e])
    return assign(
      t,
      r,
      Object.keys(a || {}).reduce(
        (t, o) => (
          (t[o] = markRaw(
            computed(() => {
              setActivePinia(n)
              const t = n._s.get(e)
              if (!isVue2 || t._r) return a[o].call(t, t)
            })
          )),
          t
        ),
        {}
      )
    )
  }
  return __name(c, 'setup'), (l = createSetupStore(e, c, t, n, o, !0)), l
}
function createSetupStore(e, t, n = {}, o, i, r) {
  let a
  const s = assign({ actions: {} }, n)
  const l = { deep: !0 }
  let c, d
  let u,
    p = [],
    h = []
  const m = o.state.value[e]
  r || m || (isVue2 ? set$1(o.state.value, e, {}) : (o.state.value[e] = {}))
  ref({})
  let f
  function _(t) {
    let n
    ;(c = d = !1),
      'function' == typeof t
        ? (t(o.state.value[e]),
          (n = { type: MutationType.patchFunction, storeId: e, events: u }))
        : (mergeReactiveObjects(o.state.value[e], t),
          (n = {
            type: MutationType.patchObject,
            payload: t,
            storeId: e,
            events: u
          }))
    const i = (f = Symbol())
    nextTick().then(() => {
      f === i && (c = !0)
    }),
      (d = !0),
      triggerSubscriptions(p, n, o.state.value[e])
  }
  __name(_, '$patch')
  const g = r
    ? __name(function () {
        const { state: e } = n,
          t = e ? e() : {}
        this.$patch((e) => {
          assign(e, t)
        })
      }, '$reset2')
    : noop$2
  function v() {
    a.stop(), (p = []), (h = []), o._s.delete(e)
  }
  __name(v, '$dispose')
  const y = __name((t, n = '') => {
      if (ACTION_MARKER in t) return (t[ACTION_NAME] = n), t
      const i = __name(function () {
        setActivePinia(o)
        const n = Array.from(arguments),
          r = [],
          a = []
        function s(e) {
          r.push(e)
        }
        function l(e) {
          a.push(e)
        }
        let c
        __name(s, 'after'),
          __name(l, 'onError'),
          triggerSubscriptions(h, {
            args: n,
            name: i[ACTION_NAME],
            store: S,
            after: s,
            onError: l
          })
        try {
          c = t.apply(this && this.$id === e ? this : S, n)
        } catch (d) {
          throw (triggerSubscriptions(a, d), d)
        }
        return c instanceof Promise
          ? c
              .then((e) => (triggerSubscriptions(r, e), e))
              .catch((e) => (triggerSubscriptions(a, e), Promise.reject(e)))
          : (triggerSubscriptions(r, c), c)
      }, 'wrappedAction')
      return (i[ACTION_MARKER] = !0), (i[ACTION_NAME] = n), i
    }, 'action'),
    b = {
      _p: o,
      $id: e,
      $onAction: addSubscription.bind(null, h),
      $patch: _,
      $reset: g,
      $subscribe(t, n = {}) {
        const i = addSubscription(p, t, n.detached, () => r()),
          r = a.run(() =>
            watch(
              () => o.state.value[e],
              (o) => {
                ;('sync' === n.flush ? d : c) &&
                  t({ storeId: e, type: MutationType.direct, events: u }, o)
              },
              assign({}, l, n)
            )
          )
        return i
      },
      $dispose: v
    }
  isVue2 && (b._r = !1)
  const S = reactive(b)
  o._s.set(e, S)
  const C = ((o._a && o._a.runWithContext) || fallbackRunWithContext)(() =>
    o._e.run(() => (a = effectScope()).run(() => t({ action: y })))
  )
  for (const w in C) {
    const t = C[w]
    if ((isRef(t) && !isComputed(t)) || isReactive(t))
      r ||
        (m &&
          shouldHydrate(t) &&
          (isRef(t) ? (t.value = m[w]) : mergeReactiveObjects(t, m[w])),
        isVue2 ? set$1(o.state.value[e], w, t) : (o.state.value[e][w] = t))
    else if ('function' == typeof t) {
      const e = y(t, w)
      isVue2 ? set$1(C, w, e) : (C[w] = e), (s.actions[w] = t)
    } else 0
  }
  return (
    isVue2
      ? Object.keys(C).forEach((e) => {
          set$1(S, e, C[e])
        })
      : (assign(S, C), assign(toRaw(S), C)),
    Object.defineProperty(S, '$state', {
      get: __name(() => o.state.value[e], 'get'),
      set: __name((e) => {
        _((t) => {
          assign(t, e)
        })
      }, 'set')
    }),
    isVue2 && (S._r = !0),
    o._p.forEach((e) => {
      assign(
        S,
        a.run(() => e({ store: S, app: o._a, pinia: o, options: s }))
      )
    }),
    m && r && n.hydrate && n.hydrate(S.$state, m),
    (c = !0),
    (d = !0),
    S
  )
}
/*! #__NO_SIDE_EFFECTS__ */
function defineStore(e, t, n) {
  let o, i
  const r = 'function' == typeof t
  function a(e, n) {
    const a = hasInjectionContext()
    ;(e = e || (a ? inject(piniaSymbol, null) : null)) && setActivePinia(e),
      (e = activePinia)._s.has(o) ||
        (r ? createSetupStore(o, t, i, e) : createOptionsStore(o, i, e))
    const s = e._s.get(o)
    return s
  }
  return (
    'string' == typeof e ? ((o = e), (i = r ? n : t)) : ((i = e), (o = e.id)),
    __name(a, 'useStore'),
    (a.$id = o),
    a
  )
}
__name(isComputed, 'isComputed'),
  __name(createOptionsStore, 'createOptionsStore'),
  __name(createSetupStore, 'createSetupStore'),
  __name(defineStore, 'defineStore')
let mapStoreSuffix = 'Store'
function setMapStoreSuffix(e) {
  mapStoreSuffix = e
}
function mapStores(...e) {
  return e.reduce(
    (e, t) => (
      (e[t.$id + mapStoreSuffix] = function () {
        return t(this.$pinia)
      }),
      e
    ),
    {}
  )
}
function mapState(e, t) {
  return Array.isArray(t)
    ? t.reduce(
        (t, n) => (
          (t[n] = function () {
            return e(this.$pinia)[n]
          }),
          t
        ),
        {}
      )
    : Object.keys(t).reduce(
        (n, o) => (
          (n[o] = function () {
            const n = e(this.$pinia),
              i = t[o]
            return 'function' == typeof i ? i.call(this, n) : n[i]
          }),
          n
        ),
        {}
      )
}
__name(setMapStoreSuffix, 'setMapStoreSuffix'),
  __name(mapStores, 'mapStores'),
  __name(mapState, 'mapState')
const mapGetters = mapState
function mapActions(e, t) {
  return Array.isArray(t)
    ? t.reduce(
        (t, n) => (
          (t[n] = function (...t) {
            return e(this.$pinia)[n](...t)
          }),
          t
        ),
        {}
      )
    : Object.keys(t).reduce(
        (n, o) => (
          (n[o] = function (...n) {
            return e(this.$pinia)[t[o]](...n)
          }),
          n
        ),
        {}
      )
}
function mapWritableState(e, t) {
  return Array.isArray(t)
    ? t.reduce(
        (t, n) => (
          (t[n] = {
            get() {
              return e(this.$pinia)[n]
            },
            set(t) {
              return (e(this.$pinia)[n] = t)
            }
          }),
          t
        ),
        {}
      )
    : Object.keys(t).reduce(
        (n, o) => (
          (n[o] = {
            get() {
              return e(this.$pinia)[t[o]]
            },
            set(n) {
              return (e(this.$pinia)[t[o]] = n)
            }
          }),
          n
        ),
        {}
      )
}
function storeToRefs(e) {
  if (isVue2) return toRefs$1(e)
  {
    const t = toRaw(e),
      n = {}
    for (const o in t) {
      const i = t[o]
      i.effect
        ? (n[o] = computed({
            get: __name(() => e[o], 'get'),
            set(t) {
              e[o] = t
            }
          }))
        : (isRef(i) || isReactive(i)) && (n[o] = toRef$1(e, o))
    }
    return n
  }
}
__name(mapActions, 'mapActions'),
  __name(mapWritableState, 'mapWritableState'),
  __name(storeToRefs, 'storeToRefs')
const PiniaVuePlugin = __name(function (e) {
    e.mixin({
      beforeCreate() {
        const e = this.$options
        if (e.pinia) {
          const t = e.pinia
          if (!this._provided) {
            const e = {}
            Object.defineProperty(this, '_provided', {
              get: __name(() => e, 'get'),
              set: __name((t) => Object.assign(e, t), 'set')
            })
          }
          ;(this._provided[piniaSymbol] = t),
            this.$pinia || (this.$pinia = t),
            (t._a = this),
            IS_CLIENT && setActivePinia(t)
        } else
          !this.$pinia &&
            e.parent &&
            e.parent.$pinia &&
            (this.$pinia = e.parent.$pinia)
      },
      destroyed() {
        delete this._pStores
      }
    })
  }, 'PiniaVuePlugin'),
  useToastStore = defineStore('toast', () => {
    const e = Vue.ref([]),
      t = Vue.ref([]),
      n = Vue.ref(!1)
    function o(t) {
      e.value = [...e.value, t]
    }
    function i(e) {
      t.value = [...t.value, e]
    }
    function r() {
      n.value = !0
    }
    function a(e) {
      o({ severity: 'warn', summary: 'Alert', detail: e })
    }
    return (
      __name(o, 'add'),
      __name(i, 'remove'),
      __name(r, 'removeAll'),
      __name(a, 'addAlert'),
      {
        messagesToAdd: e,
        messagesToRemove: t,
        removeAllRequested: n,
        add: o,
        remove: i,
        removeAll: r,
        addAlert: a
      }
    )
  })
var util, objectUtil
!(function (e) {
  function t(e) {}
  function n(e) {
    throw new Error()
  }
  function o(e, t = ' | ') {
    return e.map((e) => ('string' == typeof e ? `'${e}'` : e)).join(t)
  }
  ;(e.assertEqual = (e) => e),
    __name(t, 'assertIs'),
    (e.assertIs = t),
    __name(n, 'assertNever'),
    (e.assertNever = n),
    (e.arrayToEnum = (e) => {
      const t = {}
      for (const n of e) t[n] = n
      return t
    }),
    (e.getValidEnumValues = (t) => {
      const n = e.objectKeys(t).filter((e) => 'number' != typeof t[t[e]]),
        o = {}
      for (const e of n) o[e] = t[e]
      return e.objectValues(o)
    }),
    (e.objectValues = (t) =>
      e.objectKeys(t).map(function (e) {
        return t[e]
      })),
    (e.objectKeys =
      'function' == typeof Object.keys
        ? (e) => Object.keys(e)
        : (e) => {
            const t = []
            for (const n in e)
              Object.prototype.hasOwnProperty.call(e, n) && t.push(n)
            return t
          }),
    (e.find = (e, t) => {
      for (const n of e) if (t(n)) return n
    }),
    (e.isInteger =
      'function' == typeof Number.isInteger
        ? (e) => Number.isInteger(e)
        : (e) => 'number' == typeof e && isFinite(e) && Math.floor(e) === e),
    __name(o, 'joinValues'),
    (e.joinValues = o),
    (e.jsonStringifyReplacer = (e, t) =>
      'bigint' == typeof t ? t.toString() : t)
})(util || (util = {})),
  ((objectUtil || (objectUtil = {})).mergeShapes = (e, t) => ({ ...e, ...t }))
const ZodParsedType = util.arrayToEnum([
    'string',
    'nan',
    'number',
    'integer',
    'float',
    'boolean',
    'date',
    'bigint',
    'symbol',
    'function',
    'undefined',
    'null',
    'array',
    'object',
    'unknown',
    'promise',
    'void',
    'never',
    'map',
    'set'
  ]),
  getParsedType = __name((e) => {
    switch (typeof e) {
      case 'undefined':
        return ZodParsedType.undefined
      case 'string':
        return ZodParsedType.string
      case 'number':
        return isNaN(e) ? ZodParsedType.nan : ZodParsedType.number
      case 'boolean':
        return ZodParsedType.boolean
      case 'function':
        return ZodParsedType.function
      case 'bigint':
        return ZodParsedType.bigint
      case 'symbol':
        return ZodParsedType.symbol
      case 'object':
        return Array.isArray(e)
          ? ZodParsedType.array
          : null === e
            ? ZodParsedType.null
            : e.then &&
                'function' == typeof e.then &&
                e.catch &&
                'function' == typeof e.catch
              ? ZodParsedType.promise
              : 'undefined' != typeof Map && e instanceof Map
                ? ZodParsedType.map
                : 'undefined' != typeof Set && e instanceof Set
                  ? ZodParsedType.set
                  : 'undefined' != typeof Date && e instanceof Date
                    ? ZodParsedType.date
                    : ZodParsedType.object
      default:
        return ZodParsedType.unknown
    }
  }, 'getParsedType'),
  ZodIssueCode = util.arrayToEnum([
    'invalid_type',
    'invalid_literal',
    'custom',
    'invalid_union',
    'invalid_union_discriminator',
    'invalid_enum_value',
    'unrecognized_keys',
    'invalid_arguments',
    'invalid_return_type',
    'invalid_date',
    'invalid_string',
    'too_small',
    'too_big',
    'invalid_intersection_types',
    'not_multiple_of',
    'not_finite'
  ]),
  quotelessJson = __name(
    (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, '$1:'),
    'quotelessJson'
  )
class ZodError extends Error {
  static {
    __name(this, 'ZodError')
  }
  constructor(e) {
    super(),
      (this.issues = []),
      (this.addIssue = (e) => {
        this.issues = [...this.issues, e]
      }),
      (this.addIssues = (e = []) => {
        this.issues = [...this.issues, ...e]
      })
    const t = new.target.prototype
    Object.setPrototypeOf
      ? Object.setPrototypeOf(this, t)
      : (this.__proto__ = t),
      (this.name = 'ZodError'),
      (this.issues = e)
  }
  get errors() {
    return this.issues
  }
  format(e) {
    const t =
        e ||
        function (e) {
          return e.message
        },
      n = { _errors: [] },
      o = __name((e) => {
        for (const i of e.issues)
          if ('invalid_union' === i.code) i.unionErrors.map(o)
          else if ('invalid_return_type' === i.code) o(i.returnTypeError)
          else if ('invalid_arguments' === i.code) o(i.argumentsError)
          else if (0 === i.path.length) n._errors.push(t(i))
          else {
            let e = n,
              o = 0
            for (; o < i.path.length; ) {
              const n = i.path[o]
              o === i.path.length - 1
                ? ((e[n] = e[n] || { _errors: [] }), e[n]._errors.push(t(i)))
                : (e[n] = e[n] || { _errors: [] }),
                (e = e[n]),
                o++
            }
          }
      }, 'processError')
    return o(this), n
  }
  static assert(e) {
    if (!(e instanceof ZodError)) throw new Error(`Not a ZodError: ${e}`)
  }
  toString() {
    return this.message
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2)
  }
  get isEmpty() {
    return 0 === this.issues.length
  }
  flatten(e = (e) => e.message) {
    const t = {},
      n = []
    for (const o of this.issues)
      o.path.length > 0
        ? ((t[o.path[0]] = t[o.path[0]] || []), t[o.path[0]].push(e(o)))
        : n.push(e(o))
    return { formErrors: n, fieldErrors: t }
  }
  get formErrors() {
    return this.flatten()
  }
}
ZodError.create = (e) => new ZodError(e)
const errorMap$1 = __name((e, t) => {
  let n
  switch (e.code) {
    case ZodIssueCode.invalid_type:
      n =
        e.received === ZodParsedType.undefined
          ? 'Required'
          : `Expected ${e.expected}, received ${e.received}`
      break
    case ZodIssueCode.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, util.jsonStringifyReplacer)}`
      break
    case ZodIssueCode.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${util.joinValues(e.keys, ', ')}`
      break
    case ZodIssueCode.invalid_union:
      n = 'Invalid input'
      break
    case ZodIssueCode.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${util.joinValues(e.options)}`
      break
    case ZodIssueCode.invalid_enum_value:
      n = `Invalid enum value. Expected ${util.joinValues(e.options)}, received '${e.received}'`
      break
    case ZodIssueCode.invalid_arguments:
      n = 'Invalid function arguments'
      break
    case ZodIssueCode.invalid_return_type:
      n = 'Invalid function return type'
      break
    case ZodIssueCode.invalid_date:
      n = 'Invalid date'
      break
    case ZodIssueCode.invalid_string:
      'object' == typeof e.validation
        ? 'includes' in e.validation
          ? ((n = `Invalid input: must include "${e.validation.includes}"`),
            'number' == typeof e.validation.position &&
              (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`))
          : 'startsWith' in e.validation
            ? (n = `Invalid input: must start with "${e.validation.startsWith}"`)
            : 'endsWith' in e.validation
              ? (n = `Invalid input: must end with "${e.validation.endsWith}"`)
              : util.assertNever(e.validation)
        : (n = 'regex' !== e.validation ? `Invalid ${e.validation}` : 'Invalid')
      break
    case ZodIssueCode.too_small:
      n =
        'array' === e.type
          ? `Array must contain ${e.exact ? 'exactly' : e.inclusive ? 'at least' : 'more than'} ${e.minimum} element(s)`
          : 'string' === e.type
            ? `String must contain ${e.exact ? 'exactly' : e.inclusive ? 'at least' : 'over'} ${e.minimum} character(s)`
            : 'number' === e.type
              ? `Number must be ${e.exact ? 'exactly equal to ' : e.inclusive ? 'greater than or equal to ' : 'greater than '}${e.minimum}`
              : 'date' === e.type
                ? `Date must be ${e.exact ? 'exactly equal to ' : e.inclusive ? 'greater than or equal to ' : 'greater than '}${new Date(Number(e.minimum))}`
                : 'Invalid input'
      break
    case ZodIssueCode.too_big:
      n =
        'array' === e.type
          ? `Array must contain ${e.exact ? 'exactly' : e.inclusive ? 'at most' : 'less than'} ${e.maximum} element(s)`
          : 'string' === e.type
            ? `String must contain ${e.exact ? 'exactly' : e.inclusive ? 'at most' : 'under'} ${e.maximum} character(s)`
            : 'number' === e.type
              ? `Number must be ${e.exact ? 'exactly' : e.inclusive ? 'less than or equal to' : 'less than'} ${e.maximum}`
              : 'bigint' === e.type
                ? `BigInt must be ${e.exact ? 'exactly' : e.inclusive ? 'less than or equal to' : 'less than'} ${e.maximum}`
                : 'date' === e.type
                  ? `Date must be ${e.exact ? 'exactly' : e.inclusive ? 'smaller than or equal to' : 'smaller than'} ${new Date(Number(e.maximum))}`
                  : 'Invalid input'
      break
    case ZodIssueCode.custom:
      n = 'Invalid input'
      break
    case ZodIssueCode.invalid_intersection_types:
      n = 'Intersection results could not be merged'
      break
    case ZodIssueCode.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`
      break
    case ZodIssueCode.not_finite:
      n = 'Number must be finite'
      break
    default:
      ;(n = t.defaultError), util.assertNever(e)
  }
  return { message: n }
}, 'errorMap$1')
let overrideErrorMap = errorMap$1
function setErrorMap(e) {
  overrideErrorMap = e
}
function getErrorMap() {
  return overrideErrorMap
}
__name(setErrorMap, 'setErrorMap'), __name(getErrorMap, 'getErrorMap')
const makeIssue = __name((e) => {
    const { data: t, path: n, errorMaps: o, issueData: i } = e,
      r = [...n, ...(i.path || [])],
      a = { ...i, path: r }
    if (void 0 !== i.message) return { ...i, path: r, message: i.message }
    let s = ''
    const l = o
      .filter((e) => !!e)
      .slice()
      .reverse()
    for (const c of l) s = c(a, { data: t, defaultError: s }).message
    return { ...i, path: r, message: s }
  }, 'makeIssue'),
  EMPTY_PATH = []
function addIssueToContext(e, t) {
  const n = getErrorMap(),
    o = makeIssue({
      issueData: t,
      data: e.data,
      path: e.path,
      errorMaps: [
        e.common.contextualErrorMap,
        e.schemaErrorMap,
        n,
        n === errorMap$1 ? void 0 : errorMap$1
      ].filter((e) => !!e)
    })
  e.common.issues.push(o)
}
__name(addIssueToContext, 'addIssueToContext')
class ParseStatus {
  static {
    __name(this, 'ParseStatus')
  }
  constructor() {
    this.value = 'valid'
  }
  dirty() {
    'valid' === this.value && (this.value = 'dirty')
  }
  abort() {
    'aborted' !== this.value && (this.value = 'aborted')
  }
  static mergeArray(e, t) {
    const n = []
    for (const o of t) {
      if ('aborted' === o.status) return INVALID
      'dirty' === o.status && e.dirty(), n.push(o.value)
    }
    return { status: e.value, value: n }
  }
  static async mergeObjectAsync(e, t) {
    const n = []
    for (const o of t) {
      const e = await o.key,
        t = await o.value
      n.push({ key: e, value: t })
    }
    return ParseStatus.mergeObjectSync(e, n)
  }
  static mergeObjectSync(e, t) {
    const n = {}
    for (const o of t) {
      const { key: t, value: i } = o
      if ('aborted' === t.status) return INVALID
      if ('aborted' === i.status) return INVALID
      'dirty' === t.status && e.dirty(),
        'dirty' === i.status && e.dirty(),
        '__proto__' === t.value ||
          (void 0 === i.value && !o.alwaysSet) ||
          (n[t.value] = i.value)
    }
    return { status: e.value, value: n }
  }
}
const INVALID = Object.freeze({ status: 'aborted' }),
  DIRTY = __name((e) => ({ status: 'dirty', value: e }), 'DIRTY'),
  OK = __name((e) => ({ status: 'valid', value: e }), 'OK'),
  isAborted = __name((e) => 'aborted' === e.status, 'isAborted'),
  isDirty = __name((e) => 'dirty' === e.status, 'isDirty'),
  isValid = __name((e) => 'valid' === e.status, 'isValid'),
  isAsync = __name(
    (e) => 'undefined' != typeof Promise && e instanceof Promise,
    'isAsync'
  )
function __classPrivateFieldGet(e, t, n, o) {
  if ('a' === n && !o)
    throw new TypeError('Private accessor was defined without a getter')
  if ('function' == typeof t ? e !== t || !o : !t.has(e))
    throw new TypeError(
      'Cannot read private member from an object whose class did not declare it'
    )
  return 'm' === n ? o : 'a' === n ? o.call(e) : o ? o.value : t.get(e)
}
function __classPrivateFieldSet(e, t, n, o, i) {
  if ('m' === o) throw new TypeError('Private method is not writable')
  if ('a' === o && !i)
    throw new TypeError('Private accessor was defined without a setter')
  if ('function' == typeof t ? e !== t || !i : !t.has(e))
    throw new TypeError(
      'Cannot write private member to an object whose class did not declare it'
    )
  return 'a' === o ? i.call(e, n) : i ? (i.value = n) : t.set(e, n), n
}
var errorUtil, errorUtil2, _ZodEnum_cache, _ZodNativeEnum_cache
__name(__classPrivateFieldGet, '__classPrivateFieldGet'),
  __name(__classPrivateFieldSet, '__classPrivateFieldSet'),
  'function' == typeof SuppressedError && SuppressedError,
  (errorUtil2 = errorUtil || (errorUtil = {})),
  (errorUtil2.errToObj = (e) =>
    'string' == typeof e ? { message: e } : e || {}),
  (errorUtil2.toString = (e) =>
    'string' == typeof e ? e : null == e ? void 0 : e.message)
class ParseInputLazyPath {
  static {
    __name(this, 'ParseInputLazyPath')
  }
  constructor(e, t, n, o) {
    ;(this._cachedPath = []),
      (this.parent = e),
      (this.data = t),
      (this._path = n),
      (this._key = o)
  }
  get path() {
    return (
      this._cachedPath.length ||
        (this._key instanceof Array
          ? this._cachedPath.push(...this._path, ...this._key)
          : this._cachedPath.push(...this._path, this._key)),
      this._cachedPath
    )
  }
}
const handleResult = __name((e, t) => {
  if (isValid(t)) return { success: !0, data: t.value }
  if (!e.common.issues.length)
    throw new Error('Validation failed but no issues detected.')
  return {
    success: !1,
    get error() {
      if (this._error) return this._error
      const t = new ZodError(e.common.issues)
      return (this._error = t), this._error
    }
  }
}, 'handleResult')
function processCreateParams(e) {
  if (!e) return {}
  const {
    errorMap: t,
    invalid_type_error: n,
    required_error: o,
    description: i
  } = e
  if (t && (n || o))
    throw new Error(
      'Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.'
    )
  if (t) return { errorMap: t, description: i }
  return {
    errorMap: __name((t, i) => {
      var r, a
      const { message: s } = e
      return 'invalid_enum_value' === t.code
        ? { message: null != s ? s : i.defaultError }
        : void 0 === i.data
          ? {
              message:
                null !== (r = null != s ? s : o) && void 0 !== r
                  ? r
                  : i.defaultError
            }
          : 'invalid_type' !== t.code
            ? { message: i.defaultError }
            : {
                message:
                  null !== (a = null != s ? s : n) && void 0 !== a
                    ? a
                    : i.defaultError
              }
    }, 'customMap'),
    description: i
  }
}
__name(processCreateParams, 'processCreateParams')
class ZodType {
  static {
    __name(this, 'ZodType')
  }
  constructor(e) {
    ;(this.spa = this.safeParseAsync),
      (this._def = e),
      (this.parse = this.parse.bind(this)),
      (this.safeParse = this.safeParse.bind(this)),
      (this.parseAsync = this.parseAsync.bind(this)),
      (this.safeParseAsync = this.safeParseAsync.bind(this)),
      (this.spa = this.spa.bind(this)),
      (this.refine = this.refine.bind(this)),
      (this.refinement = this.refinement.bind(this)),
      (this.superRefine = this.superRefine.bind(this)),
      (this.optional = this.optional.bind(this)),
      (this.nullable = this.nullable.bind(this)),
      (this.nullish = this.nullish.bind(this)),
      (this.array = this.array.bind(this)),
      (this.promise = this.promise.bind(this)),
      (this.or = this.or.bind(this)),
      (this.and = this.and.bind(this)),
      (this.transform = this.transform.bind(this)),
      (this.brand = this.brand.bind(this)),
      (this.default = this.default.bind(this)),
      (this.catch = this.catch.bind(this)),
      (this.describe = this.describe.bind(this)),
      (this.pipe = this.pipe.bind(this)),
      (this.readonly = this.readonly.bind(this)),
      (this.isNullable = this.isNullable.bind(this)),
      (this.isOptional = this.isOptional.bind(this))
  }
  get description() {
    return this._def.description
  }
  _getType(e) {
    return getParsedType(e.data)
  }
  _getOrReturnCtx(e, t) {
    return (
      t || {
        common: e.parent.common,
        data: e.data,
        parsedType: getParsedType(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    )
  }
  _processInputParams(e) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: getParsedType(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    }
  }
  _parseSync(e) {
    const t = this._parse(e)
    if (isAsync(t)) throw new Error('Synchronous parse encountered promise.')
    return t
  }
  _parseAsync(e) {
    const t = this._parse(e)
    return Promise.resolve(t)
  }
  parse(e, t) {
    const n = this.safeParse(e, t)
    if (n.success) return n.data
    throw n.error
  }
  safeParse(e, t) {
    var n
    const o = {
        common: {
          issues: [],
          async:
            null !== (n = null == t ? void 0 : t.async) && void 0 !== n && n,
          contextualErrorMap: null == t ? void 0 : t.errorMap
        },
        path: (null == t ? void 0 : t.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: getParsedType(e)
      },
      i = this._parseSync({ data: e, path: o.path, parent: o })
    return handleResult(o, i)
  }
  async parseAsync(e, t) {
    const n = await this.safeParseAsync(e, t)
    if (n.success) return n.data
    throw n.error
  }
  async safeParseAsync(e, t) {
    const n = {
        common: {
          issues: [],
          contextualErrorMap: null == t ? void 0 : t.errorMap,
          async: !0
        },
        path: (null == t ? void 0 : t.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: getParsedType(e)
      },
      o = this._parse({ data: e, path: n.path, parent: n }),
      i = await (isAsync(o) ? o : Promise.resolve(o))
    return handleResult(n, i)
  }
  refine(e, t) {
    const n = __name(
      (e) =>
        'string' == typeof t || void 0 === t
          ? { message: t }
          : 'function' == typeof t
            ? t(e)
            : t,
      'getIssueProperties'
    )
    return this._refinement((t, o) => {
      const i = e(t),
        r = __name(
          () => o.addIssue({ code: ZodIssueCode.custom, ...n(t) }),
          'setError'
        )
      return 'undefined' != typeof Promise && i instanceof Promise
        ? i.then((e) => !!e || (r(), !1))
        : !!i || (r(), !1)
    })
  }
  refinement(e, t) {
    return this._refinement(
      (n, o) => !!e(n) || (o.addIssue('function' == typeof t ? t(n, o) : t), !1)
    )
  }
  _refinement(e) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: 'refinement', refinement: e }
    })
  }
  superRefine(e) {
    return this._refinement(e)
  }
  optional() {
    return ZodOptional.create(this, this._def)
  }
  nullable() {
    return ZodNullable.create(this, this._def)
  }
  nullish() {
    return this.nullable().optional()
  }
  array() {
    return ZodArray.create(this, this._def)
  }
  promise() {
    return ZodPromise.create(this, this._def)
  }
  or(e) {
    return ZodUnion.create([this, e], this._def)
  }
  and(e) {
    return ZodIntersection.create(this, e, this._def)
  }
  transform(e) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: 'transform', transform: e }
    })
  }
  default(e) {
    const t = 'function' == typeof e ? e : () => e
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: t,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    })
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    })
  }
  catch(e) {
    const t = 'function' == typeof e ? e : () => e
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: t,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    })
  }
  describe(e) {
    return new (0, this.constructor)({ ...this._def, description: e })
  }
  pipe(e) {
    return ZodPipeline.create(this, e)
  }
  readonly() {
    return ZodReadonly.create(this)
  }
  isOptional() {
    return this.safeParse(void 0).success
  }
  isNullable() {
    return this.safeParse(null).success
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i,
  cuid2Regex = /^[0-9a-z]+$/,
  ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/,
  uuidRegex =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  nanoidRegex = /^[a-z0-9_-]{21}$/i,
  durationRegex =
    /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  emailRegex =
    /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  _emojiRegex = '^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$'
let emojiRegex
const ipv4Regex =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv6Regex =
    /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  base64Regex =
    /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  dateRegexSource =
    '((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))',
  dateRegex = new RegExp(`^${dateRegexSource}$`)
function timeRegexSource(e) {
  let t = '([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d'
  return (
    e.precision
      ? (t = `${t}\\.\\d{${e.precision}}`)
      : null == e.precision && (t = `${t}(\\.\\d+)?`),
    t
  )
}
function timeRegex(e) {
  return new RegExp(`^${timeRegexSource(e)}$`)
}
function datetimeRegex(e) {
  let t = `${dateRegexSource}T${timeRegexSource(e)}`
  const n = []
  return (
    n.push(e.local ? 'Z?' : 'Z'),
    e.offset && n.push('([+-]\\d{2}:?\\d{2})'),
    (t = `${t}(${n.join('|')})`),
    new RegExp(`^${t}$`)
  )
}
function isValidIP(e, t) {
  return (
    !(('v4' !== t && t) || !ipv4Regex.test(e)) ||
    !(('v6' !== t && t) || !ipv6Regex.test(e))
  )
}
__name(timeRegexSource, 'timeRegexSource'),
  __name(timeRegex, 'timeRegex'),
  __name(datetimeRegex, 'datetimeRegex'),
  __name(isValidIP, 'isValidIP')
class ZodString extends ZodType {
  static {
    __name(this, 'ZodString')
  }
  _parse(e) {
    this._def.coerce && (e.data = String(e.data))
    if (this._getType(e) !== ZodParsedType.string) {
      const t = this._getOrReturnCtx(e)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: t.parsedType
        }),
        INVALID
      )
    }
    const t = new ParseStatus()
    let n
    for (const i of this._def.checks)
      if ('min' === i.kind)
        e.data.length < i.value &&
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            code: ZodIssueCode.too_small,
            minimum: i.value,
            type: 'string',
            inclusive: !0,
            exact: !1,
            message: i.message
          }),
          t.dirty())
      else if ('max' === i.kind)
        e.data.length > i.value &&
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            code: ZodIssueCode.too_big,
            maximum: i.value,
            type: 'string',
            inclusive: !0,
            exact: !1,
            message: i.message
          }),
          t.dirty())
      else if ('length' === i.kind) {
        const o = e.data.length > i.value,
          r = e.data.length < i.value
        ;(o || r) &&
          ((n = this._getOrReturnCtx(e, n)),
          o
            ? addIssueToContext(n, {
                code: ZodIssueCode.too_big,
                maximum: i.value,
                type: 'string',
                inclusive: !0,
                exact: !0,
                message: i.message
              })
            : r &&
              addIssueToContext(n, {
                code: ZodIssueCode.too_small,
                minimum: i.value,
                type: 'string',
                inclusive: !0,
                exact: !0,
                message: i.message
              }),
          t.dirty())
      } else if ('email' === i.kind)
        emailRegex.test(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            validation: 'email',
            code: ZodIssueCode.invalid_string,
            message: i.message
          }),
          t.dirty())
      else if ('emoji' === i.kind)
        emojiRegex || (emojiRegex = new RegExp(_emojiRegex, 'u')),
          emojiRegex.test(e.data) ||
            ((n = this._getOrReturnCtx(e, n)),
            addIssueToContext(n, {
              validation: 'emoji',
              code: ZodIssueCode.invalid_string,
              message: i.message
            }),
            t.dirty())
      else if ('uuid' === i.kind)
        uuidRegex.test(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            validation: 'uuid',
            code: ZodIssueCode.invalid_string,
            message: i.message
          }),
          t.dirty())
      else if ('nanoid' === i.kind)
        nanoidRegex.test(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            validation: 'nanoid',
            code: ZodIssueCode.invalid_string,
            message: i.message
          }),
          t.dirty())
      else if ('cuid' === i.kind)
        cuidRegex.test(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            validation: 'cuid',
            code: ZodIssueCode.invalid_string,
            message: i.message
          }),
          t.dirty())
      else if ('cuid2' === i.kind)
        cuid2Regex.test(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            validation: 'cuid2',
            code: ZodIssueCode.invalid_string,
            message: i.message
          }),
          t.dirty())
      else if ('ulid' === i.kind)
        ulidRegex.test(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            validation: 'ulid',
            code: ZodIssueCode.invalid_string,
            message: i.message
          }),
          t.dirty())
      else if ('url' === i.kind)
        try {
          new URL(e.data)
        } catch (o) {
          ;(n = this._getOrReturnCtx(e, n)),
            addIssueToContext(n, {
              validation: 'url',
              code: ZodIssueCode.invalid_string,
              message: i.message
            }),
            t.dirty()
        }
      else if ('regex' === i.kind) {
        i.regex.lastIndex = 0
        i.regex.test(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            validation: 'regex',
            code: ZodIssueCode.invalid_string,
            message: i.message
          }),
          t.dirty())
      } else if ('trim' === i.kind) e.data = e.data.trim()
      else if ('includes' === i.kind)
        e.data.includes(i.value, i.position) ||
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: i.value, position: i.position },
            message: i.message
          }),
          t.dirty())
      else if ('toLowerCase' === i.kind) e.data = e.data.toLowerCase()
      else if ('toUpperCase' === i.kind) e.data = e.data.toUpperCase()
      else if ('startsWith' === i.kind)
        e.data.startsWith(i.value) ||
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: i.value },
            message: i.message
          }),
          t.dirty())
      else if ('endsWith' === i.kind)
        e.data.endsWith(i.value) ||
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: i.value },
            message: i.message
          }),
          t.dirty())
      else if ('datetime' === i.kind) {
        datetimeRegex(i).test(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            code: ZodIssueCode.invalid_string,
            validation: 'datetime',
            message: i.message
          }),
          t.dirty())
      } else if ('date' === i.kind) {
        dateRegex.test(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            code: ZodIssueCode.invalid_string,
            validation: 'date',
            message: i.message
          }),
          t.dirty())
      } else if ('time' === i.kind) {
        timeRegex(i).test(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            code: ZodIssueCode.invalid_string,
            validation: 'time',
            message: i.message
          }),
          t.dirty())
      } else
        'duration' === i.kind
          ? durationRegex.test(e.data) ||
            ((n = this._getOrReturnCtx(e, n)),
            addIssueToContext(n, {
              validation: 'duration',
              code: ZodIssueCode.invalid_string,
              message: i.message
            }),
            t.dirty())
          : 'ip' === i.kind
            ? isValidIP(e.data, i.version) ||
              ((n = this._getOrReturnCtx(e, n)),
              addIssueToContext(n, {
                validation: 'ip',
                code: ZodIssueCode.invalid_string,
                message: i.message
              }),
              t.dirty())
            : 'base64' === i.kind
              ? base64Regex.test(e.data) ||
                ((n = this._getOrReturnCtx(e, n)),
                addIssueToContext(n, {
                  validation: 'base64',
                  code: ZodIssueCode.invalid_string,
                  message: i.message
                }),
                t.dirty())
              : util.assertNever(i)
    return { status: t.value, value: e.data }
  }
  _regex(e, t, n) {
    return this.refinement((t) => e.test(t), {
      validation: t,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(n)
    })
  }
  _addCheck(e) {
    return new ZodString({ ...this._def, checks: [...this._def.checks, e] })
  }
  email(e) {
    return this._addCheck({ kind: 'email', ...errorUtil.errToObj(e) })
  }
  url(e) {
    return this._addCheck({ kind: 'url', ...errorUtil.errToObj(e) })
  }
  emoji(e) {
    return this._addCheck({ kind: 'emoji', ...errorUtil.errToObj(e) })
  }
  uuid(e) {
    return this._addCheck({ kind: 'uuid', ...errorUtil.errToObj(e) })
  }
  nanoid(e) {
    return this._addCheck({ kind: 'nanoid', ...errorUtil.errToObj(e) })
  }
  cuid(e) {
    return this._addCheck({ kind: 'cuid', ...errorUtil.errToObj(e) })
  }
  cuid2(e) {
    return this._addCheck({ kind: 'cuid2', ...errorUtil.errToObj(e) })
  }
  ulid(e) {
    return this._addCheck({ kind: 'ulid', ...errorUtil.errToObj(e) })
  }
  base64(e) {
    return this._addCheck({ kind: 'base64', ...errorUtil.errToObj(e) })
  }
  ip(e) {
    return this._addCheck({ kind: 'ip', ...errorUtil.errToObj(e) })
  }
  datetime(e) {
    var t, n
    return 'string' == typeof e
      ? this._addCheck({
          kind: 'datetime',
          precision: null,
          offset: !1,
          local: !1,
          message: e
        })
      : this._addCheck({
          kind: 'datetime',
          precision:
            void 0 === (null == e ? void 0 : e.precision)
              ? null
              : null == e
                ? void 0
                : e.precision,
          offset:
            null !== (t = null == e ? void 0 : e.offset) && void 0 !== t && t,
          local:
            null !== (n = null == e ? void 0 : e.local) && void 0 !== n && n,
          ...errorUtil.errToObj(null == e ? void 0 : e.message)
        })
  }
  date(e) {
    return this._addCheck({ kind: 'date', message: e })
  }
  time(e) {
    return 'string' == typeof e
      ? this._addCheck({ kind: 'time', precision: null, message: e })
      : this._addCheck({
          kind: 'time',
          precision:
            void 0 === (null == e ? void 0 : e.precision)
              ? null
              : null == e
                ? void 0
                : e.precision,
          ...errorUtil.errToObj(null == e ? void 0 : e.message)
        })
  }
  duration(e) {
    return this._addCheck({ kind: 'duration', ...errorUtil.errToObj(e) })
  }
  regex(e, t) {
    return this._addCheck({ kind: 'regex', regex: e, ...errorUtil.errToObj(t) })
  }
  includes(e, t) {
    return this._addCheck({
      kind: 'includes',
      value: e,
      position: null == t ? void 0 : t.position,
      ...errorUtil.errToObj(null == t ? void 0 : t.message)
    })
  }
  startsWith(e, t) {
    return this._addCheck({
      kind: 'startsWith',
      value: e,
      ...errorUtil.errToObj(t)
    })
  }
  endsWith(e, t) {
    return this._addCheck({
      kind: 'endsWith',
      value: e,
      ...errorUtil.errToObj(t)
    })
  }
  min(e, t) {
    return this._addCheck({ kind: 'min', value: e, ...errorUtil.errToObj(t) })
  }
  max(e, t) {
    return this._addCheck({ kind: 'max', value: e, ...errorUtil.errToObj(t) })
  }
  length(e, t) {
    return this._addCheck({
      kind: 'length',
      value: e,
      ...errorUtil.errToObj(t)
    })
  }
  nonempty(e) {
    return this.min(1, errorUtil.errToObj(e))
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: 'trim' }]
    })
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: 'toLowerCase' }]
    })
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: 'toUpperCase' }]
    })
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => 'datetime' === e.kind)
  }
  get isDate() {
    return !!this._def.checks.find((e) => 'date' === e.kind)
  }
  get isTime() {
    return !!this._def.checks.find((e) => 'time' === e.kind)
  }
  get isDuration() {
    return !!this._def.checks.find((e) => 'duration' === e.kind)
  }
  get isEmail() {
    return !!this._def.checks.find((e) => 'email' === e.kind)
  }
  get isURL() {
    return !!this._def.checks.find((e) => 'url' === e.kind)
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => 'emoji' === e.kind)
  }
  get isUUID() {
    return !!this._def.checks.find((e) => 'uuid' === e.kind)
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => 'nanoid' === e.kind)
  }
  get isCUID() {
    return !!this._def.checks.find((e) => 'cuid' === e.kind)
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => 'cuid2' === e.kind)
  }
  get isULID() {
    return !!this._def.checks.find((e) => 'ulid' === e.kind)
  }
  get isIP() {
    return !!this._def.checks.find((e) => 'ip' === e.kind)
  }
  get isBase64() {
    return !!this._def.checks.find((e) => 'base64' === e.kind)
  }
  get minLength() {
    let e = null
    for (const t of this._def.checks)
      'min' === t.kind && (null === e || t.value > e) && (e = t.value)
    return e
  }
  get maxLength() {
    let e = null
    for (const t of this._def.checks)
      'max' === t.kind && (null === e || t.value < e) && (e = t.value)
    return e
  }
}
function floatSafeRemainder(e, t) {
  const n = (e.toString().split('.')[1] || '').length,
    o = (t.toString().split('.')[1] || '').length,
    i = n > o ? n : o
  return (
    (parseInt(e.toFixed(i).replace('.', '')) %
      parseInt(t.toFixed(i).replace('.', ''))) /
    Math.pow(10, i)
  )
}
;(ZodString.create = (e) => {
  var t
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t,
    ...processCreateParams(e)
  })
}),
  __name(floatSafeRemainder, 'floatSafeRemainder')
class ZodNumber extends ZodType {
  static {
    __name(this, 'ZodNumber')
  }
  constructor() {
    super(...arguments),
      (this.min = this.gte),
      (this.max = this.lte),
      (this.step = this.multipleOf)
  }
  _parse(e) {
    this._def.coerce && (e.data = Number(e.data))
    if (this._getType(e) !== ZodParsedType.number) {
      const t = this._getOrReturnCtx(e)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: t.parsedType
        }),
        INVALID
      )
    }
    let t
    const n = new ParseStatus()
    for (const o of this._def.checks)
      if ('int' === o.kind)
        util.isInteger(e.data) ||
          ((t = this._getOrReturnCtx(e, t)),
          addIssueToContext(t, {
            code: ZodIssueCode.invalid_type,
            expected: 'integer',
            received: 'float',
            message: o.message
          }),
          n.dirty())
      else if ('min' === o.kind) {
        ;(o.inclusive ? e.data < o.value : e.data <= o.value) &&
          ((t = this._getOrReturnCtx(e, t)),
          addIssueToContext(t, {
            code: ZodIssueCode.too_small,
            minimum: o.value,
            type: 'number',
            inclusive: o.inclusive,
            exact: !1,
            message: o.message
          }),
          n.dirty())
      } else if ('max' === o.kind) {
        ;(o.inclusive ? e.data > o.value : e.data >= o.value) &&
          ((t = this._getOrReturnCtx(e, t)),
          addIssueToContext(t, {
            code: ZodIssueCode.too_big,
            maximum: o.value,
            type: 'number',
            inclusive: o.inclusive,
            exact: !1,
            message: o.message
          }),
          n.dirty())
      } else
        'multipleOf' === o.kind
          ? 0 !== floatSafeRemainder(e.data, o.value) &&
            ((t = this._getOrReturnCtx(e, t)),
            addIssueToContext(t, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: o.value,
              message: o.message
            }),
            n.dirty())
          : 'finite' === o.kind
            ? Number.isFinite(e.data) ||
              ((t = this._getOrReturnCtx(e, t)),
              addIssueToContext(t, {
                code: ZodIssueCode.not_finite,
                message: o.message
              }),
              n.dirty())
            : util.assertNever(o)
    return { status: n.value, value: e.data }
  }
  gte(e, t) {
    return this.setLimit('min', e, !0, errorUtil.toString(t))
  }
  gt(e, t) {
    return this.setLimit('min', e, !1, errorUtil.toString(t))
  }
  lte(e, t) {
    return this.setLimit('max', e, !0, errorUtil.toString(t))
  }
  lt(e, t) {
    return this.setLimit('max', e, !1, errorUtil.toString(t))
  }
  setLimit(e, t, n, o) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: e, value: t, inclusive: n, message: errorUtil.toString(o) }
      ]
    })
  }
  _addCheck(e) {
    return new ZodNumber({ ...this._def, checks: [...this._def.checks, e] })
  }
  int(e) {
    return this._addCheck({ kind: 'int', message: errorUtil.toString(e) })
  }
  positive(e) {
    return this._addCheck({
      kind: 'min',
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(e)
    })
  }
  negative(e) {
    return this._addCheck({
      kind: 'max',
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(e)
    })
  }
  nonpositive(e) {
    return this._addCheck({
      kind: 'max',
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(e)
    })
  }
  nonnegative(e) {
    return this._addCheck({
      kind: 'min',
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(e)
    })
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: 'multipleOf',
      value: e,
      message: errorUtil.toString(t)
    })
  }
  finite(e) {
    return this._addCheck({ kind: 'finite', message: errorUtil.toString(e) })
  }
  safe(e) {
    return this._addCheck({
      kind: 'min',
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(e)
    })._addCheck({
      kind: 'max',
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(e)
    })
  }
  get minValue() {
    let e = null
    for (const t of this._def.checks)
      'min' === t.kind && (null === e || t.value > e) && (e = t.value)
    return e
  }
  get maxValue() {
    let e = null
    for (const t of this._def.checks)
      'max' === t.kind && (null === e || t.value < e) && (e = t.value)
    return e
  }
  get isInt() {
    return !!this._def.checks.find(
      (e) =>
        'int' === e.kind || ('multipleOf' === e.kind && util.isInteger(e.value))
    )
  }
  get isFinite() {
    let e = null,
      t = null
    for (const n of this._def.checks) {
      if ('finite' === n.kind || 'int' === n.kind || 'multipleOf' === n.kind)
        return !0
      'min' === n.kind
        ? (null === t || n.value > t) && (t = n.value)
        : 'max' === n.kind && (null === e || n.value < e) && (e = n.value)
    }
    return Number.isFinite(t) && Number.isFinite(e)
  }
}
ZodNumber.create = (e) =>
  new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (null == e ? void 0 : e.coerce) || !1,
    ...processCreateParams(e)
  })
class ZodBigInt extends ZodType {
  static {
    __name(this, 'ZodBigInt')
  }
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte)
  }
  _parse(e) {
    this._def.coerce && (e.data = BigInt(e.data))
    if (this._getType(e) !== ZodParsedType.bigint) {
      const t = this._getOrReturnCtx(e)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: t.parsedType
        }),
        INVALID
      )
    }
    let t
    const n = new ParseStatus()
    for (const o of this._def.checks)
      if ('min' === o.kind) {
        ;(o.inclusive ? e.data < o.value : e.data <= o.value) &&
          ((t = this._getOrReturnCtx(e, t)),
          addIssueToContext(t, {
            code: ZodIssueCode.too_small,
            type: 'bigint',
            minimum: o.value,
            inclusive: o.inclusive,
            message: o.message
          }),
          n.dirty())
      } else if ('max' === o.kind) {
        ;(o.inclusive ? e.data > o.value : e.data >= o.value) &&
          ((t = this._getOrReturnCtx(e, t)),
          addIssueToContext(t, {
            code: ZodIssueCode.too_big,
            type: 'bigint',
            maximum: o.value,
            inclusive: o.inclusive,
            message: o.message
          }),
          n.dirty())
      } else
        'multipleOf' === o.kind
          ? e.data % o.value !== BigInt(0) &&
            ((t = this._getOrReturnCtx(e, t)),
            addIssueToContext(t, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: o.value,
              message: o.message
            }),
            n.dirty())
          : util.assertNever(o)
    return { status: n.value, value: e.data }
  }
  gte(e, t) {
    return this.setLimit('min', e, !0, errorUtil.toString(t))
  }
  gt(e, t) {
    return this.setLimit('min', e, !1, errorUtil.toString(t))
  }
  lte(e, t) {
    return this.setLimit('max', e, !0, errorUtil.toString(t))
  }
  lt(e, t) {
    return this.setLimit('max', e, !1, errorUtil.toString(t))
  }
  setLimit(e, t, n, o) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: e, value: t, inclusive: n, message: errorUtil.toString(o) }
      ]
    })
  }
  _addCheck(e) {
    return new ZodBigInt({ ...this._def, checks: [...this._def.checks, e] })
  }
  positive(e) {
    return this._addCheck({
      kind: 'min',
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(e)
    })
  }
  negative(e) {
    return this._addCheck({
      kind: 'max',
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(e)
    })
  }
  nonpositive(e) {
    return this._addCheck({
      kind: 'max',
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(e)
    })
  }
  nonnegative(e) {
    return this._addCheck({
      kind: 'min',
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(e)
    })
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: 'multipleOf',
      value: e,
      message: errorUtil.toString(t)
    })
  }
  get minValue() {
    let e = null
    for (const t of this._def.checks)
      'min' === t.kind && (null === e || t.value > e) && (e = t.value)
    return e
  }
  get maxValue() {
    let e = null
    for (const t of this._def.checks)
      'max' === t.kind && (null === e || t.value < e) && (e = t.value)
    return e
  }
}
ZodBigInt.create = (e) => {
  var t
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t,
    ...processCreateParams(e)
  })
}
class ZodBoolean extends ZodType {
  static {
    __name(this, 'ZodBoolean')
  }
  _parse(e) {
    this._def.coerce && (e.data = Boolean(e.data))
    if (this._getType(e) !== ZodParsedType.boolean) {
      const t = this._getOrReturnCtx(e)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: t.parsedType
        }),
        INVALID
      )
    }
    return OK(e.data)
  }
}
ZodBoolean.create = (e) =>
  new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (null == e ? void 0 : e.coerce) || !1,
    ...processCreateParams(e)
  })
class ZodDate extends ZodType {
  static {
    __name(this, 'ZodDate')
  }
  _parse(e) {
    this._def.coerce && (e.data = new Date(e.data))
    if (this._getType(e) !== ZodParsedType.date) {
      const t = this._getOrReturnCtx(e)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: t.parsedType
        }),
        INVALID
      )
    }
    if (isNaN(e.data.getTime())) {
      return (
        addIssueToContext(this._getOrReturnCtx(e), {
          code: ZodIssueCode.invalid_date
        }),
        INVALID
      )
    }
    const t = new ParseStatus()
    let n
    for (const o of this._def.checks)
      'min' === o.kind
        ? e.data.getTime() < o.value &&
          ((n = this._getOrReturnCtx(e, n)),
          addIssueToContext(n, {
            code: ZodIssueCode.too_small,
            message: o.message,
            inclusive: !0,
            exact: !1,
            minimum: o.value,
            type: 'date'
          }),
          t.dirty())
        : 'max' === o.kind
          ? e.data.getTime() > o.value &&
            ((n = this._getOrReturnCtx(e, n)),
            addIssueToContext(n, {
              code: ZodIssueCode.too_big,
              message: o.message,
              inclusive: !0,
              exact: !1,
              maximum: o.value,
              type: 'date'
            }),
            t.dirty())
          : util.assertNever(o)
    return { status: t.value, value: new Date(e.data.getTime()) }
  }
  _addCheck(e) {
    return new ZodDate({ ...this._def, checks: [...this._def.checks, e] })
  }
  min(e, t) {
    return this._addCheck({
      kind: 'min',
      value: e.getTime(),
      message: errorUtil.toString(t)
    })
  }
  max(e, t) {
    return this._addCheck({
      kind: 'max',
      value: e.getTime(),
      message: errorUtil.toString(t)
    })
  }
  get minDate() {
    let e = null
    for (const t of this._def.checks)
      'min' === t.kind && (null === e || t.value > e) && (e = t.value)
    return null != e ? new Date(e) : null
  }
  get maxDate() {
    let e = null
    for (const t of this._def.checks)
      'max' === t.kind && (null === e || t.value < e) && (e = t.value)
    return null != e ? new Date(e) : null
  }
}
ZodDate.create = (e) =>
  new ZodDate({
    checks: [],
    coerce: (null == e ? void 0 : e.coerce) || !1,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(e)
  })
class ZodSymbol extends ZodType {
  static {
    __name(this, 'ZodSymbol')
  }
  _parse(e) {
    if (this._getType(e) !== ZodParsedType.symbol) {
      const t = this._getOrReturnCtx(e)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: t.parsedType
        }),
        INVALID
      )
    }
    return OK(e.data)
  }
}
ZodSymbol.create = (e) =>
  new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(e)
  })
class ZodUndefined extends ZodType {
  static {
    __name(this, 'ZodUndefined')
  }
  _parse(e) {
    if (this._getType(e) !== ZodParsedType.undefined) {
      const t = this._getOrReturnCtx(e)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: t.parsedType
        }),
        INVALID
      )
    }
    return OK(e.data)
  }
}
ZodUndefined.create = (e) =>
  new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(e)
  })
class ZodNull extends ZodType {
  static {
    __name(this, 'ZodNull')
  }
  _parse(e) {
    if (this._getType(e) !== ZodParsedType.null) {
      const t = this._getOrReturnCtx(e)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: t.parsedType
        }),
        INVALID
      )
    }
    return OK(e.data)
  }
}
ZodNull.create = (e) =>
  new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(e)
  })
class ZodAny extends ZodType {
  static {
    __name(this, 'ZodAny')
  }
  constructor() {
    super(...arguments), (this._any = !0)
  }
  _parse(e) {
    return OK(e.data)
  }
}
ZodAny.create = (e) =>
  new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(e)
  })
class ZodUnknown extends ZodType {
  static {
    __name(this, 'ZodUnknown')
  }
  constructor() {
    super(...arguments), (this._unknown = !0)
  }
  _parse(e) {
    return OK(e.data)
  }
}
ZodUnknown.create = (e) =>
  new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(e)
  })
class ZodNever extends ZodType {
  static {
    __name(this, 'ZodNever')
  }
  _parse(e) {
    const t = this._getOrReturnCtx(e)
    return (
      addIssueToContext(t, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: t.parsedType
      }),
      INVALID
    )
  }
}
ZodNever.create = (e) =>
  new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(e)
  })
class ZodVoid extends ZodType {
  static {
    __name(this, 'ZodVoid')
  }
  _parse(e) {
    if (this._getType(e) !== ZodParsedType.undefined) {
      const t = this._getOrReturnCtx(e)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: t.parsedType
        }),
        INVALID
      )
    }
    return OK(e.data)
  }
}
ZodVoid.create = (e) =>
  new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(e)
  })
class ZodArray extends ZodType {
  static {
    __name(this, 'ZodArray')
  }
  _parse(e) {
    const { ctx: t, status: n } = this._processInputParams(e),
      o = this._def
    if (t.parsedType !== ZodParsedType.array)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: t.parsedType
        }),
        INVALID
      )
    if (null !== o.exactLength) {
      const e = t.data.length > o.exactLength.value,
        i = t.data.length < o.exactLength.value
      ;(e || i) &&
        (addIssueToContext(t, {
          code: e ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: i ? o.exactLength.value : void 0,
          maximum: e ? o.exactLength.value : void 0,
          type: 'array',
          inclusive: !0,
          exact: !0,
          message: o.exactLength.message
        }),
        n.dirty())
    }
    if (
      (null !== o.minLength &&
        t.data.length < o.minLength.value &&
        (addIssueToContext(t, {
          code: ZodIssueCode.too_small,
          minimum: o.minLength.value,
          type: 'array',
          inclusive: !0,
          exact: !1,
          message: o.minLength.message
        }),
        n.dirty()),
      null !== o.maxLength &&
        t.data.length > o.maxLength.value &&
        (addIssueToContext(t, {
          code: ZodIssueCode.too_big,
          maximum: o.maxLength.value,
          type: 'array',
          inclusive: !0,
          exact: !1,
          message: o.maxLength.message
        }),
        n.dirty()),
      t.common.async)
    )
      return Promise.all(
        [...t.data].map((e, n) =>
          o.type._parseAsync(new ParseInputLazyPath(t, e, t.path, n))
        )
      ).then((e) => ParseStatus.mergeArray(n, e))
    const i = [...t.data].map((e, n) =>
      o.type._parseSync(new ParseInputLazyPath(t, e, t.path, n))
    )
    return ParseStatus.mergeArray(n, i)
  }
  get element() {
    return this._def.type
  }
  min(e, t) {
    return new ZodArray({
      ...this._def,
      minLength: { value: e, message: errorUtil.toString(t) }
    })
  }
  max(e, t) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: e, message: errorUtil.toString(t) }
    })
  }
  length(e, t) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: e, message: errorUtil.toString(t) }
    })
  }
  nonempty(e) {
    return this.min(1, e)
  }
}
function deepPartialify(e) {
  if (e instanceof ZodObject) {
    const t = {}
    for (const n in e.shape) {
      const o = e.shape[n]
      t[n] = ZodOptional.create(deepPartialify(o))
    }
    return new ZodObject({ ...e._def, shape: __name(() => t, 'shape') })
  }
  return e instanceof ZodArray
    ? new ZodArray({ ...e._def, type: deepPartialify(e.element) })
    : e instanceof ZodOptional
      ? ZodOptional.create(deepPartialify(e.unwrap()))
      : e instanceof ZodNullable
        ? ZodNullable.create(deepPartialify(e.unwrap()))
        : e instanceof ZodTuple
          ? ZodTuple.create(e.items.map((e) => deepPartialify(e)))
          : e
}
;(ZodArray.create = (e, t) =>
  new ZodArray({
    type: e,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(t)
  })),
  __name(deepPartialify, 'deepPartialify')
class ZodObject extends ZodType {
  static {
    __name(this, 'ZodObject')
  }
  constructor() {
    super(...arguments),
      (this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend)
  }
  _getCached() {
    if (null !== this._cached) return this._cached
    const e = this._def.shape(),
      t = util.objectKeys(e)
    return (this._cached = { shape: e, keys: t })
  }
  _parse(e) {
    if (this._getType(e) !== ZodParsedType.object) {
      const t = this._getOrReturnCtx(e)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: t.parsedType
        }),
        INVALID
      )
    }
    const { status: t, ctx: n } = this._processInputParams(e),
      { shape: o, keys: i } = this._getCached(),
      r = []
    if (
      !(
        this._def.catchall instanceof ZodNever &&
        'strip' === this._def.unknownKeys
      )
    )
      for (const s in n.data) i.includes(s) || r.push(s)
    const a = []
    for (const s of i) {
      const e = o[s],
        t = n.data[s]
      a.push({
        key: { status: 'valid', value: s },
        value: e._parse(new ParseInputLazyPath(n, t, n.path, s)),
        alwaysSet: s in n.data
      })
    }
    if (this._def.catchall instanceof ZodNever) {
      const e = this._def.unknownKeys
      if ('passthrough' === e)
        for (const t of r)
          a.push({
            key: { status: 'valid', value: t },
            value: { status: 'valid', value: n.data[t] }
          })
      else if ('strict' === e)
        r.length > 0 &&
          (addIssueToContext(n, {
            code: ZodIssueCode.unrecognized_keys,
            keys: r
          }),
          t.dirty())
      else if ('strip' !== e)
        throw new Error('Internal ZodObject error: invalid unknownKeys value.')
    } else {
      const e = this._def.catchall
      for (const t of r) {
        const o = n.data[t]
        a.push({
          key: { status: 'valid', value: t },
          value: e._parse(new ParseInputLazyPath(n, o, n.path, t)),
          alwaysSet: t in n.data
        })
      }
    }
    return n.common.async
      ? Promise.resolve()
          .then(async () => {
            const e = []
            for (const t of a) {
              const n = await t.key,
                o = await t.value
              e.push({ key: n, value: o, alwaysSet: t.alwaysSet })
            }
            return e
          })
          .then((e) => ParseStatus.mergeObjectSync(t, e))
      : ParseStatus.mergeObjectSync(t, a)
  }
  get shape() {
    return this._def.shape()
  }
  strict(e) {
    return (
      errorUtil.errToObj,
      new ZodObject({
        ...this._def,
        unknownKeys: 'strict',
        ...(void 0 !== e
          ? {
              errorMap: __name((t, n) => {
                var o, i, r, a
                const s =
                  null !==
                    (r =
                      null === (i = (o = this._def).errorMap) || void 0 === i
                        ? void 0
                        : i.call(o, t, n).message) && void 0 !== r
                    ? r
                    : n.defaultError
                return 'unrecognized_keys' === t.code
                  ? {
                      message:
                        null !== (a = errorUtil.errToObj(e).message) &&
                        void 0 !== a
                          ? a
                          : s
                    }
                  : { message: s }
              }, 'errorMap')
            }
          : {})
      })
    )
  }
  strip() {
    return new ZodObject({ ...this._def, unknownKeys: 'strip' })
  }
  passthrough() {
    return new ZodObject({ ...this._def, unknownKeys: 'passthrough' })
  }
  extend(e) {
    return new ZodObject({
      ...this._def,
      shape: __name(() => ({ ...this._def.shape(), ...e }), 'shape')
    })
  }
  merge(e) {
    return new ZodObject({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: __name(
        () => ({ ...this._def.shape(), ...e._def.shape() }),
        'shape'
      ),
      typeName: ZodFirstPartyTypeKind.ZodObject
    })
  }
  setKey(e, t) {
    return this.augment({ [e]: t })
  }
  catchall(e) {
    return new ZodObject({ ...this._def, catchall: e })
  }
  pick(e) {
    const t = {}
    return (
      util.objectKeys(e).forEach((n) => {
        e[n] && this.shape[n] && (t[n] = this.shape[n])
      }),
      new ZodObject({ ...this._def, shape: __name(() => t, 'shape') })
    )
  }
  omit(e) {
    const t = {}
    return (
      util.objectKeys(this.shape).forEach((n) => {
        e[n] || (t[n] = this.shape[n])
      }),
      new ZodObject({ ...this._def, shape: __name(() => t, 'shape') })
    )
  }
  deepPartial() {
    return deepPartialify(this)
  }
  partial(e) {
    const t = {}
    return (
      util.objectKeys(this.shape).forEach((n) => {
        const o = this.shape[n]
        e && !e[n] ? (t[n] = o) : (t[n] = o.optional())
      }),
      new ZodObject({ ...this._def, shape: __name(() => t, 'shape') })
    )
  }
  required(e) {
    const t = {}
    return (
      util.objectKeys(this.shape).forEach((n) => {
        if (e && !e[n]) t[n] = this.shape[n]
        else {
          let e = this.shape[n]
          for (; e instanceof ZodOptional; ) e = e._def.innerType
          t[n] = e
        }
      }),
      new ZodObject({ ...this._def, shape: __name(() => t, 'shape') })
    )
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape))
  }
}
;(ZodObject.create = (e, t) =>
  new ZodObject({
    shape: __name(() => e, 'shape'),
    unknownKeys: 'strip',
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(t)
  })),
  (ZodObject.strictCreate = (e, t) =>
    new ZodObject({
      shape: __name(() => e, 'shape'),
      unknownKeys: 'strict',
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(t)
    })),
  (ZodObject.lazycreate = (e, t) =>
    new ZodObject({
      shape: e,
      unknownKeys: 'strip',
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(t)
    }))
class ZodUnion extends ZodType {
  static {
    __name(this, 'ZodUnion')
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e),
      n = this._def.options
    function o(e) {
      for (const t of e) if ('valid' === t.result.status) return t.result
      for (const o of e)
        if ('dirty' === o.result.status)
          return t.common.issues.push(...o.ctx.common.issues), o.result
      const n = e.map((e) => new ZodError(e.ctx.common.issues))
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_union,
          unionErrors: n
        }),
        INVALID
      )
    }
    if ((__name(o, 'handleResults'), t.common.async))
      return Promise.all(
        n.map(async (e) => {
          const n = { ...t, common: { ...t.common, issues: [] }, parent: null }
          return {
            result: await e._parseAsync({
              data: t.data,
              path: t.path,
              parent: n
            }),
            ctx: n
          }
        })
      ).then(o)
    {
      let e
      const o = []
      for (const r of n) {
        const n = { ...t, common: { ...t.common, issues: [] }, parent: null },
          i = r._parseSync({ data: t.data, path: t.path, parent: n })
        if ('valid' === i.status) return i
        'dirty' !== i.status || e || (e = { result: i, ctx: n }),
          n.common.issues.length && o.push(n.common.issues)
      }
      if (e) return t.common.issues.push(...e.ctx.common.issues), e.result
      const i = o.map((e) => new ZodError(e))
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_union,
          unionErrors: i
        }),
        INVALID
      )
    }
  }
  get options() {
    return this._def.options
  }
}
ZodUnion.create = (e, t) =>
  new ZodUnion({
    options: e,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(t)
  })
const getDiscriminator = __name(
  (e) =>
    e instanceof ZodLazy
      ? getDiscriminator(e.schema)
      : e instanceof ZodEffects
        ? getDiscriminator(e.innerType())
        : e instanceof ZodLiteral
          ? [e.value]
          : e instanceof ZodEnum
            ? e.options
            : e instanceof ZodNativeEnum
              ? util.objectValues(e.enum)
              : e instanceof ZodDefault
                ? getDiscriminator(e._def.innerType)
                : e instanceof ZodUndefined
                  ? [void 0]
                  : e instanceof ZodNull
                    ? [null]
                    : e instanceof ZodOptional
                      ? [void 0, ...getDiscriminator(e.unwrap())]
                      : e instanceof ZodNullable
                        ? [null, ...getDiscriminator(e.unwrap())]
                        : e instanceof ZodBranded || e instanceof ZodReadonly
                          ? getDiscriminator(e.unwrap())
                          : e instanceof ZodCatch
                            ? getDiscriminator(e._def.innerType)
                            : [],
  'getDiscriminator'
)
class ZodDiscriminatedUnion extends ZodType {
  static {
    __name(this, 'ZodDiscriminatedUnion')
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e)
    if (t.parsedType !== ZodParsedType.object)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: t.parsedType
        }),
        INVALID
      )
    const n = this.discriminator,
      o = t.data[n],
      i = this.optionsMap.get(o)
    return i
      ? t.common.async
        ? i._parseAsync({ data: t.data, path: t.path, parent: t })
        : i._parseSync({ data: t.data, path: t.path, parent: t })
      : (addIssueToContext(t, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [n]
        }),
        INVALID)
  }
  get discriminator() {
    return this._def.discriminator
  }
  get options() {
    return this._def.options
  }
  get optionsMap() {
    return this._def.optionsMap
  }
  static create(e, t, n) {
    const o = new Map()
    for (const i of t) {
      const t = getDiscriminator(i.shape[e])
      if (!t.length)
        throw new Error(
          `A discriminator value for key \`${e}\` could not be extracted from all schema options`
        )
      for (const n of t) {
        if (o.has(n))
          throw new Error(
            `Discriminator property ${String(e)} has duplicate value ${String(n)}`
          )
        o.set(n, i)
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator: e,
      options: t,
      optionsMap: o,
      ...processCreateParams(n)
    })
  }
}
function mergeValues(e, t) {
  const n = getParsedType(e),
    o = getParsedType(t)
  if (e === t) return { valid: !0, data: e }
  if (n === ZodParsedType.object && o === ZodParsedType.object) {
    const n = util.objectKeys(t),
      o = util.objectKeys(e).filter((e) => -1 !== n.indexOf(e)),
      i = { ...e, ...t }
    for (const r of o) {
      const n = mergeValues(e[r], t[r])
      if (!n.valid) return { valid: !1 }
      i[r] = n.data
    }
    return { valid: !0, data: i }
  }
  if (n === ZodParsedType.array && o === ZodParsedType.array) {
    if (e.length !== t.length) return { valid: !1 }
    const n = []
    for (let o = 0; o < e.length; o++) {
      const i = mergeValues(e[o], t[o])
      if (!i.valid) return { valid: !1 }
      n.push(i.data)
    }
    return { valid: !0, data: n }
  }
  return n === ZodParsedType.date && o === ZodParsedType.date && +e == +t
    ? { valid: !0, data: e }
    : { valid: !1 }
}
__name(mergeValues, 'mergeValues')
class ZodIntersection extends ZodType {
  static {
    __name(this, 'ZodIntersection')
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e),
      o = __name((e, o) => {
        if (isAborted(e) || isAborted(o)) return INVALID
        const i = mergeValues(e.value, o.value)
        return i.valid
          ? ((isDirty(e) || isDirty(o)) && t.dirty(),
            { status: t.value, value: i.data })
          : (addIssueToContext(n, {
              code: ZodIssueCode.invalid_intersection_types
            }),
            INVALID)
      }, 'handleParsed')
    return n.common.async
      ? Promise.all([
          this._def.left._parseAsync({ data: n.data, path: n.path, parent: n }),
          this._def.right._parseAsync({ data: n.data, path: n.path, parent: n })
        ]).then(([e, t]) => o(e, t))
      : o(
          this._def.left._parseSync({ data: n.data, path: n.path, parent: n }),
          this._def.right._parseSync({ data: n.data, path: n.path, parent: n })
        )
  }
}
ZodIntersection.create = (e, t, n) =>
  new ZodIntersection({
    left: e,
    right: t,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(n)
  })
class ZodTuple extends ZodType {
  static {
    __name(this, 'ZodTuple')
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e)
    if (n.parsedType !== ZodParsedType.array)
      return (
        addIssueToContext(n, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: n.parsedType
        }),
        INVALID
      )
    if (n.data.length < this._def.items.length)
      return (
        addIssueToContext(n, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: 'array'
        }),
        INVALID
      )
    !this._def.rest &&
      n.data.length > this._def.items.length &&
      (addIssueToContext(n, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: 'array'
      }),
      t.dirty())
    const o = [...n.data]
      .map((e, t) => {
        const o = this._def.items[t] || this._def.rest
        return o ? o._parse(new ParseInputLazyPath(n, e, n.path, t)) : null
      })
      .filter((e) => !!e)
    return n.common.async
      ? Promise.all(o).then((e) => ParseStatus.mergeArray(t, e))
      : ParseStatus.mergeArray(t, o)
  }
  get items() {
    return this._def.items
  }
  rest(e) {
    return new ZodTuple({ ...this._def, rest: e })
  }
}
ZodTuple.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error('You must pass an array of schemas to z.tuple([ ... ])')
  return new ZodTuple({
    items: e,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(t)
  })
}
class ZodRecord extends ZodType {
  static {
    __name(this, 'ZodRecord')
  }
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e)
    if (n.parsedType !== ZodParsedType.object)
      return (
        addIssueToContext(n, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: n.parsedType
        }),
        INVALID
      )
    const o = [],
      i = this._def.keyType,
      r = this._def.valueType
    for (const a in n.data)
      o.push({
        key: i._parse(new ParseInputLazyPath(n, a, n.path, a)),
        value: r._parse(new ParseInputLazyPath(n, n.data[a], n.path, a)),
        alwaysSet: a in n.data
      })
    return n.common.async
      ? ParseStatus.mergeObjectAsync(t, o)
      : ParseStatus.mergeObjectSync(t, o)
  }
  get element() {
    return this._def.valueType
  }
  static create(e, t, n) {
    return new ZodRecord(
      t instanceof ZodType
        ? {
            keyType: e,
            valueType: t,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(n)
          }
        : {
            keyType: ZodString.create(),
            valueType: e,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(t)
          }
    )
  }
}
class ZodMap extends ZodType {
  static {
    __name(this, 'ZodMap')
  }
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e)
    if (n.parsedType !== ZodParsedType.map)
      return (
        addIssueToContext(n, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: n.parsedType
        }),
        INVALID
      )
    const o = this._def.keyType,
      i = this._def.valueType,
      r = [...n.data.entries()].map(([e, t], r) => ({
        key: o._parse(new ParseInputLazyPath(n, e, n.path, [r, 'key'])),
        value: i._parse(new ParseInputLazyPath(n, t, n.path, [r, 'value']))
      }))
    if (n.common.async) {
      const e = new Map()
      return Promise.resolve().then(async () => {
        for (const n of r) {
          const o = await n.key,
            i = await n.value
          if ('aborted' === o.status || 'aborted' === i.status) return INVALID
          ;('dirty' !== o.status && 'dirty' !== i.status) || t.dirty(),
            e.set(o.value, i.value)
        }
        return { status: t.value, value: e }
      })
    }
    {
      const e = new Map()
      for (const n of r) {
        const o = n.key,
          i = n.value
        if ('aborted' === o.status || 'aborted' === i.status) return INVALID
        ;('dirty' !== o.status && 'dirty' !== i.status) || t.dirty(),
          e.set(o.value, i.value)
      }
      return { status: t.value, value: e }
    }
  }
}
ZodMap.create = (e, t, n) =>
  new ZodMap({
    valueType: t,
    keyType: e,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(n)
  })
class ZodSet extends ZodType {
  static {
    __name(this, 'ZodSet')
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e)
    if (n.parsedType !== ZodParsedType.set)
      return (
        addIssueToContext(n, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: n.parsedType
        }),
        INVALID
      )
    const o = this._def
    null !== o.minSize &&
      n.data.size < o.minSize.value &&
      (addIssueToContext(n, {
        code: ZodIssueCode.too_small,
        minimum: o.minSize.value,
        type: 'set',
        inclusive: !0,
        exact: !1,
        message: o.minSize.message
      }),
      t.dirty()),
      null !== o.maxSize &&
        n.data.size > o.maxSize.value &&
        (addIssueToContext(n, {
          code: ZodIssueCode.too_big,
          maximum: o.maxSize.value,
          type: 'set',
          inclusive: !0,
          exact: !1,
          message: o.maxSize.message
        }),
        t.dirty())
    const i = this._def.valueType
    function r(e) {
      const n = new Set()
      for (const o of e) {
        if ('aborted' === o.status) return INVALID
        'dirty' === o.status && t.dirty(), n.add(o.value)
      }
      return { status: t.value, value: n }
    }
    __name(r, 'finalizeSet')
    const a = [...n.data.values()].map((e, t) =>
      i._parse(new ParseInputLazyPath(n, e, n.path, t))
    )
    return n.common.async ? Promise.all(a).then((e) => r(e)) : r(a)
  }
  min(e, t) {
    return new ZodSet({
      ...this._def,
      minSize: { value: e, message: errorUtil.toString(t) }
    })
  }
  max(e, t) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: e, message: errorUtil.toString(t) }
    })
  }
  size(e, t) {
    return this.min(e, t).max(e, t)
  }
  nonempty(e) {
    return this.min(1, e)
  }
}
ZodSet.create = (e, t) =>
  new ZodSet({
    valueType: e,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(t)
  })
class ZodFunction extends ZodType {
  static {
    __name(this, 'ZodFunction')
  }
  constructor() {
    super(...arguments), (this.validate = this.implement)
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e)
    if (t.parsedType !== ZodParsedType.function)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: t.parsedType
        }),
        INVALID
      )
    function n(e, n) {
      return makeIssue({
        data: e,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          getErrorMap(),
          errorMap$1
        ].filter((e) => !!e),
        issueData: { code: ZodIssueCode.invalid_arguments, argumentsError: n }
      })
    }
    function o(e, n) {
      return makeIssue({
        data: e,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          getErrorMap(),
          errorMap$1
        ].filter((e) => !!e),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: n
        }
      })
    }
    __name(n, 'makeArgsIssue'), __name(o, 'makeReturnsIssue')
    const i = { errorMap: t.common.contextualErrorMap },
      r = t.data
    if (this._def.returns instanceof ZodPromise) {
      const e = this
      return OK(async function (...t) {
        const a = new ZodError([]),
          s = await e._def.args.parseAsync(t, i).catch((e) => {
            throw (a.addIssue(n(t, e)), a)
          }),
          l = await Reflect.apply(r, this, s)
        return await e._def.returns._def.type.parseAsync(l, i).catch((e) => {
          throw (a.addIssue(o(l, e)), a)
        })
      })
    }
    {
      const e = this
      return OK(function (...t) {
        const a = e._def.args.safeParse(t, i)
        if (!a.success) throw new ZodError([n(t, a.error)])
        const s = Reflect.apply(r, this, a.data),
          l = e._def.returns.safeParse(s, i)
        if (!l.success) throw new ZodError([o(s, l.error)])
        return l.data
      })
    }
  }
  parameters() {
    return this._def.args
  }
  returnType() {
    return this._def.returns
  }
  args(...e) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(e).rest(ZodUnknown.create())
    })
  }
  returns(e) {
    return new ZodFunction({ ...this._def, returns: e })
  }
  implement(e) {
    return this.parse(e)
  }
  strictImplement(e) {
    return this.parse(e)
  }
  static create(e, t, n) {
    return new ZodFunction({
      args: e || ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: t || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(n)
    })
  }
}
class ZodLazy extends ZodType {
  static {
    __name(this, 'ZodLazy')
  }
  get schema() {
    return this._def.getter()
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e)
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t })
  }
}
ZodLazy.create = (e, t) =>
  new ZodLazy({
    getter: e,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(t)
  })
class ZodLiteral extends ZodType {
  static {
    __name(this, 'ZodLiteral')
  }
  _parse(e) {
    if (e.data !== this._def.value) {
      const t = this._getOrReturnCtx(e)
      return (
        addIssueToContext(t, {
          received: t.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        }),
        INVALID
      )
    }
    return { status: 'valid', value: e.data }
  }
  get value() {
    return this._def.value
  }
}
function createZodEnum(e, t) {
  return new ZodEnum({
    values: e,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(t)
  })
}
;(ZodLiteral.create = (e, t) =>
  new ZodLiteral({
    value: e,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(t)
  })),
  __name(createZodEnum, 'createZodEnum')
class ZodEnum extends ZodType {
  static {
    __name(this, 'ZodEnum')
  }
  constructor() {
    super(...arguments), _ZodEnum_cache.set(this, void 0)
  }
  _parse(e) {
    if ('string' != typeof e.data) {
      const t = this._getOrReturnCtx(e),
        n = this._def.values
      return (
        addIssueToContext(t, {
          expected: util.joinValues(n),
          received: t.parsedType,
          code: ZodIssueCode.invalid_type
        }),
        INVALID
      )
    }
    if (
      (__classPrivateFieldGet(this, _ZodEnum_cache, 'f') ||
        __classPrivateFieldSet(
          this,
          _ZodEnum_cache,
          new Set(this._def.values),
          'f'
        ),
      !__classPrivateFieldGet(this, _ZodEnum_cache, 'f').has(e.data))
    ) {
      const t = this._getOrReturnCtx(e),
        n = this._def.values
      return (
        addIssueToContext(t, {
          received: t.data,
          code: ZodIssueCode.invalid_enum_value,
          options: n
        }),
        INVALID
      )
    }
    return OK(e.data)
  }
  get options() {
    return this._def.values
  }
  get enum() {
    const e = {}
    for (const t of this._def.values) e[t] = t
    return e
  }
  get Values() {
    const e = {}
    for (const t of this._def.values) e[t] = t
    return e
  }
  get Enum() {
    const e = {}
    for (const t of this._def.values) e[t] = t
    return e
  }
  extract(e, t = this._def) {
    return ZodEnum.create(e, { ...this._def, ...t })
  }
  exclude(e, t = this._def) {
    return ZodEnum.create(
      this.options.filter((t) => !e.includes(t)),
      { ...this._def, ...t }
    )
  }
}
;(_ZodEnum_cache = new WeakMap()), (ZodEnum.create = createZodEnum)
class ZodNativeEnum extends ZodType {
  static {
    __name(this, 'ZodNativeEnum')
  }
  constructor() {
    super(...arguments), _ZodNativeEnum_cache.set(this, void 0)
  }
  _parse(e) {
    const t = util.getValidEnumValues(this._def.values),
      n = this._getOrReturnCtx(e)
    if (
      n.parsedType !== ZodParsedType.string &&
      n.parsedType !== ZodParsedType.number
    ) {
      const e = util.objectValues(t)
      return (
        addIssueToContext(n, {
          expected: util.joinValues(e),
          received: n.parsedType,
          code: ZodIssueCode.invalid_type
        }),
        INVALID
      )
    }
    if (
      (__classPrivateFieldGet(this, _ZodNativeEnum_cache, 'f') ||
        __classPrivateFieldSet(
          this,
          _ZodNativeEnum_cache,
          new Set(util.getValidEnumValues(this._def.values)),
          'f'
        ),
      !__classPrivateFieldGet(this, _ZodNativeEnum_cache, 'f').has(e.data))
    ) {
      const e = util.objectValues(t)
      return (
        addIssueToContext(n, {
          received: n.data,
          code: ZodIssueCode.invalid_enum_value,
          options: e
        }),
        INVALID
      )
    }
    return OK(e.data)
  }
  get enum() {
    return this._def.values
  }
}
;(_ZodNativeEnum_cache = new WeakMap()),
  (ZodNativeEnum.create = (e, t) =>
    new ZodNativeEnum({
      values: e,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(t)
    }))
class ZodPromise extends ZodType {
  static {
    __name(this, 'ZodPromise')
  }
  unwrap() {
    return this._def.type
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e)
    if (t.parsedType !== ZodParsedType.promise && !1 === t.common.async)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: t.parsedType
        }),
        INVALID
      )
    const n =
      t.parsedType === ZodParsedType.promise ? t.data : Promise.resolve(t.data)
    return OK(
      n.then((e) =>
        this._def.type.parseAsync(e, {
          path: t.path,
          errorMap: t.common.contextualErrorMap
        })
      )
    )
  }
}
ZodPromise.create = (e, t) =>
  new ZodPromise({
    type: e,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(t)
  })
class ZodEffects extends ZodType {
  static {
    __name(this, 'ZodEffects')
  }
  innerType() {
    return this._def.schema
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e),
      o = this._def.effect || null,
      i = {
        addIssue: __name((e) => {
          addIssueToContext(n, e), e.fatal ? t.abort() : t.dirty()
        }, 'addIssue'),
        get path() {
          return n.path
        }
      }
    if (((i.addIssue = i.addIssue.bind(i)), 'preprocess' === o.type)) {
      const e = o.transform(n.data, i)
      if (n.common.async)
        return Promise.resolve(e).then(async (e) => {
          if ('aborted' === t.value) return INVALID
          const o = await this._def.schema._parseAsync({
            data: e,
            path: n.path,
            parent: n
          })
          return 'aborted' === o.status
            ? INVALID
            : 'dirty' === o.status || 'dirty' === t.value
              ? DIRTY(o.value)
              : o
        })
      {
        if ('aborted' === t.value) return INVALID
        const o = this._def.schema._parseSync({
          data: e,
          path: n.path,
          parent: n
        })
        return 'aborted' === o.status
          ? INVALID
          : 'dirty' === o.status || 'dirty' === t.value
            ? DIRTY(o.value)
            : o
      }
    }
    if ('refinement' === o.type) {
      const e = __name((e) => {
        const t = o.refinement(e, i)
        if (n.common.async) return Promise.resolve(t)
        if (t instanceof Promise)
          throw new Error(
            'Async refinement encountered during synchronous parse operation. Use .parseAsync instead.'
          )
        return e
      }, 'executeRefinement')
      if (!1 === n.common.async) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        })
        return 'aborted' === o.status
          ? INVALID
          : ('dirty' === o.status && t.dirty(),
            e(o.value),
            { status: t.value, value: o.value })
      }
      return this._def.schema
        ._parseAsync({ data: n.data, path: n.path, parent: n })
        .then((n) =>
          'aborted' === n.status
            ? INVALID
            : ('dirty' === n.status && t.dirty(),
              e(n.value).then(() => ({ status: t.value, value: n.value })))
        )
    }
    if ('transform' === o.type) {
      if (!1 === n.common.async) {
        const e = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        })
        if (!isValid(e)) return e
        const r = o.transform(e.value, i)
        if (r instanceof Promise)
          throw new Error(
            'Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.'
          )
        return { status: t.value, value: r }
      }
      return this._def.schema
        ._parseAsync({ data: n.data, path: n.path, parent: n })
        .then((e) =>
          isValid(e)
            ? Promise.resolve(o.transform(e.value, i)).then((e) => ({
                status: t.value,
                value: e
              }))
            : e
        )
    }
    util.assertNever(o)
  }
}
;(ZodEffects.create = (e, t, n) =>
  new ZodEffects({
    schema: e,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect: t,
    ...processCreateParams(n)
  })),
  (ZodEffects.createWithPreprocess = (e, t, n) =>
    new ZodEffects({
      schema: t,
      effect: { type: 'preprocess', transform: e },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(n)
    }))
class ZodOptional extends ZodType {
  static {
    __name(this, 'ZodOptional')
  }
  _parse(e) {
    return this._getType(e) === ZodParsedType.undefined
      ? OK(void 0)
      : this._def.innerType._parse(e)
  }
  unwrap() {
    return this._def.innerType
  }
}
ZodOptional.create = (e, t) =>
  new ZodOptional({
    innerType: e,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(t)
  })
class ZodNullable extends ZodType {
  static {
    __name(this, 'ZodNullable')
  }
  _parse(e) {
    return this._getType(e) === ZodParsedType.null
      ? OK(null)
      : this._def.innerType._parse(e)
  }
  unwrap() {
    return this._def.innerType
  }
}
ZodNullable.create = (e, t) =>
  new ZodNullable({
    innerType: e,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(t)
  })
class ZodDefault extends ZodType {
  static {
    __name(this, 'ZodDefault')
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e)
    let n = t.data
    return (
      t.parsedType === ZodParsedType.undefined &&
        (n = this._def.defaultValue()),
      this._def.innerType._parse({ data: n, path: t.path, parent: t })
    )
  }
  removeDefault() {
    return this._def.innerType
  }
}
ZodDefault.create = (e, t) =>
  new ZodDefault({
    innerType: e,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: 'function' == typeof t.default ? t.default : () => t.default,
    ...processCreateParams(t)
  })
class ZodCatch extends ZodType {
  static {
    __name(this, 'ZodCatch')
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e),
      n = { ...t, common: { ...t.common, issues: [] } },
      o = this._def.innerType._parse({
        data: n.data,
        path: n.path,
        parent: { ...n }
      })
    return isAsync(o)
      ? o.then((e) => ({
          status: 'valid',
          value:
            'valid' === e.status
              ? e.value
              : this._def.catchValue({
                  get error() {
                    return new ZodError(n.common.issues)
                  },
                  input: n.data
                })
        }))
      : {
          status: 'valid',
          value:
            'valid' === o.status
              ? o.value
              : this._def.catchValue({
                  get error() {
                    return new ZodError(n.common.issues)
                  },
                  input: n.data
                })
        }
  }
  removeCatch() {
    return this._def.innerType
  }
}
ZodCatch.create = (e, t) =>
  new ZodCatch({
    innerType: e,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: 'function' == typeof t.catch ? t.catch : () => t.catch,
    ...processCreateParams(t)
  })
class ZodNaN extends ZodType {
  static {
    __name(this, 'ZodNaN')
  }
  _parse(e) {
    if (this._getType(e) !== ZodParsedType.nan) {
      const t = this._getOrReturnCtx(e)
      return (
        addIssueToContext(t, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: t.parsedType
        }),
        INVALID
      )
    }
    return { status: 'valid', value: e.data }
  }
}
ZodNaN.create = (e) =>
  new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(e)
  })
const BRAND = Symbol('zod_brand')
class ZodBranded extends ZodType {
  static {
    __name(this, 'ZodBranded')
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e),
      n = t.data
    return this._def.type._parse({ data: n, path: t.path, parent: t })
  }
  unwrap() {
    return this._def.type
  }
}
class ZodPipeline extends ZodType {
  static {
    __name(this, 'ZodPipeline')
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e)
    if (n.common.async) {
      return __name(async () => {
        const e = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        })
        return 'aborted' === e.status
          ? INVALID
          : 'dirty' === e.status
            ? (t.dirty(), DIRTY(e.value))
            : this._def.out._parseAsync({
                data: e.value,
                path: n.path,
                parent: n
              })
      }, 'handleAsync')()
    }
    {
      const e = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      })
      return 'aborted' === e.status
        ? INVALID
        : 'dirty' === e.status
          ? (t.dirty(), { status: 'dirty', value: e.value })
          : this._def.out._parseSync({ data: e.value, path: n.path, parent: n })
    }
  }
  static create(e, t) {
    return new ZodPipeline({
      in: e,
      out: t,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    })
  }
}
class ZodReadonly extends ZodType {
  static {
    __name(this, 'ZodReadonly')
  }
  _parse(e) {
    const t = this._def.innerType._parse(e),
      n = __name(
        (e) => (isValid(e) && (e.value = Object.freeze(e.value)), e),
        'freeze'
      )
    return isAsync(t) ? t.then((e) => n(e)) : n(t)
  }
  unwrap() {
    return this._def.innerType
  }
}
function custom(e, t = {}, n) {
  return e
    ? ZodAny.create().superRefine((o, i) => {
        var r, a
        if (!e(o)) {
          const e =
              'function' == typeof t
                ? t(o)
                : 'string' == typeof t
                  ? { message: t }
                  : t,
            s =
              null === (a = null !== (r = e.fatal) && void 0 !== r ? r : n) ||
              void 0 === a ||
              a,
            l = 'string' == typeof e ? { message: e } : e
          i.addIssue({ code: 'custom', ...l, fatal: s })
        }
      })
    : ZodAny.create()
}
;(ZodReadonly.create = (e, t) =>
  new ZodReadonly({
    innerType: e,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(t)
  })),
  __name(custom, 'custom')
const late = { object: ZodObject.lazycreate }
var ZodFirstPartyTypeKind, ZodFirstPartyTypeKind2
;(ZodFirstPartyTypeKind2 =
  ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {})),
  (ZodFirstPartyTypeKind2.ZodString = 'ZodString'),
  (ZodFirstPartyTypeKind2.ZodNumber = 'ZodNumber'),
  (ZodFirstPartyTypeKind2.ZodNaN = 'ZodNaN'),
  (ZodFirstPartyTypeKind2.ZodBigInt = 'ZodBigInt'),
  (ZodFirstPartyTypeKind2.ZodBoolean = 'ZodBoolean'),
  (ZodFirstPartyTypeKind2.ZodDate = 'ZodDate'),
  (ZodFirstPartyTypeKind2.ZodSymbol = 'ZodSymbol'),
  (ZodFirstPartyTypeKind2.ZodUndefined = 'ZodUndefined'),
  (ZodFirstPartyTypeKind2.ZodNull = 'ZodNull'),
  (ZodFirstPartyTypeKind2.ZodAny = 'ZodAny'),
  (ZodFirstPartyTypeKind2.ZodUnknown = 'ZodUnknown'),
  (ZodFirstPartyTypeKind2.ZodNever = 'ZodNever'),
  (ZodFirstPartyTypeKind2.ZodVoid = 'ZodVoid'),
  (ZodFirstPartyTypeKind2.ZodArray = 'ZodArray'),
  (ZodFirstPartyTypeKind2.ZodObject = 'ZodObject'),
  (ZodFirstPartyTypeKind2.ZodUnion = 'ZodUnion'),
  (ZodFirstPartyTypeKind2.ZodDiscriminatedUnion = 'ZodDiscriminatedUnion'),
  (ZodFirstPartyTypeKind2.ZodIntersection = 'ZodIntersection'),
  (ZodFirstPartyTypeKind2.ZodTuple = 'ZodTuple'),
  (ZodFirstPartyTypeKind2.ZodRecord = 'ZodRecord'),
  (ZodFirstPartyTypeKind2.ZodMap = 'ZodMap'),
  (ZodFirstPartyTypeKind2.ZodSet = 'ZodSet'),
  (ZodFirstPartyTypeKind2.ZodFunction = 'ZodFunction'),
  (ZodFirstPartyTypeKind2.ZodLazy = 'ZodLazy'),
  (ZodFirstPartyTypeKind2.ZodLiteral = 'ZodLiteral'),
  (ZodFirstPartyTypeKind2.ZodEnum = 'ZodEnum'),
  (ZodFirstPartyTypeKind2.ZodEffects = 'ZodEffects'),
  (ZodFirstPartyTypeKind2.ZodNativeEnum = 'ZodNativeEnum'),
  (ZodFirstPartyTypeKind2.ZodOptional = 'ZodOptional'),
  (ZodFirstPartyTypeKind2.ZodNullable = 'ZodNullable'),
  (ZodFirstPartyTypeKind2.ZodDefault = 'ZodDefault'),
  (ZodFirstPartyTypeKind2.ZodCatch = 'ZodCatch'),
  (ZodFirstPartyTypeKind2.ZodPromise = 'ZodPromise'),
  (ZodFirstPartyTypeKind2.ZodBranded = 'ZodBranded'),
  (ZodFirstPartyTypeKind2.ZodPipeline = 'ZodPipeline'),
  (ZodFirstPartyTypeKind2.ZodReadonly = 'ZodReadonly')
const instanceOfType = __name(
    (e, t = { message: `Input not instance of ${e.name}` }) =>
      custom((t) => t instanceof e, t),
    'instanceOfType'
  ),
  stringType = ZodString.create,
  numberType = ZodNumber.create,
  nanType = ZodNaN.create,
  bigIntType = ZodBigInt.create,
  booleanType = ZodBoolean.create,
  dateType = ZodDate.create,
  symbolType = ZodSymbol.create,
  undefinedType = ZodUndefined.create,
  nullType = ZodNull.create,
  anyType = ZodAny.create,
  unknownType = ZodUnknown.create,
  neverType = ZodNever.create,
  voidType = ZodVoid.create,
  arrayType = ZodArray.create,
  objectType = ZodObject.create,
  strictObjectType = ZodObject.strictCreate,
  unionType = ZodUnion.create,
  discriminatedUnionType = ZodDiscriminatedUnion.create,
  intersectionType = ZodIntersection.create,
  tupleType = ZodTuple.create,
  recordType = ZodRecord.create,
  mapType = ZodMap.create,
  setType = ZodSet.create,
  functionType = ZodFunction.create,
  lazyType = ZodLazy.create,
  literalType = ZodLiteral.create,
  enumType = ZodEnum.create,
  nativeEnumType = ZodNativeEnum.create,
  promiseType = ZodPromise.create,
  effectsType = ZodEffects.create,
  optionalType = ZodOptional.create,
  nullableType = ZodNullable.create,
  preprocessType = ZodEffects.createWithPreprocess,
  pipelineType = ZodPipeline.create,
  ostring = __name(() => stringType().optional(), 'ostring'),
  onumber = __name(() => numberType().optional(), 'onumber'),
  oboolean = __name(() => booleanType().optional(), 'oboolean'),
  coerce = {
    string: __name((e) => ZodString.create({ ...e, coerce: !0 }), 'string'),
    number: __name((e) => ZodNumber.create({ ...e, coerce: !0 }), 'number'),
    boolean: __name((e) => ZodBoolean.create({ ...e, coerce: !0 }), 'boolean'),
    bigint: __name((e) => ZodBigInt.create({ ...e, coerce: !0 }), 'bigint'),
    date: __name((e) => ZodDate.create({ ...e, coerce: !0 }), 'date')
  },
  NEVER = INVALID
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$1,
  setErrorMap: setErrorMap,
  getErrorMap: getErrorMap,
  makeIssue: makeIssue,
  EMPTY_PATH: EMPTY_PATH,
  addIssueToContext: addIssueToContext,
  ParseStatus: ParseStatus,
  INVALID: INVALID,
  DIRTY: DIRTY,
  OK: OK,
  isAborted: isAborted,
  isDirty: isDirty,
  isValid: isValid,
  isAsync: isAsync,
  get util() {
    return util
  },
  get objectUtil() {
    return objectUtil
  },
  ZodParsedType: ZodParsedType,
  getParsedType: getParsedType,
  ZodType: ZodType,
  datetimeRegex: datetimeRegex,
  ZodString: ZodString,
  ZodNumber: ZodNumber,
  ZodBigInt: ZodBigInt,
  ZodBoolean: ZodBoolean,
  ZodDate: ZodDate,
  ZodSymbol: ZodSymbol,
  ZodUndefined: ZodUndefined,
  ZodNull: ZodNull,
  ZodAny: ZodAny,
  ZodUnknown: ZodUnknown,
  ZodNever: ZodNever,
  ZodVoid: ZodVoid,
  ZodArray: ZodArray,
  ZodObject: ZodObject,
  ZodUnion: ZodUnion,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion,
  ZodIntersection: ZodIntersection,
  ZodTuple: ZodTuple,
  ZodRecord: ZodRecord,
  ZodMap: ZodMap,
  ZodSet: ZodSet,
  ZodFunction: ZodFunction,
  ZodLazy: ZodLazy,
  ZodLiteral: ZodLiteral,
  ZodEnum: ZodEnum,
  ZodNativeEnum: ZodNativeEnum,
  ZodPromise: ZodPromise,
  ZodEffects: ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional: ZodOptional,
  ZodNullable: ZodNullable,
  ZodDefault: ZodDefault,
  ZodCatch: ZodCatch,
  ZodNaN: ZodNaN,
  BRAND: BRAND,
  ZodBranded: ZodBranded,
  ZodPipeline: ZodPipeline,
  ZodReadonly: ZodReadonly,
  custom: custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late: late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind
  },
  coerce: coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean: oboolean,
  onumber: onumber,
  optional: optionalType,
  ostring: ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER: NEVER,
  ZodIssueCode: ZodIssueCode,
  quotelessJson: quotelessJson,
  ZodError: ZodError
})
function isZodErrorLike(e) {
  return (
    e instanceof Error &&
    'ZodError' === e.name &&
    'issues' in e &&
    Array.isArray(e.issues)
  )
}
__name(isZodErrorLike, 'isZodErrorLike')
var ValidationError = class extends Error {
  static {
    __name(this, 'ValidationError')
  }
  name
  details
  constructor(e, t) {
    super(e, t),
      (this.name = 'ZodValidationError'),
      (this.details = getIssuesFromErrorOptions(t))
  }
  toString() {
    return this.message
  }
}
function getIssuesFromErrorOptions(e) {
  if (e) {
    const t = e.cause
    if (isZodErrorLike(t)) return t.issues
  }
  return []
}
function isValidationError(e) {
  return e instanceof ValidationError
}
function isValidationErrorLike(e) {
  return e instanceof Error && 'ZodValidationError' === e.name
}
function isNonEmptyArray(e) {
  return 0 !== e.length
}
__name(getIssuesFromErrorOptions, 'getIssuesFromErrorOptions'),
  __name(isValidationError, 'isValidationError'),
  __name(isValidationErrorLike, 'isValidationErrorLike'),
  __name(isNonEmptyArray, 'isNonEmptyArray')
var identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u
function joinPath(e) {
  return 1 === e.length
    ? e[0].toString()
    : e.reduce((e, t) => {
        if ('number' == typeof t) return e + '[' + t.toString() + ']'
        if (t.includes('"')) return e + '["' + escapeQuotes(t) + '"]'
        if (!identifierRegex.test(t)) return e + '["' + t + '"]'
        return e + (0 === e.length ? '' : '.') + t
      }, '')
}
function escapeQuotes(e) {
  return e.replace(/"/g, '\\"')
}
__name(joinPath, 'joinPath'), __name(escapeQuotes, 'escapeQuotes')
var ISSUE_SEPARATOR = '; ',
  MAX_ISSUES_IN_MESSAGE = 99,
  PREFIX = 'Validation error',
  PREFIX_SEPARATOR = ': ',
  UNION_SEPARATOR = ', or '
function createMessageBuilder(e = {}) {
  const {
    issueSeparator: t = ISSUE_SEPARATOR,
    unionSeparator: n = UNION_SEPARATOR,
    prefixSeparator: o = PREFIX_SEPARATOR,
    prefix: i = PREFIX,
    includePath: r = !0,
    maxIssuesInMessage: a = MAX_ISSUES_IN_MESSAGE
  } = e
  return (e) =>
    prefixMessage(
      e
        .slice(0, a)
        .map((e) =>
          getMessageFromZodIssue({
            issue: e,
            issueSeparator: t,
            unionSeparator: n,
            includePath: r
          })
        )
        .join(t),
      i,
      o
    )
}
function getMessageFromZodIssue(e) {
  const { issue: t, issueSeparator: n, unionSeparator: o, includePath: i } = e
  if (t.code === ZodIssueCode.invalid_union)
    return t.unionErrors
      .reduce((e, t) => {
        const r = t.issues
          .map((e) =>
            getMessageFromZodIssue({
              issue: e,
              issueSeparator: n,
              unionSeparator: o,
              includePath: i
            })
          )
          .join(n)
        return e.includes(r) || e.push(r), e
      }, [])
      .join(o)
  if (t.code === ZodIssueCode.invalid_arguments)
    return [
      t.message,
      ...t.argumentsError.issues.map((e) =>
        getMessageFromZodIssue({
          issue: e,
          issueSeparator: n,
          unionSeparator: o,
          includePath: i
        })
      )
    ].join(n)
  if (t.code === ZodIssueCode.invalid_return_type)
    return [
      t.message,
      ...t.returnTypeError.issues.map((e) =>
        getMessageFromZodIssue({
          issue: e,
          issueSeparator: n,
          unionSeparator: o,
          includePath: i
        })
      )
    ].join(n)
  if (i && isNonEmptyArray(t.path)) {
    if (1 === t.path.length) {
      const e = t.path[0]
      if ('number' == typeof e) return `${t.message} at index ${e}`
    }
    return `${t.message} at "${joinPath(t.path)}"`
  }
  return t.message
}
function prefixMessage(e, t, n) {
  return null !== t
    ? e.length > 0
      ? [t, e].join(n)
      : t
    : e.length > 0
      ? e
      : PREFIX
}
function fromZodIssue(e, t = {}) {
  const n = createMessageBuilderFromOptions(t)([e])
  return new ValidationError(n, { cause: new ZodError([e]) })
}
function createMessageBuilderFromOptions(e) {
  return 'messageBuilder' in e ? e.messageBuilder : createMessageBuilder(e)
}
__name(createMessageBuilder, 'createMessageBuilder'),
  __name(getMessageFromZodIssue, 'getMessageFromZodIssue'),
  __name(prefixMessage, 'prefixMessage'),
  __name(fromZodIssue, 'fromZodIssue'),
  __name(createMessageBuilderFromOptions, 'createMessageBuilderFromOptions')
var errorMap = __name(
  (e, t) => ({
    message: fromZodIssue({ ...e, message: e.message ?? t.defaultError })
      .message
  }),
  'errorMap'
)
function fromZodError(e, t = {}) {
  if (!isZodErrorLike(e))
    throw new TypeError(
      `Invalid zodError param; expected instance of ZodError. Did you mean to use the "${fromError.name}" method instead?`
    )
  return fromZodErrorWithoutRuntimeCheck(e, t)
}
function fromZodErrorWithoutRuntimeCheck(e, t = {}) {
  const n = e.errors
  let o
  if (isNonEmptyArray(n)) {
    o = createMessageBuilderFromOptions2(t)(n)
  } else o = e.message
  return new ValidationError(o, { cause: e })
}
function createMessageBuilderFromOptions2(e) {
  return 'messageBuilder' in e ? e.messageBuilder : createMessageBuilder(e)
}
__name(fromZodError, 'fromZodError'),
  __name(fromZodErrorWithoutRuntimeCheck, 'fromZodErrorWithoutRuntimeCheck'),
  __name(createMessageBuilderFromOptions2, 'createMessageBuilderFromOptions2')
var toValidationError = __name(
  (e = {}) =>
    (t) =>
      isZodErrorLike(t)
        ? fromZodErrorWithoutRuntimeCheck(t, e)
        : t instanceof Error
          ? new ValidationError(t.message, { cause: t })
          : new ValidationError('Unknown error'),
  'toValidationError'
)
function fromError(e, t = {}) {
  return toValidationError(t)(e)
}
__name(fromError, 'fromError')
const zNodeId = z.union([z.number().int(), z.string()]),
  zSlotIndex = z.union([
    z.number().int(),
    z
      .string()
      .transform((e) => parseInt(e))
      .refine((e) => !isNaN(e), { message: 'Invalid number' })
  ]),
  zDataType = z.union([z.string(), z.array(z.string()), z.number()]),
  zVector2 = z.union([
    z
      .object({ 0: z.number(), 1: z.number() })
      .passthrough()
      .transform((e) => [e[0], e[1]]),
    z.tuple([z.number(), z.number()])
  ]),
  zModelFile = z.object({
    name: z.string(),
    url: z.string().url(),
    hash: z.string().optional(),
    hash_type: z.string().optional(),
    directory: z.string()
  }),
  zGraphState = z
    .object({
      lastGroupid: z.number().optional(),
      lastNodeId: z.number().optional(),
      lastLinkId: z.number().optional(),
      lastRerouteId: z.number().optional()
    })
    .passthrough(),
  zComfyLink = z.tuple([
    z.number(),
    zNodeId,
    zSlotIndex,
    zNodeId,
    zSlotIndex,
    zDataType
  ]),
  zComfyLinkExtension = z
    .object({ id: z.number(), parentId: z.number() })
    .passthrough(),
  zComfyLinkObject = z
    .object({
      id: z.number(),
      origin_id: zNodeId,
      origin_slot: zSlotIndex,
      target_id: zNodeId,
      target_slot: zSlotIndex,
      type: zDataType,
      parentId: z.number().optional()
    })
    .passthrough(),
  zReroute = z
    .object({
      id: z.number(),
      parentId: z.number().optional(),
      pos: zVector2,
      linkIds: z.array(z.number()).nullish()
    })
    .passthrough(),
  zNodeOutput = z
    .object({
      name: z.string(),
      type: zDataType,
      links: z.array(z.number()).nullable().optional(),
      slot_index: zSlotIndex.optional()
    })
    .passthrough(),
  zNodeInput = z
    .object({
      name: z.string(),
      type: zDataType,
      link: z.number().nullable().optional(),
      slot_index: zSlotIndex.optional()
    })
    .passthrough(),
  zFlags = z
    .object({
      collapsed: z.boolean().optional(),
      pinned: z.boolean().optional(),
      allow_interaction: z.boolean().optional(),
      horizontal: z.boolean().optional(),
      skip_repeated_outputs: z.boolean().optional()
    })
    .passthrough(),
  zProperties = z
    .object({ 'Node name for S&R': z.string().optional() })
    .passthrough(),
  zWidgetValues = z.union([z.array(z.any()), z.record(z.any())]),
  zComfyNode = z
    .object({
      id: zNodeId,
      type: z.string(),
      pos: zVector2,
      size: zVector2,
      flags: zFlags,
      order: z.number(),
      mode: z.number(),
      inputs: z.array(zNodeInput).optional(),
      outputs: z.array(zNodeOutput).optional(),
      properties: zProperties,
      widgets_values: zWidgetValues.optional(),
      color: z.string().optional(),
      bgcolor: z.string().optional()
    })
    .passthrough(),
  zGroup = z
    .object({
      title: z.string(),
      bounding: z.tuple([z.number(), z.number(), z.number(), z.number()]),
      color: z.string().optional(),
      font_size: z.number().optional(),
      locked: z.boolean().optional()
    })
    .passthrough(),
  zInfo = z
    .object({
      name: z.string(),
      author: z.string(),
      description: z.string(),
      version: z.string(),
      created: z.string(),
      modified: z.string(),
      software: z.string()
    })
    .passthrough(),
  zDS = z.object({ scale: z.number(), offset: zVector2 }).passthrough(),
  zConfig = z
    .object({
      links_ontop: z.boolean().optional(),
      align_to_grid: z.boolean().optional()
    })
    .passthrough(),
  zExtra = z
    .object({
      ds: zDS.optional(),
      info: zInfo.optional(),
      linkExtensions: z.array(zComfyLinkExtension).optional(),
      reroutes: z.array(zReroute).optional()
    })
    .passthrough(),
  zComfyWorkflow = z
    .object({
      last_node_id: zNodeId,
      last_link_id: z.number(),
      nodes: z.array(zComfyNode),
      links: z.array(zComfyLink),
      groups: z.array(zGroup).optional(),
      config: zConfig.optional().nullable(),
      extra: zExtra.optional().nullable(),
      version: z.number(),
      models: z.array(zModelFile).optional()
    })
    .passthrough(),
  zComfyWorkflow1 = z
    .object({
      version: z.literal(1),
      config: zConfig.optional().nullable(),
      state: zGraphState,
      groups: z.array(zGroup).optional(),
      nodes: z.array(zComfyNode),
      links: z.array(zComfyLinkObject).optional(),
      reroutes: z.array(zReroute).optional(),
      extra: zExtra.optional().nullable(),
      models: z.array(zModelFile).optional()
    })
    .passthrough(),
  zWorkflowVersion = z.object({ version: z.number() })
async function validateComfyWorkflow(e, t = console.warn) {
  const n = zWorkflowVersion.safeParse(e)
  let o
  if (!n.success) {
    return (
      t(
        `Workflow does not contain a valid version.  Zod error:\n${fromZodError(n.error)}`
      ),
      null
    )
  }
  if (
    ((o =
      1 === n.data.version
        ? await zComfyWorkflow1.safeParseAsync(e)
        : await zComfyWorkflow.safeParseAsync(e)),
    o.success)
  )
    return o.data
  return (
    t(`Invalid workflow against zod schema:\n${fromZodError(o.error)}`), null
  )
}
__name(validateComfyWorkflow, 'validateComfyWorkflow')
const nodeSlotSchema = z
    .object({
      BOOLEAN: z.string().optional(),
      CLIP: z.string(),
      CLIP_VISION: z.string(),
      CLIP_VISION_OUTPUT: z.string(),
      CONDITIONING: z.string(),
      CONTROL_NET: z.string(),
      CONTROL_NET_WEIGHTS: z.string().optional(),
      FLOAT: z.string().optional(),
      GLIGEN: z.string().optional(),
      IMAGE: z.string(),
      IMAGEUPLOAD: z.string().optional(),
      INT: z.string().optional(),
      LATENT: z.string(),
      LATENT_KEYFRAME: z.string().optional(),
      MASK: z.string(),
      MODEL: z.string(),
      SAMPLER: z.string().optional(),
      SIGMAS: z.string().optional(),
      STRING: z.string().optional(),
      STYLE_MODEL: z.string(),
      T2I_ADAPTER_WEIGHTS: z.string().optional(),
      TAESD: z.string(),
      TIMESTEP_KEYFRAME: z.string().optional(),
      UPSCALE_MODEL: z.string().optional(),
      VAE: z.string()
    })
    .passthrough(),
  litegraphBaseSchema = z
    .object({
      BACKGROUND_IMAGE: z.string(),
      CLEAR_BACKGROUND_COLOR: z.string(),
      NODE_TITLE_COLOR: z.string(),
      NODE_SELECTED_TITLE_COLOR: z.string(),
      NODE_TEXT_SIZE: z.number(),
      NODE_TEXT_COLOR: z.string(),
      NODE_SUBTEXT_SIZE: z.number(),
      NODE_DEFAULT_COLOR: z.string(),
      NODE_DEFAULT_BGCOLOR: z.string(),
      NODE_DEFAULT_BOXCOLOR: z.string(),
      NODE_DEFAULT_SHAPE: z.string(),
      NODE_BOX_OUTLINE_COLOR: z.string(),
      NODE_BYPASS_BGCOLOR: z.string(),
      NODE_ERROR_COLOUR: z.string(),
      DEFAULT_SHADOW_COLOR: z.string(),
      DEFAULT_GROUP_FONT: z.number(),
      WIDGET_BGCOLOR: z.string(),
      WIDGET_OUTLINE_COLOR: z.string(),
      WIDGET_TEXT_COLOR: z.string(),
      WIDGET_SECONDARY_TEXT_COLOR: z.string(),
      LINK_COLOR: z.string(),
      EVENT_LINK_COLOR: z.string(),
      CONNECTING_LINK_COLOR: z.string(),
      BADGE_FG_COLOR: z.string().optional(),
      BADGE_BG_COLOR: z.string().optional()
    })
    .passthrough(),
  comfyBaseSchema = z.object({
    'fg-color': z.string(),
    'bg-color': z.string(),
    'bg-img': z.string().optional(),
    'comfy-menu-bg': z.string(),
    'comfy-input-bg': z.string(),
    'input-text': z.string(),
    'descrip-text': z.string(),
    'drag-text': z.string(),
    'error-text': z.string(),
    'border-color': z.string(),
    'tr-even-bg-color': z.string(),
    'tr-odd-bg-color': z.string(),
    'content-bg': z.string(),
    'content-fg': z.string(),
    'content-hover-bg': z.string(),
    'content-hover-fg': z.string()
  }),
  colorsSchema = z
    .object({
      node_slot: nodeSlotSchema,
      litegraph_base: litegraphBaseSchema,
      comfy_base: comfyBaseSchema
    })
    .passthrough(),
  paletteSchema = z.object({
    id: z.string(),
    name: z.string(),
    colors: colorsSchema
  }),
  colorPalettesSchema = z.record(paletteSchema)
var LinkReleaseTriggerMode = ((e) => (
    (e.ALWAYS = 'always'),
    (e.HOLD_SHIFT = 'hold shift'),
    (e.NOT_HOLD_SHIFT = 'NOT hold shift'),
    e
  ))(LinkReleaseTriggerMode || {}),
  LinkReleaseTriggerAction = ((e) => (
    (e.CONTEXT_MENU = 'context menu'),
    (e.SEARCH_BOX = 'search box'),
    (e.NO_ACTION = 'no action'),
    e
  ))(LinkReleaseTriggerAction || {}),
  NodeSourceType = ((e) => (
    (e.Core = 'core'),
    (e.CustomNodes = 'custom_nodes'),
    (e.Unknown = 'unknown'),
    e
  ))(NodeSourceType || {})
const UNKNOWN_NODE_SOURCE = {
    type: 'unknown',
    className: 'comfy-unknown',
    displayText: 'Unknown',
    badgeText: '?'
  },
  shortenNodeName = __name(
    (e) =>
      e
        .replace(/^(ComfyUI-|ComfyUI_|Comfy-|Comfy_)/, '')
        .replace(/(-ComfyUI|_ComfyUI|-Comfy|_Comfy)$/, ''),
    'shortenNodeName'
  ),
  getNodeSource = __name((e) => {
    if (!e) return UNKNOWN_NODE_SOURCE
    const t = e.split('.')
    if (['nodes', 'comfy_extras'].includes(t[0]))
      return {
        type: 'core',
        className: 'comfy-core',
        displayText: 'Comfy Core',
        badgeText: '🦊'
      }
    if ('custom_nodes' === t[0]) {
      const e = shortenNodeName(t[1])
      return {
        type: 'custom_nodes',
        className: 'comfy-custom-nodes',
        displayText: e,
        badgeText: e
      }
    }
    return UNKNOWN_NODE_SOURCE
  }, 'getNodeSource')
var NodeBadgeMode = ((e) => (
  (e.None = 'None'),
  (e.ShowAll = 'Show all'),
  (e.HideBuiltIn = 'Hide built-in'),
  e
))(NodeBadgeMode || {})
const zKeyCombo = z.object({
    key: z.string(),
    ctrl: z.boolean().optional(),
    alt: z.boolean().optional(),
    shift: z.boolean().optional(),
    meta: z.boolean().optional()
  }),
  zKeybinding = z.object({
    commandId: z.string(),
    combo: zKeyCombo,
    targetSelector: z.string().optional()
  }),
  zNodeType = z.string(),
  zQueueIndex = z.number(),
  zPromptId = z.string(),
  zResultItem = z.object({
    filename: z.string().optional(),
    subfolder: z.string().optional(),
    type: z.string().optional()
  }),
  zOutputs = z
    .object({
      audio: z.array(zResultItem).optional(),
      images: z.array(zResultItem).optional()
    })
    .passthrough(),
  zStatusWsMessageStatus = z.object({
    exec_info: z.object({ queue_remaining: z.number().int() })
  }),
  zStatusWsMessage = z.object({
    status: zStatusWsMessageStatus.nullish(),
    sid: z.string().nullish()
  }),
  zProgressWsMessage = z.object({
    value: z.number().int(),
    max: z.number().int(),
    prompt_id: zPromptId,
    node: zNodeId
  }),
  zExecutingWsMessage = z.object({
    node: zNodeId,
    display_node: zNodeId,
    prompt_id: zPromptId
  }),
  zExecutedWsMessage = zExecutingWsMessage.extend({
    output: zOutputs,
    merge: z.boolean().optional()
  }),
  zExecutionWsMessageBase = z.object({
    prompt_id: zPromptId,
    timestamp: z.number().int()
  }),
  zExecutionStartWsMessage = zExecutionWsMessageBase,
  zExecutionSuccessWsMessage = zExecutionWsMessageBase,
  zExecutionCachedWsMessage = zExecutionWsMessageBase.extend({
    nodes: z.array(zNodeId)
  }),
  zExecutionInterruptedWsMessage = zExecutionWsMessageBase.extend({
    node_id: zNodeId,
    node_type: zNodeType,
    executed: z.array(zNodeId)
  }),
  zExecutionErrorWsMessage = zExecutionWsMessageBase.extend({
    node_id: zNodeId,
    node_type: zNodeType,
    executed: z.array(zNodeId),
    exception_message: z.string(),
    exception_type: z.string(),
    traceback: z.array(z.string()),
    current_inputs: z.any(),
    current_outputs: z.any()
  }),
  zTerminalSize = z.object({ cols: z.number(), row: z.number() }),
  zLogEntry = z.object({ t: z.string(), m: z.string() }),
  zLogsWsMessage = z.object({
    size: zTerminalSize.optional(),
    entries: z.array(zLogEntry)
  }),
  zLogRawResponse = z.object({
    size: zTerminalSize,
    entries: z.array(zLogEntry)
  }),
  zPromptInputItem = z.object({
    inputs: z.record(z.string(), z.any()),
    class_type: zNodeType
  }),
  zPromptInputs = z.record(zPromptInputItem),
  zExtraPngInfo = z.object({ workflow: zComfyWorkflow }).passthrough(),
  zExtraData = z.object({
    extra_pnginfo: zExtraPngInfo.optional(),
    client_id: z.string()
  }),
  zOutputsToExecute = z.array(zNodeId),
  zExecutionStartMessage = z.tuple([
    z.literal('execution_start'),
    zExecutionStartWsMessage
  ]),
  zExecutionSuccessMessage = z.tuple([
    z.literal('execution_success'),
    zExecutionSuccessWsMessage
  ]),
  zExecutionCachedMessage = z.tuple([
    z.literal('execution_cached'),
    zExecutionCachedWsMessage
  ]),
  zExecutionInterruptedMessage = z.tuple([
    z.literal('execution_interrupted'),
    zExecutionInterruptedWsMessage
  ]),
  zExecutionErrorMessage = z.tuple([
    z.literal('execution_error'),
    zExecutionErrorWsMessage
  ]),
  zStatusMessage = z.union([
    zExecutionStartMessage,
    zExecutionSuccessMessage,
    zExecutionCachedMessage,
    zExecutionInterruptedMessage,
    zExecutionErrorMessage
  ]),
  zStatus = z.object({
    status_str: z.enum(['success', 'error']),
    completed: z.boolean(),
    messages: z.array(zStatusMessage)
  }),
  zTaskPrompt = z.tuple([
    zQueueIndex,
    zPromptId,
    zPromptInputs,
    zExtraData,
    zOutputsToExecute
  ]),
  zRunningTaskItem = z.object({
    taskType: z.literal('Running'),
    prompt: zTaskPrompt,
    remove: z.object({ name: z.literal('Cancel'), cb: z.function() })
  }),
  zPendingTaskItem = z.object({
    taskType: z.literal('Pending'),
    prompt: zTaskPrompt
  }),
  zTaskOutput = z.record(zNodeId, zOutputs),
  zHistoryTaskItem = z.object({
    taskType: z.literal('History'),
    prompt: zTaskPrompt,
    status: zStatus.optional(),
    outputs: zTaskOutput
  }),
  zTaskItem = z.union([zRunningTaskItem, zPendingTaskItem, zHistoryTaskItem]),
  zTaskType = z.union([
    z.literal('Running'),
    z.literal('Pending'),
    z.literal('History')
  ])
function validateTaskItem(e) {
  const t = zTaskItem.safeParse(e)
  if (!t.success) {
    const n = fromZodError(t.error)
    console.warn(`Invalid TaskItem: ${JSON.stringify(e)}\n${n.message}`)
  }
  return t
}
function inputSpec(e, t = !0) {
  const [n, o] = e,
    i = t ? [n.transform((e) => [e, {}])] : []
  return z.union([
    z.tuple([n, o]),
    z.tuple([n]).transform(([e]) => [e, {}]),
    ...i
  ])
}
__name(validateTaskItem, 'validateTaskItem'), __name(inputSpec, 'inputSpec')
const zBaseInputSpecValue = z
    .object({
      default: z.any().optional(),
      defaultInput: z.boolean().optional(),
      forceInput: z.boolean().optional(),
      lazy: z.boolean().optional(),
      rawLink: z.boolean().optional(),
      tooltip: z.string().optional(),
      hidden: z.boolean().optional(),
      advanced: z.boolean().optional()
    })
    .passthrough(),
  zIntInputSpec = inputSpec([
    z.literal('INT'),
    zBaseInputSpecValue.extend({
      min: z.number().optional(),
      max: z.number().optional(),
      step: z.number().optional(),
      default: z.union([z.number(), z.array(z.number())]).optional()
    })
  ]),
  zFloatInputSpec = inputSpec([
    z.literal('FLOAT'),
    zBaseInputSpecValue.extend({
      min: z.number().optional(),
      max: z.number().optional(),
      step: z.number().optional(),
      round: z.union([z.number(), z.literal(!1)]).optional(),
      default: z.union([z.number(), z.array(z.number())]).optional()
    })
  ]),
  zBooleanInputSpec = inputSpec([
    z.literal('BOOLEAN'),
    zBaseInputSpecValue.extend({
      label_on: z.string().optional(),
      label_off: z.string().optional(),
      default: z.boolean().optional()
    })
  ]),
  zStringInputSpec = inputSpec([
    z.literal('STRING'),
    zBaseInputSpecValue.extend({
      default: z.string().optional(),
      multiline: z.boolean().optional(),
      dynamicPrompts: z.boolean().optional(),
      defaultVal: z.string().optional(),
      placeholder: z.string().optional()
    })
  ]),
  zComboInputSpec = inputSpec(
    [
      z.array(z.any()),
      zBaseInputSpecValue.extend({
        control_after_generate: z.boolean().optional(),
        image_upload: z.boolean().optional()
      })
    ],
    !1
  ),
  excludedLiterals = new Set(['INT', 'FLOAT', 'BOOLEAN', 'STRING', 'COMBO']),
  zCustomInputSpec = inputSpec([
    z.string().refine((e) => !excludedLiterals.has(e)),
    zBaseInputSpecValue
  ]),
  zInputSpec = z.union([
    zIntInputSpec,
    zFloatInputSpec,
    zBooleanInputSpec,
    zStringInputSpec,
    zComboInputSpec,
    zCustomInputSpec
  ]),
  zComfyInputsSpec = z.object({
    required: z.record(zInputSpec).optional(),
    optional: z.record(zInputSpec).optional(),
    hidden: z.record(z.any()).optional()
  }),
  zComfyNodeDataType = z.string(),
  zComfyComboOutput = z.array(z.any()),
  zComfyOutputTypesSpec = z.array(
    z.union([zComfyNodeDataType, zComfyComboOutput])
  ),
  zComfyNodeDef = z.object({
    input: zComfyInputsSpec.optional(),
    output: zComfyOutputTypesSpec.optional(),
    output_is_list: z.array(z.boolean()).optional(),
    output_name: z.array(z.string()).optional(),
    output_tooltips: z.array(z.string()).optional(),
    name: z.string(),
    display_name: z.string(),
    description: z.string(),
    category: z.string(),
    output_node: z.boolean(),
    python_module: z.string(),
    deprecated: z.boolean().optional(),
    experimental: z.boolean().optional()
  })
function validateComfyNodeDef(e, t = console.warn) {
  const n = zComfyNodeDef.safeParse(e)
  if (!n.success) {
    const o = fromZodError(n.error)
    return t(`Invalid ComfyNodeDef: ${JSON.stringify(e)}\n${o.message}`), null
  }
  return n.data
}
__name(validateComfyNodeDef, 'validateComfyNodeDef')
const zEmbeddingsResponse = z.array(z.string()),
  zExtensionsResponse = z.array(z.string()),
  zPromptResponse = z.object({
    node_errors: z.array(z.string()).optional(),
    prompt_id: z.string().optional(),
    exec_info: z.object({ queue_remaining: z.number().optional() }).optional()
  }),
  zDeviceStats = z.object({
    name: z.string(),
    type: z.string(),
    index: z.number(),
    vram_total: z.number(),
    vram_free: z.number(),
    torch_vram_total: z.number(),
    torch_vram_free: z.number()
  }),
  zSystemStats = z.object({
    system: z.object({
      os: z.string(),
      python_version: z.string(),
      embedded_python: z.boolean(),
      comfyui_version: z.string(),
      pytorch_version: z.string(),
      argv: z.array(z.string()),
      ram_total: z.number(),
      ram_free: z.number()
    }),
    devices: z.array(zDeviceStats)
  }),
  zUser = z.object({
    storage: z.enum(['server']),
    migrated: z.boolean().optional(),
    users: z.record(z.string(), z.string()).optional()
  }),
  zUserData = z.array(z.array(z.string(), z.string())),
  zUserDataFullInfo = z.object({
    path: z.string(),
    size: z.number(),
    modified: z.number()
  }),
  zBookmarkCustomization = z.object({
    icon: z.string().optional(),
    color: z.string().optional()
  }),
  zLinkReleaseTriggerAction = z.enum(Object.values(LinkReleaseTriggerAction)),
  zNodeBadgeMode = z.enum(Object.values(NodeBadgeMode)),
  zSettings = z
    .record(z.any())
    .and(
      z
        .object({
          'Comfy.ColorPalette': z.string(),
          'Comfy.CustomColorPalettes': colorPalettesSchema,
          'Comfy.ConfirmClear': z.boolean(),
          'Comfy.DevMode': z.boolean(),
          'Comfy.Workflow.ShowMissingNodesWarning': z.boolean(),
          'Comfy.Workflow.ShowMissingModelsWarning': z.boolean(),
          'Comfy.DisableFloatRounding': z.boolean(),
          'Comfy.DisableSliders': z.boolean(),
          'Comfy.DOMClippingEnabled': z.boolean(),
          'Comfy.EditAttention.Delta': z.number(),
          'Comfy.EnableTooltips': z.boolean(),
          'Comfy.EnableWorkflowViewRestore': z.boolean(),
          'Comfy.FloatRoundingPrecision': z.number(),
          'Comfy.Graph.CanvasInfo': z.boolean(),
          'Comfy.Graph.ZoomSpeed': z.number(),
          'Comfy.Group.DoubleClickTitleToEdit': z.boolean(),
          'Comfy.GroupSelectedNodes.Padding': z.number(),
          'Comfy.InvertMenuScrolling': z.boolean(),
          'Comfy.Locale': z.string(),
          'Comfy.Logging.Enabled': z.boolean(),
          'Comfy.NodeLibrary.Bookmarks': z.array(z.string()),
          'Comfy.NodeLibrary.Bookmarks.V2': z.array(z.string()),
          'Comfy.NodeLibrary.BookmarksCustomization': z.record(
            z.string(),
            zBookmarkCustomization
          ),
          'Comfy.NodeInputConversionSubmenus': z.boolean(),
          'Comfy.LinkRelease.Action': zLinkReleaseTriggerAction,
          'Comfy.LinkRelease.ActionShift': zLinkReleaseTriggerAction,
          'Comfy.NodeSearchBoxImpl.NodePreview': z.boolean(),
          'Comfy.NodeSearchBoxImpl': z.enum(['default', 'simple']),
          'Comfy.NodeSearchBoxImpl.ShowCategory': z.boolean(),
          'Comfy.NodeSearchBoxImpl.ShowIdName': z.boolean(),
          'Comfy.NodeSuggestions.number': z.number(),
          'Comfy.Node.ShowDeprecated': z.boolean(),
          'Comfy.Node.ShowExperimental': z.boolean(),
          'Comfy.PreviewFormat': z.string(),
          'Comfy.PromptFilename': z.boolean(),
          'Comfy.Sidebar.Location': z.enum(['left', 'right']),
          'Comfy.Sidebar.Size': z.enum(['small', 'normal']),
          'Comfy.SwitchUser': z.any(),
          'Comfy.SnapToGrid.GridSize': z.number(),
          'Comfy.TextareaWidget.FontSize': z.number(),
          'Comfy.TextareaWidget.Spellcheck': z.boolean(),
          'Comfy.UseNewMenu': z.enum(['Disabled', 'Top', 'Bottom']),
          'Comfy.TreeExplorer.ItemPadding': z.number(),
          'Comfy.Validation.Workflows': z.boolean(),
          'Comfy.Workflow.SortNodeIdOnSave': z.boolean(),
          'Comfy.Queue.ImageFit': z.enum(['contain', 'cover']),
          'Comfy.Workflow.WorkflowTabsPosition': z.enum(['Sidebar', 'Topbar']),
          'Comfy.Node.DoubleClickTitleToEdit': z.boolean(),
          'Comfy.Window.UnloadConfirmation': z.boolean(),
          'Comfy.NodeBadge.NodeSourceBadgeMode': zNodeBadgeMode,
          'Comfy.NodeBadge.NodeIdBadgeMode': zNodeBadgeMode,
          'Comfy.NodeBadge.NodeLifeCycleBadgeMode': zNodeBadgeMode,
          'Comfy.QueueButton.BatchCountLimit': z.number(),
          'Comfy.Keybinding.UnsetBindings': z.array(zKeybinding),
          'Comfy.Keybinding.NewBindings': z.array(zKeybinding),
          'Comfy.Extension.Disabled': z.array(z.string()),
          'Comfy.Settings.ExtensionPanel': z.boolean(),
          'Comfy.LinkRenderMode': z.number(),
          'Comfy.Node.AutoSnapLinkToSlot': z.boolean(),
          'Comfy.Node.SnapHighlightsNode': z.boolean(),
          'Comfy.Server.ServerConfigValues': z.record(z.string(), z.any()),
          'Comfy.Server.LaunchArgs': z.record(z.string(), z.string()),
          'LiteGraph.Canvas.MaximumFps': z.number(),
          'Comfy.Workflow.ConfirmDelete': z.boolean()
        })
        .optional()
    )
function bind$2(e, t) {
  return __name(function () {
    return e.apply(t, arguments)
  }, 'wrap')
}
__name(bind$2, 'bind$2')
const { toString: toString$2 } = Object.prototype,
  { getPrototypeOf: getPrototypeOf } = Object,
  kindOf = ((e) => (t) => {
    const n = toString$2.call(t)
    return e[n] || (e[n] = n.slice(8, -1).toLowerCase())
  })(Object.create(null)),
  kindOfTest = __name(
    (e) => ((e = e.toLowerCase()), (t) => kindOf(t) === e),
    'kindOfTest'
  ),
  typeOfTest = __name((e) => (t) => typeof t === e, 'typeOfTest'),
  { isArray: isArray$2 } = Array,
  isUndefined = typeOfTest('undefined')
function isBuffer(e) {
  return (
    null !== e &&
    !isUndefined(e) &&
    null !== e.constructor &&
    !isUndefined(e.constructor) &&
    isFunction$2(e.constructor.isBuffer) &&
    e.constructor.isBuffer(e)
  )
}
__name(isBuffer, 'isBuffer')
const isArrayBuffer = kindOfTest('ArrayBuffer')
function isArrayBufferView(e) {
  let t
  return (
    (t =
      'undefined' != typeof ArrayBuffer && ArrayBuffer.isView
        ? ArrayBuffer.isView(e)
        : e && e.buffer && isArrayBuffer(e.buffer)),
    t
  )
}
__name(isArrayBufferView, 'isArrayBufferView')
const isString$2 = typeOfTest('string'),
  isFunction$2 = typeOfTest('function'),
  isNumber$2 = typeOfTest('number'),
  isObject$3 = __name((e) => null !== e && 'object' == typeof e, 'isObject$3'),
  isBoolean$1 = __name((e) => !0 === e || !1 === e, 'isBoolean$1'),
  isPlainObject = __name((e) => {
    if ('object' !== kindOf(e)) return !1
    const t = getPrototypeOf(e)
    return !(
      (null !== t &&
        t !== Object.prototype &&
        null !== Object.getPrototypeOf(t)) ||
      Symbol.toStringTag in e ||
      Symbol.iterator in e
    )
  }, 'isPlainObject'),
  isDate$1 = kindOfTest('Date'),
  isFile = kindOfTest('File'),
  isBlob = kindOfTest('Blob'),
  isFileList = kindOfTest('FileList'),
  isStream = __name((e) => isObject$3(e) && isFunction$2(e.pipe), 'isStream'),
  isFormData = __name((e) => {
    let t
    return (
      e &&
      (('function' == typeof FormData && e instanceof FormData) ||
        (isFunction$2(e.append) &&
          ('formdata' === (t = kindOf(e)) ||
            ('object' === t &&
              isFunction$2(e.toString) &&
              '[object FormData]' === e.toString()))))
    )
  }, 'isFormData'),
  isURLSearchParams = kindOfTest('URLSearchParams'),
  [isReadableStream, isRequest, isResponse, isHeaders] = [
    'ReadableStream',
    'Request',
    'Response',
    'Headers'
  ].map(kindOfTest),
  trim = __name(
    (e) =>
      e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''),
    'trim'
  )
function forEach(e, t, { allOwnKeys: n = !1 } = {}) {
  if (null == e) return
  let o, i
  if (('object' != typeof e && (e = [e]), isArray$2(e)))
    for (o = 0, i = e.length; o < i; o++) t.call(null, e[o], o, e)
  else {
    const i = n ? Object.getOwnPropertyNames(e) : Object.keys(e),
      r = i.length
    let a
    for (o = 0; o < r; o++) (a = i[o]), t.call(null, e[a], a, e)
  }
}
function findKey(e, t) {
  t = t.toLowerCase()
  const n = Object.keys(e)
  let o,
    i = n.length
  for (; i-- > 0; ) if (((o = n[i]), t === o.toLowerCase())) return o
  return null
}
__name(forEach, 'forEach'), __name(findKey, 'findKey')
const _global$1 =
    'undefined' != typeof globalThis
      ? globalThis
      : 'undefined' != typeof self
        ? self
        : 'undefined' != typeof window
          ? window
          : global,
  isContextDefined = __name(
    (e) => !isUndefined(e) && e !== _global$1,
    'isContextDefined'
  )
function merge$1() {
  const { caseless: e } = (isContextDefined(this) && this) || {},
    t = {},
    n = __name((n, o) => {
      const i = (e && findKey(t, o)) || o
      isPlainObject(t[i]) && isPlainObject(n)
        ? (t[i] = merge$1(t[i], n))
        : isPlainObject(n)
          ? (t[i] = merge$1({}, n))
          : isArray$2(n)
            ? (t[i] = n.slice())
            : (t[i] = n)
    }, 'assignValue')
  for (let o = 0, i = arguments.length; o < i; o++)
    arguments[o] && forEach(arguments[o], n)
  return t
}
__name(merge$1, 'merge$1')
const extend = __name(
    (e, t, n, { allOwnKeys: o } = {}) => (
      forEach(
        t,
        (t, o) => {
          n && isFunction$2(t) ? (e[o] = bind$2(t, n)) : (e[o] = t)
        },
        { allOwnKeys: o }
      ),
      e
    ),
    'extend'
  ),
  stripBOM = __name(
    (e) => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e),
    'stripBOM'
  ),
  inherits = __name((e, t, n, o) => {
    ;(e.prototype = Object.create(t.prototype, o)),
      (e.prototype.constructor = e),
      Object.defineProperty(e, 'super', { value: t.prototype }),
      n && Object.assign(e.prototype, n)
  }, 'inherits'),
  toFlatObject = __name((e, t, n, o) => {
    let i, r, a
    const s = {}
    if (((t = t || {}), null == e)) return t
    do {
      for (i = Object.getOwnPropertyNames(e), r = i.length; r-- > 0; )
        (a = i[r]), (o && !o(a, e, t)) || s[a] || ((t[a] = e[a]), (s[a] = !0))
      e = !1 !== n && getPrototypeOf(e)
    } while (e && (!n || n(e, t)) && e !== Object.prototype)
    return t
  }, 'toFlatObject'),
  endsWith = __name((e, t, n) => {
    ;(e = String(e)),
      (void 0 === n || n > e.length) && (n = e.length),
      (n -= t.length)
    const o = e.indexOf(t, n)
    return -1 !== o && o === n
  }, 'endsWith'),
  toArray = __name((e) => {
    if (!e) return null
    if (isArray$2(e)) return e
    let t = e.length
    if (!isNumber$2(t)) return null
    const n = new Array(t)
    for (; t-- > 0; ) n[t] = e[t]
    return n
  }, 'toArray'),
  isTypedArray = (
    (e) => (t) =>
      e && t instanceof e
  )('undefined' != typeof Uint8Array && getPrototypeOf(Uint8Array)),
  forEachEntry = __name((e, t) => {
    const n = (e && e[Symbol.iterator]).call(e)
    let o
    for (; (o = n.next()) && !o.done; ) {
      const n = o.value
      t.call(e, n[0], n[1])
    }
  }, 'forEachEntry'),
  matchAll = __name((e, t) => {
    let n
    const o = []
    for (; null !== (n = e.exec(t)); ) o.push(n)
    return o
  }, 'matchAll'),
  isHTMLForm = kindOfTest('HTMLFormElement'),
  toCamelCase = __name(
    (e) =>
      e.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        __name(function (e, t, n) {
          return t.toUpperCase() + n
        }, 'replacer')
      ),
    'toCamelCase'
  ),
  hasOwnProperty = (
    ({ hasOwnProperty: e }) =>
    (t, n) =>
      e.call(t, n)
  )(Object.prototype),
  isRegExp = kindOfTest('RegExp'),
  reduceDescriptors = __name((e, t) => {
    const n = Object.getOwnPropertyDescriptors(e),
      o = {}
    forEach(n, (n, i) => {
      let r
      !1 !== (r = t(n, i, e)) && (o[i] = r || n)
    }),
      Object.defineProperties(e, o)
  }, 'reduceDescriptors'),
  freezeMethods = __name((e) => {
    reduceDescriptors(e, (t, n) => {
      if (
        isFunction$2(e) &&
        -1 !== ['arguments', 'caller', 'callee'].indexOf(n)
      )
        return !1
      const o = e[n]
      isFunction$2(o) &&
        ((t.enumerable = !1),
        'writable' in t
          ? (t.writable = !1)
          : t.set ||
            (t.set = () => {
              throw Error("Can not rewrite read-only method '" + n + "'")
            }))
    })
  }, 'freezeMethods'),
  toObjectSet = __name((e, t) => {
    const n = {},
      o = __name((e) => {
        e.forEach((e) => {
          n[e] = !0
        })
      }, 'define')
    return isArray$2(e) ? o(e) : o(String(e).split(t)), n
  }, 'toObjectSet'),
  noop$1 = __name(() => {}, 'noop$1'),
  toFiniteNumber = __name(
    (e, t) => (null != e && Number.isFinite((e = +e)) ? e : t),
    'toFiniteNumber'
  ),
  ALPHA = 'abcdefghijklmnopqrstuvwxyz',
  DIGIT = '0123456789',
  ALPHABET = {
    DIGIT: DIGIT,
    ALPHA: ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  },
  generateString = __name((e = 16, t = ALPHABET.ALPHA_DIGIT) => {
    let n = ''
    const { length: o } = t
    for (; e--; ) n += t[(Math.random() * o) | 0]
    return n
  }, 'generateString')
function isSpecCompliantForm(e) {
  return !!(
    e &&
    isFunction$2(e.append) &&
    'FormData' === e[Symbol.toStringTag] &&
    e[Symbol.iterator]
  )
}
__name(isSpecCompliantForm, 'isSpecCompliantForm')
const toJSONObject = __name((e) => {
    const t = new Array(10),
      n = __name((e, o) => {
        if (isObject$3(e)) {
          if (t.indexOf(e) >= 0) return
          if (!('toJSON' in e)) {
            t[o] = e
            const i = isArray$2(e) ? [] : {}
            return (
              forEach(e, (e, t) => {
                const r = n(e, o + 1)
                !isUndefined(r) && (i[t] = r)
              }),
              (t[o] = void 0),
              i
            )
          }
        }
        return e
      }, 'visit')
    return n(e, 0)
  }, 'toJSONObject'),
  isAsyncFn = kindOfTest('AsyncFunction'),
  isThenable = __name(
    (e) =>
      e &&
      (isObject$3(e) || isFunction$2(e)) &&
      isFunction$2(e.then) &&
      isFunction$2(e.catch),
    'isThenable'
  ),
  _setImmediate =
    ((setImmediateSupported = 'function' == typeof setImmediate),
    (postMessageSupported = isFunction$2(_global$1.postMessage)),
    setImmediateSupported
      ? setImmediate
      : postMessageSupported
        ? ((token = `axios@${Math.random()}`),
          (callbacks = []),
          _global$1.addEventListener(
            'message',
            ({ source: e, data: t }) => {
              e === _global$1 &&
                t === token &&
                callbacks.length &&
                callbacks.shift()()
            },
            !1
          ),
          (e) => {
            callbacks.push(e), _global$1.postMessage(token, '*')
          })
        : (e) => setTimeout(e))
var setImmediateSupported, postMessageSupported, token, callbacks
const asap =
    'undefined' != typeof queueMicrotask
      ? queueMicrotask.bind(_global$1)
      : ('undefined' != typeof process && process.nextTick) || _setImmediate,
  utils$1 = {
    isArray: isArray$2,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString$2,
    isNumber: isNumber$2,
    isBoolean: isBoolean$1,
    isObject: isObject$3,
    isPlainObject: isPlainObject,
    isReadableStream: isReadableStream,
    isRequest: isRequest,
    isResponse: isResponse,
    isHeaders: isHeaders,
    isUndefined: isUndefined,
    isDate: isDate$1,
    isFile: isFile,
    isBlob: isBlob,
    isRegExp: isRegExp,
    isFunction: isFunction$2,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isTypedArray: isTypedArray,
    isFileList: isFileList,
    forEach: forEach,
    merge: merge$1,
    extend: extend,
    trim: trim,
    stripBOM: stripBOM,
    inherits: inherits,
    toFlatObject: toFlatObject,
    kindOf: kindOf,
    kindOfTest: kindOfTest,
    endsWith: endsWith,
    toArray: toArray,
    forEachEntry: forEachEntry,
    matchAll: matchAll,
    isHTMLForm: isHTMLForm,
    hasOwnProperty: hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors: reduceDescriptors,
    freezeMethods: freezeMethods,
    toObjectSet: toObjectSet,
    toCamelCase: toCamelCase,
    noop: noop$1,
    toFiniteNumber: toFiniteNumber,
    findKey: findKey,
    global: _global$1,
    isContextDefined: isContextDefined,
    ALPHABET: ALPHABET,
    generateString: generateString,
    isSpecCompliantForm: isSpecCompliantForm,
    toJSONObject: toJSONObject,
    isAsyncFn: isAsyncFn,
    isThenable: isThenable,
    setImmediate: _setImmediate,
    asap: asap
  }
function AxiosError$1(e, t, n, o, i) {
  Error.call(this),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack),
    (this.message = e),
    (this.name = 'AxiosError'),
    t && (this.code = t),
    n && (this.config = n),
    o && (this.request = o),
    i && ((this.response = i), (this.status = i.status ? i.status : null))
}
__name(AxiosError$1, 'AxiosError$1'),
  utils$1.inherits(AxiosError$1, Error, {
    toJSON: __name(function () {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.status
      }
    }, 'toJSON')
  })
const prototype$1 = AxiosError$1.prototype,
  descriptors = {}
;[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
].forEach((e) => {
  descriptors[e] = { value: e }
}),
  Object.defineProperties(AxiosError$1, descriptors),
  Object.defineProperty(prototype$1, 'isAxiosError', { value: !0 }),
  (AxiosError$1.from = (e, t, n, o, i, r) => {
    const a = Object.create(prototype$1)
    return (
      utils$1.toFlatObject(
        e,
        a,
        __name(function (e) {
          return e !== Error.prototype
        }, 'filter'),
        (e) => 'isAxiosError' !== e
      ),
      AxiosError$1.call(a, e.message, t, n, o, i),
      (a.cause = e),
      (a.name = e.name),
      r && Object.assign(a, r),
      a
    )
  })
const httpAdapter = null
function isVisitable(e) {
  return utils$1.isPlainObject(e) || utils$1.isArray(e)
}
function removeBrackets(e) {
  return utils$1.endsWith(e, '[]') ? e.slice(0, -2) : e
}
function renderKey(e, t, n) {
  return e
    ? e
        .concat(t)
        .map(
          __name(function (e, t) {
            return (e = removeBrackets(e)), !n && t ? '[' + e + ']' : e
          }, 'each')
        )
        .join(n ? '.' : '')
    : t
}
function isFlatArray(e) {
  return utils$1.isArray(e) && !e.some(isVisitable)
}
__name(isVisitable, 'isVisitable'),
  __name(removeBrackets, 'removeBrackets'),
  __name(renderKey, 'renderKey'),
  __name(isFlatArray, 'isFlatArray')
const predicates = utils$1.toFlatObject(
  utils$1,
  {},
  null,
  __name(function (e) {
    return /^is[A-Z]/.test(e)
  }, 'filter')
)
function toFormData$1(e, t, n) {
  if (!utils$1.isObject(e)) throw new TypeError('target must be an object')
  t = t || new (httpAdapter || FormData)()
  const o = (n = utils$1.toFlatObject(
      n,
      { metaTokens: !0, dots: !1, indexes: !1 },
      !1,
      __name(function (e, t) {
        return !utils$1.isUndefined(t[e])
      }, 'defined')
    )).metaTokens,
    i = n.visitor || c,
    r = n.dots,
    a = n.indexes,
    s =
      (n.Blob || ('undefined' != typeof Blob && Blob)) &&
      utils$1.isSpecCompliantForm(t)
  if (!utils$1.isFunction(i)) throw new TypeError('visitor must be a function')
  function l(e) {
    if (null === e) return ''
    if (utils$1.isDate(e)) return e.toISOString()
    if (!s && utils$1.isBlob(e))
      throw new AxiosError$1('Blob is not supported. Use a Buffer instead.')
    return utils$1.isArrayBuffer(e) || utils$1.isTypedArray(e)
      ? s && 'function' == typeof Blob
        ? new Blob([e])
        : Buffer.from(e)
      : e
  }
  function c(e, n, i) {
    let s = e
    if (e && !i && 'object' == typeof e)
      if (utils$1.endsWith(n, '{}'))
        (n = o ? n : n.slice(0, -2)), (e = JSON.stringify(e))
      else if (
        (utils$1.isArray(e) && isFlatArray(e)) ||
        ((utils$1.isFileList(e) || utils$1.endsWith(n, '[]')) &&
          (s = utils$1.toArray(e)))
      )
        return (
          (n = removeBrackets(n)),
          s.forEach(
            __name(function (e, o) {
              !utils$1.isUndefined(e) &&
                null !== e &&
                t.append(
                  !0 === a ? renderKey([n], o, r) : null === a ? n : n + '[]',
                  l(e)
                )
            }, 'each')
          ),
          !1
        )
    return !!isVisitable(e) || (t.append(renderKey(i, n, r), l(e)), !1)
  }
  __name(l, 'convertValue'), __name(c, 'defaultVisitor')
  const d = [],
    u = Object.assign(predicates, {
      defaultVisitor: c,
      convertValue: l,
      isVisitable: isVisitable
    })
  function p(e, n) {
    if (!utils$1.isUndefined(e)) {
      if (-1 !== d.indexOf(e))
        throw Error('Circular reference detected in ' + n.join('.'))
      d.push(e),
        utils$1.forEach(
          e,
          __name(function (e, o) {
            !0 ===
              (!(utils$1.isUndefined(e) || null === e) &&
                i.call(t, e, utils$1.isString(o) ? o.trim() : o, n, u)) &&
              p(e, n ? n.concat(o) : [o])
          }, 'each')
        ),
        d.pop()
    }
  }
  if ((__name(p, 'build'), !utils$1.isObject(e)))
    throw new TypeError('data must be an object')
  return p(e), t
}
function encode$1(e) {
  const t = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\0'
  }
  return encodeURIComponent(e).replace(
    /[!'()~]|%20|%00/g,
    __name(function (e) {
      return t[e]
    }, 'replacer')
  )
}
function AxiosURLSearchParams(e, t) {
  ;(this._pairs = []), e && toFormData$1(e, this, t)
}
__name(toFormData$1, 'toFormData$1'),
  __name(encode$1, 'encode$1'),
  __name(AxiosURLSearchParams, 'AxiosURLSearchParams')
const prototype = AxiosURLSearchParams.prototype
function encode(e) {
  return encodeURIComponent(e)
    .replace(/%3A/gi, ':')
    .replace(/%24/g, '$')
    .replace(/%2C/gi, ',')
    .replace(/%20/g, '+')
    .replace(/%5B/gi, '[')
    .replace(/%5D/gi, ']')
}
function buildURL(e, t, n) {
  if (!t) return e
  const o = (n && n.encode) || encode
  utils$1.isFunction(n) && (n = { serialize: n })
  const i = n && n.serialize
  let r
  if (
    ((r = i
      ? i(t, n)
      : utils$1.isURLSearchParams(t)
        ? t.toString()
        : new AxiosURLSearchParams(t, n).toString(o)),
    r)
  ) {
    const t = e.indexOf('#')
    ;-1 !== t && (e = e.slice(0, t)),
      (e += (-1 === e.indexOf('?') ? '?' : '&') + r)
  }
  return e
}
;(prototype.append = __name(function (e, t) {
  this._pairs.push([e, t])
}, 'append')),
  (prototype.toString = __name(function (e) {
    const t = e
      ? function (t) {
          return e.call(this, t, encode$1)
        }
      : encode$1
    return this._pairs
      .map(
        __name(function (e) {
          return t(e[0]) + '=' + t(e[1])
        }, 'each'),
        ''
      )
      .join('&')
  }, 'toString')),
  __name(encode, 'encode'),
  __name(buildURL, 'buildURL')
class InterceptorManager {
  static {
    __name(this, 'InterceptorManager')
  }
  constructor() {
    this.handlers = []
  }
  use(e, t, n) {
    return (
      this.handlers.push({
        fulfilled: e,
        rejected: t,
        synchronous: !!n && n.synchronous,
        runWhen: n ? n.runWhen : null
      }),
      this.handlers.length - 1
    )
  }
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null)
  }
  clear() {
    this.handlers && (this.handlers = [])
  }
  forEach(e) {
    utils$1.forEach(
      this.handlers,
      __name(function (t) {
        null !== t && e(t)
      }, 'forEachHandler')
    )
  }
}
const transitionalDefaults = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  },
  URLSearchParams$1 =
    'undefined' != typeof URLSearchParams
      ? URLSearchParams
      : AxiosURLSearchParams,
  FormData$1 = 'undefined' != typeof FormData ? FormData : null,
  Blob$1 = 'undefined' != typeof Blob ? Blob : null,
  platform$1 = {
    isBrowser: !0,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
  },
  hasBrowserEnv =
    'undefined' != typeof window && 'undefined' != typeof document,
  _navigator = ('object' == typeof navigator && navigator) || void 0,
  hasStandardBrowserEnv =
    hasBrowserEnv &&
    (!_navigator ||
      ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0),
  hasStandardBrowserWebWorkerEnv =
    'undefined' != typeof WorkerGlobalScope &&
    self instanceof WorkerGlobalScope &&
    'function' == typeof self.importScripts,
  origin = (hasBrowserEnv && window.location.href) || 'http://localhost',
  utils = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        hasBrowserEnv: hasBrowserEnv,
        hasStandardBrowserEnv: hasStandardBrowserEnv,
        hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
        navigator: _navigator,
        origin: origin
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  platform = { ...utils, ...platform$1 }
function toURLEncodedForm(e, t) {
  return toFormData$1(
    e,
    new platform.classes.URLSearchParams(),
    Object.assign(
      {
        visitor: __name(function (e, t, n, o) {
          return platform.isNode && utils$1.isBuffer(e)
            ? (this.append(t, e.toString('base64')), !1)
            : o.defaultVisitor.apply(this, arguments)
        }, 'visitor')
      },
      t
    )
  )
}
function parsePropPath(e) {
  return utils$1
    .matchAll(/\w+|\[(\w*)]/g, e)
    .map((e) => ('[]' === e[0] ? '' : e[1] || e[0]))
}
function arrayToObject(e) {
  const t = {},
    n = Object.keys(e)
  let o
  const i = n.length
  let r
  for (o = 0; o < i; o++) (r = n[o]), (t[r] = e[r])
  return t
}
function formDataToJSON(e) {
  function t(e, n, o, i) {
    let r = e[i++]
    if ('__proto__' === r) return !0
    const a = Number.isFinite(+r),
      s = i >= e.length
    if (((r = !r && utils$1.isArray(o) ? o.length : r), s))
      return utils$1.hasOwnProp(o, r) ? (o[r] = [o[r], n]) : (o[r] = n), !a
    ;(o[r] && utils$1.isObject(o[r])) || (o[r] = [])
    return (
      t(e, n, o[r], i) && utils$1.isArray(o[r]) && (o[r] = arrayToObject(o[r])),
      !a
    )
  }
  if (
    (__name(t, 'buildPath'),
    utils$1.isFormData(e) && utils$1.isFunction(e.entries))
  ) {
    const n = {}
    return (
      utils$1.forEachEntry(e, (e, o) => {
        t(parsePropPath(e), o, n, 0)
      }),
      n
    )
  }
  return null
}
function stringifySafely(e, t, n) {
  if (utils$1.isString(e))
    try {
      return (t || JSON.parse)(e), utils$1.trim(e)
    } catch (e2) {
      if ('SyntaxError' !== e2.name) throw e2
    }
  return (n || JSON.stringify)(e)
}
__name(toURLEncodedForm, 'toURLEncodedForm'),
  __name(parsePropPath, 'parsePropPath'),
  __name(arrayToObject, 'arrayToObject'),
  __name(formDataToJSON, 'formDataToJSON'),
  __name(stringifySafely, 'stringifySafely')
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ['xhr', 'http', 'fetch'],
  transformRequest: [
    __name(function (e, t) {
      const n = t.getContentType() || '',
        o = n.indexOf('application/json') > -1,
        i = utils$1.isObject(e)
      i && utils$1.isHTMLForm(e) && (e = new FormData(e))
      if (utils$1.isFormData(e))
        return o ? JSON.stringify(formDataToJSON(e)) : e
      if (
        utils$1.isArrayBuffer(e) ||
        utils$1.isBuffer(e) ||
        utils$1.isStream(e) ||
        utils$1.isFile(e) ||
        utils$1.isBlob(e) ||
        utils$1.isReadableStream(e)
      )
        return e
      if (utils$1.isArrayBufferView(e)) return e.buffer
      if (utils$1.isURLSearchParams(e))
        return (
          t.setContentType(
            'application/x-www-form-urlencoded;charset=utf-8',
            !1
          ),
          e.toString()
        )
      let r
      if (i) {
        if (n.indexOf('application/x-www-form-urlencoded') > -1)
          return toURLEncodedForm(e, this.formSerializer).toString()
        if (
          (r = utils$1.isFileList(e)) ||
          n.indexOf('multipart/form-data') > -1
        ) {
          const t = this.env && this.env.FormData
          return toFormData$1(
            r ? { 'files[]': e } : e,
            t && new t(),
            this.formSerializer
          )
        }
      }
      return i || o
        ? (t.setContentType('application/json', !1), stringifySafely(e))
        : e
    }, 'transformRequest')
  ],
  transformResponse: [
    __name(function (e) {
      const t = this.transitional || defaults$1.transitional,
        n = t && t.forcedJSONParsing,
        o = 'json' === this.responseType
      if (utils$1.isResponse(e) || utils$1.isReadableStream(e)) return e
      if (e && utils$1.isString(e) && ((n && !this.responseType) || o)) {
        const n = !(t && t.silentJSONParsing) && o
        try {
          return JSON.parse(e)
        } catch (e2) {
          if (n) {
            if ('SyntaxError' === e2.name)
              throw AxiosError$1.from(
                e2,
                AxiosError$1.ERR_BAD_RESPONSE,
                this,
                null,
                this.response
              )
            throw e2
          }
        }
      }
      return e
    }, 'transformResponse')
  ],
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: platform.classes.FormData, Blob: platform.classes.Blob },
  validateStatus: __name(function (e) {
    return e >= 200 && e < 300
  }, 'validateStatus'),
  headers: {
    common: {
      Accept: 'application/json, text/plain, */*',
      'Content-Type': void 0
    }
  }
}
utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (e) => {
  defaults$1.headers[e] = {}
})
const ignoreDuplicateOf = utils$1.toObjectSet([
    'age',
    'authorization',
    'content-length',
    'content-type',
    'etag',
    'expires',
    'from',
    'host',
    'if-modified-since',
    'if-unmodified-since',
    'last-modified',
    'location',
    'max-forwards',
    'proxy-authorization',
    'referer',
    'retry-after',
    'user-agent'
  ]),
  parseHeaders = __name((e) => {
    const t = {}
    let n, o, i
    return (
      e &&
        e.split('\n').forEach(
          __name(function (e) {
            ;(i = e.indexOf(':')),
              (n = e.substring(0, i).trim().toLowerCase()),
              (o = e.substring(i + 1).trim()),
              !n ||
                (t[n] && ignoreDuplicateOf[n]) ||
                ('set-cookie' === n
                  ? t[n]
                    ? t[n].push(o)
                    : (t[n] = [o])
                  : (t[n] = t[n] ? t[n] + ', ' + o : o))
          }, 'parser')
        ),
      t
    )
  }, 'parseHeaders'),
  $internals = Symbol('internals')
function normalizeHeader(e) {
  return e && String(e).trim().toLowerCase()
}
function normalizeValue(e) {
  return !1 === e || null == e
    ? e
    : utils$1.isArray(e)
      ? e.map(normalizeValue)
      : String(e)
}
function parseTokens(e) {
  const t = Object.create(null),
    n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g
  let o
  for (; (o = n.exec(e)); ) t[o[1]] = o[2]
  return t
}
__name(normalizeHeader, 'normalizeHeader'),
  __name(normalizeValue, 'normalizeValue'),
  __name(parseTokens, 'parseTokens')
const isValidHeaderName = __name(
  (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()),
  'isValidHeaderName'
)
function matchHeaderValue(e, t, n, o, i) {
  return utils$1.isFunction(o)
    ? o.call(this, t, n)
    : (i && (t = n),
      utils$1.isString(t)
        ? utils$1.isString(o)
          ? -1 !== t.indexOf(o)
          : utils$1.isRegExp(o)
            ? o.test(t)
            : void 0
        : void 0)
}
function formatHeader(e) {
  return e
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (e, t, n) => t.toUpperCase() + n)
}
function buildAccessors(e, t) {
  const n = utils$1.toCamelCase(' ' + t)
  ;['get', 'set', 'has'].forEach((o) => {
    Object.defineProperty(e, o + n, {
      value: __name(function (e, n, i) {
        return this[o].call(this, t, e, n, i)
      }, 'value'),
      configurable: !0
    })
  })
}
__name(matchHeaderValue, 'matchHeaderValue'),
  __name(formatHeader, 'formatHeader'),
  __name(buildAccessors, 'buildAccessors')
let AxiosHeaders$1 = class {
  static {
    __name(this, 'AxiosHeaders')
  }
  constructor(e) {
    e && this.set(e)
  }
  set(e, t, n) {
    const o = this
    function i(e, t, n) {
      const i = normalizeHeader(t)
      if (!i) throw new Error('header name must be a non-empty string')
      const r = utils$1.findKey(o, i)
      ;(!r || void 0 === o[r] || !0 === n || (void 0 === n && !1 !== o[r])) &&
        (o[r || t] = normalizeValue(e))
    }
    __name(i, 'setHeader')
    const r = __name(
      (e, t) => utils$1.forEach(e, (e, n) => i(e, n, t)),
      'setHeaders'
    )
    if (utils$1.isPlainObject(e) || e instanceof this.constructor) r(e, t)
    else if (utils$1.isString(e) && (e = e.trim()) && !isValidHeaderName(e))
      r(parseHeaders(e), t)
    else if (utils$1.isHeaders(e)) for (const [a, s] of e.entries()) i(s, a, n)
    else null != e && i(t, e, n)
    return this
  }
  get(e, t) {
    if ((e = normalizeHeader(e))) {
      const n = utils$1.findKey(this, e)
      if (n) {
        const e = this[n]
        if (!t) return e
        if (!0 === t) return parseTokens(e)
        if (utils$1.isFunction(t)) return t.call(this, e, n)
        if (utils$1.isRegExp(t)) return t.exec(e)
        throw new TypeError('parser must be boolean|regexp|function')
      }
    }
  }
  has(e, t) {
    if ((e = normalizeHeader(e))) {
      const n = utils$1.findKey(this, e)
      return !(
        !n ||
        void 0 === this[n] ||
        (t && !matchHeaderValue(this, this[n], n, t))
      )
    }
    return !1
  }
  delete(e, t) {
    const n = this
    let o = !1
    function i(e) {
      if ((e = normalizeHeader(e))) {
        const i = utils$1.findKey(n, e)
        !i || (t && !matchHeaderValue(n, n[i], i, t)) || (delete n[i], (o = !0))
      }
    }
    return (
      __name(i, 'deleteHeader'), utils$1.isArray(e) ? e.forEach(i) : i(e), o
    )
  }
  clear(e) {
    const t = Object.keys(this)
    let n = t.length,
      o = !1
    for (; n--; ) {
      const i = t[n]
      ;(e && !matchHeaderValue(this, this[i], i, e, !0)) ||
        (delete this[i], (o = !0))
    }
    return o
  }
  normalize(e) {
    const t = this,
      n = {}
    return (
      utils$1.forEach(this, (o, i) => {
        const r = utils$1.findKey(n, i)
        if (r) return (t[r] = normalizeValue(o)), void delete t[i]
        const a = e ? formatHeader(i) : String(i).trim()
        a !== i && delete t[i], (t[a] = normalizeValue(o)), (n[a] = !0)
      }),
      this
    )
  }
  concat(...e) {
    return this.constructor.concat(this, ...e)
  }
  toJSON(e) {
    const t = Object.create(null)
    return (
      utils$1.forEach(this, (n, o) => {
        null != n &&
          !1 !== n &&
          (t[o] = e && utils$1.isArray(n) ? n.join(', ') : n)
      }),
      t
    )
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]()
  }
  toString() {
    return Object.entries(this.toJSON())
      .map(([e, t]) => e + ': ' + t)
      .join('\n')
  }
  get [Symbol.toStringTag]() {
    return 'AxiosHeaders'
  }
  static from(e) {
    return e instanceof this ? e : new this(e)
  }
  static concat(e, ...t) {
    const n = new this(e)
    return t.forEach((e) => n.set(e)), n
  }
  static accessor(e) {
    const t = (this[$internals] = this[$internals] = { accessors: {} })
        .accessors,
      n = this.prototype
    function o(e) {
      const o = normalizeHeader(e)
      t[o] || (buildAccessors(n, e), (t[o] = !0))
    }
    return (
      __name(o, 'defineAccessor'),
      utils$1.isArray(e) ? e.forEach(o) : o(e),
      this
    )
  }
}
function transformData(e, t) {
  const n = this || defaults$1,
    o = t || n,
    i = AxiosHeaders$1.from(o.headers)
  let r = o.data
  return (
    utils$1.forEach(
      e,
      __name(function (e) {
        r = e.call(n, r, i.normalize(), t ? t.status : void 0)
      }, 'transform')
    ),
    i.normalize(),
    r
  )
}
function isCancel$1(e) {
  return !(!e || !e.__CANCEL__)
}
function CanceledError$1(e, t, n) {
  AxiosError$1.call(
    this,
    null == e ? 'canceled' : e,
    AxiosError$1.ERR_CANCELED,
    t,
    n
  ),
    (this.name = 'CanceledError')
}
function settle(e, t, n) {
  const o = n.config.validateStatus
  n.status && o && !o(n.status)
    ? t(
        new AxiosError$1(
          'Request failed with status code ' + n.status,
          [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][
            Math.floor(n.status / 100) - 4
          ],
          n.config,
          n.request,
          n
        )
      )
    : e(n)
}
function parseProtocol(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e)
  return (t && t[1]) || ''
}
function speedometer(e, t) {
  e = e || 10
  const n = new Array(e),
    o = new Array(e)
  let i,
    r = 0,
    a = 0
  return (
    (t = void 0 !== t ? t : 1e3),
    __name(function (s) {
      const l = Date.now(),
        c = o[a]
      i || (i = l), (n[r] = s), (o[r] = l)
      let d = a,
        u = 0
      for (; d !== r; ) (u += n[d++]), (d %= e)
      if (((r = (r + 1) % e), r === a && (a = (a + 1) % e), l - i < t)) return
      const p = c && l - c
      return p ? Math.round((1e3 * u) / p) : void 0
    }, 'push')
  )
}
function throttle(e, t) {
  let n,
    o,
    i = 0,
    r = 1e3 / t
  const a = __name((t, r = Date.now()) => {
    ;(i = r), (n = null), o && (clearTimeout(o), (o = null)), e.apply(null, t)
  }, 'invoke')
  return [
    __name((...e) => {
      const t = Date.now(),
        s = t - i
      s >= r
        ? a(e, t)
        : ((n = e),
          o ||
            (o = setTimeout(() => {
              ;(o = null), a(n)
            }, r - s)))
    }, 'throttled'),
    __name(() => n && a(n), 'flush')
  ]
}
AxiosHeaders$1.accessor([
  'Content-Type',
  'Content-Length',
  'Accept',
  'Accept-Encoding',
  'User-Agent',
  'Authorization'
]),
  utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value: e }, t) => {
    let n = t[0].toUpperCase() + t.slice(1)
    return {
      get: __name(() => e, 'get'),
      set(e) {
        this[n] = e
      }
    }
  }),
  utils$1.freezeMethods(AxiosHeaders$1),
  __name(transformData, 'transformData'),
  __name(isCancel$1, 'isCancel$1'),
  __name(CanceledError$1, 'CanceledError$1'),
  utils$1.inherits(CanceledError$1, AxiosError$1, { __CANCEL__: !0 }),
  __name(settle, 'settle'),
  __name(parseProtocol, 'parseProtocol'),
  __name(speedometer, 'speedometer'),
  __name(throttle, 'throttle')
const progressEventReducer = __name((e, t, n = 3) => {
    let o = 0
    const i = speedometer(50, 250)
    return throttle((n) => {
      const r = n.loaded,
        a = n.lengthComputable ? n.total : void 0,
        s = r - o,
        l = i(s)
      o = r
      e({
        loaded: r,
        total: a,
        progress: a ? r / a : void 0,
        bytes: s,
        rate: l || void 0,
        estimated: l && a && r <= a ? (a - r) / l : void 0,
        event: n,
        lengthComputable: null != a,
        [t ? 'download' : 'upload']: !0
      })
    }, n)
  }, 'progressEventReducer'),
  progressEventDecorator = __name((e, t) => {
    const n = null != e
    return [(o) => t[0]({ lengthComputable: n, total: e, loaded: o }), t[1]]
  }, 'progressEventDecorator'),
  asyncDecorator = __name(
    (e) =>
      (...t) =>
        utils$1.asap(() => e(...t)),
    'asyncDecorator'
  ),
  isURLSameOrigin = platform.hasStandardBrowserEnv
    ? ((e, t) => (n) => (
        (n = new URL(n, platform.origin)),
        e.protocol === n.protocol &&
          e.host === n.host &&
          (t || e.port === n.port)
      ))(
        new URL(platform.origin),
        platform.navigator &&
          /(msie|trident)/i.test(platform.navigator.userAgent)
      )
    : () => !0,
  cookies = platform.hasStandardBrowserEnv
    ? {
        write(e, t, n, o, i, r) {
          const a = [e + '=' + encodeURIComponent(t)]
          utils$1.isNumber(n) && a.push('expires=' + new Date(n).toGMTString()),
            utils$1.isString(o) && a.push('path=' + o),
            utils$1.isString(i) && a.push('domain=' + i),
            !0 === r && a.push('secure'),
            (document.cookie = a.join('; '))
        },
        read(e) {
          const t = document.cookie.match(
            new RegExp('(^|;\\s*)(' + e + ')=([^;]*)')
          )
          return t ? decodeURIComponent(t[3]) : null
        },
        remove(e) {
          this.write(e, '', Date.now() - 864e5)
        }
      }
    : { write() {}, read: () => null, remove() {} }
function isAbsoluteURL$1(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
}
function combineURLs(e, t) {
  return t ? e.replace(/\/?\/$/, '') + '/' + t.replace(/^\/+/, '') : e
}
function buildFullPath(e, t) {
  return e && !isAbsoluteURL$1(t) ? combineURLs(e, t) : t
}
__name(isAbsoluteURL$1, 'isAbsoluteURL$1'),
  __name(combineURLs, 'combineURLs'),
  __name(buildFullPath, 'buildFullPath')
const headersToObject$1 = __name(
  (e) => (e instanceof AxiosHeaders$1 ? { ...e } : e),
  'headersToObject$1'
)
function mergeConfig$1(e, t) {
  t = t || {}
  const n = {}
  function o(e, t, n, o) {
    return utils$1.isPlainObject(e) && utils$1.isPlainObject(t)
      ? utils$1.merge.call({ caseless: o }, e, t)
      : utils$1.isPlainObject(t)
        ? utils$1.merge({}, t)
        : utils$1.isArray(t)
          ? t.slice()
          : t
  }
  function i(e, t, n, i) {
    return utils$1.isUndefined(t)
      ? utils$1.isUndefined(e)
        ? void 0
        : o(void 0, e, 0, i)
      : o(e, t, 0, i)
  }
  function r(e, t) {
    if (!utils$1.isUndefined(t)) return o(void 0, t)
  }
  function a(e, t) {
    return utils$1.isUndefined(t)
      ? utils$1.isUndefined(e)
        ? void 0
        : o(void 0, e)
      : o(void 0, t)
  }
  function s(n, i, r) {
    return r in t ? o(n, i) : r in e ? o(void 0, n) : void 0
  }
  __name(o, 'getMergedValue'),
    __name(i, 'mergeDeepProperties'),
    __name(r, 'valueFromConfig2'),
    __name(a, 'defaultToConfig2'),
    __name(s, 'mergeDirectKeys')
  const l = {
    url: r,
    method: r,
    data: r,
    baseURL: a,
    transformRequest: a,
    transformResponse: a,
    paramsSerializer: a,
    timeout: a,
    timeoutMessage: a,
    withCredentials: a,
    withXSRFToken: a,
    adapter: a,
    responseType: a,
    xsrfCookieName: a,
    xsrfHeaderName: a,
    onUploadProgress: a,
    onDownloadProgress: a,
    decompress: a,
    maxContentLength: a,
    maxBodyLength: a,
    beforeRedirect: a,
    transport: a,
    httpAgent: a,
    httpsAgent: a,
    cancelToken: a,
    socketPath: a,
    responseEncoding: a,
    validateStatus: s,
    headers: __name(
      (e, t, n) => i(headersToObject$1(e), headersToObject$1(t), 0, !0),
      'headers'
    )
  }
  return (
    utils$1.forEach(
      Object.keys(Object.assign({}, e, t)),
      __name(function (o) {
        const r = l[o] || i,
          a = r(e[o], t[o], o)
        ;(utils$1.isUndefined(a) && r !== s) || (n[o] = a)
      }, 'computeConfigValue')
    ),
    n
  )
}
__name(mergeConfig$1, 'mergeConfig$1')
const resolveConfig = __name((e) => {
    const t = mergeConfig$1({}, e)
    let n,
      {
        data: o,
        withXSRFToken: i,
        xsrfHeaderName: r,
        xsrfCookieName: a,
        headers: s,
        auth: l
      } = t
    if (
      ((t.headers = s = AxiosHeaders$1.from(s)),
      (t.url = buildURL(
        buildFullPath(t.baseURL, t.url),
        e.params,
        e.paramsSerializer
      )),
      l &&
        s.set(
          'Authorization',
          'Basic ' +
            btoa(
              (l.username || '') +
                ':' +
                (l.password ? unescape(encodeURIComponent(l.password)) : '')
            )
        ),
      utils$1.isFormData(o))
    )
      if (
        platform.hasStandardBrowserEnv ||
        platform.hasStandardBrowserWebWorkerEnv
      )
        s.setContentType(void 0)
      else if (!1 !== (n = s.getContentType())) {
        const [e, ...t] = n
          ? n
              .split(';')
              .map((e) => e.trim())
              .filter(Boolean)
          : []
        s.setContentType([e || 'multipart/form-data', ...t].join('; '))
      }
    if (
      platform.hasStandardBrowserEnv &&
      (i && utils$1.isFunction(i) && (i = i(t)),
      i || (!1 !== i && isURLSameOrigin(t.url)))
    ) {
      const e = r && a && cookies.read(a)
      e && s.set(r, e)
    }
    return t
  }, 'resolveConfig'),
  isXHRAdapterSupported = 'undefined' != typeof XMLHttpRequest,
  xhrAdapter =
    isXHRAdapterSupported &&
    function (e) {
      return new Promise(
        __name(function (t, n) {
          const o = resolveConfig(e)
          let i = o.data
          const r = AxiosHeaders$1.from(o.headers).normalize()
          let a,
            s,
            l,
            c,
            d,
            { responseType: u, onUploadProgress: p, onDownloadProgress: h } = o
          function m() {
            c && c(),
              d && d(),
              o.cancelToken && o.cancelToken.unsubscribe(a),
              o.signal && o.signal.removeEventListener('abort', a)
          }
          __name(m, 'done')
          let f = new XMLHttpRequest()
          function _() {
            if (!f) return
            const o = AxiosHeaders$1.from(
                'getAllResponseHeaders' in f && f.getAllResponseHeaders()
              ),
              i = {
                data:
                  u && 'text' !== u && 'json' !== u
                    ? f.response
                    : f.responseText,
                status: f.status,
                statusText: f.statusText,
                headers: o,
                config: e,
                request: f
              }
            settle(
              __name(function (e) {
                t(e), m()
              }, '_resolve'),
              __name(function (e) {
                n(e), m()
              }, '_reject'),
              i
            ),
              (f = null)
          }
          f.open(o.method.toUpperCase(), o.url, !0),
            (f.timeout = o.timeout),
            __name(_, 'onloadend'),
            'onloadend' in f
              ? (f.onloadend = _)
              : (f.onreadystatechange = __name(function () {
                  f &&
                    4 === f.readyState &&
                    (0 !== f.status ||
                      (f.responseURL &&
                        0 === f.responseURL.indexOf('file:'))) &&
                    setTimeout(_)
                }, 'handleLoad')),
            (f.onabort = __name(function () {
              f &&
                (n(
                  new AxiosError$1(
                    'Request aborted',
                    AxiosError$1.ECONNABORTED,
                    e,
                    f
                  )
                ),
                (f = null))
            }, 'handleAbort')),
            (f.onerror = __name(function () {
              n(
                new AxiosError$1(
                  'Network Error',
                  AxiosError$1.ERR_NETWORK,
                  e,
                  f
                )
              ),
                (f = null)
            }, 'handleError')),
            (f.ontimeout = __name(function () {
              let t = o.timeout
                ? 'timeout of ' + o.timeout + 'ms exceeded'
                : 'timeout exceeded'
              const i = o.transitional || transitionalDefaults
              o.timeoutErrorMessage && (t = o.timeoutErrorMessage),
                n(
                  new AxiosError$1(
                    t,
                    i.clarifyTimeoutError
                      ? AxiosError$1.ETIMEDOUT
                      : AxiosError$1.ECONNABORTED,
                    e,
                    f
                  )
                ),
                (f = null)
            }, 'handleTimeout')),
            void 0 === i && r.setContentType(null),
            'setRequestHeader' in f &&
              utils$1.forEach(
                r.toJSON(),
                __name(function (e, t) {
                  f.setRequestHeader(t, e)
                }, 'setRequestHeader')
              ),
            utils$1.isUndefined(o.withCredentials) ||
              (f.withCredentials = !!o.withCredentials),
            u && 'json' !== u && (f.responseType = o.responseType),
            h &&
              (([l, d] = progressEventReducer(h, !0)),
              f.addEventListener('progress', l)),
            p &&
              f.upload &&
              (([s, c] = progressEventReducer(p)),
              f.upload.addEventListener('progress', s),
              f.upload.addEventListener('loadend', c)),
            (o.cancelToken || o.signal) &&
              ((a = __name((t) => {
                f &&
                  (n(!t || t.type ? new CanceledError$1(null, e, f) : t),
                  f.abort(),
                  (f = null))
              }, 'onCanceled')),
              o.cancelToken && o.cancelToken.subscribe(a),
              o.signal &&
                (o.signal.aborted
                  ? a()
                  : o.signal.addEventListener('abort', a)))
          const g = parseProtocol(o.url)
          g && -1 === platform.protocols.indexOf(g)
            ? n(
                new AxiosError$1(
                  'Unsupported protocol ' + g + ':',
                  AxiosError$1.ERR_BAD_REQUEST,
                  e
                )
              )
            : f.send(i || null)
        }, 'dispatchXhrRequest')
      )
    },
  composeSignals = __name((e, t) => {
    const { length: n } = (e = e ? e.filter(Boolean) : [])
    if (t || n) {
      let n,
        o = new AbortController()
      const i = __name(function (e) {
        if (!n) {
          ;(n = !0), a()
          const t = e instanceof Error ? e : this.reason
          o.abort(
            t instanceof AxiosError$1
              ? t
              : new CanceledError$1(t instanceof Error ? t.message : t)
          )
        }
      }, 'onabort')
      let r =
        t &&
        setTimeout(() => {
          ;(r = null),
            i(
              new AxiosError$1(
                `timeout ${t} of ms exceeded`,
                AxiosError$1.ETIMEDOUT
              )
            )
        }, t)
      const a = __name(() => {
        e &&
          (r && clearTimeout(r),
          (r = null),
          e.forEach((e) => {
            e.unsubscribe ? e.unsubscribe(i) : e.removeEventListener('abort', i)
          }),
          (e = null))
      }, 'unsubscribe')
      e.forEach((e) => e.addEventListener('abort', i))
      const { signal: s } = o
      return (s.unsubscribe = () => utils$1.asap(a)), s
    }
  }, 'composeSignals'),
  streamChunk = __name(function* (e, t) {
    let n = e.byteLength
    if (!t || n < t) return void (yield e)
    let o,
      i = 0
    for (; i < n; ) (o = i + t), yield e.slice(i, o), (i = o)
  }, 'streamChunk'),
  readBytes = __name(async function* (e, t) {
    for await (const n of readStream(e)) yield* streamChunk(n, t)
  }, 'readBytes'),
  readStream = __name(async function* (e) {
    if (e[Symbol.asyncIterator]) return void (yield* e)
    const t = e.getReader()
    try {
      for (;;) {
        const { done: e, value: n } = await t.read()
        if (e) break
        yield n
      }
    } finally {
      await t.cancel()
    }
  }, 'readStream'),
  trackStream = __name((e, t, n, o) => {
    const i = readBytes(e, t)
    let r,
      a = 0,
      s = __name((e) => {
        r || ((r = !0), o && o(e))
      }, '_onFinish')
    return new ReadableStream(
      {
        async pull(e) {
          try {
            const { done: t, value: o } = await i.next()
            if (t) return s(), void e.close()
            let r = o.byteLength
            if (n) {
              let e = (a += r)
              n(e)
            }
            e.enqueue(new Uint8Array(o))
          } catch (t) {
            throw (s(t), t)
          }
        },
        cancel: (e) => (s(e), i.return())
      },
      { highWaterMark: 2 }
    )
  }, 'trackStream'),
  isFetchSupported =
    'function' == typeof fetch &&
    'function' == typeof Request &&
    'function' == typeof Response,
  isReadableStreamSupported =
    isFetchSupported && 'function' == typeof ReadableStream,
  encodeText =
    isFetchSupported &&
    ('function' == typeof TextEncoder
      ? (
          (e) => (t) =>
            e.encode(t)
        )(new TextEncoder())
      : async (e) => new Uint8Array(await new Response(e).arrayBuffer())),
  test = __name((e, ...t) => {
    try {
      return !!e(...t)
    } catch (e2) {
      return !1
    }
  }, 'test'),
  supportsRequestStream =
    isReadableStreamSupported &&
    test(() => {
      let e = !1
      const t = new Request(platform.origin, {
        body: new ReadableStream(),
        method: 'POST',
        get duplex() {
          return (e = !0), 'half'
        }
      }).headers.has('Content-Type')
      return e && !t
    }),
  DEFAULT_CHUNK_SIZE = 65536,
  supportsResponseStream =
    isReadableStreamSupported &&
    test(() => utils$1.isReadableStream(new Response('').body)),
  resolvers = { stream: supportsResponseStream && ((e) => e.body) }
var res
isFetchSupported &&
  ((res = new Response()),
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach((e) => {
    !resolvers[e] &&
      (resolvers[e] = utils$1.isFunction(res[e])
        ? (t) => t[e]()
        : (t, n) => {
            throw new AxiosError$1(
              `Response type '${e}' is not supported`,
              AxiosError$1.ERR_NOT_SUPPORT,
              n
            )
          })
  }))
const getBodyLength = __name(async (e) => {
    if (null == e) return 0
    if (utils$1.isBlob(e)) return e.size
    if (utils$1.isSpecCompliantForm(e)) {
      const t = new Request(platform.origin, { method: 'POST', body: e })
      return (await t.arrayBuffer()).byteLength
    }
    return utils$1.isArrayBufferView(e) || utils$1.isArrayBuffer(e)
      ? e.byteLength
      : (utils$1.isURLSearchParams(e) && (e += ''),
        utils$1.isString(e) ? (await encodeText(e)).byteLength : void 0)
  }, 'getBodyLength'),
  resolveBodyLength = __name(async (e, t) => {
    const n = utils$1.toFiniteNumber(e.getContentLength())
    return null == n ? getBodyLength(t) : n
  }, 'resolveBodyLength'),
  fetchAdapter =
    isFetchSupported &&
    (async (e) => {
      let {
        url: t,
        method: n,
        data: o,
        signal: i,
        cancelToken: r,
        timeout: a,
        onDownloadProgress: s,
        onUploadProgress: l,
        responseType: c,
        headers: d,
        withCredentials: u = 'same-origin',
        fetchOptions: p
      } = resolveConfig(e)
      c = c ? (c + '').toLowerCase() : 'text'
      let h,
        m = composeSignals([i, r && r.toAbortSignal()], a)
      const f =
        m &&
        m.unsubscribe &&
        (() => {
          m.unsubscribe()
        })
      let _
      try {
        if (
          l &&
          supportsRequestStream &&
          'get' !== n &&
          'head' !== n &&
          0 !== (_ = await resolveBodyLength(d, o))
        ) {
          let e,
            n = new Request(t, { method: 'POST', body: o, duplex: 'half' })
          if (
            (utils$1.isFormData(o) &&
              (e = n.headers.get('content-type')) &&
              d.setContentType(e),
            n.body)
          ) {
            const [e, t] = progressEventDecorator(
              _,
              progressEventReducer(asyncDecorator(l))
            )
            o = trackStream(n.body, DEFAULT_CHUNK_SIZE, e, t)
          }
        }
        utils$1.isString(u) || (u = u ? 'include' : 'omit')
        const i = 'credentials' in Request.prototype
        h = new Request(t, {
          ...p,
          signal: m,
          method: n.toUpperCase(),
          headers: d.normalize().toJSON(),
          body: o,
          duplex: 'half',
          credentials: i ? u : void 0
        })
        let r = await fetch(h)
        const a = supportsResponseStream && ('stream' === c || 'response' === c)
        if (supportsResponseStream && (s || (a && f))) {
          const e = {}
          ;['status', 'statusText', 'headers'].forEach((t) => {
            e[t] = r[t]
          })
          const t = utils$1.toFiniteNumber(r.headers.get('content-length')),
            [n, o] =
              (s &&
                progressEventDecorator(
                  t,
                  progressEventReducer(asyncDecorator(s), !0)
                )) ||
              []
          r = new Response(
            trackStream(r.body, DEFAULT_CHUNK_SIZE, n, () => {
              o && o(), f && f()
            }),
            e
          )
        }
        c = c || 'text'
        let g = await resolvers[utils$1.findKey(resolvers, c) || 'text'](r, e)
        return (
          !a && f && f(),
          await new Promise((t, n) => {
            settle(t, n, {
              data: g,
              headers: AxiosHeaders$1.from(r.headers),
              status: r.status,
              statusText: r.statusText,
              config: e,
              request: h
            })
          })
        )
      } catch (g) {
        if ((f && f(), g && 'TypeError' === g.name && /fetch/i.test(g.message)))
          throw Object.assign(
            new AxiosError$1('Network Error', AxiosError$1.ERR_NETWORK, e, h),
            { cause: g.cause || g }
          )
        throw AxiosError$1.from(g, g && g.code, e, h)
      }
    }),
  knownAdapters = { http: httpAdapter, xhr: xhrAdapter, fetch: fetchAdapter }
utils$1.forEach(knownAdapters, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, 'name', { value: t })
    } catch (e2) {}
    Object.defineProperty(e, 'adapterName', { value: t })
  }
})
const renderReason = __name((e) => `- ${e}`, 'renderReason'),
  isResolvedHandle = __name(
    (e) => utils$1.isFunction(e) || null === e || !1 === e,
    'isResolvedHandle'
  ),
  adapters = {
    getAdapter: __name((e) => {
      e = utils$1.isArray(e) ? e : [e]
      const { length: t } = e
      let n, o
      const i = {}
      for (let r = 0; r < t; r++) {
        let t
        if (
          ((n = e[r]),
          (o = n),
          !isResolvedHandle(n) &&
            ((o = knownAdapters[(t = String(n)).toLowerCase()]), void 0 === o))
        )
          throw new AxiosError$1(`Unknown adapter '${t}'`)
        if (o) break
        i[t || '#' + r] = o
      }
      if (!o) {
        const e = Object.entries(i).map(
          ([e, t]) =>
            `adapter ${e} ` +
            (!1 === t
              ? 'is not supported by the environment'
              : 'is not available in the build')
        )
        throw new AxiosError$1(
          'There is no suitable adapter to dispatch the request ' +
            (t
              ? e.length > 1
                ? 'since :\n' + e.map(renderReason).join('\n')
                : ' ' + renderReason(e[0])
              : 'as no adapter specified'),
          'ERR_NOT_SUPPORT'
        )
      }
      return o
    }, 'getAdapter'),
    adapters: knownAdapters
  }
function throwIfCancellationRequested(e) {
  if (
    (e.cancelToken && e.cancelToken.throwIfRequested(),
    e.signal && e.signal.aborted)
  )
    throw new CanceledError$1(null, e)
}
function dispatchRequest(e) {
  throwIfCancellationRequested(e),
    (e.headers = AxiosHeaders$1.from(e.headers)),
    (e.data = transformData.call(e, e.transformRequest)),
    -1 !== ['post', 'put', 'patch'].indexOf(e.method) &&
      e.headers.setContentType('application/x-www-form-urlencoded', !1)
  return adapters
    .getAdapter(e.adapter || defaults$1.adapter)(e)
    .then(
      __name(function (t) {
        return (
          throwIfCancellationRequested(e),
          (t.data = transformData.call(e, e.transformResponse, t)),
          (t.headers = AxiosHeaders$1.from(t.headers)),
          t
        )
      }, 'onAdapterResolution'),
      __name(function (t) {
        return (
          isCancel$1(t) ||
            (throwIfCancellationRequested(e),
            t &&
              t.response &&
              ((t.response.data = transformData.call(
                e,
                e.transformResponse,
                t.response
              )),
              (t.response.headers = AxiosHeaders$1.from(t.response.headers)))),
          Promise.reject(t)
        )
      }, 'onAdapterRejection')
    )
}
__name(throwIfCancellationRequested, 'throwIfCancellationRequested'),
  __name(dispatchRequest, 'dispatchRequest')
const VERSION$1 = '1.7.9',
  validators$1 = {}
;['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(
  (e, t) => {
    validators$1[e] = __name(function (n) {
      return typeof n === e || 'a' + (t < 1 ? 'n ' : ' ') + e
    }, 'validator')
  }
)
const deprecatedWarnings = {}
function assertOptions(e, t, n) {
  if ('object' != typeof e)
    throw new AxiosError$1(
      'options must be an object',
      AxiosError$1.ERR_BAD_OPTION_VALUE
    )
  const o = Object.keys(e)
  let i = o.length
  for (; i-- > 0; ) {
    const r = o[i],
      a = t[r]
    if (a) {
      const t = e[r],
        n = void 0 === t || a(t, r, e)
      if (!0 !== n)
        throw new AxiosError$1(
          'option ' + r + ' must be ' + n,
          AxiosError$1.ERR_BAD_OPTION_VALUE
        )
    } else if (!0 !== n)
      throw new AxiosError$1('Unknown option ' + r, AxiosError$1.ERR_BAD_OPTION)
  }
}
;(validators$1.transitional = __name(function (e, t, n) {
  function o(e, t) {
    return (
      '[Axios v' +
      VERSION$1 +
      "] Transitional option '" +
      e +
      "'" +
      t +
      (n ? '. ' + n : '')
    )
  }
  return (
    __name(o, 'formatMessage'),
    (n, i, r) => {
      if (!1 === e)
        throw new AxiosError$1(
          o(i, ' has been removed' + (t ? ' in ' + t : '')),
          AxiosError$1.ERR_DEPRECATED
        )
      return (
        t &&
          !deprecatedWarnings[i] &&
          ((deprecatedWarnings[i] = !0),
          console.warn(
            o(
              i,
              ' has been deprecated since v' +
                t +
                ' and will be removed in the near future'
            )
          )),
        !e || e(n, i, r)
      )
    }
  )
}, 'transitional')),
  (validators$1.spelling = __name(function (e) {
    return (t, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0)
  }, 'spelling')),
  __name(assertOptions, 'assertOptions')
const validator = { assertOptions: assertOptions, validators: validators$1 },
  validators = validator.validators
let Axios$1 = class {
  static {
    __name(this, 'Axios')
  }
  constructor(e) {
    ;(this.defaults = e),
      (this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      })
  }
  async request(e, t) {
    try {
      return await this._request(e, t)
    } catch (n) {
      if (n instanceof Error) {
        let e = {}
        Error.captureStackTrace ? Error.captureStackTrace(e) : (e = new Error())
        const t = e.stack ? e.stack.replace(/^.+\n/, '') : ''
        try {
          n.stack
            ? t &&
              !String(n.stack).endsWith(t.replace(/^.+\n.+\n/, '')) &&
              (n.stack += '\n' + t)
            : (n.stack = t)
        } catch (e2) {}
      }
      throw n
    }
  }
  _request(e, t) {
    'string' == typeof e ? ((t = t || {}).url = e) : (t = e || {}),
      (t = mergeConfig$1(this.defaults, t))
    const { transitional: n, paramsSerializer: o, headers: i } = t
    void 0 !== n &&
      validator.assertOptions(
        n,
        {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        },
        !1
      ),
      null != o &&
        (utils$1.isFunction(o)
          ? (t.paramsSerializer = { serialize: o })
          : validator.assertOptions(
              o,
              { encode: validators.function, serialize: validators.function },
              !0
            )),
      validator.assertOptions(
        t,
        {
          baseUrl: validators.spelling('baseURL'),
          withXsrfToken: validators.spelling('withXSRFToken')
        },
        !0
      ),
      (t.method = (t.method || this.defaults.method || 'get').toLowerCase())
    let r = i && utils$1.merge(i.common, i[t.method])
    i &&
      utils$1.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        (e) => {
          delete i[e]
        }
      ),
      (t.headers = AxiosHeaders$1.concat(r, i))
    const a = []
    let s = !0
    this.interceptors.request.forEach(
      __name(function (e) {
        ;('function' == typeof e.runWhen && !1 === e.runWhen(t)) ||
          ((s = s && e.synchronous), a.unshift(e.fulfilled, e.rejected))
      }, 'unshiftRequestInterceptors')
    )
    const l = []
    let c
    this.interceptors.response.forEach(
      __name(function (e) {
        l.push(e.fulfilled, e.rejected)
      }, 'pushResponseInterceptors')
    )
    let d,
      u = 0
    if (!s) {
      const e = [dispatchRequest.bind(this), void 0]
      for (
        e.unshift.apply(e, a),
          e.push.apply(e, l),
          d = e.length,
          c = Promise.resolve(t);
        u < d;

      )
        c = c.then(e[u++], e[u++])
      return c
    }
    d = a.length
    let p = t
    for (u = 0; u < d; ) {
      const e = a[u++],
        t = a[u++]
      try {
        p = e(p)
      } catch (h) {
        t.call(this, h)
        break
      }
    }
    try {
      c = dispatchRequest.call(this, p)
    } catch (h) {
      return Promise.reject(h)
    }
    for (u = 0, d = l.length; u < d; ) c = c.then(l[u++], l[u++])
    return c
  }
  getUri(e) {
    return buildURL(
      buildFullPath((e = mergeConfig$1(this.defaults, e)).baseURL, e.url),
      e.params,
      e.paramsSerializer
    )
  }
}
utils$1.forEach(
  ['delete', 'get', 'head', 'options'],
  __name(function (e) {
    Axios$1.prototype[e] = function (t, n) {
      return this.request(
        mergeConfig$1(n || {}, { method: e, url: t, data: (n || {}).data })
      )
    }
  }, 'forEachMethodNoData')
),
  utils$1.forEach(
    ['post', 'put', 'patch'],
    __name(function (e) {
      function t(t) {
        return __name(function (n, o, i) {
          return this.request(
            mergeConfig$1(i || {}, {
              method: e,
              headers: t ? { 'Content-Type': 'multipart/form-data' } : {},
              url: n,
              data: o
            })
          )
        }, 'httpMethod')
      }
      __name(t, 'generateHTTPMethod'),
        (Axios$1.prototype[e] = t()),
        (Axios$1.prototype[e + 'Form'] = t(!0))
    }, 'forEachMethodWithData')
  )
let CancelToken$1 = class e {
  static {
    __name(this, 'CancelToken')
  }
  constructor(e) {
    if ('function' != typeof e)
      throw new TypeError('executor must be a function.')
    let t
    this.promise = new Promise(
      __name(function (e) {
        t = e
      }, 'promiseExecutor')
    )
    const n = this
    this.promise.then((e) => {
      if (!n._listeners) return
      let t = n._listeners.length
      for (; t-- > 0; ) n._listeners[t](e)
      n._listeners = null
    }),
      (this.promise.then = (e) => {
        let t
        const o = new Promise((e) => {
          n.subscribe(e), (t = e)
        }).then(e)
        return (
          (o.cancel = __name(function () {
            n.unsubscribe(t)
          }, 'reject')),
          o
        )
      }),
      e(
        __name(function (e, o, i) {
          n.reason || ((n.reason = new CanceledError$1(e, o, i)), t(n.reason))
        }, 'cancel')
      )
  }
  throwIfRequested() {
    if (this.reason) throw this.reason
  }
  subscribe(e) {
    this.reason
      ? e(this.reason)
      : this._listeners
        ? this._listeners.push(e)
        : (this._listeners = [e])
  }
  unsubscribe(e) {
    if (!this._listeners) return
    const t = this._listeners.indexOf(e)
    ;-1 !== t && this._listeners.splice(t, 1)
  }
  toAbortSignal() {
    const e = new AbortController(),
      t = __name((t) => {
        e.abort(t)
      }, 'abort')
    return (
      this.subscribe(t),
      (e.signal.unsubscribe = () => this.unsubscribe(t)),
      e.signal
    )
  }
  static source() {
    let t
    return {
      token: new e(
        __name(function (e) {
          t = e
        }, 'executor')
      ),
      cancel: t
    }
  }
}
function spread$1(e) {
  return __name(function (t) {
    return e.apply(null, t)
  }, 'wrap')
}
function isAxiosError$1(e) {
  return utils$1.isObject(e) && !0 === e.isAxiosError
}
__name(spread$1, 'spread$1'), __name(isAxiosError$1, 'isAxiosError$1')
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
}
function createInstance(e) {
  const t = new Axios$1(e),
    n = bind$2(Axios$1.prototype.request, t)
  return (
    utils$1.extend(n, Axios$1.prototype, t, { allOwnKeys: !0 }),
    utils$1.extend(n, t, null, { allOwnKeys: !0 }),
    (n.create = __name(function (t) {
      return createInstance(mergeConfig$1(e, t))
    }, 'create')),
    n
  )
}
Object.entries(HttpStatusCode$1).forEach(([e, t]) => {
  HttpStatusCode$1[t] = e
}),
  __name(createInstance, 'createInstance')
const axios = createInstance(defaults$1)
;(axios.Axios = Axios$1),
  (axios.CanceledError = CanceledError$1),
  (axios.CancelToken = CancelToken$1),
  (axios.isCancel = isCancel$1),
  (axios.VERSION = VERSION$1),
  (axios.toFormData = toFormData$1),
  (axios.AxiosError = AxiosError$1),
  (axios.Cancel = axios.CanceledError),
  (axios.all = __name(function (e) {
    return Promise.all(e)
  }, 'all')),
  (axios.spread = spread$1),
  (axios.isAxiosError = isAxiosError$1),
  (axios.mergeConfig = mergeConfig$1),
  (axios.AxiosHeaders = AxiosHeaders$1),
  (axios.formToJSON = (e) =>
    formDataToJSON(utils$1.isHTMLForm(e) ? new FormData(e) : e)),
  (axios.getAdapter = adapters.getAdapter),
  (axios.HttpStatusCode = HttpStatusCode$1),
  (axios.default = axios)
const {
  Axios: Axios,
  AxiosError: AxiosError,
  CanceledError: CanceledError,
  isCancel: isCancel,
  CancelToken: CancelToken,
  VERSION: VERSION,
  all: all,
  Cancel: Cancel,
  isAxiosError: isAxiosError,
  spread: spread,
  toFormData: toFormData,
  AxiosHeaders: AxiosHeaders,
  HttpStatusCode: HttpStatusCode,
  formToJSON: formToJSON,
  getAdapter: getAdapter,
  mergeConfig: mergeConfig
} = axios
class ComfyApi extends EventTarget {
  static {
    __name(this, 'ComfyApi')
  }
  #e = new Set()
  api_host
  api_base
  initialClientId
  clientId
  user
  socket = null
  reportedUnknownMessageTypes = new Set()
  constructor() {
    super(),
      (this.user = ''),
      (this.api_host = location.host),
      (this.api_base = location.pathname.split('/').slice(0, -1).join('/')),
      console.log('Running on', this.api_host),
      (this.initialClientId = sessionStorage.getItem('clientId'))
  }
  internalURL(e) {
    return this.api_base + '/internal' + e
  }
  apiURL(e) {
    return this.api_base + '/api' + e
  }
  fileURL(e) {
    return this.api_base + e
  }
  fetchApi(e, t) {
    return (
      t || (t = {}),
      t.headers || (t.headers = {}),
      t.cache || (t.cache = 'no-cache'),
      Array.isArray(t.headers)
        ? t.headers.push(['Comfy-User', this.user])
        : t.headers instanceof Headers
          ? t.headers.set('Comfy-User', this.user)
          : (t.headers['Comfy-User'] = this.user),
      fetch(this.apiURL(e), t)
    )
  }
  addEventListener(e, t, n) {
    super.addEventListener(e, t, n), this.#e.add(e)
  }
  removeEventListener(e, t, n) {
    super.removeEventListener(e, t, n)
  }
  dispatchCustomEvent(e, t) {
    const n =
      void 0 === t ? new CustomEvent(e) : new CustomEvent(e, { detail: t })
    return super.dispatchEvent(n)
  }
  dispatchEvent(e) {
    return super.dispatchEvent(e)
  }
  #t() {
    setInterval(async () => {
      try {
        const e = await this.fetchApi('/prompt'),
          t = await e.json()
        this.dispatchCustomEvent('status', t)
      } catch (e) {
        this.dispatchCustomEvent('status', null)
      }
    }, 1e3)
  }
  #n(e) {
    if (this.socket) return
    let t = !1,
      n = window.name
    n && (n = '?clientId=' + n),
      (this.socket = new WebSocket(
        `ws${'https:' === window.location.protocol ? 's' : ''}://${this.api_host}${this.api_base}/ws${n}`
      )),
      (this.socket.binaryType = 'arraybuffer'),
      this.socket.addEventListener('open', () => {
        ;(t = !0), e && this.dispatchCustomEvent('reconnected')
      }),
      this.socket.addEventListener('error', () => {
        this.socket && this.socket.close(), e || t || this.#t()
      }),
      this.socket.addEventListener('close', () => {
        setTimeout(() => {
          ;(this.socket = null), this.#n(!0)
        }, 300),
          t &&
            (this.dispatchCustomEvent('status', null),
            this.dispatchCustomEvent('reconnecting'))
      }),
      this.socket.addEventListener('message', (e) => {
        try {
          if (e.data instanceof ArrayBuffer) {
            const t = new DataView(e.data).getUint32(0),
              n = e.data.slice(4)
            if (1 !== t)
              throw new Error(`Unknown binary websocket message of type ${t}`)
            {
              const t = new DataView(e.data)
              let o
              switch (t.getUint32(0)) {
                case 1:
                default:
                  o = 'image/jpeg'
                  break
                case 2:
                  o = 'image/png'
              }
              const i = new Blob([n.slice(4)], { type: o })
              this.dispatchCustomEvent('b_preview', i)
            }
          } else {
            const t = JSON.parse(e.data)
            switch (t.type) {
              case 'status':
                if (t.data.sid) {
                  const e = t.data.sid
                  ;(this.clientId = e),
                    (window.name = e),
                    sessionStorage.setItem('clientId', e)
                }
                this.dispatchCustomEvent('status', t.data.status ?? null)
                break
              case 'executing':
                this.dispatchCustomEvent(
                  'executing',
                  t.data.display_node || t.data.node
                )
                break
              case 'execution_start':
              case 'execution_error':
              case 'execution_cached':
              case 'execution_success':
              case 'progress':
              case 'executed':
              case 'graphChanged':
              case 'promptQueued':
              case 'logs':
              case 'b_preview':
                this.dispatchCustomEvent(t.type, t.data)
                break
              default:
                if (this.#e.has(t.type))
                  super.dispatchEvent(
                    new CustomEvent(t.type, { detail: t.data })
                  )
                else if (!this.reportedUnknownMessageTypes.has(t.type))
                  throw (
                    (this.reportedUnknownMessageTypes.add(t.type),
                    new Error(`Unknown message type ${t.type}`))
                  )
            }
          }
        } catch (t) {
          console.warn('Unhandled message:', e.data, t)
        }
      })
  }
  init() {
    this.#n()
  }
  async getExtensions() {
    const e = await this.fetchApi('/extensions', { cache: 'no-store' })
    return await e.json()
  }
  async getEmbeddings() {
    const e = await this.fetchApi('/embeddings', { cache: 'no-store' })
    return await e.json()
  }
  async getNodeDefs({ validate: e = !1 } = {}) {
    const t = await this.fetchApi('/object_info', { cache: 'no-store' }),
      n = await t.json()
    if (!e) return n
    const o = {}
    for (const i in n) {
      const e = validateComfyNodeDef(n[i], (e) => {
        console.warn(
          `Skipping invalid node definition: ${i}. See debug log for more information.`
        ),
          console.debug(e)
      })
      null !== e && (o[i] = e)
    }
    return o
  }
  async queuePrompt(e, { output: t, workflow: n }) {
    const o = {
      client_id: this.clientId ?? '',
      prompt: t,
      extra_data: { extra_pnginfo: { workflow: n } }
    }
    ;-1 === e ? (o.front = !0) : 0 != e && (o.number = e)
    const i = await this.fetchApi('/prompt', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(o)
    })
    if (200 !== i.status) throw { response: await i.json() }
    return await i.json()
  }
  async getModelFolders() {
    const e = await this.fetchApi('/models')
    if (404 === e.status) return []
    const t = ['configs', 'custom_nodes']
    return (await e.json()).filter((e) => !t.includes(e))
  }
  async getModels(e) {
    const t = await this.fetchApi(`/models/${e}`)
    return 404 === t.status ? [] : await t.json()
  }
  async viewMetadata(e, t) {
    const n = await this.fetchApi(
        `/view_metadata/${e}?filename=${encodeURIComponent(t)}`
      ),
      o = await n.text()
    if (!o) return null
    try {
      return JSON.parse(o)
    } catch (i) {
      return (
        console.error('Error viewing metadata', n.status, n.statusText, o, i),
        null
      )
    }
  }
  async getItems(e) {
    return 'queue' === e ? this.getQueue() : this.getHistory()
  }
  async getQueue() {
    try {
      const e = await this.fetchApi('/queue'),
        t = await e.json()
      return {
        Running: t.queue_running.map((e) => ({
          taskType: 'Running',
          prompt: e,
          remove: { name: 'Cancel', cb: __name(() => api.interrupt(), 'cb') }
        })),
        Pending: t.queue_pending.map((e) => ({
          taskType: 'Pending',
          prompt: e
        }))
      }
    } catch (e) {
      return console.error(e), { Running: [], Pending: [] }
    }
  }
  async getHistory(e = 200) {
    try {
      const t = await this.fetchApi(`/history?max_items=${e}`),
        n = await t.json()
      return {
        History: Object.values(n).map((e) => ({ ...e, taskType: 'History' }))
      }
    } catch (t) {
      return console.error(t), { History: [] }
    }
  }
  async getSystemStats() {
    const e = await this.fetchApi('/system_stats')
    return await e.json()
  }
  async #o(e, t) {
    try {
      await this.fetchApi('/' + e, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: t ? JSON.stringify(t) : void 0
      })
    } catch (n) {
      console.error(n)
    }
  }
  async deleteItem(e, t) {
    await this.#o(e, { delete: [t] })
  }
  async clearItems(e) {
    await this.#o(e, { clear: !0 })
  }
  async interrupt() {
    await this.#o('interrupt', null)
  }
  async getUserConfig() {
    return (await this.fetchApi('/users')).json()
  }
  createUser(e) {
    return this.fetchApi('/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username: e })
    })
  }
  async getSettings() {
    return (await this.fetchApi('/settings')).json()
  }
  async getSetting(e) {
    return (await this.fetchApi(`/settings/${encodeURIComponent(e)}`)).json()
  }
  async storeSettings(e) {
    return this.fetchApi('/settings', {
      method: 'POST',
      body: JSON.stringify(e)
    })
  }
  async storeSetting(e, t) {
    return this.fetchApi(`/settings/${encodeURIComponent(e)}`, {
      method: 'POST',
      body: JSON.stringify(t)
    })
  }
  async getUserData(e, t) {
    return this.fetchApi(`/userdata/${encodeURIComponent(e)}`, t)
  }
  async storeUserData(
    e,
    t,
    n = { overwrite: !0, stringify: !0, throwOnError: !0, full_info: !1 }
  ) {
    const o = await this.fetchApi(
      `/userdata/${encodeURIComponent(e)}?overwrite=${n.overwrite}&full_info=${n.full_info}`,
      { method: 'POST', body: n?.stringify ? JSON.stringify(t) : t, ...n }
    )
    if (200 !== o.status && !1 !== n.throwOnError)
      throw new Error(
        `Error storing user data file '${e}': ${o.status} ${(await o).statusText}`
      )
    return o
  }
  async deleteUserData(e) {
    return await this.fetchApi(`/userdata/${encodeURIComponent(e)}`, {
      method: 'DELETE'
    })
  }
  async moveUserData(e, t, n = { overwrite: !1 }) {
    return await this.fetchApi(
      `/userdata/${encodeURIComponent(e)}/move/${encodeURIComponent(t)}?overwrite=${n?.overwrite}`,
      { method: 'POST' }
    )
  }
  async listUserData(e, t, n) {
    const o = await this.fetchApi(
      `/userdata?${new URLSearchParams({ recurse: t ? 'true' : 'false', dir: e, split: n ? 'true' : 'false' })}`
    )
    if (404 === o.status) return []
    if (200 !== o.status)
      throw new Error(
        `Error getting user data list '${e}': ${o.status} ${o.statusText}`
      )
    return o.json()
  }
  async listUserDataFullInfo(e) {
    const t = await this.fetchApi(
      `/userdata?dir=${encodeURIComponent(e)}&recurse=true&split=false&full_info=true`
    )
    if (404 === t.status) return []
    if (200 !== t.status)
      throw new Error(
        `Error getting user data list '${e}': ${t.status} ${t.statusText}`
      )
    return t.json()
  }
  async getLogs() {
    return (await axios.get(this.internalURL('/logs'))).data
  }
  async getRawLogs() {
    return (await axios.get(this.internalURL('/logs/raw'))).data
  }
  async subscribeLogs(e) {
    return await axios.patch(this.internalURL('/logs/subscribe'), {
      enabled: e,
      clientId: this.clientId
    })
  }
  async getFolderPaths() {
    return (await axios.get(this.internalURL('/folder_paths'))).data
  }
}
const api = new ComfyApi()
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.api = window.comfyAPI.api || {}),
  (window.comfyAPI.api.ComfyApi = ComfyApi),
  (window.comfyAPI.api.api = api)
var TaskItemDisplayStatus = ((e) => (
  (e.Running = 'Running'),
  (e.Pending = 'Pending'),
  (e.Completed = 'Completed'),
  (e.Failed = 'Failed'),
  (e.Cancelled = 'Cancelled'),
  e
))(TaskItemDisplayStatus || {})
class ResultItemImpl {
  static {
    __name(this, 'ResultItemImpl')
  }
  filename
  subfolder
  type
  nodeId
  mediaType
  format
  frame_rate
  constructor(e) {
    ;(this.filename = e.filename ?? ''),
      (this.subfolder = e.subfolder ?? ''),
      (this.type = e.type ?? ''),
      (this.nodeId = e.nodeId),
      (this.mediaType = e.mediaType),
      (this.format = e.format),
      (this.frame_rate = e.frame_rate)
  }
  get urlParams() {
    const e = new URLSearchParams()
    return (
      e.set('filename', this.filename),
      e.set('type', this.type),
      e.set('subfolder', this.subfolder),
      this.format && e.set('format', this.format),
      this.frame_rate && e.set('frame_rate', this.frame_rate.toString()),
      e
    )
  }
  get vhsAdvancedPreviewUrl() {
    return api.apiURL('/viewvideo?' + this.urlParams)
  }
  get url() {
    return api.apiURL('/view?' + this.urlParams)
  }
  get urlWithTimestamp() {
    return `${this.url}&t=${+new Date()}`
  }
  get isVhsFormat() {
    return !!this.format && !!this.frame_rate
  }
  get htmlVideoType() {
    const e = void 0
    return this.isVhsFormat
      ? this.format?.endsWith('webm')
        ? 'video/webm'
        : this.format?.endsWith('mp4')
          ? 'video/mp4'
          : e
      : e
  }
  get isVideo() {
    return !this.isImage && !!this.format?.startsWith('video/')
  }
  get isGif() {
    return this.filename.endsWith('.gif')
  }
  get isWebp() {
    return this.filename.endsWith('.webp')
  }
  get isImage() {
    return 'images' === this.mediaType || this.isGif || this.isWebp
  }
  get supportsPreview() {
    return this.isImage || this.isVideo
  }
}
class TaskItemImpl {
  static {
    __name(this, 'TaskItemImpl')
  }
  taskType
  prompt
  status
  outputs
  flatOutputs
  constructor(e, t, n, o, i) {
    ;(this.taskType = e),
      (this.prompt = t),
      (this.status = n),
      (this.outputs = o ?? {}),
      (this.flatOutputs = i ?? this.calculateFlatOutputs())
  }
  calculateFlatOutputs() {
    return this.outputs
      ? Object.entries(this.outputs).flatMap(([e, t]) =>
          Object.entries(t).flatMap(([t, n]) =>
            n.map((n) => new ResultItemImpl({ ...n, nodeId: e, mediaType: t }))
          )
        )
      : []
  }
  get previewOutput() {
    return (
      this.flatOutputs.find((e) => 'output' === e.type && e.supportsPreview) ??
      this.flatOutputs.find((e) => e.supportsPreview)
    )
  }
  get apiTaskType() {
    switch (this.taskType) {
      case 'Running':
      case 'Pending':
        return 'queue'
      case 'History':
        return 'history'
    }
  }
  get key() {
    return this.promptId + this.displayStatus
  }
  get queueIndex() {
    return this.prompt[0]
  }
  get promptId() {
    return this.prompt[1]
  }
  get promptInputs() {
    return this.prompt[2]
  }
  get extraData() {
    return this.prompt[3]
  }
  get outputsToExecute() {
    return this.prompt[4]
  }
  get extraPngInfo() {
    return this.extraData.extra_pnginfo
  }
  get clientId() {
    return this.extraData.client_id
  }
  get workflow() {
    return this.extraPngInfo?.workflow
  }
  get messages() {
    return this.status?.messages || []
  }
  get interrupted() {
    return _.some(this.messages, (e) => 'execution_interrupted' === e[0])
  }
  get isHistory() {
    return 'History' === this.taskType
  }
  get isRunning() {
    return 'Running' === this.taskType
  }
  get displayStatus() {
    switch (this.taskType) {
      case 'Running':
        return 'Running'
      case 'Pending':
        return 'Pending'
      case 'History':
        if (this.interrupted) return 'Cancelled'
        switch (this.status.status_str) {
          case 'success':
            return 'Completed'
          case 'error':
            return 'Failed'
        }
    }
  }
  get executionStartTimestamp() {
    const e = this.messages.find((e) => 'execution_start' === e[0])
    return e ? e[1].timestamp : void 0
  }
  get executionEndTimestamp() {
    const e = this.messages.filter((e) =>
      [
        'execution_success',
        'execution_interrupted',
        'execution_error'
      ].includes(e[0])
    )
    if (e.length) return _.max(e.map((e) => e[1].timestamp))
  }
  get executionTime() {
    if (this.executionStartTimestamp && this.executionEndTimestamp)
      return this.executionEndTimestamp - this.executionStartTimestamp
  }
  get executionTimeInSeconds() {
    return void 0 !== this.executionTime ? this.executionTime / 1e3 : void 0
  }
  async loadWorkflow(e) {
    this.workflow &&
      (await e.loadGraphData(Vue.toRaw(this.workflow)),
      this.outputs && (e.nodeOutputs = Vue.toRaw(this.outputs)))
  }
  flatten() {
    return 'Completed' !== this.displayStatus
      ? [this]
      : this.flatOutputs.map(
          (e, t) =>
            new TaskItemImpl(
              this.taskType,
              [
                this.queueIndex,
                `${this.promptId}-${t}`,
                this.promptInputs,
                this.extraData,
                this.outputsToExecute
              ],
              this.status,
              { [e.nodeId]: { [e.mediaType]: [e] } },
              [e]
            )
        )
  }
}
const useQueueStore = defineStore('queue', () => {
    const e = Vue.ref([]),
      t = Vue.ref([]),
      n = Vue.ref([]),
      o = Vue.ref(64),
      i = Vue.ref(!1),
      r = Vue.computed(() => [...t.value, ...e.value, ...n.value]),
      a = Vue.computed(() => r.value.flatMap((e) => e.flatten())),
      s = Vue.computed(() => (n.value.length ? n.value[0].queueIndex : -1)),
      l = Vue.computed(() => t.value.length > 0),
      c = __name(async () => {
        i.value = !0
        try {
          const [i, r] = await Promise.all([
              api.getQueue(),
              api.getHistory(o.value)
            ]),
            a = __name(
              (e) =>
                e
                  .map(
                    (e) =>
                      new TaskItemImpl(
                        e.taskType,
                        e.prompt,
                        'status' in e ? e.status : void 0,
                        'outputs' in e ? e.outputs : void 0
                      )
                  )
                  .sort((e, t) => t.queueIndex - e.queueIndex),
              'toClassAll'
            )
          ;(e.value = a(i.Running)), (t.value = a(i.Pending))
          const l = new Set(r.History.map((e) => e.prompt[0])),
            c = a(r.History.filter((e) => e.prompt[0] > s.value)),
            d = n.value.filter((e) => l.has(e.queueIndex))
          n.value = [...c, ...d]
            .slice(0, o.value)
            .sort((e, t) => t.queueIndex - e.queueIndex)
        } finally {
          i.value = !1
        }
      }, 'update'),
      d = __name(async (e = ['queue', 'history']) => {
        0 !== e.length &&
          (await Promise.all(e.map((e) => api.clearItems(e))), await c())
      }, 'clear'),
      u = __name(async (e) => {
        await api.deleteItem(e.apiTaskType, e.promptId), await c()
      }, 'deleteTask')
    return {
      runningTasks: e,
      pendingTasks: t,
      historyTasks: n,
      maxHistoryItems: o,
      isLoading: i,
      tasks: r,
      flatTasks: a,
      lastHistoryQueueIndex: s,
      hasPendingTasks: l,
      update: c,
      clear: d,
      delete: u
    }
  }),
  useQueuePendingTaskCountStore = defineStore('queuePendingTaskCount', {
    state: __name(() => ({ count: 0 }), 'state'),
    actions: {
      update(e) {
        this.count = e.detail?.exec_info?.queue_remaining || 0
      }
    }
  }),
  useQueueSettingsStore = defineStore('queueSettingsStore', {
    state: __name(() => ({ mode: 'disabled', batchCount: 1 }), 'state')
  })
function useErrorHandling() {
  const e = useToastStore(),
    { t: t } = VueI18n.useI18n(),
    n = __name((n) => {
      e.add({
        severity: 'error',
        summary: t('error'),
        detail: n.message,
        life: 3e3
      })
    }, 'toastErrorHandler')
  return {
    wrapWithErrorHandling: __name(
      (e, t, o) =>
        (...i) => {
          try {
            return e(...i)
          } catch (e2) {
            ;(t ?? n)(e2)
          } finally {
            o?.()
          }
        },
      'wrapWithErrorHandling'
    ),
    wrapWithErrorHandlingAsync: __name(
      (e, t, o) =>
        async (...i) => {
          try {
            return await e(...i)
          } catch (e2) {
            ;(t ?? n)(e2)
          } finally {
            o?.()
          }
        },
      'wrapWithErrorHandlingAsync'
    )
  }
}
__name(useErrorHandling, 'useErrorHandling')
const scriptRel = 'modulepreload',
  assetsURL = __name(function (e, t) {
    return new URL(e, t).href
  }, 'assetsURL'),
  seen = {},
  __vitePreload = __name(function (e, t, n) {
    let o = Promise.resolve()
    if (t && t.length > 0) {
      const e = document.getElementsByTagName('link'),
        i = document.querySelector('meta[property=csp-nonce]'),
        r = i?.nonce || i?.getAttribute('nonce')
      o = Promise.allSettled(
        t.map((t) => {
          if ((t = assetsURL(t, n)) in seen) return
          seen[t] = !0
          const o = t.endsWith('.css'),
            i = o ? '[rel="stylesheet"]' : ''
          if (!!n)
            for (let n = e.length - 1; n >= 0; n--) {
              const i = e[n]
              if (i.href === t && (!o || 'stylesheet' === i.rel)) return
            }
          else if (document.querySelector(`link[href="${t}"]${i}`)) return
          const a = document.createElement('link')
          return (
            (a.rel = o ? 'stylesheet' : scriptRel),
            o || (a.as = 'script'),
            (a.crossOrigin = ''),
            (a.href = t),
            r && a.setAttribute('nonce', r),
            document.head.appendChild(a),
            o
              ? new Promise((e, n) => {
                  a.addEventListener('load', e),
                    a.addEventListener('error', () =>
                      n(new Error(`Unable to preload CSS for ${t}`))
                    )
                })
              : void 0
          )
        })
      )
    }
    function i(e) {
      const t = new Event('vite:preloadError', { cancelable: !0 })
      if (((t.payload = e), window.dispatchEvent(t), !t.defaultPrevented))
        throw e
    }
    return (
      __name(i, 'handlePreloadError'),
      o.then((t) => {
        for (const e of t || []) 'rejected' === e.status && i(e.reason)
        return e().catch(i)
      })
    )
  }, 'preload')
class LLink {
  static {
    __name(this, 'LLink')
  }
  id
  parentId
  type
  origin_id
  origin_slot
  target_id
  target_slot
  data
  _data
  _pos
  _last_time
  path
  _centreAngle
  #i
  get color() {
    return this.#i
  }
  set color(e) {
    this.#i = '' === e ? null : e
  }
  constructor(e, t, n, o, i, r, a) {
    ;(this.id = e),
      (this.type = t),
      (this.origin_id = n),
      (this.origin_slot = o),
      (this.target_id = i),
      (this.target_slot = r),
      (this.parentId = a),
      (this._data = null),
      (this._pos = new Float32Array(2))
  }
  static createFromArray(e) {
    return new LLink(e[0], e[5], e[1], e[2], e[3], e[4])
  }
  static create(e) {
    return new LLink(
      e.id,
      e.type,
      e.origin_id,
      e.origin_slot,
      e.target_id,
      e.target_slot,
      e.parentId
    )
  }
  static getReroutes(e, t) {
    return e.reroutes.get(t.parentId)?.getReroutes() ?? []
  }
  static findNextReroute(e, t, n) {
    return e.reroutes.get(t.parentId)?.findNextReroute(n)
  }
  configure(e) {
    Array.isArray(e)
      ? ((this.id = e[0]),
        (this.origin_id = e[1]),
        (this.origin_slot = e[2]),
        (this.target_id = e[3]),
        (this.target_slot = e[4]),
        (this.type = e[5]))
      : ((this.id = e.id),
        (this.type = e.type),
        (this.origin_id = e.origin_id),
        (this.origin_slot = e.origin_slot),
        (this.target_id = e.target_id),
        (this.target_slot = e.target_slot),
        (this.parentId = e.parentId))
  }
  disconnect(e, t) {
    const n = LLink.getReroutes(e, this)
    for (const o of n)
      o.linkIds.delete(this.id), t || o.linkIds.size || e.reroutes.delete(o.id)
    e.links.delete(this.id)
  }
  serialize() {
    return [
      this.id,
      this.origin_id,
      this.origin_slot,
      this.target_id,
      this.target_slot,
      this.type
    ]
  }
  asSerialisable() {
    const e = {
      id: this.id,
      origin_id: this.origin_id,
      origin_slot: this.origin_slot,
      target_id: this.target_id,
      target_slot: this.target_slot,
      type: this.type
    }
    return this.parentId && (e.parentId = this.parentId), e
  }
}
var NodeSlotType = ((e) => (
    (e[(e.INPUT = 1)] = 'INPUT'), (e[(e.OUTPUT = 2)] = 'OUTPUT'), e
  ))(NodeSlotType || {}),
  RenderShape = ((e) => (
    (e[(e.BOX = 1)] = 'BOX'),
    (e[(e.ROUND = 2)] = 'ROUND'),
    (e[(e.CIRCLE = 3)] = 'CIRCLE'),
    (e[(e.CARD = 4)] = 'CARD'),
    (e[(e.ARROW = 5)] = 'ARROW'),
    (e[(e.GRID = 6)] = 'GRID'),
    (e[(e.HollowCircle = 7)] = 'HollowCircle'),
    e
  ))(RenderShape || {}),
  CanvasItem = ((e) => (
    (e[(e.Nothing = 0)] = 'Nothing'),
    (e[(e.Node = 1)] = 'Node'),
    (e[(e.Group = 2)] = 'Group'),
    (e[(e.Reroute = 4)] = 'Reroute'),
    (e[(e.Link = 8)] = 'Link'),
    (e[(e.ResizeSe = 16)] = 'ResizeSe'),
    e
  ))(CanvasItem || {}),
  LinkDirection = ((e) => (
    (e[(e.NONE = 0)] = 'NONE'),
    (e[(e.UP = 1)] = 'UP'),
    (e[(e.DOWN = 2)] = 'DOWN'),
    (e[(e.LEFT = 3)] = 'LEFT'),
    (e[(e.RIGHT = 4)] = 'RIGHT'),
    (e[(e.CENTER = 5)] = 'CENTER'),
    e
  ))(LinkDirection || {}),
  LinkRenderType = ((e) => (
    (e[(e.HIDDEN_LINK = -1)] = 'HIDDEN_LINK'),
    (e[(e.STRAIGHT_LINK = 0)] = 'STRAIGHT_LINK'),
    (e[(e.LINEAR_LINK = 1)] = 'LINEAR_LINK'),
    (e[(e.SPLINE_LINK = 2)] = 'SPLINE_LINK'),
    e
  ))(LinkRenderType || {}),
  LinkMarkerShape = ((e) => (
    (e[(e.None = 0)] = 'None'),
    (e[(e.Circle = 1)] = 'Circle'),
    (e[(e.Arrow = 2)] = 'Arrow'),
    e
  ))(LinkMarkerShape || {}),
  TitleMode = ((e) => (
    (e[(e.NORMAL_TITLE = 0)] = 'NORMAL_TITLE'),
    (e[(e.NO_TITLE = 1)] = 'NO_TITLE'),
    (e[(e.TRANSPARENT_TITLE = 2)] = 'TRANSPARENT_TITLE'),
    (e[(e.AUTOHIDE_TITLE = 3)] = 'AUTOHIDE_TITLE'),
    e
  ))(TitleMode || {}),
  LGraphEventMode = ((e) => (
    (e[(e.ALWAYS = 0)] = 'ALWAYS'),
    (e[(e.ON_EVENT = 1)] = 'ON_EVENT'),
    (e[(e.NEVER = 2)] = 'NEVER'),
    (e[(e.ON_TRIGGER = 3)] = 'ON_TRIGGER'),
    (e[(e.BYPASS = 4)] = 'BYPASS'),
    e
  ))(LGraphEventMode || {}),
  EaseFunction = ((e) => (
    (e.LINEAR = 'linear'),
    (e.EASE_IN_QUAD = 'easeInQuad'),
    (e.EASE_OUT_QUAD = 'easeOutQuad'),
    (e.EASE_IN_OUT_QUAD = 'easeInOutQuad'),
    e
  ))(EaseFunction || {})
function distance(e, t) {
  return Math.sqrt(
    (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
  )
}
function dist2(e, t, n, o) {
  return (n - e) * (n - e) + (o - t) * (o - t)
}
function isInRectangle(e, t, n, o, i, r) {
  return e >= n && e < n + i && t >= o && t < o + r
}
function isPointInRect(e, t) {
  return (
    e[0] >= t[0] && e[0] < t[0] + t[2] && e[1] >= t[1] && e[1] < t[1] + t[3]
  )
}
function isInRect(e, t, n) {
  return e >= n[0] && e < n[0] + n[2] && t >= n[1] && t < n[1] + n[3]
}
function isInsideRectangle(e, t, n, o, i, r) {
  return n < e && n + i > e && o < t && o + r > t
}
function isSortaInsideOctagon(e, t, n) {
  return Math.min(n, Math.abs(e)) + Math.min(n, Math.abs(t)) < 0.75 * n
}
function overlapBounding(e, t) {
  const n = e[0] + e[2],
    o = e[1] + e[3],
    i = t[0] + t[2],
    r = t[1] + t[3]
  return !(e[0] > i || e[1] > r || n < t[0] || o < t[1])
}
function containsCentre(e, t) {
  return isInRect(t[0] + 0.5 * t[2], t[1] + 0.5 * t[3], e)
}
function containsRect(e, t) {
  const n = e[0] + e[2],
    o = e[1] + e[3],
    i = t[0] + t[2],
    r = t[1] + t[3]
  return (
    !(e[0] === t[0] && e[1] === t[1] && n === i && o === r) &&
    e[0] <= t[0] &&
    e[1] <= t[1] &&
    n >= i &&
    o >= r
  )
}
function findPointOnCurve(e, t, n, o, i, r = 0.5) {
  const a = 1 - r,
    s = a * a * a,
    l = a * a * 3 * r,
    c = 3 * a * (r * r),
    d = r * r * r
  ;(e[0] = s * t[0] + l * o[0] + c * i[0] + d * n[0]),
    (e[1] = s * t[1] + l * o[1] + c * i[1] + d * n[1])
}
function createBounds(e, t = 10) {
  const n = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0])
  for (const o of e) {
    const e = o.boundingRect
    ;(n[0] = Math.min(n[0], e[0])),
      (n[1] = Math.min(n[1], e[1])),
      (n[2] = Math.max(n[2], e[0] + e[2])),
      (n[3] = Math.max(n[3], e[1] + e[3]))
  }
  return n.every((e) => isFinite(e))
    ? [n[0] - t, n[1] - t, n[2] - n[0] + 2 * t, n[3] - n[1] + 2 * t]
    : null
}
function snapPoint(e, t) {
  return (
    !!t &&
    ((e[0] = t * Math.round(e[0] / t)), (e[1] = t * Math.round(e[1] / t)), !0)
  )
}
__name(distance, 'distance'),
  __name(dist2, 'dist2'),
  __name(isInRectangle, 'isInRectangle'),
  __name(isPointInRect, 'isPointInRect'),
  __name(isInRect, 'isInRect'),
  __name(isInsideRectangle, 'isInsideRectangle'),
  __name(isSortaInsideOctagon, 'isSortaInsideOctagon'),
  __name(overlapBounding, 'overlapBounding'),
  __name(containsCentre, 'containsCentre'),
  __name(containsRect, 'containsRect'),
  __name(findPointOnCurve, 'findPointOnCurve'),
  __name(createBounds, 'createBounds'),
  __name(snapPoint, 'snapPoint')
class Reroute {
  static {
    __name(this, 'Reroute')
  }
  constructor(e, t, n, o, i) {
    ;(this.id = e),
      (this.#r = new WeakRef(t)),
      this.update(o, n, i),
      (this.linkIds ??= new Set())
  }
  static radius = 10
  #a = new Float32Array(8)
  #r
  #s
  get parentId() {
    return this.#s
  }
  set parentId(e) {
    e !== this.id && null !== this.getReroutes() && (this.#s = e)
  }
  #l = this.#a.subarray(0, 2)
  get pos() {
    return this.#l
  }
  set pos(e) {
    if (!(e?.length >= 2))
      throw new TypeError(
        'Reroute.pos is an x,y point, and expects an indexable with at least two values.'
      )
    ;(this.#l[0] = e[0]), (this.#l[1] = e[1])
  }
  get boundingRect() {
    const { radius: e } = Reroute,
      [t, n] = this.#l
    return [t - e, n - e, 2 * e, 2 * e]
  }
  selected
  linkIds
  otherAngle = 0
  cos = 0
  sin = 0
  controlPoint = this.#a.subarray(4, 6)
  path
  _centreAngle
  _pos = this.#a.subarray(6, 8)
  _colour
  #c = -1 / 0
  #d = this.#a.subarray(2, 4)
  get origin_id() {
    return this.#r.deref()?.links.get(this.linkIds.values().next().value)
      ?.origin_id
  }
  get origin_slot() {
    return this.#r.deref()?.links.get(this.linkIds.values().next().value)
      ?.origin_slot
  }
  update(e, t, n) {
    ;(this.parentId = e), t && (this.pos = t), n && (this.linkIds = new Set(n))
  }
  validateLinks(e) {
    const { linkIds: t } = this
    for (const n of t) e.get(n) || t.delete(n)
    return t.size > 0
  }
  getReroutes(e = new Set()) {
    if (void 0 === this.#s) return [this]
    if (e.has(this)) return null
    e.add(this)
    const t = this.#r.deref()?.reroutes.get(this.#s)
    if (!t) return (this.#s = void 0), [this]
    const n = t.getReroutes(e)
    return n?.push(this), n
  }
  findNextReroute(e, t = new Set()) {
    return this.#s === e
      ? this
      : t.has(this)
        ? null
        : (t.add(this),
          this.#r.deref()?.reroutes.get(this.#s)?.findNextReroute(e, t))
  }
  move(e, t) {
    ;(this.#l[0] += e), (this.#l[1] += t)
  }
  snapToGrid(e) {
    if (!e) return !1
    const { pos: t } = this
    return (
      (t[0] = e * Math.round(t[0] / e)), (t[1] = e * Math.round(t[1] / e)), !0
    )
  }
  calculateAngle(e, t, n) {
    if (!(e > this.#c)) return
    this.#c = e
    const { links: o } = t,
      { linkIds: i, id: r } = this,
      a = []
    let s = 0
    for (const m of i) {
      const e = o.get(m)
      if (!e) continue
      const n =
        LLink.findNextReroute(t, e, r)?.pos ??
        t.getNodeById(e.target_id)?.getConnectionPos(!0, e.target_slot, this.#d)
      if (!n) continue
      const i = Math.atan2(n[1] - this.#l[1], n[0] - this.#l[0])
      a.push(i), (s += i)
    }
    if (!a.length) return
    s /= a.length
    const l = Math.atan2(this.#l[1] - n[1], this.#l[0] - n[0])
    let c = 0.5 * (l - s)
    Math.abs(c) > 0.5 * Math.PI && (c += Math.PI)
    const d = Math.min(80, 0.25 * distance(n, this.#l)),
      u = l - c,
      p = Math.cos(u),
      h = Math.sin(u)
    ;(this.otherAngle = u),
      (this.cos = p),
      (this.sin = h),
      (this.controlPoint[0] = d * -p),
      (this.controlPoint[1] = d * -h)
  }
  draw(e) {
    const { pos: t } = this
    ;(e.fillStyle = this._colour),
      e.beginPath(),
      e.arc(t[0], t[1], Reroute.radius, 0, 2 * Math.PI),
      e.fill(),
      (e.lineWidth = 1),
      (e.strokeStyle = 'rgb(0,0,0,0.5)'),
      e.stroke(),
      (e.fillStyle = '#ffffff55'),
      (e.strokeStyle = 'rgb(0,0,0,0.3)'),
      e.beginPath(),
      e.arc(t[0], t[1], 8, 0, 2 * Math.PI),
      e.fill(),
      e.stroke(),
      this.selected &&
        ((e.strokeStyle = '#fff'),
        e.beginPath(),
        e.arc(t[0], t[1], 12, 0, 2 * Math.PI),
        e.stroke())
  }
  asSerialisable() {
    return {
      id: this.id,
      parentId: this.parentId,
      pos: [this.pos[0], this.pos[1]],
      linkIds: [...this.linkIds]
    }
  }
}
var BadgePosition = ((e) => (
  (e.TopLeft = 'top-left'), (e.TopRight = 'top-right'), e
))(BadgePosition || {})
class LGraphBadge {
  static {
    __name(this, 'LGraphBadge')
  }
  text
  fgColor
  bgColor
  fontSize
  padding
  height
  cornerRadius
  constructor({
    text: e,
    fgColor: t = 'white',
    bgColor: n = '#0F1F0F',
    fontSize: o = 12,
    padding: i = 6,
    height: r = 20,
    cornerRadius: a = 5
  }) {
    ;(this.text = e),
      (this.fgColor = t),
      (this.bgColor = n),
      (this.fontSize = o),
      (this.padding = i),
      (this.height = r),
      (this.cornerRadius = a)
  }
  get visible() {
    return this.text.length > 0
  }
  getWidth(e) {
    if (!this.visible) return 0
    const { font: t } = e
    e.font = `${this.fontSize}px sans-serif`
    const n = e.measureText(this.text).width
    return (e.font = t), n + 2 * this.padding
  }
  draw(e, t, n) {
    if (!this.visible) return
    const { fillStyle: o } = e
    e.font = `${this.fontSize}px sans-serif`
    const i = this.getWidth(e)
    ;(e.fillStyle = this.bgColor),
      e.beginPath(),
      e.roundRect
        ? e.roundRect(t + 0, n, i, this.height, this.cornerRadius)
        : e.rect(t + 0, n, i, this.height),
      e.fill(),
      (e.fillStyle = this.fgColor),
      e.fillText(
        this.text,
        t + 0 + this.padding,
        n + this.height - this.padding
      ),
      (e.fillStyle = o)
  }
}
class LGraphNode {
  static {
    __name(this, 'LGraphNode')
  }
  static title
  static MAX_CONSOLE
  static type
  static category
  static supported_extensions
  static filter
  static skip_list
  static keepAllLinksOnBypass = !1
  title
  graph = null
  id
  type = null
  inputs = []
  outputs = []
  connections = []
  properties = {}
  properties_info = []
  flags = {}
  widgets
  locked
  order
  mode
  last_serialization
  serialize_widgets
  color
  bgcolor
  boxcolor
  exec_version
  action_call
  execute_triggered
  action_triggered
  widgets_up
  widgets_start_y
  lostFocusAt
  gotFocusAt
  badges = []
  badgePosition = BadgePosition.TopLeft
  _collapsed_width
  horizontal
  console
  _level
  _shape
  subgraph
  skip_subgraph_button
  mouseOver
  redraw_on_mouse
  optional_inputs
  optional_outputs
  resizable
  clonable
  _relative_id
  clip_area
  ignore_remove
  has_errors
  removable
  block_delete
  selected
  showAdvanced
  #u = new Float32Array(4)
  get renderArea() {
    return this.#u
  }
  #p = new Float32Array(4)
  get boundingRect() {
    return this.#p
  }
  _posSize = new Float32Array(4)
  _pos = this._posSize.subarray(0, 2)
  _size = this._posSize.subarray(2, 4)
  get pos() {
    return this._pos
  }
  set pos(e) {
    !e || e.length < 2 || ((this._pos[0] = e[0]), (this._pos[1] = e[1]))
  }
  get size() {
    return this._size
  }
  set size(e) {
    !e || e.length < 2 || ((this._size[0] = e[0]), (this._size[1] = e[1]))
  }
  get shape() {
    return this._shape
  }
  set shape(e) {
    switch (e) {
      case 'default':
        delete this._shape
        break
      case 'box':
        this._shape = RenderShape.BOX
        break
      case 'round':
        this._shape = RenderShape.ROUND
        break
      case 'circle':
        this._shape = RenderShape.CIRCLE
        break
      case 'card':
        this._shape = RenderShape.CARD
        break
      default:
        this._shape = e
    }
  }
  get is_selected() {
    return this.selected
  }
  set is_selected(e) {
    this.selected = e
  }
  constructor(e) {
    ;(this.id = LiteGraph.use_uuids ? LiteGraph.uuidv4() : -1),
      (this.title = e || 'Unnamed'),
      (this.size = [LiteGraph.NODE_WIDTH, 60]),
      (this.pos = [10, 10])
  }
  configure(e) {
    this.graph && this.graph._version++
    for (const t in e)
      if ('properties' != t)
        null != e[t] &&
          ('object' == typeof e[t]
            ? this[t]?.configure
              ? this[t]?.configure(e[t])
              : (this[t] = LiteGraph.cloneObject(e[t], this[t]))
            : (this[t] = e[t]))
      else
        for (const n in e.properties)
          (this.properties[n] = e.properties[n]),
            this.onPropertyChanged?.(n, e.properties[n])
    if ((e.title || (this.title = this.constructor.title), this.inputs))
      for (let t = 0; t < this.inputs.length; ++t) {
        const e = this.inputs[t],
          n = this.graph ? this.graph._links.get(e.link) : null
        this.onConnectionsChange?.(NodeSlotType.INPUT, t, !0, n, e),
          this.onInputAdded?.(e)
      }
    if (this.outputs)
      for (let t = 0; t < this.outputs.length; ++t) {
        const e = this.outputs[t]
        if (e.links) {
          for (let n = 0; n < e.links.length; ++n) {
            const o = this.graph ? this.graph._links.get(e.links[n]) : null
            this.onConnectionsChange?.(NodeSlotType.OUTPUT, t, !0, o, e)
          }
          this.onOutputAdded?.(e)
        }
      }
    if (this.widgets) {
      for (let e = 0; e < this.widgets.length; ++e) {
        const t = this.widgets[e]
        t &&
          t.options?.property &&
          null != this.properties[t.options.property] &&
          (t.value = JSON.parse(
            JSON.stringify(this.properties[t.options.property])
          ))
      }
      if (e.widgets_values)
        for (let t = 0; t < e.widgets_values.length; ++t)
          this.widgets[t] && (this.widgets[t].value = e.widgets_values[t])
    }
    this.pinned && this.pin(!0), this.onConfigure?.(e)
  }
  serialize() {
    const e = {
      id: this.id,
      type: this.type,
      pos: [this.pos[0], this.pos[1]],
      size: [this.size[0], this.size[1]],
      flags: LiteGraph.cloneObject(this.flags),
      order: this.order,
      mode: this.mode,
      showAdvanced: this.showAdvanced
    }
    if (this.constructor === LGraphNode && this.last_serialization)
      return this.last_serialization
    if ((this.inputs && (e.inputs = this.inputs), this.outputs)) {
      for (let e = 0; e < this.outputs.length; e++) delete this.outputs[e]._data
      e.outputs = this.outputs
    }
    if (
      (this.title &&
        this.title != this.constructor.title &&
        (e.title = this.title),
      this.properties &&
        (e.properties = LiteGraph.cloneObject(this.properties)),
      this.widgets && this.serialize_widgets)
    ) {
      e.widgets_values = []
      for (let t = 0; t < this.widgets.length; ++t)
        this.widgets[t]
          ? (e.widgets_values[t] = this.widgets[t].value)
          : (e.widgets_values[t] = null)
    }
    return (
      e.type || (e.type = this.constructor.type),
      this.color && (e.color = this.color),
      this.bgcolor && (e.bgcolor = this.bgcolor),
      this.boxcolor && (e.boxcolor = this.boxcolor),
      this.shape && (e.shape = this.shape),
      this.onSerialize?.(e) &&
        console.warn(
          'node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter'
        ),
      e
    )
  }
  clone() {
    const e = LiteGraph.createNode(this.type)
    if (!e) return null
    const t = LiteGraph.cloneObject(this.serialize())
    if (t.inputs)
      for (let n = 0; n < t.inputs.length; ++n) t.inputs[n].link = null
    if (t.outputs)
      for (let n = 0; n < t.outputs.length; ++n)
        t.outputs[n].links && (t.outputs[n].links.length = 0)
    return (
      delete t.id,
      LiteGraph.use_uuids && (t.id = LiteGraph.uuidv4()),
      e.configure(t),
      e
    )
  }
  toString() {
    return JSON.stringify(this.serialize())
  }
  getTitle() {
    return this.title || this.constructor.title
  }
  setProperty(e, t) {
    if (((this.properties ||= {}), t === this.properties[e])) return
    const n = this.properties[e]
    if (
      ((this.properties[e] = t),
      !1 === this.onPropertyChanged?.(e, t, n) && (this.properties[e] = n),
      this.widgets)
    )
      for (let o = 0; o < this.widgets.length; ++o) {
        const n = this.widgets[o]
        if (n && n.options.property == e) {
          n.value = t
          break
        }
      }
  }
  setOutputData(e, t) {
    if (!this.outputs) return
    if (-1 == e || e >= this.outputs.length) return
    const n = this.outputs[e]
    if (n && ((n._data = t), this.outputs[e].links))
      for (let o = 0; o < this.outputs[e].links.length; o++) {
        const n = this.outputs[e].links[o],
          i = this.graph._links.get(n)
        i && (i.data = t)
      }
  }
  setOutputDataType(e, t) {
    if (!this.outputs) return
    if (-1 == e || e >= this.outputs.length) return
    const n = this.outputs[e]
    if (n && ((n.type = t), this.outputs[e].links))
      for (let o = 0; o < this.outputs[e].links.length; o++) {
        const n = this.outputs[e].links[o]
        this.graph._links.get(n).type = t
      }
  }
  getInputData(e, t) {
    if (!this.inputs) return
    if (e >= this.inputs.length || null == this.inputs[e].link) return
    const n = this.inputs[e].link,
      o = this.graph._links.get(n)
    if (!o) return null
    if (!t) return o.data
    const i = this.graph.getNodeById(o.origin_id)
    return i
      ? (i.updateOutputData
          ? i.updateOutputData(o.origin_slot)
          : i.onExecute?.(),
        o.data)
      : o.data
  }
  getInputDataType(e) {
    if (!this.inputs) return null
    if (e >= this.inputs.length || null == this.inputs[e].link) return null
    const t = this.inputs[e].link,
      n = this.graph._links.get(t)
    if (!n) return null
    const o = this.graph.getNodeById(n.origin_id)
    if (!o) return n.type
    const i = o.outputs[n.origin_slot]
    return i ? i.type : null
  }
  getInputDataByName(e, t) {
    const n = this.findInputSlot(e)
    return -1 == n ? null : this.getInputData(n, t)
  }
  isInputConnected(e) {
    return (
      !!this.inputs && e < this.inputs.length && null != this.inputs[e].link
    )
  }
  getInputInfo(e) {
    return this.inputs && e < this.inputs.length ? this.inputs[e] : null
  }
  getInputLink(e) {
    if (!this.inputs) return null
    if (e < this.inputs.length) {
      const t = this.inputs[e]
      return this.graph._links.get(t.link)
    }
    return null
  }
  getInputNode(e) {
    if (!this.inputs) return null
    if (e >= this.inputs.length) return null
    const t = this.inputs[e]
    if (!t || null === t.link) return null
    const n = this.graph._links.get(t.link)
    return n ? this.graph.getNodeById(n.origin_id) : null
  }
  getInputOrProperty(e) {
    if (!this.inputs || !this.inputs.length)
      return this.properties ? this.properties[e] : null
    for (let t = 0, n = this.inputs.length; t < n; ++t) {
      const n = this.inputs[t]
      if (e == n.name && null != n.link) {
        const e = this.graph._links.get(n.link)
        if (e) return e.data
      }
    }
    return this.properties[e]
  }
  getOutputData(e) {
    if (!this.outputs) return null
    if (e >= this.outputs.length) return null
    return this.outputs[e]._data
  }
  getOutputInfo(e) {
    return this.outputs && e < this.outputs.length ? this.outputs[e] : null
  }
  isOutputConnected(e) {
    return (
      !!this.outputs &&
      e < this.outputs.length &&
      this.outputs[e].links?.length > 0
    )
  }
  isAnyOutputConnected() {
    if (!this.outputs) return !1
    for (let e = 0; e < this.outputs.length; ++e)
      if (this.outputs[e].links && this.outputs[e].links.length) return !0
    return !1
  }
  getOutputNodes(e) {
    if (!this.outputs || 0 == this.outputs.length) return null
    if (e >= this.outputs.length) return null
    const t = this.outputs[e]
    if (!t.links || 0 == t.links.length) return null
    const n = []
    for (let o = 0; o < t.links.length; o++) {
      const e = t.links[o],
        i = this.graph._links.get(e)
      if (i) {
        const e = this.graph.getNodeById(i.target_id)
        e && n.push(e)
      }
    }
    return n
  }
  addOnTriggerInput() {
    const e = this.findInputSlot('onTrigger')
    return -1 == e
      ? (this.addInput('onTrigger', LiteGraph.EVENT, {
          optional: !0,
          nameLocked: !0
        }),
        this.findInputSlot('onTrigger'))
      : e
  }
  addOnExecutedOutput() {
    const e = this.findOutputSlot('onExecuted')
    return -1 == e
      ? (this.addOutput('onExecuted', LiteGraph.ACTION, {
          optional: !0,
          nameLocked: !0
        }),
        this.findOutputSlot('onExecuted'))
      : e
  }
  onAfterExecuteNode(e, t) {
    const n = this.findOutputSlot('onExecuted')
    ;-1 != n && this.triggerSlot(n, e, null, t)
  }
  changeMode(e) {
    switch (e) {
      case LGraphEventMode.ON_EVENT:
        break
      case LGraphEventMode.ON_TRIGGER:
        this.addOnTriggerInput(), this.addOnExecutedOutput()
        break
      case LGraphEventMode.NEVER:
      case LGraphEventMode.ALWAYS:
      case LiteGraph.ON_REQUEST:
        break
      default:
        return !1
    }
    return (this.mode = e), !0
  }
  doExecute(e, t) {
    ;(t = t || {}),
      this.onExecute &&
        ((t.action_call ||=
          this.id + '_exec_' + Math.floor(9999 * Math.random())),
        (this.graph.nodes_executing[this.id] = !0),
        this.onExecute(e, t),
        (this.graph.nodes_executing[this.id] = !1),
        (this.exec_version = this.graph.iteration),
        t?.action_call &&
          ((this.action_call = t.action_call),
          (this.graph.nodes_executedAction[this.id] = t.action_call))),
      (this.execute_triggered = 2),
      this.onAfterExecuteNode?.(e, t)
  }
  actionDo(e, t, n) {
    ;(n = n || {}),
      this.onAction &&
        ((n.action_call ||=
          this.id +
          '_' +
          (e || 'action') +
          '_' +
          Math.floor(9999 * Math.random())),
        (this.graph.nodes_actioning[this.id] = e || 'actioning'),
        this.onAction(e, t, n),
        (this.graph.nodes_actioning[this.id] = !1),
        n?.action_call &&
          ((this.action_call = n.action_call),
          (this.graph.nodes_executedAction[this.id] = n.action_call))),
      (this.action_triggered = 2),
      this.onAfterExecuteNode?.(t, n)
  }
  trigger(e, t, n) {
    if (this.outputs && this.outputs.length) {
      this.graph && (this.graph._last_trigger_time = LiteGraph.getTime())
      for (let o = 0; o < this.outputs.length; ++o) {
        const i = this.outputs[o]
        !i ||
          i.type !== LiteGraph.EVENT ||
          (e && i.name != e) ||
          this.triggerSlot(o, t, null, n)
      }
    }
  }
  triggerSlot(e, t, n, o) {
    if (((o = o || {}), !this.outputs)) return
    if (null == e) return void console.error('slot must be a number')
    'number' != typeof e &&
      console.warn(
        "slot must be a number, use node.trigger('name') if you want to use a string"
      )
    const i = this.outputs[e]
    if (!i) return
    const r = i.links
    if (r && r.length) {
      this.graph && (this.graph._last_trigger_time = LiteGraph.getTime())
      for (let e = 0; e < r.length; ++e) {
        const i = r[e]
        if (null != n && n != i) continue
        const a = this.graph._links.get(i)
        if (!a) continue
        a._last_time = LiteGraph.getTime()
        const s = this.graph.getNodeById(a.target_id)
        if (s)
          if (s.mode === LGraphEventMode.ON_TRIGGER)
            o.action_call ||
              (o.action_call =
                this.id + '_trigg_' + Math.floor(9999 * Math.random())),
              s.doExecute?.(t, o)
          else if (s.onAction) {
            o.action_call ||
              (o.action_call =
                this.id + '_act_' + Math.floor(9999 * Math.random()))
            const e = s.inputs[a.target_slot]
            s.actionDo(e.name, t, o)
          }
      }
    }
  }
  clearTriggeredSlot(e, t) {
    if (!this.outputs) return
    const n = this.outputs[e]
    if (!n) return
    const o = n.links
    if (o && o.length)
      for (let i = 0; i < o.length; ++i) {
        const e = o[i]
        if (null != t && t != e) continue
        const n = this.graph._links.get(e)
        n && (n._last_time = 0)
      }
  }
  setSize(e) {
    ;(this.size = e), this.onResize?.(this.size)
  }
  addProperty(e, t, n, o) {
    const i = { name: e, type: n, default_value: t }
    if (o) for (const r in o) i[r] = o[r]
    return (
      (this.properties_info ||= []),
      this.properties_info.push(i),
      (this.properties ||= {}),
      (this.properties[e] = t),
      i
    )
  }
  addOutput(e, t, n) {
    const o = { name: e, type: t, links: null }
    if (n) for (const i in n) o[i] = n[i]
    return (
      (this.outputs ||= []),
      this.outputs.push(o),
      this.onOutputAdded?.(o),
      LiteGraph.auto_load_slot_types &&
        LiteGraph.registerNodeAndSlotType(this, t, !0),
      this.setSize(this.computeSize()),
      this.setDirtyCanvas(!0, !0),
      o
    )
  }
  addOutputs(e) {
    for (let t = 0; t < e.length; ++t) {
      const n = e[t],
        o = { name: n[0], type: n[1], links: null }
      if (e[2]) for (const e in n[2]) o[e] = n[2][e]
      ;(this.outputs ||= []),
        this.outputs.push(o),
        this.onOutputAdded?.(o),
        LiteGraph.auto_load_slot_types &&
          LiteGraph.registerNodeAndSlotType(this, n[1], !0)
    }
    this.setSize(this.computeSize()), this.setDirtyCanvas(!0, !0)
  }
  removeOutput(e) {
    this.disconnectOutput(e), this.outputs.splice(e, 1)
    for (let t = e; t < this.outputs.length; ++t) {
      if (!this.outputs[t] || !this.outputs[t].links) continue
      const e = this.outputs[t].links
      for (let t = 0; t < e.length; ++t) {
        const n = this.graph._links.get(e[t])
        n && (n.origin_slot -= 1)
      }
    }
    this.setSize(this.computeSize()),
      this.onOutputRemoved?.(e),
      this.setDirtyCanvas(!0, !0)
  }
  addInput(e, t, n) {
    const o = { name: e, type: (t = t || 0), link: null }
    if (n) for (const i in n) o[i] = n[i]
    return (
      (this.inputs ||= []),
      this.inputs.push(o),
      this.setSize(this.computeSize()),
      this.onInputAdded?.(o),
      LiteGraph.registerNodeAndSlotType(this, t),
      this.setDirtyCanvas(!0, !0),
      o
    )
  }
  addInputs(e) {
    for (let t = 0; t < e.length; ++t) {
      const n = e[t],
        o = { name: n[0], type: n[1], link: null }
      if (e[2]) for (const e in n[2]) o[e] = n[2][e]
      ;(this.inputs ||= []),
        this.inputs.push(o),
        this.onInputAdded?.(o),
        LiteGraph.registerNodeAndSlotType(this, n[1])
    }
    this.setSize(this.computeSize()), this.setDirtyCanvas(!0, !0)
  }
  removeInput(e) {
    this.disconnectInput(e)
    const t = this.inputs.splice(e, 1)
    for (let n = e; n < this.inputs.length; ++n) {
      if (!this.inputs[n]) continue
      const e = this.graph._links.get(this.inputs[n].link)
      e && (e.target_slot -= 1)
    }
    this.setSize(this.computeSize()),
      this.onInputRemoved?.(e, t[0]),
      this.setDirtyCanvas(!0, !0)
  }
  addConnection(e, t, n, o) {
    const i = { name: e, type: t, pos: n, direction: o, links: null }
    return this.connections.push(i), i
  }
  computeSize(e) {
    const t = this.constructor.size
    if (t) return [t[0], t[1]]
    let n = Math.max(
      this.inputs ? this.inputs.length : 1,
      this.outputs ? this.outputs.length : 1
    )
    const o = e || new Float32Array([0, 0])
    n = Math.max(n, 1)
    const i = LiteGraph.NODE_TEXT_SIZE,
      r = c(this.title)
    let a = 0,
      s = 0
    if (this.inputs)
      for (let d = 0, u = this.inputs.length; d < u; ++d) {
        const e = this.inputs[d],
          t = c(e.label || e.name || '')
        a < t && (a = t)
      }
    if (this.outputs)
      for (let d = 0, u = this.outputs.length; d < u; ++d) {
        const e = this.outputs[d],
          t = c(e.label || e.name || '')
        s < t && (s = t)
      }
    ;(o[0] = Math.max(a + s + 10, r)),
      (o[0] = Math.max(o[0], LiteGraph.NODE_WIDTH)),
      this.widgets?.length &&
        (o[0] = Math.max(o[0], 1.5 * LiteGraph.NODE_WIDTH)),
      (o[1] =
        (this.constructor.slot_start_y || 0) + n * LiteGraph.NODE_SLOT_HEIGHT)
    let l = 0
    if (this.widgets?.length) {
      for (let e = 0, t = this.widgets.length; e < t; ++e) {
        const t = this.widgets[e]
        t.hidden ||
          (t.advanced && !this.showAdvanced) ||
          (l += t.computeSize
            ? t.computeSize(o[0])[1] + 4
            : LiteGraph.NODE_WIDGET_HEIGHT + 4)
      }
      l += 8
    }
    function c(e) {
      return e ? i * e.length * 0.6 : 0
    }
    return (
      this.widgets_up
        ? (o[1] = Math.max(o[1], l))
        : null != this.widgets_start_y
          ? (o[1] = Math.max(o[1], l + this.widgets_start_y))
          : (o[1] += l),
      __name(c, 'compute_text_size'),
      this.constructor.min_height &&
        o[1] < this.constructor.min_height &&
        (o[1] = this.constructor.min_height),
      (o[1] += 6),
      o
    )
  }
  inResizeCorner(e, t) {
    const n = this.outputs ? this.outputs.length : 1,
      o = (this.constructor.slot_start_y || 0) + n * LiteGraph.NODE_SLOT_HEIGHT
    return isInRectangle(
      e,
      t,
      this.pos[0] + this.size[0] - 15,
      this.pos[1] + Math.max(this.size[1] - 15, o),
      20,
      20
    )
  }
  getPropertyInfo(e) {
    let t = null
    if (this.properties_info)
      for (let n = 0; n < this.properties_info.length; ++n)
        if (this.properties_info[n].name == e) {
          t = this.properties_info[n]
          break
        }
    return (
      this.constructor['@' + e] && (t = this.constructor['@' + e]),
      this.constructor.widgets_info?.[e] &&
        (t = this.constructor.widgets_info[e]),
      !t && this.onGetPropertyInfo && (t = this.onGetPropertyInfo(e)),
      (t ||= {}),
      (t.type ||= typeof this.properties[e]),
      'combo' == t.widget && (t.type = 'enum'),
      t
    )
  }
  addWidget(e, t, n, o, i) {
    ;(this.widgets ||= []),
      !i && o && 'object' == typeof o && ((i = o), (o = null)),
      i && 'string' == typeof i && (i = { property: i }),
      o && 'string' == typeof o && ((i ||= {}), (i.property = o), (o = null)),
      o &&
        'function' != typeof o &&
        (console.warn('addWidget: callback must be a function'), (o = null))
    const r = {
      type: e.toLowerCase(),
      name: t,
      value: n,
      callback: o,
      options: i || {}
    }
    if (
      (void 0 !== r.options.y && (r.y = r.options.y),
      o ||
        r.options.callback ||
        r.options.property ||
        console.warn(
          'LiteGraph addWidget(...) without a callback or property assigned'
        ),
      'combo' == e && !r.options.values)
    )
      throw "LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }"
    return this.widgets.push(r), this.setSize(this.computeSize()), r
  }
  addCustomWidget(e) {
    return (this.widgets ||= []), this.widgets.push(e), e
  }
  move(e, t) {
    this.pinned || ((this.pos[0] += e), (this.pos[1] += t))
  }
  measure(e, t = 0) {
    const n = this.constructor.title_mode,
      o =
        n != TitleMode.TRANSPARENT_TITLE && n != TitleMode.NO_TITLE
          ? LiteGraph.NODE_TITLE_HEIGHT
          : 0
    ;(e[0] = this.pos[0] - t),
      (e[1] = this.pos[1] + -o - t),
      this.flags?.collapsed
        ? ((e[2] =
            (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) + 2 * t),
          (e[3] = LiteGraph.NODE_TITLE_HEIGHT + 2 * t))
        : ((e[2] = this.size[0] + 2 * t), (e[3] = this.size[1] + o + 2 * t))
  }
  getBounding(e, t) {
    e ||= new Float32Array(4)
    const n = t ? this.renderArea : this.boundingRect
    return (e[0] = n[0]), (e[1] = n[1]), (e[2] = n[2]), (e[3] = n[3]), e
  }
  updateArea() {
    const e = this.#p
    this.measure(e), this.onBounding?.(e)
    const t = this.#u
    t.set(e), (t[0] -= 4), (t[1] -= 4), (t[2] += 10), (t[3] += 9)
  }
  isPointInside(e, t) {
    return isInRect(e, t, this.boundingRect)
  }
  isPointInCollapse(e, t) {
    const n = LiteGraph.NODE_TITLE_HEIGHT
    return isInRectangle(e, t, this.pos[0], this.pos[1] - n, n, n)
  }
  getSlotInPosition(e, t) {
    const n = new Float32Array(2)
    if (this.inputs)
      for (let o = 0, i = this.inputs.length; o < i; ++o) {
        const i = this.inputs[o]
        if (
          (this.getConnectionPos(!0, o, n),
          isInRectangle(e, t, n[0] - 10, n[1] - 5, 20, 10))
        )
          return { input: i, slot: o, link_pos: n }
      }
    if (this.outputs)
      for (let o = 0, i = this.outputs.length; o < i; ++o) {
        const i = this.outputs[o]
        if (
          (this.getConnectionPos(!1, o, n),
          isInRectangle(e, t, n[0] - 10, n[1] - 5, 20, 10))
        )
          return { output: i, slot: o, link_pos: n }
      }
    return null
  }
  getWidgetOnPos(e, t, n = !1) {
    const { widgets: o, pos: i, size: r } = this
    if (!o?.length) return null
    const a = e - i[0],
      s = t - i[1],
      l = r[0]
    for (const c of o) {
      if (
        !c ||
        (c.disabled && !n) ||
        c.hidden ||
        (c.advanced && !this.showAdvanced)
      )
        continue
      const e = c.computeSize
          ? c.computeSize(l)[1]
          : LiteGraph.NODE_WIDGET_HEIGHT,
        t = c.width || l
      if (void 0 !== c.last_y && isInRectangle(a, s, 6, c.last_y, t - 12, e))
        return c
    }
    return null
  }
  findInputSlot(e, t = !1) {
    if (!this.inputs) return -1
    for (let n = 0, o = this.inputs.length; n < o; ++n)
      if (e == this.inputs[n].name) return t ? this.inputs[n] : n
    return -1
  }
  findOutputSlot(e, t = !1) {
    if (!this.outputs) return -1
    for (let n = 0, o = this.outputs.length; n < o; ++n)
      if (e == this.outputs[n].name) return t ? this.outputs[n] : n
    return -1
  }
  findInputSlotFree(e) {
    return this.#h(this.inputs, e)
  }
  findOutputSlotFree(e) {
    return this.#h(this.outputs, e)
  }
  #h(e, t) {
    const n = Object.assign({ returnObj: !1, typesNotAccepted: [] }, t || {}),
      o = e?.length
    if (!(o > 0)) return -1
    for (let i = 0; i < o; ++i) {
      const t = e[i]
      if (
        t &&
        !t.link &&
        !t.links?.length &&
        !n.typesNotAccepted?.includes?.(t.type)
      )
        return n.returnObj ? t : i
    }
    return -1
  }
  findInputSlotByType(e, t, n, o) {
    return this.#m(this.inputs, e, t, n, o)
  }
  findOutputSlotByType(e, t, n, o) {
    return this.#m(this.outputs, e, t, n, o)
  }
  findSlotByType(e, t, n, o, i) {
    return e
      ? this.#m(this.inputs, t, n, o, i)
      : this.#m(this.outputs, t, n, o, i)
  }
  #m(e, t, n, o, i) {
    const r = e?.length
    if (!r) return -1
    ;('' != t && '*' != t) || (t = 0)
    const a = String(t).toLowerCase().split(',')
    let s = null
    for (let l = 0; l < r; ++l) {
      const t = e[l],
        i =
          '0' == t.type || '*' == t.type
            ? ['0']
            : String(t.type).toLowerCase().split(',')
      for (const e of a) {
        const r = '_event_' == e ? LiteGraph.EVENT : e
        for (const e of i) {
          const i = '_event_' == e ? LiteGraph.EVENT : e
          if (r == i || '*' === r || '*' === i) {
            if (o && (t.links?.length || null != t.link)) {
              s ??= n ? t : l
              continue
            }
            return n ? t : l
          }
        }
      }
    }
    return i ? -1 : (s ?? -1)
  }
  findConnectByTypeSlot(e, t, n, o) {
    o &&
      'object' == typeof o &&
      ('firstFreeIfInputGeneralInCase' in o &&
        (o.wildcardToTyped = !!o.firstFreeIfInputGeneralInCase),
      'firstFreeIfOutputGeneralInCase' in o &&
        (o.wildcardToTyped = !!o.firstFreeIfOutputGeneralInCase),
      'generalTypeInCase' in o && (o.typedToWildcard = !!o.generalTypeInCase))
    const i = Object.assign(
      { createEventInCase: !0, wildcardToTyped: !0, typedToWildcard: !0 },
      o
    )
    t && 'number' == typeof t && (t = this.graph.getNodeById(t))
    const r = t.findSlotByType(e, n, !1, !0)
    if (r >= 0 && null !== r) return r
    if (i.createEventInCase && n == LiteGraph.EVENT) {
      if (e) return -1
      if (LiteGraph.do_add_triggers_slots) return t.addOnExecutedOutput()
    }
    if (i.typedToWildcard) {
      const n = t.findSlotByType(e, 0, !1, !0, !0)
      if (n >= 0) return n
    }
    if (i.wildcardToTyped && (0 == n || '*' == n || '' == n)) {
      const n = { typesNotAccepted: [LiteGraph.EVENT] },
        o = e ? t.findInputSlotFree(n) : t.findOutputSlotFree(n)
      if (o >= 0) return o
    }
    return null
  }
  connectByType(e, t, n, o) {
    const i = this.findConnectByTypeSlot(!0, t, n, o)
    return null !== i
      ? this.connect(e, t, i, o?.afterRerouteId)
      : (console.debug(
          '[connectByType]: no way to connect type: ',
          n,
          ' to node: ',
          t
        ),
        null)
  }
  connectByTypeOutput(e, t, n, o) {
    'object' == typeof o &&
      ('firstFreeIfInputGeneralInCase' in o &&
        (o.wildcardToTyped = !!o.firstFreeIfInputGeneralInCase),
      'generalTypeInCase' in o && (o.typedToWildcard = !!o.generalTypeInCase))
    const i = this.findConnectByTypeSlot(!1, t, n, o)
    return null !== i
      ? t.connect(i, this, e, o?.afterRerouteId)
      : (console.debug(
          '[connectByType]: no way to connect type: ',
          n,
          ' to node: ',
          t
        ),
        null)
  }
  connect(e, t, n, o) {
    let i
    const r = this.graph
    if (!r)
      return (
        console.log(
          "Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them."
        ),
        null
      )
    if ('string' == typeof e) {
      if (-1 == (e = this.findOutputSlot(e)))
        return (
          LiteGraph.debug &&
            console.log('Connect: Error, no slot of name ' + e),
          null
        )
    } else if (!this.outputs || e >= this.outputs.length)
      return (
        LiteGraph.debug && console.log('Connect: Error, slot number not found'),
        null
      )
    if ((t && 'number' == typeof t && (t = r.getNodeById(t)), !t))
      throw 'target node is null'
    if (t == this) return null
    if ('string' == typeof n) {
      if (((i = t.findInputSlot(n)), -1 == i))
        return (
          LiteGraph.debug &&
            console.log('Connect: Error, no slot of name ' + i),
          null
        )
    } else if (n === LiteGraph.EVENT) {
      if (!LiteGraph.do_add_triggers_slots) return null
      t.changeMode(LGraphEventMode.ON_TRIGGER),
        (i = t.findInputSlot('onTrigger'))
    } else i = 'number' == typeof n ? n : 0
    if (t.onBeforeConnectInput) {
      const e = t.onBeforeConnectInput(i, n)
      i = 'number' == typeof e ? e : null
    }
    if (null === i || !t.inputs || i >= t.inputs.length)
      return (
        LiteGraph.debug && console.log('Connect: Error, slot number not found'),
        null
      )
    let a = !1
    const s = t.inputs[i]
    let l = null
    const c = this.outputs[e]
    if (!this.outputs[e]) return null
    if (!LiteGraph.isValidConnection(c.type, s.type))
      return this.setDirtyCanvas(!1, !0), a && r.connectionChange(this, l), null
    if (!1 === t.onConnectInput?.(i, c.type, c, this, e)) return null
    if (!1 === this.onConnectOutput?.(e, s.type, s, t, i)) return null
    null != t.inputs[i]?.link &&
      (r.beforeChange(), t.disconnectInput(i, !0), (a = !0)),
      c.links?.length &&
        (c.type !== LiteGraph.EVENT ||
          LiteGraph.allow_multi_output_for_events ||
          (r.beforeChange(),
          this.disconnectOutput(e, !1, { doProcessChange: !1 }),
          (a = !0)))
    const d = ++r.state.lastLinkId
    return (
      (l = new LLink(d, s.type || c.type, this.id, e, t.id, i, o)),
      r._links.set(l.id, l),
      (c.links ??= []),
      c.links.push(l.id),
      (t.inputs[i].link = l.id),
      LLink.getReroutes(r, l).forEach((e) => e?.linkIds.add(d)),
      r._version++,
      this.onConnectionsChange?.(NodeSlotType.OUTPUT, e, !0, l, c),
      t.onConnectionsChange?.(NodeSlotType.INPUT, i, !0, l, s),
      r.onNodeConnectionChange?.(NodeSlotType.INPUT, t, i, this, e),
      r.onNodeConnectionChange?.(NodeSlotType.OUTPUT, this, e, t, i),
      this.setDirtyCanvas(!1, !0),
      r.afterChange(),
      r.connectionChange(this),
      l
    )
  }
  disconnectOutput(e, t) {
    if ('string' == typeof e) {
      if (-1 == (e = this.findOutputSlot(e)))
        return (
          LiteGraph.debug &&
            console.log('Connect: Error, no slot of name ' + e),
          !1
        )
    } else if (!this.outputs || e >= this.outputs.length)
      return (
        LiteGraph.debug && console.log('Connect: Error, slot number not found'),
        !1
      )
    const n = this.outputs[e]
    if (!n || !n.links || 0 == n.links.length) return !1
    const o = this.graph
    if (t) {
      if (('number' == typeof t && (t = o.getNodeById(t)), !t))
        throw 'Target Node not found'
      for (let i = 0, r = n.links.length; i < r; i++) {
        const r = n.links[i],
          a = o._links.get(r)
        if (a.target_id == t.id) {
          n.links.splice(i, 1)
          const s = t.inputs[a.target_slot]
          ;(s.link = null),
            o._links.delete(r),
            o._version++,
            t.onConnectionsChange?.(
              NodeSlotType.INPUT,
              a.target_slot,
              !1,
              a,
              s
            ),
            this.onConnectionsChange?.(NodeSlotType.OUTPUT, e, !1, a, n),
            o.onNodeConnectionChange?.(NodeSlotType.OUTPUT, this, e),
            o.onNodeConnectionChange?.(NodeSlotType.INPUT, t, a.target_slot)
          break
        }
      }
    } else {
      for (let i = 0, r = n.links.length; i < r; i++) {
        const r = n.links[i],
          a = o._links.get(r)
        if (a) {
          if (((t = o.getNodeById(a.target_id)), o._version++, t)) {
            const e = t.inputs[a.target_slot]
            ;(e.link = null),
              t.onConnectionsChange?.(
                NodeSlotType.INPUT,
                a.target_slot,
                !1,
                a,
                e
              )
          }
          o._links.delete(r),
            this.onConnectionsChange?.(NodeSlotType.OUTPUT, e, !1, a, n),
            o.onNodeConnectionChange?.(NodeSlotType.OUTPUT, this, e),
            o.onNodeConnectionChange?.(NodeSlotType.INPUT, t, a.target_slot)
        }
      }
      n.links = null
    }
    return this.setDirtyCanvas(!1, !0), o.connectionChange(this), !0
  }
  disconnectInput(e, t) {
    if ('string' == typeof e) {
      if (-1 == (e = this.findInputSlot(e)))
        return (
          LiteGraph.debug &&
            console.log('Connect: Error, no slot of name ' + e),
          !1
        )
    } else if (!this.inputs || e >= this.inputs.length)
      return (
        LiteGraph.debug && console.log('Connect: Error, slot number not found'),
        !1
      )
    const n = this.inputs[e]
    if (!n) return !1
    const o = this.inputs[e].link
    if (null != o) {
      this.inputs[e].link = null
      const i = this.graph._links.get(o)
      if (i) {
        const r = this.graph.getNodeById(i.origin_id)
        if (!r) return !1
        const a = r.outputs[i.origin_slot]
        if (!(a?.links?.length > 0)) return !1
        let s = 0
        for (const e = a.links.length; s < e; s++)
          if (a.links[s] == o) {
            a.links.splice(s, 1)
            break
          }
        i.disconnect(this.graph, t),
          this.graph && this.graph._version++,
          this.onConnectionsChange?.(NodeSlotType.INPUT, e, !1, i, n),
          r.onConnectionsChange?.(NodeSlotType.OUTPUT, s, !1, i, a),
          this.graph?.onNodeConnectionChange?.(NodeSlotType.OUTPUT, r, s),
          this.graph?.onNodeConnectionChange?.(NodeSlotType.INPUT, this, e)
      }
    }
    return this.setDirtyCanvas(!1, !0), this.graph?.connectionChange(this), !0
  }
  getConnectionPos(e, t, n) {
    n ||= new Float32Array(2)
    const o = e ? (this.inputs?.length ?? 0) : (this.outputs?.length ?? 0),
      i = 0.5 * LiteGraph.NODE_SLOT_HEIGHT
    if (this.flags.collapsed) {
      const t = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH
      return (
        this.horizontal
          ? ((n[0] = this.pos[0] + 0.5 * t),
            (n[1] = e
              ? this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT
              : this.pos[1]))
          : ((n[0] = e ? this.pos[0] : this.pos[0] + t),
            (n[1] = this.pos[1] - 0.5 * LiteGraph.NODE_TITLE_HEIGHT)),
        n
      )
    }
    return e && -1 == t
      ? ((n[0] = this.pos[0] + 0.5 * LiteGraph.NODE_TITLE_HEIGHT),
        (n[1] = this.pos[1] + 0.5 * LiteGraph.NODE_TITLE_HEIGHT),
        n)
      : e && o > t && this.inputs[t].pos
        ? ((n[0] = this.pos[0] + this.inputs[t].pos[0]),
          (n[1] = this.pos[1] + this.inputs[t].pos[1]),
          n)
        : !e && o > t && this.outputs[t].pos
          ? ((n[0] = this.pos[0] + this.outputs[t].pos[0]),
            (n[1] = this.pos[1] + this.outputs[t].pos[1]),
            n)
          : this.horizontal
            ? ((n[0] = this.pos[0] + (t + 0.5) * (this.size[0] / o)),
              (n[1] = e
                ? this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT
                : this.pos[1] + this.size[1]),
              n)
            : ((n[0] = e
                ? this.pos[0] + i
                : this.pos[0] + this.size[0] + 1 - i),
              (n[1] =
                this.pos[1] +
                (t + 0.7) * LiteGraph.NODE_SLOT_HEIGHT +
                (this.constructor.slot_start_y || 0)),
              n)
  }
  snapToGrid(e) {
    return !this.pinned && snapPoint(this.pos, e)
  }
  alignToGrid() {
    this.snapToGrid(LiteGraph.CANVAS_GRID_SIZE)
  }
  trace(e) {
    ;(this.console ||= []),
      this.console.push(e),
      this.console.length > LGraphNode.MAX_CONSOLE && this.console.shift(),
      this.graph.onNodeTrace?.(this, e)
  }
  setDirtyCanvas(e, t) {
    this.graph?.canvasAction((n) => n.setDirty(e, t))
  }
  loadImage(e) {
    const t = new Image()
    ;(t.src = LiteGraph.node_images_path + e), (t.ready = !1)
    const n = this
    return (
      (t.onload = function () {
        ;(this.ready = !0), n.setDirtyCanvas(!0)
      }),
      t
    )
  }
  captureInput(e) {
    if (!this.graph || !this.graph.list_of_graphcanvas) return
    const t = this.graph.list_of_graphcanvas
    for (let n = 0; n < t.length; ++n) {
      const o = t[n]
      ;(e || o.node_capturing_input == this) &&
        (o.node_capturing_input = e ? this : null)
    }
  }
  get collapsed() {
    return !!this.flags.collapsed
  }
  get collapsible() {
    return !this.pinned && !1 !== this.constructor.collapsable
  }
  collapse(e) {
    ;(this.collapsible || e) &&
      (this.graph._version++,
      (this.flags.collapsed = !this.flags.collapsed),
      this.setDirtyCanvas(!0, !0))
  }
  toggleAdvanced() {
    if (!this.widgets?.some((e) => e.advanced)) return
    this.graph._version++, (this.showAdvanced = !this.showAdvanced)
    const e = this.computeSize()
    ;(this.size[0] < e[0] || this.size[1] < e[1]) &&
      this.setSize([
        Math.max(this.size[0], e[0]),
        Math.max(this.size[1], e[1])
      ]),
      this.setDirtyCanvas(!0, !0)
  }
  get pinned() {
    return !!this.flags.pinned
  }
  pin(e) {
    this.graph && this.graph._version++,
      (this.flags.pinned = e ?? !this.flags.pinned),
      (this.resizable = !this.pinned),
      this.pinned || delete this.flags.pinned
  }
  unpin() {
    this.pin(!1)
  }
  localToScreen(e, t, n) {
    return [
      (e + this.pos[0]) * n.scale + n.offset[0],
      (t + this.pos[1]) * n.scale + n.offset[1]
    ]
  }
  get width() {
    return this.collapsed
      ? this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH
      : this.size[0]
  }
  get height() {
    return this.collapsed ? LiteGraph.NODE_COLLAPSED_HEIGHT : this.size[1]
  }
  drawBadges(e, { gap: t = 2 } = {}) {
    const n = this.badges.map((e) => (e instanceof LGraphBadge ? e : e()))
    let o =
      this.badgePosition === BadgePosition.TopLeft
        ? 0
        : this.width - n.reduce((n, o) => n + o.getWidth(e) + t, 0)
    const i = -(LiteGraph.NODE_TITLE_HEIGHT + t)
    for (const r of n) r.draw(e, o, i - r.height), (o += r.getWidth(e) + t)
  }
  connectInputToOutput() {
    const { inputs: e, outputs: t, graph: n } = this
    if (!e || !t) return
    const { _links: o } = n
    let i = !1
    for (const [a, s] of e.entries()) {
      const e = t[a]
      if (!e || !LiteGraph.isValidConnection(s.type, e.type)) continue
      const i = o.get(s.link),
        l = n.getNodeById(i?.origin_id)
      l && r(e, l, i)
    }
    if (!(this.flags.keepAllLinksOnBypass ?? LGraphNode.keepAllLinksOnBypass))
      return i
    for (const a of e) {
      const e = o.get(a.link),
        i = n.getNodeById(e?.origin_id)
      if (i)
        for (const n of t)
          if (LiteGraph.isValidConnection(a.type, n.type)) {
            r(n, i, e)
            break
          }
    }
    return i
    function r(e, t, r) {
      const a = e.links?.map((e) => o.get(e)).filter((e) => !!e)
      if (a?.length)
        for (const o of a) {
          const e = n.getNodeById(o.target_id)
          if (!e) return
          const a = t.connect(r.origin_slot, e, o.target_slot, r.parentId)
          i ||= !!a
        }
    }
  }
}
class LGraphGroup {
  static {
    __name(this, 'LGraphGroup')
  }
  static minWidth = 140
  static minHeight = 80
  static resizeLength = 10
  static padding = 4
  static defaultColour = '#335'
  id
  color
  title
  font
  font_size = LiteGraph.DEFAULT_GROUP_FONT || 24
  _bounding = new Float32Array([
    10,
    10,
    LGraphGroup.minWidth,
    LGraphGroup.minHeight
  ])
  _pos = this._bounding.subarray(0, 2)
  _size = this._bounding.subarray(2, 4)
  _nodes = []
  _children = new Set()
  graph = null
  flags = {}
  selected
  constructor(e, t) {
    ;(this.id = t ?? -1),
      (this.title = e || 'Group'),
      (this.color = LGraphCanvas.node_colors.pale_blue
        ? LGraphCanvas.node_colors.pale_blue.groupcolor
        : '#AAA')
  }
  get pos() {
    return this._pos
  }
  set pos(e) {
    !e || e.length < 2 || ((this._pos[0] = e[0]), (this._pos[1] = e[1]))
  }
  get size() {
    return this._size
  }
  set size(e) {
    !e ||
      e.length < 2 ||
      ((this._size[0] = Math.max(LGraphGroup.minWidth, e[0])),
      (this._size[1] = Math.max(LGraphGroup.minHeight, e[1])))
  }
  get boundingRect() {
    return this._bounding
  }
  get nodes() {
    return this._nodes
  }
  get titleHeight() {
    return 1.4 * this.font_size
  }
  get children() {
    return this._children
  }
  get pinned() {
    return !!this.flags.pinned
  }
  pin(e) {
    ;(void 0 === e ? !this.pinned : e)
      ? (this.flags.pinned = !0)
      : delete this.flags.pinned
  }
  unpin() {
    this.pin(!1)
  }
  configure(e) {
    ;(this.id = e.id),
      (this.title = e.title),
      this._bounding.set(e.bounding),
      (this.color = e.color),
      (this.flags = e.flags || this.flags),
      e.font_size && (this.font_size = e.font_size)
  }
  serialize() {
    const e = this._bounding
    return {
      id: this.id,
      title: this.title,
      bounding: [...e],
      color: this.color,
      font_size: this.font_size,
      flags: this.flags
    }
  }
  draw(e, t) {
    const { padding: n, resizeLength: o, defaultColour: i } = LGraphGroup,
      r = this.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE,
      [a, s] = this._pos,
      [l, c] = this._size
    ;(t.globalAlpha = 0.25 * e.editor_alpha),
      (t.fillStyle = this.color || i),
      (t.strokeStyle = this.color || i),
      t.beginPath(),
      t.rect(a + 0.5, s + 0.5, l, 1.4 * r),
      t.fill(),
      (t.fillStyle = this.color),
      (t.strokeStyle = this.color),
      t.beginPath(),
      t.rect(a + 0.5, s + 0.5, l, c),
      t.fill(),
      (t.globalAlpha = e.editor_alpha),
      t.stroke(),
      t.beginPath(),
      t.moveTo(a + l, s + c),
      t.lineTo(a + l - o, s + c),
      t.lineTo(a + l, s + c - o),
      t.fill(),
      (t.font = r + 'px Arial'),
      (t.textAlign = 'left'),
      t.fillText(this.title + (this.pinned ? '📌' : ''), a + n, s + r),
      LiteGraph.highlight_selected_group &&
        this.selected &&
        e.strokeShape(t, this._bounding, {
          title_height: this.titleHeight,
          padding: n
        })
  }
  resize(e, t) {
    return (
      !this.pinned &&
      ((this._size[0] = Math.max(LGraphGroup.minWidth, e)),
      (this._size[1] = Math.max(LGraphGroup.minHeight, t)),
      !0)
    )
  }
  move(e, t, n = !1) {
    if (!this.pinned && ((this._pos[0] += e), (this._pos[1] += t), !0 !== n))
      for (const o of this._children) o.move(e, t)
  }
  snapToGrid(e) {
    return !this.pinned && snapPoint(this.pos, e)
  }
  recomputeInsideNodes() {
    const { nodes: e, reroutes: t, groups: n } = this.graph,
      o = this._children
    ;(this._nodes.length = 0), o.clear()
    for (const i of e)
      containsCentre(this._bounding, i.boundingRect) &&
        (this._nodes.push(i), o.add(i))
    for (const i of t.values()) isPointInRect(i.pos, this._bounding) && o.add(i)
    for (const i of n) containsRect(this._bounding, i._bounding) && o.add(i)
    n.sort((e, t) =>
      e === this
        ? o.has(t)
          ? -1
          : 0
        : t === this
          ? o.has(e)
            ? 1
            : 0
          : void 0
    )
  }
  resizeTo(e, t = 10) {
    const n = createBounds(e, t)
    null !== n &&
      ((this.pos[0] = n[0]),
      (this.pos[1] = n[1] - this.titleHeight),
      (this.size[0] = n[2]),
      (this.size[1] = n[3] + this.titleHeight))
  }
  addNodes(e, t = 10) {
    ;(this._nodes || 0 !== e.length) &&
      this.resizeTo([...this.children, ...this._nodes, ...e], t)
  }
  getMenuOptions() {
    return [
      {
        content: this.pinned ? 'Unpin' : 'Pin',
        callback: __name(() => {
          this.pinned ? this.unpin() : this.pin(), this.setDirtyCanvas(!1, !0)
        }, 'callback')
      },
      null,
      { content: 'Title', callback: LGraphCanvas.onShowPropertyEditor },
      {
        content: 'Color',
        has_submenu: !0,
        callback: LGraphCanvas.onMenuNodeColors
      },
      {
        content: 'Font size',
        property: 'font_size',
        type: 'Number',
        callback: LGraphCanvas.onShowPropertyEditor
      },
      null,
      { content: 'Remove', callback: LGraphCanvas.onMenuNodeRemove }
    ]
  }
  isPointInTitlebar(e, t) {
    const n = this.boundingRect
    return isInRectangle(e, t, n[0], n[1], n[2], this.titleHeight)
  }
  isInResize(e, t) {
    const n = this.boundingRect,
      o = n[0] + n[2],
      i = n[1] + n[3]
    return e < o && t < i && e - o + (t - i) > -LGraphGroup.resizeLength
  }
  isPointInside = LGraphNode.prototype.isPointInside
  setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas
}
var SlotType = ((e) => ((e.Array = 'array'), (e[(e.Event = -1)] = 'Event'), e))(
    SlotType || {}
  ),
  SlotShape =
    ((SlotShape2 = SlotShape || {}),
    (SlotShape2[(SlotShape2.Box = RenderShape.BOX)] = 'Box'),
    (SlotShape2[(SlotShape2.Arrow = RenderShape.ARROW)] = 'Arrow'),
    (SlotShape2[(SlotShape2.Grid = RenderShape.GRID)] = 'Grid'),
    (SlotShape2[(SlotShape2.Circle = RenderShape.CIRCLE)] = 'Circle'),
    (SlotShape2[(SlotShape2.HollowCircle = RenderShape.HollowCircle)] =
      'HollowCircle'),
    SlotShape2),
  SlotShape2,
  SlotDirection =
    ((SlotDirection2 = SlotDirection || {}),
    (SlotDirection2[(SlotDirection2.Up = LinkDirection.UP)] = 'Up'),
    (SlotDirection2[(SlotDirection2.Right = LinkDirection.RIGHT)] = 'Right'),
    (SlotDirection2[(SlotDirection2.Down = LinkDirection.DOWN)] = 'Down'),
    (SlotDirection2[(SlotDirection2.Left = LinkDirection.LEFT)] = 'Left'),
    SlotDirection2),
  SlotDirection2,
  LabelPosition = ((e) => ((e.Left = 'left'), (e.Right = 'right'), e))(
    LabelPosition || {}
  )
function drawSlot(
  e,
  t,
  n,
  {
    label_color: o = '#AAA',
    label_position: i = 'right',
    horizontal: r = !1,
    low_quality: a = !1,
    render_text: s = !0,
    do_stroke: l = !1,
    highlight: c = !1
  } = {}
) {
  const d = e.fillStyle,
    u = e.strokeStyle,
    p = e.lineWidth,
    h = t.type,
    m = 'array' === h ? SlotShape.Grid : t.shape
  e.beginPath()
  let f = l,
    _ = !0
  if (-1 === h || m === SlotShape.Box)
    r
      ? e.rect(n[0] - 5 + 0.5, n[1] - 8 + 0.5, 10, 14)
      : e.rect(n[0] - 6 + 0.5, n[1] - 5 + 0.5, 14, 10)
  else if (m === SlotShape.Arrow)
    e.moveTo(n[0] + 8, n[1] + 0.5),
      e.lineTo(n[0] - 4, n[1] + 6 + 0.5),
      e.lineTo(n[0] - 4, n[1] - 6 + 0.5),
      e.closePath()
  else if (m === SlotShape.Grid) {
    const t = 3,
      o = 2,
      i = 3
    for (let r = 0; r < t; r++)
      for (let a = 0; a < t; a++)
        e.rect(n[0] - 4 + r * i, n[1] - 4 + a * i, o, o)
    f = !1
  } else if (a) e.rect(n[0] - 4, n[1] - 4, 8, 8)
  else {
    let t
    m === SlotShape.HollowCircle
      ? ((_ = !1),
        (f = !0),
        (e.lineWidth = 3),
        (e.strokeStyle = e.fillStyle),
        (t = c ? 4 : 3))
      : (t = c ? 5 : 4),
      e.arc(n[0], n[1], t, 0, 2 * Math.PI)
  }
  if ((_ && e.fill(), !a && f && e.stroke(), s)) {
    const a = null != t.label ? t.label : t.name
    a &&
      ((e.fillStyle = o),
      'right' === i
        ? r || t.dir == LinkDirection.UP
          ? e.fillText(a, n[0], n[1] - 10)
          : e.fillText(a, n[0] + 10, n[1] + 5)
        : r || t.dir == LinkDirection.DOWN
          ? e.fillText(a, n[0], n[1] - 8)
          : e.fillText(a, n[0] - 10, n[1] + 5))
  }
  ;(e.fillStyle = d), (e.strokeStyle = u), (e.lineWidth = p)
}
__name(drawSlot, 'drawSlot')
class DragAndScale {
  static {
    __name(this, 'DragAndScale')
  }
  state
  max_scale
  min_scale
  enabled
  last_mouse
  element
  visible_area
  _binded_mouse_callback
  dragging
  viewport
  get offset() {
    return this.state.offset
  }
  set offset(e) {
    this.state.offset = e
  }
  get scale() {
    return this.state.scale
  }
  set scale(e) {
    this.state.scale = e
  }
  constructor(e, t) {
    ;(this.state = { offset: new Float32Array([0, 0]), scale: 1 }),
      (this.max_scale = 10),
      (this.min_scale = 0.1),
      (this.onredraw = null),
      (this.enabled = !0),
      (this.last_mouse = [0, 0]),
      (this.element = null),
      (this.visible_area = new Float32Array(4)),
      e && ((this.element = e), t || this.bindEvents(e))
  }
  bindEvents(e) {
    ;(this.last_mouse = new Float32Array(2)),
      (this._binded_mouse_callback = this.onMouse.bind(this)),
      LiteGraph.pointerListenerAdd(e, 'down', this._binded_mouse_callback),
      LiteGraph.pointerListenerAdd(e, 'move', this._binded_mouse_callback),
      LiteGraph.pointerListenerAdd(e, 'up', this._binded_mouse_callback),
      e.addEventListener('mousewheel', this._binded_mouse_callback, !1),
      e.addEventListener('wheel', this._binded_mouse_callback, !1)
  }
  computeVisibleArea(e) {
    if (!this.element)
      return void (this.visible_area[0] =
        this.visible_area[1] =
        this.visible_area[2] =
        this.visible_area[3] =
          0)
    let t = this.element.width,
      n = this.element.height,
      o = -this.offset[0],
      i = -this.offset[1]
    e &&
      ((o += e[0] / this.scale),
      (i += e[1] / this.scale),
      (t = e[2]),
      (n = e[3]))
    const r = o + t / this.scale,
      a = i + n / this.scale
    ;(this.visible_area[0] = o),
      (this.visible_area[1] = i),
      (this.visible_area[2] = r - o),
      (this.visible_area[3] = a - i)
  }
  onMouse(e) {
    if (!this.enabled) return
    const t = this.element,
      n = t.getBoundingClientRect(),
      o = e.clientX - n.left,
      i = e.clientY - n.top
    ;(e.canvasx = o), (e.canvasy = i), (e.dragging = this.dragging)
    const r = !this.viewport || isInRect(o, i, this.viewport)
    let a = !1
    if (
      (this.onmouse && (a = this.onmouse(e)),
      e.type == LiteGraph.pointerevents_method + 'down' && r)
    )
      (this.dragging = !0),
        LiteGraph.pointerListenerRemove(t, 'move', this._binded_mouse_callback),
        LiteGraph.pointerListenerAdd(
          document,
          'move',
          this._binded_mouse_callback
        ),
        LiteGraph.pointerListenerAdd(
          document,
          'up',
          this._binded_mouse_callback
        )
    else if (e.type == LiteGraph.pointerevents_method + 'move') {
      if (!a) {
        const e = o - this.last_mouse[0],
          t = i - this.last_mouse[1]
        this.dragging && this.mouseDrag(e, t)
      }
    } else
      e.type == LiteGraph.pointerevents_method + 'up'
        ? ((this.dragging = !1),
          LiteGraph.pointerListenerRemove(
            document,
            'move',
            this._binded_mouse_callback
          ),
          LiteGraph.pointerListenerRemove(
            document,
            'up',
            this._binded_mouse_callback
          ),
          LiteGraph.pointerListenerAdd(t, 'move', this._binded_mouse_callback))
        : !r ||
          ('mousewheel' != e.type &&
            'wheel' != e.type &&
            'DOMMouseScroll' != e.type) ||
          ((e.eventType = 'mousewheel'),
          'wheel' == e.type
            ? (e.wheel = -e.deltaY)
            : (e.wheel =
                null != e.wheelDeltaY ? e.wheelDeltaY : -60 * e.detail),
          (e.delta = e.wheelDelta
            ? e.wheelDelta / 40
            : e.deltaY
              ? -e.deltaY / 3
              : 0),
          this.changeDeltaScale(1 + 0.05 * e.delta))
    return (
      (this.last_mouse[0] = o),
      (this.last_mouse[1] = i),
      r ? (e.preventDefault(), e.stopPropagation(), !1) : void 0
    )
  }
  toCanvasContext(e) {
    e.scale(this.scale, this.scale), e.translate(this.offset[0], this.offset[1])
  }
  convertOffsetToCanvas(e) {
    return [
      (e[0] + this.offset[0]) * this.scale,
      (e[1] + this.offset[1]) * this.scale
    ]
  }
  convertCanvasToOffset(e, t) {
    return (
      ((t = t || [0, 0])[0] = e[0] / this.scale - this.offset[0]),
      (t[1] = e[1] / this.scale - this.offset[1]),
      t
    )
  }
  mouseDrag(e, t) {
    ;(this.offset[0] += e / this.scale),
      (this.offset[1] += t / this.scale),
      this.onredraw?.(this)
  }
  changeScale(e, t) {
    if (
      (e < this.min_scale
        ? (e = this.min_scale)
        : e > this.max_scale && (e = this.max_scale),
      e == this.scale)
    )
      return
    if (!this.element) return
    const n = this.element.getBoundingClientRect()
    if (!n) return
    ;((t = t || [0.5 * n.width, 0.5 * n.height])[0] -= n.x), (t[1] -= n.y)
    const o = this.convertCanvasToOffset(t)
    ;(this.scale = e), Math.abs(this.scale - 1) < 0.01 && (this.scale = 1)
    const i = this.convertCanvasToOffset(t),
      r = [i[0] - o[0], i[1] - o[1]]
    ;(this.offset[0] += r[0]), (this.offset[1] += r[1]), this.onredraw?.(this)
  }
  changeDeltaScale(e, t) {
    this.changeScale(this.scale * e, t)
  }
  reset() {
    ;(this.scale = 1), (this.offset[0] = 0), (this.offset[1] = 0)
  }
}
function stringOrNull(e) {
  return null == e ? null : String(e)
}
function stringOrEmpty(e) {
  return null == e ? '' : String(e)
}
function getBoundaryNodes(e) {
  const t = e?.find((e) => e)
  if (!t) return null
  let n = t,
    o = t,
    i = t,
    r = t
  for (const a of e) {
    if (!a) continue
    const [e, t] = a.pos,
      [s, l] = a.size
    t < n.pos[1] && (n = a),
      e + s > o.pos[0] + o.size[0] && (o = a),
      t + l > i.pos[1] + i.size[1] && (i = a),
      e < r.pos[0] && (r = a)
  }
  return { top: n, right: o, bottom: i, left: r }
}
function distributeNodes(e, t) {
  const n = e?.length
  if (!(n > 1)) return
  const o = t ? 0 : 1
  let i = 0,
    r = -1 / 0
  for (const d of e) {
    i += d.size[o]
    const e = d.pos[o] + d.size[o]
    e > r && (r = e)
  }
  const a = [...e].sort((e, t) => e.pos[o] - t.pos[o]),
    s = a[0].pos[o],
    l = (r - s - i) / (n - 1)
  let c = s
  for (let d = 0; d < n; d++) {
    const e = a[d]
    ;(e.pos[o] = c + l * d), (c += e.size[o])
  }
}
function alignNodes(e, t, n) {
  if (!e) return
  const o =
    void 0 === n
      ? getBoundaryNodes(e)
      : { top: n, right: n, bottom: n, left: n }
  if (null !== o)
    for (const i of e)
      switch (t) {
        case 'right':
          i.pos[0] = o.right.pos[0] + o.right.size[0] - i.size[0]
          break
        case 'left':
          i.pos[0] = o.left.pos[0]
          break
        case 'top':
          i.pos[1] = o.top.pos[1]
          break
        case 'bottom':
          i.pos[1] = o.bottom.pos[1] + o.bottom.size[1] - i.size[1]
      }
}
function getAllNestedItems(e) {
  const t = new Set()
  return e?.forEach((e) => n(e, t)), t
  function n(e, t) {
    t.has(e) || e.pinned || (t.add(e), e.children?.forEach((e) => n(e, t)))
  }
}
function findFirstNode(e) {
  for (const t of e) if (t instanceof LGraphNode) return t
}
__name(stringOrNull, 'stringOrNull'),
  __name(stringOrEmpty, 'stringOrEmpty'),
  __name(getBoundaryNodes, 'getBoundaryNodes'),
  __name(distributeNodes, 'distributeNodes'),
  __name(alignNodes, 'alignNodes'),
  __name(getAllNestedItems, 'getAllNestedItems'),
  __name(findFirstNode, 'findFirstNode')
class CanvasPointer {
  static {
    __name(this, 'CanvasPointer')
  }
  static bufferTime = 150
  static doubleClickTime = 300
  static get maxClickDrift() {
    return this.#f
  }
  static set maxClickDrift(e) {
    ;(this.#f = e), (this.#_ = e * e)
  }
  static #f = 6
  static #_ = this.#f ** 2
  element
  pointerId
  dragStarted = !1
  eLastDown
  isDouble = !1
  isDown = !1
  clearEventsOnReset = !0
  eDown = null
  eMove = null
  eUp = null
  get finally() {
    return this.#g
  }
  set finally(e) {
    try {
      this.#g?.()
    } finally {
      this.#g = e
    }
  }
  #g
  constructor(e) {
    this.element = e
  }
  down(e) {
    this.reset(),
      (this.eDown = e),
      (this.pointerId = e.pointerId),
      this.element.setPointerCapture(e.pointerId)
  }
  move(e) {
    const { eDown: t } = this
    if (!t) return
    if (!e.buttons) return void this.reset()
    if (!(e.buttons & t.buttons)) return this.#v(e), void this.reset()
    if (((this.eMove = e), this.onDrag?.(e), this.dragStarted)) return
    ;(!(e.timeStamp - t.timeStamp > CanvasPointer.bufferTime) &&
      this.#y(e, t)) ||
      this.#b()
  }
  up(e) {
    if (e.button !== this.eDown?.button) return !1
    this.#v(e)
    const { dragStarted: t } = this
    return this.reset(), !t
  }
  #v(e) {
    const { eDown: t } = this
    t &&
      ((this.eUp = e),
      this.dragStarted
        ? this.onDragEnd?.(e)
        : this.#y(e, t)
          ? this.onDoubleClick && this.#S()
            ? (this.onDoubleClick(e), (this.eLastDown = void 0))
            : (this.onClick?.(e), (this.eLastDown = t))
          : (this.#b(), this.onDragEnd?.(e)))
  }
  #y(e, t, n = CanvasPointer.#_) {
    return dist2(e.clientX, e.clientY, t.clientX, t.clientY) <= n
  }
  #S() {
    const { eDown: e, eLastDown: t } = this
    if (!e || !t) return !1
    const n = (3 * CanvasPointer.#f) ** 2,
      o = e.timeStamp - t.timeStamp
    return o > 0 && o < CanvasPointer.doubleClickTime && this.#y(e, t, n)
  }
  #b() {
    ;(this.dragStarted = !0), this.onDragStart?.(this), delete this.onDragStart
  }
  reset() {
    ;(this.finally = void 0),
      delete this.onClick,
      delete this.onDoubleClick,
      delete this.onDragStart,
      delete this.onDrag,
      delete this.onDragEnd,
      (this.isDown = !1),
      (this.isDouble = !1),
      (this.dragStarted = !1),
      this.clearEventsOnReset &&
        ((this.eDown = null), (this.eMove = null), (this.eUp = null))
    const { element: e, pointerId: t } = this
    e.hasPointerCapture(t) && e.releasePointerCapture(t)
  }
}
class LGraphCanvas {
  static {
    __name(this, 'LGraphCanvas')
  }
  static #C = new Float32Array(4)
  static #w = new Float32Array(2)
  static #k = new Float32Array(4)
  static #x = new Float32Array(4)
  static #E = new Float32Array(4)
  static #I = new Float32Array(2)
  static #T = new Float32Array(2)
  static #$ = new Float32Array(2)
  static #L = new Float32Array(2)
  static #A = new Float32Array(2)
  static DEFAULT_BACKGROUND_IMAGE =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII='
  static link_type_colors
  static gradients = {}
  static search_limit = -1
  static node_colors = {
    red: { color: '#322', bgcolor: '#533', groupcolor: '#A88' },
    brown: { color: '#332922', bgcolor: '#593930', groupcolor: '#b06634' },
    green: { color: '#232', bgcolor: '#353', groupcolor: '#8A8' },
    blue: { color: '#223', bgcolor: '#335', groupcolor: '#88A' },
    pale_blue: { color: '#2a363b', bgcolor: '#3f5159', groupcolor: '#3f789e' },
    cyan: { color: '#233', bgcolor: '#355', groupcolor: '#8AA' },
    purple: { color: '#323', bgcolor: '#535', groupcolor: '#a1309b' },
    yellow: { color: '#432', bgcolor: '#653', groupcolor: '#b58b2a' },
    black: { color: '#222', bgcolor: '#000', groupcolor: '#444' }
  }
  state = {
    draggingItems: !1,
    draggingCanvas: !1,
    readOnly: !1,
    hoveringOver: CanvasItem.Nothing,
    shouldSetCursor: !0
  }
  _previously_dragging_canvas = null
  get read_only() {
    return this.state.readOnly
  }
  set read_only(e) {
    this.state.readOnly = e
  }
  get isDragging() {
    return this.state.draggingItems
  }
  set isDragging(e) {
    this.state.draggingItems = e
  }
  get pointer_is_down() {
    return this.pointer.isDown
  }
  get pointer_is_double() {
    return this.pointer.isDouble
  }
  get dragging_canvas() {
    return this.state.draggingCanvas
  }
  set dragging_canvas(e) {
    this.state.draggingCanvas = e
  }
  get title_text_font() {
    return `${LiteGraph.NODE_TEXT_SIZE}px Arial`
  }
  get inner_text_font() {
    return `normal ${LiteGraph.NODE_SUBTEXT_SIZE}px Arial`
  }
  #O = 0
  get maximumFps() {
    return this.#O > Number.EPSILON ? this.#O / 1e3 : 0
  }
  set maximumFps(e) {
    this.#O = e > Number.EPSILON ? 1e3 / e : 0
  }
  options
  background_image
  ds
  pointer
  zoom_modify_alpha
  zoom_speed
  node_title_color
  default_link_color
  default_connection_color
  default_connection_color_byType
  default_connection_color_byTypeOff
  highquality_render
  use_gradients
  editor_alpha
  pause_rendering
  clear_background
  clear_background_color
  render_only_selected
  show_info
  allow_dragcanvas
  allow_dragnodes
  allow_interaction
  multi_select
  allow_searchbox
  allow_reconnect_links
  align_to_grid
  drag_mode
  dragging_rectangle
  filter
  set_canvas_dirty_on_mouse_event
  always_render_background
  render_shadows
  render_canvas_border
  render_connections_shadows
  render_connections_border
  render_curved_connections
  render_connection_arrows
  render_collapsed_slots
  render_execution_order
  render_title_colored
  render_link_tooltip
  reroutesEnabled = !1
  linkMarkerShape = LinkMarkerShape.Circle
  links_render_mode
  mouse
  graph_mouse
  canvas_mouse
  onSearchBox
  onSearchBoxSelection
  onMouse
  onDrawBackground
  onDrawForeground
  connections_width
  round_radius
  current_node
  node_widget
  over_link_center
  last_mouse_position
  visible_area
  renderedPaths = new Set()
  visible_links
  connecting_links
  viewport
  autoresize
  static active_canvas
  frame = 0
  last_draw_time = 0
  render_time = 0
  fps = 0
  selected_nodes = {}
  selectedItems = new Set()
  resizingGroup = null
  selected_group = null
  visible_nodes = []
  node_over
  node_capturing_input
  highlighted_links = {}
  link_over_widget
  link_over_widget_type
  dirty_canvas = !0
  dirty_bgcanvas = !0
  dirty_nodes = new Map()
  dirty_area
  node_in_panel
  last_mouse = [0, 0]
  last_mouseclick = 0
  graph
  _graph_stack = null
  canvas
  bgcanvas
  ctx
  _events_binded
  gl
  bgctx
  is_rendering
  block_click
  last_click_position
  resizing_node
  selected_group_resizing
  last_mouse_dragging
  onMouseDown
  _highlight_pos
  _highlight_input
  node_panel
  options_panel
  onDropItem
  _bg_img
  _pattern
  _pattern_img
  prompt_box
  search_box
  SELECTED_NODE
  NODEPANEL_IS_OPEN
  #P
  #V = !1
  static active_node
  onClear
  onNodeMoved
  onSelectionChange
  onDrawLinkTooltip
  onDrawOverlay
  onRenderBackground
  onNodeDblClicked
  onShowNodePanel
  onNodeSelected
  onNodeDeselected
  onRender
  getWidgetLinkType
  constructor(e, t, n) {
    ;(n ||= {}),
      (this.options = n),
      (this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE),
      (this.ds = new DragAndScale()),
      (this.pointer = new CanvasPointer(this.canvas)),
      (this.zoom_modify_alpha = !0),
      (this.zoom_speed = 1.1),
      (this.node_title_color = LiteGraph.NODE_TITLE_COLOR),
      (this.default_link_color = LiteGraph.LINK_COLOR),
      (this.default_connection_color = {
        input_off: '#778',
        input_on: '#7F7',
        output_off: '#778',
        output_on: '#7F7'
      }),
      (this.default_connection_color_byType = {}),
      (this.default_connection_color_byTypeOff = {}),
      (this.highquality_render = !0),
      (this.use_gradients = !1),
      (this.editor_alpha = 1),
      (this.pause_rendering = !1),
      (this.clear_background = !0),
      (this.clear_background_color = '#222'),
      (this.render_only_selected = !0),
      (this.show_info = !0),
      (this.allow_dragcanvas = !0),
      (this.allow_dragnodes = !0),
      (this.allow_interaction = !0),
      (this.multi_select = !1),
      (this.allow_searchbox = !0),
      (this.allow_reconnect_links = !0),
      (this.align_to_grid = !1),
      (this.drag_mode = !1),
      (this.dragging_rectangle = null),
      (this.filter = null),
      (this.set_canvas_dirty_on_mouse_event = !0),
      (this.always_render_background = !1),
      (this.render_shadows = !0),
      (this.render_canvas_border = !0),
      (this.render_connections_shadows = !1),
      (this.render_connections_border = !0),
      (this.render_curved_connections = !1),
      (this.render_connection_arrows = !1),
      (this.render_collapsed_slots = !0),
      (this.render_execution_order = !1),
      (this.render_title_colored = !0),
      (this.render_link_tooltip = !0),
      (this.links_render_mode = LinkRenderType.SPLINE_LINK),
      (this.mouse = [0, 0]),
      (this.graph_mouse = [0, 0]),
      (this.canvas_mouse = this.graph_mouse),
      (this.onSearchBox = null),
      (this.onSearchBoxSelection = null),
      (this.onMouse = null),
      (this.onDrawBackground = null),
      (this.onDrawForeground = null),
      (this.onDrawOverlay = null),
      (this.onDrawLinkTooltip = null),
      (this.onNodeMoved = null),
      (this.onSelectionChange = null),
      (this.onConnectingChange = null),
      (this.onBeforeChange = null),
      (this.onAfterChange = null),
      (this.connections_width = 3),
      (this.round_radius = 8),
      (this.current_node = null),
      (this.node_widget = null),
      (this.over_link_center = null),
      (this.last_mouse_position = [0, 0]),
      (this.visible_area = this.ds.visible_area),
      (this.visible_links = []),
      (this.connecting_links = null),
      (this.viewport = n.viewport || null),
      t?.attachCanvas(this),
      this.setCanvas(e, n.skip_events),
      this.clear(),
      n.skip_render || this.startRendering(),
      (this.autoresize = n.autoresize)
  }
  static getFileExtension(e) {
    const t = e.indexOf('?')
    ;-1 !== t && (e = e.substring(0, t))
    const n = e.lastIndexOf('.')
    return -1 === n ? '' : e.substring(n + 1).toLowerCase()
  }
  static onGroupAdd(e, t, n) {
    const o = LGraphCanvas.active_canvas,
      i = new LiteGraph.LGraphGroup()
    ;(i.pos = o.convertEventToCanvasOffset(n)), o.graph.add(i)
  }
  static getBoundaryNodes(e) {
    return (
      getBoundaryNodes(Array.isArray(e) ? e : Object.values(e)) ?? {
        top: null,
        right: null,
        bottom: null,
        left: null
      }
    )
  }
  static alignNodes(e, t, n) {
    alignNodes(Object.values(e), t, n),
      LGraphCanvas.active_canvas.setDirty(!0, !0)
  }
  static onNodeAlign(e, t, n, o, i) {
    function r(e) {
      alignNodes(
        Object.values(LGraphCanvas.active_canvas.selected_nodes),
        e.toLowerCase(),
        i
      ),
        LGraphCanvas.active_canvas.setDirty(!0, !0)
    }
    new LiteGraph.ContextMenu(['Top', 'Bottom', 'Left', 'Right'], {
      event: n,
      callback: r,
      parentMenu: o
    }),
      __name(r, 'inner_clicked')
  }
  static onGroupAlign(e, t, n, o) {
    function i(e) {
      alignNodes(
        Object.values(LGraphCanvas.active_canvas.selected_nodes),
        e.toLowerCase()
      ),
        LGraphCanvas.active_canvas.setDirty(!0, !0)
    }
    new LiteGraph.ContextMenu(['Top', 'Bottom', 'Left', 'Right'], {
      event: n,
      callback: i,
      parentMenu: o
    }),
      __name(i, 'inner_clicked')
  }
  static createDistributeMenu(e, t, n, o, i) {
    function r(e) {
      const t = LGraphCanvas.active_canvas
      distributeNodes(Object.values(t.selected_nodes), 'Horizontally' === e),
        t.setDirty(!0, !0)
    }
    new LiteGraph.ContextMenu(['Vertically', 'Horizontally'], {
      event: n,
      callback: r,
      parentMenu: o
    }),
      __name(r, 'inner_clicked')
  }
  static onMenuAdd(e, t, n, o, i) {
    const r = LGraphCanvas.active_canvas,
      a = r.getCanvasWindow(),
      s = r.graph
    if (s) return __name(l, 'inner_onMenuAdded'), l('', o), !1
    function l(e, t) {
      const o = LiteGraph.getNodeTypesCategories(r.filter || s.filter).filter(
          function (t) {
            return t.startsWith(e)
          }
        ),
        c = []
      o.map(function (t) {
        if (!t) return
        const n = new RegExp('^(' + e + ')'),
          o = t.replace(n, '').split('/')[0],
          i = '' === e ? o + '/' : e + o + '/'
        let r = o
        ;-1 != r.indexOf('::') && (r = r.split('::')[1])
        ;-1 ===
          c.findIndex(function (e) {
            return e.value === i
          }) &&
          c.push({
            value: i,
            content: r,
            has_submenu: !0,
            callback: __name(function (e, t, n, o) {
              l(e.value, o)
            }, 'callback')
          })
      })
      LiteGraph.getNodeTypesInCategory(
        e.slice(0, -1),
        r.filter || s.filter
      ).map(function (e) {
        if (e.skip_list) return
        const t = {
          value: e.type,
          content: e.title,
          has_submenu: !1,
          callback: __name(function (e, t, n, o) {
            const a = o.getFirstEvent()
            r.graph.beforeChange()
            const s = LiteGraph.createNode(e.value)
            s && ((s.pos = r.convertEventToCanvasOffset(a)), r.graph.add(s)),
              i?.(s),
              r.graph.afterChange()
          }, 'callback')
        }
        c.push(t)
      }),
        new LiteGraph.ContextMenu(c, { event: n, parentMenu: t }, a)
    }
  }
  static onMenuCollapseAll() {}
  static onMenuNodeEdit() {}
  static showMenuNodeOptionalInputs(e, t, n, o, i) {
    if (!i) return
    const r = this,
      a = LGraphCanvas.active_canvas,
      s = a.getCanvasWindow()
    let l = []
    if ((t = i.onGetInputs ? i.onGetInputs() : i.optional_inputs))
      for (let u = 0; u < t.length; u++) {
        const e = t[u]
        if (!e) {
          l.push(null)
          continue
        }
        let n = e[0]
        ;(e[2] ||= {}), e[2].label && (n = e[2].label), (e[2].removable = !0)
        const o = { content: n, value: e }
        e[1] == LiteGraph.ACTION && (o.className = 'event'), l.push(o)
      }
    const c = i.onMenuNodeInputs?.(l)
    if ((c && (l = c), l.length))
      return (
        new LiteGraph.ContextMenu(
          l,
          { event: n, callback: d, parentMenu: o, node: i },
          s
        ),
        __name(d, 'inner_clicked'),
        !1
      )
    function d(e, t, n) {
      i &&
        (e.callback?.call(r, i, e, t, n),
        e.value &&
          (i.graph.beforeChange(),
          i.addInput(e.value[0], e.value[1], e.value[2]),
          i.onNodeInputAdd?.(e.value),
          a.setDirty(!0, !0),
          i.graph.afterChange()))
    }
    console.log('no input entries')
  }
  static showMenuNodeOptionalOutputs(e, t, n, o, i) {
    if (!i) return
    const r = this,
      a = LGraphCanvas.active_canvas,
      s = a.getCanvasWindow()
    let l = []
    if ((t = i.onGetOutputs ? i.onGetOutputs() : i.optional_outputs))
      for (let u = 0; u < t.length; u++) {
        const e = t[u]
        if (!e) {
          l.push(null)
          continue
        }
        if (
          i.flags &&
          i.flags.skip_repeated_outputs &&
          -1 != i.findOutputSlot(e[0])
        )
          continue
        let n = e[0]
        ;(e[2] ||= {}), e[2].label && (n = e[2].label), (e[2].removable = !0)
        const o = { content: n, value: e }
        e[1] == LiteGraph.EVENT && (o.className = 'event'), l.push(o)
      }
    this.onMenuNodeOutputs && (l = this.onMenuNodeOutputs(l)),
      LiteGraph.do_add_triggers_slots &&
        -1 == i.findOutputSlot('onExecuted') &&
        l.push({
          content: 'On Executed',
          value: ['onExecuted', LiteGraph.EVENT, { nameLocked: !0 }],
          className: 'event'
        })
    const c = i.onMenuNodeOutputs?.(l)
    if ((c && (l = c), l.length))
      return (
        new LiteGraph.ContextMenu(
          l,
          { event: n, callback: d, parentMenu: o, node: i },
          s
        ),
        __name(d, 'inner_clicked'),
        !1
      )
    function d(e, t, n) {
      if (!i) return
      if ((e.callback && e.callback.call(r, i, e, t, n), !e.value)) return
      const s = e.value[1]
      if (s && ('object' == typeof s || Array.isArray(s))) {
        const e = []
        for (const t in s) e.push({ content: t, value: s[t] })
        return (
          new LiteGraph.ContextMenu(e, {
            event: t,
            callback: d,
            parentMenu: o,
            node: i
          }),
          !1
        )
      }
      const l = i.graph
      l.beforeChange(),
        i.addOutput(e.value[0], e.value[1], e.value[2]),
        i.onNodeOutputAdd?.(e.value),
        a.setDirty(!0, !0),
        l.afterChange()
    }
  }
  static onShowMenuNodeProperties(e, t, n, o, i) {
    if (!i || !i.properties) return
    const r = LGraphCanvas.active_canvas,
      a = r.getCanvasWindow(),
      s = []
    for (const c in i.properties) {
      'object' ==
        typeof (e = void 0 !== i.properties[c] ? i.properties[c] : ' ') &&
        (e = JSON.stringify(e))
      const t = i.getPropertyInfo(c)
      ;('enum' != t.type && 'combo' != t.type) ||
        (e = LGraphCanvas.getPropertyPrintableValue(e, t.values)),
        (e = LGraphCanvas.decodeHTML(stringOrNull(e))),
        s.push({
          content:
            "<span class='property_name'>" +
            (t.label || c) +
            "</span><span class='property_value'>" +
            e +
            '</span>',
          value: c
        })
    }
    if (s.length)
      return (
        new LiteGraph.ContextMenu(
          s,
          { event: n, callback: l, parentMenu: o, allow_html: !0, node: i },
          a
        ),
        __name(l, 'inner_clicked'),
        !1
      )
    function l(e) {
      if (!i) return
      const t = this.getBoundingClientRect()
      r.showEditPropertyValue(i, e.value, { position: [t.left, t.top] })
    }
  }
  static decodeHTML(e) {
    const t = document.createElement('div')
    return (t.innerText = e), t.innerHTML
  }
  static onMenuResizeNode(e, t, n, o, i) {
    if (!i) return
    const r = __name(function (e) {
        ;(e.size = e.computeSize()), e.onResize?.(e.size)
      }, 'fApplyMultiNode'),
      a = LGraphCanvas.active_canvas
    if (!a.selected_nodes || Object.keys(a.selected_nodes).length <= 1) r(i)
    else for (const s in a.selected_nodes) r(a.selected_nodes[s])
    a.setDirty(!0, !0)
  }
  static onShowPropertyEditor(e, t, n, o, i) {
    const r = e.property || 'title',
      a = i[r],
      s = document.createElement('div')
    ;(s.is_modified = !1),
      (s.className = 'graphdialog'),
      (s.innerHTML =
        "<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>"),
      (s.close = function () {
        s.parentNode?.removeChild(s)
      })
    s.querySelector('.name').innerText = r
    const l = s.querySelector('.value')
    l &&
      ((l.value = a),
      l.addEventListener('blur', function () {
        this.focus()
      }),
      l.addEventListener('keydown', function (e) {
        if (((s.is_modified = !0), 27 == e.keyCode)) s.close()
        else if (13 == e.keyCode) f()
        else if (13 != e.keyCode && 'textarea' != e.target.localName) return
        e.preventDefault(), e.stopPropagation()
      }))
    const c = LGraphCanvas.active_canvas,
      d = c.canvas,
      u = d.getBoundingClientRect()
    let p = -20,
      h = -20
    u && ((p -= u.left), (h -= u.top)),
      n
        ? ((s.style.left = n.clientX + p + 'px'),
          (s.style.top = n.clientY + h + 'px'))
        : ((s.style.left = 0.5 * d.width + p + 'px'),
          (s.style.top = 0.5 * d.height + h + 'px'))
    s.querySelector('button').addEventListener('click', f),
      d.parentNode.appendChild(s),
      l?.focus()
    let m = null
    function f() {
      l && _(l.value)
    }
    function _(t) {
      'Number' == e.type
        ? (t = Number(t))
        : 'Boolean' == e.type && (t = Boolean(t)),
        (i[r] = t),
        s.parentNode?.removeChild(s),
        c.setDirty(!0, !0)
    }
    s.addEventListener('mouseleave', function () {
      LiteGraph.dialog_close_on_mouse_leave &&
        !s.is_modified &&
        LiteGraph.dialog_close_on_mouse_leave &&
        (m = setTimeout(s.close, LiteGraph.dialog_close_on_mouse_leave_delay))
    }),
      s.addEventListener('mouseenter', function () {
        LiteGraph.dialog_close_on_mouse_leave && m && clearTimeout(m)
      }),
      __name(f, 'inner'),
      __name(_, 'setValue')
  }
  static getPropertyPrintableValue(e, t) {
    if (!t) return String(e)
    if (Array.isArray(t)) return String(e)
    if ('object' == typeof t) {
      let n = ''
      for (const o in t)
        if (t[o] == e) {
          n = o
          break
        }
      return String(e) + ' (' + n + ')'
    }
  }
  static onMenuNodeCollapse(e, t, n, o, i) {
    i.graph.beforeChange()
    const r = __name(function (e) {
        e.collapse()
      }, 'fApplyMultiNode'),
      a = LGraphCanvas.active_canvas
    if (!a.selected_nodes || Object.keys(a.selected_nodes).length <= 1) r(i)
    else for (const s in a.selected_nodes) r(a.selected_nodes[s])
    i.graph.afterChange()
  }
  static onMenuToggleAdvanced(e, t, n, o, i) {
    i.graph.beforeChange()
    const r = __name(function (e) {
        e.toggleAdvanced()
      }, 'fApplyMultiNode'),
      a = LGraphCanvas.active_canvas
    if (!a.selected_nodes || Object.keys(a.selected_nodes).length <= 1) r(i)
    else for (const s in a.selected_nodes) r(a.selected_nodes[s])
    i.graph.afterChange()
  }
  static onMenuNodePin(e, t, n, o, i) {}
  static onMenuNodeMode(e, t, n, o, i) {
    function r(e) {
      if (!i) return
      const t = Object.values(LiteGraph.NODE_MODES).indexOf(e),
        n = __name(function (n) {
          t >= 0 && LiteGraph.NODE_MODES[t]
            ? n.changeMode(t)
            : (console.warn('unexpected mode: ' + e),
              n.changeMode(LGraphEventMode.ALWAYS))
        }, 'fApplyMultiNode'),
        o = LGraphCanvas.active_canvas
      if (!o.selected_nodes || Object.keys(o.selected_nodes).length <= 1) n(i)
      else for (const i in o.selected_nodes) n(o.selected_nodes[i])
    }
    return (
      new LiteGraph.ContextMenu(LiteGraph.NODE_MODES, {
        event: n,
        callback: r,
        parentMenu: o,
        node: i
      }),
      __name(r, 'inner_clicked'),
      !1
    )
  }
  static onMenuNodeColors(e, t, n, o, i) {
    if (!i) throw 'no node for color'
    const r = []
    r.push({
      value: null,
      content:
        "<span style='display: block; padding-left: 4px;'>No color</span>"
    })
    for (const s in LGraphCanvas.node_colors) {
      const t = LGraphCanvas.node_colors[s]
      ;(e = {
        value: s,
        content:
          "<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid " +
          t.color +
          '; background-color:' +
          t.bgcolor +
          "'>" +
          s +
          '</span>'
      }),
        r.push(e)
    }
    function a(e) {
      if (!i) return
      const t = e.value ? LGraphCanvas.node_colors[e.value] : null,
        n = __name(function (e) {
          t
            ? e instanceof LGraphGroup
              ? (e.color = t.groupcolor)
              : ((e.color = t.color), (e.bgcolor = t.bgcolor))
            : (delete e.color, delete e.bgcolor)
        }, 'fApplyColor'),
        o = LGraphCanvas.active_canvas
      if (!o.selected_nodes || Object.keys(o.selected_nodes).length <= 1) n(i)
      else for (const i in o.selected_nodes) n(o.selected_nodes[i])
      o.setDirty(!0, !0)
    }
    return (
      new LiteGraph.ContextMenu(r, {
        event: n,
        callback: a,
        parentMenu: o,
        node: i
      }),
      __name(a, 'inner_clicked'),
      !1
    )
  }
  static onMenuNodeShapes(e, t, n, o, i) {
    if (!i) throw 'no node passed'
    function r(e) {
      if (!i) return
      i.graph.beforeChange()
      const t = __name(function (t) {
          t.shape = e
        }, 'fApplyMultiNode'),
        n = LGraphCanvas.active_canvas
      if (!n.selected_nodes || Object.keys(n.selected_nodes).length <= 1) t(i)
      else for (const o in n.selected_nodes) t(n.selected_nodes[o])
      i.graph.afterChange(), n.setDirty(!0)
    }
    return (
      new LiteGraph.ContextMenu(LiteGraph.VALID_SHAPES, {
        event: n,
        callback: r,
        parentMenu: o,
        node: i
      }),
      __name(r, 'inner_clicked'),
      !1
    )
  }
  static onMenuNodeRemove(e, t, n, o, i) {
    if (!i) throw 'no node passed'
    const r = i.graph
    r.beforeChange()
    const a = __name(function (e) {
        !1 !== e.removable && r.remove(e)
      }, 'fApplyMultiNode'),
      s = LGraphCanvas.active_canvas
    if (!s.selected_nodes || Object.keys(s.selected_nodes).length <= 1) a(i)
    else for (const l in s.selected_nodes) a(s.selected_nodes[l])
    r.afterChange(), s.setDirty(!0, !0)
  }
  static onMenuNodeToSubgraph(e, t, n, o, i) {
    const r = i.graph,
      a = LGraphCanvas.active_canvas
    if (!a) return
    let s = Object.values(a.selected_nodes || {})
    s.length || (s = [i])
    const l = LiteGraph.createNode('graph/subgraph')
    ;(l.pos = i.pos.concat()),
      r.add(l),
      l.buildFromNodes(s),
      a.deselectAll(),
      a.setDirty(!0, !0)
  }
  static onMenuNodeClone(e, t, n, o, i) {
    const r = i.graph
    r.beforeChange()
    const a = new Set(),
      s = __name(function (e, t) {
        if (!1 === e.clonable) return
        const n = e.clone()
        n && ((n.pos = [e.pos[0] + 5, e.pos[1] + 5]), e.graph.add(n), t.add(n))
      }, 'fApplyMultiNode'),
      l = LGraphCanvas.active_canvas
    if (!l.selected_nodes || Object.keys(l.selected_nodes).length <= 1) s(i, a)
    else for (const c in l.selected_nodes) s(l.selected_nodes[c], a)
    a.size && l.selectNodes([...a]), r.afterChange(), l.setDirty(!0, !0)
  }
  clear() {
    ;(this.frame = 0),
      (this.last_draw_time = 0),
      (this.render_time = 0),
      (this.fps = 0),
      (this.dragging_rectangle = null),
      (this.selected_nodes = {}),
      (this.selected_group = null),
      (this.visible_nodes = []),
      (this.node_over = null),
      (this.node_capturing_input = null),
      (this.connecting_links = null),
      (this.highlighted_links = {}),
      (this.dragging_canvas = !1),
      this.#D(),
      (this.dirty_area = null),
      (this.node_in_panel = null),
      (this.node_widget = null),
      (this.last_mouse = [0, 0]),
      (this.last_mouseclick = 0),
      this.pointer.reset(),
      this.visible_area.set([0, 0, 0, 0]),
      this.onClear?.()
  }
  setGraph(e, t) {
    this.graph != e &&
      (t || this.clear(),
      e || !this.graph
        ? (e.attachCanvas(this),
          (this._graph_stack &&= null),
          this.setDirty(!0, !0))
        : this.graph.detachCanvas(this))
  }
  getTopGraph() {
    return this._graph_stack.length ? this._graph_stack[0] : this.graph
  }
  getCurrentGraph() {
    return this.graph
  }
  #R(e) {
    if ('string' == typeof e) {
      const t = document.getElementById(e)
      if (!(t instanceof HTMLCanvasElement))
        throw 'Error validating LiteGraph canvas: Canvas element not found'
      return t
    }
    return e
  }
  setCanvas(e, t) {
    const n = this.#R(e)
    if (n === this.canvas) return
    if (
      (n || !this.canvas || t || this.unbindEvents(),
      (this.canvas = n),
      (this.ds.element = n),
      (this.pointer.element = n),
      !n)
    )
      return
    if (
      ((n.className += ' lgraphcanvas'),
      (n.data = this),
      (n.tabindex = '1'),
      (this.bgcanvas = null),
      this.bgcanvas ||
        ((this.bgcanvas = document.createElement('canvas')),
        (this.bgcanvas.width = this.canvas.width),
        (this.bgcanvas.height = this.canvas.height)),
      null == n.getContext)
    ) {
      if ('canvas' != n.localName)
        throw (
          'Element supplied for LGraphCanvas must be a <canvas> element, you passed a ' +
          n.localName
        )
      throw "This browser doesn't support Canvas"
    }
    null == (this.ctx = n.getContext('2d')) &&
      (n.webgl_enabled ||
        console.warn('This canvas seems to be WebGL, enabling WebGL renderer'),
      this.enableWebGL()),
      t || this.bindEvents()
  }
  _doNothing(e) {
    return e.preventDefault(), !1
  }
  _doReturnTrue(e) {
    return e.preventDefault(), !0
  }
  bindEvents() {
    if (this._events_binded)
      return void console.warn('LGraphCanvas: events already binded')
    const e = this.canvas,
      t = this.getCanvasWindow().document
    ;(this._mousedown_callback = this.processMouseDown.bind(this)),
      (this._mousewheel_callback = this.processMouseWheel.bind(this)),
      (this._mousemove_callback = this.processMouseMove.bind(this)),
      (this._mouseup_callback = this.processMouseUp.bind(this)),
      (this._mouseout_callback = this.processMouseOut.bind(this)),
      (this._mousecancel_callback = this.processMouseCancel.bind(this)),
      LiteGraph.pointerListenerAdd(e, 'down', this._mousedown_callback, !0),
      e.addEventListener('mousewheel', this._mousewheel_callback, !1),
      LiteGraph.pointerListenerAdd(e, 'up', this._mouseup_callback, !0),
      LiteGraph.pointerListenerAdd(e, 'move', this._mousemove_callback),
      e.addEventListener('pointerout', this._mouseout_callback),
      e.addEventListener('pointercancel', this._mousecancel_callback, !0),
      e.addEventListener('contextmenu', this._doNothing),
      e.addEventListener('DOMMouseScroll', this._mousewheel_callback, !1),
      (this._key_callback = this.processKey.bind(this)),
      e.addEventListener('keydown', this._key_callback, !0),
      t.addEventListener('keyup', this._key_callback, !0),
      (this._ondrop_callback = this.processDrop.bind(this)),
      e.addEventListener('dragover', this._doNothing, !1),
      e.addEventListener('dragend', this._doNothing, !1),
      e.addEventListener('drop', this._ondrop_callback, !1),
      e.addEventListener('dragenter', this._doReturnTrue, !1),
      (this._events_binded = !0)
  }
  unbindEvents() {
    if (!this._events_binded)
      return void console.warn('LGraphCanvas: no events binded')
    const e = this.getCanvasWindow().document
    this.canvas.removeEventListener(
      'pointercancel',
      this._mousecancel_callback
    ),
      this.canvas.removeEventListener('pointerout', this._mouseout_callback),
      LiteGraph.pointerListenerRemove(
        this.canvas,
        'move',
        this._mousemove_callback
      ),
      LiteGraph.pointerListenerRemove(
        this.canvas,
        'up',
        this._mouseup_callback
      ),
      LiteGraph.pointerListenerRemove(
        this.canvas,
        'down',
        this._mousedown_callback
      ),
      this.canvas.removeEventListener('mousewheel', this._mousewheel_callback),
      this.canvas.removeEventListener(
        'DOMMouseScroll',
        this._mousewheel_callback
      ),
      this.canvas.removeEventListener('keydown', this._key_callback),
      e.removeEventListener('keyup', this._key_callback),
      this.canvas.removeEventListener('contextmenu', this._doNothing),
      this.canvas.removeEventListener('drop', this._ondrop_callback),
      this.canvas.removeEventListener('dragenter', this._doReturnTrue),
      (this._mousedown_callback = null),
      (this._mousewheel_callback = null),
      (this._key_callback = null),
      (this._ondrop_callback = null),
      (this._events_binded = !1)
  }
  enableWebGL() {
    if ('undefined' == typeof GL)
      throw 'litegl.js must be included to use a WebGL canvas'
    if ('undefined' == typeof enableWebGLCanvas)
      throw 'webglCanvas.js must be included to use this feature'
    ;(this.gl = this.ctx = enableWebGLCanvas(this.canvas)),
      (this.ctx.webgl = !0),
      (this.bgcanvas = this.canvas),
      (this.bgctx = this.gl),
      (this.canvas.webgl_enabled = !0)
  }
  setDirty(e, t) {
    e && (this.dirty_canvas = !0), t && (this.dirty_bgcanvas = !0)
  }
  #D() {
    ;(this.dirty_canvas = !0), (this.dirty_bgcanvas = !0)
  }
  getCanvasWindow() {
    if (!this.canvas) return window
    const e = this.canvas.ownerDocument
    return e.defaultView || e.parentWindow
  }
  startRendering() {
    function e() {
      this.pause_rendering || this.draw()
      const t = this.getCanvasWindow()
      if (this.is_rendering)
        if (this.#O > 0) {
          const t = this.#O - (LiteGraph.getTime() - this.last_draw_time)
          setTimeout(e.bind(this), Math.max(1, t))
        } else t.requestAnimationFrame(e.bind(this))
    }
    this.is_rendering ||
      ((this.is_rendering = !0), e.call(this), __name(e, 'renderFrame'))
  }
  stopRendering() {
    this.is_rendering = !1
  }
  blockClick() {
    ;(this.block_click = !0), (this.last_mouseclick = 0)
  }
  getWidgetAtCursor(e) {
    if (((e ??= this.node_over), !e.widgets)) return null
    const t = this.graph_mouse,
      n = t[0] - e.pos[0],
      o = t[1] - e.pos[1]
    for (const i of e.widgets) {
      if (i.hidden || (i.advanced && !e.showAdvanced)) continue
      let t, r
      if (
        (i.computeSize
          ? ([t, r] = i.computeSize(e.size[0]))
          : ((t = i.width || e.size[0]), (r = LiteGraph.NODE_WIDGET_HEIGHT)),
        void 0 !== i.last_y &&
          n >= 6 &&
          n <= t - 12 &&
          o >= i.last_y &&
          o <= i.last_y + r)
      )
        return i
    }
    return null
  }
  updateMouseOverNodes(e, t) {
    const n = this.graph._nodes,
      o = n.length
    for (let i = 0; i < o; ++i)
      n[i].mouseOver &&
        e != n[i] &&
        ((n[i].mouseOver = null),
        (this._highlight_input = null),
        (this._highlight_pos = null),
        (this.link_over_widget = null),
        (n[i].lostFocusAt = LiteGraph.getTime()),
        this.node_over?.onMouseLeave?.(t),
        (this.node_over = null),
        (this.dirty_canvas = !0))
  }
  processMouseDown(e) {
    const { graph: t, pointer: n } = this
    if (
      (this.adjustMouseEvent(e),
      e.isPrimary && n.down(e),
      this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0),
      !t)
    )
      return
    const o = this.getCanvasWindow()
    LGraphCanvas.active_canvas = this
    const i = e.clientX,
      r = e.clientY
    this.ds.viewport = this.viewport
    if (!(!this.viewport || isInRect(i, r, this.viewport))) return
    const a = t.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes)
    ;(this.mouse[0] = i),
      (this.mouse[1] = r),
      (this.graph_mouse[0] = e.canvasX),
      (this.graph_mouse[1] = e.canvasY),
      (this.last_click_position = [this.mouse[0], this.mouse[1]]),
      (n.isDouble = n.isDown && e.isPrimary),
      (n.isDown = !0),
      this.canvas.focus(),
      LiteGraph.closeAllContextMenus(o),
      1 != this.onMouse?.(e) &&
        (0 !== e.button || n.isDouble
          ? 1 === e.button
            ? this.#N(e, a)
            : (2 !== e.button && !n.isDouble) ||
              !this.allow_interaction ||
              this.read_only ||
              (a && this.processSelect(a, e, !0), this.processContextMenu(a, e))
          : this.#M(e, a),
        (this.last_mouse = [i, r]),
        (this.last_mouseclick = LiteGraph.getTime()),
        (this.last_mouse_dragging = !0),
        t.change(),
        (!o.document.activeElement ||
          ('input' != o.document.activeElement.nodeName.toLowerCase() &&
            'textarea' != o.document.activeElement.nodeName.toLowerCase())) &&
          e.preventDefault(),
        e.stopPropagation(),
        this.onMouseDown?.(e))
  }
  #M(e, t) {
    const { pointer: n, graph: o } = this,
      i = e.canvasX,
      r = e.canvasY,
      a = e.ctrlKey || e.metaKey
    if (a && !e.altKey) {
      const e = new Float32Array(4)
      return (
        (e[0] = i),
        (e[1] = r),
        (e[2] = 1),
        (e[3] = 1),
        (n.onClick = (e) => {
          const n =
            t ??
            (this.reroutesEnabled
              ? o.getRerouteOnPos(e.canvasX, e.canvasY)
              : null) ??
            o.getGroupTitlebarOnPos(e.canvasX, e.canvasY)
          this.processSelect(n, e)
        }),
        (n.onDragStart = () => (this.dragging_rectangle = e)),
        (n.onDragEnd = (t) => this.#B(t, e)),
        void (n.finally = () => (this.dragging_rectangle = null))
      )
    }
    if (this.read_only)
      return (
        (n.finally = () => (this.dragging_canvas = !1)),
        void (this.dragging_canvas = !0)
      )
    if (
      LiteGraph.alt_drag_do_clone_nodes &&
      e.altKey &&
      !e.ctrlKey &&
      t &&
      this.allow_interaction
    ) {
      const e = t.clone()?.serialize(),
        i = LiteGraph.createNode(e.type)
      if (i)
        return (
          i.configure(e),
          (i.pos[0] += 5),
          (i.pos[1] += 5),
          void (this.allow_dragnodes
            ? ((n.onDragStart = (e) => {
                o.add(i, !1), this.#F(i, e)
              }),
              (n.onDragEnd = (e) => this.#z(e)))
            : (o.beforeChange(), o.add(i, !1), o.afterChange()))
        )
    }
    if (t && (this.allow_interaction || t.flags.allow_interaction))
      this.#H(e, a, t)
    else {
      if (this.reroutesEnabled) {
        const t = o.getRerouteOnPos(i, r)
        if (t) {
          if (e.shiftKey) {
            const e = o._links.get(t.linkIds.values().next().value),
              i = o.getNodeById(e.origin_id),
              r = e.origin_slot,
              a = {
                node: i,
                slot: r,
                input: null,
                pos: i.getConnectionPos(!1, r),
                afterRerouteId: t.id
              }
            ;(this.connecting_links = [a]),
              (n.onDragStart = () => (a.output = i.outputs[r])),
              (this.dirty_bgcanvas = !0)
          }
          return (
            (n.onClick = () => this.processSelect(t, e)),
            void (
              n.onDragStart ||
              ((n.onDragStart = (e) => this.#F(t, e, !0)),
              (n.onDragEnd = (e) => this.#z(e)))
            )
          )
        }
      }
      const { lineWidth: t } = this.ctx
      this.ctx.lineWidth = this.connections_width + 7
      const a = window?.devicePixelRatio || 1
      for (const l of this.renderedPaths) {
        const t = l._pos
        if (t)
          if (
            (e.shiftKey || e.altKey) &&
            l.path &&
            this.ctx.isPointInStroke(l.path, i * a, r * a)
          ) {
            if (e.shiftKey && !e.altKey) {
              const e = l.origin_slot,
                t = o._nodes_by_id[l.origin_id],
                i = { node: t, slot: e, pos: t.getConnectionPos(!1, e) }
              return (
                (this.connecting_links = [i]),
                l.parentId && (i.afterRerouteId = l.parentId),
                void (n.onDragStart = () => (i.output = t.outputs[e]))
              )
            }
            if (this.reroutesEnabled && e.altKey && !e.shiftKey) {
              const e = o.createReroute([i, r], l)
              return (
                (n.onDragStart = (t) => this.#F(e, t)),
                void (n.onDragEnd = (e) => this.#z(e))
              )
            }
          } else if (isInRectangle(i, r, t[0] - 4, t[1] - 4, 8, 8))
            return (
              (n.onClick = () => this.showLinkMenu(l, e)),
              (n.onDragStart = () => (this.dragging_canvas = !0)),
              (n.finally = () => (this.dragging_canvas = !1)),
              void (this.over_link_center = null)
            )
      }
      this.ctx.lineWidth = t
      const s = o.getGroupOnPos(i, r)
      if (((this.selected_group = s), s)) {
        if (s.isInResize(i, r)) {
          const e = s.boundingRect,
            t = i - (e[0] + e[2]),
            o = r - (e[1] + e[3])
          ;(n.onDragStart = () => (this.resizingGroup = s)),
            (n.onDrag = (e) => {
              if (this.read_only) return
              const n = [e.canvasX - s.pos[0] - t, e.canvasY - s.pos[1] - o]
              snapPoint(n, this.#P)
              s.resize(n[0], n[1]) && (this.dirty_bgcanvas = !0)
            }),
            (n.finally = () => (this.resizingGroup = null))
        } else {
          const t = 1.4 * (s.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE)
          isInRectangle(i, r, s.pos[0], s.pos[1], s.size[0], t) &&
            ((n.onClick = () => this.processSelect(s, e)),
            (n.onDragStart = (e) => {
              s.recomputeInsideNodes(), this.#F(s, e, !0)
            }),
            (n.onDragEnd = (e) => this.#z(e)))
        }
        n.onDoubleClick = () => {
          this.emitEvent({
            subType: 'group-double-click',
            originalEvent: e,
            group: s
          })
        }
      } else
        n.onDoubleClick = () => {
          this.allow_searchbox && (this.showSearchBox(e), e.preventDefault()),
            this.emitEvent({ subType: 'empty-double-click', originalEvent: e })
        }
    }
    n.onDragStart ||
      n.onClick ||
      n.onDrag ||
      !this.allow_dragcanvas ||
      ((n.onClick = () => this.processSelect(null, e)),
      (n.finally = () => (this.dragging_canvas = !1)),
      (this.dragging_canvas = !0))
  }
  #H(e, t, n) {
    const { pointer: o, graph: i } = this,
      r = e.canvasX,
      a = e.canvasY
    ;(o.onClick = () => this.processSelect(n, e)),
      n.flags.pinned || this.bringToFront(n)
    const s = n.isPointInCollapse(r, a)
    if (s)
      o.onClick = () => {
        n.collapse(), this.setDirty(!0, !0)
      }
    else if (!n.flags.collapsed) {
      if (!1 !== n.resizable && n.inResizeCorner(r, a)) {
        const e = n.boundingRect,
          t = r - (e[0] + e[2]),
          s = a - (e[1] + e[3])
        return (
          (o.onDragStart = () => {
            i.beforeChange(), (this.resizing_node = n)
          }),
          (o.onDrag = (e) => {
            if (this.read_only) return
            const o = [e.canvasX - n.pos[0] - t, e.canvasY - n.pos[1] - s]
            snapPoint(o, this.#P)
            const i = n.computeSize()
            ;(o[0] = Math.max(i[0], o[0])),
              (o[1] = Math.max(i[1], o[1])),
              n.setSize(o),
              this.#D()
          }),
          (o.onDragEnd = (e) => {
            this.#D(), i.afterChange(this.resizing_node)
          }),
          (o.finally = () => (this.resizing_node = null)),
          void (this.canvas.style.cursor = 'se-resize')
        )
      }
      if (n.outputs)
        for (let s = 0, l = n.outputs.length; s < l; ++s) {
          const l = n.outputs[s],
            c = n.getConnectionPos(!1, s)
          if (isInRectangle(r, a, c[0] - 15, c[1] - 10, 30, 20)) {
            if (e.shiftKey && l.links?.length > 0) {
              this.connecting_links = []
              for (const e of l.links) {
                const t = i._links.get(e),
                  o = t.target_slot,
                  r = i._nodes_by_id[t.target_id],
                  a = r.inputs[o],
                  s = r.getConnectionPos(!0, o)
                this.connecting_links.push({
                  node: r,
                  slot: o,
                  input: a,
                  output: null,
                  pos: s,
                  direction:
                    !0 !== n.horizontal
                      ? LinkDirection.RIGHT
                      : LinkDirection.CENTER
                })
              }
              return
            }
            return (
              (l.slot_index = s),
              (this.connecting_links = [
                { node: n, slot: s, input: null, output: l, pos: c }
              ]),
              LiteGraph.shift_click_do_break_link_from
                ? e.shiftKey && n.disconnectOutput(s)
                : LiteGraph.ctrl_alt_click_do_break_link &&
                  t &&
                  e.altKey &&
                  !e.shiftKey &&
                  n.disconnectOutput(s),
              (o.onDoubleClick = () => n.onOutputDblClick?.(s, e)),
              void (o.onClick = () => n.onOutputClick?.(s, e))
            )
          }
        }
      if (n.inputs)
        for (let s = 0, l = n.inputs.length; s < l; ++s) {
          const l = n.inputs[s],
            c = n.getConnectionPos(!0, s)
          if (isInRectangle(r, a, c[0] - 15, c[1] - 10, 30, 20)) {
            if (
              ((o.onDoubleClick = () => n.onInputDblClick?.(s, e)),
              (o.onClick = () => n.onInputClick?.(s, e)),
              null !== l.link)
            ) {
              const r = i._links.get(l.link),
                a = r.origin_slot,
                c = i._nodes_by_id[r.origin_id]
              if (
                LiteGraph.click_do_break_link_to ||
                (LiteGraph.ctrl_alt_click_do_break_link &&
                  t &&
                  e.altKey &&
                  !e.shiftKey)
              )
                n.disconnectInput(s)
              else if (e.shiftKey || this.allow_reconnect_links) {
                const e = {
                  node: c,
                  slot: a,
                  output: c.outputs[a],
                  pos: c.getConnectionPos(!1, a)
                }
                ;(this.connecting_links = [e]),
                  (o.onDragStart = () => {
                    this.allow_reconnect_links &&
                      !LiteGraph.click_do_break_link_to &&
                      n.disconnectInput(s),
                      (e.output = c.outputs[a])
                  }),
                  (this.dirty_bgcanvas = !0)
              }
            }
            if (!o.onDragStart) {
              const e = { node: n, slot: s, output: null, pos: c }
              ;(this.connecting_links = [e]),
                (o.onDragStart = () => (e.input = l)),
                (this.dirty_bgcanvas = !0)
            }
            return
          }
        }
    }
    const l = [r - n.pos[0], a - n.pos[1]],
      c = n.getWidgetOnPos(r, a)
    if (c) this.#j(e, n, c), (this.node_widget = [n, c])
    else {
      if (
        ((o.onDoubleClick = () => {
          l[1] < 0 && !s && n.onNodeTitleDblClick?.(e, l, this),
            n.onDblClick?.(e, l, this),
            this.processNodeDblClicked(n)
        }),
        n.onMouseDown?.(e, l, this) || !this.allow_dragnodes)
      )
        return
      ;(o.onDragStart = (e) => this.#F(n, e, !0)),
        (o.onDragEnd = (e) => this.#z(e))
    }
    this.dirty_canvas = !0
  }
  #j(e, node, widget) {
    const { pointer: pointer } = this
    if ('function' == typeof widget.onPointerDown) {
      const e = widget.onPointerDown(pointer, node, this)
      if (e) return
    }
    const width = widget.width || node.width,
      oldValue = widget.value,
      pos = this.graph_mouse,
      x = pos[0] - node.pos[0],
      y = pos[1] - node.pos[1]
    switch (widget.type) {
      case 'button':
        pointer.onClick = () => {
          widget.callback?.(widget, this, node, pos, e),
            (widget.clicked = !0),
            (this.dirty_canvas = !0)
        }
        break
      case 'slider':
        if (widget.options.read_only) break
        pointer.onDrag = (e) => {
          const t = clamp$1((e.canvasX - node.pos[0] - 15) / (width - 30), 0, 1)
          ;(widget.value =
            widget.options.min + (widget.options.max - widget.options.min) * t),
            oldValue != widget.value &&
              setWidgetValue(this, node, widget, widget.value),
            (this.dirty_canvas = !0)
        }
        break
      case 'number': {
        const delta = x < 40 ? -1 : x > width - 40 ? 1 : 0
        ;(pointer.onClick = (upEvent) => {
          let newValue = widget.value + 0.1 * delta * (widget.options.step || 1)
          null != widget.options.min &&
            newValue < widget.options.min &&
            (newValue = widget.options.min),
            null != widget.options.max &&
              newValue > widget.options.max &&
              (newValue = widget.options.max),
            newValue !== widget.value &&
              setWidgetValue(this, node, widget, newValue),
            0 === delta &&
              (this.prompt(
                'Value',
                widget.value,
                (v) => {
                  if (/^[0-9+\-*/()\s]+|\d+\.\d+$/.test(v))
                    try {
                      v = eval(v)
                    } catch {}
                  ;(widget.value = Number(v)),
                    setWidgetValue(this, node, widget, widget.value)
                },
                e
              ),
              (this.dirty_canvas = !0))
        }),
          (pointer.onDrag = (e) => {
            const t = e.canvasX - node.pos[0]
            if (delta && t > -3 && t < width + 3) return
            let n = widget.value
            e.deltaX && (n += 0.1 * e.deltaX * (widget.options.step || 1)),
              null != widget.options.min &&
                n < widget.options.min &&
                (n = widget.options.min),
              null != widget.options.max &&
                n > widget.options.max &&
                (n = widget.options.max),
              n !== widget.value && setWidgetValue(this, node, widget, n)
          })
        break
      }
      case 'combo': {
        let t, n
        pointer.onClick = (o) => {
          const i = x < 40 ? -1 : x > width - 40 ? 1 : 0
          if (
            ((t = widget.options.values),
            'function' == typeof t && (t = t(widget, node)),
            (n = null),
            (n = Array.isArray(t) ? t : Object.keys(t)),
            i)
          ) {
            let e = -1
            return (
              (this.last_mouseclick = 0),
              (e =
                'object' == typeof t
                  ? n.indexOf(String(widget.value)) + i
                  : n.indexOf(widget.value) + i),
              e >= n.length && (e = n.length - 1),
              e < 0 && (e = 0),
              (widget.value = Array.isArray(t) ? t[e] : e),
              oldValue != widget.value &&
                setWidgetValue(this, node, widget, widget.value),
              void (this.dirty_canvas = !0)
            )
          }
          const r = t != n ? Object.values(t) : t
          new LiteGraph.ContextMenu(r, {
            scale: Math.max(1, this.ds.scale),
            event: e,
            className: 'dark',
            callback: __name(
              (e) => (
                (widget.value = t != n ? r.indexOf(e) : e),
                setWidgetValue(this, node, widget, widget.value),
                (this.dirty_canvas = !0),
                !1
              ),
              'callback'
            )
          })
        }
        break
      }
      case 'toggle':
        pointer.onClick = () => {
          ;(widget.value = !widget.value),
            setWidgetValue(this, node, widget, widget.value)
        }
        break
      case 'string':
      case 'text':
        pointer.onClick = () =>
          this.prompt(
            'Value',
            widget.value,
            (e) => setWidgetValue(this, node, widget, e),
            e,
            !!widget.options && widget.options.multiline
          )
        break
      default:
        if (widget.mouse) {
          const t = widget.mouse(e, [x, y], node)
          null != t && (this.dirty_canvas = t)
        }
    }
    function setWidgetValue(t, n, o, i) {
      const r = 'number' === o.type ? Number(i) : i
      ;(o.value = r),
        o.options?.property &&
          void 0 !== n.properties[o.options.property] &&
          n.setProperty(o.options.property, r),
        o.callback?.(o.value, t, n, pos, e),
        n.onWidgetChanged?.(o.name, r, oldValue, o),
        n.graph._version++
    }
    oldValue != widget.value &&
      (node.onWidgetChanged?.(widget.name, widget.value, oldValue, widget),
      node.graph._version++),
      (pointer.finally = () => {
        if (widget.mouse) {
          const { eUp: e } = pointer,
            { canvasX: t, canvasY: n } = e
          widget.mouse(e, [t - node.pos[0], n - node.pos[1]], node)
        }
        this.node_widget = null
      }),
      __name(setWidgetValue, 'setWidgetValue')
  }
  #N(e, t) {
    const { pointer: n } = this
    if (
      LiteGraph.middle_click_slot_add_default_node &&
      t &&
      this.allow_interaction &&
      !this.read_only &&
      !this.connecting_links &&
      !t.flags.collapsed
    ) {
      let o = !1,
        i = !1,
        r = !1
      if (t.outputs)
        for (let n = 0, a = t.outputs.length; n < a; ++n) {
          const a = t.outputs[n],
            s = t.getConnectionPos(!1, n)
          if (
            isInRectangle(e.canvasX, e.canvasY, s[0] - 15, s[1] - 10, 30, 20)
          ) {
            ;(o = a), (i = n), (r = !0)
            break
          }
        }
      if (t.inputs)
        for (let n = 0, a = t.inputs.length; n < a; ++n) {
          const a = t.inputs[n],
            s = t.getConnectionPos(!0, n)
          if (
            isInRectangle(e.canvasX, e.canvasY, s[0] - 15, s[1] - 10, 30, 20)
          ) {
            ;(o = a), (i = n), (r = !1)
            break
          }
        }
      if (o && !1 !== i) {
        const o = 0.5 - (i + 1) / (r ? t.outputs.length : t.inputs.length),
          a = t.getBounding(),
          s = [r ? a[0] + a[2] : a[0], e.canvasY - 80]
        n.onClick = () =>
          this.createDefaultNodeForSlot({
            nodeFrom: r ? t : null,
            slotFrom: r ? i : null,
            nodeTo: r ? null : t,
            slotTo: r ? null : i,
            position: s,
            nodeType: 'AUTO',
            posAdd: [r ? 30 : -30, 130 * -o],
            posSizeFix: [r ? 0 : -1, 0]
          })
      }
    }
    this.allow_dragcanvas &&
      ((n.onDragStart = () => (this.dragging_canvas = !0)),
      (n.finally = () => (this.dragging_canvas = !1)))
  }
  processMouseMove(e) {
    if (
      (this.autoresize && this.resize(),
      this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0),
      !this.graph)
    )
      return
    ;(LGraphCanvas.active_canvas = this), this.adjustMouseEvent(e)
    const t = [e.clientX, e.clientY]
    ;(this.mouse[0] = t[0]), (this.mouse[1] = t[1])
    const n = [t[0] - this.last_mouse[0], t[1] - this.last_mouse[1]]
    if (
      ((this.last_mouse = t),
      (this.graph_mouse[0] = e.canvasX),
      (this.graph_mouse[1] = e.canvasY),
      e.isPrimary && this.pointer.move(e),
      this.block_click)
    )
      return void e.preventDefault()
    if (((e.dragging = this.last_mouse_dragging), this.node_widget)) {
      const [t, n] = this.node_widget
      if (n?.mouse) {
        const o = e.canvasX - t.pos[0],
          i = e.canvasY - t.pos[1],
          r = n.mouse(e, [o, i], t)
        null != r && (this.dirty_canvas = r)
      }
    }
    let o = CanvasItem.Nothing
    const i = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes),
      { resizingGroup: r } = this,
      a = this.dragging_rectangle
    if (a)
      (a[2] = e.canvasX - a[0]),
        (a[3] = e.canvasY - a[1]),
        (this.dirty_canvas = !0)
    else if (r) o |= CanvasItem.ResizeSe | CanvasItem.Group
    else if (this.dragging_canvas)
      (this.ds.offset[0] += n[0] / this.ds.scale),
        (this.ds.offset[1] += n[1] / this.ds.scale),
        this.#D()
    else if (
      (this.allow_interaction || (i && i.flags.allow_interaction)) &&
      !this.read_only
    ) {
      if (
        (this.connecting_links && (this.dirty_canvas = !0),
        this.updateMouseOverNodes(i, e),
        i)
      ) {
        ;(o |= CanvasItem.Node), i.redraw_on_mouse && (this.dirty_canvas = !0)
        const t = [0, 0],
          n = this.isOverNodeInput(i, e.canvasX, e.canvasY, t),
          r = this.isOverNodeOutput(i, e.canvasX, e.canvasY, t),
          a = this.getWidgetAtCursor(i)
        if (
          (i.mouseOver ||
            ((i.mouseOver = {
              inputId: null,
              outputId: null,
              overWidget: null
            }),
            (this.node_over = i),
            (this.dirty_canvas = !0),
            i.onMouseEnter?.(e)),
          i.onMouseMove?.(
            e,
            [e.canvasX - i.pos[0], e.canvasY - i.pos[1]],
            this
          ),
          i.mouseOver.inputId !== n ||
            i.mouseOver.outputId !== r ||
            i.mouseOver.overWidget !== a)
        ) {
          if (
            ((i.mouseOver.inputId = n),
            (i.mouseOver.outputId = r),
            (i.mouseOver.overWidget = a),
            this.connecting_links?.length)
          ) {
            const e = this.connecting_links[0]
            let o = null,
              s = null,
              l = null
            if (e.node === i);
            else if (e.output)
              if (-1 === n && -1 === r) {
                if (this.getWidgetLinkType && a) {
                  const t = this.getWidgetLinkType(a, i)
                  t &&
                    LiteGraph.isValidConnection(e.output.type, t) &&
                    !1 !==
                      e.node.isValidWidgetLink?.(e.output.slot_index, i, a) &&
                    ((l = a), (this.link_over_widget_type = t))
                }
                if (!l) {
                  const n = e.node.findConnectByTypeSlot(!0, i, e.output.type)
                  null !== n &&
                    n >= 0 &&
                    (i.getConnectionPos(!0, n, t), (o = t), (s = i.inputs[n]))
                }
              } else
                -1 != n &&
                  i.inputs[n] &&
                  LiteGraph.isValidConnection(
                    e.output.type,
                    i.inputs[n].type
                  ) &&
                  -1 != n &&
                  i.inputs[n] &&
                  LiteGraph.isValidConnection(
                    e.output.type,
                    i.inputs[n].type
                  ) &&
                  ((o = t), (s = i.inputs[n]))
            else if (e.input)
              if (-1 === n && -1 === r) {
                const n = e.node.findConnectByTypeSlot(!1, i, e.input.type)
                null !== n && n >= 0 && (i.getConnectionPos(!1, n, t), (o = t))
              } else
                -1 != r &&
                  i.outputs[r] &&
                  LiteGraph.isValidConnection(
                    e.input.type,
                    i.outputs[r].type
                  ) &&
                  (o = t)
            ;(this._highlight_pos = o),
              (this._highlight_input = s),
              (this.link_over_widget = l)
          }
          this.dirty_canvas = !0
        }
        i.inResizeCorner(e.canvasX, e.canvasY) && (o |= CanvasItem.ResizeSe)
      } else {
        const t = this.#U(e)
        if (
          (this.over_link_center !== t &&
            ((o |= CanvasItem.Link),
            (this.over_link_center = t),
            (this.dirty_bgcanvas = !0)),
          this.canvas)
        ) {
          const t = this.graph.getGroupOnPos(e.canvasX, e.canvasY)
          t &&
            !e.ctrlKey &&
            !this.read_only &&
            t.isInResize(e.canvasX, e.canvasY) &&
            (o |= CanvasItem.ResizeSe)
        }
      }
      if (
        (this.node_capturing_input &&
          this.node_capturing_input != i &&
          this.node_capturing_input.onMouseMove?.(
            e,
            [
              e.canvasX - this.node_capturing_input.pos[0],
              e.canvasY - this.node_capturing_input.pos[1]
            ],
            this
          ),
        this.isDragging)
      ) {
        const t = this.selectedItems,
          o = e.ctrlKey ? t : getAllNestedItems(t),
          i = n[0] / this.ds.scale,
          r = n[1] / this.ds.scale
        for (const e of o) e.move(i, r, !0)
        this.#D()
      }
      this.resizing_node && (o |= CanvasItem.ResizeSe)
    }
    ;(this.state.hoveringOver = o),
      this.state.shouldSetCursor &&
        (o
          ? o & CanvasItem.ResizeSe
            ? (this.canvas.style.cursor = 'se-resize')
            : o & CanvasItem.Node && (this.canvas.style.cursor = 'crosshair')
          : (this.canvas.style.cursor = '')),
      e.preventDefault()
  }
  #F(e, t, n = !1) {
    this.emitBeforeChange(),
      this.graph.beforeChange(),
      (t.finally = () => {
        ;(this.isDragging = !1),
          this.graph.afterChange(),
          this.emitAfterChange()
      }),
      this.processSelect(e, t.eDown, n),
      (this.isDragging = !0)
  }
  #z(e) {
    const { graph: t } = this
    ;(e.shiftKey || LiteGraph.alwaysSnapToGrid) &&
      t.snapToGrid(this.selectedItems),
      (this.dirty_canvas = !0),
      (this.dirty_bgcanvas = !0),
      this.onNodeMoved?.(findFirstNode(this.selectedItems))
  }
  processMouseUp(e) {
    if (!1 === e.isPrimary) return
    const { graph: t, pointer: n } = this
    if (!t) return
    ;(LGraphCanvas.active_canvas = this), this.adjustMouseEvent(e)
    const o = LiteGraph.getTime()
    e.click_time = o - this.last_mouseclick
    if (!0 === n.up(e))
      return (
        (n.isDown = !1),
        (n.isDouble = !1),
        (this.connecting_links = null),
        (this.dragging_canvas = !1),
        t.change(),
        e.stopPropagation(),
        void e.preventDefault()
      )
    if (
      ((this.last_mouse_dragging = !1),
      (this.last_click_position = null),
      (this.block_click &&= !1),
      0 === e.button)
    ) {
      ;(this.selected_group = null), (this.isDragging = !1)
      const n = e.canvasX,
        o = e.canvasY,
        i = t.getNodeOnPos(n, o, this.visible_nodes)
      if (this.connecting_links?.length) {
        const t = this.connecting_links[0]
        if (i) {
          for (const e of this.connecting_links)
            if ((this.#D(), e.output)) {
              const t = this.isOverNodeInput(i, n, o)
              ;-1 != t
                ? e.node.connect(e.slot, i, t, e.afterRerouteId)
                : this.link_over_widget
                  ? (this.emitEvent({
                      subType: 'connectingWidgetLink',
                      link: e,
                      node: i,
                      widget: this.link_over_widget
                    }),
                    (this.link_over_widget = null))
                  : e.node.connectByType(e.slot, i, e.output.type, {
                      afterRerouteId: e.afterRerouteId
                    })
            } else if (e.input) {
              const t = this.isOverNodeOutput(i, n, o)
              ;-1 != t
                ? i.connect(t, e.node, e.slot, e.afterRerouteId)
                : e.node.connectByTypeOutput(e.slot, i, e.input.type, {
                    afterRerouteId: e.afterRerouteId
                  })
            }
        } else if (t.input || t.output) {
          const n = t.output
              ? {
                  node_from: t.node,
                  slot_from: t.output,
                  type_filter_in: t.output.type
                }
              : {
                  node_to: t.node,
                  slot_from: t.input,
                  type_filter_out: t.input.type
                },
            o = { links: this.connecting_links }
          this.emitEvent({
            subType: 'empty-release',
            originalEvent: e,
            linkReleaseContext: o
          }),
            LiteGraph.release_link_on_empty_shows_menu &&
              (e.shiftKey
                ? this.allow_searchbox && this.showSearchBox(e, n)
                : t.output
                  ? this.showConnectionMenu({
                      nodeFrom: t.node,
                      slotFrom: t.output,
                      e: e
                    })
                  : t.input &&
                    this.showConnectionMenu({
                      nodeTo: t.node,
                      slotTo: t.input,
                      e: e
                    }))
        }
      } else
        (this.dirty_canvas = !0),
          this.node_over?.onMouseUp?.(
            e,
            [n - this.node_over.pos[0], o - this.node_over.pos[1]],
            this
          ),
          this.node_capturing_input?.onMouseUp?.(e, [
            n - this.node_capturing_input.pos[0],
            o - this.node_capturing_input.pos[1]
          ])
      this.connecting_links = null
    } else
      1 === e.button
        ? ((this.dirty_canvas = !0), (this.dragging_canvas = !1))
        : 2 === e.button && (this.dirty_canvas = !0)
    ;(n.isDown = !1),
      (n.isDouble = !1),
      t.change(),
      e.stopPropagation(),
      e.preventDefault()
  }
  processMouseOut(e) {
    this.adjustMouseEvent(e), this.updateMouseOverNodes(null, e)
  }
  processMouseCancel(e) {
    console.warn('Pointer cancel!'), this.pointer.reset()
  }
  processMouseWheel(e) {
    if (!this.graph || !this.allow_dragcanvas) return
    const t = e.wheelDeltaY ?? -60 * e.detail
    this.adjustMouseEvent(e)
    const n = [e.clientX, e.clientY]
    if (this.viewport && !isPointInRect(n, this.viewport)) return
    let o = this.ds.scale
    t > 0 ? (o *= this.zoom_speed) : t < 0 && (o *= 1 / this.zoom_speed),
      this.ds.changeScale(o, [e.clientX, e.clientY]),
      this.graph.change(),
      e.preventDefault()
  }
  isOverNodeInput(e, t, n, o) {
    if (e.inputs)
      for (let i = 0, r = e.inputs.length; i < r; ++i) {
        const r = e.inputs[i],
          a = e.getConnectionPos(!0, i)
        let s = !1
        if (e.horizontal) s = isInRectangle(t, n, a[0] - 5, a[1] - 10, 10, 20)
        else {
          const e = 20 + 7 * ((r.label?.length ?? r.name?.length) || 3)
          s = isInRectangle(t, n, a[0] - 10, a[1] - 10, e, 20)
        }
        if (s) return o && ((o[0] = a[0]), (o[1] = a[1])), i
      }
    return -1
  }
  isOverNodeOutput(e, t, n, o) {
    if (e.outputs)
      for (let i = 0, r = e.outputs.length; i < r; ++i) {
        const r = e.getConnectionPos(!1, i)
        let a = !1
        if (
          ((a = e.horizontal
            ? isInRectangle(t, n, r[0] - 5, r[1] - 10, 10, 20)
            : isInRectangle(t, n, r[0] - 10, r[1] - 10, 40, 20)),
          a)
        )
          return o && ((o[0] = r[0]), (o[1] = r[1])), i
      }
    return -1
  }
  processKey(e) {
    if (((this.#V = e.shiftKey), !this.graph)) return
    let t = !1
    if ('input' != e.target.localName) {
      if ('keydown' == e.type) {
        if (
          (32 == e.keyCode
            ? ((this.read_only = !0),
              null === this._previously_dragging_canvas &&
                (this._previously_dragging_canvas = this.dragging_canvas),
              (this.dragging_canvas = this.pointer.isDown),
              (t = !0))
            : 27 == e.keyCode
              ? (this.node_panel?.close(),
                this.options_panel?.close(),
                (t = !0))
              : 65 == e.keyCode && e.ctrlKey
                ? (this.selectItems(), (t = !0))
                : 67 !== e.keyCode || (!e.metaKey && !e.ctrlKey) || e.shiftKey
                  ? 86 === e.keyCode && (e.metaKey || e.ctrlKey)
                    ? this.pasteFromClipboard(e.shiftKey)
                    : (46 != e.keyCode && 8 != e.keyCode) ||
                      ('input' != e.target.localName &&
                        'textarea' != e.target.localName &&
                        (this.deleteSelected(), (t = !0)))
                  : this.selected_nodes && (this.copyToClipboard(), (t = !0)),
          this.selected_nodes)
        )
          for (const t in this.selected_nodes)
            this.selected_nodes[t].onKeyDown?.(e)
      } else if (
        'keyup' == e.type &&
        (32 == e.keyCode &&
          ((this.read_only = !1),
          (this.dragging_canvas = this._previously_dragging_canvas ?? !1),
          (this._previously_dragging_canvas = null)),
        this.selected_nodes)
      )
        for (const t in this.selected_nodes) this.selected_nodes[t].onKeyUp?.(e)
      return (
        this.graph.change(),
        t ? (e.preventDefault(), e.stopImmediatePropagation(), !1) : void 0
      )
    }
  }
  copyToClipboard(e) {
    const t = { nodes: [], groups: [], reroutes: [], links: [] }
    for (const n of e ?? this.selectedItems)
      if (n instanceof LGraphNode) {
        if (!1 === n.clonable) continue
        const e = n.clone()?.serialize()
        if (!e) continue
        ;(e.id = n.id), t.nodes.push(e)
        const o = n.inputs
          ?.map((e) => this.graph._links.get(e?.link)?.asSerialisable())
          .filter((e) => !!e)
        if (!o) continue
        t.links.push(...o)
      } else
        n instanceof LGraphGroup
          ? t.groups.push(n.serialize())
          : this.reroutesEnabled &&
            n instanceof Reroute &&
            t.reroutes.push(n.asSerialisable())
    localStorage.setItem('litegrapheditor_clipboard', JSON.stringify(t))
  }
  emitEvent(e) {
    this.canvas.dispatchEvent(
      new CustomEvent('litegraph:canvas', { bubbles: !0, detail: e })
    )
  }
  emitBeforeChange() {
    this.emitEvent({ subType: 'before-change' })
  }
  emitAfterChange() {
    this.emitEvent({ subType: 'after-change' })
  }
  _pasteFromClipboard(e = !1) {
    if (!LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && e) return
    const t = localStorage.getItem('litegrapheditor_clipboard')
    if (!t) return
    const { graph: n } = this
    n.beforeChange()
    const o = JSON.parse(t)
    ;(o.nodes ??= []), (o.groups ??= []), (o.reroutes ??= []), (o.links ??= [])
    let i = 1 / 0,
      r = 1 / 0
    for (const u of [...o.nodes, ...o.reroutes])
      u.pos[0] < i && (i = u.pos[0]), u.pos[1] < r && (r = u.pos[1])
    if (o.groups)
      for (const u of o.groups)
        u.bounding[0] < i && (i = u.bounding[0]),
          u.bounding[1] < r && (r = u.bounding[1])
    const a = {
        created: [],
        nodes: new Map(),
        links: new Map(),
        reroutes: new Map()
      },
      { created: s, nodes: l, links: c, reroutes: d } = a
    for (const u of o.groups) {
      u.id = void 0
      const e = new LGraphGroup()
      e.configure(u), n.add(e), s.push(e)
    }
    for (const u of o.nodes) {
      const e = LiteGraph.createNode(u.type)
      e &&
        (l.set(u.id, e), (u.id = void 0), e.configure(u), n.add(e), s.push(e))
    }
    for (const u of o.reroutes) {
      const { id: e } = u
      u.id = void 0
      const t = n.setReroute(u)
      s.push(t), d.set(e, t)
    }
    for (const u of d.values()) {
      const e = d.get(u.parentId)
      e && (u.parentId = e.id)
    }
    for (const u of o.links) {
      let t = l.get(u.origin_id),
        o = d.get(u.parentId)?.id
      e &&
        LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs &&
        ((t ??= n.getNodeById(u.origin_id)), (o ??= u.parentId))
      const i = l.get(u.target_id)
      if (i) {
        const e = t?.connect(u.origin_slot, i, u.target_slot, o)
        e && c.set(u.id, e)
      }
    }
    for (const u of d.values()) {
      const e = [...u.linkIds].map((e) => c.get(e)?.id ?? e)
      u.update(u.parentId, void 0, e),
        u.validateLinks(n.links) || n.removeReroute(u.id)
    }
    for (const u of s)
      (u.pos[0] += this.graph_mouse[0] - i),
        (u.pos[1] += this.graph_mouse[1] - r)
    return this.selectItems(s), n.afterChange(), a
  }
  pasteFromClipboard(e = !1) {
    this.emitBeforeChange()
    try {
      this._pasteFromClipboard(e)
    } finally {
      this.emitAfterChange()
    }
  }
  processDrop(e) {
    e.preventDefault(), this.adjustMouseEvent(e)
    const t = e.clientX,
      n = e.clientY
    if (!(!this.viewport || isInRect(t, n, this.viewport))) return
    const o = [e.canvasX, e.canvasY],
      i = this.graph ? this.graph.getNodeOnPos(o[0], o[1]) : null
    if (i) {
      if (i.onDropFile || i.onDropData) {
        const t = e.dataTransfer.files
        if (t && t.length)
          for (let n = 0; n < t.length; n++) {
            const t = e.dataTransfer.files[0],
              n = t.name
            if ((i.onDropFile?.(t), i.onDropData)) {
              const e = new FileReader()
              e.onload = function (e) {
                const o = e.target.result
                i.onDropData(o, n, t)
              }
              const o = t.type.split('/')[0]
              'text' == o || '' == o
                ? e.readAsText(t)
                : 'image' == o
                  ? e.readAsDataURL(t)
                  : e.readAsArrayBuffer(t)
            }
          }
      }
      return !!i.onDropItem?.(e) || (!!this.onDropItem && this.onDropItem(e))
    }
    {
      const t = this.onDropItem?.(e)
      t || this.checkDropItem(e)
    }
  }
  checkDropItem(e) {
    if (!e.dataTransfer.files.length) return
    const t = e.dataTransfer.files[0],
      n = LGraphCanvas.getFileExtension(t.name).toLowerCase(),
      o = LiteGraph.node_types_by_file_extension[n]
    if (!o) return
    this.graph.beforeChange()
    const i = LiteGraph.createNode(o.type)
    ;(i.pos = [e.canvasX, e.canvasY]),
      this.graph.add(i),
      i.onDropFile?.(t),
      this.graph.afterChange()
  }
  processNodeDblClicked(e) {
    this.onShowNodePanel?.(e), this.onNodeDblClicked?.(e), this.setDirty(!0)
  }
  #B(e, t) {
    const { graph: n, selectedItems: o } = this,
      i = Math.abs(t[2]),
      r = Math.abs(t[3])
    t[2] < 0 && (t[0] -= i), t[3] < 0 && (t[1] -= r), (t[2] = i), (t[3] = r)
    const a = [],
      s = []
    for (const l of n._nodes)
      overlapBounding(t, l.boundingRect) &&
        (l.selected && o.has(l) ? a.push(l) : s.push(l))
    for (const l of n.groups)
      containsRect(t, l._bounding) &&
        (l.recomputeInsideNodes(),
        l.selected && o.has(l) ? a.push(l) : s.push(l))
    for (const l of n.reroutes.values())
      isPointInRect(l.pos, t) &&
        (o.add(l),
        (l.selected = !0),
        l.selected && o.has(l) ? a.push(l) : s.push(l))
    if (e.shiftKey) for (const l of s) this.select(l)
    else if (e.altKey) for (const l of a) this.deselect(l)
    else {
      for (const e of o.values()) a.includes(e) || this.deselect(e)
      for (const e of s) this.select(e)
    }
  }
  processSelect(e, t, n = !1) {
    const o = t?.shiftKey,
      i = null != t && (t.metaKey || t.ctrlKey),
      r = o || i,
      a = r || this.multi_select
    if (e)
      if (e.selected && this.selectedItems.has(e))
        if (a && !n) this.deselect(e)
        else {
          if (n) return
          this.deselectAll(e)
        }
      else a || this.deselectAll(e), this.select(e)
    else (r && !this.multi_select) || this.deselectAll()
    this.onSelectionChange?.(this.selected_nodes), this.setDirty(!0)
  }
  select(e) {
    ;(e.selected && this.selectedItems.has(e)) ||
      ((e.selected = !0),
      this.selectedItems.add(e),
      e instanceof LGraphNode &&
        (e.onSelected?.(),
        (this.selected_nodes[e.id] = e),
        this.onNodeSelected?.(e),
        e.inputs?.forEach((e) => (this.highlighted_links[e.link] = !0)),
        e.outputs
          ?.flatMap((e) => e.links)
          .forEach((e) => (this.highlighted_links[e] = !0))))
  }
  deselect(e) {
    ;(e.selected || this.selectedItems.has(e)) &&
      ((e.selected = !1),
      this.selectedItems.delete(e),
      e instanceof LGraphNode &&
        (e.onDeselected?.(),
        delete this.selected_nodes[e.id],
        this.onNodeDeselected?.(e),
        e.inputs?.forEach((e) => delete this.highlighted_links[e.link]),
        e.outputs
          ?.flatMap((e) => e.links)
          .forEach((e) => delete this.highlighted_links[e])))
  }
  processNodeSelected(e, t) {
    this.processSelect(
      e,
      t,
      t && (t.shiftKey || t.metaKey || t.ctrlKey || this.multi_select)
    )
  }
  selectNode(e, t) {
    null == e ? this.deselectAll() : this.selectNodes([e], t)
  }
  get empty() {
    return this.graph.empty
  }
  get positionableItems() {
    return this.graph.positionableItems
  }
  selectItems(e, t) {
    const n = e ?? this.positionableItems
    t || this.deselectAll()
    for (const o of n) this.select(o)
    this.onSelectionChange?.(this.selected_nodes), this.setDirty(!0)
  }
  selectNodes(e, t) {
    this.selectItems(e, t)
  }
  deselectNode(e) {
    this.deselect(e)
  }
  deselectAll(e) {
    if (!this.graph) return
    const t = this.selectedItems
    let n
    for (const i of t)
      i !== e ? (i.onDeselected?.(), (i.selected = !1)) : (n = i)
    t.clear(), n && t.add(n), this.setDirty(!0)
    const o = null == e?.id ? null : this.selected_nodes[e.id]
    ;(this.selected_nodes = {}),
      (this.current_node = null),
      (this.highlighted_links = {}),
      e instanceof LGraphNode &&
        (o && (this.selected_nodes[o.id] = o),
        e.inputs?.forEach((e) => (this.highlighted_links[e.link] = !0)),
        e.outputs
          ?.flatMap((e) => e.links)
          .forEach((e) => (this.highlighted_links[e] = !0))),
      this.onSelectionChange?.(this.selected_nodes)
  }
  deselectAllNodes() {
    this.deselectAll()
  }
  deleteSelected() {
    const { graph: e } = this
    this.emitBeforeChange(), e.beforeChange()
    for (const t of this.selectedItems)
      if (t instanceof LGraphNode) {
        const n = t
        if (n.block_delete) continue
        n.connectInputToOutput(), e.remove(n), this.onNodeDeselected?.(n)
      } else
        t instanceof LGraphGroup
          ? e.remove(t)
          : t instanceof Reroute && e.removeReroute(t.id)
    this.selectedItems.clear(),
      (this.selected_nodes = {}),
      this.selectedItems.clear(),
      (this.current_node = null),
      (this.highlighted_links = {}),
      this.setDirty(!0),
      e.afterChange(),
      this.emitAfterChange()
  }
  deleteSelectedNodes() {
    this.deleteSelected()
  }
  centerOnNode(e) {
    const t = window?.devicePixelRatio || 1
    ;(this.ds.offset[0] =
      -e.pos[0] -
      0.5 * e.size[0] +
      (0.5 * this.canvas.width) / (this.ds.scale * t)),
      (this.ds.offset[1] =
        -e.pos[1] -
        0.5 * e.size[1] +
        (0.5 * this.canvas.height) / (this.ds.scale * t)),
      this.setDirty(!0, !0)
  }
  adjustMouseEvent(e) {
    let t = e.clientX,
      n = e.clientY
    if (this.canvas) {
      const e = this.canvas.getBoundingClientRect()
      ;(t -= e.left), (n -= e.top)
    }
    void 0 === e.deltaX && (e.deltaX = t - this.last_mouse_position[0]),
      void 0 === e.deltaY && (e.deltaY = n - this.last_mouse_position[1]),
      (this.last_mouse_position[0] = t),
      (this.last_mouse_position[1] = n),
      (e.canvasX = t / this.ds.scale - this.ds.offset[0]),
      (e.canvasY = n / this.ds.scale - this.ds.offset[1])
  }
  setZoom(e, t) {
    this.ds.changeScale(e, t), this.#D()
  }
  convertOffsetToCanvas(e, t) {
    return this.ds.convertOffsetToCanvas(e, t)
  }
  convertCanvasToOffset(e, t) {
    return this.ds.convertCanvasToOffset(e, t)
  }
  convertEventToCanvasOffset(e) {
    const t = this.canvas.getBoundingClientRect()
    return this.convertCanvasToOffset([e.clientX - t.left, e.clientY - t.top])
  }
  bringToFront(e) {
    const t = this.graph._nodes.indexOf(e)
    ;-1 != t && (this.graph._nodes.splice(t, 1), this.graph._nodes.push(e))
  }
  sendToBack(e) {
    const t = this.graph._nodes.indexOf(e)
    ;-1 != t && (this.graph._nodes.splice(t, 1), this.graph._nodes.unshift(e))
  }
  computeVisibleNodes(e, t) {
    const n = t || []
    n.length = 0
    const o = e || this.graph._nodes
    for (const i of o)
      i.updateArea(),
        overlapBounding(this.visible_area, i.renderArea) && n.push(i)
    return n
  }
  draw(e, t) {
    if (!this.canvas || 0 == this.canvas.width || 0 == this.canvas.height)
      return
    const n = LiteGraph.getTime()
    ;(this.render_time = 0.001 * (n - this.last_draw_time)),
      (this.last_draw_time = n),
      this.graph && this.ds.computeVisibleArea(this.viewport),
      (this.dirty_canvas || e) &&
        this.computeVisibleNodes(null, this.visible_nodes),
      (this.dirty_bgcanvas ||
        t ||
        this.always_render_background ||
        (this.graph?._last_trigger_time &&
          n - this.graph._last_trigger_time < 1e3)) &&
        this.drawBackCanvas(),
      (this.dirty_canvas || e) && this.drawFrontCanvas(),
      (this.fps = this.render_time ? 1 / this.render_time : 0),
      this.frame++
  }
  drawFrontCanvas() {
    ;(this.dirty_canvas = !1),
      this.ctx || (this.ctx = this.bgcanvas.getContext('2d'))
    const e = this.ctx
    if (!e) return
    const t = this.canvas
    e.start2D &&
      !this.viewport &&
      (e.start2D(), e.restore(), e.setTransform(1, 0, 0, 1, 0, 0))
    const n = this.viewport || this.dirty_area
    if (
      (n && (e.save(), e.beginPath(), e.rect(n[0], n[1], n[2], n[3]), e.clip()),
      (this.#P =
        this.#V || LiteGraph.alwaysSnapToGrid
          ? this.graph.getSnapToGridSize()
          : void 0),
      this.clear_background &&
        (n
          ? e.clearRect(n[0], n[1], n[2], n[3])
          : e.clearRect(0, 0, t.width, t.height)),
      this.bgcanvas == this.canvas)
    )
      this.drawBackCanvas()
    else {
      const t = window.devicePixelRatio
      e.drawImage(
        this.bgcanvas,
        0,
        0,
        this.bgcanvas.width / t,
        this.bgcanvas.height / t
      )
    }
    if (
      (this.onRender?.(t, e),
      this.show_info && this.renderInfo(e, n ? n[0] : 0, n ? n[1] : 0),
      this.graph)
    ) {
      e.save(), this.ds.toCanvasContext(e)
      const t = this.visible_nodes,
        n = this.#P && this.isDragging
      for (let o = 0; o < t.length; ++o) {
        const i = t[o]
        e.save(),
          n && this.selectedItems.has(i) && this.drawSnapGuide(e, i),
          e.translate(i.pos[0], i.pos[1]),
          this.drawNode(i, e),
          e.restore()
      }
      if (
        (this.render_execution_order && this.drawExecutionOrder(e),
        this.graph.config.links_ontop && this.drawConnections(e),
        this.connecting_links?.length)
      )
        for (const o of this.connecting_links) {
          e.lineWidth = this.connections_width
          let t = null
          const n = o.output || o.input,
            i = n?.type
          let r = n?.dir
          null == r &&
            (r = o.output
              ? o.node.horizontal
                ? LinkDirection.DOWN
                : LinkDirection.RIGHT
              : o.node.horizontal
                ? LinkDirection.UP
                : LinkDirection.LEFT)
          const a = n?.shape
          if (i === LiteGraph.EVENT) t = LiteGraph.EVENT_LINK_COLOR
          else t = LiteGraph.CONNECTING_LINK_COLOR
          const s = this.graph.reroutes.get(o.afterRerouteId)?.pos ?? o.pos,
            l = this.#G()
          this.renderLink(
            e,
            s,
            l,
            null,
            !1,
            null,
            t,
            r,
            o.direction ?? LinkDirection.CENTER
          ),
            e.beginPath(),
            i === LiteGraph.EVENT || a === RenderShape.BOX
              ? (e.rect(s[0] - 6 + 0.5, s[1] - 5 + 0.5, 14, 10),
                e.fill(),
                e.beginPath(),
                e.rect(
                  this.graph_mouse[0] - 6 + 0.5,
                  this.graph_mouse[1] - 5 + 0.5,
                  14,
                  10
                ))
              : a === RenderShape.ARROW
                ? (e.moveTo(s[0] + 8, s[1] + 0.5),
                  e.lineTo(s[0] - 4, s[1] + 6 + 0.5),
                  e.lineTo(s[0] - 4, s[1] - 6 + 0.5),
                  e.closePath())
                : (e.arc(s[0], s[1], 4, 0, 2 * Math.PI),
                  e.fill(),
                  e.beginPath(),
                  e.arc(
                    this.graph_mouse[0],
                    this.graph_mouse[1],
                    4,
                    0,
                    2 * Math.PI
                  )),
            e.fill(),
            this.#W(e, l)
        }
      if (this.dragging_rectangle) {
        const { eDown: t, eMove: n } = this.pointer
        if (((e.strokeStyle = '#FFF'), t && n)) {
          const o = e.getTransform(),
            i = window.devicePixelRatio
          e.setTransform(i, 0, 0, i, 0, 0)
          const r = t.offsetX,
            a = t.offsetY
          e.strokeRect(r, a, n.offsetX - r, n.offsetY - a), e.setTransform(o)
        } else {
          const [t, n, o, i] = this.dragging_rectangle
          e.strokeRect(t, n, o, i)
        }
      }
      this.over_link_center && this.render_link_tooltip
        ? this.drawLinkTooltip(e, this.over_link_center)
        : this.onDrawLinkTooltip?.(e, null),
        this.onDrawForeground?.(e, this.visible_area),
        e.restore()
    }
    this.onDrawOverlay?.(e), n && e.restore(), e.finish2D && e.finish2D()
  }
  #U(e) {
    for (const t of this.renderedPaths) {
      const n = t._pos
      if (n && isInRectangle(e.canvasX, e.canvasY, n[0] - 4, n[1] - 4, 8, 8))
        return t
    }
  }
  #G() {
    return LiteGraph.snaps_for_comfy
      ? (this._highlight_pos ?? this.graph_mouse)
      : this.graph_mouse
  }
  #W(e, t) {
    if (!this._highlight_pos) return
    ;(e.fillStyle = '#ffcc00'), e.beginPath()
    const n = this._highlight_input?.shape
    if (
      (n === RenderShape.ARROW
        ? (e.moveTo(t[0] + 8, t[1] + 0.5),
          e.lineTo(t[0] - 4, t[1] + 6 + 0.5),
          e.lineTo(t[0] - 4, t[1] - 6 + 0.5),
          e.closePath())
        : e.arc(t[0], t[1], 6, 0, 2 * Math.PI),
      e.fill(),
      !LiteGraph.snap_highlights_node)
    )
      return
    const o = this.node_over
    if (!o || !this.connecting_links?.[0]) return
    const { strokeStyle: i, lineWidth: r } = e,
      a = o.boundingRect,
      s = this.round_radius + 3,
      l = a[0] - 3,
      c = a[1] - 3,
      d = a[2] + 6,
      u = a[3] + 6
    e.beginPath(), e.roundRect(l, c, d, u, s)
    const p = null === this.connecting_links[0].output ? 0 : 1,
      h = p ? -1 : 1,
      m = t[0],
      f = t[1],
      _ = d < u ? d : d * Math.max(u / d, 0.5),
      g = e.createRadialGradient(m, f, 0, m, f, _)
    g.addColorStop(1, '#00000000'), g.addColorStop(0, '#ffcc00aa')
    const v = e.createLinearGradient(l, c, l + d, c)
    v.addColorStop(0.5, '#00000000'),
      v.addColorStop(p + 0.67 * h, '#ddeeff33'),
      v.addColorStop(p + h, '#ffcc0055'),
      e.setLineDash([s, 0.001 * s]),
      (e.lineWidth = 1),
      (e.strokeStyle = v),
      e.stroke(),
      (e.strokeStyle = g),
      e.stroke(),
      e.setLineDash([]),
      (e.lineWidth = r),
      (e.strokeStyle = i)
  }
  renderInfo(e, t, n) {
    ;(t = t || 10),
      (n = n || this.canvas.offsetHeight - 80),
      e.save(),
      e.translate(t, n),
      (e.font = '10px Arial'),
      (e.fillStyle = '#888'),
      (e.textAlign = 'left'),
      this.graph
        ? (e.fillText('T: ' + this.graph.globaltime.toFixed(2) + 's', 5, 13),
          e.fillText('I: ' + this.graph.iteration, 5, 26),
          e.fillText(
            'N: ' +
              this.graph._nodes.length +
              ' [' +
              this.visible_nodes.length +
              ']',
            5,
            39
          ),
          e.fillText('V: ' + this.graph._version, 5, 52),
          e.fillText('FPS:' + this.fps.toFixed(2), 5, 65))
        : e.fillText('No graph selected', 5, 13),
      e.restore()
  }
  drawBackCanvas() {
    const e = this.bgcanvas
    ;(e.width == this.canvas.width && e.height == this.canvas.height) ||
      ((e.width = this.canvas.width), (e.height = this.canvas.height)),
      this.bgctx || (this.bgctx = this.bgcanvas.getContext('2d'))
    const t = this.bgctx
    t.start && t.start()
    const n = this.viewport || [0, 0, t.canvas.width, t.canvas.height]
    if (
      (this.clear_background && t.clearRect(n[0], n[1], n[2], n[3]),
      this._graph_stack?.length)
    ) {
      t.save()
      const n = this.graph._subgraph_node
      ;(t.strokeStyle = n.bgcolor),
        (t.lineWidth = 10),
        t.strokeRect(1, 1, e.width - 2, e.height - 2),
        (t.lineWidth = 1),
        (t.font = '40px Arial'),
        (t.textAlign = 'center'),
        (t.fillStyle = n.bgcolor || '#AAA')
      let o = ''
      for (let e = 1; e < this._graph_stack.length; ++e)
        o += this._graph_stack[e]._subgraph_node.getTitle() + ' >> '
      t.fillText(o + n.getTitle(), 0.5 * e.width, 40), t.restore()
    }
    const o = !!this.onRenderBackground && this.onRenderBackground(e, t)
    if (!this.viewport) {
      const e = window.devicePixelRatio
      t.restore(), t.setTransform(e, 0, 0, e, 0, 0)
    }
    if (((this.visible_links.length = 0), this.graph)) {
      if (
        (t.save(),
        this.ds.toCanvasContext(t),
        this.ds.scale < 1.5 &&
          !o &&
          this.clear_background_color &&
          ((t.fillStyle = this.clear_background_color),
          t.fillRect(
            this.visible_area[0],
            this.visible_area[1],
            this.visible_area[2],
            this.visible_area[3]
          )),
        this.background_image && this.ds.scale > 0.5 && !o)
      ) {
        if (
          (this.zoom_modify_alpha
            ? (t.globalAlpha = (1 - 0.5 / this.ds.scale) * this.editor_alpha)
            : (t.globalAlpha = this.editor_alpha),
          (t.imageSmoothingEnabled = !1),
          !this._bg_img || this._bg_img.name != this.background_image)
        ) {
          ;(this._bg_img = new Image()),
            (this._bg_img.name = this.background_image),
            (this._bg_img.src = this.background_image)
          const e = this
          this._bg_img.onload = function () {
            e.draw(!0, !0)
          }
        }
        let e = this._pattern
        null == e &&
          this._bg_img.width > 0 &&
          ((e = t.createPattern(this._bg_img, 'repeat')),
          (this._pattern_img = this._bg_img),
          (this._pattern = e)),
          e &&
            ((t.fillStyle = e),
            t.fillRect(
              this.visible_area[0],
              this.visible_area[1],
              this.visible_area[2],
              this.visible_area[3]
            ),
            (t.fillStyle = 'transparent')),
          (t.globalAlpha = 1),
          (t.imageSmoothingEnabled = !0)
      }
      this.graph._groups.length && this.drawGroups(e, t),
        this.onDrawBackground?.(t, this.visible_area),
        this.render_canvas_border &&
          ((t.strokeStyle = '#235'), t.strokeRect(0, 0, e.width, e.height)),
        this.render_connections_shadows
          ? ((t.shadowColor = '#000'),
            (t.shadowOffsetX = 0),
            (t.shadowOffsetY = 0),
            (t.shadowBlur = 6))
          : (t.shadowColor = 'rgba(0,0,0,0)'),
        this.drawConnections(t),
        (t.shadowColor = 'rgba(0,0,0,0)'),
        t.restore()
    }
    t.finish?.(), (this.dirty_bgcanvas = !1), (this.dirty_canvas = !0)
  }
  drawNode(e, t) {
    this.current_node = e
    const n = e.color || e.constructor.color || LiteGraph.NODE_DEFAULT_COLOR,
      o = e.bgcolor || e.constructor.bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR,
      i = this.ds.scale < 0.6,
      r = this.editor_alpha
    if (
      ((t.globalAlpha = r),
      this.render_shadows && !i
        ? ((t.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR),
          (t.shadowOffsetX = 2 * this.ds.scale),
          (t.shadowOffsetY = 2 * this.ds.scale),
          (t.shadowBlur = 3 * this.ds.scale))
        : (t.shadowColor = 'transparent'),
      e.flags.collapsed && 1 == e.onDrawCollapsed?.(t, this))
    )
      return
    const a = e._shape || RenderShape.BOX,
      s = LGraphCanvas.#w
    LGraphCanvas.#w.set(e.size)
    const l = e.horizontal
    if (e.flags.collapsed) {
      t.font = this.inner_text_font
      const n = e.getTitle ? e.getTitle() : e.title
      null != n &&
        ((e._collapsed_width = Math.min(
          e.size[0],
          t.measureText(n).width + 2 * LiteGraph.NODE_TITLE_HEIGHT
        )),
        (s[0] = e._collapsed_width),
        (s[1] = 0))
    }
    e.clip_area &&
      (t.save(),
      t.beginPath(),
      a == RenderShape.BOX
        ? t.rect(0, 0, s[0], s[1])
        : a == RenderShape.ROUND
          ? t.roundRect(0, 0, s[0], s[1], [10])
          : a == RenderShape.CIRCLE &&
            t.arc(0.5 * s[0], 0.5 * s[1], 0.5 * s[0], 0, 2 * Math.PI),
      t.clip()),
      this.drawNodeShape(e, t, s, n, o, e.selected),
      i || e.drawBadges(t),
      (t.shadowColor = 'transparent'),
      (t.strokeStyle = LiteGraph.NODE_BOX_OUTLINE_COLOR),
      e.onDrawForeground?.(t, this, this.canvas),
      (t.textAlign = l ? 'center' : 'left'),
      (t.font = this.inner_text_font)
    const c = !i,
      d =
        LiteGraph.NODE_TEXT_HIGHLIGHT_COLOR ??
        LiteGraph.NODE_SELECTED_TITLE_COLOR ??
        LiteGraph.NODE_TEXT_COLOR,
      u = this.connecting_links?.[0]?.output,
      p = this.connecting_links?.[0]?.input
    t.lineWidth = 1
    let h = 0
    const m = new Float32Array(2)
    if (e.flags.collapsed) {
      if (this.render_collapsed_slots) {
        let n,
          o = null,
          i = null
        if (e.inputs)
          for (let t = 0; t < e.inputs.length; t++)
            if (((n = e.inputs[t]), null != n.link)) {
              o = n
              break
            }
        if (e.outputs)
          for (let t = 0; t < e.outputs.length; t++)
            (n = e.outputs[t]), n.links && n.links.length && (i = n)
        if (o) {
          let o = 0,
            i = -0.5 * LiteGraph.NODE_TITLE_HEIGHT
          l &&
            ((o = 0.5 * e._collapsed_width),
            (i = -LiteGraph.NODE_TITLE_HEIGHT)),
            (t.fillStyle = '#686'),
            t.beginPath(),
            n.type === LiteGraph.EVENT || n.shape === RenderShape.BOX
              ? t.rect(o - 7 + 0.5, i - 4, 14, 8)
              : n.shape === RenderShape.ARROW
                ? (t.moveTo(o + 8, i),
                  t.lineTo(o + -4, i - 4),
                  t.lineTo(o + -4, i + 4),
                  t.closePath())
                : t.arc(o, i, 4, 0, 2 * Math.PI),
            t.fill()
        }
        if (i) {
          let o = e._collapsed_width,
            i = -0.5 * LiteGraph.NODE_TITLE_HEIGHT
          l && ((o = 0.5 * e._collapsed_width), (i = 0)),
            (t.fillStyle = '#686'),
            (t.strokeStyle = 'black'),
            t.beginPath(),
            n.type === LiteGraph.EVENT || n.shape === RenderShape.BOX
              ? t.rect(o - 7 + 0.5, i - 4, 14, 8)
              : n.shape === RenderShape.ARROW
                ? (t.moveTo(o + 6, i),
                  t.lineTo(o - 6, i - 4),
                  t.lineTo(o - 6, i + 4),
                  t.closePath())
                : t.arc(o, i, 4, 0, 2 * Math.PI),
            t.fill()
        }
      }
    } else {
      if (e.inputs)
        for (let n = 0; n < e.inputs.length; n++) {
          const o = e.inputs[n],
            a = o.type,
            s =
              !this.connecting_links ||
              (u && LiteGraph.isValidConnection(o.type, u.type)),
            p = s && e.mouseOver?.inputId === n,
            f = p ? d : LiteGraph.NODE_TEXT_COLOR
          ;(t.globalAlpha = s ? r : 0.4 * r),
            (t.fillStyle =
              null != o.link
                ? o.color_on ||
                  this.default_connection_color_byType[a] ||
                  this.default_connection_color.input_on
                : o.color_off ||
                  this.default_connection_color_byTypeOff[a] ||
                  this.default_connection_color_byType[a] ||
                  this.default_connection_color.input_off)
          const _ = e.getConnectionPos(!0, n, m)
          ;(_[0] -= e.pos[0]),
            (_[1] -= e.pos[1]),
            h < _[1] + 0.5 * LiteGraph.NODE_SLOT_HEIGHT &&
              (h = _[1] + 0.5 * LiteGraph.NODE_SLOT_HEIGHT),
            drawSlot(t, o, _, {
              horizontal: l,
              low_quality: i,
              render_text: c,
              label_color: f,
              label_position: LabelPosition.Right,
              do_stroke: !1,
              highlight: p
            })
        }
      if (
        ((t.textAlign = l ? 'center' : 'right'),
        (t.strokeStyle = 'black'),
        e.outputs)
      )
        for (let n = 0; n < e.outputs.length; n++) {
          const o = e.outputs[n],
            a = o.type,
            s =
              !this.connecting_links ||
              (p && LiteGraph.isValidConnection(a, p.type)),
            u = s && e.mouseOver?.outputId === n,
            f = u ? d : LiteGraph.NODE_TEXT_COLOR
          t.globalAlpha = s ? r : 0.4 * r
          const _ = e.getConnectionPos(!1, n, m)
          ;(_[0] -= e.pos[0]),
            (_[1] -= e.pos[1]),
            h < _[1] + 0.5 * LiteGraph.NODE_SLOT_HEIGHT &&
              (h = _[1] + 0.5 * LiteGraph.NODE_SLOT_HEIGHT),
            (t.fillStyle =
              o.links && o.links.length
                ? o.color_on ||
                  this.default_connection_color_byType[a] ||
                  this.default_connection_color.output_on
                : o.color_off ||
                  this.default_connection_color_byTypeOff[a] ||
                  this.default_connection_color_byType[a] ||
                  this.default_connection_color.output_off),
            drawSlot(t, o, _, {
              horizontal: l,
              low_quality: i,
              render_text: c,
              label_color: f,
              label_position: LabelPosition.Left,
              do_stroke: !0,
              highlight: u
            })
        }
      if (((t.textAlign = 'left'), (t.globalAlpha = 1), e.widgets)) {
        let n = h
        ;(l || e.widgets_up) && (n = 2),
          null != e.widgets_start_y && (n = e.widgets_start_y),
          this.drawNodeWidgets(
            e,
            n,
            t,
            this.node_widget && this.node_widget[0] == e
              ? this.node_widget[1]
              : null
          )
      }
    }
    e.clip_area && t.restore(), (t.globalAlpha = 1)
  }
  drawLinkTooltip(e, t) {
    const n = t._pos
    if (
      ((e.fillStyle = 'black'),
      e.beginPath(),
      this.linkMarkerShape === LinkMarkerShape.Arrow)
    ) {
      const o = e.getTransform()
      e.translate(n[0], n[1]),
        Number.isFinite(t._centreAngle) && e.rotate(t._centreAngle),
        e.moveTo(-2, -3),
        e.lineTo(4, 0),
        e.lineTo(-2, 3),
        e.setTransform(o)
    } else
      (null != this.linkMarkerShape &&
        this.linkMarkerShape !== LinkMarkerShape.Circle) ||
        e.arc(n[0], n[1], 3, 0, 2 * Math.PI)
    e.fill()
    const o = t.data
    if (null == o) return
    if (1 == this.onDrawLinkTooltip?.(e, t, this)) return
    let i = null
    if (
      ((i =
        'number' == typeof o
          ? o.toFixed(2)
          : 'string' == typeof o
            ? '"' + o + '"'
            : 'boolean' == typeof o
              ? String(o)
              : o.toToolTip
                ? o.toToolTip()
                : '[' + o.constructor.name + ']'),
      null == i)
    )
      return
    ;(i = i.substring(0, 30)), (e.font = '14px Courier New')
    const r = e.measureText(i).width + 20
    ;(e.shadowColor = 'black'),
      (e.shadowOffsetX = 2),
      (e.shadowOffsetY = 2),
      (e.shadowBlur = 3),
      (e.fillStyle = '#454'),
      e.beginPath(),
      e.roundRect(n[0] - 0.5 * r, n[1] - 15 - 24, r, 24, [3]),
      e.moveTo(n[0] - 10, n[1] - 15),
      e.lineTo(n[0] + 10, n[1] - 15),
      e.lineTo(n[0], n[1] - 5),
      e.fill(),
      (e.shadowColor = 'transparent'),
      (e.textAlign = 'center'),
      (e.fillStyle = '#CEC'),
      e.fillText(i, n[0], n[1] - 15 - 24 * 0.3)
  }
  drawNodeShape(e, t, n, o, i, r) {
    ;(t.strokeStyle = o),
      (t.fillStyle = LiteGraph.use_legacy_node_error_indicator ? '#F00' : i)
    const a = LiteGraph.NODE_TITLE_HEIGHT,
      s = this.ds.scale < 0.5,
      { collapsed: l } = e.flags,
      c = e._shape || e.constructor.shape || RenderShape.ROUND,
      { title_mode: d } = e.constructor,
      u = d != TitleMode.TRANSPARENT_TITLE && d != TitleMode.NO_TITLE,
      p = LGraphCanvas.#k
    e.measure(p), (p[0] -= e.pos[0]), (p[1] -= e.pos[1])
    const h = t.globalAlpha
    if (
      (t.beginPath(),
      c == RenderShape.BOX || s
        ? t.fillRect(p[0], p[1], p[2], p[3])
        : c == RenderShape.ROUND || c == RenderShape.CARD
          ? t.roundRect(
              p[0],
              p[1],
              p[2],
              p[3],
              c == RenderShape.CARD
                ? [this.round_radius, this.round_radius, 0, 0]
                : [this.round_radius]
            )
          : c == RenderShape.CIRCLE &&
            t.arc(0.5 * n[0], 0.5 * n[1], 0.5 * n[0], 0, 2 * Math.PI),
      t.fill(),
      e.has_errors &&
        !LiteGraph.use_legacy_node_error_indicator &&
        this.strokeShape(t, p, {
          shape: c,
          title_mode: d,
          title_height: a,
          padding: 12,
          colour: LiteGraph.NODE_ERROR_COLOUR,
          collapsed: l,
          thickness: 10
        }),
      !l &&
        u &&
        ((t.shadowColor = 'transparent'),
        (t.fillStyle = 'rgba(0,0,0,0.2)'),
        t.fillRect(0, -1, p[2], 2)),
      (t.shadowColor = 'transparent'),
      e.onDrawBackground?.(t, this, this.canvas, this.graph_mouse),
      u || d == TitleMode.TRANSPARENT_TITLE)
    ) {
      if (e.onDrawTitleBar) e.onDrawTitleBar(t, a, n, this.ds.scale, o)
      else if (
        d != TitleMode.TRANSPARENT_TITLE &&
        (e.constructor.title_color || this.render_title_colored)
      ) {
        const i = e.constructor.title_color || o
        l && (t.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR),
          (t.fillStyle = i),
          t.beginPath(),
          c == RenderShape.BOX || s
            ? t.rect(0, -a, n[0], a)
            : (c != RenderShape.ROUND && c != RenderShape.CARD) ||
              t.roundRect(
                0,
                -a,
                n[0],
                a,
                l
                  ? [this.round_radius]
                  : [this.round_radius, this.round_radius, 0, 0]
              ),
          t.fill(),
          (t.shadowColor = 'transparent')
      }
      let i =
        !(
          !LiteGraph.node_box_coloured_by_mode ||
          !LiteGraph.NODE_MODES_COLORS[e.mode]
        ) && LiteGraph.NODE_MODES_COLORS[e.mode]
      LiteGraph.node_box_coloured_when_on &&
        (i = e.action_triggered ? '#FFF' : e.execute_triggered ? '#AAA' : i)
      const u = 10
      if (
        (e.onDrawTitleBox
          ? e.onDrawTitleBox(t, a, n, this.ds.scale)
          : c == RenderShape.ROUND ||
              c == RenderShape.CIRCLE ||
              c == RenderShape.CARD
            ? (s &&
                ((t.fillStyle = 'black'),
                t.beginPath(),
                t.arc(0.5 * a, -0.5 * a, 0.5 * u + 1, 0, 2 * Math.PI),
                t.fill()),
              (t.fillStyle =
                e.boxcolor || i || LiteGraph.NODE_DEFAULT_BOXCOLOR),
              s
                ? t.fillRect(0.5 * a - 0.5 * u, -0.5 * a - 0.5 * u, u, u)
                : (t.beginPath(),
                  t.arc(0.5 * a, -0.5 * a, 0.5 * u, 0, 2 * Math.PI),
                  t.fill()))
            : (s &&
                ((t.fillStyle = 'black'),
                t.fillRect(
                  0.5 * (a - u) - 1,
                  -0.5 * (a + u) - 1,
                  u + 2,
                  u + 2
                )),
              (t.fillStyle =
                e.boxcolor || i || LiteGraph.NODE_DEFAULT_BOXCOLOR),
              t.fillRect(0.5 * (a - u), -0.5 * (a + u), u, u)),
        (t.globalAlpha = h),
        e.onDrawTitleText &&
          e.onDrawTitleText(t, a, n, this.ds.scale, this.title_text_font, r),
        !s)
      ) {
        t.font = this.title_text_font
        const n = e.getTitle() ?? `❌ ${e.type}`,
          o = String(n) + (e.pinned ? '📌' : '')
        o &&
          ((t.fillStyle = r
            ? LiteGraph.NODE_SELECTED_TITLE_COLOR
            : e.constructor.title_text_color || this.node_title_color),
          l
            ? ((t.textAlign = 'left'),
              t.fillText(o.substr(0, 20), a, LiteGraph.NODE_TITLE_TEXT_Y - a),
              (t.textAlign = 'left'))
            : ((t.textAlign = 'left'),
              t.fillText(o, a, LiteGraph.NODE_TITLE_TEXT_Y - a)))
      }
      if (!l && e.subgraph && !e.skip_subgraph_button) {
        const n = LiteGraph.NODE_TITLE_HEIGHT,
          o = e.size[0] - n,
          i = LiteGraph.isInsideRectangle(
            this.graph_mouse[0] - e.pos[0],
            this.graph_mouse[1] - e.pos[1],
            o + 2,
            2 - n,
            n - 4,
            n - 4
          )
        ;(t.fillStyle = i ? '#888' : '#555'),
          c == RenderShape.BOX || s
            ? t.fillRect(o + 2, 2 - n, n - 4, n - 4)
            : (t.beginPath(),
              t.roundRect(o + 2, 2 - n, n - 4, n - 4, [4]),
              t.fill()),
          (t.fillStyle = '#333'),
          t.beginPath(),
          t.moveTo(o + 0.2 * n, 0.6 * -n),
          t.lineTo(o + 0.8 * n, 0.6 * -n),
          t.lineTo(o + 0.5 * n, 0.3 * -n),
          t.fill()
      }
      e.onDrawTitle?.(t)
    }
    if (r) {
      e.onBounding?.(p)
      const n =
        e.has_errors && !LiteGraph.use_legacy_node_error_indicator ? 20 : void 0
      this.strokeShape(t, p, {
        shape: c,
        title_height: a,
        title_mode: d,
        padding: n,
        collapsed: e.flags?.collapsed
      })
    }
    e.execute_triggered > 0 && e.execute_triggered--,
      e.action_triggered > 0 && e.action_triggered--
  }
  strokeShape(
    e,
    t,
    {
      shape: n = RenderShape.BOX,
      title_height: o = LiteGraph.NODE_TITLE_HEIGHT,
      title_mode: i = TitleMode.NORMAL_TITLE,
      colour: r = LiteGraph.NODE_BOX_OUTLINE_COLOR,
      padding: a = 6,
      collapsed: s = !1,
      thickness: l = 1
    } = {}
  ) {
    i === TitleMode.TRANSPARENT_TITLE && ((t[1] -= o), (t[3] += o))
    const { lineWidth: c, strokeStyle: d } = e
    ;(e.lineWidth = l),
      (e.globalAlpha = 0.8),
      (e.strokeStyle = r),
      e.beginPath()
    const [u, p, h, m] = t
    switch (n) {
      case RenderShape.BOX:
        e.rect(u - a, p - a, h + 2 * a, m + 2 * a)
        break
      case RenderShape.ROUND:
      case RenderShape.CARD: {
        const t = this.round_radius + a,
          o =
            (n === RenderShape.CARD && s) || n === RenderShape.ROUND
              ? [t]
              : [t, 2, t, 2]
        e.roundRect(u - a, p - a, h + 2 * a, m + 2 * a, o)
        break
      }
      case RenderShape.CIRCLE: {
        const t = u + h / 2,
          n = p + m / 2,
          o = Math.max(h, m) / 2 + a
        e.arc(t, n, o, 0, 2 * Math.PI)
        break
      }
    }
    e.stroke(), (e.lineWidth = c), (e.strokeStyle = d), (e.globalAlpha = 1)
  }
  drawSnapGuide(e, t, n = RenderShape.ROUND) {
    const o = LGraphCanvas.#C
    o.set(t.boundingRect)
    const { pos: i } = t,
      r = i[0] - o[0],
      a = i[1] - o[1]
    ;(o[0] += r), (o[1] += a), snapPoint(o, this.#P), (o[0] -= r), (o[1] -= a)
    const { globalAlpha: s } = e
    ;(e.globalAlpha = 1), e.beginPath()
    const [l, c, d, u] = o
    if (n === RenderShape.CIRCLE) {
      const t = l + 0.5 * d,
        n = c + 0.5 * u,
        o = Math.min(0.5 * d, 0.5 * u)
      e.arc(t, n, o, 0, 2 * Math.PI)
    } else e.rect(l, c, d, u)
    ;(e.lineWidth = 0.5),
      (e.strokeStyle = '#FFFFFF66'),
      (e.fillStyle = '#FFFFFF22'),
      e.fill(),
      e.stroke(),
      (e.globalAlpha = s)
  }
  drawConnections(e) {
    const t = this.renderedPaths
    t.clear()
    const n = [],
      o = LiteGraph.getTime(),
      i = this.visible_area
    ;(LGraphCanvas.#x[0] = i[0] - 20),
      (LGraphCanvas.#x[1] = i[1] - 20),
      (LGraphCanvas.#x[2] = i[2] + 40),
      (LGraphCanvas.#x[3] = i[3] + 40),
      (e.lineWidth = this.connections_width),
      (e.fillStyle = '#AAA'),
      (e.strokeStyle = '#AAA'),
      (e.globalAlpha = this.editor_alpha)
    const r = this.graph._nodes
    for (let a = 0, s = r.length; a < s; ++a) {
      const i = r[a]
      if (i.inputs && i.inputs.length)
        for (let r = 0; r < i.inputs.length; ++r) {
          const a = i.inputs[r]
          if (!a || null == a.link) continue
          const s = a.link,
            l = this.graph._links.get(s)
          if (!l) continue
          const c = this.graph.getNodeById(l.origin_id)
          if (null == c) continue
          const d = l.origin_slot,
            u =
              -1 == d
                ? [c.pos[0] + 10, c.pos[1] + 10]
                : c.getConnectionPos(!1, d, LGraphCanvas.#I),
            p = i.getConnectionPos(!0, r, LGraphCanvas.#T),
            h = this.reroutesEnabled ? LLink.getReroutes(this.graph, l) : [],
            m = [u, ...h.map((e) => e.pos), p],
            f = m.map((e) => e[0]),
            _ = m.map((e) => e[1])
          if (
            ((LGraphCanvas.#E[0] = Math.min(...f)),
            (LGraphCanvas.#E[1] = Math.min(..._)),
            (LGraphCanvas.#E[2] = Math.max(...f) - LGraphCanvas.#E[0]),
            (LGraphCanvas.#E[3] = Math.max(..._) - LGraphCanvas.#E[1]),
            !overlapBounding(LGraphCanvas.#E, LGraphCanvas.#x))
          )
            continue
          const g = c.outputs[d],
            v = i.inputs[r]
          if (!g || !v) continue
          const y =
              g.dir ||
              (c.horizontal ? LinkDirection.DOWN : LinkDirection.RIGHT),
            b = v.dir || (i.horizontal ? LinkDirection.UP : LinkDirection.LEFT)
          if (h.length) {
            let o
            const i = h.length
            for (let r = 0; r < i; r++) {
              const i = h[r]
              if (!t.has(i)) {
                t.add(i),
                  n.push(i),
                  (i._colour =
                    l.color ||
                    LGraphCanvas.link_type_colors[l.type] ||
                    this.default_link_color)
                const r = this.graph.reroutes.get(i.parentId),
                  a = r?.pos ?? u
                i.calculateAngle(this.last_draw_time, this.graph, a),
                  this.renderLink(e, a, i.pos, l, !1, 0, null, y, b, {
                    startControl: o,
                    endControl: i.controlPoint,
                    reroute: i
                  })
              }
              const a = h[r + 1]?.pos ?? p,
                s = Math.min(80, 0.25 * distance(i.pos, a))
              o = [s * i.cos, s * i.sin]
            }
            this.renderLink(e, m.at(-2), m.at(-1), l, !1, 0, null, y, b, {
              startControl: o
            })
          } else this.renderLink(e, u, p, l, !1, 0, null, y, b)
          if ((t.add(l), l && l._last_time && o - l._last_time < 1e3)) {
            const t = 2 - 0.002 * (o - l._last_time),
              n = e.globalAlpha
            ;(e.globalAlpha = n * t),
              this.renderLink(e, u, p, l, !0, t, 'white', y, b),
              (e.globalAlpha = n)
          }
        }
    }
    for (const a of n)
      this.#P &&
        this.isDragging &&
        this.selectedItems.has(a) &&
        this.drawSnapGuide(e, a, RenderShape.CIRCLE),
        a.draw(e)
    e.globalAlpha = 1
  }
  renderLink(
    e,
    t,
    n,
    o,
    i,
    r,
    a,
    s,
    l,
    { startControl: c, endControl: d, reroute: u, num_sublines: p = 1 } = {}
  ) {
    o && this.visible_links.push(o)
    const h =
        null != o && this.highlighted_links[o.id]
          ? '#FFF'
          : a ||
            o?.color ||
            LGraphCanvas.link_type_colors[o.type] ||
            this.default_link_color,
      m = s || LinkDirection.RIGHT,
      f = l || LinkDirection.LEFT,
      _ =
        this.links_render_mode != LinkRenderType.SPLINE_LINK || (d && c)
          ? null
          : distance(t, n)
    this.render_connections_border &&
      this.ds.scale > 0.6 &&
      (e.lineWidth = this.connections_width + 4),
      (e.lineJoin = 'round'),
      (p ||= 1),
      p > 1 && (e.lineWidth = 0.5)
    const g = new Path2D(),
      v = u ?? o
    v && (v.path = g)
    const y = LGraphCanvas.#$,
      b = LGraphCanvas.#L,
      S = v?._pos ?? [0, 0]
    for (let C = 0; C < p; C += 1) {
      const e = 5 * (C - 0.5 * (p - 1))
      if (
        ((y[0] = t[0]),
        (y[1] = t[1]),
        (b[0] = n[0]),
        (b[1] = n[1]),
        this.links_render_mode == LinkRenderType.SPLINE_LINK)
      ) {
        if (
          (d ? ((b[0] = n[0] + d[0]), (b[1] = n[1] + d[1])) : this.#K(b, f, _),
          c ? ((y[0] = t[0] + c[0]), (y[1] = t[1] + c[1])) : this.#K(y, m, _),
          g.moveTo(t[0], t[1] + e),
          g.bezierCurveTo(y[0], y[1] + e, b[0], b[1] + e, n[0], n[1] + e),
          findPointOnCurve(S, t, n, y, b, 0.5),
          v && this.linkMarkerShape === LinkMarkerShape.Arrow)
        ) {
          const e = LGraphCanvas.#A
          findPointOnCurve(e, t, n, y, b, 0.51),
            (v._centreAngle = Math.atan2(e[1] - S[1], e[0] - S[0]))
        }
      } else if (this.links_render_mode == LinkRenderType.LINEAR_LINK) {
        const o = 15
        switch (m) {
          case LinkDirection.LEFT:
            y[0] += -o
            break
          case LinkDirection.RIGHT:
            y[0] += o
            break
          case LinkDirection.UP:
            y[1] += -o
            break
          case LinkDirection.DOWN:
            y[1] += o
        }
        switch (f) {
          case LinkDirection.LEFT:
            b[0] += -o
            break
          case LinkDirection.RIGHT:
            b[0] += o
            break
          case LinkDirection.UP:
            b[1] += -o
            break
          case LinkDirection.DOWN:
            b[1] += o
        }
        g.moveTo(t[0], t[1] + e),
          g.lineTo(y[0], y[1] + e),
          g.lineTo(b[0], b[1] + e),
          g.lineTo(n[0], n[1] + e),
          (S[0] = 0.5 * (y[0] + b[0])),
          (S[1] = 0.5 * (y[1] + b[1])),
          v &&
            this.linkMarkerShape === LinkMarkerShape.Arrow &&
            (v._centreAngle = Math.atan2(b[1] - y[1], b[0] - y[0]))
      } else {
        if (this.links_render_mode != LinkRenderType.STRAIGHT_LINK) return
        {
          m == LinkDirection.RIGHT ? (y[0] += 10) : (y[1] += 10),
            f == LinkDirection.LEFT ? (b[0] -= 10) : (b[1] -= 10)
          const e = 0.5 * (y[0] + b[0])
          if (
            (g.moveTo(t[0], t[1]),
            g.lineTo(y[0], y[1]),
            g.lineTo(e, y[1]),
            g.lineTo(e, b[1]),
            g.lineTo(b[0], b[1]),
            g.lineTo(n[0], n[1]),
            (S[0] = e),
            (S[1] = 0.5 * (y[1] + b[1])),
            v && this.linkMarkerShape === LinkMarkerShape.Arrow)
          ) {
            const e = b[1] - y[1]
            Math.abs(e) < 4
              ? (v._centreAngle = 0)
              : (v._centreAngle = e > 0 ? 0.5 * Math.PI : -0.5 * Math.PI)
          }
        }
      }
    }
    if (
      (this.render_connections_border &&
        this.ds.scale > 0.6 &&
        !i &&
        ((e.strokeStyle = 'rgba(0,0,0,0.5)'), e.stroke(g)),
      (e.lineWidth = this.connections_width),
      (e.fillStyle = e.strokeStyle = h),
      e.stroke(g),
      this.ds.scale >= 0.6 &&
        this.highquality_render &&
        v &&
        f != LinkDirection.CENTER)
    ) {
      if (this.render_connection_arrows) {
        const o = this.computeConnectionPoint(t, n, 0.25, m, f),
          i = this.computeConnectionPoint(t, n, 0.26, m, f),
          r = this.computeConnectionPoint(t, n, 0.75, m, f),
          a = this.computeConnectionPoint(t, n, 0.76, m, f)
        let s = 0,
          l = 0
        this.render_curved_connections
          ? ((s = -Math.atan2(i[0] - o[0], i[1] - o[1])),
            (l = -Math.atan2(a[0] - r[0], a[1] - r[1])))
          : (l = s = n[1] > t[1] ? 0 : Math.PI)
        const c = e.getTransform()
        e.translate(o[0], o[1]),
          e.rotate(s),
          e.beginPath(),
          e.moveTo(-5, -3),
          e.lineTo(0, 7),
          e.lineTo(5, -3),
          e.fill(),
          e.setTransform(c),
          e.translate(r[0], r[1]),
          e.rotate(l),
          e.beginPath(),
          e.moveTo(-5, -3),
          e.lineTo(0, 7),
          e.lineTo(5, -3),
          e.fill(),
          e.setTransform(c)
      }
      if ((e.beginPath(), this.linkMarkerShape === LinkMarkerShape.Arrow)) {
        const t = e.getTransform()
        e.translate(S[0], S[1]),
          e.rotate(v._centreAngle),
          e.moveTo(-3.2, -5),
          e.lineTo(7, 0),
          e.lineTo(-3.2, 5),
          e.fill(),
          e.setTransform(t)
      } else
        (null != this.linkMarkerShape &&
          this.linkMarkerShape !== LinkMarkerShape.Circle) ||
          e.arc(S[0], S[1], 5, 0, 2 * Math.PI)
      e.fill()
    }
    if (r) {
      e.fillStyle = h
      for (let o = 0; o < 5; ++o) {
        const i = (0.001 * LiteGraph.getTime() + 0.2 * o) % 1,
          r = this.computeConnectionPoint(t, n, i, m, f)
        e.beginPath(), e.arc(r[0], r[1], 5, 0, 2 * Math.PI), e.fill()
      }
    }
  }
  computeConnectionPoint(e, t, n, o, i) {
    ;(o ||= LinkDirection.RIGHT), (i ||= LinkDirection.LEFT)
    const r = distance(e, t),
      a = [e[0], e[1]],
      s = [t[0], t[1]]
    this.#K(a, o, r), this.#K(s, i, r)
    const l = (1 - n) * (1 - n) * (1 - n),
      c = (1 - n) * (1 - n) * 3 * n,
      d = 3 * (1 - n) * (n * n),
      u = n * n * n
    return [
      l * e[0] + c * a[0] + d * s[0] + u * t[0],
      l * e[1] + c * a[1] + d * s[1] + u * t[1]
    ]
  }
  #K(e, t, n, o = 0.25) {
    switch (t) {
      case LinkDirection.LEFT:
        e[0] += n * -o
        break
      case LinkDirection.RIGHT:
        e[0] += n * o
        break
      case LinkDirection.UP:
        e[1] += n * -o
        break
      case LinkDirection.DOWN:
        e[1] += n * o
    }
  }
  drawExecutionOrder(e) {
    ;(e.shadowColor = 'transparent'),
      (e.globalAlpha = 0.25),
      (e.textAlign = 'center'),
      (e.strokeStyle = 'white'),
      (e.globalAlpha = 0.75)
    const t = this.visible_nodes
    for (let n = 0; n < t.length; ++n) {
      const o = t[n]
      ;(e.fillStyle = 'black'),
        e.fillRect(
          o.pos[0] - LiteGraph.NODE_TITLE_HEIGHT,
          o.pos[1] - LiteGraph.NODE_TITLE_HEIGHT,
          LiteGraph.NODE_TITLE_HEIGHT,
          LiteGraph.NODE_TITLE_HEIGHT
        ),
        0 == o.order &&
          e.strokeRect(
            o.pos[0] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
            o.pos[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
            LiteGraph.NODE_TITLE_HEIGHT,
            LiteGraph.NODE_TITLE_HEIGHT
          ),
        (e.fillStyle = '#FFF'),
        e.fillText(
          stringOrEmpty(o.order),
          o.pos[0] + -0.5 * LiteGraph.NODE_TITLE_HEIGHT,
          o.pos[1] - 6
        )
    }
    e.globalAlpha = 1
  }
  drawNodeWidgets(e, t, n, o) {
    if (!e.widgets || !e.widgets.length) return 0
    const i = e.size[0],
      r = e.widgets
    t += 2
    const a = LiteGraph.NODE_WIDGET_HEIGHT,
      s = this.ds.scale > 0.5
    n.save(), (n.globalAlpha = this.editor_alpha)
    const l = LiteGraph.WIDGET_BGCOLOR,
      c = LiteGraph.WIDGET_TEXT_COLOR,
      d = LiteGraph.WIDGET_SECONDARY_TEXT_COLOR,
      u = 15
    for (let p = 0; p < r.length; ++p) {
      const h = r[p]
      if (h.hidden || (h.advanced && !e.showAdvanced)) continue
      const m = h.y || t,
        f = h.advanced
          ? LiteGraph.WIDGET_ADVANCED_OUTLINE_COLOR
          : LiteGraph.WIDGET_OUTLINE_COLOR
      h === this.link_over_widget &&
        ((n.fillStyle =
          this.default_connection_color_byType[this.link_over_widget_type] ||
          this.default_connection_color.input_on),
        drawSlot(n, {}, [10, m + 10], {})),
        (h.last_y = m),
        (n.strokeStyle = f),
        (n.fillStyle = '#222'),
        (n.textAlign = 'left'),
        h.disabled && (n.globalAlpha *= 0.5)
      const _ = h.width || i
      switch (h.type) {
        case 'button':
          ;(n.fillStyle = l),
            h.clicked &&
              ((n.fillStyle = '#AAA'),
              (h.clicked = !1),
              (this.dirty_canvas = !0)),
            n.fillRect(u, m, _ - 30, a),
            s && !h.disabled && n.strokeRect(u, m, _ - 30, a),
            s &&
              ((n.textAlign = 'center'),
              (n.fillStyle = c),
              n.fillText(h.label || h.name, 0.5 * _, m + 0.7 * a))
          break
        case 'toggle':
          if (
            ((n.textAlign = 'left'),
            (n.strokeStyle = f),
            (n.fillStyle = l),
            n.beginPath(),
            s
              ? n.roundRect(u, m, _ - 30, a, [0.5 * a])
              : n.rect(u, m, _ - 30, a),
            n.fill(),
            s && !h.disabled && n.stroke(),
            (n.fillStyle = h.value ? '#89A' : '#333'),
            n.beginPath(),
            n.arc(_ - 30, m + 0.5 * a, 0.36 * a, 0, 2 * Math.PI),
            n.fill(),
            s)
          ) {
            n.fillStyle = d
            const e = h.label || h.name
            null != e && n.fillText(e, 30, m + 0.7 * a),
              (n.fillStyle = h.value ? c : d),
              (n.textAlign = 'right'),
              n.fillText(
                h.value ? h.options.on || 'true' : h.options.off || 'false',
                _ - 40,
                m + 0.7 * a
              )
          }
          break
        case 'slider': {
          ;(n.fillStyle = l), n.fillRect(u, m, _ - 30, a)
          const e = h.options.max - h.options.min
          let t = (h.value - h.options.min) / e
          if (
            (t < 0 && (t = 0),
            t > 1 && (t = 1),
            (n.fillStyle = h.options.hasOwnProperty('slider_color')
              ? h.options.slider_color
              : o == h
                ? '#89A'
                : '#678'),
            n.fillRect(u, m, t * (_ - 30), a),
            s && !h.disabled && n.strokeRect(u, m, _ - 30, a),
            h.marker)
          ) {
            let t = (h.marker - h.options.min) / e
            t < 0 && (t = 0),
              t > 1 && (t = 1),
              (n.fillStyle = h.options.hasOwnProperty('marker_color')
                ? h.options.marker_color
                : '#AA9'),
              n.fillRect(u + t * (_ - 30), m, 2, a)
          }
          s &&
            ((n.textAlign = 'center'),
            (n.fillStyle = c),
            n.fillText(
              h.label ||
                h.name +
                  '  ' +
                  Number(h.value).toFixed(
                    null != h.options.precision ? h.options.precision : 3
                  ),
              0.5 * _,
              m + 0.7 * a
            ))
          break
        }
        case 'number':
        case 'combo':
          if (
            ((n.textAlign = 'left'),
            (n.strokeStyle = f),
            (n.fillStyle = l),
            n.beginPath(),
            s
              ? n.roundRect(u, m, _ - 30, a, [0.5 * a])
              : n.rect(u, m, _ - 30, a),
            n.fill(),
            s)
          )
            if (
              (h.disabled || n.stroke(),
              (n.fillStyle = c),
              h.disabled ||
                (n.beginPath(),
                n.moveTo(31, m + 5),
                n.lineTo(21, m + 0.5 * a),
                n.lineTo(31, m + a - 5),
                n.fill(),
                n.beginPath(),
                n.moveTo(_ - u - 16, m + 5),
                n.lineTo(_ - u - 6, m + 0.5 * a),
                n.lineTo(_ - u - 16, m + a - 5),
                n.fill()),
              (n.fillStyle = d),
              n.fillText(h.label || h.name, 35, m + 0.7 * a),
              (n.fillStyle = c),
              (n.textAlign = 'right'),
              'number' == h.type)
            )
              n.fillText(
                Number(h.value).toFixed(
                  void 0 !== h.options.precision ? h.options.precision : 3
                ),
                _ - 30 - 20,
                m + 0.7 * a
              )
            else {
              let e = 'number' == typeof h.value ? String(h.value) : h.value
              if (h.options.values) {
                let t = h.options.values
                'function' == typeof t && (t = t()),
                  t && !Array.isArray(t) && (e = t[h.value])
              }
              const t = _ - 60 - (n.measureText(h.label || h.name).width + 30),
                o = n.measureText(e).width
              if (o > t) {
                const i = '…',
                  r = n.measureText(i).width,
                  a = n.measureText('a').width
                if (t <= r) e = '․'
                else {
                  e = `${e}`
                  if (o + r - t + 3 * a > t) {
                    const n = t + 3 * a,
                      o = Math.floor((n - r) / a)
                    e = e.substr(0, o)
                  }
                  for (; n.measureText(e).width + r > t; )
                    e = e.substr(0, e.length - 1)
                  e += i
                }
              }
              n.fillText(e, _ - 30 - 20, m + 0.7 * a)
            }
          break
        case 'string':
        case 'text':
          if (
            ((n.textAlign = 'left'),
            (n.strokeStyle = f),
            (n.fillStyle = l),
            n.beginPath(),
            s
              ? n.roundRect(u, m, _ - 30, a, [0.5 * a])
              : n.rect(u, m, _ - 30, a),
            n.fill(),
            s)
          ) {
            h.disabled || n.stroke(),
              n.save(),
              n.beginPath(),
              n.rect(u, m, _ - 30, a),
              n.clip(),
              (n.fillStyle = d)
            const e = h.label || h.name
            null != e && n.fillText(e, 30, m + 0.7 * a),
              (n.fillStyle = c),
              (n.textAlign = 'right'),
              n.fillText(String(h.value).substr(0, 30), _ - 30, m + 0.7 * a),
              n.restore()
          }
          break
        default:
          h.draw?.(n, e, _, m, a)
      }
      ;(t += (h.computeSize ? h.computeSize(_)[1] : a) + 4),
        (n.globalAlpha = this.editor_alpha)
    }
    n.restore(), (n.textAlign = 'left')
  }
  drawGroups(e, t) {
    if (!this.graph) return
    const n = this.graph._groups
    t.save(), (t.globalAlpha = 0.5 * this.editor_alpha)
    const o = this.#P && this.isDragging
    for (let i = 0; i < n.length; ++i) {
      const e = n[i]
      overlapBounding(this.visible_area, e._bounding) &&
        (o && this.selectedItems.has(e) && this.drawSnapGuide(t, e),
        e.draw(this, t))
    }
    t.restore()
  }
  adjustNodesSize() {
    const e = this.graph._nodes
    for (let t = 0; t < e.length; ++t) e[t].size = e[t].computeSize()
    this.setDirty(!0, !0)
  }
  resize(e, t) {
    if (!e && !t) {
      const n = this.canvas.parentElement
      ;(e = n.offsetWidth), (t = n.offsetHeight)
    }
    ;(this.canvas.width == e && this.canvas.height == t) ||
      ((this.canvas.width = e),
      (this.canvas.height = t),
      (this.bgcanvas.width = this.canvas.width),
      (this.bgcanvas.height = this.canvas.height),
      this.setDirty(!0, !0))
  }
  onNodeSelectionChange() {}
  boundaryNodesForSelection() {
    return LGraphCanvas.getBoundaryNodes(this.selected_nodes)
  }
  showLinkMenu(e, t) {
    const { graph: n } = this,
      o = n.getNodeById(e.origin_id),
      i = o?.outputs?.[e.origin_slot]?.type ?? '*',
      r = ['Add Node', null, 'Delete', null]
    this.reroutesEnabled && r.splice(1, 0, 'Add Reroute')
    const a = 'data' in e && null != e.data ? e.data.constructor.name : null,
      s = new LiteGraph.ContextMenu(r, {
        event: t,
        title: a,
        callback: l.bind(this)
      })
    function l(t, r, a) {
      switch (t) {
        case 'Add Node':
          LGraphCanvas.onMenuAdd(null, null, a, s, function (t) {
            if (!t.inputs?.length || !t.outputs?.length) return
            const n = this.reroutesEnabled
              ? { afterRerouteId: e.parentId }
              : void 0
            o.connectByType(e.origin_slot, t, i, n) &&
              (t.pos[0] -= 0.5 * t.size[0])
          })
          break
        case 'Add Reroute':
          this.adjustMouseEvent(a),
            n.createReroute([a.canvasX, a.canvasY], e),
            this.setDirty(!1, !0)
          break
        case 'Delete':
          n.removeLink(e.id)
      }
    }
    return __name(l, 'inner_clicked'), !1
  }
  createDefaultNodeForSlot(e) {
    const t = Object.assign(
        {
          nodeFrom: null,
          slotFrom: null,
          nodeTo: null,
          slotTo: null,
          position: [0, 0],
          nodeType: null,
          posAdd: [0, 0],
          posSizeFix: [0, 0]
        },
        e || {}
      ),
      { afterRerouteId: n } = t,
      o = t.nodeFrom && null !== t.slotFrom,
      i = !o && t.nodeTo && null !== t.slotTo
    if (!o && !i)
      return (
        console.warn(
          'No data passed to createDefaultNodeForSlot ' +
            t.nodeFrom +
            ' ' +
            t.slotFrom +
            ' ' +
            t.nodeTo +
            ' ' +
            t.slotTo
        ),
        !1
      )
    if (!t.nodeType)
      return console.warn('No type to createDefaultNodeForSlot'), !1
    const r = o ? t.nodeFrom : t.nodeTo
    let a = o ? t.slotFrom : t.slotTo,
      s = !1
    switch (typeof a) {
      case 'string':
        ;(s = o ? r.findOutputSlot(a, !1) : r.findInputSlot(a, !1)),
          (a = o ? r.outputs[a] : r.inputs[a])
        break
      case 'object':
        s = o ? r.findOutputSlot(a.name) : r.findInputSlot(a.name)
        break
      case 'number':
        ;(s = a), (a = o ? r.outputs[a] : r.inputs[a])
        break
      default:
        return console.warn('Cant get slot information ' + a), !1
    }
    const l = a.type == LiteGraph.EVENT ? '_event_' : a.type,
      c = o ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in
    if (c?.[l]) {
      let e = !1
      if ('object' == typeof c[l]) {
        for (const n in c[l])
          if (t.nodeType == c[l][n] || 'AUTO' == t.nodeType) {
            e = c[l][n]
            break
          }
      } else (t.nodeType != c[l] && 'AUTO' != t.nodeType) || (e = c[l])
      if (e) {
        let i = !1
        'object' == typeof e && e.node && ((i = e), (e = e.node))
        const r = LiteGraph.createNode(e)
        if (r) {
          if (i) {
            if (i.properties)
              for (const e in i.properties) r.addProperty(e, i.properties[e])
            if (i.inputs) {
              r.inputs = []
              for (const e in i.inputs)
                r.addOutput(i.inputs[e][0], i.inputs[e][1])
            }
            if (i.outputs) {
              r.outputs = []
              for (const e in i.outputs)
                r.addOutput(i.outputs[e][0], i.outputs[e][1])
            }
            i.title && (r.title = i.title), i.json && r.configure(i.json)
          }
          return (
            this.graph.add(r),
            (r.pos = [
              t.position[0] +
                t.posAdd[0] +
                (t.posSizeFix[0] ? t.posSizeFix[0] * r.size[0] : 0),
              t.position[1] +
                t.posAdd[1] +
                (t.posSizeFix[1] ? t.posSizeFix[1] * r.size[1] : 0)
            ]),
            o
              ? t.nodeFrom.connectByType(s, r, l, { afterRerouteId: n })
              : t.nodeTo.connectByTypeOutput(s, r, l, { afterRerouteId: n }),
            !0
          )
        }
        console.log('failed creating ' + e)
      }
    }
    return !1
  }
  showConnectionMenu(e) {
    const t = Object.assign(
        {
          nodeFrom: null,
          slotFrom: null,
          nodeTo: null,
          slotTo: null,
          e: null,
          allow_searchbox: this.allow_searchbox,
          showSearchBox: this.showSearchBox
        },
        e || {}
      ),
      n = this,
      { afterRerouteId: o } = t,
      i = t.nodeFrom && t.slotFrom,
      r = !i && t.nodeTo && t.slotTo
    if (!i && !r)
      return void console.warn('No data passed to showConnectionMenu')
    const a = i ? t.nodeFrom : t.nodeTo
    let s,
      l = i ? t.slotFrom : t.slotTo
    switch (typeof l) {
      case 'string':
        ;(s = i ? a.findOutputSlot(l, !1) : a.findInputSlot(l, !1)),
          (l = i ? a.outputs[l] : a.inputs[l])
        break
      case 'object':
        s = i ? a.findOutputSlot(l.name) : a.findInputSlot(l.name)
        break
      case 'number':
        ;(s = l), (l = i ? a.outputs[l] : a.inputs[l])
        break
      default:
        return void console.warn('Cant get slot information ' + l)
    }
    const c = ['Add Node', null]
    t.allow_searchbox && (c.push('Search'), c.push(null))
    const d = l.type == LiteGraph.EVENT ? '_event_' : l.type,
      u = i ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in
    if (u?.[d])
      if ('object' == typeof u[d]) for (const m in u[d]) c.push(u[d][m])
      else c.push(u[d])
    const p = new LiteGraph.ContextMenu(c, {
      event: t.e,
      title:
        (l && '' != l.name ? l.name + (d ? ' | ' : '') : '') +
        (l && d ? d : ''),
      callback: h
    })
    function h(e, r, a) {
      switch (e) {
        case 'Add Node':
          LGraphCanvas.onMenuAdd(null, null, a, p, function (e) {
            i
              ? t.nodeFrom.connectByType(s, e, d, { afterRerouteId: o })
              : t.nodeTo.connectByTypeOutput(s, e, d, { afterRerouteId: o })
          })
          break
        case 'Search':
          i
            ? t.showSearchBox(a, {
                node_from: t.nodeFrom,
                slot_from: l,
                type_filter_in: d
              })
            : t.showSearchBox(a, {
                node_to: t.nodeTo,
                slot_from: l,
                type_filter_out: d
              })
          break
        default:
          n.createDefaultNodeForSlot(
            Object.assign(t, {
              position: [t.e.canvasX, t.e.canvasY],
              nodeType: e,
              afterRerouteId: o
            })
          )
      }
    }
    __name(h, 'inner_clicked')
  }
  prompt(e, t, n, o, i) {
    const r = this
    e = e || ''
    const a = document.createElement('div')
    ;(a.is_modified = !1),
      (a.className = 'graphdialog rounded'),
      (a.innerHTML = i
        ? "<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>"
        : "<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>"),
      (a.close = function () {
        ;(r.prompt_box = null), a.parentNode && a.parentNode.removeChild(a)
      })
    const s = LGraphCanvas.active_canvas.canvas
    s.parentNode.appendChild(a),
      this.ds.scale > 1 && (a.style.transform = 'scale(' + this.ds.scale + ')')
    let l = null,
      c = 0
    LiteGraph.pointerListenerAdd(a, 'leave', function () {
      c ||
        (LiteGraph.dialog_close_on_mouse_leave &&
          !a.is_modified &&
          LiteGraph.dialog_close_on_mouse_leave &&
          (l = setTimeout(
            a.close,
            LiteGraph.dialog_close_on_mouse_leave_delay
          )))
    }),
      LiteGraph.pointerListenerAdd(a, 'enter', function () {
        LiteGraph.dialog_close_on_mouse_leave && l && clearTimeout(l)
      })
    const d = a.querySelectorAll('select')
    if (d)
      for (const _ of d)
        _.addEventListener('click', function () {
          c++
        }),
          _.addEventListener('blur', function () {
            c = 0
          }),
          _.addEventListener('change', function () {
            c = -1
          })
    this.prompt_box?.close(), (this.prompt_box = a)
    a.querySelector('.name').innerText = e
    const u = a.querySelector('.value')
    ;(u.value = t), u.select()
    const p = u
    p.addEventListener('keydown', function (e) {
      if (((a.is_modified = !0), 27 == e.keyCode)) a.close()
      else {
        if (13 != e.keyCode || 'textarea' == e.target.localName) return
        n && n(this.value), a.close()
      }
      e.preventDefault(), e.stopPropagation()
    })
    a.querySelector('button').addEventListener('click', function () {
      n?.(p.value), r.setDirty(!0), a.close()
    })
    const h = s.getBoundingClientRect()
    let m = -20,
      f = -20
    return (
      h && ((m -= h.left), (f -= h.top)),
      o
        ? ((a.style.left = o.clientX + m + 'px'),
          (a.style.top = o.clientY + f + 'px'))
        : ((a.style.left = 0.5 * s.width + m + 'px'),
          (a.style.top = 0.5 * s.height + f + 'px')),
      setTimeout(function () {
        p.focus()
        const e = Date.now()
        function t(n) {
          n.target === s &&
            Date.now() - e > 256 &&
            (a.close(),
            s.parentNode.removeEventListener('click', t),
            s.parentNode.removeEventListener('touchend', t))
        }
        __name(t, 'handleOutsideClick'),
          s.parentNode.addEventListener('click', t),
          s.parentNode.addEventListener('touchend', t)
      }, 10),
      a
    )
  }
  showSearchBox(e, t) {
    const n = {
      slot_from: null,
      node_from: null,
      node_to: null,
      do_type_filter: LiteGraph.search_filter_enabled,
      type_filter_in: !1,
      type_filter_out: !1,
      show_general_if_none_on_typefilter: !0,
      show_general_after_typefiltered: !0,
      hide_on_mouse_leave: LiteGraph.search_hide_on_mouse_leave,
      show_all_if_empty: !0,
      show_all_on_open: LiteGraph.search_show_all_on_open
    }
    t = Object.assign(n, t || {})
    const o = this,
      i = LGraphCanvas.active_canvas,
      r = i.canvas,
      a = r.ownerDocument || document,
      s = document.createElement('div')
    let l, c
    if (
      ((s.className = 'litegraph litesearchbox graphdialog rounded'),
      (s.innerHTML =
        "<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/>"),
      t.do_type_filter &&
        ((s.innerHTML +=
          "<select class='slot_in_type_filter'><option value=''></option></select>"),
        (s.innerHTML +=
          "<select class='slot_out_type_filter'><option value=''></option></select>")),
      (s.innerHTML += "<div class='helper'></div>"),
      a.fullscreenElement
        ? a.fullscreenElement.appendChild(s)
        : (a.body.appendChild(s), (a.body.style.overflow = 'hidden')),
      t.do_type_filter &&
        ((l = s.querySelector('.slot_in_type_filter')),
        (c = s.querySelector('.slot_out_type_filter'))),
      (s.close = function () {
        ;(o.search_box = null),
          this.blur(),
          r.focus(),
          (a.body.style.overflow = ''),
          setTimeout(function () {
            o.canvas.focus()
          }, 20),
          s.parentNode?.removeChild(s)
      }),
      this.ds.scale > 1 && (s.style.transform = 'scale(' + this.ds.scale + ')'),
      t.hide_on_mouse_leave)
    ) {
      let e = !1,
        n = null
      LiteGraph.pointerListenerAdd(s, 'enter', function () {
        n && (clearTimeout(n), (n = null))
      }),
        LiteGraph.pointerListenerAdd(s, 'leave', function () {
          e ||
            (n = setTimeout(
              function () {
                s.close()
              },
              'number' == typeof t.hide_on_mouse_leave
                ? t.hide_on_mouse_leave
                : 500
            ))
        }),
        t.do_type_filter &&
          (l.addEventListener('click', function () {
            e++
          }),
          l.addEventListener('blur', function () {
            e = 0
          }),
          l.addEventListener('change', function () {
            e = -1
          }),
          c.addEventListener('click', function () {
            e++
          }),
          c.addEventListener('blur', function () {
            e = 0
          }),
          c.addEventListener('change', function () {
            e = -1
          }))
    }
    o.search_box?.close(), (o.search_box = s)
    const d = s.querySelector('.helper')
    let u = null,
      p = null,
      h = null
    const m = s.querySelector('input')
    if (
      (m &&
        (m.addEventListener('blur', function () {
          this.focus()
        }),
        m.addEventListener('keydown', function (e) {
          if (38 == e.keyCode) y(!1)
          else if (40 == e.keyCode) y(!0)
          else if (27 == e.keyCode) s.close()
          else {
            if (13 != e.keyCode)
              return p && clearInterval(p), void (p = setTimeout(b, 10))
            h ? v(unescape(h.dataset.type)) : u ? v(u) : s.close()
          }
          return (
            e.preventDefault(),
            e.stopPropagation(),
            e.stopImmediatePropagation(),
            !0
          )
        })),
      t.do_type_filter)
    ) {
      if (l) {
        const e = LiteGraph.slot_types_in,
          n = e.length
        ;(t.type_filter_in != LiteGraph.EVENT &&
          t.type_filter_in != LiteGraph.ACTION) ||
          (t.type_filter_in = '_event_')
        for (let o = 0; o < n; o++) {
          const n = document.createElement('option')
          ;(n.value = e[o]),
            (n.innerHTML = e[o]),
            l.appendChild(n),
            !1 !== t.type_filter_in &&
              (t.type_filter_in + '').toLowerCase() ==
                (e[o] + '').toLowerCase() &&
              (n.selected = !0)
        }
        l.addEventListener('change', function () {
          b()
        })
      }
      if (c) {
        const e = LiteGraph.slot_types_out,
          n = e.length
        ;(t.type_filter_out != LiteGraph.EVENT &&
          t.type_filter_out != LiteGraph.ACTION) ||
          (t.type_filter_out = '_event_')
        for (let o = 0; o < n; o++) {
          const n = document.createElement('option')
          ;(n.value = e[o]),
            (n.innerHTML = e[o]),
            c.appendChild(n),
            !1 !== t.type_filter_out &&
              (t.type_filter_out + '').toLowerCase() ==
                (e[o] + '').toLowerCase() &&
              (n.selected = !0)
        }
        c.addEventListener('change', function () {
          b()
        })
      }
    }
    const f = r.getBoundingClientRect(),
      _ = (e ? e.clientX : f.left + 0.5 * f.width) - 80,
      g = (e ? e.clientY : f.top + 0.5 * f.height) - 20
    function v(n) {
      if (n)
        if (o.onSearchBoxSelection) o.onSearchBoxSelection(n, e, i)
        else {
          const o = LiteGraph.searchbox_extras[n.toLowerCase()]
          o && (n = o.type), i.graph.beforeChange()
          const r = LiteGraph.createNode(n)
          if (
            (r &&
              ((r.pos = i.convertEventToCanvasOffset(e)), i.graph.add(r, !1)),
            o?.data)
          ) {
            if (o.data.properties)
              for (const e in o.data.properties)
                r.addProperty(e, o.data.properties[e])
            if (o.data.inputs) {
              r.inputs = []
              for (const e in o.data.inputs)
                r.addOutput(o.data.inputs[e][0], o.data.inputs[e][1])
            }
            if (o.data.outputs) {
              r.outputs = []
              for (const e in o.data.outputs)
                r.addOutput(o.data.outputs[e][0], o.data.outputs[e][1])
            }
            o.data.title && (r.title = o.data.title),
              o.data.json && r.configure(o.data.json)
          }
          if (t.node_from) {
            let e = !1
            switch (typeof t.slot_from) {
              case 'string':
                e = t.node_from.findOutputSlot(t.slot_from)
                break
              case 'object':
                ;(e = t.slot_from.name
                  ? t.node_from.findOutputSlot(t.slot_from.name)
                  : -1),
                  -1 == e &&
                    void 0 !== t.slot_from.slot_index &&
                    (e = t.slot_from.slot_index)
                break
              case 'number':
                e = t.slot_from
                break
              default:
                e = 0
            }
            void 0 !== t.node_from.outputs[e] &&
              !1 !== e &&
              e > -1 &&
              t.node_from.connectByType(e, r, t.node_from.outputs[e].type)
          }
          if (t.node_to) {
            let e = !1
            switch (typeof t.slot_from) {
              case 'string':
                e = t.node_to.findInputSlot(t.slot_from)
                break
              case 'object':
                ;(e = t.slot_from.name
                  ? t.node_to.findInputSlot(t.slot_from.name)
                  : -1),
                  -1 == e &&
                    void 0 !== t.slot_from.slot_index &&
                    (e = t.slot_from.slot_index)
                break
              case 'number':
                e = t.slot_from
                break
              default:
                e = 0
            }
            void 0 !== t.node_to.inputs[e] &&
              !1 !== e &&
              e > -1 &&
              t.node_to.connectByTypeOutput(e, r, t.node_to.inputs[e].type)
          }
          i.graph.afterChange()
        }
      s.close()
    }
    function y(e) {
      const t = h
      h
        ? (h.classList.remove('selected'),
          (h = e ? h.nextSibling : h.previousSibling),
          (h ||= t))
        : (h = e ? d.childNodes[0] : d.childNodes[d.childNodes.length]),
        h &&
          (h.classList.add('selected'),
          h.scrollIntoView({ block: 'end', behavior: 'smooth' }))
    }
    function b() {
      p = null
      let e = m.value
      if (((u = null), (d.innerHTML = ''), e || t.show_all_if_empty)) {
        if (o.onSearchBox) {
          const t = o.onSearchBox(d, e, i)
          if (t) for (let e = 0; e < t.length; ++e) n(t[e])
        } else {
          let r = __name(function (n, o) {
              o = o || {}
              const i = Object.assign(
                  { skipFilter: !1, inTypeOverride: !1, outTypeOverride: !1 },
                  o
                ),
                r = LiteGraph.registered_node_types[n]
              if (s && r.filter != s) return !1
              if (
                (!t.show_all_if_empty || e) &&
                -1 === n.toLowerCase().indexOf(e) &&
                (!r.title || -1 === r.title.toLowerCase().indexOf(e))
              )
                return !1
              if (t.do_type_filter && !i.skipFilter) {
                const e = n
                let t = !1 !== i.inTypeOverride ? i.inTypeOverride : l.value
                if (l && t && LiteGraph.registered_slot_in_types[t]?.nodes) {
                  if (
                    !1 ===
                    LiteGraph.registered_slot_in_types[t].nodes.includes(e)
                  )
                    return !1
                }
                if (
                  ((t = c.value),
                  !1 !== i.outTypeOverride && (t = i.outTypeOverride),
                  c && t && LiteGraph.registered_slot_out_types[t]?.nodes)
                ) {
                  if (
                    !1 ===
                    LiteGraph.registered_slot_out_types[t].nodes.includes(e)
                  )
                    return !1
                }
              }
              return !0
            }, 'inner_test_filter'),
            a = 0
          e = e.toLowerCase()
          const s = i.filter || i.graph.filter
          let l = !1,
            c = !1
          t.do_type_filter &&
            o.search_box &&
            ((l = o.search_box.querySelector('.slot_in_type_filter')),
            (c = o.search_box.querySelector('.slot_out_type_filter')))
          for (const o in LiteGraph.searchbox_extras) {
            const i = LiteGraph.searchbox_extras[o]
            if (
              (!t.show_all_if_empty || e) &&
              -1 === i.desc.toLowerCase().indexOf(e)
            )
              continue
            const l = LiteGraph.registered_node_types[i.type]
            if (
              (!l || l.filter == s) &&
              r(i.type) &&
              (n(i.desc, 'searchbox_extra'),
              -1 !== LGraphCanvas.search_limit &&
                a++ > LGraphCanvas.search_limit)
            )
              break
          }
          let u = null
          if (Array.prototype.filter) {
            u = Object.keys(LiteGraph.registered_node_types).filter(r)
          } else {
            u = []
            for (const e in LiteGraph.registered_node_types) r(e) && u.push(e)
          }
          for (
            let e = 0;
            e < u.length &&
            (n(u[e]),
            !(
              -1 !== LGraphCanvas.search_limit &&
              a++ > LGraphCanvas.search_limit
            ));
            e++
          );
          if (t.show_general_after_typefiltered && (l.value || c.value)) {
            filtered_extra = []
            for (const e in LiteGraph.registered_node_types)
              r(e, {
                inTypeOverride: !(!l || !l.value) && '*',
                outTypeOverride: !(!c || !c.value) && '*'
              }) && filtered_extra.push(e)
            for (
              let e = 0;
              e < filtered_extra.length &&
              (n(filtered_extra[e], 'generic_type'),
              !(
                -1 !== LGraphCanvas.search_limit &&
                a++ > LGraphCanvas.search_limit
              ));
              e++
            );
          }
          if (
            (l.value || c.value) &&
            0 == d.childNodes.length &&
            t.show_general_if_none_on_typefilter
          ) {
            filtered_extra = []
            for (const e in LiteGraph.registered_node_types)
              r(e, { skipFilter: !0 }) && filtered_extra.push(e)
            for (
              let e = 0;
              e < filtered_extra.length &&
              (n(filtered_extra[e], 'not_in_filter'),
              !(
                -1 !== LGraphCanvas.search_limit &&
                a++ > LGraphCanvas.search_limit
              ));
              e++
            );
          }
        }
        __name(n, 'addResult')
      }
      function n(e, t) {
        const n = document.createElement('div')
        u ||= e
        const o = LiteGraph.registered_node_types[e]
        if (o?.title) {
          n.innerText = o?.title
          const t = document.createElement('span')
          ;(t.className = 'litegraph lite-search-item-type'),
            (t.textContent = e),
            n.append(t)
        } else n.innerText = e
        ;(n.dataset.type = escape(e)),
          (n.className = 'litegraph lite-search-item'),
          t && (n.className += ' ' + t),
          n.addEventListener('click', function () {
            v(unescape(this.dataset.type))
          }),
          d.appendChild(n)
      }
    }
    return (
      (s.style.left = _ + 'px'),
      (s.style.top = g + 'px'),
      e.layerY > f.height - 200 &&
        (d.style.maxHeight = f.height - e.layerY - 20 + 'px'),
      requestAnimationFrame(function () {
        m.focus()
      }),
      t.show_all_on_open && b(),
      __name(v, 'select'),
      __name(y, 'changeSelection'),
      __name(b, 'refreshHelper'),
      s
    )
  }
  showEditPropertyValue(e, t, n) {
    if (!e || void 0 === e.properties[t]) return
    n = n || {}
    const o = e.getPropertyInfo(t),
      i = o.type
    let r = ''
    if ('string' == i || 'number' == i || 'array' == i || 'object' == i)
      r = "<input autofocus type='text' class='value'/>"
    else if (('enum' != i && 'combo' != i) || !o.values) {
      if ('boolean' != i && 'toggle' != i)
        return void console.warn('unknown type: ' + i)
      r =
        "<input autofocus type='checkbox' class='value' " +
        (e.properties[t] ? 'checked' : '') +
        '/>'
    } else {
      r = "<select autofocus type='text' class='value'>"
      for (const n in o.values) {
        const i = Array.isArray(o.values) ? o.values[n] : n
        r +=
          "<option value='" +
          i +
          "' " +
          (i == e.properties[t] ? 'selected' : '') +
          '>' +
          o.values[n] +
          '</option>'
      }
      r += '</select>'
    }
    const a = this.createDialog(
      "<span class='name'>" +
        (o.label || t) +
        '</span>' +
        r +
        '<button>OK</button>',
      n
    )
    let s
    if (('enum' != i && 'combo' != i) || !o.values) {
      if ('boolean' == i || 'toggle' == i)
        (s = a.querySelector('input')),
          s?.addEventListener('click', function () {
            a.modified(), c(!!s.checked)
          })
      else if (((s = a.querySelector('input')), s)) {
        s.addEventListener('blur', function () {
          this.focus()
        })
        let n = void 0 !== e.properties[t] ? e.properties[t] : ''
        'string' !== i && (n = JSON.stringify(n)),
          (s.value = n),
          s.addEventListener('keydown', function (e) {
            if (27 == e.keyCode) a.close()
            else if (13 == e.keyCode) l()
            else if (13 != e.keyCode) return void a.modified()
            e.preventDefault(), e.stopPropagation()
          })
      }
    } else
      (s = a.querySelector('select')),
        s.addEventListener('change', function (e) {
          a.modified(), c(e.target?.value)
        })
    s?.focus()
    function l() {
      c(s.value)
    }
    function c(r) {
      o?.values &&
        'object' == typeof o.values &&
        null != o.values[r] &&
        (r = o.values[r]),
        'number' == typeof e.properties[t] && (r = Number(r)),
        ('array' != i && 'object' != i) || (r = JSON.parse(r)),
        (e.properties[t] = r),
        e.graph && e.graph._version++,
        e.onPropertyChanged?.(t, r),
        n.onclose?.(),
        a.close(),
        this.setDirty(!0, !0)
    }
    return (
      a.querySelector('button').addEventListener('click', l),
      __name(l, 'inner'),
      __name(c, 'setValue'),
      a
    )
  }
  createDialog(e, t) {
    t = Object.assign(
      { checkForInput: !1, closeOnLeave: !0, closeOnLeave_checkModified: !0 },
      t || {}
    )
    const n = document.createElement('div')
    ;(n.className = 'graphdialog'), (n.innerHTML = e), (n.is_modified = !1)
    const o = this.canvas.getBoundingClientRect()
    let i = -20,
      r = -20
    if (
      (o && ((i -= o.left), (r -= o.top)),
      t.position
        ? ((i += t.position[0]), (r += t.position[1]))
        : t.event
          ? ((i += t.event.clientX), (r += t.event.clientY))
          : ((i += 0.5 * this.canvas.width), (r += 0.5 * this.canvas.height)),
      (n.style.left = i + 'px'),
      (n.style.top = r + 'px'),
      this.canvas.parentNode.appendChild(n),
      t.checkForInput)
    ) {
      const e = n.querySelectorAll('input')
      e?.forEach(function (e) {
        e.addEventListener('keydown', function (e) {
          if ((n.modified(), 27 == e.keyCode)) n.close()
          else if (13 != e.keyCode) return
          e.preventDefault(), e.stopPropagation()
        }),
          e.focus()
      })
    }
    ;(n.modified = function () {
      n.is_modified = !0
    }),
      (n.close = function () {
        n.parentNode?.removeChild(n)
      })
    let a = null,
      s = 0
    n.addEventListener('mouseleave', function () {
      s ||
        (!n.is_modified &&
          LiteGraph.dialog_close_on_mouse_leave &&
          (a = setTimeout(
            n.close,
            LiteGraph.dialog_close_on_mouse_leave_delay
          )))
    }),
      n.addEventListener('mouseenter', function () {
        ;(t.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave) &&
          a &&
          clearTimeout(a)
      })
    const l = n.querySelectorAll('select')
    return (
      l?.forEach(function (e) {
        e.addEventListener('click', function () {
          s++
        }),
          e.addEventListener('blur', function () {
            s = 0
          }),
          e.addEventListener('change', function () {
            s = -1
          })
      }),
      n
    )
  }
  createPanel(e, t) {
    const n = (t = t || {}).window || window,
      o = document.createElement('div')
    if (
      ((o.className = 'litegraph dialog'),
      (o.innerHTML =
        "<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div style='display:none;' class='dialog-alt-content'></div><div class='dialog-footer'></div>"),
      (o.header = o.querySelector('.dialog-header')),
      t.width &&
        (o.style.width = t.width + ('number' == typeof t.width ? 'px' : '')),
      t.height &&
        (o.style.height = t.height + ('number' == typeof t.height ? 'px' : '')),
      t.closable)
    ) {
      const e = document.createElement('span')
      ;(e.innerHTML = '&#10005;'),
        e.classList.add('close'),
        e.addEventListener('click', function () {
          o.close()
        }),
        o.header.appendChild(e)
    }
    return (
      (o.title_element = o.querySelector('.dialog-title')),
      (o.title_element.innerText = e),
      (o.content = o.querySelector('.dialog-content')),
      (o.alt_content = o.querySelector('.dialog-alt-content')),
      (o.footer = o.querySelector('.dialog-footer')),
      (o.close = function () {
        'function' == typeof o.onClose && o.onClose(),
          o.parentNode?.removeChild(o),
          this.parentNode?.removeChild(this)
      }),
      (o.toggleAltContent = function (e) {
        let t, n
        void 0 !== e
          ? ((t = e ? 'block' : 'none'), (n = e ? 'none' : 'block'))
          : ((t = 'block' != o.alt_content.style.display ? 'block' : 'none'),
            (n = 'block' != o.alt_content.style.display ? 'none' : 'block')),
          (o.alt_content.style.display = t),
          (o.content.style.display = n)
      }),
      (o.toggleFooterVisibility = function (e) {
        let t
        ;(t =
          void 0 !== e
            ? e
              ? 'block'
              : 'none'
            : 'block' != o.footer.style.display
              ? 'block'
              : 'none'),
          (o.footer.style.display = t)
      }),
      (o.clear = function () {
        this.content.innerHTML = ''
      }),
      (o.addHTML = function (e, t, n) {
        const i = document.createElement('div')
        return (
          t && (i.className = t),
          (i.innerHTML = e),
          n ? o.footer.appendChild(i) : o.content.appendChild(i),
          i
        )
      }),
      (o.addButton = function (e, t, n) {
        const i = document.createElement('button')
        return (
          (i.innerText = e),
          (i.options = n),
          i.classList.add('btn'),
          i.addEventListener('click', t),
          o.footer.appendChild(i),
          i
        )
      }),
      (o.addSeparator = function () {
        const e = document.createElement('div')
        ;(e.className = 'separator'), o.content.appendChild(e)
      }),
      (o.addWidget = function (e, t, i, r, a) {
        r = r || {}
        let s = String(i)
        'number' == (e = e.toLowerCase()) && (s = i.toFixed(3))
        const l = document.createElement('div')
        ;(l.className = 'property'),
          (l.innerHTML =
            "<span class='property_name'></span><span class='property_value'></span>"),
          (l.querySelector('.property_name').innerText = r.label || t)
        const c = l.querySelector('.property_value')
        if (
          ((c.innerText = s),
          (l.dataset.property = t),
          (l.dataset.type = r.type || e),
          (l.options = r),
          (l.value = i),
          'code' == e)
        )
          l.addEventListener('click', function () {
            o.inner_showCodePad(this.dataset.property)
          })
        else if ('boolean' == e)
          l.classList.add('boolean'),
            i && l.classList.add('bool-on'),
            l.addEventListener('click', function () {
              const e = this.dataset.property
              ;(this.value = !this.value),
                this.classList.toggle('bool-on'),
                (this.querySelector('.property_value').innerText = this.value
                  ? 'true'
                  : 'false'),
                d(e, this.value)
            })
        else if ('string' == e || 'number' == e)
          c.setAttribute('contenteditable', !0),
            c.addEventListener('keydown', function (t) {
              'Enter' != t.code ||
                ('string' == e && t.shiftKey) ||
                (t.preventDefault(), this.blur())
            }),
            c.addEventListener('blur', function () {
              let e = this.innerText
              const t = this.parentNode.dataset.property
              'number' == this.parentNode.dataset.type && (e = Number(e)),
                d(t, e)
            })
        else if ('enum' == e || 'combo' == e) {
          const e = LGraphCanvas.getPropertyPrintableValue(i, r.values)
          ;(c.innerText = e),
            c.addEventListener('click', function (e) {
              const t = r.values || [],
                o = this.parentNode.dataset.property,
                i = this
              function a(e) {
                return (i.innerText = e), d(o, e), !1
              }
              new LiteGraph.ContextMenu(
                t,
                { event: e, className: 'dark', callback: a },
                n
              ),
                __name(a, 'inner_clicked')
            })
        }
        function d(e, t) {
          r.callback?.(e, t, r), a?.(e, t, r)
        }
        return o.content.appendChild(l), __name(d, 'innerChange'), l
      }),
      o.onOpen && 'function' == typeof o.onOpen && o.onOpen(),
      o
    )
  }
  closePanels() {
    document.querySelector('#node-panel')?.close(),
      document.querySelector('#option-panel')?.close()
  }
  showShowNodePanel(e) {
    ;(this.SELECTED_NODE = e), this.closePanels()
    const t = this.getCanvasWindow(),
      n = this,
      o = this.createPanel(e.title || '', {
        closable: !0,
        window: t,
        onOpen: __name(function () {
          n.NODEPANEL_IS_OPEN = !0
        }, 'onOpen'),
        onClose: __name(function () {
          ;(n.NODEPANEL_IS_OPEN = !1), (n.node_panel = null)
        }, 'onClose')
      })
    function i() {
      ;(o.content.innerHTML = ''),
        o.addHTML(
          `<span class='node_type'>${e.type}</span><span class='node_desc'>${e.constructor.desc || ''}</span><span class='separator'></span>`
        ),
        o.addHTML('<h3>Properties</h3>')
      const t = __name(function (t, o) {
        switch ((n.graph.beforeChange(e), t)) {
          case 'Title':
            e.title = o
            break
          case 'Mode': {
            const t = Object.values(LiteGraph.NODE_MODES).indexOf(o)
            t >= 0 && LiteGraph.NODE_MODES[t]
              ? e.changeMode(t)
              : console.warn('unexpected mode: ' + o)
            break
          }
          case 'Color':
            LGraphCanvas.node_colors[o]
              ? ((e.color = LGraphCanvas.node_colors[o].color),
                (e.bgcolor = LGraphCanvas.node_colors[o].bgcolor))
              : console.warn('unexpected color: ' + o)
            break
          default:
            e.setProperty(t, o)
        }
        n.graph.afterChange(), (n.dirty_canvas = !0)
      }, 'fUpdate')
      o.addWidget('string', 'Title', e.title, {}, t),
        o.addWidget(
          'combo',
          'Mode',
          LiteGraph.NODE_MODES[e.mode],
          { values: LiteGraph.NODE_MODES },
          t
        )
      const i =
        void 0 !== e.color
          ? Object.keys(LGraphCanvas.node_colors).filter(function (t) {
              return LGraphCanvas.node_colors[t].color == e.color
            })
          : ''
      o.addWidget(
        'combo',
        'Color',
        i,
        { values: Object.keys(LGraphCanvas.node_colors) },
        t
      )
      for (const n in e.properties) {
        const i = e.properties[n],
          r = e.getPropertyInfo(n)
        e.onAddPropertyToPanel?.(n, o) ||
          o.addWidget(r.widget || r.type, n, i, r, t)
      }
      o.addSeparator(),
        e.onShowCustomPanelInfo?.(o),
        (o.footer.innerHTML = ''),
        o
          .addButton('Delete', function () {
            e.block_delete || (e.graph.remove(e), o.close())
          })
          .classList.add('delete')
    }
    ;(n.node_panel = o),
      (o.id = 'node-panel'),
      (o.node = e),
      o.classList.add('settings'),
      __name(i, 'inner_refresh'),
      (o.inner_showCodePad = function (t) {
        o.classList.remove('settings'),
          o.classList.add('centered'),
          (o.alt_content.innerHTML = "<textarea class='code'></textarea>")
        const n = o.alt_content.querySelector('textarea'),
          r = __name(function () {
            o.toggleAltContent(!1),
              o.toggleFooterVisibility(!0),
              n.parentNode.removeChild(n),
              o.classList.add('settings'),
              o.classList.remove('centered'),
              i()
          }, 'fDoneWith')
        ;(n.value = e.properties[t]),
          n.addEventListener('keydown', function (o) {
            'Enter' == o.code && o.ctrlKey && (e.setProperty(t, n.value), r())
          }),
          o.toggleAltContent(!0),
          o.toggleFooterVisibility(!1),
          (n.style.height = 'calc(100% - 40px)')
        const a = o.addButton('Assign', function () {
          e.setProperty(t, n.value), r()
        })
        o.alt_content.appendChild(a)
        const s = o.addButton('Close', r)
        ;(s.style.float = 'right'), o.alt_content.appendChild(s)
      }),
      i(),
      this.canvas.parentNode.appendChild(o)
  }
  checkPanels() {
    if (!this.canvas) return
    const e = this.canvas.parentNode.querySelectorAll('.litegraph.dialog')
    for (let t = 0; t < e.length; ++t) {
      const n = e[t]
      n.node && ((n.node.graph && n.graph == this.graph) || n.close())
    }
  }
  getCanvasMenuOptions() {
    let e = null
    this.getMenuOptions
      ? (e = this.getMenuOptions())
      : ((e = [
          {
            content: 'Add Node',
            has_submenu: !0,
            callback: LGraphCanvas.onMenuAdd
          },
          { content: 'Add Group', callback: LGraphCanvas.onGroupAdd }
        ]),
        Object.keys(this.selected_nodes).length > 1 &&
          e.push({
            content: 'Align',
            has_submenu: !0,
            callback: LGraphCanvas.onGroupAlign
          }))
    const t = this.getExtraMenuOptions?.(this, e)
    return t ? e.concat(t) : e
  }
  getNodeMenuOptions(e) {
    let t = null
    e.getMenuOptions
      ? (t = e.getMenuOptions(this))
      : ((t = [
          {
            content: 'Inputs',
            has_submenu: !0,
            disabled: !0,
            callback: LGraphCanvas.showMenuNodeOptionalInputs
          },
          {
            content: 'Outputs',
            has_submenu: !0,
            disabled: !0,
            callback: LGraphCanvas.showMenuNodeOptionalOutputs
          },
          null,
          {
            content: 'Properties',
            has_submenu: !0,
            callback: LGraphCanvas.onShowMenuNodeProperties
          },
          {
            content: 'Properties Panel',
            callback: __name(function (e, t, n, o, i) {
              LGraphCanvas.active_canvas.showShowNodePanel(i)
            }, 'callback')
          },
          null,
          { content: 'Title', callback: LGraphCanvas.onShowPropertyEditor },
          {
            content: 'Mode',
            has_submenu: !0,
            callback: LGraphCanvas.onMenuNodeMode
          }
        ]),
        !1 !== e.resizable &&
          t.push({
            content: 'Resize',
            callback: LGraphCanvas.onMenuResizeNode
          }),
        e.collapsible &&
          t.push({
            content: e.collapsed ? 'Expand' : 'Collapse',
            callback: LGraphCanvas.onMenuNodeCollapse
          }),
        e.widgets?.some((e) => e.advanced) &&
          t.push({
            content: e.showAdvanced ? 'Hide Advanced' : 'Show Advanced',
            callback: LGraphCanvas.onMenuToggleAdvanced
          }),
        t.push(
          {
            content: e.pinned ? 'Unpin' : 'Pin',
            callback: __name((...e) => {
              LGraphCanvas.onMenuNodePin(...e)
              for (const t in this.selected_nodes) {
                this.selected_nodes[t].pin()
              }
              this.setDirty(!0, !0)
            }, 'callback')
          },
          {
            content: 'Colors',
            has_submenu: !0,
            callback: LGraphCanvas.onMenuNodeColors
          },
          {
            content: 'Shapes',
            has_submenu: !0,
            callback: LGraphCanvas.onMenuNodeShapes
          },
          null
        ))
    const n = e.onGetInputs?.()
    n?.length && (t[0].disabled = !1)
    const o = e.onGetOutputs?.()
    o?.length && (t[1].disabled = !1)
    const i = e.getExtraMenuOptions?.(this, t)
    return (
      i && (i.push(null), (t = i.concat(t))),
      !1 !== e.clonable &&
        t.push({ content: 'Clone', callback: LGraphCanvas.onMenuNodeClone }),
      Object.keys(this.selected_nodes).length > 1 &&
        (t.push({
          content: 'Align Selected To',
          has_submenu: !0,
          callback: LGraphCanvas.onNodeAlign
        }),
        t.push({
          content: 'Distribute Nodes',
          has_submenu: !0,
          callback: LGraphCanvas.createDistributeMenu
        })),
      t.push(null, {
        content: 'Remove',
        disabled: !(!1 !== e.removable && !e.block_delete),
        callback: LGraphCanvas.onMenuNodeRemove
      }),
      e.graph?.onGetNodeMenuOptions?.(t, e),
      t
    )
  }
  getGroupMenuOptions(e) {
    return (
      console.warn(
        'LGraphCanvas.getGroupMenuOptions is deprecated, use LGraphGroup.getMenuOptions instead'
      ),
      e.getMenuOptions()
    )
  }
  processContextMenu(e, t) {
    const n = this,
      o = LGraphCanvas.active_canvas.getCanvasWindow()
    let i = null
    const r = { event: t, callback: s, extra: e }
    e && (r.title = e.type)
    let a = null
    if (
      (e &&
        ((a = e.getSlotInPosition(t.canvasX, t.canvasY)),
        (LGraphCanvas.active_node = e)),
      a)
    ) {
      if (((i = []), e.getSlotMenuOptions)) i = e.getSlotMenuOptions(a)
      else {
        a?.output?.links?.length &&
          i.push({ content: 'Disconnect Links', slot: a })
        const e = a.input || a.output
        e.removable &&
          i.push(
            e.locked ? 'Cannot remove' : { content: 'Remove Slot', slot: a }
          ),
          e.nameLocked || i.push({ content: 'Rename Slot', slot: a })
      }
      ;(r.title = (a.input ? a.input.type : a.output.type) || '*'),
        a.input && a.input.type == LiteGraph.ACTION && (r.title = 'Action'),
        a.output && a.output.type == LiteGraph.EVENT && (r.title = 'Event')
    } else if (e) i = this.getNodeMenuOptions(e)
    else {
      if (((i = this.getCanvasMenuOptions()), this.reroutesEnabled)) {
        const e = this.graph.getRerouteOnPos(t.canvasX, t.canvasY)
        e &&
          i.unshift(
            {
              content: 'Delete Reroute',
              callback: __name(() => this.graph.removeReroute(e.id), 'callback')
            },
            null
          )
      }
      const e = this.graph.getGroupOnPos(t.canvasX, t.canvasY)
      e &&
        i.push(null, {
          content: 'Edit Group',
          has_submenu: !0,
          submenu: { title: 'Group', extra: e, options: e.getMenuOptions() }
        })
    }
    function s(t, o) {
      if (t) {
        if ('Remove Slot' == t.content) {
          const n = t.slot
          return (
            e.graph.beforeChange(),
            n.input
              ? e.removeInput(n.slot)
              : n.output && e.removeOutput(n.slot),
            void e.graph.afterChange()
          )
        }
        if ('Disconnect Links' == t.content) {
          const n = t.slot
          return (
            e.graph.beforeChange(),
            n.output
              ? e.disconnectOutput(n.slot)
              : n.input && e.disconnectInput(n.slot),
            void e.graph.afterChange()
          )
        }
        if ('Rename Slot' == t.content) {
          const i = t.slot,
            r = i.input ? e.getInputInfo(i.slot) : e.getOutputInfo(i.slot),
            a = n.createDialog(
              "<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>",
              o
            ),
            s = a.querySelector('input')
          s && r && (s.value = r.label || '')
          const l = __name(function () {
            e.graph.beforeChange(),
              s.value && (r && (r.label = s.value), n.setDirty(!0)),
              a.close(),
              e.graph.afterChange()
          }, 'inner')
          a.querySelector('button').addEventListener('click', l),
            s.addEventListener('keydown', function (e) {
              if (((a.is_modified = !0), 27 == e.keyCode)) a.close()
              else if (13 == e.keyCode) l()
              else if (13 != e.keyCode && 'textarea' != e.target.localName)
                return
              e.preventDefault(), e.stopPropagation()
            }),
            s.focus()
        }
      }
    }
    i && (new LiteGraph.ContextMenu(i, r, o), __name(s, 'inner_option_clicked'))
  }
  animateToBounds(
    e,
    {
      duration: t = 350,
      zoom: n = 0.75,
      easing: o = EaseFunction.EASE_IN_OUT_QUAD
    } = {}
  ) {
    const i = {
        linear: __name((e) => e, 'linear'),
        easeInQuad: __name((e) => e * e, 'easeInQuad'),
        easeOutQuad: __name((e) => e * (2 - e), 'easeOutQuad'),
        easeInOutQuad: __name(
          (e) => (e < 0.5 ? 2 * e * e : (4 - 2 * e) * e - 1),
          'easeInOutQuad'
        )
      },
      r = i[o] ?? i.linear
    let a = null
    const s = performance.now(),
      l = this.ds.offset[0],
      c = this.ds.offset[1],
      d = this.ds.scale,
      u = this.canvas.width / window.devicePixelRatio,
      p = this.canvas.height / window.devicePixelRatio
    let h = d,
      m = l,
      f = c
    if (n > 0) {
      const t = (n * u) / Math.max(e[2], 300),
        o = (n * p) / Math.max(e[3], 300)
      h = Math.min(t, o, this.ds.max_scale)
    }
    ;(m = -e[0] - 0.5 * e[2] + (0.5 * u) / h),
      (f = -e[1] - 0.5 * e[3] + (0.5 * p) / h)
    const _ = __name((e) => {
      const o = e - s,
        i = Math.min(o / t, 1),
        u = r(i)
      ;(this.ds.offset[0] = l + (m - l) * u),
        (this.ds.offset[1] = c + (f - c) * u),
        n > 0 && (this.ds.scale = d + (h - d) * u),
        this.setDirty(!0, !0),
        i < 1 ? (a = requestAnimationFrame(_)) : cancelAnimationFrame(a)
    }, 'animate')
    a = requestAnimationFrame(_)
  }
  fitViewToSelectionAnimated(e = {}) {
    const t = this.selectedItems.size
      ? Array.from(this.selectedItems)
      : this.positionableItems
    this.animateToBounds(createBounds(t), e)
  }
}
class MapProxyHandler {
  static {
    __name(this, 'MapProxyHandler')
  }
  getOwnPropertyDescriptor(e, t) {
    const n = this.get(e, t)
    if (n) return { configurable: !0, enumerable: !0, value: n }
  }
  has(e, t) {
    if ('symbol' == typeof t) return !1
    const n = parseInt(t, 10)
    return e.has(isNaN(n) ? t : n)
  }
  ownKeys(e) {
    return [...e.keys()].map((e) => String(e))
  }
  get(e, t) {
    if (t in e) return Reflect.get(e, t, e)
    if ('symbol' == typeof t) return
    const n = parseInt(t, 10)
    return e.get(isNaN(n) ? t : n)
  }
  set(e, t, n) {
    if ('symbol' == typeof t) return !1
    const o = parseInt(t, 10)
    return e.set(isNaN(o) ? t : o, n), !0
  }
  deleteProperty(e, t) {
    return e.delete(t)
  }
  static bindAllMethods(e) {
    ;(e.clear = e.clear.bind(e)),
      (e.delete = e.delete.bind(e)),
      (e.forEach = e.forEach.bind(e)),
      (e.get = e.get.bind(e)),
      (e.has = e.has.bind(e)),
      (e.set = e.set.bind(e)),
      (e.entries = e.entries.bind(e)),
      (e.keys = e.keys.bind(e)),
      (e.values = e.values.bind(e))
  }
}
let LGraph$1 = class e {
  static {
    __name(this, 'LGraph')
  }
  static serialisedSchemaVersion = 1
  static supported_types = ['number', 'string', 'boolean']
  static STATUS_STOPPED = 1
  static STATUS_RUNNING = 2
  _version
  _links = new Map()
  links
  list_of_graphcanvas
  status
  state
  _nodes
  _nodes_by_id
  _nodes_in_order
  _nodes_executable
  _groups
  iteration
  globaltime
  runningtime
  fixedtime
  fixedtime_lapse
  elapsed_time
  last_update_time
  starttime
  catch_errors
  execution_timer_id
  errors_in_execution
  execution_time
  _last_trigger_time
  filter
  _subgraph_node
  config
  vars
  nodes_executing
  nodes_actioning
  nodes_executedAction
  extra
  inputs
  outputs
  get empty() {
    return 0 === this.positionableItems.length
  }
  get positionableItems() {
    return [...this._nodes, ...this._groups, ...this.reroutes.values()]
  }
  #Z = new Map()
  get reroutes() {
    return this.#Z
  }
  set reroutes(e) {
    if (!e)
      throw new TypeError('Attempted to set LGraph.reroutes to a falsy value.')
    const t = this.#Z
    if (0 !== e.size) {
      for (const n of t.keys()) e.has(n) || t.delete(n)
      for (const [n, o] of e) t.set(n, o)
    } else t.clear()
  }
  get last_node_id() {
    return this.state.lastNodeId
  }
  set last_node_id(e) {
    this.state.lastNodeId = e
  }
  get last_link_id() {
    return this.state.lastLinkId
  }
  set last_link_id(e) {
    this.state.lastLinkId = e
  }
  _input_nodes
  constructor(e) {
    LiteGraph.debug && console.log('Graph created')
    const t = this._links
    MapProxyHandler.bindAllMethods(t)
    const n = new MapProxyHandler()
    ;(this.links = new Proxy(t, n)),
      (this.list_of_graphcanvas = null),
      this.clear(),
      e && this.configure(e)
  }
  getSupportedTypes() {
    return this.supported_types || e.supported_types
  }
  clear() {
    if (
      (this.stop(),
      (this.status = e.STATUS_STOPPED),
      (this.state = {
        lastGroupId: 0,
        lastNodeId: 0,
        lastLinkId: 0,
        lastRerouteId: 0
      }),
      (this._version = -1),
      this._nodes)
    )
      for (let e = 0; e < this._nodes.length; ++e) this._nodes[e].onRemoved?.()
    ;(this._nodes = []),
      (this._nodes_by_id = {}),
      (this._nodes_in_order = []),
      (this._nodes_executable = null),
      this._links.clear(),
      this.reroutes.clear(),
      (this._groups = []),
      (this.iteration = 0),
      (this.config = {}),
      (this.vars = {}),
      (this.extra = {}),
      (this.globaltime = 0),
      (this.runningtime = 0),
      (this.fixedtime = 0),
      (this.fixedtime_lapse = 0.01),
      (this.elapsed_time = 0.01),
      (this.last_update_time = 0),
      (this.starttime = 0),
      (this.catch_errors = !0),
      (this.nodes_executing = []),
      (this.nodes_actioning = []),
      (this.nodes_executedAction = []),
      (this.inputs = {}),
      (this.outputs = {}),
      this.change(),
      this.canvasAction((e) => e.clear())
  }
  get nodes() {
    return this._nodes
  }
  get groups() {
    return this._groups
  }
  attachCanvas(e) {
    if (e.constructor != LGraphCanvas)
      throw 'attachCanvas expects a LGraphCanvas instance'
    e.graph != this && e.graph?.detachCanvas(e),
      (e.graph = this),
      (this.list_of_graphcanvas ||= []),
      this.list_of_graphcanvas.push(e)
  }
  detachCanvas(e) {
    if (!this.list_of_graphcanvas) return
    const t = this.list_of_graphcanvas.indexOf(e)
    ;-1 != t && ((e.graph = null), this.list_of_graphcanvas.splice(t, 1))
  }
  start(t) {
    if (this.status == e.STATUS_RUNNING) return
    ;(this.status = e.STATUS_RUNNING),
      this.onPlayEvent?.(),
      this.sendEventToAllNodes('onStart'),
      (this.starttime = LiteGraph.getTime()),
      (this.last_update_time = this.starttime),
      (t ||= 0)
    const n = this
    if (
      0 == t &&
      'undefined' != typeof window &&
      window.requestAnimationFrame
    ) {
      let e = __name(function () {
        ;-1 == n.execution_timer_id &&
          (window.requestAnimationFrame(e),
          n.onBeforeStep?.(),
          n.runStep(1, !n.catch_errors),
          n.onAfterStep?.())
      }, 'on_frame')
      ;(this.execution_timer_id = -1), e()
    } else
      this.execution_timer_id = setInterval(function () {
        n.onBeforeStep?.(), n.runStep(1, !n.catch_errors), n.onAfterStep?.()
      }, t)
  }
  stop() {
    this.status != e.STATUS_STOPPED &&
      ((this.status = e.STATUS_STOPPED),
      this.onStopEvent?.(),
      null != this.execution_timer_id &&
        (-1 != this.execution_timer_id &&
          clearInterval(this.execution_timer_id),
        (this.execution_timer_id = null)),
      this.sendEventToAllNodes('onStop'))
  }
  runStep(e, t, n) {
    e = e || 1
    const o = LiteGraph.getTime()
    this.globaltime = 0.001 * (o - this.starttime)
    const i = this._nodes_executable ? this._nodes_executable : this._nodes
    if (!i) return
    if (((n = n || i.length), t)) {
      for (let t = 0; t < e; t++) {
        for (let e = 0; e < n; ++e) {
          const t = i[e]
          t.mode == LGraphEventMode.ALWAYS && t.onExecute && t.doExecute?.()
        }
        ;(this.fixedtime += this.fixedtime_lapse), this.onExecuteStep?.()
      }
      this.onAfterExecute?.()
    } else
      try {
        for (let t = 0; t < e; t++) {
          for (let e = 0; e < n; ++e) {
            const t = i[e]
            t.mode == LGraphEventMode.ALWAYS && t.onExecute?.()
          }
          ;(this.fixedtime += this.fixedtime_lapse), this.onExecuteStep?.()
        }
        this.onAfterExecute?.(), (this.errors_in_execution = !1)
      } catch (s) {
        if (((this.errors_in_execution = !0), LiteGraph.throw_errors)) throw s
        LiteGraph.debug && console.log('Error during execution: ' + s),
          this.stop()
      }
    const r = LiteGraph.getTime()
    let a = r - o
    0 == a && (a = 1),
      (this.execution_time = 0.001 * a),
      (this.globaltime += 0.001 * a),
      (this.iteration += 1),
      (this.elapsed_time = 0.001 * (r - this.last_update_time)),
      (this.last_update_time = r),
      (this.nodes_executing = []),
      (this.nodes_actioning = []),
      (this.nodes_executedAction = [])
  }
  updateExecutionOrder() {
    ;(this._nodes_in_order = this.computeExecutionOrder(!1)),
      (this._nodes_executable = [])
    for (let e = 0; e < this._nodes_in_order.length; ++e)
      this._nodes_in_order[e].onExecute &&
        this._nodes_executable.push(this._nodes_in_order[e])
  }
  computeExecutionOrder(e, t) {
    const n = [],
      o = [],
      i = {},
      r = {},
      a = {}
    for (let l = 0, c = this._nodes.length; l < c; ++l) {
      const n = this._nodes[l]
      if (e && !n.onExecute) continue
      i[n.id] = n
      let r = 0
      if (n.inputs)
        for (let e = 0, t = n.inputs.length; e < t; e++)
          null != n.inputs[e]?.link && (r += 1)
      0 == r
        ? (o.push(n), t && (n._level = 1))
        : (t && (n._level = 0), (a[n.id] = r))
    }
    for (;;) {
      const e = o.shift()
      if (void 0 === e) break
      if ((n.push(e), delete i[e.id], e.outputs))
        for (let n = 0; n < e.outputs.length; n++) {
          const i = e.outputs[n]
          if (null != i?.links && 0 != i.links.length)
            for (let n = 0; n < i.links.length; n++) {
              const s = i.links[n],
                l = this._links.get(s)
              if (!l) continue
              if (r[l.id]) continue
              const c = this.getNodeById(l.target_id)
              null != c
                ? (t &&
                    (!c._level || c._level <= e._level) &&
                    (c._level = e._level + 1),
                  (r[l.id] = !0),
                  (a[c.id] -= 1),
                  0 == a[c.id] && o.push(c))
                : (r[l.id] = !0)
            }
        }
    }
    for (const l in i) n.push(i[l])
    function s(e) {
      const t = e.length
      for (let n = 0; n < t; ++n) e[n].order = n
    }
    return (
      n.length != this._nodes.length &&
        LiteGraph.debug &&
        console.warn('something went wrong, nodes missing'),
      n.length,
      __name(s, 'setOrder'),
      s(n),
      n.sort(function (e, t) {
        const n = e.constructor.priority || e.priority || 0,
          o = t.constructor.priority || t.priority || 0
        return n == o ? e.order - t.order : n - o
      }),
      s(n),
      n
    )
  }
  getAncestors(e) {
    const t = [],
      n = [e],
      o = {}
    for (; n.length; ) {
      const i = n.shift()
      if (i?.inputs) {
        o[i.id] || i == e || ((o[i.id] = !0), t.push(i))
        for (let e = 0; e < i.inputs.length; ++e) {
          const o = i.getInputNode(e)
          o && -1 == t.indexOf(o) && n.push(o)
        }
      }
    }
    return (
      t.sort(function (e, t) {
        return e.order - t.order
      }),
      t
    )
  }
  arrange(e, t) {
    e = e || 100
    const n = this.computeExecutionOrder(!1, !0),
      o = []
    for (let r = 0; r < n.length; ++r) {
      const e = n[r],
        t = e._level || 1
      ;(o[t] ||= []), o[t].push(e)
    }
    let i = e
    for (let r = 0; r < o.length; ++r) {
      const n = o[r]
      if (!n) continue
      let a = 100,
        s = e + LiteGraph.NODE_TITLE_HEIGHT
      for (let o = 0; o < n.length; ++o) {
        const r = n[o]
        ;(r.pos[0] = t == LiteGraph.VERTICAL_LAYOUT ? s : i),
          (r.pos[1] = t == LiteGraph.VERTICAL_LAYOUT ? i : s)
        const l = t == LiteGraph.VERTICAL_LAYOUT ? 1 : 0
        r.size[l] > a && (a = r.size[l])
        const c = t == LiteGraph.VERTICAL_LAYOUT ? 0 : 1
        s += r.size[c] + e + LiteGraph.NODE_TITLE_HEIGHT
      }
      i += a + e
    }
    this.setDirtyCanvas(!0, !0)
  }
  getTime() {
    return this.globaltime
  }
  getFixedTime() {
    return this.fixedtime
  }
  getElapsedTime() {
    return this.elapsed_time
  }
  sendEventToAllNodes(e, t, n) {
    n = n || LGraphEventMode.ALWAYS
    const o = this._nodes_in_order ? this._nodes_in_order : this._nodes
    if (o)
      for (let i = 0, r = o.length; i < r; ++i) {
        const r = o[i]
        r.constructor !== LiteGraph.Subgraph || 'onExecute' == e
          ? r[e] &&
            r.mode == n &&
            (void 0 === t
              ? r[e]()
              : t && t.constructor === Array
                ? r[e].apply(r, t)
                : r[e](t))
          : r.mode == n && r.sendEventToAllNodes(e, t, n)
      }
  }
  canvasAction(e) {
    this.list_of_graphcanvas?.forEach(e)
  }
  sendActionToCanvas(e, t) {
    if (this.list_of_graphcanvas)
      for (let n = 0; n < this.list_of_graphcanvas.length; ++n) {
        const o = this.list_of_graphcanvas[n]
        o[e]?.apply(o, t)
      }
  }
  add(e, t) {
    if (!e) return
    const { state: n } = this
    if (LiteGraph.alwaysSnapToGrid) {
      const t = this.getSnapToGridSize()
      t && e.snapToGrid(t)
    }
    if (e instanceof LGraphGroup)
      return (
        (null != e.id && -1 !== e.id) || (e.id = ++n.lastGroupId),
        e.id > n.lastGroupId && (n.lastGroupId = e.id),
        this._groups.push(e),
        this.setDirtyCanvas(!0),
        this.change(),
        (e.graph = this),
        void this._version++
      )
    if (
      (-1 != e.id &&
        null != this._nodes_by_id[e.id] &&
        (console.warn(
          'LiteGraph: there is already a node with this ID, changing it'
        ),
        (e.id = LiteGraph.use_uuids ? LiteGraph.uuidv4() : ++n.lastNodeId)),
      this._nodes.length >= LiteGraph.MAX_NUMBER_OF_NODES)
    )
      throw 'LiteGraph: max number of nodes in a graph reached'
    return (
      LiteGraph.use_uuids
        ? (null != e.id && -1 != e.id) || (e.id = LiteGraph.uuidv4())
        : null == e.id || -1 == e.id
          ? (e.id = ++n.lastNodeId)
          : 'number' == typeof e.id &&
            n.lastNodeId < e.id &&
            (n.lastNodeId = e.id),
      (e.graph = this),
      this._version++,
      this._nodes.push(e),
      (this._nodes_by_id[e.id] = e),
      e.onAdded?.(this),
      this.config.align_to_grid && e.alignToGrid(),
      t || this.updateExecutionOrder(),
      this.onNodeAdded?.(e),
      this.setDirtyCanvas(!0),
      this.change(),
      e
    )
  }
  remove(e) {
    if (e instanceof LGraphGroup) {
      const t = this._groups.indexOf(e)
      return (
        -1 != t && this._groups.splice(t, 1),
        (e.graph = null),
        this._version++,
        this.setDirtyCanvas(!0, !0),
        void this.change()
      )
    }
    if (null == this._nodes_by_id[e.id]) return
    if (e.ignore_remove) return
    if ((this.beforeChange(), e.inputs))
      for (let n = 0; n < e.inputs.length; n++) {
        null != e.inputs[n].link && e.disconnectInput(n)
      }
    if (e.outputs)
      for (let n = 0; n < e.outputs.length; n++) {
        const t = e.outputs[n]
        t.links?.length && e.disconnectOutput(n)
      }
    if (
      (e.onRemoved?.(),
      (e.graph = null),
      this._version++,
      this.list_of_graphcanvas)
    )
      for (let n = 0; n < this.list_of_graphcanvas.length; ++n) {
        const t = this.list_of_graphcanvas[n]
        t.selected_nodes[e.id] && delete t.selected_nodes[e.id]
      }
    const t = this._nodes.indexOf(e)
    ;-1 != t && this._nodes.splice(t, 1),
      delete this._nodes_by_id[e.id],
      this.onNodeRemoved?.(e),
      this.canvasAction((e) => e.checkPanels()),
      this.setDirtyCanvas(!0, !0),
      this.afterChange(),
      this.change(),
      this.updateExecutionOrder()
  }
  getNodeById(e) {
    return null != e ? this._nodes_by_id[e] : null
  }
  findNodesByClass(e, t) {
    ;(t = t || []).length = 0
    for (let n = 0, o = this._nodes.length; n < o; ++n)
      this._nodes[n].constructor === e && t.push(this._nodes[n])
    return t
  }
  findNodesByType(e, t) {
    const n = e.toLowerCase()
    ;(t = t || []).length = 0
    for (let o = 0, i = this._nodes.length; o < i; ++o)
      this._nodes[o].type?.toLowerCase() == n && t.push(this._nodes[o])
    return t
  }
  findNodeByTitle(e) {
    for (let t = 0, n = this._nodes.length; t < n; ++t)
      if (this._nodes[t].title == e) return this._nodes[t]
    return null
  }
  findNodesByTitle(e) {
    const t = []
    for (let n = 0, o = this._nodes.length; n < o; ++n)
      this._nodes[n].title == e && t.push(this._nodes[n])
    return t
  }
  getNodeOnPos(e, t, n) {
    const o = n || this._nodes
    let i = o.length
    for (; --i >= 0; ) {
      const n = o[i]
      if (n.isPointInside(e, t)) return n
    }
    return null
  }
  getGroupOnPos(e, t) {
    return this._groups.toReversed().find((n) => n.isPointInside(e, t))
  }
  getGroupTitlebarOnPos(e, t) {
    return this._groups.toReversed().find((n) => n.isPointInTitlebar(e, t))
  }
  getRerouteOnPos(e, t) {
    for (const n of this.reroutes.values()) {
      const o = n.pos
      if (isSortaInsideOctagon(e - o[0], t - o[1], 20)) return n
    }
  }
  snapToGrid(e) {
    const t = this.getSnapToGridSize()
    t &&
      getAllNestedItems(e).forEach((e) => {
        e.pinned || e.snapToGrid(t)
      })
  }
  getSnapToGridSize() {
    return LiteGraph.alwaysSnapToGrid
      ? LiteGraph.CANVAS_GRID_SIZE || 1
      : LiteGraph.CANVAS_GRID_SIZE
  }
  checkNodeTypes() {
    for (let e = 0; e < this._nodes.length; e++) {
      const t = this._nodes[e],
        n = LiteGraph.registered_node_types[t.type]
      if (t.constructor == n) continue
      console.log('node being replaced by newer version: ' + t.type)
      const o = LiteGraph.createNode(t.type)
      ;(this._nodes[e] = o),
        o.configure(t.serialize()),
        (o.graph = this),
        (this._nodes_by_id[o.id] = o),
        t.inputs && (o.inputs = t.inputs.concat()),
        t.outputs && (o.outputs = t.outputs.concat())
    }
    this.updateExecutionOrder()
  }
  onAction(e, t, n) {
    this._input_nodes = this.findNodesByClass(
      LiteGraph.GraphInput,
      this._input_nodes
    )
    for (let o = 0; o < this._input_nodes.length; ++o) {
      const i = this._input_nodes[o]
      if (i.properties.name == e) {
        i.actionDo(e, t, n)
        break
      }
    }
  }
  trigger(e, t) {
    this.onTrigger?.(e, t)
  }
  addInput(e, t, n) {
    this.inputs[e] ||
      (this.beforeChange(),
      (this.inputs[e] = { name: e, type: t, value: n }),
      this._version++,
      this.afterChange(),
      this.onInputAdded?.(e, t),
      this.onInputsOutputsChange?.())
  }
  setInputData(e, t) {
    const n = this.inputs[e]
    n && (n.value = t)
  }
  getInputData(e) {
    const t = this.inputs[e]
    return t ? t.value : null
  }
  renameInput(e, t) {
    if (t != e) {
      if (!this.inputs[e]) return !1
      if (this.inputs[t])
        return console.error('there is already one input with that name'), !1
      ;(this.inputs[t] = this.inputs[e]),
        delete this.inputs[e],
        this._version++,
        this.onInputRenamed?.(e, t),
        this.onInputsOutputsChange?.()
    }
  }
  changeInputType(e, t) {
    if (!this.inputs[e]) return !1
    ;(this.inputs[e].type &&
      String(this.inputs[e].type).toLowerCase() == String(t).toLowerCase()) ||
      ((this.inputs[e].type = t),
      this._version++,
      this.onInputTypeChanged?.(e, t))
  }
  removeInput(e) {
    return (
      !!this.inputs[e] &&
      (delete this.inputs[e],
      this._version++,
      this.onInputRemoved?.(e),
      this.onInputsOutputsChange?.(),
      !0)
    )
  }
  addOutput(e, t, n) {
    ;(this.outputs[e] = { name: e, type: t, value: n }),
      this._version++,
      this.onOutputAdded?.(e, t),
      this.onInputsOutputsChange?.()
  }
  setOutputData(e, t) {
    const n = this.outputs[e]
    n && (n.value = t)
  }
  getOutputData(e) {
    const t = this.outputs[e]
    return t ? t.value : null
  }
  renameOutput(e, t) {
    return (
      !!this.outputs[e] &&
      (this.outputs[t]
        ? (console.error('there is already one output with that name'), !1)
        : ((this.outputs[t] = this.outputs[e]),
          delete this.outputs[e],
          this._version++,
          this.onOutputRenamed?.(e, t),
          void this.onInputsOutputsChange?.()))
    )
  }
  changeOutputType(e, t) {
    if (!this.outputs[e]) return !1
    ;(this.outputs[e].type &&
      String(this.outputs[e].type).toLowerCase() == String(t).toLowerCase()) ||
      ((this.outputs[e].type = t),
      this._version++,
      this.onOutputTypeChanged?.(e, t))
  }
  removeOutput(e) {
    return (
      !!this.outputs[e] &&
      (delete this.outputs[e],
      this._version++,
      this.onOutputRemoved?.(e),
      this.onInputsOutputsChange?.(),
      !0)
    )
  }
  triggerInput(e, t) {
    const n = this.findNodesByTitle(e)
    for (let o = 0; o < n.length; ++o) n[o].onTrigger(t)
  }
  setCallback(e, t) {
    const n = this.findNodesByTitle(e)
    for (let o = 0; o < n.length; ++o) n[o].setTrigger(t)
  }
  beforeChange(e) {
    this.onBeforeChange?.(this, e),
      this.canvasAction((e) => e.onBeforeChange?.(this))
  }
  afterChange(e) {
    this.onAfterChange?.(this, e),
      this.canvasAction((e) => e.onAfterChange?.(this))
  }
  connectionChange(e) {
    this.updateExecutionOrder(),
      this.onConnectionChange?.(e),
      this._version++,
      this.canvasAction((e) => e.onConnectionChange?.())
  }
  clearTriggeredSlots() {
    for (const e of this._links.values())
      e && e._last_time && (e._last_time = 0)
  }
  change() {
    LiteGraph.debug && console.log('Graph changed'),
      this.canvasAction((e) => e.setDirty(!0, !0)),
      this.on_change?.(this)
  }
  setDirtyCanvas(e, t) {
    this.canvasAction((n) => n.setDirty(e, t))
  }
  setReroute({ id: e, parentId: t, pos: n, linkIds: o }) {
    ;(e ??= ++this.state.lastRerouteId),
      e > this.state.lastRerouteId && (this.state.lastRerouteId = e)
    const i = this.reroutes.get(e) ?? new Reroute(e, this)
    return i.update(t, n, o), this.reroutes.set(e, i), i
  }
  createReroute(e, t) {
    const n = ++this.state.lastRerouteId,
      o = t instanceof Reroute ? t.linkIds : [t.id],
      i = new Reroute(n, this, e, t.parentId, o)
    this.reroutes.set(n, i)
    for (const r of o) {
      const e = this._links.get(r)
      e &&
        (e.parentId === t.parentId && (e.parentId = n),
        LLink.getReroutes(this, e)
          ?.filter((e) => e.parentId === t.parentId)
          .forEach((e) => (e.parentId = n)))
    }
    return i
  }
  removeReroute(e) {
    const { reroutes: t } = this,
      n = t.get(e)
    if (!n) return
    const { parentId: o, linkIds: i } = n
    for (const r of t.values()) r.parentId === e && (r.parentId = o)
    for (const r of i) {
      const t = this._links.get(r)
      t && t.parentId === e && (t.parentId = o)
    }
    t.delete(e), this.setDirtyCanvas(!1, !0)
  }
  removeLink(e) {
    const t = this._links.get(e)
    if (!t) return
    const n = this.getNodeById(t.target_id)
    n?.disconnectInput(t.target_slot), t.disconnect(this)
  }
  serialize(e) {
    const {
        config: t,
        state: n,
        groups: o,
        nodes: i,
        reroutes: r,
        extra: a
      } = this.asSerialisable(e),
      s = [...this._links.values()],
      l = s.map((e) => e.serialize())
    return (
      r.length &&
        ((a.reroutes = r),
        (a.linkExtensions = s
          .filter((e) => void 0 !== e.parentId)
          .map((e) => ({ id: e.id, parentId: e.parentId })))),
      {
        last_node_id: n.lastNodeId,
        last_link_id: n.lastLinkId,
        nodes: i,
        links: l,
        groups: o,
        config: t,
        extra: a,
        version: LiteGraph.VERSION
      }
    )
  }
  asSerialisable(t) {
    const { config: n, state: o, extra: i } = this,
      r = (
        !LiteGraph.use_uuids && t?.sortNodes
          ? [...this._nodes].sort((e, t) => e.id - t.id)
          : this._nodes
      ).map((e) => e.serialize()),
      a = this._groups.map((e) => e.serialize()),
      s = [...this._links.values()].map((e) => e.asSerialisable()),
      l = [...this.reroutes.values()].map((e) => e.asSerialisable()),
      c = {
        version: e.serialisedSchemaVersion,
        config: n,
        state: o,
        groups: a,
        nodes: r,
        links: s,
        reroutes: l,
        extra: i
      }
    return this.onSerialize?.(c), c
  }
  configure(e, t) {
    if (!e) return
    t || this.clear()
    const { extra: n } = e
    let o
    if (0.4 === e.version) {
      if (Array.isArray(e.links))
        for (const t of e.links) {
          const e = LLink.createFromArray(t)
          this._links.set(e.id, e)
        }
      if (Array.isArray(n?.linkExtensions))
        for (const e of n.linkExtensions) {
          const t = this._links.get(e.id)
          t && (t.parentId = e.parentId)
        }
      o = n?.reroutes
    } else {
      if (e.state) {
        const {
          state: {
            lastGroupId: t,
            lastLinkId: n,
            lastNodeId: o,
            lastRerouteId: i
          }
        } = e
        null != t && (this.state.lastGroupId = t),
          null != n && (this.state.lastLinkId = n),
          null != o && (this.state.lastNodeId = o),
          null != i && (this.state.lastRerouteId = i)
      }
      if (Array.isArray(e.links))
        for (const t of e.links) {
          const e = LLink.create(t)
          this._links.set(e.id, e)
        }
      o = e.reroutes
    }
    if (Array.isArray(o))
      for (const a of o) {
        this.setReroute(a).validateLinks(this._links) ||
          this.reroutes.delete(a.id)
      }
    const i = e.nodes
    for (const a in e)
      'nodes' != a &&
        'groups' != a &&
        'links' != a &&
        'state' !== a &&
        'reroutes' !== a &&
        (this[a] = e[a])
    let r = !1
    if (((this._nodes = []), i)) {
      for (let e = 0, t = i.length; e < t; ++e) {
        const t = i[e]
        let n = LiteGraph.createNode(t.type, t.title)
        n ||
          (LiteGraph.debug &&
            console.log('Node not found or has errors: ' + t.type),
          (n = new LGraphNode(void 0)),
          (n.last_serialization = t),
          (n.has_errors = !0),
          (r = !0)),
          (n.id = t.id),
          this.add(n, !0)
      }
      for (let e = 0, t = i.length; e < t; ++e) {
        const t = i[e],
          n = this.getNodeById(t.id)
        n?.configure(t)
      }
    }
    if (((this._groups.length = 0), e.groups))
      for (let a = 0; a < e.groups.length; ++a) {
        const t = new LiteGraph.LGraphGroup()
        t.configure(e.groups[a]), this.add(t)
      }
    return (
      this.updateExecutionOrder(),
      (this.extra = e.extra || {}),
      this.onConfigure?.(e),
      this._version++,
      this.setDirtyCanvas(!0, !0),
      r
    )
  }
  load(e, t) {
    const n = this
    if (e instanceof Blob || e instanceof File) {
      const o = new FileReader()
      return (
        o.addEventListener('load', function (e) {
          const o = JSON.parse(e.target.result.toString())
          n.configure(o), t?.()
        }),
        void o.readAsText(e)
      )
    }
    const o = new XMLHttpRequest()
    o.open('GET', e, !0),
      o.send(null),
      (o.onload = function () {
        if (200 !== o.status)
          return void console.error(
            'Error loading graph:',
            o.status,
            o.response
          )
        const e = JSON.parse(o.response)
        n.configure(e), t?.()
      }),
      (o.onerror = function (e) {
        console.error('Error loading graph:', e)
      })
  }
  onNodeTrace(e, t) {}
}
class ContextMenu {
  static {
    __name(this, 'ContextMenu')
  }
  options
  parentMenu
  root
  current_submenu
  lock
  constructor(e, t) {
    ;(t ||= {}), (this.options = t)
    const n = t.parentMenu
    n &&
      (n instanceof ContextMenu
        ? ((this.parentMenu = n),
          (this.parentMenu.lock = !0),
          (this.parentMenu.current_submenu = this))
        : (console.error(
            'parentMenu must be of class ContextMenu, ignoring it'
          ),
          (t.parentMenu = null)),
      'dark' === n.options?.className && (t.className = 'dark'))
    const o = t.event ? t.event.constructor.name : null
    'MouseEvent' !== o &&
      'CustomEvent' !== o &&
      'PointerEvent' !== o &&
      (console.error(
        `Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it. (${o})`
      ),
      (t.event = null))
    const i = document.createElement('div')
    let r = 'litegraph litecontextmenu litemenubar-panel'
    function a(e) {
      const n = parseInt(i.style.top)
      return (
        (i.style.top = (n + e.deltaY * t.scroll_speed).toFixed() + 'px'),
        e.preventDefault(),
        !0
      )
    }
    if (
      (t.className && (r += ' ' + t.className),
      (i.className = r),
      (i.style.minWidth = '100'),
      (i.style.minHeight = '100'),
      (i.style.pointerEvents = 'none'),
      setTimeout(function () {
        i.style.pointerEvents = 'auto'
      }, 100),
      LiteGraph.pointerListenerAdd(
        i,
        'up',
        function (e) {
          return e.preventDefault(), !0
        },
        !0
      ),
      i.addEventListener(
        'contextmenu',
        function (e) {
          return 2 != e.button || e.preventDefault(), !1
        },
        !0
      ),
      LiteGraph.pointerListenerAdd(
        i,
        'down',
        (e) => {
          if (2 == e.button) return this.close(), e.preventDefault(), !0
        },
        !0
      ),
      __name(a, 'on_mouse_wheel'),
      t.scroll_speed || (t.scroll_speed = 0.1),
      i.addEventListener('wheel', a, !0),
      (this.root = i),
      t.title)
    ) {
      const e = document.createElement('div')
      ;(e.className = 'litemenu-title'),
        (e.innerHTML = t.title),
        i.appendChild(e)
    }
    for (let d = 0; d < e.length; d++) {
      const n = e[d]
      let o = Array.isArray(e) ? n : String(d)
      'string' != typeof o &&
        (o = null != o ? (void 0 === o.content ? String(o) : o.content) : o),
        this.addItem(o, n, t)
    }
    LiteGraph.pointerListenerAdd(i, 'enter', function () {
      i.closing_timer && clearTimeout(i.closing_timer)
    })
    const s = (t.event?.target).ownerDocument || document
    s.fullscreenElement
      ? s.fullscreenElement.appendChild(i)
      : s.body.appendChild(i)
    let l = t.left || 0,
      c = t.top || 0
    if (t.event) {
      if (
        ((l = t.event.clientX - 10),
        (c = t.event.clientY - 10),
        t.title && (c -= 20),
        n)
      ) {
        const e = n.root.getBoundingClientRect()
        l = e.left + e.width
      }
      const e = document.body.getBoundingClientRect(),
        o = i.getBoundingClientRect()
      0 == e.height &&
        console.error(
          'document.body height is 0. That is dangerous, set html,body { height: 100%; }'
        ),
        e.width && l > e.width - o.width - 10 && (l = e.width - o.width - 10),
        e.height &&
          c > e.height - o.height - 10 &&
          (c = e.height - o.height - 10)
    }
    ;(i.style.left = l + 'px'),
      (i.style.top = c + 'px'),
      t.scale && (i.style.transform = `scale(${t.scale})`)
  }
  addItem(e, t, n) {
    n ||= {}
    const o = document.createElement('div')
    o.className = 'litemenu-entry submenu'
    let i = !1
    null === t
      ? o.classList.add('separator')
      : ('string' == typeof t
          ? (o.innerHTML = e)
          : ((o.innerHTML = t?.title ?? e),
            t.disabled &&
              ((i = !0),
              o.classList.add('disabled'),
              o.setAttribute('aria-disabled', 'true')),
            (t.submenu || t.has_submenu) &&
              (o.classList.add('has_submenu'),
              o.setAttribute('aria-haspopup', 'true'),
              o.setAttribute('aria-expanded', 'false')),
            t.className && (o.className += ' ' + t.className)),
        (o.value = t),
        o.setAttribute('role', 'menuitem'),
        'function' == typeof t
          ? ((o.dataset.value = e), (o.onclick_callback = t))
          : (o.dataset.value = String(t))),
      this.root.appendChild(o),
      i || o.addEventListener('click', l),
      !i && n.autoopen && LiteGraph.pointerListenerAdd(o, 'enter', a)
    const r = __name(() => {
      const e = this.root.querySelectorAll('div.litemenu-entry.has_submenu')
      if (e)
        for (let t = 0; t < e.length; t++)
          e[t].setAttribute('aria-expanded', 'false')
      o.setAttribute('aria-expanded', 'true')
    }, 'setAriaExpanded')
    function a(e) {
      const t = this.value
      t && t.has_submenu && (l.call(this, e), r())
    }
    __name(a, 'inner_over')
    const s = this
    function l(e) {
      const t = this.value
      let o = !0
      if (
        (s.current_submenu?.close(e),
        (t?.has_submenu || t?.submenu) && r(),
        n.callback)
      ) {
        !0 === n.callback.call(this, t, n, e, s, n.node) && (o = !1)
      }
      if ('object' == typeof t) {
        if (t.callback && !n.ignore_item_callbacks && !0 !== t.disabled) {
          !0 === t.callback.call(this, t, n, e, s, n.extra) && (o = !1)
        }
        if (t.submenu) {
          if (!t.submenu.options) throw 'ContextMenu submenu needs options'
          new s.constructor(t.submenu.options, {
            callback: t.submenu.callback,
            event: e,
            parentMenu: s,
            ignore_item_callbacks: t.submenu.ignore_item_callbacks,
            title: t.submenu.title,
            extra: t.submenu.extra,
            autoopen: n.autoopen
          }),
            (o = !1)
        }
      }
      o && !s.lock && s.close()
    }
    return __name(l, 'inner_onclick'), o
  }
  close(e, t) {
    this.root.parentNode?.removeChild(this.root),
      this.parentMenu &&
        !t &&
        ((this.parentMenu.lock = !1),
        (this.parentMenu.current_submenu = null),
        void 0 === e
          ? this.parentMenu.close()
          : e &&
            !ContextMenu.isCursorOverElement(e, this.parentMenu.root) &&
            ContextMenu.trigger(
              this.parentMenu.root,
              LiteGraph.pointerevents_method + 'leave',
              e
            )),
      this.current_submenu?.close(e, !0),
      this.root.closing_timer && clearTimeout(this.root.closing_timer)
  }
  static trigger(e, t, n, o) {
    const i = document.createEvent('CustomEvent')
    return (
      i.initCustomEvent(t, !0, !0, n),
      (i.srcElement = o),
      e.dispatchEvent
        ? e.dispatchEvent(i)
        : e.__events && e.__events.dispatchEvent(i),
      i
    )
  }
  getTopMenu() {
    return this.options.parentMenu ? this.options.parentMenu.getTopMenu() : this
  }
  getFirstEvent() {
    return this.options.parentMenu
      ? this.options.parentMenu.getFirstEvent()
      : this.options.event
  }
  static isCursorOverElement(e, t) {
    const n = e.clientX,
      o = e.clientY,
      i = t.getBoundingClientRect()
    return (
      !!i &&
      o > i.top &&
      o < i.top + i.height &&
      n > i.left &&
      n < i.left + i.width
    )
  }
}
class CurveEditor {
  static {
    __name(this, 'CurveEditor')
  }
  points
  selected
  nearest
  size
  must_update
  margin
  _nearest
  constructor(e) {
    ;(this.points = e),
      (this.selected = -1),
      (this.nearest = -1),
      (this.size = null),
      (this.must_update = !0),
      (this.margin = 5)
  }
  static sampleCurve(e, t) {
    if (t) {
      for (let n = 0; n < t.length - 1; ++n) {
        const o = t[n],
          i = t[n + 1]
        if (i[0] < e) continue
        const r = i[0] - o[0]
        if (Math.abs(r) < 1e-5) return o[1]
        const a = (e - o[0]) / r
        return o[1] * (1 - a) + i[1] * a
      }
      return 0
    }
  }
  draw(e, t, n, o, i, r = !1) {
    const a = this.points
    if (!a) return
    this.size = t
    const s = t[0] - 2 * this.margin,
      l = t[1] - 2 * this.margin
    ;(i = i || '#666'),
      e.save(),
      e.translate(this.margin, this.margin),
      o &&
        ((e.fillStyle = '#111'),
        e.fillRect(0, 0, s, l),
        (e.fillStyle = '#222'),
        e.fillRect(0.5 * s, 0, 1, l),
        (e.strokeStyle = '#333'),
        e.strokeRect(0, 0, s, l)),
      (e.strokeStyle = i),
      r && (e.globalAlpha = 0.5),
      e.beginPath()
    for (let c = 0; c < a.length; ++c) {
      const t = a[c]
      e.lineTo(t[0] * s, (1 - t[1]) * l)
    }
    if ((e.stroke(), (e.globalAlpha = 1), !r))
      for (let c = 0; c < a.length; ++c) {
        const t = a[c]
        ;(e.fillStyle =
          this.selected == c ? '#FFF' : this.nearest == c ? '#DDD' : '#AAA'),
          e.beginPath(),
          e.arc(t[0] * s, (1 - t[1]) * l, 2, 0, 2 * Math.PI),
          e.fill()
      }
    e.restore()
  }
  onMouseDown(e, t) {
    const n = this.points
    if (!n) return
    if (e[1] < 0) return
    const o = this.size[0] - 2 * this.margin,
      i = this.size[1] - 2 * this.margin,
      r = e[0] - this.margin,
      a = e[1] - this.margin,
      s = [r, a],
      l = 30 / t.ds.scale
    if (((this.selected = this.getCloserPoint(s, l)), -1 == this.selected)) {
      const e = [r / o, 1 - a / i]
      n.push(e),
        n.sort(function (e, t) {
          return e[0] - t[0]
        }),
        (this.selected = n.indexOf(e)),
        (this.must_update = !0)
    }
    return -1 != this.selected || void 0
  }
  onMouseMove(e, t) {
    const n = this.points
    if (!n) return
    const o = this.selected
    if (o < 0) return
    const i = (e[0] - this.margin) / (this.size[0] - 2 * this.margin),
      r = (e[1] - this.margin) / (this.size[1] - 2 * this.margin),
      a = [e[0] - this.margin, e[1] - this.margin],
      s = 30 / t.ds.scale
    this._nearest = this.getCloserPoint(a, s)
    const l = n[o]
    if (l) {
      const t = 0 == o || o == n.length - 1
      if (
        !t &&
        (e[0] < -10 ||
          e[0] > this.size[0] + 10 ||
          e[1] < -10 ||
          e[1] > this.size[1] + 10)
      )
        return n.splice(o, 1), void (this.selected = -1)
      ;(l[0] = t ? (0 == o ? 0 : 1) : clamp$1(i, 0, 1)),
        (l[1] = 1 - clamp$1(r, 0, 1)),
        n.sort(function (e, t) {
          return e[0] - t[0]
        }),
        (this.selected = n.indexOf(l)),
        (this.must_update = !0)
    }
  }
  onMouseUp() {
    return (this.selected = -1), !1
  }
  getCloserPoint(e, t) {
    const n = this.points
    if (!n) return -1
    t = t || 30
    const o = this.size[0] - 2 * this.margin,
      i = this.size[1] - 2 * this.margin,
      r = n.length,
      a = [0, 0]
    let s = 1e6,
      l = -1
    for (let c = 0; c < r; ++c) {
      const r = n[c]
      ;(a[0] = r[0] * o), (a[1] = (1 - r[1]) * i)
      const d = distance(e, a)
      d > s || d > t || ((l = c), (s = d))
    }
    return l
  }
}
class LiteGraphGlobal {
  static {
    __name(this, 'LiteGraphGlobal')
  }
  SlotShape = SlotShape
  SlotDirection = SlotDirection
  SlotType = SlotType
  LabelPosition = LabelPosition
  VERSION = 0.4
  CANVAS_GRID_SIZE = 10
  NODE_TITLE_HEIGHT = 30
  NODE_TITLE_TEXT_Y = 20
  NODE_SLOT_HEIGHT = 20
  NODE_WIDGET_HEIGHT = 20
  NODE_WIDTH = 140
  NODE_MIN_WIDTH = 50
  NODE_COLLAPSED_RADIUS = 10
  NODE_COLLAPSED_WIDTH = 80
  NODE_TITLE_COLOR = '#999'
  NODE_SELECTED_TITLE_COLOR = '#FFF'
  NODE_TEXT_SIZE = 14
  NODE_TEXT_COLOR = '#AAA'
  NODE_TEXT_HIGHLIGHT_COLOR = '#EEE'
  NODE_SUBTEXT_SIZE = 12
  NODE_DEFAULT_COLOR = '#333'
  NODE_DEFAULT_BGCOLOR = '#353535'
  NODE_DEFAULT_BOXCOLOR = '#666'
  NODE_DEFAULT_SHAPE = 'box'
  NODE_BOX_OUTLINE_COLOR = '#FFF'
  NODE_ERROR_COLOUR = '#E00'
  DEFAULT_SHADOW_COLOR = 'rgba(0,0,0,0.5)'
  DEFAULT_GROUP_FONT = 24
  DEFAULT_GROUP_FONT_SIZE
  WIDGET_BGCOLOR = '#222'
  WIDGET_OUTLINE_COLOR = '#666'
  WIDGET_ADVANCED_OUTLINE_COLOR = 'rgba(56, 139, 253, 0.8)'
  WIDGET_TEXT_COLOR = '#DDD'
  WIDGET_SECONDARY_TEXT_COLOR = '#999'
  LINK_COLOR = '#9A9'
  static DEFAULT_EVENT_LINK_COLOR = '#A86'
  EVENT_LINK_COLOR = '#A86'
  CONNECTING_LINK_COLOR = '#AFA'
  MAX_NUMBER_OF_NODES = 1e4
  DEFAULT_POSITION = [100, 100]
  VALID_SHAPES = ['default', 'box', 'round', 'card']
  BOX_SHAPE = RenderShape.BOX
  ROUND_SHAPE = RenderShape.ROUND
  CIRCLE_SHAPE = RenderShape.CIRCLE
  CARD_SHAPE = RenderShape.CARD
  ARROW_SHAPE = RenderShape.ARROW
  GRID_SHAPE = RenderShape.GRID
  INPUT = NodeSlotType.INPUT
  OUTPUT = NodeSlotType.OUTPUT
  EVENT = -1
  ACTION = -1
  NODE_MODES = ['Always', 'On Event', 'Never', 'On Trigger']
  NODE_MODES_COLORS = ['#666', '#422', '#333', '#224', '#626']
  ALWAYS = LGraphEventMode.ALWAYS
  ON_EVENT = LGraphEventMode.ON_EVENT
  NEVER = LGraphEventMode.NEVER
  ON_TRIGGER = LGraphEventMode.ON_TRIGGER
  UP = LinkDirection.UP
  DOWN = LinkDirection.DOWN
  LEFT = LinkDirection.LEFT
  RIGHT = LinkDirection.RIGHT
  CENTER = LinkDirection.CENTER
  LINK_RENDER_MODES = ['Straight', 'Linear', 'Spline']
  HIDDEN_LINK = LinkRenderType.HIDDEN_LINK
  STRAIGHT_LINK = LinkRenderType.STRAIGHT_LINK
  LINEAR_LINK = LinkRenderType.LINEAR_LINK
  SPLINE_LINK = LinkRenderType.SPLINE_LINK
  NORMAL_TITLE = TitleMode.NORMAL_TITLE
  NO_TITLE = TitleMode.NO_TITLE
  TRANSPARENT_TITLE = TitleMode.TRANSPARENT_TITLE
  AUTOHIDE_TITLE = TitleMode.AUTOHIDE_TITLE
  VERTICAL_LAYOUT = 'vertical'
  proxy = null
  node_images_path = ''
  debug = !1
  catch_exceptions = !0
  throw_errors = !0
  allow_scripts = !1
  registered_node_types = {}
  node_types_by_file_extension = {}
  Nodes = {}
  Globals = {}
  searchbox_extras = {}
  auto_sort_node_types = !1
  node_box_coloured_when_on = !1
  node_box_coloured_by_mode = !1
  dialog_close_on_mouse_leave = !1
  dialog_close_on_mouse_leave_delay = 500
  shift_click_do_break_link_from = !1
  click_do_break_link_to = !1
  ctrl_alt_click_do_break_link = !0
  snaps_for_comfy = !0
  snap_highlights_node = !0
  alwaysSnapToGrid
  snapToGrid
  search_hide_on_mouse_leave = !0
  search_filter_enabled = !1
  search_show_all_on_open = !0
  auto_load_slot_types = !1
  registered_slot_in_types = {}
  registered_slot_out_types = {}
  slot_types_in = []
  slot_types_out = []
  slot_types_default_in = {}
  slot_types_default_out = {}
  alt_drag_do_clone_nodes = !1
  do_add_triggers_slots = !1
  allow_multi_output_for_events = !0
  middle_click_slot_add_default_node = !1
  release_link_on_empty_shows_menu = !1
  pointerevents_method = 'pointer'
  ctrl_shift_v_paste_connect_unselected_outputs = !0
  use_uuids = !1
  highlight_selected_group = !0
  use_legacy_node_error_indicator = !1
  LGraph = LGraph$1
  LLink = LLink
  LGraphNode = LGraphNode
  LGraphGroup = LGraphGroup
  DragAndScale = DragAndScale
  LGraphCanvas = LGraphCanvas
  ContextMenu = ContextMenu
  CurveEditor = CurveEditor
  static {
    LGraphCanvas.link_type_colors = {
      '-1': LiteGraphGlobal.DEFAULT_EVENT_LINK_COLOR,
      number: '#AAA',
      node: '#DCA'
    }
  }
  constructor() {
    'undefined' != typeof performance
      ? (this.getTime = performance.now.bind(performance))
      : 'undefined' != typeof Date && Date.now
        ? (this.getTime = Date.now.bind(Date))
        : 'undefined' != typeof process
          ? (this.getTime = function () {
              const e = process.hrtime()
              return 0.001 * e[0] + 1e-6 * e[1]
            })
          : (this.getTime = function () {
              return new Date().getTime()
            })
  }
  registerNodeType(e, t) {
    if (!t.prototype)
      throw 'Cannot register a simple object, it must be a class with a prototype'
    ;(t.type = e), this.debug && console.log('Node registered: ' + e)
    const n = t.name,
      o = e.lastIndexOf('/')
    ;(t.category = e.substring(0, o)), (t.title ||= n)
    for (const r in LGraphNode.prototype)
      t.prototype[r] ||= LGraphNode.prototype[r]
    const i = this.registered_node_types[e]
    if (
      (i && console.log('replacing node type: ' + e),
      !Object.prototype.hasOwnProperty.call(t.prototype, 'shape') &&
        (Object.defineProperty(t.prototype, 'shape', {
          set(e) {
            switch (e) {
              case 'default':
                delete this._shape
                break
              case 'box':
                this._shape = RenderShape.BOX
                break
              case 'round':
                this._shape = RenderShape.ROUND
                break
              case 'circle':
                this._shape = RenderShape.CIRCLE
                break
              case 'card':
                this._shape = RenderShape.CARD
                break
              default:
                this._shape = e
            }
          },
          get() {
            return this._shape
          },
          enumerable: !0,
          configurable: !0
        }),
        t.supported_extensions))
    )
      for (const r in t.supported_extensions) {
        const e = t.supported_extensions[r]
        e &&
          'string' == typeof e &&
          (this.node_types_by_file_extension[e.toLowerCase()] = t)
      }
    ;(this.registered_node_types[e] = t),
      t.constructor.name && (this.Nodes[n] = t),
      this.onNodeTypeRegistered?.(e, t),
      i && this.onNodeTypeReplaced?.(e, t, i),
      t.prototype.onPropertyChange &&
        console.warn(
          `LiteGraph node class ${e} has onPropertyChange method, it must be called onPropertyChanged with d at the end`
        ),
      this.auto_load_slot_types && new t(t.title || 'tmpnode')
  }
  unregisterNodeType(e) {
    const t = 'string' == typeof e ? this.registered_node_types[e] : e
    if (!t) throw 'node type not found: ' + e
    delete this.registered_node_types[t.type]
    const n = t.constructor.name
    n && delete this.Nodes[n]
  }
  registerNodeAndSlotType(e, t, n) {
    n ||= !1
    const o = (
      'string' == typeof e && 'anonymous' !== this.registered_node_types[e]
        ? this.registered_node_types[e]
        : e
    ).constructor.type
    let i = []
    i =
      'string' == typeof t
        ? t.split(',')
        : t == this.EVENT || t == this.ACTION
          ? ['_event_']
          : ['*']
    for (let r = 0; r < i.length; ++r) {
      let e = i[r]
      '' === e && (e = '*')
      const t = n ? 'registered_slot_out_types' : 'registered_slot_in_types'
      void 0 === this[t][e] && (this[t][e] = { nodes: [] }),
        this[t][e].nodes.includes(o) || this[t][e].nodes.push(o)
      const a = n ? this.slot_types_out : this.slot_types_in
      a.includes(e.toLowerCase()) || (a.push(e.toLowerCase()), a.sort())
    }
  }
  wrapFunctionAsNode(e, t, n, o, i) {
    const r = Array(t.length)
    let a = ''
    const s = this.getParameterNames(t)
    for (let c = 0; c < s.length; ++c)
      a += `this.addInput('${s[c]}',${n && n[c] ? `'${n[c]}'` : '0'});\n`
    ;(a += `this.addOutput('out',${o ? `'${o}'` : 0});\n`),
      i && (a += `this.properties = ${JSON.stringify(i)};\n`)
    const l = Function(a)
    ;(l.title = e.split('/').pop()),
      (l.desc = 'Generated from ' + t.name),
      (l.prototype.onExecute = __name(function () {
        for (let t = 0; t < r.length; ++t) r[t] = this.getInputData(t)
        const e = t.apply(this, r)
        this.setOutputData(0, e)
      }, 'onExecute')),
      this.registerNodeType(e, l)
  }
  clearRegisteredTypes() {
    ;(this.registered_node_types = {}),
      (this.node_types_by_file_extension = {}),
      (this.Nodes = {}),
      (this.searchbox_extras = {})
  }
  addNodeMethod(e, t) {
    LGraphNode.prototype[e] = t
    for (const n in this.registered_node_types) {
      const o = this.registered_node_types[n]
      o.prototype[e] && (o.prototype['_' + e] = o.prototype[e]),
        (o.prototype[e] = t)
    }
  }
  createNode(e, t, n) {
    const o = this.registered_node_types[e]
    if (!o)
      return (
        this.debug && console.log(`GraphNode type "${e}" not registered.`), null
      )
    t = t || o.title || e
    let i = null
    if (this.catch_exceptions)
      try {
        i = new o(t)
      } catch (r) {
        return console.error(r), null
      }
    else i = new o(t)
    if (
      ((i.type = e),
      !i.title && t && (i.title = t),
      (i.properties ||= {}),
      (i.properties_info ||= []),
      (i.flags ||= {}),
      (i.size ||= i.computeSize()),
      (i.pos ||= this.DEFAULT_POSITION.concat()),
      (i.mode ||= LGraphEventMode.ALWAYS),
      n)
    )
      for (const a in n) i[a] = n[a]
    return i.onNodeCreated?.(), i
  }
  getNodeType(e) {
    return this.registered_node_types[e]
  }
  getNodeTypesInCategory(e, t) {
    const n = []
    for (const o in this.registered_node_types) {
      const i = this.registered_node_types[o]
      i.filter == t &&
        ('' == e
          ? null == i.category && n.push(i)
          : i.category == e && n.push(i))
    }
    return (
      this.auto_sort_node_types &&
        n.sort(function (e, t) {
          return e.title.localeCompare(t.title)
        }),
      n
    )
  }
  getNodeTypesCategories(e) {
    const t = { '': 1 }
    for (const o in this.registered_node_types) {
      const n = this.registered_node_types[o]
      if (n.category && !n.skip_list) {
        if (n.filter != e) continue
        t[n.category] = 1
      }
    }
    const n = []
    for (const o in t) n.push(o)
    return this.auto_sort_node_types ? n.sort() : n
  }
  reloadNodes(e) {
    const t = document.getElementsByTagName('script'),
      n = []
    for (let r = 0; r < t.length; r++) n.push(t[r])
    const o = document.getElementsByTagName('head')[0]
    e = document.location.href + e
    for (let r = 0; r < n.length; r++) {
      const t = n[r].src
      if (t && t.substr(0, e.length) == e)
        try {
          this.debug && console.log('Reloading: ' + t)
          const e = document.createElement('script')
          ;(e.type = 'text/javascript'),
            (e.src = t),
            o.appendChild(e),
            o.removeChild(n[r])
        } catch (i) {
          if (this.throw_errors) throw i
          this.debug && console.log('Error while reloading ' + t)
        }
    }
    this.debug && console.log('Nodes reloaded')
  }
  cloneObject(e, t) {
    if (null == e) return null
    const n = JSON.parse(JSON.stringify(e))
    if (!t) return n
    for (const o in n) t[o] = n[o]
    return t
  }
  uuidv4() {
    return '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, (e) =>
      (e ^ ((16 * Math.random()) >> (e / 4))).toString(16)
    )
  }
  isValidConnection(e, t) {
    if (
      (('' != e && '*' !== e) || (e = 0),
      ('' != t && '*' !== t) || (t = 0),
      !e || !t || e == t || (e == this.EVENT && t == this.ACTION))
    )
      return !0
    if (
      ((e = String(e)),
      (t = String(t)),
      (e = e.toLowerCase()),
      (t = t.toLowerCase()),
      -1 == e.indexOf(',') && -1 == t.indexOf(','))
    )
      return e == t
    const n = e.split(','),
      o = t.split(',')
    for (let i = 0; i < n.length; ++i)
      for (let e = 0; e < o.length; ++e)
        if (this.isValidConnection(n[i], o[e])) return !0
    return !1
  }
  registerSearchboxExtra(e, t, n) {
    this.searchbox_extras[t.toLowerCase()] = { type: e, desc: t, data: n }
  }
  fetchFile(e, t, n, o) {
    if (!e) return null
    if (((t = t || 'text'), 'string' == typeof e))
      return (
        'http' == e.substr(0, 4) &&
          this.proxy &&
          (e = this.proxy + e.substr(e.indexOf(':') + 3)),
        fetch(e)
          .then(function (e) {
            if (!e.ok) throw new Error('File not found')
            return 'arraybuffer' == t
              ? e.arrayBuffer()
              : 'text' == t || 'string' == t
                ? e.text()
                : 'json' == t
                  ? e.json()
                  : 'blob' == t
                    ? e.blob()
                    : void 0
          })
          .then(function (e) {
            n?.(e)
          })
          .catch(function (t) {
            console.error('error fetching file:', e), o?.(t)
          })
      )
    if (e instanceof File || e instanceof Blob) {
      const o = new FileReader()
      if (
        ((o.onload = function (e) {
          let o = e.target.result
          'json' == t && (o = JSON.parse(o)), n?.(o)
        }),
        'arraybuffer' == t)
      )
        return o.readAsArrayBuffer(e)
      if ('text' == t || 'json' == t) return o.readAsText(e)
      if ('blob' == t) return o.readAsBinaryString(e)
    }
    return null
  }
  getParameterNames(e) {
    return (e + '')
      .replace(/[/][/].*$/gm, '')
      .replace(/\s+/g, '')
      .replace(/[/][*][^/*]*[*][/]/g, '')
      .split('){', 1)[0]
      .replace(/^[^(]*[(]/, '')
      .replace(/=[^,]+/g, '')
      .split(',')
      .filter(Boolean)
  }
  pointerListenerAdd(e, t, n, o = !1) {
    if (!e || !e.addEventListener || !t || 'function' != typeof n) return
    let i = this.pointerevents_method,
      r = t
    if ('pointer' == i && !window.PointerEvent)
      switch (
        (console.warn("sMethod=='pointer' && !window.PointerEvent"),
        console.log(
          'Converting pointer[' +
            r +
            '] : down move up cancel enter TO touchstart touchmove touchend, etc ..'
        ),
        r)
      ) {
        case 'down':
          ;(i = 'touch'), (r = 'start')
          break
        case 'move':
        case 'cancel':
          i = 'touch'
          break
        case 'up':
          ;(i = 'touch'), (r = 'end')
          break
        case 'enter':
          console.log('debug: Should I send a move event?')
          break
        default:
          console.warn(
            'PointerEvent not available in this browser ? The event ' +
              r +
              ' would not be called'
          )
      }
    switch (r) {
      case 'down':
      case 'up':
      case 'move':
      case 'over':
      case 'out':
      case 'enter':
        e.addEventListener(i + r, n, o)
      case 'leave':
      case 'cancel':
      case 'gotpointercapture':
      case 'lostpointercapture':
        if ('mouse' != i) return e.addEventListener(i + r, n, o)
      default:
        return e.addEventListener(r, n, o)
    }
  }
  pointerListenerRemove(e, t, n, o = !1) {
    if (e && e.removeEventListener && t && 'function' == typeof n)
      switch (t) {
        case 'down':
        case 'up':
        case 'move':
        case 'over':
        case 'out':
        case 'enter':
          ;('pointer' != this.pointerevents_method &&
            'mouse' != this.pointerevents_method) ||
            e.removeEventListener(this.pointerevents_method + t, n, o)
        case 'leave':
        case 'cancel':
        case 'gotpointercapture':
        case 'lostpointercapture':
          if ('pointer' == this.pointerevents_method)
            return e.removeEventListener(this.pointerevents_method + t, n, o)
        default:
          return e.removeEventListener(t, n, o)
      }
  }
  getTime
  compareObjects(e, t) {
    for (const n in e) if (e[n] != t[n]) return !1
    return !0
  }
  distance = distance
  colorToString(e) {
    return (
      'rgba(' +
      Math.round(255 * e[0]).toFixed() +
      ',' +
      Math.round(255 * e[1]).toFixed() +
      ',' +
      Math.round(255 * e[2]).toFixed() +
      ',' +
      (4 == e.length ? e[3].toFixed(2) : '1.0') +
      ')'
    )
  }
  isInsideRectangle = isInsideRectangle
  growBounding(e, t, n) {
    t < e[0] ? (e[0] = t) : t > e[2] && (e[2] = t),
      n < e[1] ? (e[1] = n) : n > e[3] && (e[3] = n)
  }
  overlapBounding = overlapBounding
  isInsideBounding(e, t) {
    return !(
      e[0] < t[0][0] ||
      e[1] < t[0][1] ||
      e[0] > t[1][0] ||
      e[1] > t[1][1]
    )
  }
  hex2num(e) {
    '#' == e.charAt(0) && (e = e.slice(1)), (e = e.toUpperCase())
    const t = '0123456789ABCDEF',
      n = new Array(3)
    let o,
      i,
      r = 0
    for (let a = 0; a < 6; a += 2)
      (o = t.indexOf(e.charAt(a))),
        (i = t.indexOf(e.charAt(a + 1))),
        (n[r] = 16 * o + i),
        r++
    return n
  }
  num2hex(e) {
    const t = '0123456789ABCDEF'
    let n,
      o,
      i = '#'
    for (let r = 0; r < 3; r++)
      (n = e[r] / 16), (o = e[r] % 16), (i += t.charAt(n) + t.charAt(o))
    return i
  }
  closeAllContextMenus(e) {
    const t = (e = e || window).document.querySelectorAll('.litecontextmenu')
    if (!t.length) return
    const n = []
    for (let o = 0; o < t.length; o++) n.push(t[o])
    for (let o = 0; o < n.length; o++)
      n[o].close
        ? n[o].close()
        : n[o].parentNode && n[o].parentNode.removeChild(n[o])
  }
  extendClass(e, t) {
    for (const n in t) e.hasOwnProperty(n) || (e[n] = t[n])
    if (t.prototype)
      for (const n in t.prototype)
        t.prototype.hasOwnProperty(n) &&
          (e.prototype.hasOwnProperty(n) ||
            (t.prototype.__lookupGetter__(n)
              ? e.prototype.__defineGetter__(n, t.prototype.__lookupGetter__(n))
              : (e.prototype[n] = t.prototype[n]),
            t.prototype.__lookupSetter__(n) &&
              e.prototype.__defineSetter__(n, t.prototype.__lookupSetter__(n))))
  }
}
function loadPolyfills() {
  'undefined' != typeof window &&
    window.CanvasRenderingContext2D &&
    !window.CanvasRenderingContext2D.prototype.roundRect &&
    (window.CanvasRenderingContext2D.prototype.roundRect = function (
      e,
      t,
      n,
      o,
      i,
      r
    ) {
      let a = 0,
        s = 0,
        l = 0,
        c = 0
      if (0 !== i) {
        if ((void 0 === r && (r = i), null != i && i.constructor === Array))
          if (1 == i.length) a = s = l = c = i[0]
          else if (2 == i.length) (a = c = i[0]), (s = l = i[1])
          else {
            if (4 != i.length) return
            ;(a = i[0]), (s = i[1]), (l = i[2]), (c = i[3])
          }
        else (a = i || 0), (s = i || 0), (l = r || 0), (c = r || 0)
        this.moveTo(e + a, t),
          this.lineTo(e + n - s, t),
          this.quadraticCurveTo(e + n, t, e + n, t + s),
          this.lineTo(e + n, t + o - c),
          this.quadraticCurveTo(e + n, t + o, e + n - c, t + o),
          this.lineTo(e + c, t + o),
          this.quadraticCurveTo(e, t + o, e, t + o - l),
          this.lineTo(e, t + l),
          this.quadraticCurveTo(e, t, e + a, t)
      } else this.rect(e, t, n, o)
    }),
    'undefined' == typeof window ||
      window.requestAnimationFrame ||
      (window.requestAnimationFrame =
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function (e) {
          window.setTimeout(e, 1e3 / 60)
        })
}
__name(loadPolyfills, 'loadPolyfills')
const LiteGraph = new LiteGraphGlobal()
function clamp$1(e, t, n) {
  return t > e ? t : n < e ? n : e
}
__name(clamp$1, 'clamp$1'), loadPolyfills()
const SIZE = Symbol()
function intersect(e, t) {
  const n = Math.max(e.x, t.x),
    o = Math.min(e.x + e.width, t.x + t.width),
    i = Math.max(e.y, t.y),
    r = Math.min(e.y + e.height, t.y + t.height)
  return o >= n && r >= i ? [n, i, o - n, r - i] : null
}
function getClipPath(e, t, n) {
  const o = Object.values(app$1.canvas.selected_nodes)[0]
  if (o && o !== e) {
    const e = t.getBoundingClientRect(),
      i = 4,
      { offset: r, scale: a } = app$1.canvas.ds,
      { renderArea: s } = o,
      l = intersect(
        {
          x: e.left - n.left,
          y: e.top - n.top,
          width: e.width,
          height: e.height
        },
        {
          x: (s[0] + r[0] - i) * a,
          y: (s[1] + r[1] - i) * a,
          width: (s[2] + 2 * i) * a,
          height: (s[3] + 2 * i) * a
        }
      )
    if (!l) return ''
    const c = (l[0] - e.left + n.left) / a + 'px',
      d = (l[1] - e.top + n.top) / a + 'px',
      u = l[2] / a + 'px',
      p = l[3] / a + 'px'
    return `polygon(0% 0%, 0% 100%, ${c} 100%, ${c} ${d}, calc(${c} + ${u}) ${d}, calc(${c} + ${u}) calc(${d} + ${p}), ${c} calc(${d} + ${p}), ${c} 100%, 100% 100%, 100% 0%)`
  }
  return ''
}
function computeSize(e) {
  if (null == this.widgets?.[0]?.last_y) return
  let t = this.widgets[0].last_y,
    n = e[1] - t,
    o = 0,
    i = []
  for (const l of this.widgets)
    if ('converted-widget' === l.type) delete l.computedHeight
    else if (l.computeSize) o += l.computeSize()[1] + 4
    else if (l.element) {
      const t = getComputedStyle(l.element)
      let n =
          l.options.getMinHeight?.() ??
          parseInt(t.getPropertyValue('--comfy-widget-min-height')),
        o =
          l.options.getMaxHeight?.() ??
          parseInt(t.getPropertyValue('--comfy-widget-max-height')),
        r =
          l.options.getHeight?.() ?? t.getPropertyValue('--comfy-widget-height')
      r.endsWith?.('%')
        ? (r = e[1] * (parseFloat(r.substring(0, r.length - 1)) / 100))
        : ((r = parseInt(r)), isNaN(n) && (n = r)),
        isNaN(n) && (n = 50),
        isNaN(o) || (r = isNaN(r) ? o : Math.min(r, o)),
        i.push({ minHeight: n, prefHeight: r, w: l })
    } else o += LiteGraph.NODE_WIDGET_HEIGHT + 4
  n -= o
  const r = [],
    a = []
  let s = 0
  for (const l of i)
    if (((n -= l.minHeight), isNaN(l.prefHeight)))
      a.push(l), (l.w.computedHeight = l.minHeight)
    else {
      const e = l.prefHeight - l.minHeight
      e > 0
        ? (r.push(l), (s += e), (l.diff = e))
        : (l.w.computedHeight = l.minHeight)
    }
  if (
    (this.imgs &&
      !this.widgets.find((e) => e.name === ANIM_PREVIEW_WIDGET) &&
      (n -= 220),
    (this.freeWidgetSpace = n),
    n < 0)
  )
    (e[1] -= n), this.graph.setDirtyCanvas(!0)
  else {
    const e = n - s
    if (e > 0) {
      n = e
      for (const e of r) e.w.computedHeight = e.prefHeight
    } else {
      const t = -e / r.length
      for (const e of r) e.w.computedHeight = e.prefHeight - t
      n = 0
    }
    if (n > 0 && a.length) {
      const e = n / a.length
      for (const t of a) t.w.computedHeight += e
    }
  }
  for (const l of this.widgets)
    (l.y = t),
      l.computedHeight
        ? (t += l.computedHeight)
        : l.computeSize
          ? (t += l.computeSize()[1] + 4)
          : (t += LiteGraph.NODE_WIDGET_HEIGHT + 4)
}
__name(intersect, 'intersect'),
  __name(getClipPath, 'getClipPath'),
  __name(computeSize, 'computeSize')
const elementWidgets = new Set(),
  computeVisibleNodes = LGraphCanvas.prototype.computeVisibleNodes
;(LGraphCanvas.prototype.computeVisibleNodes = function () {
  const e = computeVisibleNodes.apply(this, arguments)
  for (const t of app$1.graph.nodes)
    if (elementWidgets.has(t)) {
      const n = -1 === e.indexOf(t)
      for (const e of t.widgets)
        if (e.element) {
          e.element.dataset.isInVisibleNodes = n ? 'false' : 'true'
          const t = 'true' === e.element.dataset.shouldHide,
            o = 'true' === e.element.dataset.collapsed,
            i = e.element.hidden,
            r = n || t || o
          ;(e.element.hidden = r),
            (e.element.style.display = r ? 'none' : null),
            r && !i && e.options.onHide?.(e)
        }
    }
  return e
}),
  (LGraphNode.prototype.addDOMWidget = function (e, t, n, o = {}) {
    let i
    ;(o = { hideOnZoom: !0, selectOn: ['focus', 'click'], ...o }),
      n.parentElement || app$1.canvasContainer.append(n),
      (n.hidden = !0),
      (n.style.display = 'none'),
      n.blur &&
        ((i = __name((e) => {
          n.contains(e.target) || n.blur()
        }, 'mouseDownHandler')),
        document.addEventListener('mousedown', i))
    const { nodeData: r } = this.constructor,
      a = (r?.input.required?.[e] ?? r?.input.optional?.[e])?.[1]?.tooltip
    a && !n.title && (n.title = a)
    const s = {
      type: t,
      name: e,
      get value() {
        return o.getValue?.() ?? void 0
      },
      set value(e) {
        o.setValue?.(e), s.callback?.(s.value)
      },
      draw: __name(function (e, t, i, r, a) {
        null == s.computedHeight && computeSize.call(t, t.size)
        const { offset: l, scale: c } = app$1.canvas.ds,
          d =
            (!!o.hideOnZoom && c < 0.5) ||
            s.computedHeight <= 0 ||
            'converted-widget' === s.type ||
            'hidden' === s.type
        n.dataset.shouldHide = d ? 'true' : 'false'
        const u = 'true' === n.dataset.isInVisibleNodes,
          p = 'true' === n.dataset.collapsed,
          h = d || !u || p,
          m = n.hidden
        if (
          ((n.hidden = h),
          (n.style.display = h ? 'none' : null),
          h && !m && s.options.onHide?.(s),
          h)
        )
          return
        const f = e.canvas.getBoundingClientRect(),
          _ = t.pos[0] + l[0] + 10,
          g = t.pos[1] + l[1] + 10 + r
        Object.assign(n.style, {
          transformOrigin: '0 0',
          transform: `scale(${c})`,
          left: _ * c + 'px',
          top: g * c + 'px',
          width: i - 20 + 'px',
          height: (s.computedHeight ?? 50) - 20 + 'px',
          position: 'absolute',
          zIndex: app$1.graph.nodes.indexOf(t),
          pointerEvents: app$1.canvas.read_only ? 'none' : 'auto'
        }),
          useSettingStore().get('Comfy.DOMClippingEnabled') &&
            ((n.style.clipPath = getClipPath(t, n, f)),
            (n.style.willChange = 'clip-path')),
          this.options.onDraw?.(s)
      }, 'draw'),
      element: n,
      options: o,
      onRemove() {
        i && document.removeEventListener('mousedown', i), n.remove()
      }
    }
    for (const d of o.selectOn)
      n.addEventListener(d, () => {
        app$1.canvas.selectNode(this), app$1.canvas.bringToFront(this)
      })
    this.addCustomWidget(s), elementWidgets.add(this)
    const l = this.collapse
    this.collapse = function () {
      l.apply(this, arguments),
        this.flags?.collapsed && ((n.hidden = !0), (n.style.display = 'none')),
        (n.dataset.collapsed = this.flags?.collapsed ? 'true' : 'false')
    }
    const c = this.onRemoved
    if (
      ((this.onRemoved = function () {
        n.remove(), elementWidgets.delete(this), c?.apply(this, arguments)
      }),
      !this[SIZE])
    ) {
      this[SIZE] = !0
      const e = this.onResize
      this.onResize = function (t) {
        o.beforeResize?.call(s, this),
          computeSize.call(this, t),
          e?.apply(this, arguments),
          o.afterResize?.call(s, this)
      }
    }
    return s
  })
let controlValueRunBefore = !1
function updateControlWidgetLabel(e) {
  let t = 'after',
    n = 'before'
  controlValueRunBefore && ([n, t] = [t, n]),
    (e.label = (e.label ?? e.name).replace(n, t))
}
__name(updateControlWidgetLabel, 'updateControlWidgetLabel')
const IS_CONTROL_WIDGET = Symbol(),
  HAS_EXECUTED = Symbol()
function getNumberDefaults(e, t, n, o) {
  let i = e[1].default,
    { min: r, max: a, step: s, round: l } = e[1]
  return (
    null == i && (i = 0),
    null == r && (r = 0),
    null == a && (a = 2048),
    null == s && (s = t),
    null == n && (n = Math.max(-Math.floor(Math.log10(s)), 0)),
    !o ||
      (null != l && !0 !== l) ||
      (l = Math.round(1e6 * Math.pow(0.1, n)) / 1e6),
    { val: i, config: { min: r, max: a, step: 10 * s, round: l, precision: n } }
  )
}
function addValueControlWidget(e, t, n = 'randomize', o, i, r) {
  let a = r[1]?.control_after_generate
  'string' != typeof a && (a = i)
  return addValueControlWidgets(
    e,
    t,
    n,
    { addFilterList: !1, controlAfterGenerateName: a },
    r
  )[0]
}
function addValueControlWidgets(e, t, n = 'randomize', o, i) {
  n || (n = 'randomize'), o || (o = {})
  const r = __name((e, t) => {
      let n = e
      return (
        o[t]
          ? (n = o[t])
          : 'string' == typeof i?.[1]?.[e]
            ? (n = i?.[1]?.[e])
            : i?.[1]?.control_prefix && (n = i?.[1]?.control_prefix + ' ' + n),
        n
      )
    }, 'getName'),
    a = [],
    s = e.addWidget(
      'combo',
      r('control_after_generate', 'controlAfterGenerateName'),
      n,
      function () {},
      {
        values: ['fixed', 'increment', 'decrement', 'randomize'],
        serialize: !1
      }
    )
  ;(s.tooltip =
    'Allows the linked widget to be changed automatically, for example randomizing the noise seed.'),
    (s[IS_CONTROL_WIDGET] = !0),
    updateControlWidgetLabel(s),
    a.push(s)
  const l = 'combo' === t.type
  let c
  l && s.options.values.push('increment-wrap'),
    l &&
      !1 !== o.addFilterList &&
      ((c = e.addWidget(
        'string',
        r('control_filter_list', 'controlFilterListName'),
        '',
        function () {},
        { serialize: !1 }
      )),
      updateControlWidgetLabel(c),
      (c.tooltip =
        "Allows for filtering the list of values when changing the value via the control generate mode. Allows for RegEx matches in the format /abc/ to only filter to values containing 'abc'."),
      a.push(c))
  const d = __name(() => {
    var n = s.value
    if (l && 'fixed' !== n) {
      let i = t.options.values
      const r = c?.value
      if (r) {
        let n
        if (r.startsWith('/') && r.endsWith('/'))
          try {
            const e = new RegExp(r.substring(1, r.length - 1))
            n = __name((t) => e.test(t), 'check')
          } catch (o) {
            console.error(
              'Error constructing RegExp filter for node ' + e.id,
              r,
              o
            )
          }
        if (!n) {
          const e = r.toLocaleLowerCase()
          n = __name((t) => t.toLocaleLowerCase().includes(e), 'check')
        }
        ;(i = i.filter((e) => n(e))),
          !i.length &&
            t.options.values.length &&
            console.warn(
              'Filter for node ' + e.id + ' has filtered out all items',
              r
            )
      }
      let a = i.indexOf(t.value),
        s = i.length
      switch (n) {
        case 'increment':
          a += 1
          break
        case 'increment-wrap':
          ;(a += 1), a >= s && (a = 0)
          break
        case 'decrement':
          a -= 1
          break
        case 'randomize':
          a = Math.floor(Math.random() * s)
      }
      if (((a = Math.max(0, a)), (a = Math.min(s - 1, a)), a >= 0)) {
        let e = i[a]
        ;(t.value = e), t.callback(e)
      }
    } else {
      let e = t.options.min,
        o = t.options.max
      ;(o = Math.min(0x4000000000000, o)), (e = Math.max(-0x4000000000000, e))
      let i = (o - e) / (t.options.step / 10)
      switch (n) {
        case 'fixed':
        default:
          break
        case 'increment':
          t.value += t.options.step / 10
          break
        case 'decrement':
          t.value -= t.options.step / 10
          break
        case 'randomize':
          t.value = Math.floor(Math.random() * i) * (t.options.step / 10) + e
      }
      t.value < e && (t.value = e),
        t.value > o && (t.value = o),
        t.callback(t.value)
    }
  }, 'applyWidgetControl')
  return (
    (s.beforeQueued = () => {
      controlValueRunBefore && s[HAS_EXECUTED] && d(), (s[HAS_EXECUTED] = !0)
    }),
    (s.afterQueued = () => {
      controlValueRunBefore || d()
    }),
    a
  )
}
function seedWidget(e, t, n, o, i) {
  const r = createIntWidget(e, t, n, o, !0),
    a = addValueControlWidget(e, r.widget, 'randomize', void 0, i, n)
  return (r.widget.linkedWidgets = [a]), r
}
function createIntWidget(e, t, n, o, i = !1) {
  const r = n[1]?.control_after_generate
  if (!i && r) return seedWidget(e, t, n, o, 'string' == typeof r ? r : void 0)
  let a = isSlider(n[1].display, o)
  const { val: s, config: l } = getNumberDefaults(n, 1, 0, !0)
  return (
    Object.assign(l, { precision: 0 }),
    {
      widget: e.addWidget(
        a,
        t,
        s,
        function (e) {
          const t = this.options.step / 10
          let n = this.options.min % t
          isNaN(n) && (n = 0), (this.value = Math.round((e - n) / t) * t + n)
        },
        l
      )
    }
  )
}
function addMultilineWidget(e, t, n, o) {
  const i = document.createElement('textarea')
  ;(i.className = 'comfy-multiline-input'),
    (i.value = n.defaultVal),
    (i.placeholder = n.placeholder || t),
    o.vueAppReady &&
      (i.spellcheck = useSettingStore().get('Comfy.TextareaWidget.Spellcheck'))
  const r = e.addDOMWidget(t, 'customtext', i, {
    getValue: () => i.value,
    setValue(e) {
      i.value = e
    }
  })
  return (
    (r.inputEl = i),
    i.addEventListener('input', () => {
      r.callback?.(r.value)
    }),
    { minWidth: 400, minHeight: 200, widget: r }
  )
}
function isSlider(e, t) {
  return t.ui.settings.getSettingValue('Comfy.DisableSliders')
    ? 'number'
    : 'slider' === e
      ? 'slider'
      : 'number'
}
function initWidgets(e) {
  e.ui.settings.addSetting({
    id: 'Comfy.WidgetControlMode',
    category: ['Comfy', 'Node Widget', 'WidgetControlMode'],
    name: 'Widget control mode',
    tooltip:
      'Controls when widget values are updated (randomize/increment/decrement), either before the prompt is queued or after.',
    type: 'combo',
    defaultValue: 'after',
    options: ['before', 'after'],
    onChange(t) {
      controlValueRunBefore = 'before' === t
      for (const n of e.graph.nodes)
        if (n.widgets)
          for (const e of n.widgets)
            if (
              e[IS_CONTROL_WIDGET] &&
              (updateControlWidgetLabel(e), e.linkedWidgets)
            )
              for (const t of e.linkedWidgets) updateControlWidgetLabel(t)
      e.graph.setDirtyCanvas(!0)
    }
  })
}
__name(getNumberDefaults, 'getNumberDefaults'),
  __name(addValueControlWidget, 'addValueControlWidget'),
  __name(addValueControlWidgets, 'addValueControlWidgets'),
  __name(seedWidget, 'seedWidget'),
  __name(createIntWidget, 'createIntWidget'),
  __name(addMultilineWidget, 'addMultilineWidget'),
  __name(isSlider, 'isSlider'),
  __name(initWidgets, 'initWidgets')
const ComfyWidgets = {
  'INT:seed': seedWidget,
  'INT:noise_seed': seedWidget,
  FLOAT(e, t, n, o) {
    let i = isSlider(n[1].display, o),
      r = o.ui.settings.getSettingValue('Comfy.FloatRoundingPrecision'),
      a = o.ui.settings.getSettingValue('Comfy.DisableFloatRounding')
    0 == r && (r = void 0)
    const { val: s, config: l } = getNumberDefaults(n, 0.5, r, !a)
    return {
      widget: e.addWidget(
        i,
        t,
        s,
        function (e) {
          l.round
            ? ((this.value =
                Math.round((e + Number.EPSILON) / l.round) * l.round),
              this.value > l.max && (this.value = l.max),
              this.value < l.min && (this.value = l.min))
            : (this.value = e)
        },
        l
      )
    }
  },
  INT: (e, t, n, o) => createIntWidget(e, t, n, o),
  BOOLEAN(e, t, n) {
    let o = !1,
      i = {}
    return (
      n[1] &&
        (n[1].default && (o = n[1].default),
        n[1].label_on && (i.on = n[1].label_on),
        n[1].label_off && (i.off = n[1].label_off)),
      { widget: e.addWidget('toggle', t, o, () => {}, i) }
    )
  },
  STRING(e, t, n, o) {
    const i = n[1].default || ''
    let r
    return (
      (r = !!n[1].multiline
        ? addMultilineWidget(e, t, { defaultVal: i, ...n[1] }, o)
        : { widget: e.addWidget('text', t, i, () => {}, {}) }),
      null != n[1].dynamicPrompts &&
        (r.widget.dynamicPrompts = n[1].dynamicPrompts),
      r
    )
  },
  COMBO(e, t, n) {
    const o = n[0]
    let i = o[0]
    n[1] && n[1].default && (i = n[1].default)
    const r = { widget: e.addWidget('combo', t, i, () => {}, { values: o }) }
    return (
      n[1]?.control_after_generate &&
        (r.widget.linkedWidgets = addValueControlWidgets(
          e,
          r.widget,
          void 0,
          void 0,
          n
        )),
      r
    )
  },
  IMAGEUPLOAD(e, t, n, o) {
    const i = e.widgets.find((e) => e.name === (n[1]?.widget ?? 'image'))
    let r
    function a(t) {
      const n = new Image()
      n.onload = () => {
        ;(e.imgs = [n]), o.graph.setDirtyCanvas(!0)
      }
      let i = t.lastIndexOf('/'),
        r = ''
      i > -1 && ((r = t.substring(0, i)), (t = t.substring(i + 1))),
        (n.src = api.apiURL(
          `/view?filename=${encodeURIComponent(t)}&type=input&subfolder=${r}${o.getPreviewFormatParam()}${o.getRandParam()}`
        )),
        e.setSizeForImage?.()
    }
    __name(a, 'showImage')
    var s = i.value
    Object.defineProperty(i, 'value', {
      set: __name(function (e) {
        this._real_value = e
      }, 'set'),
      get: __name(function () {
        if (!this._real_value) return s
        let e = this._real_value
        if (e.filename) {
          let t = e
          ;(e = ''),
            t.subfolder && (e = t.subfolder + '/'),
            (e += t.filename),
            t.type && 'input' !== t.type && (e += ` [${t.type}]`)
        }
        return e
      }, 'get')
    })
    const l = e.callback
    async function c(e, t, n = !1) {
      try {
        const o = new FormData()
        o.append('image', e), n && o.append('subfolder', 'pasted')
        const r = await api.fetchApi('/upload/image', {
          method: 'POST',
          body: o
        })
        if (200 === r.status) {
          const e = await r.json()
          let n = e.name
          e.subfolder && (n = e.subfolder + '/' + n),
            i.options.values.includes(n) || i.options.values.push(n),
            t && (a(n), (i.value = n))
        } else useToastStore().addAlert(r.status + ' - ' + r.statusText)
      } catch (o) {
        useToastStore().addAlert(o)
      }
    }
    ;(i.callback = function () {
      if ((a(i.value), l)) return l.apply(this, arguments)
    }),
      requestAnimationFrame(() => {
        i.value && a(i.value)
      }),
      __name(c, 'uploadFile')
    const d = document.createElement('input')
    return (
      Object.assign(d, {
        type: 'file',
        accept: 'image/jpeg,image/png,image/webp',
        style: 'display: none',
        onchange: __name(async () => {
          d.files.length && (await c(d.files[0], !0))
        }, 'onchange')
      }),
      document.body.append(d),
      (r = e.addWidget('button', t, 'image', () => {
        d.click()
      })),
      (r.label = 'choose file to upload'),
      (r.serialize = !1),
      (e.onDragOver = function (e) {
        if (e.dataTransfer && e.dataTransfer.items) {
          return !![...e.dataTransfer.items].find((e) => 'file' === e.kind)
        }
        return !1
      }),
      (e.onDragDrop = function (e) {
        console.log('onDragDrop called')
        let t = !1
        for (const n of e.dataTransfer.files)
          n.type.startsWith('image/') && (c(n, !t), (t = !0))
        return t
      }),
      (e.pasteFile = function (e) {
        if (e.type.startsWith('image/')) {
          return (
            c(
              e,
              !0,
              'image.png' === e.name && e.lastModified - Date.now() < 2e3
            ),
            !0
          )
        }
        return !1
      }),
      { widget: r }
    )
  }
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.widgets = window.comfyAPI.widgets || {}),
  (window.comfyAPI.widgets.updateControlWidgetLabel = updateControlWidgetLabel),
  (window.comfyAPI.widgets.addValueControlWidget = addValueControlWidget),
  (window.comfyAPI.widgets.addValueControlWidgets = addValueControlWidgets),
  (window.comfyAPI.widgets.initWidgets = initWidgets),
  (window.comfyAPI.widgets.ComfyWidgets = ComfyWidgets)
let ComfyDialog$1 = class extends EventTarget {
  static {
    __name(this, 'ComfyDialog')
  }
  element
  textElement
  #q
  constructor(e = 'div', t = null) {
    super(),
      (this.#q = t),
      (this.element = $el(e + '.comfy-modal', { parent: document.body }, [
        $el('div.comfy-modal-content', [
          $el('p', { $: __name((e) => (this.textElement = e), '$') }),
          ...this.createButtons()
        ])
      ]))
  }
  createButtons() {
    return (
      this.#q ?? [
        $el('button', {
          type: 'button',
          textContent: 'Close',
          onclick: __name(() => this.close(), 'onclick')
        })
      ]
    )
  }
  close() {
    this.element.style.display = 'none'
  }
  show(e) {
    'string' == typeof e
      ? (this.textElement.innerHTML = e)
      : this.textElement.replaceChildren(...(e instanceof Array ? e : [e])),
      (this.element.style.display = 'flex')
  }
}
function toggleSwitch(e, t, n) {
  const o = n?.onChange
  let i, r
  function a(e) {
    null != i && r[i].classList.remove('comfy-toggle-selected'),
      o?.({ item: t[e], prev: null == i ? void 0 : t[i] }),
      (i = e),
      r[i].classList.add('comfy-toggle-selected')
  }
  __name(a, 'updateSelected'),
    (r = t.map((t, n) => {
      'string' == typeof t && (t = { text: t }), t.value || (t.value = t.text)
      const o = $el(
        'label',
        { textContent: t.text, title: t.tooltip ?? '' },
        $el('input', {
          name: e,
          type: 'radio',
          value: t.value ?? t.text,
          checked: t.selected,
          onchange: __name(() => {
            a(n)
          }, 'onchange')
        })
      )
      return t.selected && a(n), o
    }))
  const s = $el('div.comfy-toggle-switch', r)
  return null == i && ((r[0].children[0].checked = !0), a(0)), s
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.dialog = window.comfyAPI.dialog || {}),
  (window.comfyAPI.dialog.ComfyDialog = ComfyDialog$1),
  __name(toggleSwitch, 'toggleSwitch'),
  (window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.toggleSwitch = window.comfyAPI.toggleSwitch || {}),
  (window.comfyAPI.toggleSwitch.toggleSwitch = toggleSwitch)
class ComfySettingsDialog extends ComfyDialog$1 {
  static {
    __name(this, 'ComfySettingsDialog')
  }
  app
  settingsValues
  settingsLookup
  settingsParamLookup
  constructor(e) {
    super(),
      (this.app = e),
      (this.settingsValues = {}),
      (this.settingsLookup = {}),
      (this.settingsParamLookup = {})
  }
  get settings() {
    return Object.values(this.settingsLookup)
  }
  tryMigrateDeprecatedValue(e, t) {
    if (this.app.vueAppReady) {
      const n = useSettingStore().settings[e]
      if (n?.migrateDeprecatedValue) return n.migrateDeprecatedValue(t)
    }
    return t
  }
  #Y(e, t, n) {
    this.app.vueAppReady && (useSettingStore().settingValues[e] = t),
      this.dispatchEvent(
        new CustomEvent(e + '.change', { detail: { value: t, oldValue: n } })
      )
  }
  async load() {
    this.settingsValues = await api.getSettings()
    for (const e in this.settingsLookup) {
      const t = e
      this.settingsValues[t] = this.tryMigrateDeprecatedValue(
        e,
        this.settingsValues[t]
      )
      const n = this.settingsValues[t]
      this.settingsLookup[e].onChange?.(n), this.#Y(e, n)
    }
  }
  getSettingValue(e, t) {
    return this.settingsValues[e] ?? t
  }
  getSettingDefaultValue(e) {
    const t = this.settingsParamLookup[e]
    return 'function' == typeof t?.defaultValue
      ? t.defaultValue()
      : t?.defaultValue
  }
  async setSettingValueAsync(e, t) {
    t = this.tryMigrateDeprecatedValue(e, t)
    let n = this.getSettingValue(e, void 0)
    ;(this.settingsValues[e] = t),
      e in this.settingsLookup && this.settingsLookup[e].onChange?.(t, n),
      this.#Y(e, t, n),
      await api.storeSetting(e, t)
  }
  setSettingValue(e, t) {
    this.setSettingValueAsync(e, t).catch((t) => {
      useToastStore().addAlert(`Error saving setting '${e}': ${t}`)
    })
  }
  refreshSetting(e) {
    const t = this.getSettingValue(e)
    this.settingsLookup[e].onChange?.(t), this.#Y(e, t)
  }
  addSetting(e) {
    const { id: t, name: n, type: o, defaultValue: i, onChange: r } = e
    if (!t) throw new Error('Settings must have an ID')
    if (t in this.settingsLookup)
      throw new Error(`Setting ${t} of type ${o} must have a unique ID.`)
    const a = this.getSettingValue(t) ?? i
    r?.(a, void 0),
      this.#Y(t, a),
      (this.settingsParamLookup[t] = e),
      this.app.vueAppReady && (useSettingStore().settings[t] = e),
      (this.settingsLookup[t] = {
        id: t,
        onChange: r,
        name: n,
        render: __name(() => {
          console.warn('[ComfyUI] Setting render is deprecated', t)
        }, 'render')
      })
    const s = this
    return {
      get value() {
        return s.getSettingValue(t, i)
      },
      set value(e) {
        s.setSettingValue(t, e)
      }
    }
  }
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.settings = window.comfyAPI.settings || {}),
  (window.comfyAPI.settings.ComfySettingsDialog = ComfySettingsDialog)
const useDialogStore = defineStore('dialog', () => {
  const e = Vue.ref([]),
    t = __name(
      () => `dialog-${Math.random().toString(36).slice(2, 9)}`,
      'genDialogKey'
    )
  function n(t) {
    const n = t.key,
      o = e.value.findIndex((e) => e.key === n)
    if (-1 !== o) {
      const t = e.value.splice(o, 1)
      e.value.push(...t)
    }
  }
  function o(t) {
    if (!t) return void e.value.pop()
    const n = t.key,
      o = e.value.findIndex((e) => e.key === n)
    ;-1 !== o && e.value.splice(o, 1)
  }
  function i(t) {
    e.value.length >= 10 && e.value.shift()
    const i = {
      key: t.key,
      visible: !0,
      title: t.title,
      headerComponent: t.headerComponent
        ? Vue.markRaw(t.headerComponent)
        : void 0,
      component: Vue.markRaw(t.component),
      contentProps: { ...t.props },
      dialogComponentProps: {
        maximizable: !1,
        modal: !0,
        closable: !0,
        closeOnEscape: !0,
        dismissableMask: !0,
        ...t.dialogComponentProps,
        maximized: !1,
        onMaximize: __name(() => {
          i.dialogComponentProps.maximized = !0
        }, 'onMaximize'),
        onUnmaximize: __name(() => {
          i.dialogComponentProps.maximized = !1
        }, 'onUnmaximize'),
        onAfterHide: __name(() => {
          t.dialogComponentProps?.onClose?.(), o(i)
        }, 'onAfterHide'),
        pt: {
          root: {
            onMousedown: __name(() => {
              n(i)
            }, 'onMousedown')
          }
        }
      }
    }
    return e.value.push(i), i
  }
  function r(o) {
    const r = o.key || t()
    let a = e.value.find((e) => e.key === r)
    return a ? ((a.visible = !0), n(a)) : (a = i({ ...o, key: r })), a
  }
  return (
    __name(n, 'riseDialog'),
    __name(o, 'closeDialog'),
    __name(i, 'createDialog'),
    __name(r, 'showDialog'),
    { dialogStack: e, riseDialog: n, showDialog: r, closeDialog: o }
  )
})
function hasClass(e, t) {
  return (
    !!e &&
    (e.classList
      ? e.classList.contains(t)
      : new RegExp('(^| )' + t + '( |$)', 'gi').test(e.className))
  )
}
function addClass(e, t) {
  if (e && t) {
    const n = __name((t) => {
      hasClass(e, t) ||
        (e.classList ? e.classList.add(t) : (e.className += ' ' + t))
    }, 'fn')
    ;[t]
      .flat()
      .filter(Boolean)
      .forEach((e) => e.split(' ').forEach(n))
  }
}
function calculateBodyScrollbarWidth() {
  return window.innerWidth - document.documentElement.offsetWidth
}
function getCSSVariableByRegex(e) {
  for (const t of null == document ? void 0 : document.styleSheets)
    try {
      for (const n of null == t ? void 0 : t.cssRules)
        for (const t of null == n ? void 0 : n.style)
          if (e.test(t))
            return { name: t, value: n.style.getPropertyValue(t).trim() }
    } catch (e2) {}
  return null
}
function blockBodyScroll(e = 'p-overflow-hidden') {
  const t = getCSSVariableByRegex(/-scrollbar-width$/)
  ;(null == t ? void 0 : t.name) &&
    document.body.style.setProperty(
      t.name,
      calculateBodyScrollbarWidth() + 'px'
    ),
    addClass(document.body, e)
}
function saveAs(e) {
  if (e) {
    let t = document.createElement('a')
    if (void 0 !== t.download) {
      const { name: n, src: o } = e
      return (
        t.setAttribute('href', o),
        t.setAttribute('download', n),
        (t.style.display = 'none'),
        document.body.appendChild(t),
        t.click(),
        document.body.removeChild(t),
        !0
      )
    }
  }
  return !1
}
function exportCSV(e, t) {
  let n = new Blob([e], { type: 'application/csv;charset=utf-8;' })
  if (window.navigator.msSaveOrOpenBlob)
    navigator.msSaveOrOpenBlob(n, t + '.csv')
  else {
    saveAs({ name: t + '.csv', src: URL.createObjectURL(n) }) ||
      ((e = 'data:text/csv;charset=utf-8,' + e), window.open(encodeURI(e)))
  }
}
function removeClass(e, t) {
  if (e && t) {
    const n = __name((t) => {
      e.classList
        ? e.classList.remove(t)
        : (e.className = e.className.replace(
            new RegExp('(^|\\b)' + t.split(' ').join('|') + '(\\b|$)', 'gi'),
            ' '
          ))
    }, 'fn')
    ;[t]
      .flat()
      .filter(Boolean)
      .forEach((e) => e.split(' ').forEach(n))
  }
}
function unblockBodyScroll(e = 'p-overflow-hidden') {
  const t = getCSSVariableByRegex(/-scrollbar-width$/)
  ;(null == t ? void 0 : t.name) && document.body.style.removeProperty(t.name),
    removeClass(document.body, e)
}
function getHiddenElementDimensions(e) {
  let t = { width: 0, height: 0 }
  return (
    e &&
      ((e.style.visibility = 'hidden'),
      (e.style.display = 'block'),
      (t.width = e.offsetWidth),
      (t.height = e.offsetHeight),
      (e.style.display = 'none'),
      (e.style.visibility = 'visible')),
    t
  )
}
function getViewport() {
  let e = window,
    t = document,
    n = t.documentElement,
    o = t.getElementsByTagName('body')[0]
  return {
    width: e.innerWidth || n.clientWidth || o.clientWidth,
    height: e.innerHeight || n.clientHeight || o.clientHeight
  }
}
function getWindowScrollLeft() {
  let e = document.documentElement
  return (window.pageXOffset || e.scrollLeft) - (e.clientLeft || 0)
}
function getWindowScrollTop() {
  let e = document.documentElement
  return (window.pageYOffset || e.scrollTop) - (e.clientTop || 0)
}
function absolutePosition(e, t, n = !0) {
  var o, i, r, a
  if (e) {
    const s = e.offsetParent
        ? { width: e.offsetWidth, height: e.offsetHeight }
        : getHiddenElementDimensions(e),
      l = s.height,
      c = s.width,
      d = t.offsetHeight,
      u = t.offsetWidth,
      p = t.getBoundingClientRect(),
      h = getWindowScrollTop(),
      m = getWindowScrollLeft(),
      f = getViewport()
    let _,
      g,
      v = 'top'
    p.top + d + l > f.height
      ? ((_ = p.top + h - l), (v = 'bottom'), _ < 0 && (_ = h))
      : (_ = d + p.top + h),
      (g = p.left + c > f.width ? Math.max(0, p.left + m + u - c) : p.left + m),
      (e.style.top = _ + 'px'),
      (e.style.left = g + 'px'),
      (e.style.transformOrigin = v),
      n &&
        (e.style.marginTop =
          'bottom' === v
            ? `calc(${null != (i = null == (o = getCSSVariableByRegex(/-anchor-gutter$/)) ? void 0 : o.value) ? i : '2px'} * -1)`
            : null !=
                (a =
                  null == (r = getCSSVariableByRegex(/-anchor-gutter$/))
                    ? void 0
                    : r.value)
              ? a
              : '')
  }
}
function addStyle(e, t) {
  e &&
    ('string' == typeof t
      ? (e.style.cssText = t)
      : Object.entries(t || {}).forEach(([t, n]) => (e.style[t] = n)))
}
function getOuterWidth(e, t) {
  if (e instanceof HTMLElement) {
    let n = e.offsetWidth
    if (t) {
      let t = getComputedStyle(e)
      n += parseFloat(t.marginLeft) + parseFloat(t.marginRight)
    }
    return n
  }
  return 0
}
function relativePosition(e, t, n = !0) {
  var o, i, r, a
  if (e) {
    const s = e.offsetParent
        ? { width: e.offsetWidth, height: e.offsetHeight }
        : getHiddenElementDimensions(e),
      l = t.offsetHeight,
      c = t.getBoundingClientRect(),
      d = getViewport()
    let u,
      p,
      h = 'top'
    c.top + l + s.height > d.height
      ? ((u = -1 * s.height), (h = 'bottom'), c.top + u < 0 && (u = -1 * c.top))
      : (u = l),
      (p =
        s.width > d.width
          ? -1 * c.left
          : c.left + s.width > d.width
            ? -1 * (c.left + s.width - d.width)
            : 0),
      (e.style.top = u + 'px'),
      (e.style.left = p + 'px'),
      (e.style.transformOrigin = h),
      n &&
        (e.style.marginTop =
          'bottom' === h
            ? `calc(${null != (i = null == (o = getCSSVariableByRegex(/-anchor-gutter$/)) ? void 0 : o.value) ? i : '2px'} * -1)`
            : null !=
                (a =
                  null == (r = getCSSVariableByRegex(/-anchor-gutter$/))
                    ? void 0
                    : r.value)
              ? a
              : '')
  }
}
function alignOverlay(e, t, n, o = !0) {
  e &&
    t &&
    ('self' === n
      ? relativePosition(e, t)
      : (o && (e.style.minWidth = getOuterWidth(t) + 'px'),
        absolutePosition(e, t)))
}
function isElement(e) {
  return 'object' == typeof HTMLElement
    ? e instanceof HTMLElement
    : e &&
        'object' == typeof e &&
        null !== e &&
        1 === e.nodeType &&
        'string' == typeof e.nodeName
}
function toElement(e) {
  let t = e
  return (
    e &&
      'object' == typeof e &&
      (e.hasOwnProperty('current')
        ? (t = e.current)
        : e.hasOwnProperty('el') &&
          (t = e.el.hasOwnProperty('nativeElement')
            ? e.el.nativeElement
            : e.el)),
    isElement(t) ? t : void 0
  )
}
function appendChild(e, t) {
  const n = toElement(e)
  if (!n) throw new Error('Cannot append ' + t + ' to ' + e)
  n.appendChild(t)
}
__name(hasClass, 'hasClass'),
  __name(addClass, 'addClass'),
  __name(calculateBodyScrollbarWidth, 'calculateBodyScrollbarWidth'),
  __name(getCSSVariableByRegex, 'getCSSVariableByRegex'),
  __name(blockBodyScroll, 'blockBodyScroll'),
  __name(saveAs, 'saveAs'),
  __name(exportCSV, 'exportCSV'),
  __name(removeClass, 'removeClass'),
  __name(unblockBodyScroll, 'unblockBodyScroll'),
  __name(getHiddenElementDimensions, 'getHiddenElementDimensions'),
  __name(getViewport, 'getViewport'),
  __name(getWindowScrollLeft, 'getWindowScrollLeft'),
  __name(getWindowScrollTop, 'getWindowScrollTop'),
  __name(absolutePosition, 'absolutePosition'),
  __name(addStyle, 'addStyle'),
  __name(getOuterWidth, 'getOuterWidth'),
  __name(relativePosition, 'relativePosition'),
  __name(alignOverlay, 'alignOverlay'),
  __name(isElement, 'isElement'),
  __name(toElement, 'toElement'),
  __name(appendChild, 'appendChild')
var calculatedScrollbarHeight = void 0
function calculateScrollbarHeight(e) {
  if (e) {
    let t = getComputedStyle(e)
    return (
      e.offsetHeight -
      e.clientHeight -
      parseFloat(t.borderTopWidth) -
      parseFloat(t.borderBottomWidth)
    )
  }
  {
    if (null != calculatedScrollbarHeight) return calculatedScrollbarHeight
    let e = document.createElement('div')
    addStyle(e, {
      width: '100px',
      height: '100px',
      overflow: 'scroll',
      position: 'absolute',
      top: '-9999px'
    }),
      document.body.appendChild(e)
    let t = e.offsetHeight - e.clientHeight
    return document.body.removeChild(e), (calculatedScrollbarHeight = t), t
  }
}
__name(calculateScrollbarHeight, 'calculateScrollbarHeight')
var calculatedScrollbarWidth = void 0
function calculateScrollbarWidth(e) {
  if (e) {
    let t = getComputedStyle(e)
    return (
      e.offsetWidth -
      e.clientWidth -
      parseFloat(t.borderLeftWidth) -
      parseFloat(t.borderRightWidth)
    )
  }
  {
    if (null != calculatedScrollbarWidth) return calculatedScrollbarWidth
    let e = document.createElement('div')
    addStyle(e, {
      width: '100px',
      height: '100px',
      overflow: 'scroll',
      position: 'absolute',
      top: '-9999px'
    }),
      document.body.appendChild(e)
    let t = e.offsetWidth - e.clientWidth
    return document.body.removeChild(e), (calculatedScrollbarWidth = t), t
  }
}
function clearSelection() {
  if (window.getSelection) {
    const e = window.getSelection() || {}
    e.empty
      ? e.empty()
      : e.removeAllRanges &&
        e.rangeCount > 0 &&
        e.getRangeAt(0).getClientRects().length > 0 &&
        e.removeAllRanges()
  }
}
function setAttributes(e, t = {}) {
  if (isElement(e)) {
    const n = __name((t, o) => {
      var i, r
      const a = (null == (i = null == e ? void 0 : e.$attrs) ? void 0 : i[t])
        ? [null == (r = null == e ? void 0 : e.$attrs) ? void 0 : r[t]]
        : []
      return [o].flat().reduce((e, o) => {
        if (null != o) {
          const i = typeof o
          if ('string' === i || 'number' === i) e.push(o)
          else if ('object' === i) {
            const i = Array.isArray(o)
              ? n(t, o)
              : Object.entries(o).map(([e, n]) =>
                  'style' !== t || (!n && 0 !== n)
                    ? n
                      ? e
                      : void 0
                    : `${e.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()}:${n}`
                )
            e = i.length ? e.concat(i.filter((e) => !!e)) : e
          }
        }
        return e
      }, a)
    }, 'computedStyles')
    Object.entries(t).forEach(([t, o]) => {
      if (null != o) {
        const i = t.match(/^on(.+)/)
        i
          ? e.addEventListener(i[1].toLowerCase(), o)
          : 'p-bind' === t || 'pBind' === t
            ? setAttributes(e, o)
            : ((o =
                'class' === t
                  ? [...new Set(n('class', o))].join(' ').trim()
                  : 'style' === t
                    ? n('style', o).join(';').trim()
                    : o),
              (e.$attrs = e.$attrs || {}) && (e.$attrs[t] = o),
              e.setAttribute(t, o))
      }
    })
  }
}
function createElement(e, t = {}, ...n) {
  if (e) {
    const o = document.createElement(e)
    return setAttributes(o, t), o.append(...n), o
  }
}
function createStyleAsString(e, t = {}) {
  return e
    ? `'<style ${Object.entries(t).reduce((e, [t, n]) => e + `${t}="${n}"`, ' ')}>${e}</style>'`
    : ''
}
function createStyleTag(e = {}, t) {
  let n = document.createElement('style')
  return setAttributes(n, e), t || (t = document.head), t.appendChild(n), n
}
function fadeIn(e, t) {
  if (e) {
    e.style.opacity = '0'
    let n = +new Date(),
      o = '0',
      i = __name(function () {
        ;(o = '' + (+e.style.opacity + (new Date().getTime() - n) / t)),
          (e.style.opacity = o),
          (n = +new Date()),
          +o < 1 &&
            ((window.requestAnimationFrame && requestAnimationFrame(i)) ||
              setTimeout(i, 16))
      }, 'tick')
    i()
  }
}
function fadeOut(e, t) {
  if (e) {
    let n = 1,
      o = 50,
      i = o / t,
      r = setInterval(() => {
        ;(n -= i),
          n <= 0 && ((n = 0), clearInterval(r)),
          (e.style.opacity = n.toString())
      }, o)
  }
}
function find(e, t) {
  return isElement(e) ? Array.from(e.querySelectorAll(t)) : []
}
function findSingle(e, t) {
  return isElement(e) ? (e.matches(t) ? e : e.querySelector(t)) : null
}
function focus(e, t) {
  e && document.activeElement !== e && e.focus(t)
}
function getAttribute(e, t) {
  if (isElement(e)) {
    const n = e.getAttribute(t)
    return isNaN(n) ? ('true' === n || 'false' === n ? 'true' === n : n) : +n
  }
}
function resolveUserAgent() {
  let e = navigator.userAgent.toLowerCase(),
    t =
      /(chrome)[ ]([\w.]+)/.exec(e) ||
      /(webkit)[ ]([\w.]+)/.exec(e) ||
      /(opera)(?:.*version|)[ ]([\w.]+)/.exec(e) ||
      /(msie) ([\w.]+)/.exec(e) ||
      (e.indexOf('compatible') < 0 &&
        /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e)) ||
      []
  return { browser: t[1] || '', version: t[2] || '0' }
}
__name(calculateScrollbarWidth, 'calculateScrollbarWidth'),
  __name(clearSelection, 'clearSelection'),
  __name(setAttributes, 'setAttributes'),
  __name(createElement, 'createElement'),
  __name(createStyleAsString, 'createStyleAsString'),
  __name(createStyleTag, 'createStyleTag'),
  __name(fadeIn, 'fadeIn'),
  __name(fadeOut, 'fadeOut'),
  __name(find, 'find'),
  __name(findSingle, 'findSingle'),
  __name(focus, 'focus'),
  __name(getAttribute, 'getAttribute'),
  __name(resolveUserAgent, 'resolveUserAgent')
var browser = null
function getBrowser() {
  if (!browser) {
    browser = {}
    let e = resolveUserAgent()
    e.browser && ((browser[e.browser] = !0), (browser.version = e.version)),
      browser.chrome
        ? (browser.webkit = !0)
        : browser.webkit && (browser.safari = !0)
  }
  return browser
}
function getBrowserLanguage() {
  return (
    (navigator.languages &&
      navigator.languages.length &&
      navigator.languages[0]) ||
    navigator.language ||
    'en'
  )
}
function getCSSProperty(e, t, n) {
  var o
  return e && t
    ? n
      ? null == (o = null == e ? void 0 : e.style)
        ? void 0
        : o.getPropertyValue(t)
      : getComputedStyle(e).getPropertyValue(t)
    : null
}
function getCursorOffset(e, t, n, o) {
  if (e) {
    let i = getComputedStyle(e),
      r = document.createElement('div')
    ;(r.style.position = 'absolute'),
      (r.style.top = '0px'),
      (r.style.left = '0px'),
      (r.style.visibility = 'hidden'),
      (r.style.pointerEvents = 'none'),
      (r.style.overflow = i.overflow),
      (r.style.width = i.width),
      (r.style.height = i.height),
      (r.style.padding = i.padding),
      (r.style.border = i.border),
      (r.style.overflowWrap = i.overflowWrap),
      (r.style.whiteSpace = i.whiteSpace),
      (r.style.lineHeight = i.lineHeight),
      (r.innerHTML = t.replace(/\r\n|\r|\n/g, '<br />'))
    let a = document.createElement('span')
    ;(a.textContent = o), r.appendChild(a)
    let s = document.createTextNode(n)
    r.appendChild(s), document.body.appendChild(r)
    const { offsetLeft: l, offsetTop: c, clientHeight: d } = a
    return (
      document.body.removeChild(r),
      { left: Math.abs(l - e.scrollLeft), top: Math.abs(c - e.scrollTop) + d }
    )
  }
  return { top: 'auto', left: 'auto' }
}
function getFocusableElements(e, t = '') {
  let n = find(
      e,
      `button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t}`
    ),
    o = []
  for (let i of n)
    'none' != getComputedStyle(i).display &&
      'hidden' != getComputedStyle(i).visibility &&
      o.push(i)
  return o
}
function getFirstFocusableElement(e, t) {
  const n = getFocusableElements(e, t)
  return n.length > 0 ? n[0] : null
}
function getHeight(e) {
  if (e) {
    let t = e.offsetHeight,
      n = getComputedStyle(e)
    return (
      (t -=
        parseFloat(n.paddingTop) +
        parseFloat(n.paddingBottom) +
        parseFloat(n.borderTopWidth) +
        parseFloat(n.borderBottomWidth)),
      t
    )
  }
  return 0
}
function getHiddenElementOuterHeight(e) {
  if (e) {
    ;(e.style.visibility = 'hidden'), (e.style.display = 'block')
    let t = e.offsetHeight
    return (e.style.display = 'none'), (e.style.visibility = 'visible'), t
  }
  return 0
}
function getHiddenElementOuterWidth(e) {
  if (e) {
    ;(e.style.visibility = 'hidden'), (e.style.display = 'block')
    let t = e.offsetWidth
    return (e.style.display = 'none'), (e.style.visibility = 'visible'), t
  }
  return 0
}
function getParentNode(e) {
  if (e) {
    let t = e.parentNode
    return t && t instanceof ShadowRoot && t.host && (t = t.host), t
  }
  return null
}
function getIndex(e) {
  var t
  if (e) {
    let n = null == (t = getParentNode(e)) ? void 0 : t.childNodes,
      o = 0
    if (n)
      for (let t = 0; t < n.length; t++) {
        if (n[t] === e) return o
        1 === n[t].nodeType && o++
      }
  }
  return -1
}
function getInnerWidth(e) {
  if (e) {
    let t = e.offsetWidth,
      n = getComputedStyle(e)
    return (t -= parseFloat(n.borderLeft) + parseFloat(n.borderRight)), t
  }
  return 0
}
function getLastFocusableElement(e, t) {
  const n = getFocusableElements(e, t)
  return n.length > 0 ? n[n.length - 1] : null
}
function getNextElementSibling(e, t) {
  let n = e.nextElementSibling
  for (; n; ) {
    if (n.matches(t)) return n
    n = n.nextElementSibling
  }
  return null
}
function getNextFocusableElement(e, t, n) {
  const o = getFocusableElements(e, n),
    i = o.length > 0 ? o.findIndex((e) => e === t) : -1,
    r = i > -1 && o.length >= i + 1 ? i + 1 : -1
  return r > -1 ? o[r] : null
}
function getOffset(e) {
  if (e) {
    let t = e.getBoundingClientRect()
    return {
      top:
        t.top +
        (window.pageYOffset ||
          document.documentElement.scrollTop ||
          document.body.scrollTop ||
          0),
      left:
        t.left +
        (window.pageXOffset ||
          document.documentElement.scrollLeft ||
          document.body.scrollLeft ||
          0)
    }
  }
  return { top: 'auto', left: 'auto' }
}
function getOuterHeight(e, t) {
  if (e) {
    let n = e.offsetHeight
    if (t) {
      let t = getComputedStyle(e)
      n += parseFloat(t.marginTop) + parseFloat(t.marginBottom)
    }
    return n
  }
  return 0
}
function getParents(e, t = []) {
  const n = getParentNode(e)
  return null === n ? t : getParents(n, t.concat([n]))
}
function getPreviousElementSibling(e, t) {
  let n = e.previousElementSibling
  for (; n; ) {
    if (n.matches(t)) return n
    n = n.previousElementSibling
  }
  return null
}
function getScrollableParents(e) {
  let t = []
  if (e) {
    let n = getParents(e)
    const o = /(auto|scroll)/,
      i = __name((e) => {
        try {
          let t = window.getComputedStyle(e, null)
          return (
            o.test(t.getPropertyValue('overflow')) ||
            o.test(t.getPropertyValue('overflowX')) ||
            o.test(t.getPropertyValue('overflowY'))
          )
        } catch (t) {
          return !1
        }
      }, 'overflowCheck')
    for (let e of n) {
      let n = 1 === e.nodeType && e.dataset.scrollselectors
      if (n) {
        let o = n.split(',')
        for (let n of o) {
          let o = findSingle(e, n)
          o && i(o) && t.push(o)
        }
      }
      9 !== e.nodeType && i(e) && t.push(e)
    }
  }
  return t
}
function getSelection() {
  return window.getSelection
    ? window.getSelection().toString()
    : document.getSelection
      ? document.getSelection().toString()
      : void 0
}
function isExist(e) {
  return !(null == e || !e.nodeName || !getParentNode(e))
}
function getTargetElement(e, t) {
  var n
  if (e)
    switch (e) {
      case 'document':
        return document
      case 'window':
        return window
      case 'body':
        return document.body
      case '@next':
        return null == t ? void 0 : t.nextElementSibling
      case '@prev':
        return null == t ? void 0 : t.previousElementSibling
      case '@parent':
        return null == t ? void 0 : t.parentElement
      case '@grandparent':
        return null == (n = null == t ? void 0 : t.parentElement)
          ? void 0
          : n.parentElement
      default:
        if ('string' == typeof e) return document.querySelector(e)
        const o = toElement(
          __name(
            (e) => !!(e && e.constructor && e.call && e.apply),
            'isFunction'
          )(e)
            ? e()
            : e
        )
        return 9 === (null == o ? void 0 : o.nodeType) || isExist(o)
          ? o
          : void 0
    }
}
function getUserAgent() {
  return navigator.userAgent
}
function getWidth(e) {
  if (e) {
    let t = e.offsetWidth,
      n = getComputedStyle(e)
    return (
      (t -=
        parseFloat(n.paddingLeft) +
        parseFloat(n.paddingRight) +
        parseFloat(n.borderLeftWidth) +
        parseFloat(n.borderRightWidth)),
      t
    )
  }
  return 0
}
function hasCSSAnimation(e) {
  if (e) {
    const t = getComputedStyle(e)
    return parseFloat(t.getPropertyValue('animation-duration') || '0') > 0
  }
  return !1
}
function hasCSSTransition(e) {
  if (e) {
    const t = getComputedStyle(e)
    return parseFloat(t.getPropertyValue('transition-duration') || '0') > 0
  }
  return !1
}
function invokeElementMethod(e, t, n) {
  e[t].apply(e, n)
}
function isAndroid$1() {
  return /(android)/i.test(navigator.userAgent)
}
function isAttributeEquals(e, t, n) {
  return !!isElement(e) && getAttribute(e, t) === n
}
function isAttributeNotEquals(e, t, n) {
  return !isAttributeEquals(e, t, n)
}
function isClickable(e) {
  if (e) {
    const t = e.nodeName,
      n = e.parentElement && e.parentElement.nodeName
    return (
      'INPUT' === t ||
      'TEXTAREA' === t ||
      'BUTTON' === t ||
      'A' === t ||
      'INPUT' === n ||
      'TEXTAREA' === n ||
      'BUTTON' === n ||
      'A' === n ||
      !!e.closest('.p-button, .p-checkbox, .p-radiobutton')
    )
  }
  return !1
}
function isClient$1() {
  return !(
    'undefined' == typeof window ||
    !window.document ||
    !window.document.createElement
  )
}
function isFocusableElement(e, t = '') {
  return (
    !!isElement(e) &&
    e.matches(
      `button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t}`
    )
  )
}
function isVisible(e) {
  return !(!e || null == e.offsetParent)
}
function isHidden(e) {
  return !isVisible(e)
}
function isIOS$1() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream
}
function isRTL(e) {
  return !!e && 'rtl' === getComputedStyle(e).direction
}
function isServer() {
  return !isClient$1()
}
function isTouchDevice() {
  return (
    'ontouchstart' in window ||
    navigator.maxTouchPoints > 0 ||
    navigator.msMaxTouchPoints > 0
  )
}
function nestedPosition(e, t) {
  var n, o
  if (e) {
    const i = e.parentElement,
      r = getOffset(i),
      a = getViewport(),
      s = e.offsetParent ? e.offsetWidth : getHiddenElementOuterWidth(e),
      l = e.offsetParent ? e.offsetHeight : getHiddenElementOuterHeight(e),
      c = getOuterWidth(
        null == (n = null == i ? void 0 : i.children) ? void 0 : n[0]
      ),
      d = getOuterHeight(
        null == (o = null == i ? void 0 : i.children) ? void 0 : o[0]
      )
    let u = '',
      p = ''
    r.left + c + s > a.width - calculateScrollbarWidth()
      ? r.left < s
        ? t % 2 == 1
          ? (u = r.left ? '-' + r.left + 'px' : '100%')
          : t % 2 == 0 && (u = a.width - s - calculateScrollbarWidth() + 'px')
        : (u = '-100%')
      : (u = '100%'),
      (p =
        e.getBoundingClientRect().top + d + l > a.height
          ? `-${l - d}px`
          : '0px'),
      (e.style.top = p),
      (e.style.left = u)
  }
}
function remove(e) {
  var t
  e &&
    ('remove' in Element.prototype
      ? e.remove()
      : null == (t = e.parentNode) || t.removeChild(e))
}
function removeChild(e, t) {
  const n = toElement(e)
  if (!n) throw new Error('Cannot remove ' + t + ' from ' + e)
  n.removeChild(t)
}
function removeStyleTag(e) {
  var t
  if (isExist(e)) {
    try {
      null == (t = e.parentNode) || t.removeChild(e)
    } catch (n) {}
    return null
  }
  return e
}
function scrollInView(e, t) {
  let n = getComputedStyle(e).getPropertyValue('borderTopWidth'),
    o = n ? parseFloat(n) : 0,
    i = getComputedStyle(e).getPropertyValue('paddingTop'),
    r = i ? parseFloat(i) : 0,
    a = e.getBoundingClientRect(),
    s =
      t.getBoundingClientRect().top +
      document.body.scrollTop -
      (a.top + document.body.scrollTop) -
      o -
      r,
    l = e.scrollTop,
    c = e.clientHeight,
    d = getOuterHeight(t)
  s < 0 ? (e.scrollTop = l + s) : s + d > c && (e.scrollTop = l + s - c + d)
}
function setAttribute(e, t = '', n) {
  isElement(e) && null != n && e.setAttribute(t, n)
}
function setCSSProperty(e, t, n = null, o) {
  var i
  t && (null == (i = null == e ? void 0 : e.style) || i.setProperty(t, n, o))
}
__name(getBrowser, 'getBrowser'),
  __name(getBrowserLanguage, 'getBrowserLanguage'),
  __name(getCSSProperty, 'getCSSProperty'),
  __name(getCursorOffset, 'getCursorOffset'),
  __name(getFocusableElements, 'getFocusableElements'),
  __name(getFirstFocusableElement, 'getFirstFocusableElement'),
  __name(getHeight, 'getHeight'),
  __name(getHiddenElementOuterHeight, 'getHiddenElementOuterHeight'),
  __name(getHiddenElementOuterWidth, 'getHiddenElementOuterWidth'),
  __name(getParentNode, 'getParentNode'),
  __name(getIndex, 'getIndex'),
  __name(getInnerWidth, 'getInnerWidth'),
  __name(getLastFocusableElement, 'getLastFocusableElement'),
  __name(getNextElementSibling, 'getNextElementSibling'),
  __name(getNextFocusableElement, 'getNextFocusableElement'),
  __name(getOffset, 'getOffset'),
  __name(getOuterHeight, 'getOuterHeight'),
  __name(getParents, 'getParents'),
  __name(getPreviousElementSibling, 'getPreviousElementSibling'),
  __name(getScrollableParents, 'getScrollableParents'),
  __name(getSelection, 'getSelection'),
  __name(isExist, 'isExist'),
  __name(getTargetElement, 'getTargetElement'),
  __name(getUserAgent, 'getUserAgent'),
  __name(getWidth, 'getWidth'),
  __name(hasCSSAnimation, 'hasCSSAnimation'),
  __name(hasCSSTransition, 'hasCSSTransition'),
  __name(invokeElementMethod, 'invokeElementMethod'),
  __name(isAndroid$1, 'isAndroid$1'),
  __name(isAttributeEquals, 'isAttributeEquals'),
  __name(isAttributeNotEquals, 'isAttributeNotEquals'),
  __name(isClickable, 'isClickable'),
  __name(isClient$1, 'isClient$1'),
  __name(isFocusableElement, 'isFocusableElement'),
  __name(isVisible, 'isVisible'),
  __name(isHidden, 'isHidden'),
  __name(isIOS$1, 'isIOS$1'),
  __name(isRTL, 'isRTL'),
  __name(isServer, 'isServer'),
  __name(isTouchDevice, 'isTouchDevice'),
  __name(nestedPosition, 'nestedPosition'),
  __name(remove, 'remove'),
  __name(removeChild, 'removeChild'),
  __name(removeStyleTag, 'removeStyleTag'),
  __name(scrollInView, 'scrollInView'),
  __name(setAttribute, 'setAttribute'),
  __name(setCSSProperty, 'setCSSProperty')
var __defProp$2 = Object.defineProperty,
  __getOwnPropSymbols$2 = Object.getOwnPropertySymbols,
  __hasOwnProp$2 = Object.prototype.hasOwnProperty,
  __propIsEnum$2 = Object.prototype.propertyIsEnumerable,
  __defNormalProp$2 = __name(
    (e, t, n) =>
      t in e
        ? __defProp$2(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n
          })
        : (e[t] = n),
    '__defNormalProp$2'
  ),
  __spreadValues$2 = __name((e, t) => {
    for (var n in t || (t = {}))
      __hasOwnProp$2.call(t, n) && __defNormalProp$2(e, n, t[n])
    if (__getOwnPropSymbols$2)
      for (var n of __getOwnPropSymbols$2(t))
        __propIsEnum$2.call(t, n) && __defNormalProp$2(e, n, t[n])
    return e
  }, '__spreadValues$2')
function isEmpty(e) {
  return (
    null == e ||
    '' === e ||
    (Array.isArray(e) && 0 === e.length) ||
    (!(e instanceof Date) &&
      'object' == typeof e &&
      0 === Object.keys(e).length)
  )
}
function compare$1(e, t, n, o = 1) {
  let i = -1
  const r = isEmpty(e),
    a = isEmpty(t)
  return (
    (i =
      r && a
        ? 0
        : r
          ? o
          : a
            ? -o
            : 'string' == typeof e && 'string' == typeof t
              ? n(e, t)
              : e < t
                ? -1
                : e > t
                  ? 1
                  : 0),
    i
  )
}
function _deepEquals(e, t, n = new WeakSet()) {
  if (e === t) return !0
  if (!e || !t || 'object' != typeof e || 'object' != typeof t) return !1
  if (n.has(e) || n.has(t)) return !1
  n.add(e).add(t)
  let o,
    i,
    r,
    a = Array.isArray(e),
    s = Array.isArray(t)
  if (a && s) {
    if (((i = e.length), i != t.length)) return !1
    for (o = i; 0 != o--; ) if (!_deepEquals(e[o], t[o], n)) return !1
    return !0
  }
  if (a != s) return !1
  let l = e instanceof Date,
    c = t instanceof Date
  if (l != c) return !1
  if (l && c) return e.getTime() == t.getTime()
  let d = e instanceof RegExp,
    u = t instanceof RegExp
  if (d != u) return !1
  if (d && u) return e.toString() == t.toString()
  let p = Object.keys(e)
  if (((i = p.length), i !== Object.keys(t).length)) return !1
  for (o = i; 0 != o--; )
    if (!Object.prototype.hasOwnProperty.call(t, p[o])) return !1
  for (o = i; 0 != o--; )
    if (((r = p[o]), !_deepEquals(e[r], t[r], n))) return !1
  return !0
}
function deepEquals(e, t) {
  return _deepEquals(e, t)
}
function isFunction$1(e) {
  return !!(e && e.constructor && e.call && e.apply)
}
function isNotEmpty(e) {
  return !isEmpty(e)
}
function resolveFieldData(e, t) {
  if (!e || !t) return null
  try {
    const n = e[t]
    if (isNotEmpty(n)) return n
  } catch (e2) {}
  if (Object.keys(e).length) {
    if (isFunction$1(t)) return t(e)
    if (-1 === t.indexOf('.')) return e[t]
    {
      let n = t.split('.'),
        o = e
      for (let e = 0, t = n.length; e < t; ++e) {
        if (null == o) return null
        o = o[n[e]]
      }
      return o
    }
  }
  return null
}
function equals(e, t, n) {
  return n
    ? resolveFieldData(e, n) === resolveFieldData(t, n)
    : deepEquals(e, t)
}
function contains(e, t) {
  if (null != e && t && t.length) for (let n of t) if (equals(e, n)) return !0
  return !1
}
function filter(e, t, n) {
  let o = []
  if (e)
    for (let i of e)
      for (let e of t)
        if (
          String(resolveFieldData(i, e))
            .toLowerCase()
            .indexOf(n.toLowerCase()) > -1
        ) {
          o.push(i)
          break
        }
  return o
}
function findIndexInList(e, t) {
  let n = -1
  if (t)
    for (let o = 0; o < t.length; o++)
      if (t[o] === e) {
        n = o
        break
      }
  return n
}
function findLast$1(e, t) {
  let n
  if (isNotEmpty(e))
    try {
      n = e.findLast(t)
    } catch (e2) {
      n = [...e].reverse().find(t)
    }
  return n
}
function findLastIndex(e, t) {
  let n = -1
  if (isNotEmpty(e))
    try {
      n = e.findLastIndex(t)
    } catch (e2) {
      n = e.lastIndexOf([...e].reverse().find(t))
    }
  return n
}
function isObject$2(e, t = !0) {
  return (
    e instanceof Object &&
    e.constructor === Object &&
    (t || 0 !== Object.keys(e).length)
  )
}
function resolve(e, ...t) {
  return isFunction$1(e) ? e(...t) : e
}
function isString$1(e, t = !0) {
  return 'string' == typeof e && (t || '' !== e)
}
function toFlatCase(e) {
  return isString$1(e) ? e.replace(/(-|_)/g, '').toLowerCase() : e
}
function getKeyValue(e, t = '', n = {}) {
  const o = toFlatCase(t).split('.'),
    i = o.shift()
  return i
    ? isObject$2(e)
      ? getKeyValue(
          resolve(e[Object.keys(e).find((e) => toFlatCase(e) === i) || ''], n),
          o.join('.'),
          n
        )
      : void 0
    : resolve(e, n)
}
function insertIntoOrderedArray(e, t, n, o) {
  if (n.length > 0) {
    let i = !1
    for (let r = 0; r < n.length; r++) {
      if (findIndexInList(n[r], o) > t) {
        n.splice(r, 0, e), (i = !0)
        break
      }
    }
    i || n.push(e)
  } else n.push(e)
}
function isArray$1(e, t = !0) {
  return Array.isArray(e) && (t || 0 !== e.length)
}
function isDate(e) {
  return e instanceof Date && e.constructor === Date
}
function isLetter(e) {
  return /^[a-zA-Z\u00C0-\u017F]$/.test(e)
}
function isNumber$1(e) {
  return isNotEmpty(e) && !isNaN(e)
}
function isPrintableCharacter(e = '') {
  return isNotEmpty(e) && 1 === e.length && !!e.match(/\S| /)
}
function isScalar(e) {
  return (
    null != e &&
    ('string' == typeof e ||
      'number' == typeof e ||
      'bigint' == typeof e ||
      'boolean' == typeof e)
  )
}
function localeComparator() {
  return new Intl.Collator(void 0, { numeric: !0 }).compare
}
function matchRegex(e, t) {
  if (t) {
    const n = t.test(e)
    return (t.lastIndex = 0), n
  }
  return !1
}
function mergeKeys(...e) {
  const t = __name((e = {}, n = {}) => {
    const o = __spreadValues$2({}, e)
    return (
      Object.keys(n).forEach((i) => {
        isObject$2(n[i]) && i in e && isObject$2(e[i])
          ? (o[i] = t(e[i], n[i]))
          : (o[i] = n[i])
      }),
      o
    )
  }, '_mergeKeys')
  return e.reduce((e, n, o) => (0 === o ? n : t(e, n)), {})
}
function minifyCSS(e) {
  return e
    ? e
        .replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, '')
        .replace(/ {2,}/g, ' ')
        .replace(/ ([{:}]) /g, '$1')
        .replace(/([;,]) /g, '$1')
        .replace(/ !/g, '!')
        .replace(/: /g, ':')
    : e
}
function nestedKeys(e = {}, t = '') {
  return Object.entries(e).reduce((e, [n, o]) => {
    const i = t ? `${t}.${n}` : n
    return isObject$2(o) ? (e = e.concat(nestedKeys(o, i))) : e.push(i), e
  }, [])
}
function omit(e, ...t) {
  if (!isObject$2(e)) return e
  const n = __spreadValues$2({}, e)
  return null == t || t.flat().forEach((e) => delete n[e]), n
}
function removeAccents(e) {
  if (e && /[\xC0-\xFF\u0100-\u017E]/.test(e)) {
    const t = {
      A: /[\xC0-\xC5\u0100\u0102\u0104]/g,
      AE: /[\xC6]/g,
      C: /[\xC7\u0106\u0108\u010A\u010C]/g,
      D: /[\xD0\u010E\u0110]/g,
      E: /[\xC8-\xCB\u0112\u0114\u0116\u0118\u011A]/g,
      G: /[\u011C\u011E\u0120\u0122]/g,
      H: /[\u0124\u0126]/g,
      I: /[\xCC-\xCF\u0128\u012A\u012C\u012E\u0130]/g,
      IJ: /[\u0132]/g,
      J: /[\u0134]/g,
      K: /[\u0136]/g,
      L: /[\u0139\u013B\u013D\u013F\u0141]/g,
      N: /[\xD1\u0143\u0145\u0147\u014A]/g,
      O: /[\xD2-\xD6\xD8\u014C\u014E\u0150]/g,
      OE: /[\u0152]/g,
      R: /[\u0154\u0156\u0158]/g,
      S: /[\u015A\u015C\u015E\u0160]/g,
      T: /[\u0162\u0164\u0166]/g,
      U: /[\xD9-\xDC\u0168\u016A\u016C\u016E\u0170\u0172]/g,
      W: /[\u0174]/g,
      Y: /[\xDD\u0176\u0178]/g,
      Z: /[\u0179\u017B\u017D]/g,
      a: /[\xE0-\xE5\u0101\u0103\u0105]/g,
      ae: /[\xE6]/g,
      c: /[\xE7\u0107\u0109\u010B\u010D]/g,
      d: /[\u010F\u0111]/g,
      e: /[\xE8-\xEB\u0113\u0115\u0117\u0119\u011B]/g,
      g: /[\u011D\u011F\u0121\u0123]/g,
      i: /[\xEC-\xEF\u0129\u012B\u012D\u012F\u0131]/g,
      ij: /[\u0133]/g,
      j: /[\u0135]/g,
      k: /[\u0137,\u0138]/g,
      l: /[\u013A\u013C\u013E\u0140\u0142]/g,
      n: /[\xF1\u0144\u0146\u0148\u014B]/g,
      p: /[\xFE]/g,
      o: /[\xF2-\xF6\xF8\u014D\u014F\u0151]/g,
      oe: /[\u0153]/g,
      r: /[\u0155\u0157\u0159]/g,
      s: /[\u015B\u015D\u015F\u0161]/g,
      t: /[\u0163\u0165\u0167]/g,
      u: /[\xF9-\xFC\u0169\u016B\u016D\u016F\u0171\u0173]/g,
      w: /[\u0175]/g,
      y: /[\xFD\xFF\u0177]/g,
      z: /[\u017A\u017C\u017E]/g
    }
    for (let n in t) e = e.replace(t[n], n)
  }
  return e
}
function reorderArray(e, t, n) {
  e &&
    t !== n &&
    (n >= e.length && ((n %= e.length), (t %= e.length)),
    e.splice(n, 0, e.splice(t, 1)[0]))
}
function sort(e, t, n = 1, o, i = 1) {
  const r = compare$1(e, t, o, n)
  let a = n
  return (isEmpty(e) || isEmpty(t)) && (a = 1 === i ? n : i), a * r
}
function stringify(e, t = 2, n = 0) {
  const o = ' '.repeat(n),
    i = ' '.repeat(n + t)
  return isArray$1(e)
    ? '[' + e.map((e) => stringify(e, t, n + t)).join(', ') + ']'
    : isDate(e)
      ? e.toISOString()
      : isFunction$1(e)
        ? e.toString()
        : isObject$2(e)
          ? '{\n' +
            Object.entries(e)
              .map(([e, o]) => `${i}${e}: ${stringify(o, t, n + t)}`)
              .join(',\n') +
            `\n${o}}`
          : JSON.stringify(e)
}
function toCapitalCase(e) {
  return isString$1(e, !1) ? e[0].toUpperCase() + e.slice(1) : e
}
function toKebabCase(e) {
  return isString$1(e)
    ? e
        .replace(/(_)/g, '-')
        .replace(/[A-Z]/g, (e, t) => (0 === t ? e : '-' + e.toLowerCase()))
        .toLowerCase()
    : e
}
function toTokenKey$1(e) {
  return isString$1(e)
    ? e
        .replace(/[A-Z]/g, (e, t) => (0 === t ? e : '.' + e.toLowerCase()))
        .toLowerCase()
    : e
}
function toValue$2(e) {
  if (e && 'object' == typeof e) {
    if (e.hasOwnProperty('current')) return e.current
    if (e.hasOwnProperty('value')) return e.value
  }
  return resolve(e)
}
__name(isEmpty, 'isEmpty'),
  __name(compare$1, 'compare$1'),
  __name(_deepEquals, '_deepEquals'),
  __name(deepEquals, 'deepEquals'),
  __name(isFunction$1, 'isFunction$1'),
  __name(isNotEmpty, 'isNotEmpty'),
  __name(resolveFieldData, 'resolveFieldData'),
  __name(equals, 'equals'),
  __name(contains, 'contains'),
  __name(filter, 'filter'),
  __name(findIndexInList, 'findIndexInList'),
  __name(findLast$1, 'findLast$1'),
  __name(findLastIndex, 'findLastIndex'),
  __name(isObject$2, 'isObject$2'),
  __name(resolve, 'resolve'),
  __name(isString$1, 'isString$1'),
  __name(toFlatCase, 'toFlatCase'),
  __name(getKeyValue, 'getKeyValue'),
  __name(insertIntoOrderedArray, 'insertIntoOrderedArray'),
  __name(isArray$1, 'isArray$1'),
  __name(isDate, 'isDate'),
  __name(isLetter, 'isLetter'),
  __name(isNumber$1, 'isNumber$1'),
  __name(isPrintableCharacter, 'isPrintableCharacter'),
  __name(isScalar, 'isScalar'),
  __name(localeComparator, 'localeComparator'),
  __name(matchRegex, 'matchRegex'),
  __name(mergeKeys, 'mergeKeys'),
  __name(minifyCSS, 'minifyCSS'),
  __name(nestedKeys, 'nestedKeys'),
  __name(omit, 'omit'),
  __name(removeAccents, 'removeAccents'),
  __name(reorderArray, 'reorderArray'),
  __name(sort, 'sort'),
  __name(stringify, 'stringify'),
  __name(toCapitalCase, 'toCapitalCase'),
  __name(toKebabCase, 'toKebabCase'),
  __name(toTokenKey$1, 'toTokenKey$1'),
  __name(toValue$2, 'toValue$2')
var FilterMatchMode = {
    STARTS_WITH: 'startsWith',
    CONTAINS: 'contains',
    NOT_CONTAINS: 'notContains',
    ENDS_WITH: 'endsWith',
    EQUALS: 'equals',
    NOT_EQUALS: 'notEquals',
    IN: 'in',
    LESS_THAN: 'lt',
    LESS_THAN_OR_EQUAL_TO: 'lte',
    GREATER_THAN: 'gt',
    GREATER_THAN_OR_EQUAL_TO: 'gte',
    BETWEEN: 'between',
    DATE_IS: 'dateIs',
    DATE_IS_NOT: 'dateIsNot',
    DATE_BEFORE: 'dateBefore',
    DATE_AFTER: 'dateAfter'
  },
  FilterOperator = { AND: 'and', OR: 'or' }
function _createForOfIteratorHelper$4(e, t) {
  var n =
    ('undefined' != typeof Symbol && e[Symbol.iterator]) || e['@@iterator']
  if (!n) {
    if (Array.isArray(e) || (n = _unsupportedIterableToArray$i(e)) || t) {
      n && (e = n)
      var o = 0,
        i = __name(function () {}, 'F')
      return {
        s: i,
        n: __name(function () {
          return o >= e.length ? { done: !0 } : { done: !1, value: e[o++] }
        }, 'n'),
        e: __name(function (e) {
          throw e
        }, 'e'),
        f: i
      }
    }
    throw new TypeError(
      'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
    )
  }
  var r,
    a = !0,
    s = !1
  return {
    s: __name(function () {
      n = n.call(e)
    }, 's'),
    n: __name(function () {
      var e = n.next()
      return (a = e.done), e
    }, 'n'),
    e: __name(function (e) {
      ;(s = !0), (r = e)
    }, 'e'),
    f: __name(function () {
      try {
        a || null == n.return || n.return()
      } finally {
        if (s) throw r
      }
    }, 'f')
  }
}
function _unsupportedIterableToArray$i(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$i(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$i(e, t)
          : void 0
    )
  }
}
function _arrayLikeToArray$i(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
__name(_createForOfIteratorHelper$4, '_createForOfIteratorHelper$4'),
  __name(_unsupportedIterableToArray$i, '_unsupportedIterableToArray$i'),
  __name(_arrayLikeToArray$i, '_arrayLikeToArray$i')
var FilterService = {
    filter: __name(function (e, t, n, o, i) {
      var r = []
      if (!e) return r
      var a,
        s = _createForOfIteratorHelper$4(e)
      try {
        for (s.s(); !(a = s.n()).done; ) {
          var l = a.value
          if ('string' == typeof l) {
            if (this.filters[o](l, n, i)) {
              r.push(l)
              continue
            }
          } else {
            var c,
              d = _createForOfIteratorHelper$4(t)
            try {
              for (d.s(); !(c = d.n()).done; ) {
                var u = resolveFieldData(l, c.value)
                if (this.filters[o](u, n, i)) {
                  r.push(l)
                  break
                }
              }
            } catch (p) {
              d.e(p)
            } finally {
              d.f()
            }
          }
        }
      } catch (p) {
        s.e(p)
      } finally {
        s.f()
      }
      return r
    }, 'filter'),
    filters: {
      startsWith: __name(function (e, t, n) {
        if (null == t || '' === t) return !0
        if (null == e) return !1
        var o = removeAccents(t.toString()).toLocaleLowerCase(n)
        return (
          removeAccents(e.toString())
            .toLocaleLowerCase(n)
            .slice(0, o.length) === o
        )
      }, 'startsWith'),
      contains: __name(function (e, t, n) {
        if (null == t || '' === t) return !0
        if (null == e) return !1
        var o = removeAccents(t.toString()).toLocaleLowerCase(n)
        return (
          -1 !== removeAccents(e.toString()).toLocaleLowerCase(n).indexOf(o)
        )
      }, 'contains'),
      notContains: __name(function (e, t, n) {
        if (null == t || '' === t) return !0
        if (null == e) return !1
        var o = removeAccents(t.toString()).toLocaleLowerCase(n)
        return (
          -1 === removeAccents(e.toString()).toLocaleLowerCase(n).indexOf(o)
        )
      }, 'notContains'),
      endsWith: __name(function (e, t, n) {
        if (null == t || '' === t) return !0
        if (null == e) return !1
        var o = removeAccents(t.toString()).toLocaleLowerCase(n),
          i = removeAccents(e.toString()).toLocaleLowerCase(n)
        return -1 !== i.indexOf(o, i.length - o.length)
      }, 'endsWith'),
      equals: __name(function (e, t, n) {
        return (
          null == t ||
          '' === t ||
          (null != e &&
            (e.getTime && t.getTime
              ? e.getTime() === t.getTime()
              : removeAccents(e.toString()).toLocaleLowerCase(n) ==
                removeAccents(t.toString()).toLocaleLowerCase(n)))
        )
      }, 'equals'),
      notEquals: __name(function (e, t, n) {
        return (
          null != t &&
          '' !== t &&
          (null == e ||
            (e.getTime && t.getTime
              ? e.getTime() !== t.getTime()
              : removeAccents(e.toString()).toLocaleLowerCase(n) !=
                removeAccents(t.toString()).toLocaleLowerCase(n)))
        )
      }, 'notEquals'),
      in: __name(function (e, t) {
        if (null == t || 0 === t.length) return !0
        for (var n = 0; n < t.length; n++) if (equals(e, t[n])) return !0
        return !1
      }, '_in'),
      between: __name(function (e, t) {
        return (
          null == t ||
          null == t[0] ||
          null == t[1] ||
          (null != e &&
            (e.getTime
              ? t[0].getTime() <= e.getTime() && e.getTime() <= t[1].getTime()
              : t[0] <= e && e <= t[1]))
        )
      }, 'between'),
      lt: __name(function (e, t) {
        return (
          null == t ||
          (null != e &&
            (e.getTime && t.getTime ? e.getTime() < t.getTime() : e < t))
        )
      }, 'lt'),
      lte: __name(function (e, t) {
        return (
          null == t ||
          (null != e &&
            (e.getTime && t.getTime ? e.getTime() <= t.getTime() : e <= t))
        )
      }, 'lte'),
      gt: __name(function (e, t) {
        return (
          null == t ||
          (null != e &&
            (e.getTime && t.getTime ? e.getTime() > t.getTime() : e > t))
        )
      }, 'gt'),
      gte: __name(function (e, t) {
        return (
          null == t ||
          (null != e &&
            (e.getTime && t.getTime ? e.getTime() >= t.getTime() : e >= t))
        )
      }, 'gte'),
      dateIs: __name(function (e, t) {
        return null == t || (null != e && e.toDateString() === t.toDateString())
      }, 'dateIs'),
      dateIsNot: __name(function (e, t) {
        return null == t || (null != e && e.toDateString() !== t.toDateString())
      }, 'dateIsNot'),
      dateBefore: __name(function (e, t) {
        return null == t || (null != e && e.getTime() < t.getTime())
      }, 'dateBefore'),
      dateAfter: __name(function (e, t) {
        return null == t || (null != e && e.getTime() > t.getTime())
      }, 'dateAfter')
    },
    register: __name(function (e, t) {
      this.filters[e] = t
    }, 'register')
  },
  PrimeIcons = {
    ALIGN_CENTER: 'pi pi-align-center',
    ALIGN_JUSTIFY: 'pi pi-align-justify',
    ALIGN_LEFT: 'pi pi-align-left',
    ALIGN_RIGHT: 'pi pi-align-right',
    AMAZON: 'pi pi-amazon',
    ANDROID: 'pi pi-android',
    ANGLE_DOUBLE_DOWN: 'pi pi-angle-double-down',
    ANGLE_DOUBLE_LEFT: 'pi pi-angle-double-left',
    ANGLE_DOUBLE_RIGHT: 'pi pi-angle-double-right',
    ANGLE_DOUBLE_UP: 'pi pi-angle-double-up',
    ANGLE_DOWN: 'pi pi-angle-down',
    ANGLE_LEFT: 'pi pi-angle-left',
    ANGLE_RIGHT: 'pi pi-angle-right',
    ANGLE_UP: 'pi pi-angle-up',
    APPLE: 'pi pi-apple',
    ARROW_CIRCLE_DOWN: 'pi pi-arrow-circle-down',
    ARROW_CIRCLE_LEFT: 'pi pi-arrow-circle-left',
    ARROW_CIRCLE_RIGHT: 'pi pi-arrow-circle-right',
    ARROW_CIRCLE_UP: 'pi pi-arrow-circle-up',
    ARROW_DOWN: 'pi pi-arrow-down',
    ARROW_DOWN_LEFT: 'pi pi-arrow-down-left',
    ARROW_DOWN_RIGHT: 'pi pi-arrow-down-right',
    ARROW_LEFT: 'pi pi-arrow-left',
    ARROW_RIGHT: 'pi pi-arrow-right',
    ARROW_RIGHT_ARROW_LEFT: 'pi pi-arrow-right-arrow-left',
    ARROW_UP: 'pi pi-arrow-up',
    ARROW_UP_LEFT: 'pi pi-arrow-up-left',
    ARROW_UP_RIGHT: 'pi pi-arrow-up-right',
    ARROWS_H: 'pi pi-arrows-h',
    ARROWS_V: 'pi pi-arrows-v',
    ARROWS_ALT: 'pi pi-arrows-alt',
    AT: 'pi pi-at',
    BACKWARD: 'pi pi-backward',
    BAN: 'pi pi-ban',
    BARS: 'pi pi-bars',
    BELL: 'pi pi-bell',
    BITCOIN: 'pi pi-bitcoin',
    BOLT: 'pi pi-bolt',
    BOOK: 'pi pi-book',
    BOOKMARK: 'pi pi-bookmark',
    BOOKMARK_FILL: 'pi pi-bookmark-fill',
    BOX: 'pi pi-box',
    BRIEFCASE: 'pi pi-briefcase',
    BUILDING: 'pi pi-building',
    CALENDAR: 'pi pi-calendar',
    CALENDAR_MINUS: 'pi pi-calendar-minus',
    CALENDAR_PLUS: 'pi pi-calendar-plus',
    CALENDAR_TIMES: 'pi pi-calendar-times',
    CALCULATOR: 'pi pi-calculator',
    CAMERA: 'pi pi-camera',
    CAR: 'pi pi-car',
    CARET_DOWN: 'pi pi-caret-down',
    CARET_LEFT: 'pi pi-caret-left',
    CARET_RIGHT: 'pi pi-caret-right',
    CARET_UP: 'pi pi-caret-up',
    CART_PLUS: 'pi pi-cart-plus',
    CHART_BAR: 'pi pi-chart-bar',
    CHART_LINE: 'pi pi-chart-line',
    CHART_PIE: 'pi pi-chart-pie',
    CHECK: 'pi pi-check',
    CHECK_CIRCLE: 'pi pi-check-circle',
    CHECK_SQUARE: 'pi pi-check-square',
    CHEVRON_CIRCLE_DOWN: 'pi pi-chevron-circle-down',
    CHEVRON_CIRCLE_LEFT: 'pi pi-chevron-circle-left',
    CHEVRON_CIRCLE_RIGHT: 'pi pi-chevron-circle-right',
    CHEVRON_CIRCLE_UP: 'pi pi-chevron-circle-up',
    CHEVRON_DOWN: 'pi pi-chevron-down',
    CHEVRON_LEFT: 'pi pi-chevron-left',
    CHEVRON_RIGHT: 'pi pi-chevron-right',
    CHEVRON_UP: 'pi pi-chevron-up',
    CIRCLE: 'pi pi-circle',
    CIRCLE_FILL: 'pi pi-circle-fill',
    CLOCK: 'pi pi-clock',
    CLONE: 'pi pi-clone',
    CLOUD: 'pi pi-cloud',
    CLOUD_DOWNLOAD: 'pi pi-cloud-download',
    CLOUD_UPLOAD: 'pi pi-cloud-upload',
    CODE: 'pi pi-code',
    COG: 'pi pi-cog',
    COMMENT: 'pi pi-comment',
    COMMENTS: 'pi pi-comments',
    COMPASS: 'pi pi-compass',
    COPY: 'pi pi-copy',
    CREDIT_CARD: 'pi pi-credit-card',
    DATABASE: 'pi pi-database',
    DELETELEFT: 'pi pi-delete-left',
    DESKTOP: 'pi pi-desktop',
    DIRECTIONS: 'pi pi-directions',
    DIRECTIONS_ALT: 'pi pi-directions-alt',
    DISCORD: 'pi pi-discord',
    DOLLAR: 'pi pi-dollar',
    DOWNLOAD: 'pi pi-download',
    EJECT: 'pi pi-eject',
    ELLIPSIS_H: 'pi pi-ellipsis-h',
    ELLIPSIS_V: 'pi pi-ellipsis-v',
    ENVELOPE: 'pi pi-envelope',
    ERASER: 'pi pi-eraser',
    EURO: 'pi pi-euro',
    EXCLAMATION_CIRCLE: 'pi pi-exclamation-circle',
    EXCLAMATION_TRIANGLE: 'pi pi-exclamation-triangle',
    EXTERNAL_LINK: 'pi pi-external-link',
    EYE: 'pi pi-eye',
    EYE_SLASH: 'pi pi-eye-slash',
    FACEBOOK: 'pi pi-facebook',
    FAST_BACKWARD: 'pi pi-fast-backward',
    FAST_FORWARD: 'pi pi-fast-forward',
    FILE: 'pi pi-file',
    FILE_EDIT: 'pi pi-file-edit',
    FILE_EXCEL: 'pi pi-file-excel',
    FILE_EXPORT: 'pi pi-file-export',
    FILE_IMPORT: 'pi pi-file-import',
    FILE_PDF: 'pi pi-file-pdf',
    FILE_WORD: 'pi pi-file-word',
    FILTER: 'pi pi-filter',
    FILTER_FILL: 'pi pi-filter-fill',
    FILTER_SLASH: 'pi pi-filter-slash',
    FLAG: 'pi pi-flag',
    FLAG_FILL: 'pi pi-flag-fill',
    FOLDER: 'pi pi-folder',
    FOLDER_OPEN: 'pi pi-folder-open',
    FORWARD: 'pi pi-forward',
    GIFT: 'pi pi-gift',
    GITHUB: 'pi pi-github',
    GLOBE: 'pi pi-globe',
    GOOGLE: 'pi pi-google',
    HASHTAG: 'pi pi-hashtag',
    HEART: 'pi pi-heart',
    HEART_FILL: 'pi pi-heart-fill',
    HISTORY: 'pi pi-history',
    HOURGLASS: 'pi pi-hourglass',
    HOME: 'pi pi-home',
    ID_CARD: 'pi pi-id-card',
    IMAGE: 'pi pi-image',
    IMAGES: 'pi pi-images',
    INBOX: 'pi pi-inbox',
    INFO: 'pi pi-info',
    INFO_CIRCLE: 'pi pi-info-circle',
    INSTAGRAM: 'pi pi-instagram',
    KEY: 'pi pi-key',
    LANGUAGE: 'pi pi-language',
    LINK: 'pi pi-link',
    LINKEDIN: 'pi pi-linkedin',
    LIST: 'pi pi-list',
    LOCK: 'pi pi-lock',
    LOCK_OPEN: 'pi pi-lock-open',
    MAP: 'pi pi-map',
    MAP_MARKER: 'pi pi-map-marker',
    MEGAPHONE: 'pi pi-megaphone',
    MICROPHONE: 'pi pi-microphone',
    MICROSOFT: 'pi pi-microsoft',
    MINUS: 'pi pi-minus',
    MINUS_CIRCLE: 'pi pi-minus-circle',
    MOBILE: 'pi pi-mobile',
    MONEY_BILL: 'pi pi-money-bill',
    MOON: 'pi pi-moon',
    PALETTE: 'pi pi-palette',
    PAPERCLIP: 'pi pi-paperclip',
    PAUSE: 'pi pi-pause',
    PAYPAL: 'pi pi-paypal',
    PENCIL: 'pi pi-pencil',
    PERCENTAGE: 'pi pi-percentage',
    PHONE: 'pi pi-phone',
    PLAY: 'pi pi-play',
    PLUS: 'pi pi-plus',
    PLUS_CIRCLE: 'pi pi-plus-circle',
    POUND: 'pi pi-pound',
    POWER_OFF: 'pi pi-power-off',
    PRIME: 'pi pi-prime',
    PRINT: 'pi pi-print',
    QRCODE: 'pi pi-qrcode',
    QUESTION: 'pi pi-question',
    QUESTION_CIRCLE: 'pi pi-question-circle',
    REDDIT: 'pi pi-reddit',
    REFRESH: 'pi pi-refresh',
    REPLAY: 'pi pi-replay',
    REPLY: 'pi pi-reply',
    SAVE: 'pi pi-save',
    SEARCH: 'pi pi-search',
    SEARCH_MINUS: 'pi pi-search-minus',
    SEARCH_PLUS: 'pi pi-search-plus',
    SEND: 'pi pi-send',
    SERVER: 'pi pi-server',
    SHARE_ALT: 'pi pi-share-alt',
    SHIELD: 'pi pi-shield',
    SHOPPING_BAG: 'pi pi-shopping-bag',
    SHOPPING_CART: 'pi pi-shopping-cart',
    SIGN_IN: 'pi pi-sign-in',
    SIGN_OUT: 'pi pi-sign-out',
    SITEMAP: 'pi pi-sitemap',
    SLACK: 'pi pi-slack',
    SLIDERS_H: 'pi pi-sliders-h',
    SLIDERS_V: 'pi pi-sliders-v',
    SORT: 'pi pi-sort',
    SORT_ALPHA_DOWN: 'pi pi-sort-alpha-down',
    SORT_ALPHA_DOWN_ALT: 'pi pi-sort-alpha-down-alt',
    SORT_ALPHA_UP: 'pi pi-sort-alpha-up',
    SORT_ALPHA_UP_ALT: 'pi pi-sort-alpha-up-alt',
    SORT_ALT: 'pi pi-sort-alt',
    SORT_ALT_SLASH: 'pi pi-sort-alt-slash',
    SORT_AMOUNT_DOWN: 'pi pi-sort-amount-down',
    SORT_AMOUNT_DOWN_ALT: 'pi pi-sort-amount-down-alt',
    SORT_AMOUNT_UP: 'pi pi-sort-amount-up',
    SORT_AMOUNT_UP_ALT: 'pi pi-sort-amount-up-alt',
    SORT_DOWN: 'pi pi-sort-down',
    SORT_NUMERIC_DOWN: 'pi pi-sort-numeric-down',
    SORT_NUMERIC_DOWN_ALT: 'pi pi-sort-numeric-down-alt',
    SORT_NUMERIC_UP: 'pi pi-sort-numeric-up',
    SORT_NUMERIC_UP_ALT: 'pi pi-sort-numeric-up-alt',
    SORT_UP: 'pi pi-sort-up',
    SPINNER: 'pi pi-spinner',
    STAR: 'pi pi-star',
    STAR_FILL: 'pi pi-star-fill',
    STEP_BACKWARD: 'pi pi-step-backward',
    STEP_BACKWARD_ALT: 'pi pi-step-backward-alt',
    STEP_FORWARD: 'pi pi-step-forward',
    STEP_FORWARD_ALT: 'pi pi-step-forward-alt',
    STOP: 'pi pi-stop',
    STOPWATCH: 'pi pi-stopwatch',
    STOP_CIRCLE: 'pi pi-stop-circle',
    SUN: 'pi pi-sun',
    SYNC: 'pi pi-sync',
    TABLE: 'pi pi-table',
    TABLET: 'pi pi-tablet',
    TAG: 'pi pi-tag',
    TAGS: 'pi pi-tags',
    TELEGRAM: 'pi pi-telegram',
    TH_LARGE: 'pi pi-th-large',
    THUMBS_DOWN: 'pi pi-thumbs-down',
    THUMBS_DOWN_FILL: 'pi pi-thumbs-down-fill',
    THUMBS_UP: 'pi pi-thumbs-up',
    THUMBS_UP_FILL: 'pi pi-thumbs-up-fill',
    TICKET: 'pi pi-ticket',
    TIMES: 'pi pi-times',
    TIMES_CIRCLE: 'pi pi-times-circle',
    TRASH: 'pi pi-trash',
    TRUCK: 'pi pi-truck',
    TWITTER: 'pi pi-twitter',
    UNDO: 'pi pi-undo',
    UNLOCK: 'pi pi-unlock',
    UPLOAD: 'pi pi-upload',
    USER: 'pi pi-user',
    USER_EDIT: 'pi pi-user-edit',
    USER_MINUS: 'pi pi-user-minus',
    USER_PLUS: 'pi pi-user-plus',
    USERS: 'pi pi-users',
    VERIFIED: 'pi pi-verified',
    VIDEO: 'pi pi-video',
    VIMEO: 'pi pi-vimeo',
    VOLUME_DOWN: 'pi pi-volume-down',
    VOLUME_OFF: 'pi pi-volume-off',
    VOLUME_UP: 'pi pi-volume-up',
    WALLET: 'pi pi-wallet',
    WHATSAPP: 'pi pi-whatsapp',
    WIFI: 'pi pi-wifi',
    WINDOW_MAXIMIZE: 'pi pi-window-maximize',
    WINDOW_MINIMIZE: 'pi pi-window-minimize',
    WRENCH: 'pi pi-wrench',
    YOUTUBE: 'pi pi-youtube'
  },
  ToastSeverities = {
    INFO: 'info',
    WARN: 'warn',
    ERROR: 'error',
    SUCCESS: 'success'
  }
function classNames(...e) {
  if (e) {
    let t = []
    for (let n = 0; n < e.length; n++) {
      let o = e[n]
      if (!o) continue
      const i = typeof o
      if ('string' === i || 'number' === i) t.push(o)
      else if ('object' === i) {
        const e = Array.isArray(o)
          ? [classNames(...o)]
          : Object.entries(o).map(([e, t]) => (t ? e : void 0))
        t = e.length ? t.concat(e.filter((e) => !!e)) : t
      }
    }
    return t.join(' ').trim()
  }
}
function EventBus() {
  const e = new Map()
  return {
    on(t, n) {
      let o = e.get(t)
      return o ? o.push(n) : (o = [n]), e.set(t, o), this
    },
    off(t, n) {
      let o = e.get(t)
      return o && o.splice(o.indexOf(n) >>> 0, 1), this
    },
    emit(t, n) {
      let o = e.get(t)
      o &&
        o.slice().map((e) => {
          e(n)
        })
    },
    clear() {
      e.clear()
    }
  }
}
__name(classNames, 'classNames'), __name(EventBus, 'EventBus')
var __defProp$1 = Object.defineProperty,
  __getOwnPropSymbols$1 = Object.getOwnPropertySymbols,
  __hasOwnProp$1 = Object.prototype.hasOwnProperty,
  __propIsEnum$1 = Object.prototype.propertyIsEnumerable,
  __defNormalProp$1 = __name(
    (e, t, n) =>
      t in e
        ? __defProp$1(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n
          })
        : (e[t] = n),
    '__defNormalProp$1'
  ),
  __spreadValues$1 = __name((e, t) => {
    for (var n in t || (t = {}))
      __hasOwnProp$1.call(t, n) && __defNormalProp$1(e, n, t[n])
    if (__getOwnPropSymbols$1)
      for (var n of __getOwnPropSymbols$1(t))
        __propIsEnum$1.call(t, n) && __defNormalProp$1(e, n, t[n])
    return e
  }, '__spreadValues$1')
function isFunction(e) {
  return !!(e && e.constructor && e.call && e.apply)
}
function mergeProps(...e) {
  return null == e
    ? void 0
    : e.reduce((e, t = {}) => {
        for (const n in t) {
          const o = t[n]
          if ('style' === n)
            e.style = __spreadValues$1(__spreadValues$1({}, e.style), t.style)
          else if ('class' === n)
            e.class = [e.class, t.class].join(' ').trim() || void 0
          else if ('className' === n)
            e.className = [e.className, t.className].join(' ').trim() || void 0
          else if (isFunction(o)) {
            const t = e[n]
            e[n] = t
              ? (...e) => {
                  t(...e), o(...e)
                }
              : o
          } else e[n] = o
        }
        return e
      }, {})
}
__name(isFunction, 'isFunction'), __name(mergeProps, 'mergeProps')
var lastIds = {}
function uuid(e = 'pui_id_') {
  return (
    lastIds.hasOwnProperty(e) || (lastIds[e] = 0),
    lastIds[e]++,
    `${e}${lastIds[e]}`
  )
}
function handler() {
  let e = []
  const t = __name((t, n, o = 999) => {
      const r = i(t, n, o),
        a = r.value + (r.key === t ? 0 : o) + 1
      return e.push({ key: t, value: a }), a
    }, 'generateZIndex'),
    n = __name((t) => {
      e = e.filter((e) => e.value !== t)
    }, 'revertZIndex'),
    o = __name((e, t) => i(e, t).value, 'getCurrentZIndex'),
    i = __name(
      (t, n, o = 0) =>
        [...e].reverse().find((e) => !!n || e.key === t) || {
          key: t,
          value: o
        },
      'getLastZIndex'
    ),
    r = __name((e) => (e && parseInt(e.style.zIndex, 10)) || 0, 'getZIndex')
  return {
    get: r,
    set: __name((e, n, o) => {
      n && (n.style.zIndex = String(t(e, !0, o)))
    }, 'set'),
    clear: __name((e) => {
      e && (n(r(e)), (e.style.zIndex = ''))
    }, 'clear'),
    getCurrent: __name((e) => o(e, !0), 'getCurrent')
  }
}
__name(uuid, 'uuid'), __name(handler, 'handler')
var ZIndex = handler()
function _typeof$1$3(e) {
  return (_typeof$1$3 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function _classCallCheck$1(e, t) {
  if (!(e instanceof t))
    throw new TypeError('Cannot call a class as a function')
}
function _defineProperties$1(e, t) {
  for (var n = 0; n < t.length; n++) {
    var o = t[n]
    ;(o.enumerable = o.enumerable || !1),
      (o.configurable = !0),
      'value' in o && (o.writable = !0),
      Object.defineProperty(e, _toPropertyKey$1$3(o.key), o)
  }
}
function _createClass$1(e, t, n) {
  return (
    t && _defineProperties$1(e.prototype, t),
    Object.defineProperty(e, 'prototype', { writable: !1 }),
    e
  )
}
function _toPropertyKey$1$3(e) {
  var t = _toPrimitive$1$3(e, 'string')
  return 'symbol' == _typeof$1$3(t) ? t : t + ''
}
function _toPrimitive$1$3(e, t) {
  if ('object' != _typeof$1$3(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t)
    if ('object' != _typeof$1$3(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return String(e)
}
__name(_typeof$1$3, '_typeof$1$3'),
  __name(_classCallCheck$1, '_classCallCheck$1'),
  __name(_defineProperties$1, '_defineProperties$1'),
  __name(_createClass$1, '_createClass$1'),
  __name(_toPropertyKey$1$3, '_toPropertyKey$1$3'),
  __name(_toPrimitive$1$3, '_toPrimitive$1$3')
var ConnectedOverlayScrollHandler = (function () {
  function e(t) {
    var n =
      arguments.length > 1 && void 0 !== arguments[1]
        ? arguments[1]
        : function () {}
    _classCallCheck$1(this, e), (this.element = t), (this.listener = n)
  }
  return (
    __name(e, 'ConnectedOverlayScrollHandler'),
    _createClass$1(e, [
      {
        key: 'bindScrollListener',
        value: __name(function () {
          this.scrollableParents = getScrollableParents(this.element)
          for (var e = 0; e < this.scrollableParents.length; e++)
            this.scrollableParents[e].addEventListener('scroll', this.listener)
        }, 'bindScrollListener')
      },
      {
        key: 'unbindScrollListener',
        value: __name(function () {
          if (this.scrollableParents)
            for (var e = 0; e < this.scrollableParents.length; e++)
              this.scrollableParents[e].removeEventListener(
                'scroll',
                this.listener
              )
        }, 'unbindScrollListener')
      },
      {
        key: 'destroy',
        value: __name(function () {
          this.unbindScrollListener(),
            (this.element = null),
            (this.listener = null),
            (this.scrollableParents = null)
        }, 'destroy')
      }
    ])
  )
})()
function _typeof$l(e) {
  return (_typeof$l =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function _toConsumableArray$b(e) {
  return (
    _arrayWithoutHoles$b(e) ||
    _iterableToArray$c(e) ||
    _unsupportedIterableToArray$h(e) ||
    _nonIterableSpread$b()
  )
}
function _nonIterableSpread$b() {
  throw new TypeError(
    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$h(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$h(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$h(e, t)
          : void 0
    )
  }
}
function _iterableToArray$c(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _arrayWithoutHoles$b(e) {
  if (Array.isArray(e)) return _arrayLikeToArray$h(e)
}
function _arrayLikeToArray$h(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
function _classCallCheck(e, t) {
  if (!(e instanceof t))
    throw new TypeError('Cannot call a class as a function')
}
function _defineProperties(e, t) {
  for (var n = 0; n < t.length; n++) {
    var o = t[n]
    ;(o.enumerable = o.enumerable || !1),
      (o.configurable = !0),
      'value' in o && (o.writable = !0),
      Object.defineProperty(e, _toPropertyKey$k(o.key), o)
  }
}
function _createClass(e, t, n) {
  return (
    t && _defineProperties(e.prototype, t),
    Object.defineProperty(e, 'prototype', { writable: !1 }),
    e
  )
}
function _defineProperty$l(e, t, n) {
  return (
    (t = _toPropertyKey$k(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$k(e) {
  var t = _toPrimitive$k(e, 'string')
  return 'symbol' == _typeof$l(t) ? t : t + ''
}
function _toPrimitive$k(e, t) {
  if ('object' != _typeof$l(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t)
    if ('object' != _typeof$l(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return String(e)
}
__name(_typeof$l, '_typeof$l'),
  __name(_toConsumableArray$b, '_toConsumableArray$b'),
  __name(_nonIterableSpread$b, '_nonIterableSpread$b'),
  __name(_unsupportedIterableToArray$h, '_unsupportedIterableToArray$h'),
  __name(_iterableToArray$c, '_iterableToArray$c'),
  __name(_arrayWithoutHoles$b, '_arrayWithoutHoles$b'),
  __name(_arrayLikeToArray$h, '_arrayLikeToArray$h'),
  __name(_classCallCheck, '_classCallCheck'),
  __name(_defineProperties, '_defineProperties'),
  __name(_createClass, '_createClass'),
  __name(_defineProperty$l, '_defineProperty$l'),
  __name(_toPropertyKey$k, '_toPropertyKey$k'),
  __name(_toPrimitive$k, '_toPrimitive$k')
var _default = (function () {
  function e(t) {
    var n = t.init,
      o = t.type
    _classCallCheck(this, e),
      _defineProperty$l(this, 'helpers', void 0),
      _defineProperty$l(this, 'type', void 0),
      (this.helpers = new Set(n)),
      (this.type = o)
  }
  return (
    __name(e, '_default'),
    _createClass(e, [
      {
        key: 'add',
        value: __name(function (e) {
          this.helpers.add(e)
        }, 'add')
      },
      { key: 'update', value: __name(function () {}, 'update') },
      {
        key: 'delete',
        value: __name(function (e) {
          this.helpers.delete(e)
        }, '_delete')
      },
      {
        key: 'clear',
        value: __name(function () {
          this.helpers.clear()
        }, 'clear')
      },
      {
        key: 'get',
        value: __name(function (e, t) {
          var n = this._get(e, t),
            o = n
              ? this._recursive(_toConsumableArray$b(this.helpers), n)
              : null
          return isNotEmpty(o) ? o : null
        }, 'get')
      },
      {
        key: '_isMatched',
        value: __name(function (e, t) {
          var n,
            o = null == e ? void 0 : e.parent
          return (
            (null == o || null === (n = o.vnode) || void 0 === n
              ? void 0
              : n.key) === t ||
            (o && this._isMatched(o, t)) ||
            !1
          )
        }, '_isMatched')
      },
      {
        key: '_get',
        value: __name(function (e, t) {
          var n, o
          return (
            (null === (n = t || (null == e ? void 0 : e.$slots)) ||
            void 0 === n ||
            null === (o = n.default) ||
            void 0 === o
              ? void 0
              : o.call(n)) || null
          )
        }, '_get')
      },
      {
        key: '_recursive',
        value: __name(function () {
          var e = this,
            t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : [],
            n = []
          return (
            (arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : []
            ).forEach(function (o) {
              o.children instanceof Array
                ? (n = n.concat(e._recursive(n, o.children)))
                : o.type.name === e.type
                  ? n.push(o)
                  : isNotEmpty(o.key) &&
                    (n = n.concat(
                      t
                        .filter(function (t) {
                          return e._isMatched(t, o.key)
                        })
                        .map(function (e) {
                          return e.vnode
                        })
                    ))
            }),
            n
          )
        }, '_recursive')
      }
    ])
  )
})()
function UniqueComponentId() {
  return uuid(
    arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'pv_id_'
  )
}
function getVNodeProp(e, t) {
  if (e) {
    var n = e.props
    if (n) {
      var o = t.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(),
        i = Object.prototype.hasOwnProperty.call(n, o) ? o : t
      return (e.type.extends.props[t].type === Boolean && '' === n[i]) || n[i]
    }
  }
  return null
}
__name(UniqueComponentId, 'UniqueComponentId'),
  __name(getVNodeProp, 'getVNodeProp')
var __defProp = Object.defineProperty,
  __defProps = Object.defineProperties,
  __getOwnPropDescs = Object.getOwnPropertyDescriptors,
  __getOwnPropSymbols = Object.getOwnPropertySymbols,
  __hasOwnProp = Object.prototype.hasOwnProperty,
  __propIsEnum = Object.prototype.propertyIsEnumerable,
  __defNormalProp = __name(
    (e, t, n) =>
      t in e
        ? __defProp(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n
          })
        : (e[t] = n),
    '__defNormalProp'
  ),
  __spreadValues = __name((e, t) => {
    for (var n in t || (t = {}))
      __hasOwnProp.call(t, n) && __defNormalProp(e, n, t[n])
    if (__getOwnPropSymbols)
      for (var n of __getOwnPropSymbols(t))
        __propIsEnum.call(t, n) && __defNormalProp(e, n, t[n])
    return e
  }, '__spreadValues'),
  __spreadProps = __name(
    (e, t) => __defProps(e, __getOwnPropDescs(t)),
    '__spreadProps'
  ),
  __objRest = __name((e, t) => {
    var n = {}
    for (var o in e)
      __hasOwnProp.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o])
    if (null != e && __getOwnPropSymbols)
      for (var o of __getOwnPropSymbols(e))
        t.indexOf(o) < 0 && __propIsEnum.call(e, o) && (n[o] = e[o])
    return n
  }, '__objRest')
function definePreset(...e) {
  return mergeKeys(...e)
}
__name(definePreset, 'definePreset')
var ThemeService = EventBus(),
  service_default = ThemeService
function toTokenKey(e) {
  return isString$1(e)
    ? e
        .replace(/[A-Z]/g, (e, t) => (0 === t ? e : '.' + e.toLowerCase()))
        .toLowerCase()
    : e
}
function merge(e, t) {
  isArray$1(e) ? e.push(...(t || [])) : isObject$2(e) && Object.assign(e, t)
}
function toValue$1(e) {
  return isObject$2(e) && e.hasOwnProperty('value') && e.hasOwnProperty('type')
    ? e.value
    : e
}
function toUnit(e, t = '') {
  if (
    ![
      'opacity',
      'z-index',
      'line-height',
      'font-weight',
      'flex',
      'flex-grow',
      'flex-shrink',
      'order'
    ].some((e) => t.endsWith(e))
  ) {
    return `${e}`
      .trim()
      .split(' ')
      .map((e) => (isNumber$1(e) ? `${e}px` : e))
      .join(' ')
  }
  return e
}
function toNormalizePrefix(e) {
  return e.replaceAll(/ /g, '').replace(/[^\w]/g, '-')
}
function toNormalizeVariable(e = '', t = '') {
  return toNormalizePrefix(
    `${isString$1(e, !1) && isString$1(t, !1) ? `${e}-` : e}${t}`
  )
}
function getVariableName(e = '', t = '') {
  return `--${toNormalizeVariable(e, t)}`
}
function hasOddBraces(e = '') {
  return ((e.match(/{/g) || []).length + (e.match(/}/g) || []).length) % 2 != 0
}
function getVariableValue(e, t = '', n = '', o = [], i) {
  if (isString$1(e)) {
    const t = /{([^}]*)}/g,
      r = e.trim()
    if (hasOddBraces(r)) return
    if (matchRegex(r, t)) {
      const e = r.replaceAll(t, (e) => {
          const t = e
            .replace(/{|}/g, '')
            .split('.')
            .filter((e) => !o.some((t) => matchRegex(e, t)))
          return `var(${getVariableName(n, toKebabCase(t.join('-')))}${isNotEmpty(i) ? `, ${i}` : ''})`
        }),
        a = /(\d+\s+[\+\-\*\/]\s+\d+)/g,
        s = /var\([^)]+\)/g
      return matchRegex(e.replace(s, '0'), a) ? `calc(${e})` : e
    }
    return r
  }
  if (isNumber$1(e)) return e
}
function getComputedValue(e = {}, t) {
  if (isString$1(t)) {
    const n = /{([^}]*)}/g,
      o = t.trim()
    return matchRegex(o, n)
      ? o.replaceAll(n, (t) => getKeyValue(e, t.replace(/{|}/g, '')))
      : o
  }
  if (isNumber$1(t)) return t
}
function setProperty(e, t, n) {
  isString$1(t, !1) && e.push(`${t}:${n};`)
}
function getRule(e, t) {
  return e ? `${e}{${t}}` : ''
}
function normalizeColor(e) {
  return 4 === e.length ? `#${e[1]}${e[1]}${e[2]}${e[2]}${e[3]}${e[3]}` : e
}
function hexToRgb$1(e) {
  var t = parseInt(e.substring(1), 16)
  return { r: (t >> 16) & 255, g: (t >> 8) & 255, b: 255 & t }
}
function rgbToHex(e, t, n) {
  return `#${e.toString(16).padStart(2, '0')}${t.toString(16).padStart(2, '0')}${n.toString(16).padStart(2, '0')}`
}
__name(toTokenKey, 'toTokenKey'),
  __name(merge, 'merge'),
  __name(toValue$1, 'toValue$1'),
  __name(toUnit, 'toUnit'),
  __name(toNormalizePrefix, 'toNormalizePrefix'),
  __name(toNormalizeVariable, 'toNormalizeVariable'),
  __name(getVariableName, 'getVariableName'),
  __name(hasOddBraces, 'hasOddBraces'),
  __name(getVariableValue, 'getVariableValue'),
  __name(getComputedValue, 'getComputedValue'),
  __name(setProperty, 'setProperty'),
  __name(getRule, 'getRule'),
  __name(normalizeColor, 'normalizeColor'),
  __name(hexToRgb$1, 'hexToRgb$1'),
  __name(rgbToHex, 'rgbToHex')
var mix_default = __name((e, t, n) => {
    ;(e = normalizeColor(e)), (t = normalizeColor(t))
    var o = (2 * (n / 100) - 1 + 1) / 2,
      i = 1 - o,
      r = hexToRgb$1(e),
      a = hexToRgb$1(t)
    return rgbToHex(
      Math.round(r.r * o + a.r * i),
      Math.round(r.g * o + a.g * i),
      Math.round(r.b * o + a.b * i)
    )
  }, 'mix_default'),
  shade_default = __name(
    (e, t) => mix_default('#000000', e, t),
    'shade_default'
  ),
  tint_default = __name((e, t) => mix_default('#ffffff', e, t), 'tint_default'),
  scales = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950],
  palette_default = __name((e) => {
    if (/{([^}]*)}/g.test(e)) {
      const t = e.replace(/{|}/g, '')
      return scales.reduce((e, n) => ((e[n] = `{${t}.${n}}`), e), {})
    }
    return 'string' == typeof e
      ? scales.reduce(
          (t, n, o) => (
            (t[n] =
              o <= 5
                ? tint_default(e, 19 * (5 - o))
                : shade_default(e, 15 * (o - 5))),
            t
          ),
          {}
        )
      : e
  }, 'palette_default'),
  $dt = __name((e) => {
    var t
    const n = config_default.getTheme(),
      o = dtwt(n, e, void 0, 'variable')
    return {
      name:
        null == (t = null == o ? void 0 : o.match(/--[\w-]+/g)) ? void 0 : t[0],
      variable: o,
      value: dtwt(n, e, void 0, 'value')
    }
  }, '$dt'),
  dt = __name((...e) => dtwt(config_default.getTheme(), ...e), 'dt'),
  dtwt = __name((e = {}, t, n, o) => {
    if (t) {
      const { variable: i, options: r } = config_default.defaults || {},
        { prefix: a, transform: s } =
          (null == e ? void 0 : e.options) || r || {},
        l = matchRegex(t, /{([^}]*)}/g) ? t : `{${t}}`
      return 'value' === o || (isEmpty(o) && 'strict' === s)
        ? config_default.getTokenValue(t)
        : getVariableValue(l, void 0, a, [i.excludedKeyRegex], n)
    }
    return ''
  }, 'dtwt')
function css$3(e) {
  return resolve(e, { dt: dt })
}
__name(css$3, 'css$3')
var $t = __name((e = {}) => {
  let { preset: t, options: n } = e
  return {
    preset(e) {
      return (t = t ? mergeKeys(t, e) : e), this
    },
    options(e) {
      return (n = n ? __spreadValues(__spreadValues({}, n), e) : e), this
    },
    primaryPalette(e) {
      const { semantic: n } = t || {}
      return (
        (t = __spreadProps(__spreadValues({}, t), {
          semantic: __spreadProps(__spreadValues({}, n), { primary: e })
        })),
        this
      )
    },
    surfacePalette(e) {
      var n, o
      const { semantic: i } = t || {},
        r = (null == e ? void 0 : e.hasOwnProperty('light'))
          ? null == e
            ? void 0
            : e.light
          : e,
        a = (null == e ? void 0 : e.hasOwnProperty('dark'))
          ? null == e
            ? void 0
            : e.dark
          : e,
        s = {
          colorScheme: {
            light: __spreadValues(
              __spreadValues(
                {},
                null == (n = null == i ? void 0 : i.colorScheme)
                  ? void 0
                  : n.light
              ),
              !!r && { surface: r }
            ),
            dark: __spreadValues(
              __spreadValues(
                {},
                null == (o = null == i ? void 0 : i.colorScheme)
                  ? void 0
                  : o.dark
              ),
              !!a && { surface: a }
            )
          }
        }
      return (
        (t = __spreadProps(__spreadValues({}, t), {
          semantic: __spreadValues(__spreadValues({}, i), s)
        })),
        this
      )
    },
    define: ({ useDefaultPreset: e = !1, useDefaultOptions: o = !1 } = {}) => ({
      preset: e ? config_default.getPreset() : t,
      options: o ? config_default.getOptions() : n
    }),
    update({ mergePresets: e = !0, mergeOptions: o = !0 } = {}) {
      const i = {
        preset: e ? mergeKeys(config_default.getPreset(), t) : t,
        options: o
          ? __spreadValues(__spreadValues({}, config_default.getOptions()), n)
          : n
      }
      return config_default.setTheme(i), i
    },
    use(e) {
      const t = this.define(e)
      return config_default.setTheme(t), t
    }
  }
}, '$t')
function toVariables_default(e, t = {}) {
  const n = config_default.defaults.variable,
    {
      prefix: o = n.prefix,
      selector: i = n.selector,
      excludedKeyRegex: r = n.excludedKeyRegex
    } = t,
    a = __name(
      (e, t = '') =>
        Object.entries(e).reduce(
          (e, [n, i]) => {
            const s = matchRegex(n, r)
                ? toNormalizeVariable(t)
                : toNormalizeVariable(t, toKebabCase(n)),
              l = toValue$1(i)
            if (isObject$2(l)) {
              const { variables: t, tokens: n } = a(l, s)
              merge(e.tokens, n), merge(e.variables, t)
            } else
              e.tokens.push(
                (o ? s.replace(`${o}-`, '') : s).replaceAll('-', '.')
              ),
                setProperty(
                  e.variables,
                  getVariableName(s),
                  getVariableValue(l, s, o, [r])
                )
            return e
          },
          { variables: [], tokens: [] }
        ),
      '_toVariables'
    ),
    { variables: s, tokens: l } = a(e, o)
  return {
    value: s,
    tokens: l,
    declarations: s.join(''),
    css: getRule(i, s.join(''))
  }
}
__name(toVariables_default, 'toVariables_default')
var themeUtils_default = {
    regex: {
      rules: {
        class: {
          pattern: /^\.([a-zA-Z][\w-]*)$/,
          resolve(e) {
            return {
              type: 'class',
              selector: e,
              matched: this.pattern.test(e.trim())
            }
          }
        },
        attr: {
          pattern: /^\[(.*)\]$/,
          resolve(e) {
            return {
              type: 'attr',
              selector: `:root${e}`,
              matched: this.pattern.test(e.trim())
            }
          }
        },
        media: {
          pattern: /^@media (.*)$/,
          resolve(e) {
            return {
              type: 'media',
              selector: `${e}{:root{[CSS]}}`,
              matched: this.pattern.test(e.trim())
            }
          }
        },
        system: {
          pattern: /^system$/,
          resolve(e) {
            return {
              type: 'system',
              selector: '@media (prefers-color-scheme: dark){:root{[CSS]}}',
              matched: this.pattern.test(e.trim())
            }
          }
        },
        custom: {
          resolve: (e) => ({ type: 'custom', selector: e, matched: !0 })
        }
      },
      resolve(e) {
        const t = Object.keys(this.rules)
          .filter((e) => 'custom' !== e)
          .map((e) => this.rules[e])
        return [e].flat().map((e) => {
          var n
          return null != (n = t.map((t) => t.resolve(e)).find((e) => e.matched))
            ? n
            : this.rules.custom.resolve(e)
        })
      }
    },
    _toVariables: (e, t) =>
      toVariables_default(e, { prefix: null == t ? void 0 : t.prefix }),
    getCommon({ name: e = '', theme: t = {}, params: n, set: o, defaults: i }) {
      var r, a, s, l, c, d, u
      const { preset: p, options: h } = t
      let m, f, _, g, v, y, b
      if (isNotEmpty(p) && 'strict' !== h.transform) {
        const { primitive: t, semantic: n, extend: S } = p,
          C = n || {},
          { colorScheme: w } = C,
          k = __objRest(C, ['colorScheme']),
          x = S || {},
          { colorScheme: E } = x,
          I = __objRest(x, ['colorScheme']),
          T = w || {},
          { dark: $ } = T,
          L = __objRest(T, ['dark']),
          A = E || {},
          { dark: O } = A,
          P = __objRest(A, ['dark']),
          V = isNotEmpty(t) ? this._toVariables({ primitive: t }, h) : {},
          D = isNotEmpty(k) ? this._toVariables({ semantic: k }, h) : {},
          R = isNotEmpty(L) ? this._toVariables({ light: L }, h) : {},
          N = isNotEmpty($) ? this._toVariables({ dark: $ }, h) : {},
          M = isNotEmpty(I) ? this._toVariables({ semantic: I }, h) : {},
          B = isNotEmpty(P) ? this._toVariables({ light: P }, h) : {},
          F = isNotEmpty(O) ? this._toVariables({ dark: O }, h) : {},
          [z, H] = [null != (r = V.declarations) ? r : '', V.tokens],
          [j, U] = [null != (a = D.declarations) ? a : '', D.tokens || []],
          [G, W] = [null != (s = R.declarations) ? s : '', R.tokens || []],
          [K, Z] = [null != (l = N.declarations) ? l : '', N.tokens || []],
          [q, Y] = [null != (c = M.declarations) ? c : '', M.tokens || []],
          [X, J] = [null != (d = B.declarations) ? d : '', B.tokens || []],
          [Q, ee] = [null != (u = F.declarations) ? u : '', F.tokens || []]
        ;(m = this.transformCSS(e, z, 'light', 'variable', h, o, i)), (f = H)
        ;(_ = `${this.transformCSS(e, `${j}${G}`, 'light', 'variable', h, o, i)}${this.transformCSS(e, `${K}`, 'dark', 'variable', h, o, i)}`),
          (g = [...new Set([...U, ...W, ...Z])])
        ;(v = `${this.transformCSS(e, `${q}${X}color-scheme:light`, 'light', 'variable', h, o, i)}${this.transformCSS(e, `${Q}color-scheme:dark`, 'dark', 'variable', h, o, i)}`),
          (y = [...new Set([...Y, ...J, ...ee])]),
          (b = resolve(p.css, { dt: dt }))
      }
      return {
        primitive: { css: m, tokens: f },
        semantic: { css: _, tokens: g },
        global: { css: v, tokens: y },
        style: b
      }
    },
    getPreset({
      name: e = '',
      preset: t = {},
      options: n,
      params: o,
      set: i,
      defaults: r,
      selector: a
    }) {
      var s, l, c
      let d, u, p
      if (isNotEmpty(t) && 'strict' !== n.transform) {
        const o = e.replace('-directive', ''),
          h = t,
          { colorScheme: m, extend: f, css: _ } = h,
          g = __objRest(h, ['colorScheme', 'extend', 'css']),
          v = f || {},
          { colorScheme: y } = v,
          b = __objRest(v, ['colorScheme']),
          S = m || {},
          { dark: C } = S,
          w = __objRest(S, ['dark']),
          k = y || {},
          { dark: x } = k,
          E = __objRest(k, ['dark']),
          I = isNotEmpty(g)
            ? this._toVariables(
                { [o]: __spreadValues(__spreadValues({}, g), b) },
                n
              )
            : {},
          T = isNotEmpty(w)
            ? this._toVariables(
                { [o]: __spreadValues(__spreadValues({}, w), E) },
                n
              )
            : {},
          $ = isNotEmpty(C)
            ? this._toVariables(
                { [o]: __spreadValues(__spreadValues({}, C), x) },
                n
              )
            : {},
          [L, A] = [null != (s = I.declarations) ? s : '', I.tokens || []],
          [O, P] = [null != (l = T.declarations) ? l : '', T.tokens || []],
          [V, D] = [null != (c = $.declarations) ? c : '', $.tokens || []]
        ;(d = `${this.transformCSS(o, `${L}${O}`, 'light', 'variable', n, i, r, a)}${this.transformCSS(o, V, 'dark', 'variable', n, i, r, a)}`),
          (u = [...new Set([...A, ...P, ...D])]),
          (p = resolve(_, { dt: dt }))
      }
      return { css: d, tokens: u, style: p }
    },
    getPresetC({
      name: e = '',
      theme: t = {},
      params: n,
      set: o,
      defaults: i
    }) {
      var r
      const { preset: a, options: s } = t,
        l = null == (r = null == a ? void 0 : a.components) ? void 0 : r[e]
      return this.getPreset({
        name: e,
        preset: l,
        options: s,
        params: n,
        set: o,
        defaults: i
      })
    },
    getPresetD({
      name: e = '',
      theme: t = {},
      params: n,
      set: o,
      defaults: i
    }) {
      var r
      const a = e.replace('-directive', ''),
        { preset: s, options: l } = t,
        c = null == (r = null == s ? void 0 : s.directives) ? void 0 : r[a]
      return this.getPreset({
        name: a,
        preset: c,
        options: l,
        params: n,
        set: o,
        defaults: i
      })
    },
    applyDarkColorScheme: (e) =>
      !('none' === e.darkModeSelector || !1 === e.darkModeSelector),
    getColorSchemeOption(e, t) {
      var n
      return this.applyDarkColorScheme(e)
        ? this.regex.resolve(
            !0 === e.darkModeSelector
              ? t.options.darkModeSelector
              : null != (n = e.darkModeSelector)
                ? n
                : t.options.darkModeSelector
          )
        : []
    },
    getLayerOrder(e, t = {}, n, o) {
      const { cssLayer: i } = t
      if (i) {
        return `@layer ${resolve(i.order || 'primeui', n)}`
      }
      return ''
    },
    getCommonStyleSheet({
      name: e = '',
      theme: t = {},
      params: n,
      props: o = {},
      set: i,
      defaults: r
    }) {
      const a = this.getCommon({
          name: e,
          theme: t,
          params: n,
          set: i,
          defaults: r
        }),
        s = Object.entries(o)
          .reduce((e, [t, n]) => e.push(`${t}="${n}"`) && e, [])
          .join(' ')
      return Object.entries(a || {})
        .reduce((e, [t, n]) => {
          if (null == n ? void 0 : n.css) {
            const o = minifyCSS(null == n ? void 0 : n.css),
              i = `${t}-variables`
            e.push(
              `<style type="text/css" data-primevue-style-id="${i}" ${s}>${o}</style>`
            )
          }
          return e
        }, [])
        .join('')
    },
    getStyleSheet({
      name: e = '',
      theme: t = {},
      params: n,
      props: o = {},
      set: i,
      defaults: r
    }) {
      var a
      const s = { name: e, theme: t, params: n, set: i, defaults: r },
        l =
          null ==
          (a = e.includes('-directive')
            ? this.getPresetD(s)
            : this.getPresetC(s))
            ? void 0
            : a.css,
        c = Object.entries(o)
          .reduce((e, [t, n]) => e.push(`${t}="${n}"`) && e, [])
          .join(' ')
      return l
        ? `<style type="text/css" data-primevue-style-id="${e}-variables" ${c}>${minifyCSS(l)}</style>`
        : ''
    },
    createTokens(e = {}, t, n = '', o = '', i = {}) {
      return (
        Object.entries(e).forEach(([e, r]) => {
          const a = matchRegex(e, t.variable.excludedKeyRegex)
              ? n
              : n
                ? `${n}.${toTokenKey$1(e)}`
                : toTokenKey$1(e),
            s = o ? `${o}.${e}` : e
          isObject$2(r)
            ? this.createTokens(r, t, a, s, i)
            : (i[a] ||
                (i[a] = {
                  paths: [],
                  computed(e, t = {}) {
                    var n, o
                    return 1 === this.paths.length
                      ? null == (n = this.paths[0])
                        ? void 0
                        : n.computed(this.paths[0].scheme, t.binding)
                      : e && 'none' !== e
                        ? null == (o = this.paths.find((t) => t.scheme === e))
                          ? void 0
                          : o.computed(e, t.binding)
                        : this.paths.map((e) =>
                            e.computed(e.scheme, t[e.scheme])
                          )
                  }
                }),
              i[a].paths.push({
                path: s,
                value: r,
                scheme: s.includes('colorScheme.light')
                  ? 'light'
                  : s.includes('colorScheme.dark')
                    ? 'dark'
                    : 'none',
                computed(e, t = {}) {
                  const n = /{([^}]*)}/g
                  let o = r
                  if (
                    ((t.name = this.path),
                    t.binding || (t.binding = {}),
                    matchRegex(r, n))
                  ) {
                    const a = r.trim().replaceAll(n, (n) => {
                        var o
                        const r = n.replace(/{|}/g, ''),
                          a = null == (o = i[r]) ? void 0 : o.computed(e, t)
                        return isArray$1(a) && 2 === a.length
                          ? `light-dark(${a[0].value},${a[1].value})`
                          : null == a
                            ? void 0
                            : a.value
                      }),
                      s = /(\d+\w*\s+[\+\-\*\/]\s+\d+\w*)/g,
                      l = /var\([^)]+\)/g
                    o = matchRegex(a.replace(l, '0'), s) ? `calc(${a})` : a
                  }
                  return (
                    isEmpty(t.binding) && delete t.binding,
                    {
                      colorScheme: e,
                      path: this.path,
                      paths: t,
                      value: o.includes('undefined') ? void 0 : o
                    }
                  )
                }
              }))
        }),
        i
      )
    },
    getTokenValue(e, t, n) {
      var o
      const i = __name(
          (e) =>
            e
              .split('.')
              .filter(
                (e) => !matchRegex(e.toLowerCase(), n.variable.excludedKeyRegex)
              )
              .join('.'),
          'normalizePath'
        )(t),
        r = t.includes('colorScheme.light')
          ? 'light'
          : t.includes('colorScheme.dark')
            ? 'dark'
            : void 0,
        a = [null == (o = e[i]) ? void 0 : o.computed(r)]
          .flat()
          .filter((e) => e)
      return 1 === a.length
        ? a[0].value
        : a.reduce(
            (e = {}, t) => {
              const n = t,
                { colorScheme: o } = n,
                i = __objRest(n, ['colorScheme'])
              return (e[o] = i), e
            },
            void 0
          )
    },
    getSelectorRule: (e, t, n, o) =>
      'class' === n || 'attr' === n
        ? getRule(isNotEmpty(t) ? `${e}${t},${e} ${t}` : e, o)
        : getRule(e, isNotEmpty(t) ? getRule(t, o) : o),
    transformCSS(e, t, n, o, i = {}, r, a, s) {
      if (isNotEmpty(t)) {
        const { cssLayer: l } = i
        if ('style' !== o) {
          const e = this.getColorSchemeOption(i, a)
          t =
            'dark' === n
              ? e.reduce(
                  (e, { type: n, selector: o }) => (
                    isNotEmpty(o) &&
                      (e += o.includes('[CSS]')
                        ? o.replace('[CSS]', t)
                        : this.getSelectorRule(o, s, n, t)),
                    e
                  ),
                  ''
                )
              : getRule(null != s ? s : ':root', t)
        }
        if (l) {
          const n = { name: 'primeui', order: 'primeui' }
          isObject$2(l) && (n.name = resolve(l.name, { name: e, type: o })),
            isNotEmpty(n.name) &&
              ((t = getRule(`@layer ${n.name}`, t)),
              null == r || r.layerNames(n.name))
        }
        return t
      }
      return ''
    }
  },
  config_default = {
    defaults: {
      variable: {
        prefix: 'p',
        selector: ':root',
        excludedKeyRegex:
          /^(primitive|semantic|components|directives|variables|colorscheme|light|dark|common|root|states|extend|css)$/gi
      },
      options: { prefix: 'p', darkModeSelector: 'system', cssLayer: !1 }
    },
    _theme: void 0,
    _layerNames: new Set(),
    _loadedStyleNames: new Set(),
    _loadingStyles: new Set(),
    _tokens: {},
    update(e = {}) {
      const { theme: t } = e
      t &&
        ((this._theme = __spreadProps(__spreadValues({}, t), {
          options: __spreadValues(
            __spreadValues({}, this.defaults.options),
            t.options
          )
        })),
        (this._tokens = themeUtils_default.createTokens(
          this.preset,
          this.defaults
        )),
        this.clearLoadedStyleNames())
    },
    get theme() {
      return this._theme
    },
    get preset() {
      var e
      return (null == (e = this.theme) ? void 0 : e.preset) || {}
    },
    get options() {
      var e
      return (null == (e = this.theme) ? void 0 : e.options) || {}
    },
    get tokens() {
      return this._tokens
    },
    getTheme() {
      return this.theme
    },
    setTheme(e) {
      this.update({ theme: e }), service_default.emit('theme:change', e)
    },
    getPreset() {
      return this.preset
    },
    setPreset(e) {
      ;(this._theme = __spreadProps(__spreadValues({}, this.theme), {
        preset: e
      })),
        (this._tokens = themeUtils_default.createTokens(e, this.defaults)),
        this.clearLoadedStyleNames(),
        service_default.emit('preset:change', e),
        service_default.emit('theme:change', this.theme)
    },
    getOptions() {
      return this.options
    },
    setOptions(e) {
      ;(this._theme = __spreadProps(__spreadValues({}, this.theme), {
        options: e
      })),
        this.clearLoadedStyleNames(),
        service_default.emit('options:change', e),
        service_default.emit('theme:change', this.theme)
    },
    getLayerNames() {
      return [...this._layerNames]
    },
    setLayerNames(e) {
      this._layerNames.add(e)
    },
    getLoadedStyleNames() {
      return this._loadedStyleNames
    },
    isStyleNameLoaded(e) {
      return this._loadedStyleNames.has(e)
    },
    setLoadedStyleName(e) {
      this._loadedStyleNames.add(e)
    },
    deleteLoadedStyleName(e) {
      this._loadedStyleNames.delete(e)
    },
    clearLoadedStyleNames() {
      this._loadedStyleNames.clear()
    },
    getTokenValue(e) {
      return themeUtils_default.getTokenValue(this.tokens, e, this.defaults)
    },
    getCommon(e = '', t) {
      return themeUtils_default.getCommon({
        name: e,
        theme: this.theme,
        params: t,
        defaults: this.defaults,
        set: { layerNames: this.setLayerNames.bind(this) }
      })
    },
    getComponent(e = '', t) {
      const n = {
        name: e,
        theme: this.theme,
        params: t,
        defaults: this.defaults,
        set: { layerNames: this.setLayerNames.bind(this) }
      }
      return themeUtils_default.getPresetC(n)
    },
    getDirective(e = '', t) {
      const n = {
        name: e,
        theme: this.theme,
        params: t,
        defaults: this.defaults,
        set: { layerNames: this.setLayerNames.bind(this) }
      }
      return themeUtils_default.getPresetD(n)
    },
    getCustomPreset(e = '', t, n, o) {
      const i = {
        name: e,
        preset: t,
        options: this.options,
        selector: n,
        params: o,
        defaults: this.defaults,
        set: { layerNames: this.setLayerNames.bind(this) }
      }
      return themeUtils_default.getPreset(i)
    },
    getLayerOrderCSS(e = '') {
      return themeUtils_default.getLayerOrder(
        e,
        this.options,
        { names: this.getLayerNames() },
        this.defaults
      )
    },
    transformCSS(e = '', t, n = 'style', o) {
      return themeUtils_default.transformCSS(
        e,
        t,
        o,
        n,
        this.options,
        { layerNames: this.setLayerNames.bind(this) },
        this.defaults
      )
    },
    getCommonStyleSheet(e = '', t, n = {}) {
      return themeUtils_default.getCommonStyleSheet({
        name: e,
        theme: this.theme,
        params: t,
        props: n,
        defaults: this.defaults,
        set: { layerNames: this.setLayerNames.bind(this) }
      })
    },
    getStyleSheet(e, t, n = {}) {
      return themeUtils_default.getStyleSheet({
        name: e,
        theme: this.theme,
        params: t,
        props: n,
        defaults: this.defaults,
        set: { layerNames: this.setLayerNames.bind(this) }
      })
    },
    onStyleMounted(e) {
      this._loadingStyles.add(e)
    },
    onStyleUpdated(e) {
      this._loadingStyles.add(e)
    },
    onStyleLoaded(e, { name: t }) {
      this._loadingStyles.size &&
        (this._loadingStyles.delete(t),
        service_default.emit(`theme:${t}:load`, e),
        !this._loadingStyles.size && service_default.emit('theme:load'))
    }
  }
function updatePreset(...e) {
  const t = mergeKeys(config_default.getPreset(), ...e)
  return config_default.setPreset(t), t
}
function updatePrimaryPalette(e) {
  return $t().primaryPalette(e).update().preset
}
function updateSurfacePalette(e) {
  return $t().surfacePalette(e).update().preset
}
function usePreset(...e) {
  const t = mergeKeys(...e)
  return config_default.setPreset(t), t
}
function useTheme(e) {
  return $t(e).update({ mergePresets: !1 })
}
__name(updatePreset, 'updatePreset'),
  __name(updatePrimaryPalette, 'updatePrimaryPalette'),
  __name(updateSurfacePalette, 'updateSurfacePalette'),
  __name(usePreset, 'usePreset'),
  __name(useTheme, 'useTheme')
var Base = {
  _loadedStyleNames: new Set(),
  getLoadedStyleNames: __name(function () {
    return this._loadedStyleNames
  }, 'getLoadedStyleNames'),
  isStyleNameLoaded: __name(function (e) {
    return this._loadedStyleNames.has(e)
  }, 'isStyleNameLoaded'),
  setLoadedStyleName: __name(function (e) {
    this._loadedStyleNames.add(e)
  }, 'setLoadedStyleName'),
  deleteLoadedStyleName: __name(function (e) {
    this._loadedStyleNames.delete(e)
  }, 'deleteLoadedStyleName'),
  clearLoadedStyleNames: __name(function () {
    this._loadedStyleNames.clear()
  }, 'clearLoadedStyleNames')
}
function _typeof$k(e) {
  return (_typeof$k =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$k(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$k(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$k(Object(n), !0).forEach(function (t) {
          _defineProperty$k(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$k(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$k(e, t, n) {
  return (
    (t = _toPropertyKey$j(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$j(e) {
  var t = _toPrimitive$j(e, 'string')
  return 'symbol' == _typeof$k(t) ? t : t + ''
}
function _toPrimitive$j(e, t) {
  if ('object' != _typeof$k(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$k(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
function tryOnMounted$1(e) {
  var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
  Vue.getCurrentInstance() ? Vue.onMounted(e) : t ? e() : Vue.nextTick(e)
}
__name(_typeof$k, '_typeof$k'),
  __name(ownKeys$k, 'ownKeys$k'),
  __name(_objectSpread$k, '_objectSpread$k'),
  __name(_defineProperty$k, '_defineProperty$k'),
  __name(_toPropertyKey$j, '_toPropertyKey$j'),
  __name(_toPrimitive$j, '_toPrimitive$j'),
  __name(tryOnMounted$1, 'tryOnMounted$1')
var _id$1 = 0
function useStyle(e) {
  var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
    n = Vue.ref(!1),
    o = Vue.ref(e),
    i = Vue.ref(null),
    r = isClient$1() ? window.document : void 0,
    a = t.document,
    s = void 0 === a ? r : a,
    l = t.immediate,
    c = void 0 === l || l,
    d = t.manual,
    u = void 0 !== d && d,
    p = t.name,
    h = void 0 === p ? 'style_'.concat(++_id$1) : p,
    m = t.id,
    f = void 0 === m ? void 0 : m,
    _ = t.media,
    g = void 0 === _ ? void 0 : _,
    v = t.nonce,
    y = void 0 === v ? void 0 : v,
    b = t.first,
    S = void 0 !== b && b,
    C = t.onMounted,
    w = void 0 === C ? void 0 : C,
    k = t.onUpdated,
    x = void 0 === k ? void 0 : k,
    E = t.onLoad,
    I = void 0 === E ? void 0 : E,
    T = t.props,
    $ = void 0 === T ? {} : T,
    L = __name(function () {}, 'stop'),
    A = __name(function (t) {
      var r =
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      if (s) {
        var a = _objectSpread$k(_objectSpread$k({}, $), r),
          l = a.name || h,
          c = a.id || f,
          d = a.nonce || y
        ;(i.value =
          s.querySelector('style[data-primevue-style-id="'.concat(l, '"]')) ||
          s.getElementById(c) ||
          s.createElement('style')),
          i.value.isConnected ||
            ((o.value = t || e),
            setAttributes(i.value, {
              type: 'text/css',
              id: c,
              media: g,
              nonce: d
            }),
            S ? s.head.prepend(i.value) : s.head.appendChild(i.value),
            setAttribute(i.value, 'data-primevue-style-id', l),
            setAttributes(i.value, a),
            (i.value.onload = function (e) {
              return null == I ? void 0 : I(e, { name: l })
            }),
            null == w || w(l)),
          n.value ||
            ((L = Vue.watch(
              o,
              function (e) {
                ;(i.value.textContent = e), null == x || x(l)
              },
              { immediate: !0 }
            )),
            (n.value = !0))
      }
    }, 'load'),
    O = __name(function () {
      s &&
        n.value &&
        (L(), isExist(i.value) && s.head.removeChild(i.value), (n.value = !1))
    }, 'unload')
  return (
    c && !u && tryOnMounted$1(A),
    {
      id: f,
      name: h,
      el: i,
      css: o,
      unload: O,
      load: A,
      isLoaded: Vue.readonly(n)
    }
  )
}
function _typeof$j(e) {
  return (_typeof$j =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function _slicedToArray$4(e, t) {
  return (
    _arrayWithHoles$4(e) ||
    _iterableToArrayLimit$4(e, t) ||
    _unsupportedIterableToArray$g(e, t) ||
    _nonIterableRest$4()
  )
}
function _nonIterableRest$4() {
  throw new TypeError(
    'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$g(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$g(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$g(e, t)
          : void 0
    )
  }
}
function _arrayLikeToArray$g(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
function _iterableToArrayLimit$4(e, t) {
  var n =
    null == e
      ? null
      : ('undefined' != typeof Symbol && e[Symbol.iterator]) || e['@@iterator']
  if (null != n) {
    var o,
      i,
      r,
      a,
      s = [],
      l = !0,
      c = !1
    try {
      if (((r = (n = n.call(e)).next), 0 === t));
      else
        for (
          ;
          !(l = (o = r.call(n)).done) && (s.push(o.value), s.length !== t);
          l = !0
        );
    } catch (d) {
      ;(c = !0), (i = d)
    } finally {
      try {
        if (!l && null != n.return && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (c) throw i
      }
    }
    return s
  }
}
function _arrayWithHoles$4(e) {
  if (Array.isArray(e)) return e
}
function ownKeys$j(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$j(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$j(Object(n), !0).forEach(function (t) {
          _defineProperty$j(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$j(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$j(e, t, n) {
  return (
    (t = _toPropertyKey$i(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$i(e) {
  var t = _toPrimitive$i(e, 'string')
  return 'symbol' == _typeof$j(t) ? t : t + ''
}
function _toPrimitive$i(e, t) {
  if ('object' != _typeof$j(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$j(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(useStyle, 'useStyle'),
  __name(_typeof$j, '_typeof$j'),
  __name(_slicedToArray$4, '_slicedToArray$4'),
  __name(_nonIterableRest$4, '_nonIterableRest$4'),
  __name(_unsupportedIterableToArray$g, '_unsupportedIterableToArray$g'),
  __name(_arrayLikeToArray$g, '_arrayLikeToArray$g'),
  __name(_iterableToArrayLimit$4, '_iterableToArrayLimit$4'),
  __name(_arrayWithHoles$4, '_arrayWithHoles$4'),
  __name(ownKeys$j, 'ownKeys$j'),
  __name(_objectSpread$j, '_objectSpread$j'),
  __name(_defineProperty$j, '_defineProperty$j'),
  __name(_toPropertyKey$i, '_toPropertyKey$i'),
  __name(_toPrimitive$i, '_toPrimitive$i')
var theme$A = __name(function (e) {
    var t = e.dt
    return '\n*,\n::before,\n::after {\n    box-sizing: border-box;\n}\n\n/* Non vue overlay animations */\n.p-connected-overlay {\n    opacity: 0;\n    transform: scaleY(0.8);\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1),\n        opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-connected-overlay-visible {\n    opacity: 1;\n    transform: scaleY(1);\n}\n\n.p-connected-overlay-hidden {\n    opacity: 0;\n    transform: scaleY(1);\n    transition: opacity 0.1s linear;\n}\n\n/* Vue based overlay animations */\n.p-connected-overlay-enter-from {\n    opacity: 0;\n    transform: scaleY(0.8);\n}\n\n.p-connected-overlay-leave-to {\n    opacity: 0;\n}\n\n.p-connected-overlay-enter-active {\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1),\n        opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-connected-overlay-leave-active {\n    transition: opacity 0.1s linear;\n}\n\n/* Toggleable Content */\n.p-toggleable-content-enter-from,\n.p-toggleable-content-leave-to {\n    max-height: 0;\n}\n\n.p-toggleable-content-enter-to,\n.p-toggleable-content-leave-from {\n    max-height: 1000px;\n}\n\n.p-toggleable-content-leave-active {\n    overflow: hidden;\n    transition: max-height 0.45s cubic-bezier(0, 1, 0, 1);\n}\n\n.p-toggleable-content-enter-active {\n    overflow: hidden;\n    transition: max-height 1s ease-in-out;\n}\n\n.p-disabled,\n.p-disabled * {\n    cursor: default;\n    pointer-events: none;\n    user-select: none;\n}\n\n.p-disabled,\n.p-component:disabled {\n    opacity: '
      .concat(t('disabled.opacity'), ';\n}\n\n.pi {\n    font-size: ')
      .concat(t('icon.size'), ';\n}\n\n.p-icon {\n    width: ')
      .concat(t('icon.size'), ';\n    height: ')
      .concat(t('icon.size'), ';\n}\n\n.p-overlay-mask {\n    background: ')
      .concat(t('mask.background'), ';\n    color: ')
      .concat(
        t('mask.color'),
        ';\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n\n.p-overlay-mask-enter {\n    animation: p-overlay-mask-enter-animation '
      )
      .concat(
        t('mask.transition.duration'),
        ' forwards;\n}\n\n.p-overlay-mask-leave {\n    animation: p-overlay-mask-leave-animation '
      )
      .concat(
        t('mask.transition.duration'),
        ' forwards;\n}\n\n@keyframes p-overlay-mask-enter-animation {\n    from {\n        background: transparent;\n    }\n    to {\n        background: '
      )
      .concat(
        t('mask.background'),
        ';\n    }\n}\n@keyframes p-overlay-mask-leave-animation {\n    from {\n        background: '
      )
      .concat(
        t('mask.background'),
        ';\n    }\n    to {\n        background: transparent;\n    }\n}\n'
      )
  }, 'theme'),
  css$2 = __name(function (e) {
    var t = e.dt
    return '\n.p-hidden-accessible {\n    border: 0;\n    clip: rect(0 0 0 0);\n    height: 1px;\n    margin: -1px;\n    overflow: hidden;\n    padding: 0;\n    position: absolute;\n    width: 1px;\n}\n\n.p-hidden-accessible input,\n.p-hidden-accessible select {\n    transform: scale(0);\n}\n\n.p-overflow-hidden {\n    overflow: hidden;\n    padding-right: '.concat(
      t('scrollbar.width'),
      ';\n}\n'
    )
  }, 'css'),
  classes$C = {},
  inlineStyles$4 = {},
  BaseStyle = {
    name: 'base',
    css: css$2,
    theme: theme$A,
    classes: classes$C,
    inlineStyles: inlineStyles$4,
    load: __name(function (e) {
      var t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
        n = (
          arguments.length > 2 && void 0 !== arguments[2]
            ? arguments[2]
            : function (e) {
                return e
              }
        )(resolve(e, { dt: dt }))
      return isNotEmpty(n)
        ? useStyle(minifyCSS(n), _objectSpread$j({ name: this.name }, t))
        : {}
    }, 'load'),
    loadCSS: __name(function () {
      var e =
        arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
      return this.load(this.css, e)
    }, 'loadCSS'),
    loadTheme: __name(function () {
      var e = this,
        t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ''
      return this.load(this.theme, t, function () {
        var o =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ''
        return config_default.transformCSS(
          t.name || e.name,
          ''.concat(o).concat(n)
        )
      })
    }, 'loadTheme'),
    getCommonTheme: __name(function (e) {
      return config_default.getCommon(this.name, e)
    }, 'getCommonTheme'),
    getComponentTheme: __name(function (e) {
      return config_default.getComponent(this.name, e)
    }, 'getComponentTheme'),
    getDirectiveTheme: __name(function (e) {
      return config_default.getDirective(this.name, e)
    }, 'getDirectiveTheme'),
    getPresetTheme: __name(function (e, t, n) {
      return config_default.getCustomPreset(this.name, e, t, n)
    }, 'getPresetTheme'),
    getLayerOrderThemeCSS: __name(function () {
      return config_default.getLayerOrderCSS(this.name)
    }, 'getLayerOrderThemeCSS'),
    getStyleSheet: __name(function () {
      var e =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : '',
        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      if (this.css) {
        var n = resolve(this.css, { dt: dt }) || '',
          o = minifyCSS(''.concat(n).concat(e)),
          i = Object.entries(t)
            .reduce(function (e, t) {
              var n = _slicedToArray$4(t, 2),
                o = n[0],
                i = n[1]
              return e.push(''.concat(o, '="').concat(i, '"')) && e
            }, [])
            .join(' ')
        return isNotEmpty(o)
          ? '<style type="text/css" data-primevue-style-id="'
              .concat(this.name, '" ')
              .concat(i, '>')
              .concat(o, '</style>')
          : ''
      }
      return ''
    }, 'getStyleSheet'),
    getCommonThemeStyleSheet: __name(function (e) {
      var t =
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      return config_default.getCommonStyleSheet(this.name, e, t)
    }, 'getCommonThemeStyleSheet'),
    getThemeStyleSheet: __name(function (e) {
      var t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
        n = [config_default.getStyleSheet(this.name, e, t)]
      if (this.theme) {
        var o =
            'base' === this.name
              ? 'global-style'
              : ''.concat(this.name, '-style'),
          i = resolve(this.theme, { dt: dt }),
          r = minifyCSS(config_default.transformCSS(o, i)),
          a = Object.entries(t)
            .reduce(function (e, t) {
              var n = _slicedToArray$4(t, 2),
                o = n[0],
                i = n[1]
              return e.push(''.concat(o, '="').concat(i, '"')) && e
            }, [])
            .join(' ')
        isNotEmpty(r) &&
          n.push(
            '<style type="text/css" data-primevue-style-id="'
              .concat(o, '" ')
              .concat(a, '>')
              .concat(r, '</style>')
          )
      }
      return n.join('')
    }, 'getThemeStyleSheet'),
    extend: __name(function (e) {
      return _objectSpread$j(
        _objectSpread$j({}, this),
        {},
        { css: void 0, theme: void 0 },
        e
      )
    }, 'extend')
  },
  BaseComponentStyle$1 = BaseStyle.extend({ name: 'common' })
function _typeof$i(e) {
  return (_typeof$i =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function _toArray(e) {
  return (
    _arrayWithHoles$3(e) ||
    _iterableToArray$b(e) ||
    _unsupportedIterableToArray$f(e) ||
    _nonIterableRest$3()
  )
}
function _iterableToArray$b(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _slicedToArray$3(e, t) {
  return (
    _arrayWithHoles$3(e) ||
    _iterableToArrayLimit$3(e, t) ||
    _unsupportedIterableToArray$f(e, t) ||
    _nonIterableRest$3()
  )
}
function _nonIterableRest$3() {
  throw new TypeError(
    'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$f(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$f(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$f(e, t)
          : void 0
    )
  }
}
function _arrayLikeToArray$f(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
function _iterableToArrayLimit$3(e, t) {
  var n =
    null == e
      ? null
      : ('undefined' != typeof Symbol && e[Symbol.iterator]) || e['@@iterator']
  if (null != n) {
    var o,
      i,
      r,
      a,
      s = [],
      l = !0,
      c = !1
    try {
      if (((r = (n = n.call(e)).next), 0 === t)) {
        if (Object(n) !== n) return
        l = !1
      } else
        for (
          ;
          !(l = (o = r.call(n)).done) && (s.push(o.value), s.length !== t);
          l = !0
        );
    } catch (d) {
      ;(c = !0), (i = d)
    } finally {
      try {
        if (!l && null != n.return && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (c) throw i
      }
    }
    return s
  }
}
function _arrayWithHoles$3(e) {
  if (Array.isArray(e)) return e
}
function ownKeys$i(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$i(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$i(Object(n), !0).forEach(function (t) {
          _defineProperty$i(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$i(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$i(e, t, n) {
  return (
    (t = _toPropertyKey$h(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$h(e) {
  var t = _toPrimitive$h(e, 'string')
  return 'symbol' == _typeof$i(t) ? t : t + ''
}
function _toPrimitive$h(e, t) {
  if ('object' != _typeof$i(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$i(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$i, '_typeof$i'),
  __name(_toArray, '_toArray'),
  __name(_iterableToArray$b, '_iterableToArray$b'),
  __name(_slicedToArray$3, '_slicedToArray$3'),
  __name(_nonIterableRest$3, '_nonIterableRest$3'),
  __name(_unsupportedIterableToArray$f, '_unsupportedIterableToArray$f'),
  __name(_arrayLikeToArray$f, '_arrayLikeToArray$f'),
  __name(_iterableToArrayLimit$3, '_iterableToArrayLimit$3'),
  __name(_arrayWithHoles$3, '_arrayWithHoles$3'),
  __name(ownKeys$i, 'ownKeys$i'),
  __name(_objectSpread$i, '_objectSpread$i'),
  __name(_defineProperty$i, '_defineProperty$i'),
  __name(_toPropertyKey$h, '_toPropertyKey$h'),
  __name(_toPrimitive$h, '_toPrimitive$h')
var script$Y = {
    name: 'BaseComponent',
    props: {
      pt: { type: Object, default: void 0 },
      ptOptions: { type: Object, default: void 0 },
      unstyled: { type: Boolean, default: void 0 },
      dt: { type: Object, default: void 0 }
    },
    inject: { $parentInstance: { default: void 0 } },
    watch: {
      isUnstyled: {
        immediate: !0,
        handler: __name(function (e) {
          e ||
            (this._loadCoreStyles(),
            this._themeChangeListener(this._loadCoreStyles))
        }, 'handler')
      },
      dt: {
        immediate: !0,
        handler: __name(function (e) {
          var t = this
          e
            ? (this._loadScopedThemeStyles(e),
              this._themeChangeListener(function () {
                return t._loadScopedThemeStyles(e)
              }))
            : this._unloadScopedThemeStyles()
        }, 'handler')
      }
    },
    scopedStyleEl: void 0,
    rootEl: void 0,
    $attrSelector: void 0,
    beforeCreate: __name(function () {
      var e,
        t,
        n,
        o,
        i,
        r,
        a,
        s,
        l,
        c,
        d,
        u = null === (e = this.pt) || void 0 === e ? void 0 : e._usept,
        p = u
          ? null === (t = this.pt) ||
            void 0 === t ||
            null === (t = t.originalValue) ||
            void 0 === t
            ? void 0
            : t[this.$.type.name]
          : void 0
      null ===
        (o =
          (u
            ? null === (n = this.pt) ||
              void 0 === n ||
              null === (n = n.value) ||
              void 0 === n
              ? void 0
              : n[this.$.type.name]
            : this.pt) || p) ||
        void 0 === o ||
        null === (o = o.hooks) ||
        void 0 === o ||
        null === (i = o.onBeforeCreate) ||
        void 0 === i ||
        i.call(o)
      var h =
          null === (r = this.$primevueConfig) ||
          void 0 === r ||
          null === (r = r.pt) ||
          void 0 === r
            ? void 0
            : r._usept,
        m = h
          ? null === (a = this.$primevue) ||
            void 0 === a ||
            null === (a = a.config) ||
            void 0 === a ||
            null === (a = a.pt) ||
            void 0 === a
            ? void 0
            : a.originalValue
          : void 0
      null ===
        (c =
          (h
            ? null === (s = this.$primevue) ||
              void 0 === s ||
              null === (s = s.config) ||
              void 0 === s ||
              null === (s = s.pt) ||
              void 0 === s
              ? void 0
              : s.value
            : null === (l = this.$primevue) ||
                void 0 === l ||
                null === (l = l.config) ||
                void 0 === l
              ? void 0
              : l.pt) || m) ||
        void 0 === c ||
        null === (c = c[this.$.type.name]) ||
        void 0 === c ||
        null === (c = c.hooks) ||
        void 0 === c ||
        null === (d = c.onBeforeCreate) ||
        void 0 === d ||
        d.call(c),
        (this.$attrSelector = uuid('pc'))
    }, 'beforeCreate'),
    created: __name(function () {
      this._hook('onCreated')
    }, 'created'),
    beforeMount: __name(function () {
      ;(this.rootEl = findSingle(
        this.$el,
        '[data-pc-name="'.concat(toFlatCase(this.$.type.name), '"]')
      )),
        this.rootEl &&
          (this.$attrSelector &&
            !this.rootEl.hasAttribute(this.$attrSelector) &&
            this.rootEl.setAttribute(this.$attrSelector, ''),
          (this.rootEl.$pc = _objectSpread$i(
            { name: this.$.type.name, attrSelector: this.$attrSelector },
            this.$params
          ))),
        this._loadStyles(),
        this._hook('onBeforeMount')
    }, 'beforeMount'),
    mounted: __name(function () {
      this._hook('onMounted')
    }, 'mounted'),
    beforeUpdate: __name(function () {
      this._hook('onBeforeUpdate')
    }, 'beforeUpdate'),
    updated: __name(function () {
      this._hook('onUpdated')
    }, 'updated'),
    beforeUnmount: __name(function () {
      this._hook('onBeforeUnmount')
    }, 'beforeUnmount'),
    unmounted: __name(function () {
      this._unloadScopedThemeStyles(), this._hook('onUnmounted')
    }, 'unmounted'),
    methods: {
      _hook: __name(function (e) {
        if (!this.$options.hostName) {
          var t = this._usePT(
              this._getPT(this.pt, this.$.type.name),
              this._getOptionValue,
              'hooks.'.concat(e)
            ),
            n = this._useDefaultPT(this._getOptionValue, 'hooks.'.concat(e))
          null == t || t(), null == n || n()
        }
      }, '_hook'),
      _mergeProps: __name(function (e) {
        for (
          var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1;
          o < t;
          o++
        )
          n[o - 1] = arguments[o]
        return isFunction$1(e)
          ? e.apply(void 0, n)
          : Vue.mergeProps.apply(void 0, n)
      }, '_mergeProps'),
      _loadStyles: __name(function () {
        var e = this,
          t = __name(function () {
            Base.isStyleNameLoaded('base') ||
              (BaseStyle.loadCSS(e.$styleOptions),
              e._loadGlobalStyles(),
              Base.setLoadedStyleName('base')),
              e._loadThemeStyles()
          }, '_load')
        t(), this._themeChangeListener(t)
      }, '_loadStyles'),
      _loadCoreStyles: __name(function () {
        var e, t
        !Base.isStyleNameLoaded(
          null === (e = this.$style) || void 0 === e ? void 0 : e.name
        ) &&
          null !== (t = this.$style) &&
          void 0 !== t &&
          t.name &&
          (BaseComponentStyle$1.loadCSS(this.$styleOptions),
          this.$options.style && this.$style.loadCSS(this.$styleOptions),
          Base.setLoadedStyleName(this.$style.name))
      }, '_loadCoreStyles'),
      _loadGlobalStyles: __name(function () {
        var e = this._useGlobalPT(
          this._getOptionValue,
          'global.css',
          this.$params
        )
        isNotEmpty(e) &&
          BaseStyle.load(
            e,
            _objectSpread$i({ name: 'global' }, this.$styleOptions)
          )
      }, '_loadGlobalStyles'),
      _loadThemeStyles: __name(function () {
        var e, t
        if (!this.isUnstyled && 'none' !== this.$theme) {
          if (!config_default.isStyleNameLoaded('common')) {
            var n,
              o,
              i =
                (null === (n = this.$style) ||
                void 0 === n ||
                null === (o = n.getCommonTheme) ||
                void 0 === o
                  ? void 0
                  : o.call(n)) || {},
              r = i.primitive,
              a = i.semantic,
              s = i.global,
              l = i.style
            BaseStyle.load(
              null == r ? void 0 : r.css,
              _objectSpread$i(
                { name: 'primitive-variables' },
                this.$styleOptions
              )
            ),
              BaseStyle.load(
                null == a ? void 0 : a.css,
                _objectSpread$i(
                  { name: 'semantic-variables' },
                  this.$styleOptions
                )
              ),
              BaseStyle.load(
                null == s ? void 0 : s.css,
                _objectSpread$i(
                  { name: 'global-variables' },
                  this.$styleOptions
                )
              ),
              BaseStyle.loadTheme(
                _objectSpread$i({ name: 'global-style' }, this.$styleOptions),
                l
              ),
              config_default.setLoadedStyleName('common')
          }
          if (
            !config_default.isStyleNameLoaded(
              null === (e = this.$style) || void 0 === e ? void 0 : e.name
            ) &&
            null !== (t = this.$style) &&
            void 0 !== t &&
            t.name
          ) {
            var c,
              d,
              u,
              p,
              h =
                (null === (c = this.$style) ||
                void 0 === c ||
                null === (d = c.getComponentTheme) ||
                void 0 === d
                  ? void 0
                  : d.call(c)) || {},
              m = h.css,
              f = h.style
            null === (u = this.$style) ||
              void 0 === u ||
              u.load(
                m,
                _objectSpread$i(
                  { name: ''.concat(this.$style.name, '-variables') },
                  this.$styleOptions
                )
              ),
              null === (p = this.$style) ||
                void 0 === p ||
                p.loadTheme(
                  _objectSpread$i(
                    { name: ''.concat(this.$style.name, '-style') },
                    this.$styleOptions
                  ),
                  f
                ),
              config_default.setLoadedStyleName(this.$style.name)
          }
          if (!config_default.isStyleNameLoaded('layer-order')) {
            var _,
              g,
              v =
                null === (_ = this.$style) ||
                void 0 === _ ||
                null === (g = _.getLayerOrderThemeCSS) ||
                void 0 === g
                  ? void 0
                  : g.call(_)
            BaseStyle.load(
              v,
              _objectSpread$i(
                { name: 'layer-order', first: !0 },
                this.$styleOptions
              )
            ),
              config_default.setLoadedStyleName('layer-order')
          }
        }
      }, '_loadThemeStyles'),
      _loadScopedThemeStyles: __name(function (e) {
        var t,
          n,
          o,
          i = (
            (null === (t = this.$style) ||
            void 0 === t ||
            null === (n = t.getPresetTheme) ||
            void 0 === n
              ? void 0
              : n.call(t, e, '['.concat(this.$attrSelector, ']'))) || {}
          ).css,
          r =
            null === (o = this.$style) || void 0 === o
              ? void 0
              : o.load(
                  i,
                  _objectSpread$i(
                    {
                      name: ''
                        .concat(this.$attrSelector, '-')
                        .concat(this.$style.name)
                    },
                    this.$styleOptions
                  )
                )
        this.scopedStyleEl = r.el
      }, '_loadScopedThemeStyles'),
      _unloadScopedThemeStyles: __name(function () {
        var e
        null === (e = this.scopedStyleEl) ||
          void 0 === e ||
          null === (e = e.value) ||
          void 0 === e ||
          e.remove()
      }, '_unloadScopedThemeStyles'),
      _themeChangeListener: __name(function () {
        var e =
          arguments.length > 0 && void 0 !== arguments[0]
            ? arguments[0]
            : function () {}
        Base.clearLoadedStyleNames(), service_default.on('theme:change', e)
      }, '_themeChangeListener'),
      _getHostInstance: __name(function (e) {
        return e
          ? this.$options.hostName
            ? e.$.type.name === this.$options.hostName
              ? e
              : this._getHostInstance(e.$parentInstance)
            : e.$parentInstance
          : void 0
      }, '_getHostInstance'),
      _getPropValue: __name(function (e) {
        var t
        return (
          this[e] ||
          (null === (t = this._getHostInstance(this)) || void 0 === t
            ? void 0
            : t[e])
        )
      }, '_getPropValue'),
      _getOptionValue: __name(function (e) {
        return getKeyValue(
          e,
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '',
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
        )
      }, '_getOptionValue'),
      _getPTValue: __name(function () {
        var e,
          t =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          n =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '',
          o =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
          i =
            !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
          r = /./g.test(n) && !!o[n.split('.')[0]],
          a =
            this._getPropValue('ptOptions') ||
            (null === (e = this.$primevueConfig) || void 0 === e
              ? void 0
              : e.ptOptions) ||
            {},
          s = a.mergeSections,
          l = void 0 === s || s,
          c = a.mergeProps,
          d = void 0 !== c && c,
          u = i
            ? r
              ? this._useGlobalPT(this._getPTClassValue, n, o)
              : this._useDefaultPT(this._getPTClassValue, n, o)
            : void 0,
          p = r
            ? void 0
            : this._getPTSelf(
                t,
                this._getPTClassValue,
                n,
                _objectSpread$i(_objectSpread$i({}, o), {}, { global: u || {} })
              ),
          h = this._getPTDatasets(n)
        return l || (!l && p)
          ? d
            ? this._mergeProps(d, u, p, h)
            : _objectSpread$i(_objectSpread$i(_objectSpread$i({}, u), p), h)
          : _objectSpread$i(_objectSpread$i({}, p), h)
      }, '_getPTValue'),
      _getPTSelf: __name(function () {
        for (
          var e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            t = arguments.length,
            n = new Array(t > 1 ? t - 1 : 0),
            o = 1;
          o < t;
          o++
        )
          n[o - 1] = arguments[o]
        return Vue.mergeProps(
          this._usePT.apply(this, [this._getPT(e, this.$name)].concat(n)),
          this._usePT.apply(this, [this.$_attrsPT].concat(n))
        )
      }, '_getPTSelf'),
      _getPTDatasets: __name(function () {
        var e,
          t,
          n =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : '',
          o = 'data-pc-',
          i =
            'root' === n &&
            isNotEmpty(
              null === (e = this.pt) || void 0 === e
                ? void 0
                : e['data-pc-section']
            )
        return (
          'transition' !== n &&
          _objectSpread$i(
            _objectSpread$i(
              {},
              'root' === n &&
                _objectSpread$i(
                  _objectSpread$i(
                    _defineProperty$i(
                      {},
                      ''.concat(o, 'name'),
                      toFlatCase(
                        i
                          ? null === (t = this.pt) || void 0 === t
                            ? void 0
                            : t['data-pc-section']
                          : this.$.type.name
                      )
                    ),
                    i &&
                      _defineProperty$i(
                        {},
                        ''.concat(o, 'extend'),
                        toFlatCase(this.$.type.name)
                      )
                  ),
                  isClient$1() &&
                    _defineProperty$i({}, ''.concat(this.$attrSelector), '')
                )
            ),
            {},
            _defineProperty$i({}, ''.concat(o, 'section'), toFlatCase(n))
          )
        )
      }, '_getPTDatasets'),
      _getPTClassValue: __name(function () {
        var e = this._getOptionValue.apply(this, arguments)
        return isString$1(e) || isArray$1(e) ? { class: e } : e
      }, '_getPTClassValue'),
      _getPT: __name(function (e) {
        var t = this,
          n =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '',
          o = arguments.length > 2 ? arguments[2] : void 0,
          i = __name(function (e) {
            var i,
              r =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
              a = o ? o(e) : e,
              s = toFlatCase(n),
              l = toFlatCase(t.$name)
            return null !==
              (i = r
                ? s !== l
                  ? null == a
                    ? void 0
                    : a[s]
                  : void 0
                : null == a
                  ? void 0
                  : a[s]) && void 0 !== i
              ? i
              : a
          }, 'getValue')
        return null != e && e.hasOwnProperty('_usept')
          ? {
              _usept: e._usept,
              originalValue: i(e.originalValue),
              value: i(e.value)
            }
          : i(e, !0)
      }, '_getPT'),
      _usePT: __name(function (e, t, n, o) {
        var i = __name(function (e) {
          return t(e, n, o)
        }, 'fn')
        if (null != e && e.hasOwnProperty('_usept')) {
          var r,
            a =
              e._usept ||
              (null === (r = this.$primevueConfig) || void 0 === r
                ? void 0
                : r.ptOptions) ||
              {},
            s = a.mergeSections,
            l = void 0 === s || s,
            c = a.mergeProps,
            d = void 0 !== c && c,
            u = i(e.originalValue),
            p = i(e.value)
          if (void 0 === u && void 0 === p) return
          return isString$1(p)
            ? p
            : isString$1(u)
              ? u
              : l || (!l && p)
                ? d
                  ? this._mergeProps(d, u, p)
                  : _objectSpread$i(_objectSpread$i({}, u), p)
                : p
        }
        return i(e)
      }, '_usePT'),
      _useGlobalPT: __name(function (e, t, n) {
        return this._usePT(this.globalPT, e, t, n)
      }, '_useGlobalPT'),
      _useDefaultPT: __name(function (e, t, n) {
        return this._usePT(this.defaultPT, e, t, n)
      }, '_useDefaultPT'),
      ptm: __name(function () {
        var e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : '',
          t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
        return this._getPTValue(
          this.pt,
          e,
          _objectSpread$i(_objectSpread$i({}, this.$params), t)
        )
      }, 'ptm'),
      ptmi: __name(function () {
        var e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : '',
          t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
        return Vue.mergeProps(this.$_attrsWithoutPT, this.ptm(e, t))
      }, 'ptmi'),
      ptmo: __name(function () {
        var e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '',
          n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
        return this._getPTValue(
          e,
          t,
          _objectSpread$i({ instance: this }, n),
          !1
        )
      }, 'ptmo'),
      cx: __name(function () {
        var e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : '',
          t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
        return this.isUnstyled
          ? void 0
          : this._getOptionValue(
              this.$style.classes,
              e,
              _objectSpread$i(_objectSpread$i({}, this.$params), t)
            )
      }, 'cx'),
      sx: __name(function () {
        var e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : '',
          t =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
        if (
          !(arguments.length > 1 && void 0 !== arguments[1]) ||
          arguments[1]
        ) {
          var n = this._getOptionValue(
            this.$style.inlineStyles,
            e,
            _objectSpread$i(_objectSpread$i({}, this.$params), t)
          )
          return [
            this._getOptionValue(
              BaseComponentStyle$1.inlineStyles,
              e,
              _objectSpread$i(_objectSpread$i({}, this.$params), t)
            ),
            n
          ]
        }
      }, 'sx')
    },
    computed: {
      globalPT: __name(function () {
        var e,
          t = this
        return this._getPT(
          null === (e = this.$primevueConfig) || void 0 === e ? void 0 : e.pt,
          void 0,
          function (e) {
            return resolve(e, { instance: t })
          }
        )
      }, 'globalPT'),
      defaultPT: __name(function () {
        var e,
          t = this
        return this._getPT(
          null === (e = this.$primevueConfig) || void 0 === e ? void 0 : e.pt,
          void 0,
          function (e) {
            return (
              t._getOptionValue(e, t.$name, _objectSpread$i({}, t.$params)) ||
              resolve(e, _objectSpread$i({}, t.$params))
            )
          }
        )
      }, 'defaultPT'),
      isUnstyled: __name(function () {
        var e
        return void 0 !== this.unstyled
          ? this.unstyled
          : null === (e = this.$primevueConfig) || void 0 === e
            ? void 0
            : e.unstyled
      }, 'isUnstyled'),
      $inProps: __name(function () {
        var e,
          t = Object.keys(
            (null === (e = this.$.vnode) || void 0 === e ? void 0 : e.props) ||
              {}
          )
        return Object.fromEntries(
          Object.entries(this.$props).filter(function (e) {
            var n = _slicedToArray$3(e, 1)[0]
            return null == t ? void 0 : t.includes(n)
          })
        )
      }, '$inProps'),
      $theme: __name(function () {
        var e
        return null === (e = this.$primevueConfig) || void 0 === e
          ? void 0
          : e.theme
      }, '$theme'),
      $style: __name(function () {
        return _objectSpread$i(
          _objectSpread$i(
            {
              classes: void 0,
              inlineStyles: void 0,
              load: __name(function () {}, 'load'),
              loadCSS: __name(function () {}, 'loadCSS'),
              loadTheme: __name(function () {}, 'loadTheme')
            },
            (this._getHostInstance(this) || {}).$style
          ),
          this.$options.style
        )
      }, '$style'),
      $styleOptions: __name(function () {
        var e
        return {
          nonce:
            null === (e = this.$primevueConfig) ||
            void 0 === e ||
            null === (e = e.csp) ||
            void 0 === e
              ? void 0
              : e.nonce
        }
      }, '$styleOptions'),
      $primevueConfig: __name(function () {
        var e
        return null === (e = this.$primevue) || void 0 === e ? void 0 : e.config
      }, '$primevueConfig'),
      $name: __name(function () {
        return this.$options.hostName || this.$.type.name
      }, '$name'),
      $params: __name(function () {
        var e = this._getHostInstance(this) || this.$parent
        return {
          instance: this,
          props: this.$props,
          state: this.$data,
          attrs: this.$attrs,
          parent: {
            instance: e,
            props: null == e ? void 0 : e.$props,
            state: null == e ? void 0 : e.$data,
            attrs: null == e ? void 0 : e.$attrs
          }
        }
      }, '$params'),
      $_attrsPT: __name(function () {
        return Object.entries(this.$attrs || {})
          .filter(function (e) {
            var t = _slicedToArray$3(e, 1)[0]
            return null == t ? void 0 : t.startsWith('pt:')
          })
          .reduce(function (e, t) {
            var n = _slicedToArray$3(t, 2),
              o = n[0],
              i = n[1],
              r = _toArray(o.split(':')).slice(1)
            return (
              null == r ||
                r.reduce(function (e, t, n, o) {
                  return !e[t] && (e[t] = n === o.length - 1 ? i : {}), e[t]
                }, e),
              e
            )
          }, {})
      }, '$_attrsPT'),
      $_attrsWithoutPT: __name(function () {
        return Object.entries(this.$attrs || {})
          .filter(function (e) {
            var t = _slicedToArray$3(e, 1)[0]
            return !(null != t && t.startsWith('pt:'))
          })
          .reduce(function (e, t) {
            var n = _slicedToArray$3(t, 2),
              o = n[0],
              i = n[1]
            return (e[o] = i), e
          }, {})
      }, '$_attrsWithoutPT')
    }
  },
  css$1 =
    '\n.p-icon {\n    display: inline-block;\n    vertical-align: baseline;\n}\n\n.p-icon-spin {\n    -webkit-animation: p-icon-spin 2s infinite linear;\n    animation: p-icon-spin 2s infinite linear;\n}\n\n@-webkit-keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n\n@keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n',
  BaseIconStyle = BaseStyle.extend({ name: 'baseicon', css: css$1 })
function _typeof$h(e) {
  return (_typeof$h =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$h(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$h(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$h(Object(n), !0).forEach(function (t) {
          _defineProperty$h(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$h(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$h(e, t, n) {
  return (
    (t = _toPropertyKey$g(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$g(e) {
  var t = _toPrimitive$g(e, 'string')
  return 'symbol' == _typeof$h(t) ? t : t + ''
}
function _toPrimitive$g(e, t) {
  if ('object' != _typeof$h(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$h(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$h, '_typeof$h'),
  __name(ownKeys$h, 'ownKeys$h'),
  __name(_objectSpread$h, '_objectSpread$h'),
  __name(_defineProperty$h, '_defineProperty$h'),
  __name(_toPropertyKey$g, '_toPropertyKey$g'),
  __name(_toPrimitive$g, '_toPrimitive$g')
var script$X = {
    name: 'BaseIcon',
    extends: script$Y,
    props: {
      label: { type: String, default: void 0 },
      spin: { type: Boolean, default: !1 }
    },
    style: BaseIconStyle,
    provide: __name(function () {
      return { $pcIcon: this, $parentInstance: this }
    }, 'provide'),
    methods: {
      pti: __name(function () {
        var e = isEmpty(this.label)
        return _objectSpread$h(
          _objectSpread$h(
            {},
            !this.isUnstyled && {
              class: ['p-icon', { 'p-icon-spin': this.spin }]
            }
          ),
          {},
          {
            role: e ? void 0 : 'img',
            'aria-label': e ? void 0 : this.label,
            'aria-hidden': e
          }
        )
      }, 'pti')
    }
  },
  script$W = { name: 'BlankIcon', extends: script$X }
function render$T(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'rect',
            {
              width: '1',
              height: '1',
              fill: 'currentColor',
              'fill-opacity': '0'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$T, 'render$T'), (script$W.render = render$T)
var script$V = { name: 'CheckIcon', extends: script$X }
function render$S(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              d: 'M4.86199 11.5948C4.78717 11.5923 4.71366 11.5745 4.64596 11.5426C4.57826 11.5107 4.51779 11.4652 4.46827 11.4091L0.753985 7.69483C0.683167 7.64891 0.623706 7.58751 0.580092 7.51525C0.536478 7.44299 0.509851 7.36177 0.502221 7.27771C0.49459 7.19366 0.506156 7.10897 0.536046 7.03004C0.565935 6.95111 0.613367 6.88 0.674759 6.82208C0.736151 6.76416 0.8099 6.72095 0.890436 6.69571C0.970973 6.67046 1.05619 6.66385 1.13966 6.67635C1.22313 6.68886 1.30266 6.72017 1.37226 6.76792C1.44186 6.81567 1.4997 6.8786 1.54141 6.95197L4.86199 10.2503L12.6397 2.49483C12.7444 2.42694 12.8689 2.39617 12.9932 2.40745C13.1174 2.41873 13.2343 2.47141 13.3251 2.55705C13.4159 2.64268 13.4753 2.75632 13.4938 2.87973C13.5123 3.00315 13.4888 3.1292 13.4271 3.23768L5.2557 11.4091C5.20618 11.4652 5.14571 11.5107 5.07801 11.5426C5.01031 11.5745 4.9368 11.5923 4.86199 11.5948Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$S, 'render$S'), (script$V.render = render$S)
var script$U = { name: 'SearchIcon', extends: script$X }
function render$R(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              'fill-rule': 'evenodd',
              'clip-rule': 'evenodd',
              d: 'M2.67602 11.0265C3.6661 11.688 4.83011 12.0411 6.02086 12.0411C6.81149 12.0411 7.59438 11.8854 8.32483 11.5828C8.87005 11.357 9.37808 11.0526 9.83317 10.6803L12.9769 13.8241C13.0323 13.8801 13.0983 13.9245 13.171 13.9548C13.2438 13.985 13.3219 14.0003 13.4007 14C13.4795 14.0003 13.5575 13.985 13.6303 13.9548C13.7031 13.9245 13.7691 13.8801 13.8244 13.8241C13.9367 13.7116 13.9998 13.5592 13.9998 13.4003C13.9998 13.2414 13.9367 13.089 13.8244 12.9765L10.6807 9.8328C11.053 9.37773 11.3573 8.86972 11.5831 8.32452C11.8857 7.59408 12.0414 6.81119 12.0414 6.02056C12.0414 4.8298 11.6883 3.66579 11.0268 2.67572C10.3652 1.68564 9.42494 0.913972 8.32483 0.45829C7.22472 0.00260857 6.01418 -0.116618 4.84631 0.115686C3.67844 0.34799 2.60568 0.921393 1.76369 1.76338C0.921698 2.60537 0.348296 3.67813 0.115991 4.84601C-0.116313 6.01388 0.00291375 7.22441 0.458595 8.32452C0.914277 9.42464 1.68595 10.3649 2.67602 11.0265ZM3.35565 2.0158C4.14456 1.48867 5.07206 1.20731 6.02086 1.20731C7.29317 1.20731 8.51338 1.71274 9.41304 2.6124C10.3127 3.51206 10.8181 4.73226 10.8181 6.00457C10.8181 6.95337 10.5368 7.88088 10.0096 8.66978C9.48251 9.45868 8.73328 10.0736 7.85669 10.4367C6.98011 10.7997 6.01554 10.8947 5.08496 10.7096C4.15439 10.5245 3.2996 10.0676 2.62869 9.39674C1.95778 8.72583 1.50089 7.87104 1.31579 6.94046C1.13068 6.00989 1.22568 5.04532 1.58878 4.16874C1.95187 3.29215 2.56675 2.54292 3.35565 2.0158Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$R, 'render$R'), (script$U.render = render$R)
var theme$z = __name(function (e) {
    var t = e.dt
    return '\n.p-iconfield {\n    position: relative;\n}\n\n.p-inputicon {\n    position: absolute;\n    top: 50%;\n    margin-top: calc(-1 * ('
      .concat(t('icon.size'), ' / 2));\n    color: ')
      .concat(
        t('iconfield.icon.color'),
        ';\n    line-height: 1;\n}\n\n.p-iconfield .p-inputicon:first-child {\n    inset-inline-start: '
      )
      .concat(
        t('form.field.padding.x'),
        ';\n}\n\n.p-iconfield .p-inputicon:last-child {\n    inset-inline-end: '
      )
      .concat(
        t('form.field.padding.x'),
        ';\n}\n\n.p-iconfield .p-inputtext:not(:first-child) {\n    padding-inline-start: calc(('
      )
      .concat(t('form.field.padding.x'), ' * 2) + ')
      .concat(
        t('icon.size'),
        ');\n}\n\n.p-iconfield .p-inputtext:not(:last-child) {\n    padding-inline-end: calc(('
      )
      .concat(t('form.field.padding.x'), ' * 2) + ')
      .concat(
        t('icon.size'),
        ');\n}\n\n.p-iconfield:has(.p-inputfield-sm) .p-inputicon {\n    font-size: '
      )
      .concat(t('form.field.sm.font.size'), ';\n    width: ')
      .concat(t('form.field.sm.font.size'), ';\n    height: ')
      .concat(t('form.field.sm.font.size'), ';\n    margin-top: calc(-1 * (')
      .concat(
        t('form.field.sm.font.size'),
        ' / 2));\n}\n\n.p-iconfield:has(.p-inputfield-lg) .p-inputicon {\n    font-size: '
      )
      .concat(t('form.field.lg.font.size'), ';\n    width: ')
      .concat(t('form.field.lg.font.size'), ';\n    height: ')
      .concat(t('form.field.lg.font.size'), ';\n    margin-top: calc(-1 * (')
      .concat(t('form.field.lg.font.size'), ' / 2));\n}\n')
  }, 'theme'),
  classes$B = { root: 'p-iconfield' },
  IconFieldStyle = BaseStyle.extend({
    name: 'iconfield',
    theme: theme$z,
    classes: classes$B
  }),
  script$1$A = {
    name: 'BaseIconField',
    extends: script$Y,
    style: IconFieldStyle,
    provide: __name(function () {
      return { $pcIconField: this, $parentInstance: this }
    }, 'provide')
  },
  script$T = { name: 'IconField', extends: script$1$A, inheritAttrs: !1 }
function render$Q(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps({ class: e.cx('root') }, e.ptmi('root')),
      [Vue.renderSlot(e.$slots, 'default')],
      16
    )
  )
}
__name(render$Q, 'render$Q'), (script$T.render = render$Q)
var classes$A = { root: 'p-inputicon' },
  InputIconStyle = BaseStyle.extend({ name: 'inputicon', classes: classes$A }),
  script$1$z = {
    name: 'BaseInputIcon',
    extends: script$Y,
    style: InputIconStyle,
    props: { class: null },
    provide: __name(function () {
      return { $pcInputIcon: this, $parentInstance: this }
    }, 'provide')
  },
  script$S = {
    name: 'InputIcon',
    extends: script$1$z,
    inheritAttrs: !1,
    computed: {
      containerClass: __name(function () {
        return [this.cx('root'), this.class]
      }, 'containerClass')
    }
  }
function render$P(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'span',
      Vue.mergeProps({ class: r.containerClass }, e.ptmi('root')),
      [Vue.renderSlot(e.$slots, 'default')],
      16
    )
  )
}
__name(render$P, 'render$P'), (script$S.render = render$P)
var script$R = {
    name: 'BaseEditableHolder',
    extends: script$Y,
    emits: ['update:modelValue', 'value-change'],
    props: {
      modelValue: { type: null, default: void 0 },
      defaultValue: { type: null, default: void 0 },
      name: { type: String, default: void 0 },
      invalid: { type: Boolean, default: void 0 },
      disabled: { type: Boolean, default: !1 },
      formControl: { type: Object, default: void 0 }
    },
    inject: {
      $parentInstance: { default: void 0 },
      $pcForm: { default: void 0 },
      $pcFormField: { default: void 0 }
    },
    data: __name(function () {
      return { d_value: this.defaultValue || this.modelValue }
    }, 'data'),
    watch: {
      modelValue: __name(function (e) {
        this.d_value = e
      }, 'modelValue'),
      defaultValue: __name(function (e) {
        this.d_value = e
      }, 'defaultValue'),
      $formName: {
        immediate: !0,
        handler: __name(function (e) {
          var t, n
          this.formField =
            (null === (t = this.$pcForm) ||
            void 0 === t ||
            null === (n = t.register) ||
            void 0 === n
              ? void 0
              : n.call(t, e, this.$formControl)) || {}
        }, 'handler')
      },
      $formControl: {
        immediate: !0,
        handler: __name(function (e) {
          var t, n
          this.formField =
            (null === (t = this.$pcForm) ||
            void 0 === t ||
            null === (n = t.register) ||
            void 0 === n
              ? void 0
              : n.call(t, this.$formName, e)) || {}
        }, 'handler')
      },
      $formDefaultValue: {
        immediate: !0,
        handler: __name(function (e) {
          this.d_value !== e && (this.d_value = e)
        }, 'handler')
      }
    },
    formField: {},
    methods: {
      writeValue: __name(function (e, t) {
        var n, o
        this.controlled &&
          ((this.d_value = e), this.$emit('update:modelValue', e)),
          this.$emit('value-change', e),
          null === (n = (o = this.formField).onChange) ||
            void 0 === n ||
            n.call(o, { originalEvent: t, value: e })
      }, 'writeValue')
    },
    computed: {
      $filled: __name(function () {
        return isNotEmpty(this.d_value)
      }, '$filled'),
      $invalid: __name(function () {
        var e, t, n, o
        return null !==
          (e =
            null !== (t = this.invalid) && void 0 !== t
              ? t
              : null === (n = this.$pcFormField) ||
                  void 0 === n ||
                  null === (n = n.$field) ||
                  void 0 === n
                ? void 0
                : n.invalid) && void 0 !== e
          ? e
          : null === (o = this.$pcForm) ||
              void 0 === o ||
              null === (o = o.states) ||
              void 0 === o ||
              null === (o = o[this.$formName]) ||
              void 0 === o
            ? void 0
            : o.invalid
      }, '$invalid'),
      $formName: __name(function () {
        var e
        return (
          this.name ||
          (null === (e = this.$formControl) || void 0 === e ? void 0 : e.name)
        )
      }, '$formName'),
      $formControl: __name(function () {
        var e
        return (
          this.formControl ||
          (null === (e = this.$pcFormField) || void 0 === e
            ? void 0
            : e.formControl)
        )
      }, '$formControl'),
      $formDefaultValue: __name(function () {
        var e, t, n, o
        return null !==
          (e =
            null !== (t = this.d_value) && void 0 !== t
              ? t
              : null === (n = this.$pcFormField) || void 0 === n
                ? void 0
                : n.initialValue) && void 0 !== e
          ? e
          : null === (o = this.$pcForm) ||
              void 0 === o ||
              null === (o = o.initialValues) ||
              void 0 === o
            ? void 0
            : o[this.$formName]
      }, '$formDefaultValue'),
      controlled: __name(function () {
        return (
          this.$inProps.hasOwnProperty('modelValue') ||
          (!this.$inProps.hasOwnProperty('modelValue') &&
            !this.$inProps.hasOwnProperty('defaultValue'))
        )
      }, 'controlled'),
      filled: __name(function () {
        return this.$filled
      }, 'filled')
    }
  },
  script$Q = {
    name: 'BaseInput',
    extends: script$R,
    props: {
      size: { type: String, default: null },
      fluid: { type: Boolean, default: null },
      variant: { type: String, default: null }
    },
    inject: {
      $parentInstance: { default: void 0 },
      $pcFluid: { default: void 0 }
    },
    computed: {
      $variant: __name(function () {
        var e
        return null !== (e = this.variant) && void 0 !== e
          ? e
          : this.$primevue.config.inputStyle ||
              this.$primevue.config.inputVariant
      }, '$variant'),
      $fluid: __name(function () {
        var e
        return null !== (e = this.fluid) && void 0 !== e ? e : !!this.$pcFluid
      }, '$fluid'),
      hasFluid: __name(function () {
        return this.$fluid
      }, 'hasFluid')
    }
  },
  theme$y = __name(function (e) {
    var t = e.dt
    return '\n.p-inputtext {\n    font-family: inherit;\n    font-feature-settings: inherit;\n    font-size: 1rem;\n    color: '
      .concat(t('inputtext.color'), ';\n    background: ')
      .concat(t('inputtext.background'), ';\n    padding-block: ')
      .concat(t('inputtext.padding.y'), ';\n    padding-inline: ')
      .concat(t('inputtext.padding.x'), ';\n    border: 1px solid ')
      .concat(t('inputtext.border.color'), ';\n    transition: background ')
      .concat(t('inputtext.transition.duration'), ', color ')
      .concat(t('inputtext.transition.duration'), ', border-color ')
      .concat(t('inputtext.transition.duration'), ', outline-color ')
      .concat(t('inputtext.transition.duration'), ', box-shadow ')
      .concat(
        t('inputtext.transition.duration'),
        ';\n    appearance: none;\n    border-radius: '
      )
      .concat(
        t('inputtext.border.radius'),
        ';\n    outline-color: transparent;\n    box-shadow: '
      )
      .concat(
        t('inputtext.shadow'),
        ';\n}\n\n.p-inputtext:enabled:hover {\n    border-color: '
      )
      .concat(
        t('inputtext.hover.border.color'),
        ';\n}\n\n.p-inputtext:enabled:focus {\n    border-color: '
      )
      .concat(t('inputtext.focus.border.color'), ';\n    box-shadow: ')
      .concat(t('inputtext.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('inputtext.focus.ring.width'), ' ')
      .concat(t('inputtext.focus.ring.style'), ' ')
      .concat(t('inputtext.focus.ring.color'), ';\n    outline-offset: ')
      .concat(
        t('inputtext.focus.ring.offset'),
        ';\n}\n\n.p-inputtext.p-invalid {\n    border-color: '
      )
      .concat(
        t('inputtext.invalid.border.color'),
        ';\n}\n\n.p-inputtext.p-variant-filled {\n    background: '
      )
      .concat(
        t('inputtext.filled.background'),
        ';\n}\n\n.p-inputtext.p-variant-filled:enabled:hover {\n    background: '
      )
      .concat(
        t('inputtext.filled.hover.background'),
        ';\n}\n\n.p-inputtext.p-variant-filled:enabled:focus {\n    background: '
      )
      .concat(
        t('inputtext.filled.focus.background'),
        ';\n}\n\n.p-inputtext:disabled {\n    opacity: 1;\n    background: '
      )
      .concat(t('inputtext.disabled.background'), ';\n    color: ')
      .concat(
        t('inputtext.disabled.color'),
        ';\n}\n\n.p-inputtext::placeholder {\n    color: '
      )
      .concat(
        t('inputtext.placeholder.color'),
        ';\n}\n\n.p-inputtext.p-invalid::placeholder {\n    color: '
      )
      .concat(
        t('inputtext.invalid.placeholder.color'),
        ';\n}\n\n.p-inputtext-sm {\n    font-size: '
      )
      .concat(t('inputtext.sm.font.size'), ';\n    padding-block: ')
      .concat(t('inputtext.sm.padding.y'), ';\n    padding-inline: ')
      .concat(
        t('inputtext.sm.padding.x'),
        ';\n}\n\n.p-inputtext-lg {\n    font-size: '
      )
      .concat(t('inputtext.lg.font.size'), ';\n    padding-block: ')
      .concat(t('inputtext.lg.padding.y'), ';\n    padding-inline: ')
      .concat(
        t('inputtext.lg.padding.x'),
        ';\n}\n\n.p-inputtext-fluid {\n    width: 100%;\n}\n'
      )
  }, 'theme'),
  classes$z = {
    root: __name(function (e) {
      var t = e.instance,
        n = e.props
      return [
        'p-inputtext p-component',
        {
          'p-filled': t.$filled,
          'p-inputtext-sm p-inputfield-sm': 'small' === n.size,
          'p-inputtext-lg p-inputfield-lg': 'large' === n.size,
          'p-invalid': t.$invalid,
          'p-variant-filled': 'filled' === t.$variant,
          'p-inputtext-fluid': t.$fluid
        }
      ]
    }, 'root')
  },
  InputTextStyle = BaseStyle.extend({
    name: 'inputtext',
    theme: theme$y,
    classes: classes$z
  }),
  script$1$y = {
    name: 'BaseInputText',
    extends: script$Q,
    style: InputTextStyle,
    provide: __name(function () {
      return { $pcInputText: this, $parentInstance: this }
    }, 'provide')
  },
  script$P = {
    name: 'InputText',
    extends: script$1$y,
    inheritAttrs: !1,
    methods: {
      onInput: __name(function (e) {
        this.writeValue(e.target.value, e)
      }, 'onInput')
    },
    computed: {
      attrs: __name(function () {
        return Vue.mergeProps(
          this.ptmi('root', {
            context: { filled: this.$filled, disabled: this.disabled }
          }),
          this.formField
        )
      }, 'attrs')
    }
  },
  _hoisted_1$11 = ['value', 'disabled', 'aria-invalid']
function render$O(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'input',
      Vue.mergeProps(
        {
          type: 'text',
          class: e.cx('root'),
          value: e.d_value,
          disabled: e.disabled,
          'aria-invalid': e.$invalid || void 0,
          onInput:
            t[0] ||
            (t[0] = function () {
              return r.onInput && r.onInput.apply(r, arguments)
            })
        },
        r.attrs
      ),
      null,
      16,
      _hoisted_1$11
    )
  )
}
__name(render$O, 'render$O'), (script$P.render = render$O)
var PrimeVueService = EventBus()
function _typeof$g(e) {
  return (_typeof$g =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function _slicedToArray$2(e, t) {
  return (
    _arrayWithHoles$2(e) ||
    _iterableToArrayLimit$2(e, t) ||
    _unsupportedIterableToArray$e(e, t) ||
    _nonIterableRest$2()
  )
}
function _nonIterableRest$2() {
  throw new TypeError(
    'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$e(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$e(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$e(e, t)
          : void 0
    )
  }
}
function _arrayLikeToArray$e(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
function _iterableToArrayLimit$2(e, t) {
  var n =
    null == e
      ? null
      : ('undefined' != typeof Symbol && e[Symbol.iterator]) || e['@@iterator']
  if (null != n) {
    var o,
      i,
      r,
      a,
      s = [],
      l = !0,
      c = !1
    try {
      if (((r = (n = n.call(e)).next), 0 === t));
      else
        for (
          ;
          !(l = (o = r.call(n)).done) && (s.push(o.value), s.length !== t);
          l = !0
        );
    } catch (d) {
      ;(c = !0), (i = d)
    } finally {
      try {
        if (!l && null != n.return && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (c) throw i
      }
    }
    return s
  }
}
function _arrayWithHoles$2(e) {
  if (Array.isArray(e)) return e
}
function ownKeys$g(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$g(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$g(Object(n), !0).forEach(function (t) {
          _defineProperty$g(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$g(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$g(e, t, n) {
  return (
    (t = _toPropertyKey$f(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$f(e) {
  var t = _toPrimitive$f(e, 'string')
  return 'symbol' == _typeof$g(t) ? t : t + ''
}
function _toPrimitive$f(e, t) {
  if ('object' != _typeof$g(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$g(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$g, '_typeof$g'),
  __name(_slicedToArray$2, '_slicedToArray$2'),
  __name(_nonIterableRest$2, '_nonIterableRest$2'),
  __name(_unsupportedIterableToArray$e, '_unsupportedIterableToArray$e'),
  __name(_arrayLikeToArray$e, '_arrayLikeToArray$e'),
  __name(_iterableToArrayLimit$2, '_iterableToArrayLimit$2'),
  __name(_arrayWithHoles$2, '_arrayWithHoles$2'),
  __name(ownKeys$g, 'ownKeys$g'),
  __name(_objectSpread$g, '_objectSpread$g'),
  __name(_defineProperty$g, '_defineProperty$g'),
  __name(_toPropertyKey$f, '_toPropertyKey$f'),
  __name(_toPrimitive$f, '_toPrimitive$f')
var BaseDirective = {
    _getMeta: __name(function () {
      return [
        isObject$2(arguments.length <= 0 ? void 0 : arguments[0]) ||
        arguments.length <= 0
          ? void 0
          : arguments[0],
        resolve(
          isObject$2(arguments.length <= 0 ? void 0 : arguments[0])
            ? arguments.length <= 0
              ? void 0
              : arguments[0]
            : arguments.length <= 1
              ? void 0
              : arguments[1]
        )
      ]
    }, '_getMeta'),
    _getConfig: __name(function (e, t) {
      var n, o, i
      return null ===
        (n =
          (null == e || null === (o = e.instance) || void 0 === o
            ? void 0
            : o.$primevue) ||
          (null == t ||
          null === (i = t.ctx) ||
          void 0 === i ||
          null === (i = i.appContext) ||
          void 0 === i ||
          null === (i = i.config) ||
          void 0 === i ||
          null === (i = i.globalProperties) ||
          void 0 === i
            ? void 0
            : i.$primevue)) || void 0 === n
        ? void 0
        : n.config
    }, '_getConfig'),
    _getOptionValue: getKeyValue,
    _getPTValue: __name(function () {
      var e,
        t,
        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : '',
        r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
        a = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
        s = __name(function () {
          var e = BaseDirective._getOptionValue.apply(BaseDirective, arguments)
          return isString$1(e) || isArray$1(e) ? { class: e } : e
        }, 'getValue'),
        l =
          (null === (e = n.binding) ||
          void 0 === e ||
          null === (e = e.value) ||
          void 0 === e
            ? void 0
            : e.ptOptions) ||
          (null === (t = n.$primevueConfig) || void 0 === t
            ? void 0
            : t.ptOptions) ||
          {},
        c = l.mergeSections,
        d = void 0 === c || c,
        u = l.mergeProps,
        p = void 0 !== u && u,
        h = a ? BaseDirective._useDefaultPT(n, n.defaultPT(), s, i, r) : void 0,
        m = BaseDirective._usePT(
          n,
          BaseDirective._getPT(o, n.$name),
          s,
          i,
          _objectSpread$g(_objectSpread$g({}, r), {}, { global: h || {} })
        ),
        f = BaseDirective._getPTDatasets(n, i)
      return d || (!d && m)
        ? p
          ? BaseDirective._mergeProps(n, p, h, m, f)
          : _objectSpread$g(_objectSpread$g(_objectSpread$g({}, h), m), f)
        : _objectSpread$g(_objectSpread$g({}, m), f)
    }, '_getPTValue'),
    _getPTDatasets: __name(function () {
      var e =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '',
        n = 'data-pc-'
      return _objectSpread$g(
        _objectSpread$g(
          {},
          'root' === t &&
            _defineProperty$g({}, ''.concat(n, 'name'), toFlatCase(e.$name))
        ),
        {},
        _defineProperty$g({}, ''.concat(n, 'section'), toFlatCase(t))
      )
    }, '_getPTDatasets'),
    _getPT: __name(function (e) {
      var t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '',
        n = arguments.length > 2 ? arguments[2] : void 0,
        o = __name(function (e) {
          var o,
            i = n ? n(e) : e,
            r = toFlatCase(t)
          return null !== (o = null == i ? void 0 : i[r]) && void 0 !== o
            ? o
            : i
        }, 'getValue')
      return null != e && e.hasOwnProperty('_usept')
        ? {
            _usept: e._usept,
            originalValue: o(e.originalValue),
            value: o(e.value)
          }
        : o(e)
    }, '_getPT'),
    _usePT: __name(function () {
      var e =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        t = arguments.length > 1 ? arguments[1] : void 0,
        n = arguments.length > 2 ? arguments[2] : void 0,
        o = arguments.length > 3 ? arguments[3] : void 0,
        i = arguments.length > 4 ? arguments[4] : void 0,
        r = __name(function (e) {
          return n(e, o, i)
        }, 'fn')
      if (null != t && t.hasOwnProperty('_usept')) {
        var a,
          s =
            t._usept ||
            (null === (a = e.$primevueConfig) || void 0 === a
              ? void 0
              : a.ptOptions) ||
            {},
          l = s.mergeSections,
          c = void 0 === l || l,
          d = s.mergeProps,
          u = void 0 !== d && d,
          p = r(t.originalValue),
          h = r(t.value)
        if (void 0 === p && void 0 === h) return
        return isString$1(h)
          ? h
          : isString$1(p)
            ? p
            : c || (!c && h)
              ? u
                ? BaseDirective._mergeProps(e, u, p, h)
                : _objectSpread$g(_objectSpread$g({}, p), h)
              : h
      }
      return r(t)
    }, '_usePT'),
    _useDefaultPT: __name(function () {
      var e =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
        n = arguments.length > 2 ? arguments[2] : void 0,
        o = arguments.length > 3 ? arguments[3] : void 0,
        i = arguments.length > 4 ? arguments[4] : void 0
      return BaseDirective._usePT(e, t, n, o, i)
    }, '_useDefaultPT'),
    _loadStyles: __name(function (e, t, n) {
      var o,
        i = BaseDirective._getConfig(t, n),
        r = {
          nonce:
            null == i || null === (o = i.csp) || void 0 === o ? void 0 : o.nonce
        }
      BaseDirective._loadCoreStyles(e.$instance, r),
        BaseDirective._loadThemeStyles(e.$instance, r),
        BaseDirective._loadScopedThemeStyles(e.$instance, r),
        BaseDirective._themeChangeListener(function () {
          return BaseDirective._loadThemeStyles(e.$instance, r)
        })
    }, '_loadStyles'),
    _loadCoreStyles: __name(function () {
      var e,
        t,
        n,
        o = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        i = arguments.length > 1 ? arguments[1] : void 0
      !Base.isStyleNameLoaded(
        null === (e = o.$style) || void 0 === e ? void 0 : e.name
      ) &&
        null !== (t = o.$style) &&
        void 0 !== t &&
        t.name &&
        (BaseStyle.loadCSS(i),
        null === (n = o.$style) || void 0 === n || n.loadCSS(i),
        Base.setLoadedStyleName(o.$style.name))
    }, '_loadCoreStyles'),
    _loadThemeStyles: __name(function () {
      var e,
        t,
        n,
        o = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        i = arguments.length > 1 ? arguments[1] : void 0
      if (
        !(
          (null != o && o.isUnstyled()) ||
          'none' ===
            (null == o || null === (e = o.theme) || void 0 === e
              ? void 0
              : e.call(o))
        )
      ) {
        if (!config_default.isStyleNameLoaded('common')) {
          var r,
            a,
            s =
              (null === (r = o.$style) ||
              void 0 === r ||
              null === (a = r.getCommonTheme) ||
              void 0 === a
                ? void 0
                : a.call(r)) || {},
            l = s.primitive,
            c = s.semantic,
            d = s.global,
            u = s.style
          BaseStyle.load(
            null == l ? void 0 : l.css,
            _objectSpread$g({ name: 'primitive-variables' }, i)
          ),
            BaseStyle.load(
              null == c ? void 0 : c.css,
              _objectSpread$g({ name: 'semantic-variables' }, i)
            ),
            BaseStyle.load(
              null == d ? void 0 : d.css,
              _objectSpread$g({ name: 'global-variables' }, i)
            ),
            BaseStyle.loadTheme(
              _objectSpread$g({ name: 'global-style' }, i),
              u
            ),
            config_default.setLoadedStyleName('common')
        }
        if (
          !config_default.isStyleNameLoaded(
            null === (t = o.$style) || void 0 === t ? void 0 : t.name
          ) &&
          null !== (n = o.$style) &&
          void 0 !== n &&
          n.name
        ) {
          var p,
            h,
            m,
            f,
            _ =
              (null === (p = o.$style) ||
              void 0 === p ||
              null === (h = p.getDirectiveTheme) ||
              void 0 === h
                ? void 0
                : h.call(p)) || {},
            g = _.css,
            v = _.style
          null === (m = o.$style) ||
            void 0 === m ||
            m.load(
              g,
              _objectSpread$g(
                { name: ''.concat(o.$style.name, '-variables') },
                i
              )
            ),
            null === (f = o.$style) ||
              void 0 === f ||
              f.loadTheme(
                _objectSpread$g(
                  { name: ''.concat(o.$style.name, '-style') },
                  i
                ),
                v
              ),
            config_default.setLoadedStyleName(o.$style.name)
        }
        if (!config_default.isStyleNameLoaded('layer-order')) {
          var y,
            b,
            S =
              null === (y = o.$style) ||
              void 0 === y ||
              null === (b = y.getLayerOrderThemeCSS) ||
              void 0 === b
                ? void 0
                : b.call(y)
          BaseStyle.load(
            S,
            _objectSpread$g({ name: 'layer-order', first: !0 }, i)
          ),
            config_default.setLoadedStyleName('layer-order')
        }
      }
    }, '_loadThemeStyles'),
    _loadScopedThemeStyles: __name(function () {
      var e =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        t = arguments.length > 1 ? arguments[1] : void 0,
        n = e.preset()
      if (n && e.$attrSelector) {
        var o,
          i,
          r,
          a = (
            (null === (o = e.$style) ||
            void 0 === o ||
            null === (i = o.getPresetTheme) ||
            void 0 === i
              ? void 0
              : i.call(o, n, '['.concat(e.$attrSelector, ']'))) || {}
          ).css,
          s =
            null === (r = e.$style) || void 0 === r
              ? void 0
              : r.load(
                  a,
                  _objectSpread$g(
                    {
                      name: ''
                        .concat(e.$attrSelector, '-')
                        .concat(e.$style.name)
                    },
                    t
                  )
                )
        e.scopedStyleEl = s.el
      }
    }, '_loadScopedThemeStyles'),
    _themeChangeListener: __name(function () {
      var e =
        arguments.length > 0 && void 0 !== arguments[0]
          ? arguments[0]
          : function () {}
      Base.clearLoadedStyleNames(), service_default.on('theme:change', e)
    }, '_themeChangeListener'),
    _hook: __name(function (e, t, n, o, i, r) {
      var a,
        s,
        l = 'on'.concat(toCapitalCase(t)),
        c = BaseDirective._getConfig(o, i),
        d = null == n ? void 0 : n.$instance,
        u = BaseDirective._usePT(
          d,
          BaseDirective._getPT(
            null == o || null === (a = o.value) || void 0 === a ? void 0 : a.pt,
            e
          ),
          BaseDirective._getOptionValue,
          'hooks.'.concat(l)
        ),
        p = BaseDirective._useDefaultPT(
          d,
          null == c ||
            null === (s = c.pt) ||
            void 0 === s ||
            null === (s = s.directives) ||
            void 0 === s
            ? void 0
            : s[e],
          BaseDirective._getOptionValue,
          'hooks.'.concat(l)
        ),
        h = { el: n, binding: o, vnode: i, prevVnode: r }
      null == u || u(d, h), null == p || p(d, h)
    }, '_hook'),
    _mergeProps: __name(function () {
      for (
        var e = arguments.length > 1 ? arguments[1] : void 0,
          t = arguments.length,
          n = new Array(t > 2 ? t - 2 : 0),
          o = 2;
        o < t;
        o++
      )
        n[o - 2] = arguments[o]
      return isFunction$1(e)
        ? e.apply(void 0, n)
        : Vue.mergeProps.apply(void 0, n)
    }, '_mergeProps'),
    _extend: __name(function (e) {
      var t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
        n = __name(function (n, o, i, r, a) {
          var s, l, c, d
          o._$instances = o._$instances || {}
          var u = BaseDirective._getConfig(i, r),
            p = o._$instances[e] || {},
            h = isEmpty(p)
              ? _objectSpread$g(
                  _objectSpread$g({}, t),
                  null == t ? void 0 : t.methods
                )
              : {}
          ;(o._$instances[e] = _objectSpread$g(
            _objectSpread$g({}, p),
            {},
            {
              $name: e,
              $host: o,
              $binding: i,
              $modifiers: null == i ? void 0 : i.modifiers,
              $value: null == i ? void 0 : i.value,
              $el: p.$el || o || void 0,
              $style: _objectSpread$g(
                {
                  classes: void 0,
                  inlineStyles: void 0,
                  load: __name(function () {}, 'load'),
                  loadCSS: __name(function () {}, 'loadCSS'),
                  loadTheme: __name(function () {}, 'loadTheme')
                },
                null == t ? void 0 : t.style
              ),
              $primevueConfig: u,
              $attrSelector:
                null === (s = o.$pd) ||
                void 0 === s ||
                null === (s = s[e]) ||
                void 0 === s
                  ? void 0
                  : s.attrSelector,
              defaultPT: __name(function () {
                return BaseDirective._getPT(
                  null == u ? void 0 : u.pt,
                  void 0,
                  function (t) {
                    var n
                    return null == t ||
                      null === (n = t.directives) ||
                      void 0 === n
                      ? void 0
                      : n[e]
                  }
                )
              }, 'defaultPT'),
              isUnstyled: __name(function () {
                var e, t
                return void 0 !==
                  (null === (e = o.$instance) ||
                  void 0 === e ||
                  null === (e = e.$binding) ||
                  void 0 === e ||
                  null === (e = e.value) ||
                  void 0 === e
                    ? void 0
                    : e.unstyled)
                  ? null === (t = o.$instance) ||
                    void 0 === t ||
                    null === (t = t.$binding) ||
                    void 0 === t ||
                    null === (t = t.value) ||
                    void 0 === t
                    ? void 0
                    : t.unstyled
                  : null == u
                    ? void 0
                    : u.unstyled
              }, 'isUnstyled'),
              theme: __name(function () {
                var e
                return null === (e = o.$instance) ||
                  void 0 === e ||
                  null === (e = e.$primevueConfig) ||
                  void 0 === e
                  ? void 0
                  : e.theme
              }, 'theme'),
              preset: __name(function () {
                var e
                return null === (e = o.$instance) ||
                  void 0 === e ||
                  null === (e = e.$binding) ||
                  void 0 === e ||
                  null === (e = e.value) ||
                  void 0 === e
                  ? void 0
                  : e.dt
              }, 'preset'),
              ptm: __name(function () {
                var e,
                  t =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : '',
                  n =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {}
                return BaseDirective._getPTValue(
                  o.$instance,
                  null === (e = o.$instance) ||
                    void 0 === e ||
                    null === (e = e.$binding) ||
                    void 0 === e ||
                    null === (e = e.value) ||
                    void 0 === e
                    ? void 0
                    : e.pt,
                  t,
                  _objectSpread$g({}, n)
                )
              }, 'ptm'),
              ptmo: __name(function () {
                var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : {},
                  t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : '',
                  n =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : {}
                return BaseDirective._getPTValue(o.$instance, e, t, n, !1)
              }, 'ptmo'),
              cx: __name(function () {
                var e,
                  t,
                  n =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : '',
                  i =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {}
                return null !== (e = o.$instance) &&
                  void 0 !== e &&
                  e.isUnstyled()
                  ? void 0
                  : BaseDirective._getOptionValue(
                      null === (t = o.$instance) ||
                        void 0 === t ||
                        null === (t = t.$style) ||
                        void 0 === t
                        ? void 0
                        : t.classes,
                      n,
                      _objectSpread$g({}, i)
                    )
              }, 'cx'),
              sx: __name(function () {
                var e,
                  t =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : '',
                  n =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : {}
                return !(arguments.length > 1 && void 0 !== arguments[1]) ||
                  arguments[1]
                  ? BaseDirective._getOptionValue(
                      null === (e = o.$instance) ||
                        void 0 === e ||
                        null === (e = e.$style) ||
                        void 0 === e
                        ? void 0
                        : e.inlineStyles,
                      t,
                      _objectSpread$g({}, n)
                    )
                  : void 0
              }, 'sx')
            },
            h
          )),
            (o.$instance = o._$instances[e]),
            null === (l = (c = o.$instance)[n]) ||
              void 0 === l ||
              l.call(c, o, i, r, a),
            (o['$'.concat(e)] = o.$instance),
            BaseDirective._hook(e, n, o, i, r, a),
            o.$pd || (o.$pd = {}),
            (o.$pd[e] = _objectSpread$g(
              _objectSpread$g(
                {},
                null === (d = o.$pd) || void 0 === d ? void 0 : d[e]
              ),
              {},
              { name: e, instance: o.$instance }
            ))
        }, 'handleHook'),
        o = __name(function (e) {
          var t,
            n,
            o,
            i,
            r,
            a = null === (t = e.$instance) || void 0 === t ? void 0 : t.watch
          null == a ||
            null === (n = a.config) ||
            void 0 === n ||
            n.call(
              e.$instance,
              null === (o = e.$instance) || void 0 === o
                ? void 0
                : o.$primevueConfig
            ),
            PrimeVueService.on('config:change', function (t) {
              var n,
                o = t.newValue,
                i = t.oldValue
              return null == a || null === (n = a.config) || void 0 === n
                ? void 0
                : n.call(e.$instance, o, i)
            }),
            null == a ||
              null === (i = a['config.ripple']) ||
              void 0 === i ||
              i.call(
                e.$instance,
                null === (r = e.$instance) ||
                  void 0 === r ||
                  null === (r = r.$primevueConfig) ||
                  void 0 === r
                  ? void 0
                  : r.ripple
              ),
            PrimeVueService.on('config:ripple:change', function (t) {
              var n,
                o = t.newValue,
                i = t.oldValue
              return null == a ||
                null === (n = a['config.ripple']) ||
                void 0 === n
                ? void 0
                : n.call(e.$instance, o, i)
            })
        }, 'handleWatch')
      return {
        created: __name(function (t, o, i, r) {
          t.$pd || (t.$pd = {}),
            (t.$pd[e] = { name: e, attrSelector: uuid('pd') }),
            n('created', t, o, i, r)
        }, 'created'),
        beforeMount: __name(function (e, t, i, r) {
          BaseDirective._loadStyles(e, t, i), n('beforeMount', e, t, i, r), o(e)
        }, 'beforeMount'),
        mounted: __name(function (e, t, o, i) {
          BaseDirective._loadStyles(e, t, o), n('mounted', e, t, o, i)
        }, 'mounted'),
        beforeUpdate: __name(function (e, t, o, i) {
          n('beforeUpdate', e, t, o, i)
        }, 'beforeUpdate'),
        updated: __name(function (e, t, o, i) {
          BaseDirective._loadStyles(e, t, o), n('updated', e, t, o, i)
        }, 'updated'),
        beforeUnmount: __name(function (e, t, o, i) {
          n('beforeUnmount', e, t, o, i)
        }, 'beforeUnmount'),
        unmounted: __name(function (e, t, o, i) {
          var r
          null === (r = e.$instance) ||
            void 0 === r ||
            null === (r = r.scopedStyleEl) ||
            void 0 === r ||
            null === (r = r.value) ||
            void 0 === r ||
            r.remove(),
            n('unmounted', e, t, o, i)
        }, 'unmounted')
      }
    }, '_extend'),
    extend: __name(function () {
      var e = _slicedToArray$2(
          BaseDirective._getMeta.apply(BaseDirective, arguments),
          2
        ),
        t = e[0],
        n = e[1]
      return _objectSpread$g(
        {
          extend: __name(function () {
            var e = _slicedToArray$2(
                BaseDirective._getMeta.apply(BaseDirective, arguments),
                2
              ),
              t = e[0],
              o = e[1]
            return BaseDirective.extend(
              t,
              _objectSpread$g(
                _objectSpread$g(
                  _objectSpread$g({}, n),
                  null == n ? void 0 : n.methods
                ),
                o
              )
            )
          }, 'extend')
        },
        BaseDirective._extend(t, n)
      )
    }, 'extend')
  },
  theme$x = __name(function (e) {
    var t = e.dt
    return '\n.p-ink {\n    display: block;\n    position: absolute;\n    background: '.concat(
      t('ripple.background'),
      ';\n    border-radius: 100%;\n    transform: scale(0);\n    pointer-events: none;\n}\n\n.p-ink-active {\n    animation: ripple 0.4s linear;\n}\n\n@keyframes ripple {\n    100% {\n        opacity: 0;\n        transform: scale(2.5);\n    }\n}\n'
    )
  }, 'theme'),
  classes$y = { root: 'p-ink' },
  RippleStyle = BaseStyle.extend({
    name: 'ripple-directive',
    theme: theme$x,
    classes: classes$y
  }),
  BaseRipple = BaseDirective.extend({ style: RippleStyle })
function _typeof$f(e) {
  return (_typeof$f =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function _toConsumableArray$a(e) {
  return (
    _arrayWithoutHoles$a(e) ||
    _iterableToArray$a(e) ||
    _unsupportedIterableToArray$d(e) ||
    _nonIterableSpread$a()
  )
}
function _nonIterableSpread$a() {
  throw new TypeError(
    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$d(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$d(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$d(e, t)
          : void 0
    )
  }
}
function _iterableToArray$a(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _arrayWithoutHoles$a(e) {
  if (Array.isArray(e)) return _arrayLikeToArray$d(e)
}
function _arrayLikeToArray$d(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
function _defineProperty$f(e, t, n) {
  return (
    (t = _toPropertyKey$e(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$e(e) {
  var t = _toPrimitive$e(e, 'string')
  return 'symbol' == _typeof$f(t) ? t : t + ''
}
function _toPrimitive$e(e, t) {
  if ('object' != _typeof$f(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$f(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$f, '_typeof$f'),
  __name(_toConsumableArray$a, '_toConsumableArray$a'),
  __name(_nonIterableSpread$a, '_nonIterableSpread$a'),
  __name(_unsupportedIterableToArray$d, '_unsupportedIterableToArray$d'),
  __name(_iterableToArray$a, '_iterableToArray$a'),
  __name(_arrayWithoutHoles$a, '_arrayWithoutHoles$a'),
  __name(_arrayLikeToArray$d, '_arrayLikeToArray$d'),
  __name(_defineProperty$f, '_defineProperty$f'),
  __name(_toPropertyKey$e, '_toPropertyKey$e'),
  __name(_toPrimitive$e, '_toPrimitive$e')
var Ripple = BaseRipple.extend('ripple', {
    watch: {
      'config.ripple': __name(function (e) {
        e
          ? (this.createRipple(this.$host),
            this.bindEvents(this.$host),
            this.$host.setAttribute('data-pd-ripple', !0),
            (this.$host.style.overflow = 'hidden'),
            (this.$host.style.position = 'relative'))
          : (this.remove(this.$host),
            this.$host.removeAttribute('data-pd-ripple'))
      }, 'configRipple')
    },
    unmounted: __name(function (e) {
      this.remove(e)
    }, 'unmounted'),
    timeout: void 0,
    methods: {
      bindEvents: __name(function (e) {
        e.addEventListener('mousedown', this.onMouseDown.bind(this))
      }, 'bindEvents'),
      unbindEvents: __name(function (e) {
        e.removeEventListener('mousedown', this.onMouseDown.bind(this))
      }, 'unbindEvents'),
      createRipple: __name(function (e) {
        var t = createElement(
          'span',
          _defineProperty$f(
            _defineProperty$f(
              {
                role: 'presentation',
                'aria-hidden': !0,
                'data-p-ink': !0,
                'data-p-ink-active': !1,
                class: !this.isUnstyled() && this.cx('root'),
                onAnimationEnd: this.onAnimationEnd.bind(this)
              },
              this.$attrSelector,
              ''
            ),
            'p-bind',
            this.ptm('root')
          )
        )
        e.appendChild(t), (this.$el = t)
      }, 'createRipple'),
      remove: __name(function (e) {
        var t = this.getInk(e)
        t &&
          ((this.$host.style.overflow = ''),
          (this.$host.style.position = ''),
          this.unbindEvents(e),
          t.removeEventListener('animationend', this.onAnimationEnd),
          t.remove())
      }, 'remove'),
      onMouseDown: __name(function (e) {
        var t = this,
          n = e.currentTarget,
          o = this.getInk(n)
        if (o && 'none' !== getComputedStyle(o, null).display) {
          if (
            (!this.isUnstyled() && removeClass(o, 'p-ink-active'),
            o.setAttribute('data-p-ink-active', 'false'),
            !getHeight(o) && !getWidth(o))
          ) {
            var i = Math.max(getOuterWidth(n), getOuterHeight(n))
            ;(o.style.height = i + 'px'), (o.style.width = i + 'px')
          }
          var r = getOffset(n),
            a = e.pageX - r.left + document.body.scrollTop - getWidth(o) / 2,
            s = e.pageY - r.top + document.body.scrollLeft - getHeight(o) / 2
          ;(o.style.top = s + 'px'),
            (o.style.left = a + 'px'),
            !this.isUnstyled() && addClass(o, 'p-ink-active'),
            o.setAttribute('data-p-ink-active', 'true'),
            (this.timeout = setTimeout(function () {
              o &&
                (!t.isUnstyled() && removeClass(o, 'p-ink-active'),
                o.setAttribute('data-p-ink-active', 'false'))
            }, 401))
        }
      }, 'onMouseDown'),
      onAnimationEnd: __name(function (e) {
        this.timeout && clearTimeout(this.timeout),
          !this.isUnstyled() && removeClass(e.currentTarget, 'p-ink-active'),
          e.currentTarget.setAttribute('data-p-ink-active', 'false')
      }, 'onAnimationEnd'),
      getInk: __name(function (e) {
        return e && e.children
          ? _toConsumableArray$a(e.children).find(function (e) {
              return 'ripple' === getAttribute(e, 'data-pc-name')
            })
          : void 0
      }, 'getInk')
    }
  }),
  script$O = { name: 'SpinnerIcon', extends: script$X }
function render$N(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              d: 'M6.99701 14C5.85441 13.999 4.72939 13.7186 3.72012 13.1832C2.71084 12.6478 1.84795 11.8737 1.20673 10.9284C0.565504 9.98305 0.165424 8.89526 0.041387 7.75989C-0.0826496 6.62453 0.073125 5.47607 0.495122 4.4147C0.917119 3.35333 1.59252 2.4113 2.46241 1.67077C3.33229 0.930247 4.37024 0.413729 5.4857 0.166275C6.60117 -0.0811796 7.76026 -0.0520535 8.86188 0.251112C9.9635 0.554278 10.9742 1.12227 11.8057 1.90555C11.915 2.01493 11.9764 2.16319 11.9764 2.31778C11.9764 2.47236 11.915 2.62062 11.8057 2.73C11.7521 2.78503 11.688 2.82877 11.6171 2.85864C11.5463 2.8885 11.4702 2.90389 11.3933 2.90389C11.3165 2.90389 11.2404 2.8885 11.1695 2.85864C11.0987 2.82877 11.0346 2.78503 10.9809 2.73C9.9998 1.81273 8.73246 1.26138 7.39226 1.16876C6.05206 1.07615 4.72086 1.44794 3.62279 2.22152C2.52471 2.99511 1.72683 4.12325 1.36345 5.41602C1.00008 6.70879 1.09342 8.08723 1.62775 9.31926C2.16209 10.5513 3.10478 11.5617 4.29713 12.1803C5.48947 12.7989 6.85865 12.988 8.17414 12.7157C9.48963 12.4435 10.6711 11.7264 11.5196 10.6854C12.3681 9.64432 12.8319 8.34282 12.8328 7C12.8328 6.84529 12.8943 6.69692 13.0038 6.58752C13.1132 6.47812 13.2616 6.41667 13.4164 6.41667C13.5712 6.41667 13.7196 6.47812 13.8291 6.58752C13.9385 6.69692 14 6.84529 14 7C14 8.85651 13.2622 10.637 11.9489 11.9497C10.6356 13.2625 8.85432 14 6.99701 14Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$N, 'render$N'), (script$O.render = render$N)
var theme$w = __name(function (e) {
    var t = e.dt
    return '\n.p-virtualscroller-loader {\n    background: '
      .concat(t('virtualscroller.loader.mask.background'), ';\n    color: ')
      .concat(
        t('virtualscroller.loader.mask.color'),
        ';\n}\n\n.p-virtualscroller-loading-icon {\n    font-size: '
      )
      .concat(t('virtualscroller.loader.icon.size'), ';\n    width: ')
      .concat(t('virtualscroller.loader.icon.size'), ';\n    height: ')
      .concat(t('virtualscroller.loader.icon.size'), ';\n}\n')
  }, 'theme'),
  css =
    '\n.p-virtualscroller {\n    position: relative;\n    overflow: auto;\n    contain: strict;\n    transform: translateZ(0);\n    will-change: scroll-position;\n    outline: 0 none;\n}\n\n.p-virtualscroller-content {\n    position: absolute;\n    top: 0;\n    left: 0;\n    min-height: 100%;\n    min-width: 100%;\n    will-change: transform;\n}\n\n.p-virtualscroller-spacer {\n    position: absolute;\n    top: 0;\n    left: 0;\n    height: 1px;\n    width: 1px;\n    transform-origin: 0 0;\n    pointer-events: none;\n}\n\n.p-virtualscroller-loader {\n    position: sticky;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n\n.p-virtualscroller-loader-mask {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-virtualscroller-horizontal > .p-virtualscroller-content {\n    display: flex;\n}\n\n.p-virtualscroller-inline .p-virtualscroller-content {\n    position: static;\n}\n',
  VirtualScrollerStyle = BaseStyle.extend({
    name: 'virtualscroller',
    css: css,
    theme: theme$w
  }),
  script$1$x = {
    name: 'BaseVirtualScroller',
    extends: script$Y,
    props: {
      id: { type: String, default: null },
      style: null,
      class: null,
      items: { type: Array, default: null },
      itemSize: { type: [Number, Array], default: 0 },
      scrollHeight: null,
      scrollWidth: null,
      orientation: { type: String, default: 'vertical' },
      numToleratedItems: { type: Number, default: null },
      delay: { type: Number, default: 0 },
      resizeDelay: { type: Number, default: 10 },
      lazy: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      loaderDisabled: { type: Boolean, default: !1 },
      columns: { type: Array, default: null },
      loading: { type: Boolean, default: !1 },
      showSpacer: { type: Boolean, default: !0 },
      showLoader: { type: Boolean, default: !1 },
      tabindex: { type: Number, default: 0 },
      inline: { type: Boolean, default: !1 },
      step: { type: Number, default: 0 },
      appendOnly: { type: Boolean, default: !1 },
      autoSize: { type: Boolean, default: !1 }
    },
    style: VirtualScrollerStyle,
    provide: __name(function () {
      return { $pcVirtualScroller: this, $parentInstance: this }
    }, 'provide'),
    beforeMount: __name(function () {
      var e
      VirtualScrollerStyle.loadCSS({
        nonce:
          null === (e = this.$primevueConfig) ||
          void 0 === e ||
          null === (e = e.csp) ||
          void 0 === e
            ? void 0
            : e.nonce
      })
    }, 'beforeMount')
  }
function _typeof$e(e) {
  return (_typeof$e =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$f(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$f(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$f(Object(n), !0).forEach(function (t) {
          _defineProperty$e(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$f(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$e(e, t, n) {
  return (
    (t = _toPropertyKey$d(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$d(e) {
  var t = _toPrimitive$d(e, 'string')
  return 'symbol' == _typeof$e(t) ? t : t + ''
}
function _toPrimitive$d(e, t) {
  if ('object' != _typeof$e(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$e(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$e, '_typeof$e'),
  __name(ownKeys$f, 'ownKeys$f'),
  __name(_objectSpread$f, '_objectSpread$f'),
  __name(_defineProperty$e, '_defineProperty$e'),
  __name(_toPropertyKey$d, '_toPropertyKey$d'),
  __name(_toPrimitive$d, '_toPrimitive$d')
var script$N = {
    name: 'VirtualScroller',
    extends: script$1$x,
    inheritAttrs: !1,
    emits: [
      'update:numToleratedItems',
      'scroll',
      'scroll-index-change',
      'lazy-load'
    ],
    data: __name(function () {
      var e = this.isBoth()
      return {
        first: e ? { rows: 0, cols: 0 } : 0,
        last: e ? { rows: 0, cols: 0 } : 0,
        page: e ? { rows: 0, cols: 0 } : 0,
        numItemsInViewport: e ? { rows: 0, cols: 0 } : 0,
        lastScrollPos: e ? { top: 0, left: 0 } : 0,
        d_numToleratedItems: this.numToleratedItems,
        d_loading: this.loading,
        loaderArr: [],
        spacerStyle: {},
        contentStyle: {}
      }
    }, 'data'),
    element: null,
    content: null,
    lastScrollPos: null,
    scrollTimeout: null,
    resizeTimeout: null,
    defaultWidth: 0,
    defaultHeight: 0,
    defaultContentWidth: 0,
    defaultContentHeight: 0,
    isRangeChanged: !1,
    lazyLoadState: {},
    resizeListener: null,
    initialized: !1,
    watch: {
      numToleratedItems: __name(function (e) {
        this.d_numToleratedItems = e
      }, 'numToleratedItems'),
      loading: __name(function (e, t) {
        this.lazy && e !== t && e !== this.d_loading && (this.d_loading = e)
      }, 'loading'),
      items: __name(function (e, t) {
        ;(t && t.length === (e || []).length) ||
          (this.init(), this.calculateAutoSize())
      }, 'items'),
      itemSize: __name(function () {
        this.init(), this.calculateAutoSize()
      }, 'itemSize'),
      orientation: __name(function () {
        this.lastScrollPos = this.isBoth() ? { top: 0, left: 0 } : 0
      }, 'orientation'),
      scrollHeight: __name(function () {
        this.init(), this.calculateAutoSize()
      }, 'scrollHeight'),
      scrollWidth: __name(function () {
        this.init(), this.calculateAutoSize()
      }, 'scrollWidth')
    },
    mounted: __name(function () {
      this.viewInit(),
        (this.lastScrollPos = this.isBoth() ? { top: 0, left: 0 } : 0),
        (this.lazyLoadState = this.lazyLoadState || {})
    }, 'mounted'),
    updated: __name(function () {
      !this.initialized && this.viewInit()
    }, 'updated'),
    unmounted: __name(function () {
      this.unbindResizeListener(), (this.initialized = !1)
    }, 'unmounted'),
    methods: {
      viewInit: __name(function () {
        isVisible(this.element) &&
          (this.setContentEl(this.content),
          this.init(),
          this.calculateAutoSize(),
          this.bindResizeListener(),
          (this.defaultWidth = getWidth(this.element)),
          (this.defaultHeight = getHeight(this.element)),
          (this.defaultContentWidth = getWidth(this.content)),
          (this.defaultContentHeight = getHeight(this.content)),
          (this.initialized = !0))
      }, 'viewInit'),
      init: __name(function () {
        this.disabled ||
          (this.setSize(), this.calculateOptions(), this.setSpacerSize())
      }, 'init'),
      isVertical: __name(function () {
        return 'vertical' === this.orientation
      }, 'isVertical'),
      isHorizontal: __name(function () {
        return 'horizontal' === this.orientation
      }, 'isHorizontal'),
      isBoth: __name(function () {
        return 'both' === this.orientation
      }, 'isBoth'),
      scrollTo: __name(function (e) {
        this.element && this.element.scrollTo(e)
      }, 'scrollTo'),
      scrollToIndex: __name(function (e) {
        var t = this,
          n =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : 'auto',
          o = this.isBoth(),
          i = this.isHorizontal()
        if (
          o
            ? e.every(function (e) {
                return e > -1
              })
            : e > -1
        ) {
          var r = this.first,
            a = this.element,
            s = a.scrollTop,
            l = void 0 === s ? 0 : s,
            c = a.scrollLeft,
            d = void 0 === c ? 0 : c,
            u = this.calculateNumItems().numToleratedItems,
            p = this.getContentPosition(),
            h = this.itemSize,
            m = __name(function () {
              var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 0
              return e <= (arguments.length > 1 ? arguments[1] : void 0) ? 0 : e
            }, 'calculateFirst'),
            f = __name(function (e, t, n) {
              return e * t + n
            }, 'calculateCoord'),
            _ = __name(function () {
              var e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : 0,
                o =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : 0
              return t.scrollTo({ left: e, top: o, behavior: n })
            }, 'scrollTo'),
            g = o ? { rows: 0, cols: 0 } : 0,
            v = !1,
            y = !1
          o
            ? (_(
                f(
                  (g = { rows: m(e[0], u[0]), cols: m(e[1], u[1]) }).cols,
                  h[1],
                  p.left
                ),
                f(g.rows, h[0], p.top)
              ),
              (y =
                this.lastScrollPos.top !== l || this.lastScrollPos.left !== d),
              (v = g.rows !== r.rows || g.cols !== r.cols))
            : ((g = m(e, u)),
              i ? _(f(g, h, p.left), l) : _(d, f(g, h, p.top)),
              (y = this.lastScrollPos !== (i ? d : l)),
              (v = g !== r)),
            (this.isRangeChanged = v),
            y && (this.first = g)
        }
      }, 'scrollToIndex'),
      scrollInView: __name(function (e, t) {
        var n = this,
          o =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : 'auto'
        if (t) {
          var i = this.isBoth(),
            r = this.isHorizontal()
          if (
            i
              ? e.every(function (e) {
                  return e > -1
                })
              : e > -1
          ) {
            var a = this.getRenderedRange(),
              s = a.first,
              l = a.viewport,
              c = __name(function () {
                var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : 0,
                  t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : 0
                return n.scrollTo({ left: e, top: t, behavior: o })
              }, 'scrollTo'),
              d = 'to-end' === t
            if ('to-start' === t) {
              if (i)
                l.first.rows - s.rows > e[0]
                  ? c(
                      l.first.cols * this.itemSize[1],
                      (l.first.rows - 1) * this.itemSize[0]
                    )
                  : l.first.cols - s.cols > e[1] &&
                    c(
                      (l.first.cols - 1) * this.itemSize[1],
                      l.first.rows * this.itemSize[0]
                    )
              else if (l.first - s > e) {
                var u = (l.first - 1) * this.itemSize
                r ? c(u, 0) : c(0, u)
              }
            } else if (d)
              if (i)
                l.last.rows - s.rows <= e[0] + 1
                  ? c(
                      l.first.cols * this.itemSize[1],
                      (l.first.rows + 1) * this.itemSize[0]
                    )
                  : l.last.cols - s.cols <= e[1] + 1 &&
                    c(
                      (l.first.cols + 1) * this.itemSize[1],
                      l.first.rows * this.itemSize[0]
                    )
              else if (l.last - s <= e + 1) {
                var p = (l.first + 1) * this.itemSize
                r ? c(p, 0) : c(0, p)
              }
          }
        } else this.scrollToIndex(e, o)
      }, 'scrollInView'),
      getRenderedRange: __name(function () {
        var e = __name(function (e, t) {
            return Math.floor(e / (t || e))
          }, 'calculateFirstInViewport'),
          t = this.first,
          n = 0
        if (this.element) {
          var o = this.isBoth(),
            i = this.isHorizontal(),
            r = this.element,
            a = r.scrollTop,
            s = r.scrollLeft
          if (o)
            n = {
              rows:
                (t = {
                  rows: e(a, this.itemSize[0]),
                  cols: e(s, this.itemSize[1])
                }).rows + this.numItemsInViewport.rows,
              cols: t.cols + this.numItemsInViewport.cols
            }
          else n = (t = e(i ? s : a, this.itemSize)) + this.numItemsInViewport
        }
        return {
          first: this.first,
          last: this.last,
          viewport: { first: t, last: n }
        }
      }, 'getRenderedRange'),
      calculateNumItems: __name(function () {
        var e = this.isBoth(),
          t = this.isHorizontal(),
          n = this.itemSize,
          o = this.getContentPosition(),
          i = this.element ? this.element.offsetWidth - o.left : 0,
          r = this.element ? this.element.offsetHeight - o.top : 0,
          a = __name(function (e, t) {
            return Math.ceil(e / (t || e))
          }, 'calculateNumItemsInViewport'),
          s = __name(function (e) {
            return Math.ceil(e / 2)
          }, 'calculateNumToleratedItems'),
          l = e ? { rows: a(r, n[0]), cols: a(i, n[1]) } : a(t ? i : r, n)
        return {
          numItemsInViewport: l,
          numToleratedItems:
            this.d_numToleratedItems || (e ? [s(l.rows), s(l.cols)] : s(l))
        }
      }, 'calculateNumItems'),
      calculateOptions: __name(function () {
        var e = this,
          t = this.isBoth(),
          n = this.first,
          o = this.calculateNumItems(),
          i = o.numItemsInViewport,
          r = o.numToleratedItems,
          a = __name(function (t, n, o) {
            var i =
              arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
            return e.getLast(t + n + (t < o ? 2 : 3) * o, i)
          }, 'calculateLast'),
          s = t
            ? {
                rows: a(n.rows, i.rows, r[0]),
                cols: a(n.cols, i.cols, r[1], !0)
              }
            : a(n, i, r)
        ;(this.last = s),
          (this.numItemsInViewport = i),
          (this.d_numToleratedItems = r),
          this.$emit('update:numToleratedItems', this.d_numToleratedItems),
          this.showLoader &&
            (this.loaderArr = t
              ? Array.from({ length: i.rows }).map(function () {
                  return Array.from({ length: i.cols })
                })
              : Array.from({ length: i })),
          this.lazy &&
            Promise.resolve().then(function () {
              var o
              ;(e.lazyLoadState = {
                first: e.step ? (t ? { rows: 0, cols: n.cols } : 0) : n,
                last: Math.min(
                  e.step ? e.step : s,
                  (null === (o = e.items) || void 0 === o
                    ? void 0
                    : o.length) || 0
                )
              }),
                e.$emit('lazy-load', e.lazyLoadState)
            })
      }, 'calculateOptions'),
      calculateAutoSize: __name(function () {
        var e = this
        this.autoSize &&
          !this.d_loading &&
          Promise.resolve().then(function () {
            if (e.content) {
              var t = e.isBoth(),
                n = e.isHorizontal(),
                o = e.isVertical()
              ;(e.content.style.minHeight = e.content.style.minWidth = 'auto'),
                (e.content.style.position = 'relative'),
                (e.element.style.contain = 'none')
              var i = [getWidth(e.element), getHeight(e.element)],
                r = i[0],
                a = i[1]
              ;(t || n) &&
                (e.element.style.width =
                  r < e.defaultWidth
                    ? r + 'px'
                    : e.scrollWidth || e.defaultWidth + 'px'),
                (t || o) &&
                  (e.element.style.height =
                    a < e.defaultHeight
                      ? a + 'px'
                      : e.scrollHeight || e.defaultHeight + 'px'),
                (e.content.style.minHeight = e.content.style.minWidth = ''),
                (e.content.style.position = ''),
                (e.element.style.contain = '')
            }
          })
      }, 'calculateAutoSize'),
      getLast: __name(function () {
        var e,
          t,
          n =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
          o = arguments.length > 1 ? arguments[1] : void 0
        return this.items
          ? Math.min(
              o
                ? (null === (e = this.columns || this.items[0]) || void 0 === e
                    ? void 0
                    : e.length) || 0
                : (null === (t = this.items) || void 0 === t
                    ? void 0
                    : t.length) || 0,
              n
            )
          : 0
      }, 'getLast'),
      getContentPosition: __name(function () {
        if (this.content) {
          var e = getComputedStyle(this.content),
            t =
              parseFloat(e.paddingLeft) + Math.max(parseFloat(e.left) || 0, 0),
            n =
              parseFloat(e.paddingRight) +
              Math.max(parseFloat(e.right) || 0, 0),
            o = parseFloat(e.paddingTop) + Math.max(parseFloat(e.top) || 0, 0),
            i =
              parseFloat(e.paddingBottom) +
              Math.max(parseFloat(e.bottom) || 0, 0)
          return { left: t, right: n, top: o, bottom: i, x: t + n, y: o + i }
        }
        return { left: 0, right: 0, top: 0, bottom: 0, x: 0, y: 0 }
      }, 'getContentPosition'),
      setSize: __name(function () {
        var e = this
        if (this.element) {
          var t = this.isBoth(),
            n = this.isHorizontal(),
            o = this.element.parentElement,
            i =
              this.scrollWidth ||
              ''.concat(this.element.offsetWidth || o.offsetWidth, 'px'),
            r =
              this.scrollHeight ||
              ''.concat(this.element.offsetHeight || o.offsetHeight, 'px'),
            a = __name(function (t, n) {
              return (e.element.style[t] = n)
            }, 'setProp')
          t || n ? (a('height', r), a('width', i)) : a('height', r)
        }
      }, 'setSize'),
      setSpacerSize: __name(function () {
        var e = this,
          t = this.items
        if (t) {
          var n = this.isBoth(),
            o = this.isHorizontal(),
            i = this.getContentPosition(),
            r = __name(function (t, n, o) {
              var i =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 0
              return (e.spacerStyle = _objectSpread$f(
                _objectSpread$f({}, e.spacerStyle),
                _defineProperty$e(
                  {},
                  ''.concat(t),
                  (n || []).length * o + i + 'px'
                )
              ))
            }, 'setProp')
          n
            ? (r('height', t, this.itemSize[0], i.y),
              r('width', this.columns || t[1], this.itemSize[1], i.x))
            : o
              ? r('width', this.columns || t, this.itemSize, i.x)
              : r('height', t, this.itemSize, i.y)
        }
      }, 'setSpacerSize'),
      setContentPosition: __name(function (e) {
        var t = this
        if (this.content && !this.appendOnly) {
          var n = this.isBoth(),
            o = this.isHorizontal(),
            i = e ? e.first : this.first,
            r = __name(function (e, t) {
              return e * t
            }, 'calculateTranslateVal'),
            a = __name(function () {
              var e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : 0,
                n =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : 0
              return (t.contentStyle = _objectSpread$f(
                _objectSpread$f({}, t.contentStyle),
                {
                  transform: 'translate3d('
                    .concat(e, 'px, ')
                    .concat(n, 'px, 0)')
                }
              ))
            }, 'setTransform')
          if (n) a(r(i.cols, this.itemSize[1]), r(i.rows, this.itemSize[0]))
          else {
            var s = r(i, this.itemSize)
            o ? a(s, 0) : a(0, s)
          }
        }
      }, 'setContentPosition'),
      onScrollPositionChange: __name(function (e) {
        var t = this,
          n = e.target,
          o = this.isBoth(),
          i = this.isHorizontal(),
          r = this.getContentPosition(),
          a = __name(function (e, t) {
            return e ? (e > t ? e - t : e) : 0
          }, 'calculateScrollPos'),
          s = __name(function (e, t) {
            return Math.floor(e / (t || e))
          }, 'calculateCurrentIndex'),
          l = __name(function (e, t, n, o, i, r) {
            return e <= i ? i : r ? n - o - i : t + i - 1
          }, 'calculateTriggerIndex'),
          c = __name(function (e, t, n, o, i, r, a) {
            return e <= r
              ? 0
              : Math.max(0, a ? (e < t ? n : e - r) : e > t ? n : e - 2 * r)
          }, 'calculateFirst'),
          d = __name(function (e, n, o, i, r, a) {
            var s = n + i + 2 * r
            return e >= r && (s += r + 1), t.getLast(s, a)
          }, 'calculateLast'),
          u = a(n.scrollTop, r.top),
          p = a(n.scrollLeft, r.left),
          h = o ? { rows: 0, cols: 0 } : 0,
          m = this.last,
          f = !1,
          _ = this.lastScrollPos
        if (o) {
          var g = this.lastScrollPos.top <= u,
            v = this.lastScrollPos.left <= p
          if (!this.appendOnly || (this.appendOnly && (g || v))) {
            var y = {
                rows: s(u, this.itemSize[0]),
                cols: s(p, this.itemSize[1])
              },
              b = {
                rows: l(
                  y.rows,
                  this.first.rows,
                  this.last.rows,
                  this.numItemsInViewport.rows,
                  this.d_numToleratedItems[0],
                  g
                ),
                cols: l(
                  y.cols,
                  this.first.cols,
                  this.last.cols,
                  this.numItemsInViewport.cols,
                  this.d_numToleratedItems[1],
                  v
                )
              }
            ;(h = {
              rows: c(
                y.rows,
                b.rows,
                this.first.rows,
                this.last.rows,
                this.numItemsInViewport.rows,
                this.d_numToleratedItems[0],
                g
              ),
              cols: c(
                y.cols,
                b.cols,
                this.first.cols,
                this.last.cols,
                this.numItemsInViewport.cols,
                this.d_numToleratedItems[1],
                v
              )
            }),
              (m = {
                rows: d(
                  y.rows,
                  h.rows,
                  this.last.rows,
                  this.numItemsInViewport.rows,
                  this.d_numToleratedItems[0]
                ),
                cols: d(
                  y.cols,
                  h.cols,
                  this.last.cols,
                  this.numItemsInViewport.cols,
                  this.d_numToleratedItems[1],
                  !0
                )
              }),
              (f =
                h.rows !== this.first.rows ||
                m.rows !== this.last.rows ||
                h.cols !== this.first.cols ||
                m.cols !== this.last.cols ||
                this.isRangeChanged),
              (_ = { top: u, left: p })
          }
        } else {
          var S = i ? p : u,
            C = this.lastScrollPos <= S
          if (!this.appendOnly || (this.appendOnly && C)) {
            var w = s(S, this.itemSize)
            ;(m = d(
              w,
              (h = c(
                w,
                l(
                  w,
                  this.first,
                  this.last,
                  this.numItemsInViewport,
                  this.d_numToleratedItems,
                  C
                ),
                this.first,
                this.last,
                this.numItemsInViewport,
                this.d_numToleratedItems,
                C
              )),
              this.last,
              this.numItemsInViewport,
              this.d_numToleratedItems
            )),
              (f = h !== this.first || m !== this.last || this.isRangeChanged),
              (_ = S)
          }
        }
        return { first: h, last: m, isRangeChanged: f, scrollPos: _ }
      }, 'onScrollPositionChange'),
      onScrollChange: __name(function (e) {
        var t = this.onScrollPositionChange(e),
          n = t.first,
          o = t.last,
          i = t.isRangeChanged,
          r = t.scrollPos
        if (i) {
          var a = { first: n, last: o }
          if (
            (this.setContentPosition(a),
            (this.first = n),
            (this.last = o),
            (this.lastScrollPos = r),
            this.$emit('scroll-index-change', a),
            this.lazy && this.isPageChanged(n))
          ) {
            var s,
              l,
              c = {
                first: this.step
                  ? Math.min(
                      this.getPageByFirst(n) * this.step,
                      ((null === (s = this.items) || void 0 === s
                        ? void 0
                        : s.length) || 0) - this.step
                    )
                  : n,
                last: Math.min(
                  this.step ? (this.getPageByFirst(n) + 1) * this.step : o,
                  (null === (l = this.items) || void 0 === l
                    ? void 0
                    : l.length) || 0
                )
              }
            ;(this.lazyLoadState.first !== c.first ||
              this.lazyLoadState.last !== c.last) &&
              this.$emit('lazy-load', c),
              (this.lazyLoadState = c)
          }
        }
      }, 'onScrollChange'),
      onScroll: __name(function (e) {
        var t = this
        if ((this.$emit('scroll', e), this.delay)) {
          if (
            (this.scrollTimeout && clearTimeout(this.scrollTimeout),
            this.isPageChanged())
          ) {
            if (!this.d_loading && this.showLoader)
              (this.onScrollPositionChange(e).isRangeChanged ||
                (!!this.step && this.isPageChanged())) &&
                (this.d_loading = !0)
            this.scrollTimeout = setTimeout(function () {
              t.onScrollChange(e),
                !t.d_loading ||
                  !t.showLoader ||
                  (t.lazy && void 0 !== t.loading) ||
                  ((t.d_loading = !1), (t.page = t.getPageByFirst()))
            }, this.delay)
          }
        } else this.onScrollChange(e)
      }, 'onScroll'),
      onResize: __name(function () {
        var e = this
        this.resizeTimeout && clearTimeout(this.resizeTimeout),
          (this.resizeTimeout = setTimeout(function () {
            if (isVisible(e.element)) {
              var t = e.isBoth(),
                n = e.isVertical(),
                o = e.isHorizontal(),
                i = [getWidth(e.element), getHeight(e.element)],
                r = i[0],
                a = i[1],
                s = r !== e.defaultWidth,
                l = a !== e.defaultHeight
              ;(t ? s || l : o ? s : !!n && l) &&
                ((e.d_numToleratedItems = e.numToleratedItems),
                (e.defaultWidth = r),
                (e.defaultHeight = a),
                (e.defaultContentWidth = getWidth(e.content)),
                (e.defaultContentHeight = getHeight(e.content)),
                e.init())
            }
          }, this.resizeDelay))
      }, 'onResize'),
      bindResizeListener: __name(function () {
        this.resizeListener ||
          ((this.resizeListener = this.onResize.bind(this)),
          window.addEventListener('resize', this.resizeListener),
          window.addEventListener('orientationchange', this.resizeListener))
      }, 'bindResizeListener'),
      unbindResizeListener: __name(function () {
        this.resizeListener &&
          (window.removeEventListener('resize', this.resizeListener),
          window.removeEventListener('orientationchange', this.resizeListener),
          (this.resizeListener = null))
      }, 'unbindResizeListener'),
      getOptions: __name(function (e) {
        var t = (this.items || []).length,
          n = this.isBoth() ? this.first.rows + e : this.first + e
        return {
          index: n,
          count: t,
          first: 0 === n,
          last: n === t - 1,
          even: n % 2 == 0,
          odd: n % 2 != 0
        }
      }, 'getOptions'),
      getLoaderOptions: __name(function (e, t) {
        var n = this.loaderArr.length
        return _objectSpread$f(
          {
            index: e,
            count: n,
            first: 0 === e,
            last: e === n - 1,
            even: e % 2 == 0,
            odd: e % 2 != 0
          },
          t
        )
      }, 'getLoaderOptions'),
      getPageByFirst: __name(function (e) {
        return Math.floor(
          ((null != e ? e : this.first) + 4 * this.d_numToleratedItems) /
            (this.step || 1)
        )
      }, 'getPageByFirst'),
      isPageChanged: __name(function (e) {
        return (
          !(this.step && !this.lazy) ||
          this.page !== this.getPageByFirst(null != e ? e : this.first)
        )
      }, 'isPageChanged'),
      setContentEl: __name(function (e) {
        this.content =
          e ||
          this.content ||
          findSingle(this.element, '[data-pc-section="content"]')
      }, 'setContentEl'),
      elementRef: __name(function (e) {
        this.element = e
      }, 'elementRef'),
      contentRef: __name(function (e) {
        this.content = e
      }, 'contentRef')
    },
    computed: {
      containerClass: __name(function () {
        return [
          'p-virtualscroller',
          this.class,
          {
            'p-virtualscroller-inline': this.inline,
            'p-virtualscroller-both p-both-scroll': this.isBoth(),
            'p-virtualscroller-horizontal p-horizontal-scroll':
              this.isHorizontal()
          }
        ]
      }, 'containerClass'),
      contentClass: __name(function () {
        return [
          'p-virtualscroller-content',
          { 'p-virtualscroller-loading': this.d_loading }
        ]
      }, 'contentClass'),
      loaderClass: __name(function () {
        return [
          'p-virtualscroller-loader',
          { 'p-virtualscroller-loader-mask': !this.$slots.loader }
        ]
      }, 'loaderClass'),
      loadedItems: __name(function () {
        var e = this
        return this.items && !this.d_loading
          ? this.isBoth()
            ? this.items
                .slice(this.appendOnly ? 0 : this.first.rows, this.last.rows)
                .map(function (t) {
                  return e.columns
                    ? t
                    : t.slice(e.appendOnly ? 0 : e.first.cols, e.last.cols)
                })
            : this.isHorizontal() && this.columns
              ? this.items
              : this.items.slice(this.appendOnly ? 0 : this.first, this.last)
          : []
      }, 'loadedItems'),
      loadedRows: __name(function () {
        return this.d_loading
          ? this.loaderDisabled
            ? this.loaderArr
            : []
          : this.loadedItems
      }, 'loadedRows'),
      loadedColumns: __name(function () {
        if (this.columns) {
          var e = this.isBoth(),
            t = this.isHorizontal()
          if (e || t)
            return this.d_loading && this.loaderDisabled
              ? e
                ? this.loaderArr[0]
                : this.loaderArr
              : this.columns.slice(
                  e ? this.first.cols : this.first,
                  e ? this.last.cols : this.last
                )
        }
        return this.columns
      }, 'loadedColumns')
    },
    components: { SpinnerIcon: script$O }
  },
  _hoisted_1$10 = ['tabindex']
function render$M(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('SpinnerIcon')
  return e.disabled
    ? (Vue.openBlock(),
      Vue.createElementBlock(
        Vue.Fragment,
        { key: 1 },
        [
          Vue.renderSlot(e.$slots, 'default'),
          Vue.renderSlot(e.$slots, 'content', {
            items: e.items,
            rows: e.items,
            columns: r.loadedColumns
          })
        ],
        64
      ))
    : (Vue.openBlock(),
      Vue.createElementBlock(
        'div',
        Vue.mergeProps(
          {
            key: 0,
            ref: r.elementRef,
            class: r.containerClass,
            tabindex: e.tabindex,
            style: e.style,
            onScroll:
              t[0] ||
              (t[0] = function () {
                return r.onScroll && r.onScroll.apply(r, arguments)
              })
          },
          e.ptmi('root')
        ),
        [
          Vue.renderSlot(
            e.$slots,
            'content',
            {
              styleClass: r.contentClass,
              items: r.loadedItems,
              getItemOptions: r.getOptions,
              loading: i.d_loading,
              getLoaderOptions: r.getLoaderOptions,
              itemSize: e.itemSize,
              rows: r.loadedRows,
              columns: r.loadedColumns,
              contentRef: r.contentRef,
              spacerStyle: i.spacerStyle,
              contentStyle: i.contentStyle,
              vertical: r.isVertical(),
              horizontal: r.isHorizontal(),
              both: r.isBoth()
            },
            function () {
              return [
                Vue.createElementVNode(
                  'div',
                  Vue.mergeProps(
                    {
                      ref: r.contentRef,
                      class: r.contentClass,
                      style: i.contentStyle
                    },
                    e.ptm('content')
                  ),
                  [
                    (Vue.openBlock(!0),
                    Vue.createElementBlock(
                      Vue.Fragment,
                      null,
                      Vue.renderList(r.loadedItems, function (t, n) {
                        return Vue.renderSlot(e.$slots, 'item', {
                          key: n,
                          item: t,
                          options: r.getOptions(n)
                        })
                      }),
                      128
                    ))
                  ],
                  16
                )
              ]
            }
          ),
          e.showSpacer
            ? (Vue.openBlock(),
              Vue.createElementBlock(
                'div',
                Vue.mergeProps(
                  {
                    key: 0,
                    class: 'p-virtualscroller-spacer',
                    style: i.spacerStyle
                  },
                  e.ptm('spacer')
                ),
                null,
                16
              ))
            : Vue.createCommentVNode('', !0),
          !e.loaderDisabled && e.showLoader && i.d_loading
            ? (Vue.openBlock(),
              Vue.createElementBlock(
                'div',
                Vue.mergeProps(
                  { key: 1, class: r.loaderClass },
                  e.ptm('loader')
                ),
                [
                  e.$slots && e.$slots.loader
                    ? (Vue.openBlock(!0),
                      Vue.createElementBlock(
                        Vue.Fragment,
                        { key: 0 },
                        Vue.renderList(i.loaderArr, function (t, n) {
                          return Vue.renderSlot(e.$slots, 'loader', {
                            key: n,
                            options: r.getLoaderOptions(
                              n,
                              r.isBoth() && {
                                numCols: e.d_numItemsInViewport.cols
                              }
                            )
                          })
                        }),
                        128
                      ))
                    : Vue.createCommentVNode('', !0),
                  Vue.renderSlot(e.$slots, 'loadingicon', {}, function () {
                    return [
                      Vue.createVNode(
                        a,
                        Vue.mergeProps(
                          { spin: '', class: 'p-virtualscroller-loading-icon' },
                          e.ptm('loadingIcon')
                        ),
                        null,
                        16
                      )
                    ]
                  })
                ],
                16
              ))
            : Vue.createCommentVNode('', !0)
        ],
        16,
        _hoisted_1$10
      ))
}
__name(render$M, 'render$M'), (script$N.render = render$M)
var theme$v = __name(function (e) {
    var t = e.dt
    return '\n.p-listbox {\n    background: '
      .concat(t('listbox.background'), ';\n    color: ')
      .concat(t('listbox.color'), ';\n    border: 1px solid ')
      .concat(t('listbox.border.color'), ';\n    border-radius: ')
      .concat(t('listbox.border.radius'), ';\n    transition: background ')
      .concat(t('listbox.transition.duration'), ', color ')
      .concat(t('listbox.transition.duration'), ', border-color ')
      .concat(t('listbox.transition.duration'), ',\n            box-shadow ')
      .concat(t('listbox.transition.duration'), ', outline-color ')
      .concat(
        t('listbox.transition.duration'),
        ';\n    outline-color: transparent;\n    box-shadow: '
      )
      .concat(
        t('listbox.shadow'),
        ';\n}\n\n.p-listbox.p-disabled {\n    opacity: 1;\n    background: '
      )
      .concat(t('listbox.disabled.background'), ';\n    color: ')
      .concat(
        t('listbox.disabled.color'),
        ';\n}\n\n.p-listbox.p-disabled .p-listbox-option {\n    color: '
      )
      .concat(
        t('listbox.disabled.color'),
        ';\n}\n\n.p-listbox.p-invalid {\n    border-color: '
      )
      .concat(
        t('listbox.invalid.border.color'),
        ';\n}\n\n.p-listbox-header {\n    padding: '
      )
      .concat(
        t('listbox.list.header.padding'),
        ';\n}\n\n.p-listbox-filter {\n    width: 100%;\n}\n\n.p-listbox-list-container {\n    overflow: auto;\n}\n\n.p-listbox-list {\n    list-style-type: none;\n    margin: 0;\n    padding: '
      )
      .concat(
        t('listbox.list.padding'),
        ';\n    outline: 0 none;\n    display: flex;\n    flex-direction: column;\n    gap: '
      )
      .concat(
        t('listbox.list.gap'),
        ';\n}\n\n.p-listbox-option {\n    display: flex;\n    align-items: center;\n    cursor: pointer;\n    position: relative;\n    overflow: hidden;\n    padding: '
      )
      .concat(
        t('listbox.option.padding'),
        ';\n    border: 0 none;\n    border-radius: '
      )
      .concat(t('listbox.option.border.radius'), ';\n    color: ')
      .concat(t('listbox.option.color'), ';\n    transition: background ')
      .concat(t('listbox.transition.duration'), ', color ')
      .concat(t('listbox.transition.duration'), ', border-color ')
      .concat(t('listbox.transition.duration'), ',\n            box-shadow ')
      .concat(t('listbox.transition.duration'), ', outline-color ')
      .concat(
        t('listbox.transition.duration'),
        ';\n}\n\n.p-listbox-striped li:nth-child(even of .p-listbox-option) {\n    background: '
      )
      .concat(
        t('listbox.option.striped.background'),
        ';\n}\n\n.p-listbox .p-listbox-list .p-listbox-option.p-listbox-option-selected {\n    background: '
      )
      .concat(t('listbox.option.selected.background'), ';\n    color: ')
      .concat(
        t('listbox.option.selected.color'),
        ';\n}\n\n.p-listbox:not(.p-disabled) .p-listbox-option.p-listbox-option-selected.p-focus {\n    background: '
      )
      .concat(t('listbox.option.selected.focus.background'), ';\n    color: ')
      .concat(
        t('listbox.option.selected.focus.color'),
        ';\n}\n\n.p-listbox:not(.p-disabled) .p-listbox-option:not(.p-listbox-option-selected):not(.p-disabled).p-focus {\n    background: '
      )
      .concat(t('listbox.option.focus.background'), ';\n    color: ')
      .concat(
        t('listbox.option.focus.color'),
        ';\n}\n\n.p-listbox:not(.p-disabled) .p-listbox-option:not(.p-listbox-option-selected):not(.p-disabled):hover {\n    background: '
      )
      .concat(t('listbox.option.focus.background'), ';\n    color: ')
      .concat(
        t('listbox.option.focus.color'),
        ';\n}\n\n.p-listbox-option-check-icon {\n    position: relative;\n    margin-inline-start: '
      )
      .concat(t('listbox.checkmark.gutter.start'), ';\n    margin-inline-end: ')
      .concat(t('listbox.checkmark.gutter.end'), ';\n    color: ')
      .concat(
        t('listbox.checkmark.color'),
        ';\n}\n\n.p-listbox-option-group {\n    margin: 0;\n    padding: '
      )
      .concat(t('listbox.option.group.padding'), ';\n    color: ')
      .concat(t('listbox.option.group.color'), ';\n    background: ')
      .concat(t('listbox.option.group.background'), ';\n    font-weight: ')
      .concat(
        t('listbox.option.group.font.weight'),
        ';\n}\n\n.p-listbox-empty-message {\n    padding: '
      )
      .concat(t('listbox.empty.message.padding'), ';\n}\n')
  }, 'theme'),
  classes$x = {
    root: __name(function (e) {
      var t = e.instance,
        n = e.props
      return [
        'p-listbox p-component',
        {
          'p-listbox-striped': n.striped,
          'p-disabled': n.disabled,
          'p-invalid': t.$invalid
        }
      ]
    }, 'root'),
    header: 'p-listbox-header',
    pcFilter: 'p-listbox-filter',
    listContainer: 'p-listbox-list-container',
    list: 'p-listbox-list',
    optionGroup: 'p-listbox-option-group',
    option: __name(function (e) {
      var t = e.instance,
        n = e.props,
        o = e.option,
        i = e.index,
        r = e.getItemOptions
      return [
        'p-listbox-option',
        {
          'p-listbox-option-selected': t.isSelected(o) && n.highlightOnSelect,
          'p-focus': t.focusedOptionIndex === t.getOptionIndex(i, r),
          'p-disabled': t.isOptionDisabled(o)
        }
      ]
    }, 'option'),
    optionCheckIcon: 'p-listbox-option-check-icon',
    optionBlankIcon: 'p-listbox-option-blank-icon',
    emptyMessage: 'p-listbox-empty-message'
  },
  ListboxStyle = BaseStyle.extend({
    name: 'listbox',
    theme: theme$v,
    classes: classes$x
  }),
  script$1$w = {
    name: 'BaseListbox',
    extends: script$R,
    props: {
      options: Array,
      optionLabel: null,
      optionValue: null,
      optionDisabled: null,
      optionGroupLabel: null,
      optionGroupChildren: null,
      listStyle: null,
      scrollHeight: { type: String, default: '14rem' },
      dataKey: null,
      multiple: { type: Boolean, default: !1 },
      metaKeySelection: { type: Boolean, default: !1 },
      filter: Boolean,
      filterPlaceholder: String,
      filterLocale: String,
      filterMatchMode: { type: String, default: 'contains' },
      filterFields: { type: Array, default: null },
      virtualScrollerOptions: { type: Object, default: null },
      autoOptionFocus: { type: Boolean, default: !0 },
      selectOnFocus: { type: Boolean, default: !1 },
      focusOnHover: { type: Boolean, default: !0 },
      highlightOnSelect: { type: Boolean, default: !0 },
      checkmark: { type: Boolean, default: !1 },
      filterMessage: { type: String, default: null },
      selectionMessage: { type: String, default: null },
      emptySelectionMessage: { type: String, default: null },
      emptyFilterMessage: { type: String, default: null },
      emptyMessage: { type: String, default: null },
      filterIcon: { type: String, default: void 0 },
      striped: { type: Boolean, default: !1 },
      tabindex: { type: Number, default: 0 },
      ariaLabel: { type: String, default: null },
      ariaLabelledby: { type: String, default: null }
    },
    style: ListboxStyle,
    provide: __name(function () {
      return { $pcListbox: this, $parentInstance: this }
    }, 'provide')
  }
function _toConsumableArray$9(e) {
  return (
    _arrayWithoutHoles$9(e) ||
    _iterableToArray$9(e) ||
    _unsupportedIterableToArray$c(e) ||
    _nonIterableSpread$9()
  )
}
function _nonIterableSpread$9() {
  throw new TypeError(
    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$c(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$c(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$c(e, t)
          : void 0
    )
  }
}
function _iterableToArray$9(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _arrayWithoutHoles$9(e) {
  if (Array.isArray(e)) return _arrayLikeToArray$c(e)
}
function _arrayLikeToArray$c(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
__name(_toConsumableArray$9, '_toConsumableArray$9'),
  __name(_nonIterableSpread$9, '_nonIterableSpread$9'),
  __name(_unsupportedIterableToArray$c, '_unsupportedIterableToArray$c'),
  __name(_iterableToArray$9, '_iterableToArray$9'),
  __name(_arrayWithoutHoles$9, '_arrayWithoutHoles$9'),
  __name(_arrayLikeToArray$c, '_arrayLikeToArray$c')
var script$M = {
    name: 'Listbox',
    extends: script$1$w,
    inheritAttrs: !1,
    emits: [
      'change',
      'focus',
      'blur',
      'filter',
      'item-dblclick',
      'option-dblclick'
    ],
    list: null,
    virtualScroller: null,
    optionTouched: !1,
    startRangeIndex: -1,
    searchTimeout: null,
    searchValue: '',
    data: __name(function () {
      return {
        id: this.$attrs.id,
        filterValue: null,
        focused: !1,
        focusedOptionIndex: -1
      }
    }, 'data'),
    watch: {
      '$attrs.id': __name(function (e) {
        this.id = e || UniqueComponentId()
      }, '$attrsId'),
      options: __name(function () {
        this.autoUpdateModel()
      }, 'options')
    },
    mounted: __name(function () {
      ;(this.id = this.id || UniqueComponentId()), this.autoUpdateModel()
    }, 'mounted'),
    methods: {
      getOptionIndex: __name(function (e, t) {
        return this.virtualScrollerDisabled ? e : t && t(e).index
      }, 'getOptionIndex'),
      getOptionLabel: __name(function (e) {
        return this.optionLabel
          ? resolveFieldData(e, this.optionLabel)
          : 'string' == typeof e
            ? e
            : null
      }, 'getOptionLabel'),
      getOptionValue: __name(function (e) {
        return this.optionValue ? resolveFieldData(e, this.optionValue) : e
      }, 'getOptionValue'),
      getOptionRenderKey: __name(function (e, t) {
        return (
          (this.dataKey
            ? resolveFieldData(e, this.dataKey)
            : this.getOptionLabel(e)) +
          '_' +
          t
        )
      }, 'getOptionRenderKey'),
      getPTOptions: __name(function (e, t, n, o) {
        return this.ptm(o, {
          context: {
            selected: this.isSelected(e),
            focused: this.focusedOptionIndex === this.getOptionIndex(n, t),
            disabled: this.isOptionDisabled(e)
          }
        })
      }, 'getPTOptions'),
      isOptionDisabled: __name(function (e) {
        return !!this.optionDisabled && resolveFieldData(e, this.optionDisabled)
      }, 'isOptionDisabled'),
      isOptionGroup: __name(function (e) {
        return this.optionGroupLabel && e.optionGroup && e.group
      }, 'isOptionGroup'),
      getOptionGroupLabel: __name(function (e) {
        return resolveFieldData(e, this.optionGroupLabel)
      }, 'getOptionGroupLabel'),
      getOptionGroupChildren: __name(function (e) {
        return resolveFieldData(e, this.optionGroupChildren)
      }, 'getOptionGroupChildren'),
      getAriaPosInset: __name(function (e) {
        var t = this
        return (
          (this.optionGroupLabel
            ? e -
              this.visibleOptions.slice(0, e).filter(function (e) {
                return t.isOptionGroup(e)
              }).length
            : e) + 1
        )
      }, 'getAriaPosInset'),
      onFirstHiddenFocus: __name(function () {
        focus(this.list)
        var e = getFirstFocusableElement(
          this.$el,
          ':not([data-p-hidden-focusable="true"])'
        )
        ;(this.$refs.lastHiddenFocusableElement.tabIndex = isElement(e)
          ? void 0
          : -1),
          (this.$refs.firstHiddenFocusableElement.tabIndex = -1)
      }, 'onFirstHiddenFocus'),
      onLastHiddenFocus: __name(function (e) {
        e.relatedTarget === this.list
          ? (focus(
              getFirstFocusableElement(
                this.$el,
                ':not([data-p-hidden-focusable="true"])'
              )
            ),
            (this.$refs.firstHiddenFocusableElement.tabIndex = void 0))
          : focus(this.$refs.firstHiddenFocusableElement)
        this.$refs.lastHiddenFocusableElement.tabIndex = -1
      }, 'onLastHiddenFocus'),
      onFocusout: __name(function (e) {
        !this.$el.contains(e.relatedTarget) &&
          this.$refs.lastHiddenFocusableElement &&
          this.$refs.firstHiddenFocusableElement &&
          (this.$refs.lastHiddenFocusableElement.tabIndex =
            this.$refs.firstHiddenFocusableElement.tabIndex =
              void 0)
      }, 'onFocusout'),
      onListFocus: __name(function (e) {
        ;(this.focused = !0),
          (this.focusedOptionIndex =
            -1 !== this.focusedOptionIndex
              ? this.focusedOptionIndex
              : this.autoOptionFocus
                ? this.findFirstFocusedOptionIndex()
                : this.findSelectedOptionIndex()),
          this.autoUpdateModel(),
          this.$emit('focus', e)
      }, 'onListFocus'),
      onListBlur: __name(function (e) {
        ;(this.focused = !1),
          (this.focusedOptionIndex = this.startRangeIndex = -1),
          (this.searchValue = ''),
          this.$emit('blur', e)
      }, 'onListBlur'),
      onListKeyDown: __name(function (e) {
        var t = this,
          n = e.metaKey || e.ctrlKey
        switch (e.code) {
          case 'ArrowDown':
            this.onArrowDownKey(e)
            break
          case 'ArrowUp':
            this.onArrowUpKey(e)
            break
          case 'Home':
            this.onHomeKey(e)
            break
          case 'End':
            this.onEndKey(e)
            break
          case 'PageDown':
            this.onPageDownKey(e)
            break
          case 'PageUp':
            this.onPageUpKey(e)
            break
          case 'Enter':
          case 'NumpadEnter':
          case 'Space':
            this.onSpaceKey(e)
            break
          case 'Tab':
            break
          case 'ShiftLeft':
          case 'ShiftRight':
            this.onShiftKey(e)
            break
          default:
            if (this.multiple && 'KeyA' === e.code && n) {
              var o = this.visibleOptions
                .filter(function (e) {
                  return t.isValidOption(e)
                })
                .map(function (e) {
                  return t.getOptionValue(e)
                })
              this.updateModel(e, o), e.preventDefault()
              break
            }
            !n &&
              isPrintableCharacter(e.key) &&
              (this.searchOptions(e, e.key), e.preventDefault())
        }
      }, 'onListKeyDown'),
      onOptionSelect: __name(function (e, t) {
        var n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1
        this.disabled ||
          this.isOptionDisabled(t) ||
          (this.multiple
            ? this.onOptionSelectMultiple(e, t)
            : this.onOptionSelectSingle(e, t),
          (this.optionTouched = !1),
          -1 !== n && (this.focusedOptionIndex = n))
      }, 'onOptionSelect'),
      onOptionMouseDown: __name(function (e, t) {
        this.changeFocusedOptionIndex(e, t)
      }, 'onOptionMouseDown'),
      onOptionMouseMove: __name(function (e, t) {
        this.focusOnHover && this.focused && this.changeFocusedOptionIndex(e, t)
      }, 'onOptionMouseMove'),
      onOptionTouchEnd: __name(function () {
        this.disabled || (this.optionTouched = !0)
      }, 'onOptionTouchEnd'),
      onOptionDblClick: __name(function (e, t) {
        this.$emit('item-dblclick', { originalEvent: e, value: t }),
          this.$emit('option-dblclick', { originalEvent: e, value: t })
      }, 'onOptionDblClick'),
      onOptionSelectSingle: __name(function (e, t) {
        var n = this.isSelected(t),
          o = !1,
          i = null
        if (!this.optionTouched && this.metaKeySelection) {
          var r = e && (e.metaKey || e.ctrlKey)
          n
            ? r && ((i = null), (o = !0))
            : ((i = this.getOptionValue(t)), (o = !0))
        } else (i = n ? null : this.getOptionValue(t)), (o = !0)
        o && this.updateModel(e, i)
      }, 'onOptionSelectSingle'),
      onOptionSelectMultiple: __name(function (e, t) {
        var n = this.isSelected(t),
          o = null
        if (!this.optionTouched && this.metaKeySelection) {
          var i = e.metaKey || e.ctrlKey
          n
            ? (o = i ? this.removeOption(t) : [this.getOptionValue(t)])
            : ((o = (i && this.d_value) || []),
              (o = [].concat(_toConsumableArray$9(o), [
                this.getOptionValue(t)
              ])))
        } else
          o = n
            ? this.removeOption(t)
            : [].concat(_toConsumableArray$9(this.d_value || []), [
                this.getOptionValue(t)
              ])
        this.updateModel(e, o)
      }, 'onOptionSelectMultiple'),
      onOptionSelectRange: __name(function (e) {
        var t = this,
          n =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1,
          o =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1
        if (
          (-1 === n && (n = this.findNearestSelectedOptionIndex(o, !0)),
          -1 === o && (o = this.findNearestSelectedOptionIndex(n)),
          -1 !== n && -1 !== o)
        ) {
          var i = Math.min(n, o),
            r = Math.max(n, o),
            a = this.visibleOptions
              .slice(i, r + 1)
              .filter(function (e) {
                return t.isValidOption(e)
              })
              .map(function (e) {
                return t.getOptionValue(e)
              })
          this.updateModel(e, a)
        }
      }, 'onOptionSelectRange'),
      onFilterChange: __name(function (e) {
        this.$emit('filter', {
          originalEvent: e,
          value: e.target.value,
          filterValue: this.visibleOptions
        }),
          (this.focusedOptionIndex = this.startRangeIndex = -1)
      }, 'onFilterChange'),
      onFilterBlur: __name(function () {
        this.focusedOptionIndex = this.startRangeIndex = -1
      }, 'onFilterBlur'),
      onFilterKeyDown: __name(function (e) {
        switch (e.code) {
          case 'ArrowDown':
            this.onArrowDownKey(e)
            break
          case 'ArrowUp':
            this.onArrowUpKey(e)
            break
          case 'ArrowLeft':
          case 'ArrowRight':
            this.onArrowLeftKey(e, !0)
            break
          case 'Home':
            this.onHomeKey(e, !0)
            break
          case 'End':
            this.onEndKey(e, !0)
            break
          case 'Enter':
          case 'NumpadEnter':
            this.onEnterKey(e)
            break
          case 'ShiftLeft':
          case 'ShiftRight':
            this.onShiftKey(e)
        }
      }, 'onFilterKeyDown'),
      onArrowDownKey: __name(function (e) {
        var t =
          -1 !== this.focusedOptionIndex
            ? this.findNextOptionIndex(this.focusedOptionIndex)
            : this.findFirstFocusedOptionIndex()
        this.multiple &&
          e.shiftKey &&
          this.onOptionSelectRange(e, this.startRangeIndex, t),
          this.changeFocusedOptionIndex(e, t),
          e.preventDefault()
      }, 'onArrowDownKey'),
      onArrowUpKey: __name(function (e) {
        var t =
          -1 !== this.focusedOptionIndex
            ? this.findPrevOptionIndex(this.focusedOptionIndex)
            : this.findLastFocusedOptionIndex()
        this.multiple &&
          e.shiftKey &&
          this.onOptionSelectRange(e, t, this.startRangeIndex),
          this.changeFocusedOptionIndex(e, t),
          e.preventDefault()
      }, 'onArrowUpKey'),
      onArrowLeftKey: __name(function (e) {
        arguments.length > 1 &&
          void 0 !== arguments[1] &&
          arguments[1] &&
          (this.focusedOptionIndex = -1)
      }, 'onArrowLeftKey'),
      onHomeKey: __name(function (e) {
        if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) {
          var t = e.currentTarget
          e.shiftKey
            ? t.setSelectionRange(0, e.target.selectionStart)
            : (t.setSelectionRange(0, 0), (this.focusedOptionIndex = -1))
        } else {
          var n = e.metaKey || e.ctrlKey,
            o = this.findFirstOptionIndex()
          this.multiple &&
            e.shiftKey &&
            n &&
            this.onOptionSelectRange(e, o, this.startRangeIndex),
            this.changeFocusedOptionIndex(e, o)
        }
        e.preventDefault()
      }, 'onHomeKey'),
      onEndKey: __name(function (e) {
        if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) {
          var t = e.currentTarget
          if (e.shiftKey)
            t.setSelectionRange(e.target.selectionStart, t.value.length)
          else {
            var n = t.value.length
            t.setSelectionRange(n, n), (this.focusedOptionIndex = -1)
          }
        } else {
          var o = e.metaKey || e.ctrlKey,
            i = this.findLastOptionIndex()
          this.multiple &&
            e.shiftKey &&
            o &&
            this.onOptionSelectRange(e, this.startRangeIndex, i),
            this.changeFocusedOptionIndex(e, i)
        }
        e.preventDefault()
      }, 'onEndKey'),
      onPageUpKey: __name(function (e) {
        this.scrollInView(0), e.preventDefault()
      }, 'onPageUpKey'),
      onPageDownKey: __name(function (e) {
        this.scrollInView(this.visibleOptions.length - 1), e.preventDefault()
      }, 'onPageDownKey'),
      onEnterKey: __name(function (e) {
        ;-1 !== this.focusedOptionIndex &&
          (this.multiple && e.shiftKey
            ? this.onOptionSelectRange(e, this.focusedOptionIndex)
            : this.onOptionSelect(
                e,
                this.visibleOptions[this.focusedOptionIndex]
              ))
      }, 'onEnterKey'),
      onSpaceKey: __name(function (e) {
        e.preventDefault(), this.onEnterKey(e)
      }, 'onSpaceKey'),
      onShiftKey: __name(function () {
        this.startRangeIndex = this.focusedOptionIndex
      }, 'onShiftKey'),
      isOptionMatched: __name(function (e) {
        var t
        return (
          this.isValidOption(e) &&
          'string' == typeof this.getOptionLabel(e) &&
          (null === (t = this.getOptionLabel(e)) || void 0 === t
            ? void 0
            : t
                .toLocaleLowerCase(this.filterLocale)
                .startsWith(
                  this.searchValue.toLocaleLowerCase(this.filterLocale)
                ))
        )
      }, 'isOptionMatched'),
      isValidOption: __name(function (e) {
        return (
          isNotEmpty(e) && !(this.isOptionDisabled(e) || this.isOptionGroup(e))
        )
      }, 'isValidOption'),
      isValidSelectedOption: __name(function (e) {
        return this.isValidOption(e) && this.isSelected(e)
      }, 'isValidSelectedOption'),
      isEquals: __name(function (e, t) {
        return equals(e, t, this.equalityKey)
      }, 'isEquals'),
      isSelected: __name(function (e) {
        var t = this,
          n = this.getOptionValue(e)
        return this.multiple
          ? (this.d_value || []).some(function (e) {
              return t.isEquals(e, n)
            })
          : this.isEquals(this.d_value, n)
      }, 'isSelected'),
      findFirstOptionIndex: __name(function () {
        var e = this
        return this.visibleOptions.findIndex(function (t) {
          return e.isValidOption(t)
        })
      }, 'findFirstOptionIndex'),
      findLastOptionIndex: __name(function () {
        var e = this
        return findLastIndex(this.visibleOptions, function (t) {
          return e.isValidOption(t)
        })
      }, 'findLastOptionIndex'),
      findNextOptionIndex: __name(function (e) {
        var t = this,
          n =
            e < this.visibleOptions.length - 1
              ? this.visibleOptions.slice(e + 1).findIndex(function (e) {
                  return t.isValidOption(e)
                })
              : -1
        return n > -1 ? n + e + 1 : e
      }, 'findNextOptionIndex'),
      findPrevOptionIndex: __name(function (e) {
        var t = this,
          n =
            e > 0
              ? findLastIndex(this.visibleOptions.slice(0, e), function (e) {
                  return t.isValidOption(e)
                })
              : -1
        return n > -1 ? n : e
      }, 'findPrevOptionIndex'),
      findSelectedOptionIndex: __name(function () {
        var e = this
        if (this.$filled) {
          if (!this.multiple)
            return this.visibleOptions.findIndex(function (t) {
              return e.isValidSelectedOption(t)
            })
          for (
            var t,
              n = __name(function () {
                var t = e.d_value[o],
                  n = e.visibleOptions.findIndex(function (n) {
                    return (
                      e.isValidSelectedOption(n) &&
                      e.isEquals(t, e.getOptionValue(n))
                    )
                  })
                if (n > -1) return { v: n }
              }, '_loop'),
              o = this.d_value.length - 1;
            o >= 0;
            o--
          )
            if ((t = n())) return t.v
        }
        return -1
      }, 'findSelectedOptionIndex'),
      findFirstSelectedOptionIndex: __name(function () {
        var e = this
        return this.$filled
          ? this.visibleOptions.findIndex(function (t) {
              return e.isValidSelectedOption(t)
            })
          : -1
      }, 'findFirstSelectedOptionIndex'),
      findLastSelectedOptionIndex: __name(function () {
        var e = this
        return this.$filled
          ? findLastIndex(this.visibleOptions, function (t) {
              return e.isValidSelectedOption(t)
            })
          : -1
      }, 'findLastSelectedOptionIndex'),
      findNextSelectedOptionIndex: __name(function (e) {
        var t = this,
          n =
            this.$filled && e < this.visibleOptions.length - 1
              ? this.visibleOptions.slice(e + 1).findIndex(function (e) {
                  return t.isValidSelectedOption(e)
                })
              : -1
        return n > -1 ? n + e + 1 : -1
      }, 'findNextSelectedOptionIndex'),
      findPrevSelectedOptionIndex: __name(function (e) {
        var t = this,
          n =
            this.$filled && e > 0
              ? findLastIndex(this.visibleOptions.slice(0, e), function (e) {
                  return t.isValidSelectedOption(e)
                })
              : -1
        return n > -1 ? n : -1
      }, 'findPrevSelectedOptionIndex'),
      findNearestSelectedOptionIndex: __name(function (e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
          n = -1
        return (
          this.$filled &&
            (n = t
              ? -1 === (n = this.findPrevSelectedOptionIndex(e))
                ? this.findNextSelectedOptionIndex(e)
                : n
              : -1 === (n = this.findNextSelectedOptionIndex(e))
                ? this.findPrevSelectedOptionIndex(e)
                : n),
          n > -1 ? n : e
        )
      }, 'findNearestSelectedOptionIndex'),
      findFirstFocusedOptionIndex: __name(function () {
        var e = this.findFirstSelectedOptionIndex()
        return e < 0 ? this.findFirstOptionIndex() : e
      }, 'findFirstFocusedOptionIndex'),
      findLastFocusedOptionIndex: __name(function () {
        var e = this.findLastSelectedOptionIndex()
        return e < 0 ? this.findLastOptionIndex() : e
      }, 'findLastFocusedOptionIndex'),
      searchOptions: __name(function (e, t) {
        var n = this
        this.searchValue = (this.searchValue || '') + t
        var o = -1
        isNotEmpty(this.searchValue) &&
          (-1 ===
            (o =
              -1 !== this.focusedOptionIndex
                ? -1 ===
                  (o = this.visibleOptions
                    .slice(this.focusedOptionIndex)
                    .findIndex(function (e) {
                      return n.isOptionMatched(e)
                    }))
                  ? this.visibleOptions
                      .slice(0, this.focusedOptionIndex)
                      .findIndex(function (e) {
                        return n.isOptionMatched(e)
                      })
                  : o + this.focusedOptionIndex
                : this.visibleOptions.findIndex(function (e) {
                    return n.isOptionMatched(e)
                  })) &&
            -1 === this.focusedOptionIndex &&
            (o = this.findFirstFocusedOptionIndex()),
          -1 !== o && this.changeFocusedOptionIndex(e, o)),
          this.searchTimeout && clearTimeout(this.searchTimeout),
          (this.searchTimeout = setTimeout(function () {
            ;(n.searchValue = ''), (n.searchTimeout = null)
          }, 500))
      }, 'searchOptions'),
      removeOption: __name(function (e) {
        var t = this
        return this.d_value.filter(function (n) {
          return !equals(n, t.getOptionValue(e), t.equalityKey)
        })
      }, 'removeOption'),
      changeFocusedOptionIndex: __name(function (e, t) {
        this.focusedOptionIndex !== t &&
          ((this.focusedOptionIndex = t),
          this.scrollInView(),
          this.selectOnFocus &&
            !this.multiple &&
            this.onOptionSelect(e, this.visibleOptions[t]))
      }, 'changeFocusedOptionIndex'),
      scrollInView: __name(function () {
        var e = this,
          t =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1
        this.$nextTick(function () {
          var n = -1 !== t ? ''.concat(e.id, '_').concat(t) : e.focusedOptionId,
            o = findSingle(e.list, 'li[id="'.concat(n, '"]'))
          o
            ? o.scrollIntoView &&
              o.scrollIntoView({
                block: 'nearest',
                inline: 'nearest',
                behavior: 'smooth'
              })
            : e.virtualScrollerDisabled ||
              (e.virtualScroller &&
                e.virtualScroller.scrollToIndex(
                  -1 !== t ? t : e.focusedOptionIndex
                ))
        })
      }, 'scrollInView'),
      autoUpdateModel: __name(function () {
        this.selectOnFocus &&
          this.autoOptionFocus &&
          !this.$filled &&
          !this.multiple &&
          this.focused &&
          ((this.focusedOptionIndex = this.findFirstFocusedOptionIndex()),
          this.onOptionSelect(
            null,
            this.visibleOptions[this.focusedOptionIndex]
          ))
      }, 'autoUpdateModel'),
      updateModel: __name(function (e, t) {
        this.writeValue(t, e),
          this.$emit('change', { originalEvent: e, value: t })
      }, 'updateModel'),
      listRef: __name(function (e, t) {
        ;(this.list = e), t && t(e)
      }, 'listRef'),
      virtualScrollerRef: __name(function (e) {
        this.virtualScroller = e
      }, 'virtualScrollerRef')
    },
    computed: {
      optionsListFlat: __name(function () {
        return this.filterValue
          ? FilterService.filter(
              this.options,
              this.searchFields,
              this.filterValue,
              this.filterMatchMode,
              this.filterLocale
            )
          : this.options
      }, 'optionsListFlat'),
      optionsListGroup: __name(function () {
        var e = this,
          t = []
        return (
          (this.options || []).forEach(function (n) {
            var o = e.getOptionGroupChildren(n) || [],
              i = e.filterValue
                ? FilterService.filter(
                    o,
                    e.searchFields,
                    e.filterValue,
                    e.filterMatchMode,
                    e.filterLocale
                  )
                : o
            null != i &&
              i.length &&
              t.push.apply(
                t,
                [{ optionGroup: n, group: !0 }].concat(_toConsumableArray$9(i))
              )
          }),
          t
        )
      }, 'optionsListGroup'),
      visibleOptions: __name(function () {
        return this.optionGroupLabel
          ? this.optionsListGroup
          : this.optionsListFlat
      }, 'visibleOptions'),
      hasSelectedOption: __name(function () {
        return isNotEmpty(this.d_value)
      }, 'hasSelectedOption'),
      equalityKey: __name(function () {
        return this.optionValue ? null : this.dataKey
      }, 'equalityKey'),
      searchFields: __name(function () {
        return this.filterFields || [this.optionLabel]
      }, 'searchFields'),
      filterResultMessageText: __name(function () {
        return isNotEmpty(this.visibleOptions)
          ? this.filterMessageText.replaceAll('{0}', this.visibleOptions.length)
          : this.emptyFilterMessageText
      }, 'filterResultMessageText'),
      filterMessageText: __name(function () {
        return (
          this.filterMessage || this.$primevue.config.locale.searchMessage || ''
        )
      }, 'filterMessageText'),
      emptyFilterMessageText: __name(function () {
        return (
          this.emptyFilterMessage ||
          this.$primevue.config.locale.emptySearchMessage ||
          this.$primevue.config.locale.emptyFilterMessage ||
          ''
        )
      }, 'emptyFilterMessageText'),
      emptyMessageText: __name(function () {
        return (
          this.emptyMessage || this.$primevue.config.locale.emptyMessage || ''
        )
      }, 'emptyMessageText'),
      selectionMessageText: __name(function () {
        return (
          this.selectionMessage ||
          this.$primevue.config.locale.selectionMessage ||
          ''
        )
      }, 'selectionMessageText'),
      emptySelectionMessageText: __name(function () {
        return (
          this.emptySelectionMessage ||
          this.$primevue.config.locale.emptySelectionMessage ||
          ''
        )
      }, 'emptySelectionMessageText'),
      selectedMessageText: __name(function () {
        return this.$filled
          ? this.selectionMessageText.replaceAll(
              '{0}',
              this.multiple ? this.d_value.length : '1'
            )
          : this.emptySelectionMessageText
      }, 'selectedMessageText'),
      focusedOptionId: __name(function () {
        return -1 !== this.focusedOptionIndex
          ? ''.concat(this.id, '_').concat(this.focusedOptionIndex)
          : null
      }, 'focusedOptionId'),
      ariaSetSize: __name(function () {
        var e = this
        return this.visibleOptions.filter(function (t) {
          return !e.isOptionGroup(t)
        }).length
      }, 'ariaSetSize'),
      virtualScrollerDisabled: __name(function () {
        return !this.virtualScrollerOptions
      }, 'virtualScrollerDisabled')
    },
    directives: { ripple: Ripple },
    components: {
      InputText: script$P,
      VirtualScroller: script$N,
      InputIcon: script$S,
      IconField: script$T,
      SearchIcon: script$U,
      CheckIcon: script$V,
      BlankIcon: script$W
    }
  },
  _hoisted_1$$ = ['id'],
  _hoisted_2$D = ['tabindex'],
  _hoisted_3$p = [
    'id',
    'aria-multiselectable',
    'aria-label',
    'aria-labelledby',
    'aria-activedescendant',
    'aria-disabled'
  ],
  _hoisted_4$e = ['id'],
  _hoisted_5$b = [
    'id',
    'aria-label',
    'aria-selected',
    'aria-disabled',
    'aria-setsize',
    'aria-posinset',
    'onClick',
    'onMousedown',
    'onMousemove',
    'onDblclick',
    'data-p-selected',
    'data-p-focused',
    'data-p-disabled'
  ],
  _hoisted_6$8 = ['tabindex']
function render$L(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('InputText'),
    s = Vue.resolveComponent('SearchIcon'),
    l = Vue.resolveComponent('InputIcon'),
    c = Vue.resolveComponent('IconField'),
    d = Vue.resolveComponent('CheckIcon'),
    u = Vue.resolveComponent('BlankIcon'),
    p = Vue.resolveComponent('VirtualScroller'),
    h = Vue.resolveDirective('ripple')
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps(
        {
          id: i.id,
          class: e.cx('root'),
          onFocusout:
            t[7] ||
            (t[7] = function () {
              return r.onFocusout && r.onFocusout.apply(r, arguments)
            })
        },
        e.ptmi('root')
      ),
      [
        Vue.createElementVNode(
          'span',
          Vue.mergeProps(
            {
              ref: 'firstHiddenFocusableElement',
              role: 'presentation',
              'aria-hidden': 'true',
              class: 'p-hidden-accessible p-hidden-focusable',
              tabindex: e.disabled ? -1 : e.tabindex,
              onFocus:
                t[0] ||
                (t[0] = function () {
                  return (
                    r.onFirstHiddenFocus &&
                    r.onFirstHiddenFocus.apply(r, arguments)
                  )
                })
            },
            e.ptm('hiddenFirstFocusableEl'),
            { 'data-p-hidden-accessible': !0, 'data-p-hidden-focusable': !0 }
          ),
          null,
          16,
          _hoisted_2$D
        ),
        e.$slots.header
          ? (Vue.openBlock(),
            Vue.createElementBlock(
              'div',
              { key: 0, class: Vue.normalizeClass(e.cx('header')) },
              [
                Vue.renderSlot(e.$slots, 'header', {
                  value: e.d_value,
                  options: r.visibleOptions
                })
              ],
              2
            ))
          : Vue.createCommentVNode('', !0),
        e.filter
          ? (Vue.openBlock(),
            Vue.createElementBlock(
              'div',
              Vue.mergeProps(
                { key: 1, class: e.cx('header') },
                e.ptm('header')
              ),
              [
                Vue.createVNode(
                  c,
                  { unstyled: e.unstyled, pt: e.ptm('pcFilterContainer') },
                  {
                    default: Vue.withCtx(function () {
                      return [
                        Vue.createVNode(
                          a,
                          {
                            modelValue: i.filterValue,
                            'onUpdate:modelValue':
                              t[1] ||
                              (t[1] = function (e) {
                                return (i.filterValue = e)
                              }),
                            type: 'text',
                            class: Vue.normalizeClass(e.cx('pcFilter')),
                            placeholder: e.filterPlaceholder,
                            role: 'searchbox',
                            autocomplete: 'off',
                            disabled: e.disabled,
                            unstyled: e.unstyled,
                            'aria-owns': i.id + '_list',
                            'aria-activedescendant': r.focusedOptionId,
                            tabindex: e.disabled || i.focused ? -1 : e.tabindex,
                            onInput: r.onFilterChange,
                            onBlur: r.onFilterBlur,
                            onKeydown: r.onFilterKeyDown,
                            pt: e.ptm('pcFilter')
                          },
                          null,
                          8,
                          [
                            'modelValue',
                            'class',
                            'placeholder',
                            'disabled',
                            'unstyled',
                            'aria-owns',
                            'aria-activedescendant',
                            'tabindex',
                            'onInput',
                            'onBlur',
                            'onKeydown',
                            'pt'
                          ]
                        ),
                        Vue.createVNode(
                          l,
                          {
                            unstyled: e.unstyled,
                            pt: e.ptm('pcFilterIconContainer')
                          },
                          {
                            default: Vue.withCtx(function () {
                              return [
                                Vue.renderSlot(
                                  e.$slots,
                                  'filtericon',
                                  {},
                                  function () {
                                    return [
                                      e.filterIcon
                                        ? (Vue.openBlock(),
                                          Vue.createElementBlock(
                                            'span',
                                            Vue.mergeProps(
                                              { key: 0, class: e.filterIcon },
                                              e.ptm('filterIcon')
                                            ),
                                            null,
                                            16
                                          ))
                                        : (Vue.openBlock(),
                                          Vue.createBlock(
                                            s,
                                            Vue.normalizeProps(
                                              Vue.mergeProps(
                                                { key: 1 },
                                                e.ptm('filterIcon')
                                              )
                                            ),
                                            null,
                                            16
                                          ))
                                    ]
                                  }
                                )
                              ]
                            }),
                            _: 3
                          },
                          8,
                          ['unstyled', 'pt']
                        )
                      ]
                    }),
                    _: 3
                  },
                  8,
                  ['unstyled', 'pt']
                ),
                Vue.createElementVNode(
                  'span',
                  Vue.mergeProps(
                    {
                      role: 'status',
                      'aria-live': 'polite',
                      class: 'p-hidden-accessible'
                    },
                    e.ptm('hiddenFilterResult'),
                    { 'data-p-hidden-accessible': !0 }
                  ),
                  Vue.toDisplayString(r.filterResultMessageText),
                  17
                )
              ],
              16
            ))
          : Vue.createCommentVNode('', !0),
        Vue.createElementVNode(
          'div',
          Vue.mergeProps(
            {
              class: e.cx('listContainer'),
              style: [
                {
                  'max-height': r.virtualScrollerDisabled ? e.scrollHeight : ''
                },
                e.listStyle
              ]
            },
            e.ptm('listContainer')
          ),
          [
            Vue.createVNode(
              p,
              Vue.mergeProps(
                { ref: r.virtualScrollerRef },
                e.virtualScrollerOptions,
                {
                  items: r.visibleOptions,
                  style: [{ height: e.scrollHeight }, e.listStyle],
                  tabindex: -1,
                  disabled: r.virtualScrollerDisabled,
                  pt: e.ptm('virtualScroller')
                }
              ),
              Vue.createSlots(
                {
                  content: Vue.withCtx(function (n) {
                    var o = n.styleClass,
                      a = n.contentRef,
                      s = n.items,
                      l = n.getItemOptions,
                      c = n.contentStyle,
                      p = n.itemSize
                    return [
                      Vue.createElementVNode(
                        'ul',
                        Vue.mergeProps(
                          {
                            ref: __name(function (e) {
                              return r.listRef(e, a)
                            }, 'ref'),
                            id: i.id + '_list',
                            class: [e.cx('list'), o],
                            style: c,
                            tabindex: -1,
                            role: 'listbox',
                            'aria-multiselectable': e.multiple,
                            'aria-label': e.ariaLabel,
                            'aria-labelledby': e.ariaLabelledby,
                            'aria-activedescendant': i.focused
                              ? r.focusedOptionId
                              : void 0,
                            'aria-disabled': e.disabled,
                            onFocus:
                              t[3] ||
                              (t[3] = function () {
                                return (
                                  r.onListFocus &&
                                  r.onListFocus.apply(r, arguments)
                                )
                              }),
                            onBlur:
                              t[4] ||
                              (t[4] = function () {
                                return (
                                  r.onListBlur &&
                                  r.onListBlur.apply(r, arguments)
                                )
                              }),
                            onKeydown:
                              t[5] ||
                              (t[5] = function () {
                                return (
                                  r.onListKeyDown &&
                                  r.onListKeyDown.apply(r, arguments)
                                )
                              })
                          },
                          e.ptm('list')
                        ),
                        [
                          (Vue.openBlock(!0),
                          Vue.createElementBlock(
                            Vue.Fragment,
                            null,
                            Vue.renderList(s, function (n, o) {
                              return (
                                Vue.openBlock(),
                                Vue.createElementBlock(
                                  Vue.Fragment,
                                  {
                                    key: r.getOptionRenderKey(
                                      n,
                                      r.getOptionIndex(o, l)
                                    )
                                  },
                                  [
                                    r.isOptionGroup(n)
                                      ? (Vue.openBlock(),
                                        Vue.createElementBlock(
                                          'li',
                                          Vue.mergeProps(
                                            {
                                              key: 0,
                                              id:
                                                i.id +
                                                '_' +
                                                r.getOptionIndex(o, l),
                                              style: {
                                                height: p ? p + 'px' : void 0
                                              },
                                              class: e.cx('optionGroup'),
                                              role: 'option',
                                              ref_for: !0
                                            },
                                            e.ptm('optionGroup')
                                          ),
                                          [
                                            Vue.renderSlot(
                                              e.$slots,
                                              'optiongroup',
                                              {
                                                option: n.optionGroup,
                                                index: r.getOptionIndex(o, l)
                                              },
                                              function () {
                                                return [
                                                  Vue.createTextVNode(
                                                    Vue.toDisplayString(
                                                      r.getOptionGroupLabel(
                                                        n.optionGroup
                                                      )
                                                    ),
                                                    1
                                                  )
                                                ]
                                              }
                                            )
                                          ],
                                          16,
                                          _hoisted_4$e
                                        ))
                                      : Vue.withDirectives(
                                          (Vue.openBlock(),
                                          Vue.createElementBlock(
                                            'li',
                                            Vue.mergeProps(
                                              {
                                                key: 1,
                                                id:
                                                  i.id +
                                                  '_' +
                                                  r.getOptionIndex(o, l),
                                                style: {
                                                  height: p ? p + 'px' : void 0
                                                },
                                                class: e.cx('option', {
                                                  option: n,
                                                  index: o,
                                                  getItemOptions: l
                                                }),
                                                role: 'option',
                                                'aria-label':
                                                  r.getOptionLabel(n),
                                                'aria-selected':
                                                  r.isSelected(n),
                                                'aria-disabled':
                                                  r.isOptionDisabled(n),
                                                'aria-setsize': r.ariaSetSize,
                                                'aria-posinset':
                                                  r.getAriaPosInset(
                                                    r.getOptionIndex(o, l)
                                                  ),
                                                onClick: __name(function (e) {
                                                  return r.onOptionSelect(
                                                    e,
                                                    n,
                                                    r.getOptionIndex(o, l)
                                                  )
                                                }, 'onClick'),
                                                onMousedown: __name(function (
                                                  e
                                                ) {
                                                  return r.onOptionMouseDown(
                                                    e,
                                                    r.getOptionIndex(o, l)
                                                  )
                                                }, 'onMousedown'),
                                                onMousemove: __name(function (
                                                  e
                                                ) {
                                                  return r.onOptionMouseMove(
                                                    e,
                                                    r.getOptionIndex(o, l)
                                                  )
                                                }, 'onMousemove'),
                                                onTouchend:
                                                  t[2] ||
                                                  (t[2] = function (e) {
                                                    return r.onOptionTouchEnd()
                                                  }),
                                                onDblclick: __name(function (
                                                  e
                                                ) {
                                                  return r.onOptionDblClick(
                                                    e,
                                                    n
                                                  )
                                                }, 'onDblclick'),
                                                ref_for: !0
                                              },
                                              r.getPTOptions(n, l, o, 'option'),
                                              {
                                                'data-p-selected':
                                                  r.isSelected(n),
                                                'data-p-focused':
                                                  i.focusedOptionIndex ===
                                                  r.getOptionIndex(o, l),
                                                'data-p-disabled':
                                                  r.isOptionDisabled(n)
                                              }
                                            ),
                                            [
                                              e.checkmark
                                                ? (Vue.openBlock(),
                                                  Vue.createElementBlock(
                                                    Vue.Fragment,
                                                    { key: 0 },
                                                    [
                                                      r.isSelected(n)
                                                        ? (Vue.openBlock(),
                                                          Vue.createBlock(
                                                            d,
                                                            Vue.mergeProps(
                                                              {
                                                                key: 0,
                                                                class:
                                                                  e.cx(
                                                                    'optionCheckIcon'
                                                                  ),
                                                                ref_for: !0
                                                              },
                                                              e.ptm(
                                                                'optionCheckIcon'
                                                              )
                                                            ),
                                                            null,
                                                            16,
                                                            ['class']
                                                          ))
                                                        : (Vue.openBlock(),
                                                          Vue.createBlock(
                                                            u,
                                                            Vue.mergeProps(
                                                              {
                                                                key: 1,
                                                                class:
                                                                  e.cx(
                                                                    'optionBlankIcon'
                                                                  ),
                                                                ref_for: !0
                                                              },
                                                              e.ptm(
                                                                'optionBlankIcon'
                                                              )
                                                            ),
                                                            null,
                                                            16,
                                                            ['class']
                                                          ))
                                                    ],
                                                    64
                                                  ))
                                                : Vue.createCommentVNode(
                                                    '',
                                                    !0
                                                  ),
                                              Vue.renderSlot(
                                                e.$slots,
                                                'option',
                                                {
                                                  option: n,
                                                  selected: r.isSelected(n),
                                                  index: r.getOptionIndex(o, l)
                                                },
                                                function () {
                                                  return [
                                                    Vue.createTextVNode(
                                                      Vue.toDisplayString(
                                                        r.getOptionLabel(n)
                                                      ),
                                                      1
                                                    )
                                                  ]
                                                }
                                              )
                                            ],
                                            16,
                                            _hoisted_5$b
                                          )),
                                          [[h]]
                                        )
                                  ],
                                  64
                                )
                              )
                            }),
                            128
                          )),
                          i.filterValue && (!s || (s && 0 === s.length))
                            ? (Vue.openBlock(),
                              Vue.createElementBlock(
                                'li',
                                Vue.mergeProps(
                                  {
                                    key: 0,
                                    class: e.cx('emptyMessage'),
                                    role: 'option'
                                  },
                                  e.ptm('emptyMessage')
                                ),
                                [
                                  Vue.renderSlot(
                                    e.$slots,
                                    'emptyfilter',
                                    {},
                                    function () {
                                      return [
                                        Vue.createTextVNode(
                                          Vue.toDisplayString(
                                            r.emptyFilterMessageText
                                          ),
                                          1
                                        )
                                      ]
                                    }
                                  )
                                ],
                                16
                              ))
                            : !e.options ||
                                (e.options && 0 === e.options.length)
                              ? (Vue.openBlock(),
                                Vue.createElementBlock(
                                  'li',
                                  Vue.mergeProps(
                                    {
                                      key: 1,
                                      class: e.cx('emptyMessage'),
                                      role: 'option'
                                    },
                                    e.ptm('emptyMessage')
                                  ),
                                  [
                                    Vue.renderSlot(
                                      e.$slots,
                                      'empty',
                                      {},
                                      function () {
                                        return [
                                          Vue.createTextVNode(
                                            Vue.toDisplayString(
                                              r.emptyMessageText
                                            ),
                                            1
                                          )
                                        ]
                                      }
                                    )
                                  ],
                                  16
                                ))
                              : Vue.createCommentVNode('', !0)
                        ],
                        16,
                        _hoisted_3$p
                      )
                    ]
                  }),
                  _: 2
                },
                [
                  e.$slots.loader
                    ? {
                        name: 'loader',
                        fn: Vue.withCtx(function (t) {
                          var n = t.options
                          return [
                            Vue.renderSlot(e.$slots, 'loader', { options: n })
                          ]
                        }),
                        key: '0'
                      }
                    : void 0
                ]
              ),
              1040,
              ['items', 'style', 'disabled', 'pt']
            )
          ],
          16
        ),
        Vue.renderSlot(e.$slots, 'footer', {
          value: e.d_value,
          options: r.visibleOptions
        }),
        !e.options || (e.options && 0 === e.options.length)
          ? (Vue.openBlock(),
            Vue.createElementBlock(
              'span',
              Vue.mergeProps(
                {
                  key: 2,
                  role: 'status',
                  'aria-live': 'polite',
                  class: 'p-hidden-accessible'
                },
                e.ptm('hiddenEmptyMessage'),
                { 'data-p-hidden-accessible': !0 }
              ),
              Vue.toDisplayString(r.emptyMessageText),
              17
            ))
          : Vue.createCommentVNode('', !0),
        Vue.createElementVNode(
          'span',
          Vue.mergeProps(
            {
              role: 'status',
              'aria-live': 'polite',
              class: 'p-hidden-accessible'
            },
            e.ptm('hiddenSelectedMessage'),
            { 'data-p-hidden-accessible': !0 }
          ),
          Vue.toDisplayString(r.selectedMessageText),
          17
        ),
        Vue.createElementVNode(
          'span',
          Vue.mergeProps(
            {
              ref: 'lastHiddenFocusableElement',
              role: 'presentation',
              'aria-hidden': 'true',
              class: 'p-hidden-accessible p-hidden-focusable',
              tabindex: e.disabled ? -1 : e.tabindex,
              onFocus:
                t[6] ||
                (t[6] = function () {
                  return (
                    r.onLastHiddenFocus &&
                    r.onLastHiddenFocus.apply(r, arguments)
                  )
                })
            },
            e.ptm('hiddenLastFocusableEl'),
            { 'data-p-hidden-accessible': !0, 'data-p-hidden-focusable': !0 }
          ),
          null,
          16,
          _hoisted_6$8
        )
      ],
      16,
      _hoisted_1$$
    )
  )
}
__name(render$L, 'render$L'), (script$M.render = render$L)
var theme$u = __name(function (e) {
    var t = e.dt
    return '\n.p-badge {\n    display: inline-flex;\n    border-radius: '
      .concat(
        t('badge.border.radius'),
        ';\n    align-items: center;\n    justify-content: center;\n    padding: '
      )
      .concat(t('badge.padding'), ';\n    background: ')
      .concat(t('badge.primary.background'), ';\n    color: ')
      .concat(t('badge.primary.color'), ';\n    font-size: ')
      .concat(t('badge.font.size'), ';\n    font-weight: ')
      .concat(t('badge.font.weight'), ';\n    min-width: ')
      .concat(t('badge.min.width'), ';\n    height: ')
      .concat(t('badge.height'), ';\n}\n\n.p-badge-dot {\n    width: ')
      .concat(t('badge.dot.size'), ';\n    min-width: ')
      .concat(t('badge.dot.size'), ';\n    height: ')
      .concat(
        t('badge.dot.size'),
        ';\n    border-radius: 50%;\n    padding: 0;\n}\n\n.p-badge-circle {\n    padding: 0;\n    border-radius: 50%;\n}\n\n.p-badge-secondary {\n    background: '
      )
      .concat(t('badge.secondary.background'), ';\n    color: ')
      .concat(
        t('badge.secondary.color'),
        ';\n}\n\n.p-badge-success {\n    background: '
      )
      .concat(t('badge.success.background'), ';\n    color: ')
      .concat(
        t('badge.success.color'),
        ';\n}\n\n.p-badge-info {\n    background: '
      )
      .concat(t('badge.info.background'), ';\n    color: ')
      .concat(
        t('badge.info.color'),
        ';\n}\n\n.p-badge-warn {\n    background: '
      )
      .concat(t('badge.warn.background'), ';\n    color: ')
      .concat(
        t('badge.warn.color'),
        ';\n}\n\n.p-badge-danger {\n    background: '
      )
      .concat(t('badge.danger.background'), ';\n    color: ')
      .concat(
        t('badge.danger.color'),
        ';\n}\n\n.p-badge-contrast {\n    background: '
      )
      .concat(t('badge.contrast.background'), ';\n    color: ')
      .concat(
        t('badge.contrast.color'),
        ';\n}\n\n.p-badge-sm {\n    font-size: '
      )
      .concat(t('badge.sm.font.size'), ';\n    min-width: ')
      .concat(t('badge.sm.min.width'), ';\n    height: ')
      .concat(t('badge.sm.height'), ';\n}\n\n.p-badge-lg {\n    font-size: ')
      .concat(t('badge.lg.font.size'), ';\n    min-width: ')
      .concat(t('badge.lg.min.width'), ';\n    height: ')
      .concat(t('badge.lg.height'), ';\n}\n\n.p-badge-xl {\n    font-size: ')
      .concat(t('badge.xl.font.size'), ';\n    min-width: ')
      .concat(t('badge.xl.min.width'), ';\n    height: ')
      .concat(t('badge.xl.height'), ';\n}\n')
  }, 'theme'),
  classes$w = {
    root: __name(function (e) {
      var t = e.props,
        n = e.instance
      return [
        'p-badge p-component',
        {
          'p-badge-circle': isNotEmpty(t.value) && 1 === String(t.value).length,
          'p-badge-dot': isEmpty(t.value) && !n.$slots.default,
          'p-badge-sm': 'small' === t.size,
          'p-badge-lg': 'large' === t.size,
          'p-badge-xl': 'xlarge' === t.size,
          'p-badge-info': 'info' === t.severity,
          'p-badge-success': 'success' === t.severity,
          'p-badge-warn': 'warn' === t.severity,
          'p-badge-danger': 'danger' === t.severity,
          'p-badge-secondary': 'secondary' === t.severity,
          'p-badge-contrast': 'contrast' === t.severity
        }
      ]
    }, 'root')
  },
  BadgeStyle = BaseStyle.extend({
    name: 'badge',
    theme: theme$u,
    classes: classes$w
  }),
  script$1$v = {
    name: 'BaseBadge',
    extends: script$Y,
    props: {
      value: { type: [String, Number], default: null },
      severity: { type: String, default: null },
      size: { type: String, default: null }
    },
    style: BadgeStyle,
    provide: __name(function () {
      return { $pcBadge: this, $parentInstance: this }
    }, 'provide')
  },
  script$L = { name: 'Badge', extends: script$1$v, inheritAttrs: !1 }
function render$K(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'span',
      Vue.mergeProps({ class: e.cx('root') }, e.ptmi('root')),
      [
        Vue.renderSlot(e.$slots, 'default', {}, function () {
          return [Vue.createTextVNode(Vue.toDisplayString(e.value), 1)]
        })
      ],
      16
    )
  )
}
function _typeof$d(e) {
  return (_typeof$d =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function _defineProperty$d(e, t, n) {
  return (
    (t = _toPropertyKey$c(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$c(e) {
  var t = _toPrimitive$c(e, 'string')
  return 'symbol' == _typeof$d(t) ? t : t + ''
}
function _toPrimitive$c(e, t) {
  if ('object' != _typeof$d(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$d(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(render$K, 'render$K'),
  (script$L.render = render$K),
  __name(_typeof$d, '_typeof$d'),
  __name(_defineProperty$d, '_defineProperty$d'),
  __name(_toPropertyKey$c, '_toPropertyKey$c'),
  __name(_toPrimitive$c, '_toPrimitive$c')
var theme$t = __name(function (e) {
    var t = e.dt
    return '\n.p-button {\n    display: inline-flex;\n    cursor: pointer;\n    user-select: none;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    color: '
      .concat(t('button.primary.color'), ';\n    background: ')
      .concat(t('button.primary.background'), ';\n    border: 1px solid ')
      .concat(t('button.primary.border.color'), ';\n    padding: ')
      .concat(t('button.padding.y'), ' ')
      .concat(
        t('button.padding.x'),
        ';\n    font-size: 1rem;\n    font-family: inherit;\n    font-feature-settings: inherit;\n    transition: background '
      )
      .concat(t('button.transition.duration'), ', color ')
      .concat(t('button.transition.duration'), ', border-color ')
      .concat(t('button.transition.duration'), ',\n            outline-color ')
      .concat(t('button.transition.duration'), ', box-shadow ')
      .concat(t('button.transition.duration'), ';\n    border-radius: ')
      .concat(
        t('button.border.radius'),
        ';\n    outline-color: transparent;\n    gap: '
      )
      .concat(
        t('button.gap'),
        ';\n}\n\n.p-button:disabled {\n    cursor: default;\n}\n\n.p-button-icon-right {\n    order: 1;\n}\n\n.p-button-icon-right:dir(rtl) {\n    order: -1;\n}\n\n.p-button:not(.p-button-vertical) .p-button-icon:not(.p-button-icon-right):dir(rtl) {\n    order: 1;\n}\n\n.p-button-icon-bottom {\n    order: 2;\n}\n\n.p-button-icon-only {\n    width: '
      )
      .concat(
        t('button.icon.only.width'),
        ';\n    padding-inline-start: 0;\n    padding-inline-end: 0;\n    gap: 0;\n}\n\n.p-button-icon-only.p-button-rounded {\n    border-radius: 50%;\n    height: '
      )
      .concat(
        t('button.icon.only.width'),
        ';\n}\n\n.p-button-icon-only .p-button-label {\n    visibility: hidden;\n    width: 0;\n}\n\n.p-button-sm {\n    font-size: '
      )
      .concat(t('button.sm.font.size'), ';\n    padding: ')
      .concat(t('button.sm.padding.y'), ' ')
      .concat(
        t('button.sm.padding.x'),
        ';\n}\n\n.p-button-sm .p-button-icon {\n    font-size: '
      )
      .concat(
        t('button.sm.font.size'),
        ';\n}\n\n.p-button-lg {\n    font-size: '
      )
      .concat(t('button.lg.font.size'), ';\n    padding: ')
      .concat(t('button.lg.padding.y'), ' ')
      .concat(
        t('button.lg.padding.x'),
        ';\n}\n\n.p-button-lg .p-button-icon {\n    font-size: '
      )
      .concat(
        t('button.lg.font.size'),
        ';\n}\n\n.p-button-vertical {\n    flex-direction: column;\n}\n\n.p-button-label {\n    font-weight: '
      )
      .concat(
        t('button.label.font.weight'),
        ';\n}\n\n.p-button-fluid {\n    width: 100%;\n}\n\n.p-button-fluid.p-button-icon-only {\n    width: '
      )
      .concat(
        t('button.icon.only.width'),
        ';\n}\n\n.p-button:not(:disabled):hover {\n    background: '
      )
      .concat(t('button.primary.hover.background'), ';\n    border: 1px solid ')
      .concat(t('button.primary.hover.border.color'), ';\n    color: ')
      .concat(
        t('button.primary.hover.color'),
        ';\n}\n\n.p-button:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.primary.active.background'),
        ';\n    border: 1px solid '
      )
      .concat(t('button.primary.active.border.color'), ';\n    color: ')
      .concat(
        t('button.primary.active.color'),
        ';\n}\n\n.p-button:focus-visible {\n    box-shadow: '
      )
      .concat(t('button.primary.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('button.focus.ring.width'), ' ')
      .concat(t('button.focus.ring.style'), ' ')
      .concat(t('button.primary.focus.ring.color'), ';\n    outline-offset: ')
      .concat(
        t('button.focus.ring.offset'),
        ';\n}\n\n.p-button .p-badge {\n    min-width: '
      )
      .concat(t('button.badge.size'), ';\n    height: ')
      .concat(t('button.badge.size'), ';\n    line-height: ')
      .concat(
        t('button.badge.size'),
        ';\n}\n\n.p-button-raised {\n    box-shadow: '
      )
      .concat(
        t('button.raised.shadow'),
        ';\n}\n\n.p-button-rounded {\n    border-radius: '
      )
      .concat(
        t('button.rounded.border.radius'),
        ';\n}\n\n.p-button-secondary {\n    background: '
      )
      .concat(t('button.secondary.background'), ';\n    border: 1px solid ')
      .concat(t('button.secondary.border.color'), ';\n    color: ')
      .concat(
        t('button.secondary.color'),
        ';\n}\n\n.p-button-secondary:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.secondary.hover.background'),
        ';\n    border: 1px solid '
      )
      .concat(t('button.secondary.hover.border.color'), ';\n    color: ')
      .concat(
        t('button.secondary.hover.color'),
        ';\n}\n\n.p-button-secondary:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.secondary.active.background'),
        ';\n    border: 1px solid '
      )
      .concat(t('button.secondary.active.border.color'), ';\n    color: ')
      .concat(
        t('button.secondary.active.color'),
        ';\n}\n\n.p-button-secondary:focus-visible {\n    outline-color: '
      )
      .concat(t('button.secondary.focus.ring.color'), ';\n    box-shadow: ')
      .concat(
        t('button.secondary.focus.ring.shadow'),
        ';\n}\n\n.p-button-success {\n    background: '
      )
      .concat(t('button.success.background'), ';\n    border: 1px solid ')
      .concat(t('button.success.border.color'), ';\n    color: ')
      .concat(
        t('button.success.color'),
        ';\n}\n\n.p-button-success:not(:disabled):hover {\n    background: '
      )
      .concat(t('button.success.hover.background'), ';\n    border: 1px solid ')
      .concat(t('button.success.hover.border.color'), ';\n    color: ')
      .concat(
        t('button.success.hover.color'),
        ';\n}\n\n.p-button-success:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.success.active.background'),
        ';\n    border: 1px solid '
      )
      .concat(t('button.success.active.border.color'), ';\n    color: ')
      .concat(
        t('button.success.active.color'),
        ';\n}\n\n.p-button-success:focus-visible {\n    outline-color: '
      )
      .concat(t('button.success.focus.ring.color'), ';\n    box-shadow: ')
      .concat(
        t('button.success.focus.ring.shadow'),
        ';\n}\n\n.p-button-info {\n    background: '
      )
      .concat(t('button.info.background'), ';\n    border: 1px solid ')
      .concat(t('button.info.border.color'), ';\n    color: ')
      .concat(
        t('button.info.color'),
        ';\n}\n\n.p-button-info:not(:disabled):hover {\n    background: '
      )
      .concat(t('button.info.hover.background'), ';\n    border: 1px solid ')
      .concat(t('button.info.hover.border.color'), ';\n    color: ')
      .concat(
        t('button.info.hover.color'),
        ';\n}\n\n.p-button-info:not(:disabled):active {\n    background: '
      )
      .concat(t('button.info.active.background'), ';\n    border: 1px solid ')
      .concat(t('button.info.active.border.color'), ';\n    color: ')
      .concat(
        t('button.info.active.color'),
        ';\n}\n\n.p-button-info:focus-visible {\n    outline-color: '
      )
      .concat(t('button.info.focus.ring.color'), ';\n    box-shadow: ')
      .concat(
        t('button.info.focus.ring.shadow'),
        ';\n}\n\n.p-button-warn {\n    background: '
      )
      .concat(t('button.warn.background'), ';\n    border: 1px solid ')
      .concat(t('button.warn.border.color'), ';\n    color: ')
      .concat(
        t('button.warn.color'),
        ';\n}\n\n.p-button-warn:not(:disabled):hover {\n    background: '
      )
      .concat(t('button.warn.hover.background'), ';\n    border: 1px solid ')
      .concat(t('button.warn.hover.border.color'), ';\n    color: ')
      .concat(
        t('button.warn.hover.color'),
        ';\n}\n\n.p-button-warn:not(:disabled):active {\n    background: '
      )
      .concat(t('button.warn.active.background'), ';\n    border: 1px solid ')
      .concat(t('button.warn.active.border.color'), ';\n    color: ')
      .concat(
        t('button.warn.active.color'),
        ';\n}\n\n.p-button-warn:focus-visible {\n    outline-color: '
      )
      .concat(t('button.warn.focus.ring.color'), ';\n    box-shadow: ')
      .concat(
        t('button.warn.focus.ring.shadow'),
        ';\n}\n\n.p-button-help {\n    background: '
      )
      .concat(t('button.help.background'), ';\n    border: 1px solid ')
      .concat(t('button.help.border.color'), ';\n    color: ')
      .concat(
        t('button.help.color'),
        ';\n}\n\n.p-button-help:not(:disabled):hover {\n    background: '
      )
      .concat(t('button.help.hover.background'), ';\n    border: 1px solid ')
      .concat(t('button.help.hover.border.color'), ';\n    color: ')
      .concat(
        t('button.help.hover.color'),
        ';\n}\n\n.p-button-help:not(:disabled):active {\n    background: '
      )
      .concat(t('button.help.active.background'), ';\n    border: 1px solid ')
      .concat(t('button.help.active.border.color'), ';\n    color: ')
      .concat(
        t('button.help.active.color'),
        ';\n}\n\n.p-button-help:focus-visible {\n    outline-color: '
      )
      .concat(t('button.help.focus.ring.color'), ';\n    box-shadow: ')
      .concat(
        t('button.help.focus.ring.shadow'),
        ';\n}\n\n.p-button-danger {\n    background: '
      )
      .concat(t('button.danger.background'), ';\n    border: 1px solid ')
      .concat(t('button.danger.border.color'), ';\n    color: ')
      .concat(
        t('button.danger.color'),
        ';\n}\n\n.p-button-danger:not(:disabled):hover {\n    background: '
      )
      .concat(t('button.danger.hover.background'), ';\n    border: 1px solid ')
      .concat(t('button.danger.hover.border.color'), ';\n    color: ')
      .concat(
        t('button.danger.hover.color'),
        ';\n}\n\n.p-button-danger:not(:disabled):active {\n    background: '
      )
      .concat(t('button.danger.active.background'), ';\n    border: 1px solid ')
      .concat(t('button.danger.active.border.color'), ';\n    color: ')
      .concat(
        t('button.danger.active.color'),
        ';\n}\n\n.p-button-danger:focus-visible {\n    outline-color: '
      )
      .concat(t('button.danger.focus.ring.color'), ';\n    box-shadow: ')
      .concat(
        t('button.danger.focus.ring.shadow'),
        ';\n}\n\n.p-button-contrast {\n    background: '
      )
      .concat(t('button.contrast.background'), ';\n    border: 1px solid ')
      .concat(t('button.contrast.border.color'), ';\n    color: ')
      .concat(
        t('button.contrast.color'),
        ';\n}\n\n.p-button-contrast:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.contrast.hover.background'),
        ';\n    border: 1px solid '
      )
      .concat(t('button.contrast.hover.border.color'), ';\n    color: ')
      .concat(
        t('button.contrast.hover.color'),
        ';\n}\n\n.p-button-contrast:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.contrast.active.background'),
        ';\n    border: 1px solid '
      )
      .concat(t('button.contrast.active.border.color'), ';\n    color: ')
      .concat(
        t('button.contrast.active.color'),
        ';\n}\n\n.p-button-contrast:focus-visible {\n    outline-color: '
      )
      .concat(t('button.contrast.focus.ring.color'), ';\n    box-shadow: ')
      .concat(
        t('button.contrast.focus.ring.shadow'),
        ';\n}\n\n.p-button-outlined {\n    background: transparent;\n    border-color: '
      )
      .concat(t('button.outlined.primary.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.primary.color'),
        ';\n}\n\n.p-button-outlined:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.outlined.primary.hover.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.primary.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.primary.color'),
        ';\n}\n\n.p-button-outlined:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.outlined.primary.active.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.primary.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.primary.color'),
        ';\n}\n\n.p-button-outlined.p-button-secondary {\n    border-color: '
      )
      .concat(t('button.outlined.secondary.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.secondary.color'),
        ';\n}\n\n.p-button-outlined.p-button-secondary:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.outlined.secondary.hover.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.secondary.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.secondary.color'),
        ';\n}\n\n.p-button-outlined.p-button-secondary:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.outlined.secondary.active.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.secondary.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.secondary.color'),
        ';\n}\n\n.p-button-outlined.p-button-success {\n    border-color: '
      )
      .concat(t('button.outlined.success.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.success.color'),
        ';\n}\n\n.p-button-outlined.p-button-success:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.outlined.success.hover.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.success.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.success.color'),
        ';\n}\n\n.p-button-outlined.p-button-success:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.outlined.success.active.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.success.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.success.color'),
        ';\n}\n\n.p-button-outlined.p-button-info {\n    border-color: '
      )
      .concat(t('button.outlined.info.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.info.color'),
        ';\n}\n\n.p-button-outlined.p-button-info:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.outlined.info.hover.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.info.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.info.color'),
        ';\n}\n\n.p-button-outlined.p-button-info:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.outlined.info.active.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.info.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.info.color'),
        ';\n}\n\n.p-button-outlined.p-button-warn {\n    border-color: '
      )
      .concat(t('button.outlined.warn.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.warn.color'),
        ';\n}\n\n.p-button-outlined.p-button-warn:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.outlined.warn.hover.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.warn.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.warn.color'),
        ';\n}\n\n.p-button-outlined.p-button-warn:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.outlined.warn.active.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.warn.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.warn.color'),
        ';\n}\n\n.p-button-outlined.p-button-help {\n    border-color: '
      )
      .concat(t('button.outlined.help.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.help.color'),
        ';\n}\n\n.p-button-outlined.p-button-help:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.outlined.help.hover.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.help.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.help.color'),
        ';\n}\n\n.p-button-outlined.p-button-help:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.outlined.help.active.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.help.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.help.color'),
        ';\n}\n\n.p-button-outlined.p-button-danger {\n    border-color: '
      )
      .concat(t('button.outlined.danger.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.danger.color'),
        ';\n}\n\n.p-button-outlined.p-button-danger:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.outlined.danger.hover.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.danger.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.danger.color'),
        ';\n}\n\n.p-button-outlined.p-button-danger:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.outlined.danger.active.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.danger.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.danger.color'),
        ';\n}\n\n.p-button-outlined.p-button-contrast {\n    border-color: '
      )
      .concat(t('button.outlined.contrast.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.contrast.color'),
        ';\n}\n\n.p-button-outlined.p-button-contrast:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.outlined.contrast.hover.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.contrast.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.contrast.color'),
        ';\n}\n\n.p-button-outlined.p-button-contrast:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.outlined.contrast.active.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.contrast.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.contrast.color'),
        ';\n}\n\n.p-button-outlined.p-button-plain {\n    border-color: '
      )
      .concat(t('button.outlined.plain.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.plain.color'),
        ';\n}\n\n.p-button-outlined.p-button-plain:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.outlined.plain.hover.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.plain.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.plain.color'),
        ';\n}\n\n.p-button-outlined.p-button-plain:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.outlined.plain.active.background'),
        ';\n    border-color: '
      )
      .concat(t('button.outlined.plain.border.color'), ';\n    color: ')
      .concat(
        t('button.outlined.plain.color'),
        ';\n}\n\n.p-button-text {\n    background: transparent;\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.primary.color'),
        ';\n}\n\n.p-button-text:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.text.primary.hover.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.primary.color'),
        ';\n}\n\n.p-button-text:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.text.primary.active.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.primary.color'),
        ';\n}\n\n.p-button-text.p-button-secondary {\n    background: transparent;\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.secondary.color'),
        ';\n}\n\n.p-button-text.p-button-secondary:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.text.secondary.hover.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.secondary.color'),
        ';\n}\n\n.p-button-text.p-button-secondary:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.text.secondary.active.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.secondary.color'),
        ';\n}\n\n.p-button-text.p-button-success {\n    background: transparent;\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.success.color'),
        ';\n}\n\n.p-button-text.p-button-success:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.text.success.hover.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.success.color'),
        ';\n}\n\n.p-button-text.p-button-success:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.text.success.active.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.success.color'),
        ';\n}\n\n.p-button-text.p-button-info {\n    background: transparent;\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.info.color'),
        ';\n}\n\n.p-button-text.p-button-info:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.text.info.hover.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.info.color'),
        ';\n}\n\n.p-button-text.p-button-info:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.text.info.active.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.info.color'),
        ';\n}\n\n.p-button-text.p-button-warn {\n    background: transparent;\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.warn.color'),
        ';\n}\n\n.p-button-text.p-button-warn:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.text.warn.hover.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.warn.color'),
        ';\n}\n\n.p-button-text.p-button-warn:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.text.warn.active.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.warn.color'),
        ';\n}\n\n.p-button-text.p-button-help {\n    background: transparent;\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.help.color'),
        ';\n}\n\n.p-button-text.p-button-help:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.text.help.hover.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.help.color'),
        ';\n}\n\n.p-button-text.p-button-help:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.text.help.active.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.help.color'),
        ';\n}\n\n.p-button-text.p-button-danger {\n    background: transparent;\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.danger.color'),
        ';\n}\n\n.p-button-text.p-button-danger:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.text.danger.hover.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.danger.color'),
        ';\n}\n\n.p-button-text.p-button-danger:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.text.danger.active.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.danger.color'),
        ';\n}\n\n.p-button-text.p-button-contrast {\n    background: transparent;\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.contrast.color'),
        ';\n}\n\n.p-button-text.p-button-contrast:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.text.contrast.hover.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.contrast.color'),
        ';\n}\n\n.p-button-text.p-button-contrast:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.text.contrast.active.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.contrast.color'),
        ';\n}\n\n.p-button-text.p-button-plain {\n    background: transparent;\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.plain.color'),
        ';\n}\n\n.p-button-text.p-button-plain:not(:disabled):hover {\n    background: '
      )
      .concat(
        t('button.text.plain.hover.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.plain.color'),
        ';\n}\n\n.p-button-text.p-button-plain:not(:disabled):active {\n    background: '
      )
      .concat(
        t('button.text.plain.active.background'),
        ';\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.text.plain.color'),
        ';\n}\n\n.p-button-link {\n    background: transparent;\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.link.color'),
        ';\n}\n\n.p-button-link:not(:disabled):hover {\n    background: transparent;\n    border-color: transparent;\n    color: '
      )
      .concat(
        t('button.link.hover.color'),
        ';\n}\n\n.p-button-link:not(:disabled):hover .p-button-label {\n    text-decoration: underline;\n}\n\n.p-button-link:not(:disabled):active {\n    background: transparent;\n    border-color: transparent;\n    color: '
      )
      .concat(t('button.link.active.color'), ';\n}\n')
  }, 'theme'),
  classes$v = {
    root: __name(function (e) {
      var t = e.instance,
        n = e.props
      return [
        'p-button p-component',
        _defineProperty$d(
          _defineProperty$d(
            _defineProperty$d(
              _defineProperty$d(
                _defineProperty$d(
                  _defineProperty$d(
                    _defineProperty$d(
                      _defineProperty$d(
                        _defineProperty$d(
                          {
                            'p-button-icon-only':
                              t.hasIcon && !n.label && !n.badge,
                            'p-button-vertical':
                              ('top' === n.iconPos || 'bottom' === n.iconPos) &&
                              n.label,
                            'p-button-loading': n.loading,
                            'p-button-link': n.link || 'link' === n.variant
                          },
                          'p-button-'.concat(n.severity),
                          n.severity
                        ),
                        'p-button-raised',
                        n.raised
                      ),
                      'p-button-rounded',
                      n.rounded
                    ),
                    'p-button-text',
                    n.text || 'text' === n.variant
                  ),
                  'p-button-outlined',
                  n.outlined || 'outlined' === n.variant
                ),
                'p-button-sm',
                'small' === n.size
              ),
              'p-button-lg',
              'large' === n.size
            ),
            'p-button-plain',
            n.plain
          ),
          'p-button-fluid',
          t.hasFluid
        )
      ]
    }, 'root'),
    loadingIcon: 'p-button-loading-icon',
    icon: __name(function (e) {
      var t = e.props
      return [
        'p-button-icon',
        _defineProperty$d({}, 'p-button-icon-'.concat(t.iconPos), t.label)
      ]
    }, 'icon'),
    label: 'p-button-label'
  },
  ButtonStyle = BaseStyle.extend({
    name: 'button',
    theme: theme$t,
    classes: classes$v
  }),
  script$1$u = {
    name: 'BaseButton',
    extends: script$Y,
    props: {
      label: { type: String, default: null },
      icon: { type: String, default: null },
      iconPos: { type: String, default: 'left' },
      iconClass: { type: [String, Object], default: null },
      badge: { type: String, default: null },
      badgeClass: { type: [String, Object], default: null },
      badgeSeverity: { type: String, default: 'secondary' },
      loading: { type: Boolean, default: !1 },
      loadingIcon: { type: String, default: void 0 },
      as: { type: [String, Object], default: 'BUTTON' },
      asChild: { type: Boolean, default: !1 },
      link: { type: Boolean, default: !1 },
      severity: { type: String, default: null },
      raised: { type: Boolean, default: !1 },
      rounded: { type: Boolean, default: !1 },
      text: { type: Boolean, default: !1 },
      outlined: { type: Boolean, default: !1 },
      size: { type: String, default: null },
      variant: { type: String, default: null },
      plain: { type: Boolean, default: !1 },
      fluid: { type: Boolean, default: null }
    },
    style: ButtonStyle,
    provide: __name(function () {
      return { $pcButton: this, $parentInstance: this }
    }, 'provide')
  },
  script$K = {
    name: 'Button',
    extends: script$1$u,
    inheritAttrs: !1,
    inject: { $pcFluid: { default: null } },
    methods: {
      getPTOptions: __name(function (e) {
        return ('root' === e ? this.ptmi : this.ptm)(e, {
          context: { disabled: this.disabled }
        })
      }, 'getPTOptions')
    },
    computed: {
      disabled: __name(function () {
        return (
          this.$attrs.disabled || '' === this.$attrs.disabled || this.loading
        )
      }, 'disabled'),
      defaultAriaLabel: __name(function () {
        return this.label
          ? this.label + (this.badge ? ' ' + this.badge : '')
          : this.$attrs.ariaLabel
      }, 'defaultAriaLabel'),
      hasIcon: __name(function () {
        return this.icon || this.$slots.icon
      }, 'hasIcon'),
      attrs: __name(function () {
        return Vue.mergeProps(
          this.asAttrs,
          this.a11yAttrs,
          this.getPTOptions('root')
        )
      }, 'attrs'),
      asAttrs: __name(function () {
        return 'BUTTON' === this.as
          ? { type: 'button', disabled: this.disabled }
          : void 0
      }, 'asAttrs'),
      a11yAttrs: __name(function () {
        return {
          'aria-label': this.defaultAriaLabel,
          'data-pc-name': 'button',
          'data-p-disabled': this.disabled,
          'data-p-severity': this.severity
        }
      }, 'a11yAttrs'),
      hasFluid: __name(function () {
        return isEmpty(this.fluid) ? !!this.$pcFluid : this.fluid
      }, 'hasFluid')
    },
    components: { SpinnerIcon: script$O, Badge: script$L },
    directives: { ripple: Ripple }
  }
function render$J(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('SpinnerIcon'),
    s = Vue.resolveComponent('Badge'),
    l = Vue.resolveDirective('ripple')
  return e.asChild
    ? Vue.renderSlot(e.$slots, 'default', {
        key: 1,
        class: Vue.normalizeClass(e.cx('root')),
        a11yAttrs: r.a11yAttrs
      })
    : Vue.withDirectives(
        (Vue.openBlock(),
        Vue.createBlock(
          Vue.resolveDynamicComponent(e.as),
          Vue.mergeProps({ key: 0, class: e.cx('root') }, r.attrs),
          {
            default: Vue.withCtx(function () {
              return [
                Vue.renderSlot(e.$slots, 'default', {}, function () {
                  return [
                    e.loading
                      ? Vue.renderSlot(
                          e.$slots,
                          'loadingicon',
                          Vue.mergeProps(
                            {
                              key: 0,
                              class: [e.cx('loadingIcon'), e.cx('icon')]
                            },
                            e.ptm('loadingIcon')
                          ),
                          function () {
                            return [
                              e.loadingIcon
                                ? (Vue.openBlock(),
                                  Vue.createElementBlock(
                                    'span',
                                    Vue.mergeProps(
                                      {
                                        key: 0,
                                        class: [
                                          e.cx('loadingIcon'),
                                          e.cx('icon'),
                                          e.loadingIcon
                                        ]
                                      },
                                      e.ptm('loadingIcon')
                                    ),
                                    null,
                                    16
                                  ))
                                : (Vue.openBlock(),
                                  Vue.createBlock(
                                    a,
                                    Vue.mergeProps(
                                      {
                                        key: 1,
                                        class: [
                                          e.cx('loadingIcon'),
                                          e.cx('icon')
                                        ],
                                        spin: ''
                                      },
                                      e.ptm('loadingIcon')
                                    ),
                                    null,
                                    16,
                                    ['class']
                                  ))
                            ]
                          }
                        )
                      : Vue.renderSlot(
                          e.$slots,
                          'icon',
                          Vue.mergeProps(
                            { key: 1, class: [e.cx('icon')] },
                            e.ptm('icon')
                          ),
                          function () {
                            return [
                              e.icon
                                ? (Vue.openBlock(),
                                  Vue.createElementBlock(
                                    'span',
                                    Vue.mergeProps(
                                      {
                                        key: 0,
                                        class: [
                                          e.cx('icon'),
                                          e.icon,
                                          e.iconClass
                                        ]
                                      },
                                      e.ptm('icon')
                                    ),
                                    null,
                                    16
                                  ))
                                : Vue.createCommentVNode('', !0)
                            ]
                          }
                        ),
                    Vue.createElementVNode(
                      'span',
                      Vue.mergeProps({ class: e.cx('label') }, e.ptm('label')),
                      Vue.toDisplayString(e.label || ' '),
                      17
                    ),
                    e.badge
                      ? (Vue.openBlock(),
                        Vue.createBlock(
                          s,
                          {
                            key: 2,
                            value: e.badge,
                            class: Vue.normalizeClass(e.badgeClass),
                            severity: e.badgeSeverity,
                            unstyled: e.unstyled,
                            pt: e.ptm('pcBadge')
                          },
                          null,
                          8,
                          ['value', 'class', 'severity', 'unstyled', 'pt']
                        ))
                      : Vue.createCommentVNode('', !0)
                  ]
                })
              ]
            }),
            _: 3
          },
          16,
          ['class']
        )),
        [[l]]
      )
}
__name(render$J, 'render$J'), (script$K.render = render$J)
var theme$s = __name(function (e) {
    var t = e.dt
    return '\n.p-card {\n    background: '
      .concat(t('card.background'), ';\n    color: ')
      .concat(t('card.color'), ';\n    box-shadow: ')
      .concat(t('card.shadow'), ';\n    border-radius: ')
      .concat(
        t('card.border.radius'),
        ';\n    display: flex;\n    flex-direction: column;\n}\n\n.p-card-caption {\n    display: flex;\n    flex-direction: column;\n    gap: '
      )
      .concat(t('card.caption.gap'), ';\n}\n\n.p-card-body {\n    padding: ')
      .concat(
        t('card.body.padding'),
        ';\n    display: flex;\n    flex-direction: column;\n    gap: '
      )
      .concat(t('card.body.gap'), ';\n}\n\n.p-card-title {\n    font-size: ')
      .concat(t('card.title.font.size'), ';\n    font-weight: ')
      .concat(
        t('card.title.font.weight'),
        ';\n}\n\n.p-card-subtitle {\n    color: '
      )
      .concat(t('card.subtitle.color'), ';\n}\n')
  }, 'theme'),
  classes$u = {
    root: 'p-card p-component',
    header: 'p-card-header',
    body: 'p-card-body',
    caption: 'p-card-caption',
    title: 'p-card-title',
    subtitle: 'p-card-subtitle',
    content: 'p-card-content',
    footer: 'p-card-footer'
  },
  CardStyle = BaseStyle.extend({
    name: 'card',
    theme: theme$s,
    classes: classes$u
  }),
  script$1$t = {
    name: 'BaseCard',
    extends: script$Y,
    style: CardStyle,
    provide: __name(function () {
      return { $pcCard: this, $parentInstance: this }
    }, 'provide')
  },
  script$J = { name: 'Card', extends: script$1$t, inheritAttrs: !1 }
function render$I(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps({ class: e.cx('root') }, e.ptmi('root')),
      [
        e.$slots.header
          ? (Vue.openBlock(),
            Vue.createElementBlock(
              'div',
              Vue.mergeProps(
                { key: 0, class: e.cx('header') },
                e.ptm('header')
              ),
              [Vue.renderSlot(e.$slots, 'header')],
              16
            ))
          : Vue.createCommentVNode('', !0),
        Vue.createElementVNode(
          'div',
          Vue.mergeProps({ class: e.cx('body') }, e.ptm('body')),
          [
            e.$slots.title || e.$slots.subtitle
              ? (Vue.openBlock(),
                Vue.createElementBlock(
                  'div',
                  Vue.mergeProps(
                    { key: 0, class: e.cx('caption') },
                    e.ptm('caption')
                  ),
                  [
                    e.$slots.title
                      ? (Vue.openBlock(),
                        Vue.createElementBlock(
                          'div',
                          Vue.mergeProps(
                            { key: 0, class: e.cx('title') },
                            e.ptm('title')
                          ),
                          [Vue.renderSlot(e.$slots, 'title')],
                          16
                        ))
                      : Vue.createCommentVNode('', !0),
                    e.$slots.subtitle
                      ? (Vue.openBlock(),
                        Vue.createElementBlock(
                          'div',
                          Vue.mergeProps(
                            { key: 1, class: e.cx('subtitle') },
                            e.ptm('subtitle')
                          ),
                          [Vue.renderSlot(e.$slots, 'subtitle')],
                          16
                        ))
                      : Vue.createCommentVNode('', !0)
                  ],
                  16
                ))
              : Vue.createCommentVNode('', !0),
            Vue.createElementVNode(
              'div',
              Vue.mergeProps({ class: e.cx('content') }, e.ptm('content')),
              [Vue.renderSlot(e.$slots, 'content')],
              16
            ),
            e.$slots.footer
              ? (Vue.openBlock(),
                Vue.createElementBlock(
                  'div',
                  Vue.mergeProps(
                    { key: 1, class: e.cx('footer') },
                    e.ptm('footer')
                  ),
                  [Vue.renderSlot(e.$slots, 'footer')],
                  16
                ))
              : Vue.createCommentVNode('', !0)
          ],
          16
        )
      ],
      16
    )
  )
}
__name(render$I, 'render$I'), (script$J.render = render$I)
const _hoisted_1$_ = { class: 'flex flex-col items-center' },
  _hoisted_2$C = { class: 'whitespace-pre-line text-center' },
  _sfc_main$U = Vue.defineComponent({
    __name: 'NoResultsPlaceholder',
    props: { class: {}, icon: {}, title: {}, message: {}, buttonLabel: {} },
    emits: ['action'],
    setup(e) {
      const t = e
      return (e, n) => (
        Vue.openBlock(),
        Vue.createElementBlock(
          'div',
          {
            class: Vue.normalizeClass([
              'no-results-placeholder p-8 h-full',
              t.class
            ])
          },
          [
            Vue.createVNode(Vue.unref(script$J), null, {
              content: Vue.withCtx(() => [
                Vue.createElementVNode('div', _hoisted_1$_, [
                  Vue.createElementVNode(
                    'i',
                    {
                      class: Vue.normalizeClass(e.icon),
                      style: { 'font-size': '3rem', 'margin-bottom': '1rem' }
                    },
                    null,
                    2
                  ),
                  Vue.createElementVNode(
                    'h3',
                    null,
                    Vue.toDisplayString(e.title),
                    1
                  ),
                  Vue.createElementVNode(
                    'p',
                    _hoisted_2$C,
                    Vue.toDisplayString(e.message),
                    1
                  ),
                  e.buttonLabel
                    ? (Vue.openBlock(),
                      Vue.createBlock(
                        Vue.unref(script$K),
                        {
                          key: 0,
                          label: e.buttonLabel,
                          onClick: n[0] || (n[0] = (t) => e.$emit('action')),
                          class: 'p-button-text'
                        },
                        null,
                        8,
                        ['label']
                      ))
                    : Vue.createCommentVNode('', !0)
                ])
              ]),
              _: 1
            })
          ],
          2
        )
      )
    }
  }),
  _export_sfc = __name((e, t) => {
    const n = e.__vccOpts || e
    for (const [o, i] of t) n[o] = i
    return n
  }, '_export_sfc'),
  NoResultsPlaceholder = _export_sfc(_sfc_main$U, [
    ['__scopeId', 'data-v-a1e982e0']
  ]),
  _hoisted_1$Z = { class: 'flex align-items-center' },
  _hoisted_2$B = { class: 'node-type' },
  _hoisted_3$o = { key: 0, class: 'node-hint' },
  _sfc_main$T = Vue.defineComponent({
    __name: 'LoadWorkflowWarning',
    props: { missingNodeTypes: {} },
    setup(e) {
      const t = e,
        n = Vue.computed(() => {
          const e = new Set()
          return t.missingNodeTypes
            .filter((t) => {
              const n = 'object' == typeof t ? t.type : t
              return !e.has(n) && (e.add(n), !0)
            })
            .map((e) =>
              'object' == typeof e
                ? { label: e.type, hint: e.hint, action: e.action }
                : { label: e }
            )
        })
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock(
          Vue.Fragment,
          null,
          [
            Vue.createVNode(NoResultsPlaceholder, {
              class: 'pb-0',
              icon: 'pi pi-exclamation-circle',
              title: 'Missing Node Types',
              message:
                'When loading the graph, the following node types were not found'
            }),
            Vue.createVNode(
              Vue.unref(script$M),
              {
                options: n.value,
                optionLabel: 'label',
                scrollHeight: '100%',
                class: 'comfy-missing-nodes',
                pt: { list: { class: 'border-none' } }
              },
              {
                option: Vue.withCtx((e) => [
                  Vue.createElementVNode('div', _hoisted_1$Z, [
                    Vue.createElementVNode(
                      'span',
                      _hoisted_2$B,
                      Vue.toDisplayString(e.option.label),
                      1
                    ),
                    e.option.hint
                      ? (Vue.openBlock(),
                        Vue.createElementBlock(
                          'span',
                          _hoisted_3$o,
                          Vue.toDisplayString(e.option.hint),
                          1
                        ))
                      : Vue.createCommentVNode('', !0),
                    e.option.action
                      ? (Vue.openBlock(),
                        Vue.createBlock(
                          Vue.unref(script$K),
                          {
                            key: 1,
                            onClick: e.option.action.callback,
                            label: e.option.action.text,
                            size: 'small',
                            outlined: ''
                          },
                          null,
                          8,
                          ['onClick', 'label']
                        ))
                      : Vue.createCommentVNode('', !0)
                  ])
                ]),
                _: 1
              },
              8,
              ['options']
            )
          ],
          64
        )
      )
    }
  }),
  LoadWorkflowWarning = _export_sfc(_sfc_main$T, [
    ['__scopeId', 'data-v-05a7c5eb']
  ])
function useDownload(e, t) {
  const n = Vue.ref(null),
    o = __name(async () => {
      try {
        const t = await fetch(e, { method: 'HEAD' })
        if (!t.ok) throw new Error('Failed to fetch file size')
        const n = t.headers.get('content-length')
        return n
          ? parseInt(n)
          : (console.error('"content-length" header not found'), null)
      } catch (e2) {
        return console.error('Error fetching file size:', e2), null
      }
    }, 'fetchFileSize'),
    i = __name(() => {
      const n = document.createElement('a')
      ;(n.href = e),
        (n.download = t || e.split('/').pop() || 'download'),
        (n.target = '_blank'),
        (n.rel = 'noopener noreferrer'),
        n.click()
    }, 'triggerBrowserDownload')
  return (
    Vue.onMounted(async () => {
      n.value = await o()
    }),
    { triggerBrowserDownload: i, fileSize: n }
  )
}
function formatCamelCase(e) {
  if (!/^([A-Z][a-z]*)+$/.test(e)) return e
  return e
    .split(/(?=[A-Z][a-z])|\d+/)
    .map((e) =>
      e.length > 1 && e === e.toUpperCase()
        ? e
        : e.charAt(0).toUpperCase() + e.slice(1)
    )
    .join(' ')
}
function appendJsonExt(e) {
  return e.toLowerCase().endsWith('.json') || (e += '.json'), e
}
function trimJsonExt(e) {
  return e?.replace(/\.json$/, '')
}
function highlightQuery(e, t) {
  if (!t) return e
  const n = new RegExp(`(${t})`, 'gi')
  return e.replace(n, '<span class="highlight">$1</span>')
}
function formatNumberWithSuffix(
  e,
  { precision: t = 1, roundToInt: n = !1 } = {}
) {
  const o = ['', 'k', 'm', 'b', 't'],
    i = Math.abs(e)
  if (i < 1e3) return n ? Math.round(e).toString() : e.toFixed(t)
  const r = Math.min(Math.floor(Math.log10(i) / 3), o.length - 1)
  return `${(e / Math.pow(1e3, r)).toFixed(t)}${o[r]}`
}
function formatSize(e) {
  if (null == e) return '-'
  const t = e
  if (0 === t) return '0 B'
  const n = Math.floor(Math.log(t) / Math.log(1024))
  return `${parseFloat((t / Math.pow(1024, n)).toFixed(2))} ${['B', 'KB', 'MB', 'GB'][n]}`
}
function findCommonPrefix(e, t) {
  const n = e.split('/'),
    o = t.split('/'),
    i = []
  for (let r = 0; r < Math.min(n.length, o.length) && n[r] === o[r]; r++)
    i.push(n[r])
  return i.join('/')
}
function getFilenameDetails(e) {
  return e.includes('.')
    ? {
        filename: e.split('.').slice(0, -1).join('.'),
        suffix: e.split('.').pop() ?? null
      }
    : { filename: e, suffix: null }
}
function getPathDetails(e) {
  const t = e.split('/').slice(0, -1).join('/'),
    n = e.split('/').pop() ?? e
  return { directory: t, fullFilename: n, ...getFilenameDetails(n) }
}
function normalizeI18nKey(e) {
  return e.replace(/\./g, '_')
}
__name(useDownload, 'useDownload'),
  __name(formatCamelCase, 'formatCamelCase'),
  __name(appendJsonExt, 'appendJsonExt'),
  __name(trimJsonExt, 'trimJsonExt'),
  __name(highlightQuery, 'highlightQuery'),
  __name(formatNumberWithSuffix, 'formatNumberWithSuffix'),
  __name(formatSize, 'formatSize'),
  __name(findCommonPrefix, 'findCommonPrefix'),
  __name(getFilenameDetails, 'getFilenameDetails'),
  __name(getPathDetails, 'getPathDetails'),
  __name(normalizeI18nKey, 'normalizeI18nKey')
const _hoisted_1$Y = { class: 'flex flex-row items-center gap-2' },
  _hoisted_2$A = { class: 'file-info' },
  _hoisted_3$n = { class: 'file-details' },
  _hoisted_4$d = ['title'],
  _hoisted_5$a = { key: 0, class: 'file-error' },
  _hoisted_6$7 = { class: 'file-action' },
  _sfc_main$S = Vue.defineComponent({
    __name: 'FileDownload',
    props: { url: {}, hint: {}, label: {}, error: {} },
    setup(e) {
      const t = e,
        n = Vue.computed(() => t.label || t.url.split('/').pop()),
        o = Vue.computed(() => t.hint || t.url),
        i = useDownload(t.url),
        r = Vue.computed(() =>
          i.fileSize.value ? formatSize(i.fileSize.value) : '?'
        )
      return (e, a) => (
        Vue.openBlock(),
        Vue.createElementBlock('div', _hoisted_1$Y, [
          Vue.createElementVNode('div', _hoisted_2$A, [
            Vue.createElementVNode('div', _hoisted_3$n, [
              Vue.createElementVNode(
                'span',
                { class: 'file-type', title: o.value },
                Vue.toDisplayString(n.value),
                9,
                _hoisted_4$d
              )
            ]),
            t.error
              ? (Vue.openBlock(),
                Vue.createElementBlock(
                  'div',
                  _hoisted_5$a,
                  Vue.toDisplayString(t.error),
                  1
                ))
              : Vue.createCommentVNode('', !0)
          ]),
          Vue.createElementVNode('div', _hoisted_6$7, [
            Vue.createVNode(
              Vue.unref(script$K),
              {
                class: 'file-action-button',
                label: e.$t('download') + ' (' + r.value + ')',
                size: 'small',
                outlined: '',
                disabled: t.error,
                title: t.url,
                onClick: Vue.unref(i).triggerBrowserDownload
              },
              null,
              8,
              ['label', 'disabled', 'title', 'onClick']
            )
          ])
        ])
      )
    }
  })
function isElectron() {
  return 'electronAPI' in window && void 0 !== window.electronAPI
}
function electronAPI() {
  return window.electronAPI
}
__name(isElectron, 'isElectron'), __name(electronAPI, 'electronAPI')
const _sfc_main$R = Vue.defineComponent({
    __name: 'MissingModelsWarning',
    props: { missingModels: {}, paths: {} },
    setup(e) {
      const t = [
          'https://civitai.com/',
          'https://huggingface.co/',
          'http://localhost:'
        ],
        n = ['.safetensors', '.sft'],
        o = e,
        i = Vue.ref({}),
        r = Vue.computed(() =>
          o.missingModels.map((e) => {
            const r = o.paths[e.directory]
            if (e.directory_invalid || !r)
              return {
                label: `${e.directory} / ${e.name}`,
                url: e.url,
                error:
                  'Invalid directory specified (does this require custom nodes?)'
              }
            const a = i.value[e.name] ?? {
              downloading: !1,
              completed: !1,
              progress: 0,
              error: null,
              name: e.name,
              directory: e.directory,
              url: e.url,
              folder_path: r[0]
            }
            return (
              (i.value[e.name] = a),
              t.some((t) => e.url.startsWith(t))
                ? n.some((t) => e.name.endsWith(t))
                  ? {
                      url: e.url,
                      label: `${e.directory} / ${e.name}`,
                      downloading: a.downloading,
                      completed: a.completed,
                      progress: a.progress,
                      error: a.error,
                      name: e.name,
                      paths: r,
                      folderPath: a.folder_path
                    }
                  : {
                      label: `${e.directory} / ${e.name}`,
                      url: e.url,
                      error: `Only allowed suffixes are: '${n.join("', '")}'`
                    }
                : {
                    label: `${e.directory} / ${e.name}`,
                    url: e.url,
                    error: `Download not allowed from source '${e.url}', only allowed from '${t.join("', '")}'`
                  }
            )
          })
        )
      return (e, t) => {
        const n = Vue.resolveComponent('ElectronFileDownload')
        return (
          Vue.openBlock(),
          Vue.createElementBlock(
            Vue.Fragment,
            null,
            [
              Vue.createVNode(NoResultsPlaceholder, {
                class: 'pb-0',
                icon: 'pi pi-exclamation-circle',
                title: 'Missing Models',
                message:
                  'When loading the graph, the following models were not found'
              }),
              Vue.createVNode(
                Vue.unref(script$M),
                { options: r.value, class: 'comfy-missing-models' },
                {
                  option: Vue.withCtx(({ option: e }) => [
                    Vue.unref(isElectron)()
                      ? (Vue.openBlock(),
                        Vue.createBlock(
                          Vue.Suspense,
                          { key: 0 },
                          {
                            default: Vue.withCtx(() => [
                              Vue.createVNode(
                                n,
                                { url: e.url, label: e.label, error: e.error },
                                null,
                                8,
                                ['url', 'label', 'error']
                              )
                            ]),
                            _: 2
                          },
                          1024
                        ))
                      : (Vue.openBlock(),
                        Vue.createBlock(
                          _sfc_main$S,
                          {
                            key: 1,
                            url: e.url,
                            label: e.label,
                            error: e.error
                          },
                          null,
                          8,
                          ['url', 'label', 'error']
                        ))
                  ]),
                  _: 1
                },
                8,
                ['options']
              )
            ],
            64
          )
        )
      }
    }
  }),
  MissingModelsWarning = _export_sfc(_sfc_main$R, [
    ['__scopeId', 'data-v-8528eb79']
  ])
var theme$r = __name(function (e) {
    var t = e.dt
    return '\n.p-tabs {\n    display: flex;\n    flex-direction: column;\n}\n\n.p-tablist {\n    display: flex;\n    position: relative;\n}\n\n.p-tabs-scrollable > .p-tablist {\n    overflow: hidden;\n}\n\n.p-tablist-viewport {\n    overflow-x: auto;\n    overflow-y: hidden;\n    scroll-behavior: smooth;\n    scrollbar-width: none;\n    overscroll-behavior: contain auto;\n}\n\n.p-tablist-viewport::-webkit-scrollbar {\n    display: none;\n}\n\n.p-tablist-tab-list {\n    position: relative;\n    display: flex;\n    background: '
      .concat(
        t('tabs.tablist.background'),
        ';\n    border-style: solid;\n    border-color: '
      )
      .concat(t('tabs.tablist.border.color'), ';\n    border-width: ')
      .concat(
        t('tabs.tablist.border.width'),
        ';\n}\n\n.p-tablist-content {\n    flex-grow: 1;\n}\n\n.p-tablist-nav-button {\n    all: unset;\n    position: absolute !important;\n    flex-shrink: 0;\n    inset-block-start: 0;\n    z-index: 2;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: '
      )
      .concat(t('tabs.nav.button.background'), ';\n    color: ')
      .concat(t('tabs.nav.button.color'), ';\n    width: ')
      .concat(t('tabs.nav.button.width'), ';\n    transition: color ')
      .concat(t('tabs.transition.duration'), ', outline-color ')
      .concat(t('tabs.transition.duration'), ', box-shadow ')
      .concat(t('tabs.transition.duration'), ';\n    box-shadow: ')
      .concat(
        t('tabs.nav.button.shadow'),
        ';\n    outline-color: transparent;\n    cursor: pointer;\n}\n\n.p-tablist-nav-button:focus-visible {\n    z-index: 1;\n    box-shadow: '
      )
      .concat(t('tabs.nav.button.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('tabs.nav.button.focus.ring.width'), ' ')
      .concat(t('tabs.nav.button.focus.ring.style'), ' ')
      .concat(t('tabs.nav.button.focus.ring.color'), ';\n    outline-offset: ')
      .concat(
        t('tabs.nav.button.focus.ring.offset'),
        ';\n}\n\n.p-tablist-nav-button:hover {\n    color: '
      )
      .concat(
        t('tabs.nav.button.hover.color'),
        ';\n}\n\n.p-tablist-prev-button {\n    inset-inline-start: 0;\n}\n\n.p-tablist-next-button {\n    inset-inline-end: 0;\n}\n\n.p-tablist-prev-button:dir(rtl),\n.p-tablist-next-button:dir(rtl) {\n    transform: rotate(180deg);\n}\n\n\n.p-tab {\n    flex-shrink: 0;\n    cursor: pointer;\n    user-select: none;\n    position: relative;\n    border-style: solid;\n    white-space: nowrap;\n    background: '
      )
      .concat(t('tabs.tab.background'), ';\n    border-width: ')
      .concat(t('tabs.tab.border.width'), ';\n    border-color: ')
      .concat(t('tabs.tab.border.color'), ';\n    color: ')
      .concat(t('tabs.tab.color'), ';\n    padding: ')
      .concat(t('tabs.tab.padding'), ';\n    font-weight: ')
      .concat(t('tabs.tab.font.weight'), ';\n    transition: background ')
      .concat(t('tabs.transition.duration'), ', border-color ')
      .concat(t('tabs.transition.duration'), ', color ')
      .concat(t('tabs.transition.duration'), ', outline-color ')
      .concat(t('tabs.transition.duration'), ', box-shadow ')
      .concat(t('tabs.transition.duration'), ';\n    margin: ')
      .concat(
        t('tabs.tab.margin'),
        ';\n    outline-color: transparent;\n}\n\n.p-tab:not(.p-disabled):focus-visible {\n    z-index: 1;\n    box-shadow: '
      )
      .concat(t('tabs.tab.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('tabs.tab.focus.ring.width'), ' ')
      .concat(t('tabs.tab.focus.ring.style'), ' ')
      .concat(t('tabs.tab.focus.ring.color'), ';\n    outline-offset: ')
      .concat(
        t('tabs.tab.focus.ring.offset'),
        ';\n}\n\n.p-tab:not(.p-tab-active):not(.p-disabled):hover {\n    background: '
      )
      .concat(t('tabs.tab.hover.background'), ';\n    border-color: ')
      .concat(t('tabs.tab.hover.border.color'), ';\n    color: ')
      .concat(
        t('tabs.tab.hover.color'),
        ';\n}\n\n.p-tab-active {\n    background: '
      )
      .concat(t('tabs.tab.active.background'), ';\n    border-color: ')
      .concat(t('tabs.tab.active.border.color'), ';\n    color: ')
      .concat(
        t('tabs.tab.active.color'),
        ';\n}\n\n.p-tabpanels {\n    background: '
      )
      .concat(t('tabs.tabpanel.background'), ';\n    color: ')
      .concat(t('tabs.tabpanel.color'), ';\n    padding: ')
      .concat(
        t('tabs.tabpanel.padding'),
        ';\n    outline: 0 none;\n}\n\n.p-tabpanel:focus-visible {\n    box-shadow: '
      )
      .concat(t('tabs.tabpanel.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('tabs.tabpanel.focus.ring.width'), ' ')
      .concat(t('tabs.tabpanel.focus.ring.style'), ' ')
      .concat(t('tabs.tabpanel.focus.ring.color'), ';\n    outline-offset: ')
      .concat(
        t('tabs.tabpanel.focus.ring.offset'),
        ';\n}\n\n.p-tablist-active-bar {\n    z-index: 1;\n    display: block;\n    position: absolute;\n    inset-block-end: '
      )
      .concat(t('tabs.active.bar.bottom'), ';\n    height: ')
      .concat(t('tabs.active.bar.height'), ';\n    background: ')
      .concat(
        t('tabs.active.bar.background'),
        ';\n    transition: 250ms cubic-bezier(0.35, 0, 0.25, 1);\n}\n'
      )
  }, 'theme'),
  classes$t = {
    root: __name(function (e) {
      return ['p-tabs p-component', { 'p-tabs-scrollable': e.props.scrollable }]
    }, 'root')
  },
  TabsStyle = BaseStyle.extend({
    name: 'tabs',
    theme: theme$r,
    classes: classes$t
  }),
  script$1$s = {
    name: 'BaseTabs',
    extends: script$Y,
    props: {
      value: { type: [String, Number], default: void 0 },
      lazy: { type: Boolean, default: !1 },
      scrollable: { type: Boolean, default: !1 },
      showNavigators: { type: Boolean, default: !0 },
      tabindex: { type: Number, default: 0 },
      selectOnFocus: { type: Boolean, default: !1 }
    },
    style: TabsStyle,
    provide: __name(function () {
      return { $pcTabs: this, $parentInstance: this }
    }, 'provide')
  },
  script$I = {
    name: 'Tabs',
    extends: script$1$s,
    inheritAttrs: !1,
    emits: ['update:value'],
    data: __name(function () {
      return { id: this.$attrs.id, d_value: this.value }
    }, 'data'),
    watch: {
      '$attrs.id': __name(function (e) {
        this.id = e || UniqueComponentId()
      }, '$attrsId'),
      value: __name(function (e) {
        this.d_value = e
      }, 'value')
    },
    mounted: __name(function () {
      this.id = this.id || UniqueComponentId()
    }, 'mounted'),
    methods: {
      updateValue: __name(function (e) {
        this.d_value !== e &&
          ((this.d_value = e), this.$emit('update:value', e))
      }, 'updateValue'),
      isVertical: __name(function () {
        return 'vertical' === this.orientation
      }, 'isVertical')
    }
  }
function render$H(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps({ class: e.cx('root') }, e.ptmi('root')),
      [Vue.renderSlot(e.$slots, 'default')],
      16
    )
  )
}
__name(render$H, 'render$H'), (script$I.render = render$H)
var classes$s = { root: 'p-tabpanels' },
  TabPanelsStyle = BaseStyle.extend({ name: 'tabpanels', classes: classes$s }),
  script$1$r = {
    name: 'BaseTabPanels',
    extends: script$Y,
    props: {},
    style: TabPanelsStyle,
    provide: __name(function () {
      return { $pcTabPanels: this, $parentInstance: this }
    }, 'provide')
  },
  script$H = { name: 'TabPanels', extends: script$1$r, inheritAttrs: !1 }
function render$G(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps(
        { class: e.cx('root'), role: 'presentation' },
        e.ptmi('root')
      ),
      [Vue.renderSlot(e.$slots, 'default')],
      16
    )
  )
}
__name(render$G, 'render$G'), (script$H.render = render$G)
var theme$q = __name(function (e) {
    var t = e.dt
    return '\n.p-divider-horizontal {\n    display: flex;\n    width: 100%;\n    position: relative;\n    align-items: center;\n    margin: '
      .concat(t('divider.horizontal.margin'), ';\n    padding: ')
      .concat(
        t('divider.horizontal.padding'),
        ';\n}\n\n.p-divider-horizontal:before {\n    position: absolute;\n    display: block;\n    inset-block-start: 50%;\n    inset-inline-start: 0;\n    width: 100%;\n    content: "";\n    border-block-start: 1px solid '
      )
      .concat(
        t('divider.border.color'),
        ';\n}\n\n.p-divider-horizontal .p-divider-content {\n    padding: '
      )
      .concat(
        t('divider.horizontal.content.padding'),
        ';\n}\n\n.p-divider-vertical {\n    min-height: 100%;\n    display: flex;\n    position: relative;\n    justify-content: center;\n    margin: '
      )
      .concat(t('divider.vertical.margin'), ';\n    padding: ')
      .concat(
        t('divider.vertical.padding'),
        ';\n}\n\n.p-divider-vertical:before {\n    position: absolute;\n    display: block;\n    inset-block-start: 0;\n    inset-inline-start: 50%;\n    height: 100%;\n    content: "";\n    border-inline-start: 1px solid '
      )
      .concat(
        t('divider.border.color'),
        ';\n}\n\n.p-divider.p-divider-vertical .p-divider-content {\n    padding: '
      )
      .concat(
        t('divider.vertical.content.padding'),
        ';\n}\n\n.p-divider-content {\n    z-index: 1;\n    background: '
      )
      .concat(t('divider.content.background'), ';\n    color: ')
      .concat(
        t('divider.content.color'),
        ';\n}\n\n.p-divider-solid.p-divider-horizontal:before {\n    border-block-start-style: solid;\n}\n\n.p-divider-solid.p-divider-vertical:before {\n    border-inline-start-style: solid;\n}\n\n.p-divider-dashed.p-divider-horizontal:before {\n    border-block-start-style: dashed;\n}\n\n.p-divider-dashed.p-divider-vertical:before {\n    border-inline-start-style: dashed;\n}\n\n.p-divider-dotted.p-divider-horizontal:before {\n    border-block-start-style: dotted;\n}\n\n.p-divider-dotted.p-divider-vertical:before {\n    border-inline-start-style: dotted;\n}\n\n.p-divider-left:dir(rtl),\n.p-divider-right:dir(rtl) {\n    flex-direction: row-reverse;\n}\n'
      )
  }, 'theme'),
  inlineStyles$3 = {
    root: __name(function (e) {
      var t = e.props
      return {
        justifyContent:
          'horizontal' === t.layout
            ? 'center' === t.align || null === t.align
              ? 'center'
              : 'left' === t.align
                ? 'flex-start'
                : 'right' === t.align
                  ? 'flex-end'
                  : null
            : null,
        alignItems:
          'vertical' === t.layout
            ? 'center' === t.align || null === t.align
              ? 'center'
              : 'top' === t.align
                ? 'flex-start'
                : 'bottom' === t.align
                  ? 'flex-end'
                  : null
            : null
      }
    }, 'root')
  },
  classes$r = {
    root: __name(function (e) {
      var t = e.props
      return [
        'p-divider p-component',
        'p-divider-' + t.layout,
        'p-divider-' + t.type,
        {
          'p-divider-left':
            'horizontal' === t.layout && (!t.align || 'left' === t.align)
        },
        {
          'p-divider-center': 'horizontal' === t.layout && 'center' === t.align
        },
        { 'p-divider-right': 'horizontal' === t.layout && 'right' === t.align },
        { 'p-divider-top': 'vertical' === t.layout && 'top' === t.align },
        {
          'p-divider-center':
            'vertical' === t.layout && (!t.align || 'center' === t.align)
        },
        { 'p-divider-bottom': 'vertical' === t.layout && 'bottom' === t.align }
      ]
    }, 'root'),
    content: 'p-divider-content'
  },
  DividerStyle = BaseStyle.extend({
    name: 'divider',
    theme: theme$q,
    classes: classes$r,
    inlineStyles: inlineStyles$3
  }),
  script$1$q = {
    name: 'BaseDivider',
    extends: script$Y,
    props: {
      align: { type: String, default: null },
      layout: { type: String, default: 'horizontal' },
      type: { type: String, default: 'solid' }
    },
    style: DividerStyle,
    provide: __name(function () {
      return { $pcDivider: this, $parentInstance: this }
    }, 'provide')
  },
  script$G = { name: 'Divider', extends: script$1$q, inheritAttrs: !1 },
  _hoisted_1$X = ['aria-orientation']
function render$F(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps(
        {
          class: e.cx('root'),
          style: e.sx('root'),
          role: 'separator',
          'aria-orientation': e.layout
        },
        e.ptmi('root')
      ),
      [
        e.$slots.default
          ? (Vue.openBlock(),
            Vue.createElementBlock(
              'div',
              Vue.mergeProps(
                { key: 0, class: e.cx('content') },
                e.ptm('content')
              ),
              [Vue.renderSlot(e.$slots, 'default')],
              16
            ))
          : Vue.createCommentVNode('', !0)
      ],
      16,
      _hoisted_1$X
    )
  )
}
__name(render$F, 'render$F'), (script$G.render = render$F)
var theme$p = __name(function (e) {
    var t = e.dt
    return '\n.p-scrollpanel-content-container {\n    overflow: hidden;\n    width: 100%;\n    height: 100%;\n    position: relative;\n    z-index: 1;\n    float: left;\n}\n\n.p-scrollpanel-content {\n    height: calc(100% + calc(2 * '
      .concat(
        t('scrollpanel.bar.size'),
        '));\n    width: calc(100% + calc(2 * '
      )
      .concat(t('scrollpanel.bar.size'), '));\n    padding-inline: 0 calc(2 * ')
      .concat(t('scrollpanel.bar.size'), ');\n    padding-block: 0 calc(2 * ')
      .concat(
        t('scrollpanel.bar.size'),
        ');\n    position: relative;\n    overflow: auto;\n    box-sizing: border-box;\n    scrollbar-width: none;\n}\n\n.p-scrollpanel-content::-webkit-scrollbar {\n    display: none;\n}\n\n.p-scrollpanel-bar {\n    position: relative;\n    border-radius: '
      )
      .concat(
        t('scrollpanel.bar.border.radius'),
        ';\n    z-index: 2;\n    cursor: pointer;\n    opacity: 0;\n    outline-color: transparent;\n    background: '
      )
      .concat(
        t('scrollpanel.bar.background'),
        ';\n    border: 0 none;\n    transition: outline-color '
      )
      .concat(t('scrollpanel.transition.duration'), ', opacity ')
      .concat(
        t('scrollpanel.transition.duration'),
        ';\n}\n\n.p-scrollpanel-bar:focus-visible {\n    box-shadow: '
      )
      .concat(t('scrollpanel.bar.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('scrollpanel.barfocus.ring.width'), ' ')
      .concat(t('scrollpanel.bar.focus.ring.style'), ' ')
      .concat(t('scrollpanel.bar.focus.ring.color'), ';\n    outline-offset: ')
      .concat(
        t('scrollpanel.barfocus.ring.offset'),
        ';\n}\n\n.p-scrollpanel-bar-y {\n    width: '
      )
      .concat(
        t('scrollpanel.bar.size'),
        ';\n    inset-block-start: 0;\n}\n\n.p-scrollpanel-bar-x {\n    height: '
      )
      .concat(
        t('scrollpanel.bar.size'),
        ';\n    inset-block-end: 0;\n}\n\n.p-scrollpanel-hidden {\n    visibility: hidden;\n}\n\n.p-scrollpanel:hover .p-scrollpanel-bar,\n.p-scrollpanel:active .p-scrollpanel-bar {\n    opacity: 1;\n}\n\n.p-scrollpanel-grabbed {\n    user-select: none;\n}\n'
      )
  }, 'theme'),
  classes$q = {
    root: 'p-scrollpanel p-component',
    contentContainer: 'p-scrollpanel-content-container',
    content: 'p-scrollpanel-content',
    barX: 'p-scrollpanel-bar p-scrollpanel-bar-x',
    barY: 'p-scrollpanel-bar p-scrollpanel-bar-y'
  },
  ScrollPanelStyle = BaseStyle.extend({
    name: 'scrollpanel',
    theme: theme$p,
    classes: classes$q
  }),
  script$1$p = {
    name: 'BaseScrollPanel',
    extends: script$Y,
    props: { step: { type: Number, default: 5 } },
    style: ScrollPanelStyle,
    provide: __name(function () {
      return { $pcScrollPanel: this, $parentInstance: this }
    }, 'provide')
  },
  script$F = {
    name: 'ScrollPanel',
    extends: script$1$p,
    inheritAttrs: !1,
    initialized: !1,
    documentResizeListener: null,
    documentMouseMoveListener: null,
    documentMouseUpListener: null,
    frame: null,
    scrollXRatio: null,
    scrollYRatio: null,
    isXBarClicked: !1,
    isYBarClicked: !1,
    lastPageX: null,
    lastPageY: null,
    timer: null,
    outsideClickListener: null,
    data: __name(function () {
      return {
        id: this.$attrs.id,
        orientation: 'vertical',
        lastScrollTop: 0,
        lastScrollLeft: 0
      }
    }, 'data'),
    watch: {
      '$attrs.id': __name(function (e) {
        this.id = e || UniqueComponentId()
      }, '$attrsId')
    },
    mounted: __name(function () {
      ;(this.id = this.id || UniqueComponentId()),
        this.$el.offsetParent && this.initialize()
    }, 'mounted'),
    updated: __name(function () {
      !this.initialized && this.$el.offsetParent && this.initialize()
    }, 'updated'),
    beforeUnmount: __name(function () {
      this.unbindDocumentResizeListener(),
        this.frame && window.cancelAnimationFrame(this.frame)
    }, 'beforeUnmount'),
    methods: {
      initialize: __name(function () {
        this.moveBar(),
          this.bindDocumentResizeListener(),
          this.calculateContainerHeight()
      }, 'initialize'),
      calculateContainerHeight: __name(function () {
        var e = getComputedStyle(this.$el),
          t = getComputedStyle(this.$refs.xBar),
          n = getHeight(this.$el) - parseInt(t.height, 10)
        'none' !== e['max-height'] &&
          0 === n &&
          (this.$refs.content.offsetHeight + parseInt(t.height, 10) >
          parseInt(e['max-height'], 10)
            ? (this.$el.style.height = e['max-height'])
            : (this.$el.style.height =
                this.$refs.content.offsetHeight +
                parseFloat(e.paddingTop) +
                parseFloat(e.paddingBottom) +
                parseFloat(e.borderTopWidth) +
                parseFloat(e.borderBottomWidth) +
                'px'))
      }, 'calculateContainerHeight'),
      moveBar: __name(function () {
        var e = this
        if (this.$refs.content) {
          var t = this.$refs.content.scrollWidth,
            n = this.$refs.content.clientWidth,
            o = -1 * (this.$el.clientHeight - this.$refs.xBar.clientHeight)
          this.scrollXRatio = n / t
          var i = this.$refs.content.scrollHeight,
            r = this.$refs.content.clientHeight,
            a = -1 * (this.$el.clientWidth - this.$refs.yBar.clientWidth)
          ;(this.scrollYRatio = r / i),
            (this.frame = this.requestAnimationFrame(function () {
              e.$refs.xBar &&
                (e.scrollXRatio >= 1
                  ? (e.$refs.xBar.setAttribute(
                      'data-p-scrollpanel-hidden',
                      'true'
                    ),
                    !e.isUnstyled &&
                      addClass(e.$refs.xBar, 'p-scrollpanel-hidden'))
                  : (e.$refs.xBar.setAttribute(
                      'data-p-scrollpanel-hidden',
                      'false'
                    ),
                    !e.isUnstyled &&
                      removeClass(e.$refs.xBar, 'p-scrollpanel-hidden'),
                    (e.$refs.xBar.style.cssText =
                      'width:' +
                      Math.max(100 * e.scrollXRatio, 10) +
                      '%; inset-inline-start:' +
                      (Math.abs(e.$refs.content.scrollLeft) / t) * 100 +
                      '%;bottom:' +
                      o +
                      'px;'))),
                e.$refs.yBar &&
                  (e.scrollYRatio >= 1
                    ? (e.$refs.yBar.setAttribute(
                        'data-p-scrollpanel-hidden',
                        'true'
                      ),
                      !e.isUnstyled &&
                        addClass(e.$refs.yBar, 'p-scrollpanel-hidden'))
                    : (e.$refs.yBar.setAttribute(
                        'data-p-scrollpanel-hidden',
                        'false'
                      ),
                      !e.isUnstyled &&
                        removeClass(e.$refs.yBar, 'p-scrollpanel-hidden'),
                      (e.$refs.yBar.style.cssText =
                        'height:' +
                        Math.max(100 * e.scrollYRatio, 10) +
                        '%; top: calc(' +
                        (e.$refs.content.scrollTop / i) * 100 +
                        '% - ' +
                        e.$refs.xBar.clientHeight +
                        'px); inset-inline-end:' +
                        a +
                        'px;')))
            }))
        }
      }, 'moveBar'),
      onYBarMouseDown: __name(function (e) {
        ;(this.isYBarClicked = !0),
          this.$refs.yBar.focus(),
          (this.lastPageY = e.pageY),
          this.$refs.yBar.setAttribute('data-p-scrollpanel-grabbed', 'true'),
          !this.isUnstyled &&
            addClass(this.$refs.yBar, 'p-scrollpanel-grabbed'),
          document.body.setAttribute('data-p-scrollpanel-grabbed', 'true'),
          !this.isUnstyled && addClass(document.body, 'p-scrollpanel-grabbed'),
          this.bindDocumentMouseListeners(),
          e.preventDefault()
      }, 'onYBarMouseDown'),
      onXBarMouseDown: __name(function (e) {
        ;(this.isXBarClicked = !0),
          this.$refs.xBar.focus(),
          (this.lastPageX = e.pageX),
          this.$refs.yBar.setAttribute('data-p-scrollpanel-grabbed', 'false'),
          !this.isUnstyled &&
            addClass(this.$refs.xBar, 'p-scrollpanel-grabbed'),
          document.body.setAttribute('data-p-scrollpanel-grabbed', 'false'),
          !this.isUnstyled && addClass(document.body, 'p-scrollpanel-grabbed'),
          this.bindDocumentMouseListeners(),
          e.preventDefault()
      }, 'onXBarMouseDown'),
      onScroll: __name(function (e) {
        this.lastScrollLeft !== e.target.scrollLeft
          ? ((this.lastScrollLeft = e.target.scrollLeft),
            (this.orientation = 'horizontal'))
          : this.lastScrollTop !== e.target.scrollTop &&
            ((this.lastScrollTop = e.target.scrollTop),
            (this.orientation = 'vertical')),
          this.moveBar()
      }, 'onScroll'),
      onKeyDown: __name(function (e) {
        if ('vertical' === this.orientation)
          switch (e.code) {
            case 'ArrowDown':
              this.setTimer('scrollTop', this.step), e.preventDefault()
              break
            case 'ArrowUp':
              this.setTimer('scrollTop', -1 * this.step), e.preventDefault()
              break
            case 'ArrowLeft':
            case 'ArrowRight':
              e.preventDefault()
          }
        else if ('horizontal' === this.orientation)
          switch (e.code) {
            case 'ArrowRight':
              this.setTimer('scrollLeft', this.step), e.preventDefault()
              break
            case 'ArrowLeft':
              this.setTimer('scrollLeft', -1 * this.step), e.preventDefault()
              break
            case 'ArrowDown':
            case 'ArrowUp':
              e.preventDefault()
          }
      }, 'onKeyDown'),
      onKeyUp: __name(function () {
        this.clearTimer()
      }, 'onKeyUp'),
      repeat: __name(function (e, t) {
        ;(this.$refs.content[e] += t), this.moveBar()
      }, 'repeat'),
      setTimer: __name(function (e, t) {
        var n = this
        this.clearTimer(),
          (this.timer = setTimeout(function () {
            n.repeat(e, t)
          }, 40))
      }, 'setTimer'),
      clearTimer: __name(function () {
        this.timer && clearTimeout(this.timer)
      }, 'clearTimer'),
      onDocumentMouseMove: __name(function (e) {
        this.isXBarClicked
          ? this.onMouseMoveForXBar(e)
          : (this.isYBarClicked || this.onMouseMoveForXBar(e),
            this.onMouseMoveForYBar(e))
      }, 'onDocumentMouseMove'),
      onMouseMoveForXBar: __name(function (e) {
        var t = this,
          n = e.pageX - this.lastPageX
        ;(this.lastPageX = e.pageX),
          (this.frame = this.requestAnimationFrame(function () {
            t.$refs.content.scrollLeft += n / t.scrollXRatio
          }))
      }, 'onMouseMoveForXBar'),
      onMouseMoveForYBar: __name(function (e) {
        var t = this,
          n = e.pageY - this.lastPageY
        ;(this.lastPageY = e.pageY),
          (this.frame = this.requestAnimationFrame(function () {
            t.$refs.content.scrollTop += n / t.scrollYRatio
          }))
      }, 'onMouseMoveForYBar'),
      onFocus: __name(function (e) {
        this.$refs.xBar.isSameNode(e.target)
          ? (this.orientation = 'horizontal')
          : this.$refs.yBar.isSameNode(e.target) &&
            (this.orientation = 'vertical')
      }, 'onFocus'),
      onBlur: __name(function () {
        'horizontal' === this.orientation && (this.orientation = 'vertical')
      }, 'onBlur'),
      onDocumentMouseUp: __name(function () {
        this.$refs.yBar.setAttribute('data-p-scrollpanel-grabbed', 'false'),
          !this.isUnstyled &&
            removeClass(this.$refs.yBar, 'p-scrollpanel-grabbed'),
          this.$refs.xBar.setAttribute('data-p-scrollpanel-grabbed', 'false'),
          !this.isUnstyled &&
            removeClass(this.$refs.xBar, 'p-scrollpanel-grabbed'),
          document.body.setAttribute('data-p-scrollpanel-grabbed', 'false'),
          !this.isUnstyled &&
            removeClass(document.body, 'p-scrollpanel-grabbed'),
          this.unbindDocumentMouseListeners(),
          (this.isXBarClicked = !1),
          (this.isYBarClicked = !1)
      }, 'onDocumentMouseUp'),
      requestAnimationFrame: __name(function (e) {
        return (window.requestAnimationFrame || this.timeoutFrame)(e)
      }, 'requestAnimationFrame'),
      refresh: __name(function () {
        this.moveBar()
      }, 'refresh'),
      scrollTop: __name(function (e) {
        var t =
          this.$refs.content.scrollHeight - this.$refs.content.clientHeight
        ;(e = e > t ? t : e > 0 ? e : 0), (this.$refs.content.scrollTop = e)
      }, 'scrollTop'),
      timeoutFrame: __name(function (e) {
        setTimeout(e, 0)
      }, 'timeoutFrame'),
      bindDocumentMouseListeners: __name(function () {
        var e = this
        this.documentMouseMoveListener ||
          ((this.documentMouseMoveListener = function (t) {
            e.onDocumentMouseMove(t)
          }),
          document.addEventListener(
            'mousemove',
            this.documentMouseMoveListener
          )),
          this.documentMouseUpListener ||
            ((this.documentMouseUpListener = function (t) {
              e.onDocumentMouseUp(t)
            }),
            document.addEventListener('mouseup', this.documentMouseUpListener))
      }, 'bindDocumentMouseListeners'),
      unbindDocumentMouseListeners: __name(function () {
        this.documentMouseMoveListener &&
          (document.removeEventListener(
            'mousemove',
            this.documentMouseMoveListener
          ),
          (this.documentMouseMoveListener = null)),
          this.documentMouseUpListener &&
            (document.removeEventListener(
              'mouseup',
              this.documentMouseUpListener
            ),
            (this.documentMouseUpListener = null))
      }, 'unbindDocumentMouseListeners'),
      bindDocumentResizeListener: __name(function () {
        var e = this
        this.documentResizeListener ||
          ((this.documentResizeListener = function () {
            e.moveBar()
          }),
          window.addEventListener('resize', this.documentResizeListener))
      }, 'bindDocumentResizeListener'),
      unbindDocumentResizeListener: __name(function () {
        this.documentResizeListener &&
          (window.removeEventListener('resize', this.documentResizeListener),
          (this.documentResizeListener = null))
      }, 'unbindDocumentResizeListener')
    },
    computed: {
      contentId: __name(function () {
        return this.id + '_content'
      }, 'contentId')
    }
  },
  _hoisted_1$W = ['id'],
  _hoisted_2$z = ['aria-controls', 'aria-valuenow'],
  _hoisted_3$m = ['aria-controls', 'aria-valuenow']
function render$E(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps({ class: e.cx('root') }, e.ptmi('root')),
      [
        Vue.createElementVNode(
          'div',
          Vue.mergeProps(
            { class: e.cx('contentContainer') },
            e.ptm('contentContainer')
          ),
          [
            Vue.createElementVNode(
              'div',
              Vue.mergeProps(
                {
                  ref: 'content',
                  id: r.contentId,
                  class: e.cx('content'),
                  onScroll:
                    t[0] ||
                    (t[0] = function () {
                      return r.onScroll && r.onScroll.apply(r, arguments)
                    }),
                  onMouseenter:
                    t[1] ||
                    (t[1] = function () {
                      return r.moveBar && r.moveBar.apply(r, arguments)
                    })
                },
                e.ptm('content')
              ),
              [Vue.renderSlot(e.$slots, 'default')],
              16,
              _hoisted_1$W
            )
          ],
          16
        ),
        Vue.createElementVNode(
          'div',
          Vue.mergeProps(
            {
              ref: 'xBar',
              class: e.cx('barx'),
              tabindex: '0',
              role: 'scrollbar',
              'aria-orientation': 'horizontal',
              'aria-controls': r.contentId,
              'aria-valuenow': i.lastScrollLeft,
              onMousedown:
                t[2] ||
                (t[2] = function () {
                  return (
                    r.onXBarMouseDown && r.onXBarMouseDown.apply(r, arguments)
                  )
                }),
              onKeydown:
                t[3] ||
                (t[3] = function (e) {
                  return r.onKeyDown(e)
                }),
              onKeyup:
                t[4] ||
                (t[4] = function () {
                  return r.onKeyUp && r.onKeyUp.apply(r, arguments)
                }),
              onFocus:
                t[5] ||
                (t[5] = function () {
                  return r.onFocus && r.onFocus.apply(r, arguments)
                }),
              onBlur:
                t[6] ||
                (t[6] = function () {
                  return r.onBlur && r.onBlur.apply(r, arguments)
                })
            },
            e.ptm('barx'),
            { 'data-pc-group-section': 'bar' }
          ),
          null,
          16,
          _hoisted_2$z
        ),
        Vue.createElementVNode(
          'div',
          Vue.mergeProps(
            {
              ref: 'yBar',
              class: e.cx('bary'),
              tabindex: '0',
              role: 'scrollbar',
              'aria-orientation': 'vertical',
              'aria-controls': r.contentId,
              'aria-valuenow': i.lastScrollTop,
              onMousedown:
                t[7] ||
                (t[7] = function () {
                  return (
                    r.onYBarMouseDown && r.onYBarMouseDown.apply(r, arguments)
                  )
                }),
              onKeydown:
                t[8] ||
                (t[8] = function (e) {
                  return r.onKeyDown(e)
                }),
              onKeyup:
                t[9] ||
                (t[9] = function () {
                  return r.onKeyUp && r.onKeyUp.apply(r, arguments)
                }),
              onFocus:
                t[10] ||
                (t[10] = function () {
                  return r.onFocus && r.onFocus.apply(r, arguments)
                })
            },
            e.ptm('bary'),
            { 'data-pc-group-section': 'bar' }
          ),
          null,
          16,
          _hoisted_3$m
        )
      ],
      16
    )
  )
}
__name(render$E, 'render$E'), (script$F.render = render$E)
var script$E = { name: 'TimesCircleIcon', extends: script$X }
function render$D(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              'fill-rule': 'evenodd',
              'clip-rule': 'evenodd',
              d: 'M7 14C5.61553 14 4.26215 13.5895 3.11101 12.8203C1.95987 12.0511 1.06266 10.9579 0.532846 9.67879C0.00303296 8.3997 -0.13559 6.99224 0.134506 5.63437C0.404603 4.2765 1.07129 3.02922 2.05026 2.05026C3.02922 1.07129 4.2765 0.404603 5.63437 0.134506C6.99224 -0.13559 8.3997 0.00303296 9.67879 0.532846C10.9579 1.06266 12.0511 1.95987 12.8203 3.11101C13.5895 4.26215 14 5.61553 14 7C14 8.85652 13.2625 10.637 11.9497 11.9497C10.637 13.2625 8.85652 14 7 14ZM7 1.16667C5.84628 1.16667 4.71846 1.50879 3.75918 2.14976C2.79989 2.79074 2.05222 3.70178 1.61071 4.76768C1.16919 5.83358 1.05367 7.00647 1.27876 8.13803C1.50384 9.26958 2.05941 10.309 2.87521 11.1248C3.69102 11.9406 4.73042 12.4962 5.86198 12.7212C6.99353 12.9463 8.16642 12.8308 9.23232 12.3893C10.2982 11.9478 11.2093 11.2001 11.8502 10.2408C12.4912 9.28154 12.8333 8.15373 12.8333 7C12.8333 5.45291 12.2188 3.96918 11.1248 2.87521C10.0308 1.78125 8.5471 1.16667 7 1.16667ZM4.66662 9.91668C4.58998 9.91704 4.51404 9.90209 4.44325 9.87271C4.37246 9.84333 4.30826 9.8001 4.2544 9.74557C4.14516 9.6362 4.0838 9.48793 4.0838 9.33335C4.0838 9.17876 4.14516 9.0305 4.2544 8.92113L6.17553 7L4.25443 5.07891C4.15139 4.96832 4.09529 4.82207 4.09796 4.67094C4.10063 4.51982 4.16185 4.37563 4.26872 4.26876C4.3756 4.16188 4.51979 4.10066 4.67091 4.09799C4.82204 4.09532 4.96829 4.15142 5.07887 4.25446L6.99997 6.17556L8.92106 4.25446C9.03164 4.15142 9.1779 4.09532 9.32903 4.09799C9.48015 4.10066 9.62434 4.16188 9.73121 4.26876C9.83809 4.37563 9.89931 4.51982 9.90198 4.67094C9.90464 4.82207 9.84855 4.96832 9.74551 5.07891L7.82441 7L9.74554 8.92113C9.85478 9.0305 9.91614 9.17876 9.91614 9.33335C9.91614 9.48793 9.85478 9.6362 9.74554 9.74557C9.69168 9.8001 9.62748 9.84333 9.55669 9.87271C9.4859 9.90209 9.40996 9.91704 9.33332 9.91668C9.25668 9.91704 9.18073 9.90209 9.10995 9.87271C9.03916 9.84333 8.97495 9.8001 8.9211 9.74557L6.99997 7.82444L5.07884 9.74557C5.02499 9.8001 4.96078 9.84333 4.88999 9.87271C4.81921 9.90209 4.74326 9.91704 4.66662 9.91668Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$D, 'render$D'), (script$E.render = render$D)
var theme$o = __name(function (e) {
    var t = e.dt
    return '\n.p-chip {\n    display: inline-flex;\n    align-items: center;\n    background: '
      .concat(t('chip.background'), ';\n    color: ')
      .concat(t('chip.color'), ';\n    border-radius: ')
      .concat(t('chip.border.radius'), ';\n    padding-block: ')
      .concat(t('chip.padding.y'), ';\n    padding-inline: ')
      .concat(t('chip.padding.x'), ';\n    gap: ')
      .concat(t('chip.gap'), ';\n}\n\n.p-chip-icon {\n    color: ')
      .concat(t('chip.icon.color'), ';\n    font-size: ')
      .concat(t('chip.icon.font.size'), ';\n    width: ')
      .concat(t('chip.icon.size'), ';\n    height: ')
      .concat(
        t('chip.icon.size'),
        ';\n}\n\n.p-chip-image {\n    border-radius: 50%;\n    width: '
      )
      .concat(t('chip.image.width'), ';\n    height: ')
      .concat(t('chip.image.height'), ';\n    margin-inline-start: calc(-1 * ')
      .concat(
        t('chip.padding.y'),
        ');\n}\n\n.p-chip:has(.p-chip-remove-icon) {\n    padding-inline-end: '
      )
      .concat(
        t('chip.padding.y'),
        ';\n}\n\n.p-chip:has(.p-chip-image) {\n    padding-block-start: calc('
      )
      .concat(t('chip.padding.y'), ' / 2);\n    padding-block-end: calc(')
      .concat(
        t('chip.padding.y'),
        ' / 2);\n}\n\n.p-chip-remove-icon {\n    cursor: pointer;\n    font-size: '
      )
      .concat(t('chip.remove.icon.size'), ';\n    width: ')
      .concat(t('chip.remove.icon.size'), ';\n    height: ')
      .concat(t('chip.remove.icon.size'), ';\n    color: ')
      .concat(
        t('chip.remove.icon.color'),
        ';\n    border-radius: 50%;\n    transition: outline-color '
      )
      .concat(t('chip.transition.duration'), ', box-shadow ')
      .concat(
        t('chip.transition.duration'),
        ';\n    outline-color: transparent;\n}\n\n.p-chip-remove-icon:focus-visible {\n    box-shadow: '
      )
      .concat(t('chip.remove.icon.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('chip.remove.icon.focus.ring.width'), ' ')
      .concat(t('chip.remove.icon.focus.ring.style'), ' ')
      .concat(t('chip.remove.icon.focus.ring.color'), ';\n    outline-offset: ')
      .concat(t('chip.remove.icon.focus.ring.offset'), ';\n}\n')
  }, 'theme'),
  classes$p = {
    root: 'p-chip p-component',
    image: 'p-chip-image',
    icon: 'p-chip-icon',
    label: 'p-chip-label',
    removeIcon: 'p-chip-remove-icon'
  },
  ChipStyle = BaseStyle.extend({
    name: 'chip',
    theme: theme$o,
    classes: classes$p
  }),
  script$1$o = {
    name: 'BaseChip',
    extends: script$Y,
    props: {
      label: { type: String, default: null },
      icon: { type: String, default: null },
      image: { type: String, default: null },
      removable: { type: Boolean, default: !1 },
      removeIcon: { type: String, default: void 0 }
    },
    style: ChipStyle,
    provide: __name(function () {
      return { $pcChip: this, $parentInstance: this }
    }, 'provide')
  },
  script$D = {
    name: 'Chip',
    extends: script$1$o,
    inheritAttrs: !1,
    emits: ['remove'],
    data: __name(function () {
      return { visible: !0 }
    }, 'data'),
    methods: {
      onKeydown: __name(function (e) {
        ;('Enter' !== e.key && 'Backspace' !== e.key) || this.close(e)
      }, 'onKeydown'),
      close: __name(function (e) {
        ;(this.visible = !1), this.$emit('remove', e)
      }, 'close')
    },
    components: { TimesCircleIcon: script$E }
  },
  _hoisted_1$V = ['aria-label'],
  _hoisted_2$y = ['src']
function render$C(e, t, n, o, i, r) {
  return i.visible
    ? (Vue.openBlock(),
      Vue.createElementBlock(
        'div',
        Vue.mergeProps(
          { key: 0, class: e.cx('root'), 'aria-label': e.label },
          e.ptmi('root')
        ),
        [
          Vue.renderSlot(e.$slots, 'default', {}, function () {
            return [
              e.image
                ? (Vue.openBlock(),
                  Vue.createElementBlock(
                    'img',
                    Vue.mergeProps({ key: 0, src: e.image }, e.ptm('image'), {
                      class: e.cx('image')
                    }),
                    null,
                    16,
                    _hoisted_2$y
                  ))
                : e.$slots.icon
                  ? (Vue.openBlock(),
                    Vue.createBlock(
                      Vue.resolveDynamicComponent(e.$slots.icon),
                      Vue.mergeProps(
                        { key: 1, class: e.cx('icon') },
                        e.ptm('icon')
                      ),
                      null,
                      16,
                      ['class']
                    ))
                  : e.icon
                    ? (Vue.openBlock(),
                      Vue.createElementBlock(
                        'span',
                        Vue.mergeProps(
                          { key: 2, class: [e.cx('icon'), e.icon] },
                          e.ptm('icon')
                        ),
                        null,
                        16
                      ))
                    : Vue.createCommentVNode('', !0),
              e.label
                ? (Vue.openBlock(),
                  Vue.createElementBlock(
                    'div',
                    Vue.mergeProps(
                      { key: 3, class: e.cx('label') },
                      e.ptm('label')
                    ),
                    Vue.toDisplayString(e.label),
                    17
                  ))
                : Vue.createCommentVNode('', !0)
            ]
          }),
          e.removable
            ? Vue.renderSlot(
                e.$slots,
                'removeicon',
                {
                  key: 0,
                  removeCallback: r.close,
                  keydownCallback: r.onKeydown
                },
                function () {
                  return [
                    (Vue.openBlock(),
                    Vue.createBlock(
                      Vue.resolveDynamicComponent(
                        e.removeIcon ? 'span' : 'TimesCircleIcon'
                      ),
                      Vue.mergeProps(
                        {
                          class: [e.cx('removeIcon'), e.removeIcon],
                          onClick: r.close,
                          onKeydown: r.onKeydown
                        },
                        e.ptm('removeIcon')
                      ),
                      null,
                      16,
                      ['class', 'onClick', 'onKeydown']
                    ))
                  ]
                }
              )
            : Vue.createCommentVNode('', !0)
        ],
        16,
        _hoisted_1$V
      ))
    : Vue.createCommentVNode('', !0)
}
__name(render$C, 'render$C'), (script$D.render = render$C)
const _sfc_main$Q = Vue.defineComponent({
    __name: 'SearchFilterChip',
    props: { text: {}, badge: {}, badgeClass: {} },
    emits: ['remove'],
    setup: (e) => (e, t) => (
      Vue.openBlock(),
      Vue.createBlock(
        Vue.unref(script$D),
        {
          removable: '',
          onRemove: t[0] || (t[0] = (t) => e.$emit('remove', t))
        },
        {
          default: Vue.withCtx(() => [
            Vue.createVNode(
              Vue.unref(script$L),
              { size: 'small', class: Vue.normalizeClass(e.badgeClass) },
              {
                default: Vue.withCtx(() => [
                  Vue.createTextVNode(Vue.toDisplayString(e.badge), 1)
                ]),
                _: 1
              },
              8,
              ['class']
            ),
            Vue.createTextVNode(' ' + Vue.toDisplayString(e.text), 1)
          ]),
          _: 1
        }
      )
    )
  }),
  SearchFilterChip = _export_sfc(_sfc_main$Q, [
    ['__scopeId', 'data-v-a4c03005']
  ]),
  _hoisted_1$U = { key: 0, class: 'search-filters pt-2 flex flex-wrap gap-2' },
  _sfc_main$P = Vue.defineComponent({
    __name: 'SearchBox',
    props: {
      class: {},
      modelValue: {},
      placeholder: { default: 'Search...' },
      icon: { default: 'pi pi-search' },
      debounceTime: { default: 300 },
      filterIcon: {},
      filters: {}
    },
    emits: ['update:modelValue', 'search', 'showFilter', 'removeFilter'],
    setup(e, { emit: t }) {
      const n = e,
        { filters: o } = Vue.toRefs(n),
        i = t,
        r = _.debounce((e) => {
          i('search', e, n.filters)
        }, n.debounceTime),
        a = __name((e) => {
          const t = e.target
          i('update:modelValue', t.value), r(t.value)
        }, 'handleInput')
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock(
          'div',
          { class: Vue.normalizeClass(n.class) },
          [
            Vue.createVNode(Vue.unref(script$T), null, {
              default: Vue.withCtx(() => [
                Vue.createVNode(
                  Vue.unref(script$S),
                  { class: Vue.normalizeClass(n.icon) },
                  null,
                  8,
                  ['class']
                ),
                Vue.createVNode(
                  Vue.unref(script$P),
                  {
                    class: Vue.normalizeClass([
                      'search-box-input',
                      { 'with-filter': n.filterIcon }
                    ]),
                    onInput: a,
                    modelValue: n.modelValue,
                    placeholder: n.placeholder
                  },
                  null,
                  8,
                  ['class', 'modelValue', 'placeholder']
                ),
                n.filterIcon
                  ? (Vue.openBlock(),
                    Vue.createBlock(
                      Vue.unref(script$K),
                      {
                        key: 0,
                        class: 'p-inputicon',
                        icon: n.filterIcon,
                        text: '',
                        severity: 'contrast',
                        onClick:
                          t[0] || (t[0] = (t) => e.$emit('showFilter', t))
                      },
                      null,
                      8,
                      ['icon']
                    ))
                  : Vue.createCommentVNode('', !0)
              ]),
              _: 1
            }),
            Vue.unref(o)?.length
              ? (Vue.openBlock(),
                Vue.createElementBlock('div', _hoisted_1$U, [
                  (Vue.openBlock(!0),
                  Vue.createElementBlock(
                    Vue.Fragment,
                    null,
                    Vue.renderList(
                      Vue.unref(o),
                      (t) => (
                        Vue.openBlock(),
                        Vue.createBlock(
                          SearchFilterChip,
                          {
                            key: t.id,
                            text: t.text,
                            badge: t.badge,
                            'badge-class': t.badgeClass,
                            onRemove: __name(
                              (n) => e.$emit('removeFilter', t),
                              'onRemove'
                            )
                          },
                          null,
                          8,
                          ['text', 'badge', 'badge-class', 'onRemove']
                        )
                      )
                    ),
                    128
                  ))
                ]))
              : Vue.createCommentVNode('', !0)
          ],
          2
        )
      )
    }
  }),
  SearchBox = _export_sfc(_sfc_main$P, [['__scopeId', 'data-v-e10998c1']])
var theme$n = __name(function (e) {
    var t = e.dt
    return '\n.p-tag {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    background: '
      .concat(t('tag.primary.background'), ';\n    color: ')
      .concat(t('tag.primary.color'), ';\n    font-size: ')
      .concat(t('tag.font.size'), ';\n    font-weight: ')
      .concat(t('tag.font.weight'), ';\n    padding: ')
      .concat(t('tag.padding'), ';\n    border-radius: ')
      .concat(t('tag.border.radius'), ';\n    gap: ')
      .concat(t('tag.gap'), ';\n}\n\n.p-tag-icon {\n    font-size: ')
      .concat(t('tag.icon.size'), ';\n    width: ')
      .concat(t('tag.icon.size'), ';\n    height:')
      .concat(
        t('tag.icon.size'),
        ';\n}\n\n.p-tag-rounded {\n    border-radius: '
      )
      .concat(
        t('tag.rounded.border.radius'),
        ';\n}\n\n.p-tag-success {\n    background: '
      )
      .concat(t('tag.success.background'), ';\n    color: ')
      .concat(t('tag.success.color'), ';\n}\n\n.p-tag-info {\n    background: ')
      .concat(t('tag.info.background'), ';\n    color: ')
      .concat(t('tag.info.color'), ';\n}\n\n.p-tag-warn {\n    background: ')
      .concat(t('tag.warn.background'), ';\n    color: ')
      .concat(t('tag.warn.color'), ';\n}\n\n.p-tag-danger {\n    background: ')
      .concat(t('tag.danger.background'), ';\n    color: ')
      .concat(
        t('tag.danger.color'),
        ';\n}\n\n.p-tag-secondary {\n    background: '
      )
      .concat(t('tag.secondary.background'), ';\n    color: ')
      .concat(
        t('tag.secondary.color'),
        ';\n}\n\n.p-tag-contrast {\n    background: '
      )
      .concat(t('tag.contrast.background'), ';\n    color: ')
      .concat(t('tag.contrast.color'), ';\n}\n')
  }, 'theme'),
  classes$o = {
    root: __name(function (e) {
      var t = e.props
      return [
        'p-tag p-component',
        {
          'p-tag-info': 'info' === t.severity,
          'p-tag-success': 'success' === t.severity,
          'p-tag-warn': 'warn' === t.severity,
          'p-tag-danger': 'danger' === t.severity,
          'p-tag-secondary': 'secondary' === t.severity,
          'p-tag-contrast': 'contrast' === t.severity,
          'p-tag-rounded': t.rounded
        }
      ]
    }, 'root'),
    icon: 'p-tag-icon',
    label: 'p-tag-label'
  },
  TagStyle = BaseStyle.extend({
    name: 'tag',
    theme: theme$n,
    classes: classes$o
  }),
  script$1$n = {
    name: 'BaseTag',
    extends: script$Y,
    props: { value: null, severity: null, rounded: Boolean, icon: String },
    style: TagStyle,
    provide: __name(function () {
      return { $pcTag: this, $parentInstance: this }
    }, 'provide')
  },
  script$C = { name: 'Tag', extends: script$1$n, inheritAttrs: !1 }
function render$B(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'span',
      Vue.mergeProps({ class: e.cx('root') }, e.ptmi('root')),
      [
        e.$slots.icon
          ? (Vue.openBlock(),
            Vue.createBlock(
              Vue.resolveDynamicComponent(e.$slots.icon),
              Vue.mergeProps({ key: 0, class: e.cx('icon') }, e.ptm('icon')),
              null,
              16,
              ['class']
            ))
          : e.icon
            ? (Vue.openBlock(),
              Vue.createElementBlock(
                'span',
                Vue.mergeProps(
                  { key: 1, class: [e.cx('icon'), e.icon] },
                  e.ptm('icon')
                ),
                null,
                16
              ))
            : Vue.createCommentVNode('', !0),
        null != e.value || e.$slots.default
          ? Vue.renderSlot(e.$slots, 'default', { key: 2 }, function () {
              return [
                Vue.createElementVNode(
                  'span',
                  Vue.mergeProps({ class: e.cx('label') }, e.ptm('label')),
                  Vue.toDisplayString(e.value),
                  17
                )
              ]
            })
          : Vue.createCommentVNode('', !0)
      ],
      16
    )
  )
}
__name(render$B, 'render$B'), (script$C.render = render$B)
var script$B = { name: 'AngleDownIcon', extends: script$X }
function render$A(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              d: 'M3.58659 4.5007C3.68513 4.50023 3.78277 4.51945 3.87379 4.55723C3.9648 4.59501 4.04735 4.65058 4.11659 4.7207L7.11659 7.7207L10.1166 4.7207C10.2619 4.65055 10.4259 4.62911 10.5843 4.65956C10.7427 4.69002 10.8871 4.77074 10.996 4.88976C11.1049 5.00877 11.1726 5.15973 11.1889 5.32022C11.2052 5.48072 11.1693 5.6422 11.0866 5.7807L7.58659 9.2807C7.44597 9.42115 7.25534 9.50004 7.05659 9.50004C6.85784 9.50004 6.66722 9.42115 6.52659 9.2807L3.02659 5.7807C2.88614 5.64007 2.80725 5.44945 2.80725 5.2507C2.80725 5.05195 2.88614 4.86132 3.02659 4.7207C3.09932 4.64685 3.18675 4.58911 3.28322 4.55121C3.37969 4.51331 3.48305 4.4961 3.58659 4.5007Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$A, 'render$A'), (script$B.render = render$A)
var script$A = { name: 'AngleUpIcon', extends: script$X }
function render$z(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              d: 'M10.4134 9.49931C10.3148 9.49977 10.2172 9.48055 10.1262 9.44278C10.0352 9.405 9.95263 9.34942 9.88338 9.27931L6.88338 6.27931L3.88338 9.27931C3.73811 9.34946 3.57409 9.3709 3.41567 9.34044C3.25724 9.30999 3.11286 9.22926 3.00395 9.11025C2.89504 8.99124 2.82741 8.84028 2.8111 8.67978C2.79478 8.51928 2.83065 8.35781 2.91338 8.21931L6.41338 4.71931C6.55401 4.57886 6.74463 4.49997 6.94338 4.49997C7.14213 4.49997 7.33276 4.57886 7.47338 4.71931L10.9734 8.21931C11.1138 8.35994 11.1927 8.55056 11.1927 8.74931C11.1927 8.94806 11.1138 9.13868 10.9734 9.27931C10.9007 9.35315 10.8132 9.41089 10.7168 9.44879C10.6203 9.48669 10.5169 9.5039 10.4134 9.49931Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$z, 'render$z'), (script$A.render = render$z)
var theme$m = __name(function (e) {
    var t = e.dt
    return '\n.p-inputnumber {\n    display: inline-flex;\n    position: relative;\n}\n\n.p-inputnumber-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex: 0 0 auto;\n    cursor: pointer;\n    background: '
      .concat(t('inputnumber.button.background'), ';\n    color: ')
      .concat(t('inputnumber.button.color'), ';\n    width: ')
      .concat(t('inputnumber.button.width'), ';\n    transition: background ')
      .concat(t('inputnumber.transition.duration'), ', color ')
      .concat(t('inputnumber.transition.duration'), ', border-color ')
      .concat(t('inputnumber.transition.duration'), ', outline-color ')
      .concat(
        t('inputnumber.transition.duration'),
        ';\n}\n\n.p-inputnumber-button:hover {\n    background: '
      )
      .concat(t('inputnumber.button.hover.background'), ';\n    color: ')
      .concat(
        t('inputnumber.button.hover.color'),
        ';\n}\n\n.p-inputnumber-button:active {\n    background: '
      )
      .concat(t('inputnumber.button.active.background'), ';\n    color: ')
      .concat(
        t('inputnumber.button.active.color'),
        ';\n}\n\n.p-inputnumber-stacked .p-inputnumber-button {\n    position: relative;\n    border: 0 none;\n}\n\n.p-inputnumber-stacked .p-inputnumber-button-group {\n    display: flex;\n    flex-direction: column;\n    position: absolute;\n    inset-block-start: 1px;\n    inset-inline-end: 1px;\n    height: calc(100% - 2px);\n    z-index: 1;\n}\n\n.p-inputnumber-stacked .p-inputnumber-increment-button {\n    padding: 0;\n    border-start-end-radius: calc('
      )
      .concat(
        t('inputnumber.button.border.radius'),
        ' - 1px);\n}\n\n.p-inputnumber-stacked .p-inputnumber-decrement-button {\n    padding: 0;\n    border-end-end-radius: calc('
      )
      .concat(
        t('inputnumber.button.border.radius'),
        ' - 1px);\n}\n\n.p-inputnumber-stacked .p-inputnumber-button {\n    flex: 1 1 auto;\n    border: 0 none;\n}\n\n.p-inputnumber-horizontal .p-inputnumber-button {\n    border: 1px solid '
      )
      .concat(
        t('inputnumber.button.border.color'),
        ';\n}\n\n.p-inputnumber-horizontal .p-inputnumber-button:hover {\n    border-color: '
      )
      .concat(
        t('inputnumber.button.hover.border.color'),
        ';\n}\n\n.p-inputnumber-horizontal .p-inputnumber-button:active {\n    border-color: '
      )
      .concat(
        t('inputnumber.button.active.border.color'),
        ';\n}\n\n.p-inputnumber-horizontal .p-inputnumber-increment-button {\n    order: 3;\n    border-start-end-radius: '
      )
      .concat(
        t('inputnumber.button.border.radius'),
        ';\n    border-end-end-radius: '
      )
      .concat(
        t('inputnumber.button.border.radius'),
        ';\n    border-inline-start: 0 none;\n}\n\n.p-inputnumber-horizontal .p-inputnumber-input {\n    order: 2;\n    border-radius: 0;\n}\n\n.p-inputnumber-horizontal .p-inputnumber-decrement-button {\n    order: 1;\n    border-start-start-radius: '
      )
      .concat(
        t('inputnumber.button.border.radius'),
        ';\n    border-end-start-radius: '
      )
      .concat(
        t('inputnumber.button.border.radius'),
        ';\n    border-inline-end: 0 none;\n}\n\n.p-floatlabel:has(.p-inputnumber-horizontal) label {\n    margin-inline-start: '
      )
      .concat(
        t('inputnumber.button.width'),
        ';\n}\n\n.p-inputnumber-vertical {\n    flex-direction: column;\n}\n\n.p-inputnumber-vertical .p-inputnumber-button {\n    border: 1px solid '
      )
      .concat(t('inputnumber.button.border.color'), ';\n    padding: ')
      .concat(
        t('inputnumber.button.vertical.padding'),
        ';\n}\n\n.p-inputnumber-vertical .p-inputnumber-button:hover {\n    border-color: '
      )
      .concat(
        t('inputnumber.button.hover.border.color'),
        ';\n}\n\n.p-inputnumber-vertical .p-inputnumber-button:active {\n    border-color: '
      )
      .concat(
        t('inputnumber.button.active.border.color'),
        ';\n}\n\n.p-inputnumber-vertical .p-inputnumber-increment-button {\n    order: 1;\n    border-start-start-radius: '
      )
      .concat(
        t('inputnumber.button.border.radius'),
        ';\n    border-start-end-radius: '
      )
      .concat(
        t('inputnumber.button.border.radius'),
        ';\n    width: 100%;\n    border-block-end: 0 none;\n}\n\n.p-inputnumber-vertical .p-inputnumber-input {\n    order: 2;\n    border-radius: 0;\n    text-align: center;\n}\n\n.p-inputnumber-vertical .p-inputnumber-decrement-button {\n    order: 3;\n    border-end-start-radius: '
      )
      .concat(
        t('inputnumber.button.border.radius'),
        ';\n    border-end-end-radius: '
      )
      .concat(
        t('inputnumber.button.border.radius'),
        ';\n    width: 100%;\n    border-block-start: 0 none;\n}\n\n.p-inputnumber-input {\n    flex: 1 1 auto;\n}\n\n.p-inputnumber-fluid {\n    width: 100%;\n}\n\n.p-inputnumber-fluid .p-inputnumber-input {\n    width: 1%;\n}\n\n.p-inputnumber-fluid.p-inputnumber-vertical .p-inputnumber-input {\n    width: 100%;\n}\n\n.p-inputnumber:has(.p-inputtext-sm) .p-inputnumber-button .p-icon {\n    font-size: '
      )
      .concat(t('form.field.sm.font.size'), ';\n    width: ')
      .concat(t('form.field.sm.font.size'), ';\n    height: ')
      .concat(
        t('form.field.sm.font.size'),
        ';\n}\n\n.p-inputnumber:has(.p-inputtext-lg) .p-inputnumber-button .p-icon {\n    font-size: '
      )
      .concat(t('form.field.lg.font.size'), ';\n    width: ')
      .concat(t('form.field.lg.font.size'), ';\n    height: ')
      .concat(t('form.field.lg.font.size'), ';\n}\n')
  }, 'theme'),
  classes$n = {
    root: __name(function (e) {
      var t = e.instance,
        n = e.props
      return [
        'p-inputnumber p-component p-inputwrapper',
        {
          'p-inputwrapper-filled': t.$filled || !1 === n.allowEmpty,
          'p-inputwrapper-focus': t.focused,
          'p-inputnumber-stacked':
            n.showButtons && 'stacked' === n.buttonLayout,
          'p-inputnumber-horizontal':
            n.showButtons && 'horizontal' === n.buttonLayout,
          'p-inputnumber-vertical':
            n.showButtons && 'vertical' === n.buttonLayout,
          'p-inputnumber-fluid': t.$fluid
        }
      ]
    }, 'root'),
    pcInputText: 'p-inputnumber-input',
    buttonGroup: 'p-inputnumber-button-group',
    incrementButton: __name(function (e) {
      var t = e.instance,
        n = e.props
      return [
        'p-inputnumber-button p-inputnumber-increment-button',
        { 'p-disabled': n.showButtons && null !== n.max && t.maxBoundry() }
      ]
    }, 'incrementButton'),
    decrementButton: __name(function (e) {
      var t = e.instance,
        n = e.props
      return [
        'p-inputnumber-button p-inputnumber-decrement-button',
        { 'p-disabled': n.showButtons && null !== n.min && t.minBoundry() }
      ]
    }, 'decrementButton')
  },
  InputNumberStyle = BaseStyle.extend({
    name: 'inputnumber',
    theme: theme$m,
    classes: classes$n
  }),
  script$1$m = {
    name: 'BaseInputNumber',
    extends: script$Q,
    props: {
      format: { type: Boolean, default: !0 },
      showButtons: { type: Boolean, default: !1 },
      buttonLayout: { type: String, default: 'stacked' },
      incrementButtonClass: { type: String, default: null },
      decrementButtonClass: { type: String, default: null },
      incrementButtonIcon: { type: String, default: void 0 },
      incrementIcon: { type: String, default: void 0 },
      decrementButtonIcon: { type: String, default: void 0 },
      decrementIcon: { type: String, default: void 0 },
      locale: { type: String, default: void 0 },
      localeMatcher: { type: String, default: void 0 },
      mode: { type: String, default: 'decimal' },
      prefix: { type: String, default: null },
      suffix: { type: String, default: null },
      currency: { type: String, default: void 0 },
      currencyDisplay: { type: String, default: void 0 },
      useGrouping: { type: Boolean, default: !0 },
      minFractionDigits: { type: Number, default: void 0 },
      maxFractionDigits: { type: Number, default: void 0 },
      roundingMode: {
        type: String,
        default: 'halfExpand',
        validator: __name(function (e) {
          return [
            'ceil',
            'floor',
            'expand',
            'trunc',
            'halfCeil',
            'halfFloor',
            'halfExpand',
            'halfTrunc',
            'halfEven'
          ].includes(e)
        }, 'validator')
      },
      min: { type: Number, default: null },
      max: { type: Number, default: null },
      step: { type: Number, default: 1 },
      allowEmpty: { type: Boolean, default: !0 },
      highlightOnFocus: { type: Boolean, default: !1 },
      readonly: { type: Boolean, default: !1 },
      placeholder: { type: String, default: null },
      inputId: { type: String, default: null },
      inputClass: { type: [String, Object], default: null },
      inputStyle: { type: Object, default: null },
      ariaLabelledby: { type: String, default: null },
      ariaLabel: { type: String, default: null }
    },
    style: InputNumberStyle,
    provide: __name(function () {
      return { $pcInputNumber: this, $parentInstance: this }
    }, 'provide')
  }
function _typeof$c(e) {
  return (_typeof$c =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$e(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$e(Object(n), !0).forEach(function (t) {
          _defineProperty$c(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$e(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$c(e, t, n) {
  return (
    (t = _toPropertyKey$b(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$b(e) {
  var t = _toPrimitive$b(e, 'string')
  return 'symbol' == _typeof$c(t) ? t : t + ''
}
function _toPrimitive$b(e, t) {
  if ('object' != _typeof$c(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$c(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
function _toConsumableArray$8(e) {
  return (
    _arrayWithoutHoles$8(e) ||
    _iterableToArray$8(e) ||
    _unsupportedIterableToArray$b(e) ||
    _nonIterableSpread$8()
  )
}
function _nonIterableSpread$8() {
  throw new TypeError(
    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$b(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$b(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$b(e, t)
          : void 0
    )
  }
}
function _iterableToArray$8(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _arrayWithoutHoles$8(e) {
  if (Array.isArray(e)) return _arrayLikeToArray$b(e)
}
function _arrayLikeToArray$b(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
__name(_typeof$c, '_typeof$c'),
  __name(ownKeys$e, 'ownKeys$e'),
  __name(_objectSpread$e, '_objectSpread$e'),
  __name(_defineProperty$c, '_defineProperty$c'),
  __name(_toPropertyKey$b, '_toPropertyKey$b'),
  __name(_toPrimitive$b, '_toPrimitive$b'),
  __name(_toConsumableArray$8, '_toConsumableArray$8'),
  __name(_nonIterableSpread$8, '_nonIterableSpread$8'),
  __name(_unsupportedIterableToArray$b, '_unsupportedIterableToArray$b'),
  __name(_iterableToArray$8, '_iterableToArray$8'),
  __name(_arrayWithoutHoles$8, '_arrayWithoutHoles$8'),
  __name(_arrayLikeToArray$b, '_arrayLikeToArray$b')
var script$z = {
    name: 'InputNumber',
    extends: script$1$m,
    inheritAttrs: !1,
    emits: ['input', 'focus', 'blur'],
    inject: { $pcFluid: { default: null } },
    numberFormat: null,
    _numeral: null,
    _decimal: null,
    _group: null,
    _minusSign: null,
    _currency: null,
    _suffix: null,
    _prefix: null,
    _index: null,
    groupChar: '',
    isSpecialChar: null,
    prefixChar: null,
    suffixChar: null,
    timer: null,
    data: __name(function () {
      return { d_modelValue: this.d_value, focused: !1 }
    }, 'data'),
    watch: {
      d_value: __name(function (e) {
        this.d_modelValue = e
      }, 'd_value'),
      locale: __name(function (e, t) {
        this.updateConstructParser(e, t)
      }, 'locale'),
      localeMatcher: __name(function (e, t) {
        this.updateConstructParser(e, t)
      }, 'localeMatcher'),
      mode: __name(function (e, t) {
        this.updateConstructParser(e, t)
      }, 'mode'),
      currency: __name(function (e, t) {
        this.updateConstructParser(e, t)
      }, 'currency'),
      currencyDisplay: __name(function (e, t) {
        this.updateConstructParser(e, t)
      }, 'currencyDisplay'),
      useGrouping: __name(function (e, t) {
        this.updateConstructParser(e, t)
      }, 'useGrouping'),
      minFractionDigits: __name(function (e, t) {
        this.updateConstructParser(e, t)
      }, 'minFractionDigits'),
      maxFractionDigits: __name(function (e, t) {
        this.updateConstructParser(e, t)
      }, 'maxFractionDigits'),
      suffix: __name(function (e, t) {
        this.updateConstructParser(e, t)
      }, 'suffix'),
      prefix: __name(function (e, t) {
        this.updateConstructParser(e, t)
      }, 'prefix')
    },
    created: __name(function () {
      this.constructParser()
    }, 'created'),
    methods: {
      getOptions: __name(function () {
        return {
          localeMatcher: this.localeMatcher,
          style: this.mode,
          currency: this.currency,
          currencyDisplay: this.currencyDisplay,
          useGrouping: this.useGrouping,
          minimumFractionDigits: this.minFractionDigits,
          maximumFractionDigits: this.maxFractionDigits,
          roundingMode: this.roundingMode
        }
      }, 'getOptions'),
      constructParser: __name(function () {
        this.numberFormat = new Intl.NumberFormat(
          this.locale,
          this.getOptions()
        )
        var e = _toConsumableArray$8(
            new Intl.NumberFormat(this.locale, { useGrouping: !1 }).format(
              9876543210
            )
          ).reverse(),
          t = new Map(
            e.map(function (e, t) {
              return [e, t]
            })
          )
        ;(this._numeral = new RegExp('['.concat(e.join(''), ']'), 'g')),
          (this._group = this.getGroupingExpression()),
          (this._minusSign = this.getMinusSignExpression()),
          (this._currency = this.getCurrencyExpression()),
          (this._decimal = this.getDecimalExpression()),
          (this._suffix = this.getSuffixExpression()),
          (this._prefix = this.getPrefixExpression()),
          (this._index = function (e) {
            return t.get(e)
          })
      }, 'constructParser'),
      updateConstructParser: __name(function (e, t) {
        e !== t && this.constructParser()
      }, 'updateConstructParser'),
      escapeRegExp: __name(function (e) {
        return e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
      }, 'escapeRegExp'),
      getDecimalExpression: __name(function () {
        var e = new Intl.NumberFormat(
          this.locale,
          _objectSpread$e(
            _objectSpread$e({}, this.getOptions()),
            {},
            { useGrouping: !1 }
          )
        )
        return new RegExp(
          '['.concat(
            e
              .format(1.1)
              .replace(this._currency, '')
              .trim()
              .replace(this._numeral, ''),
            ']'
          ),
          'g'
        )
      }, 'getDecimalExpression'),
      getGroupingExpression: __name(function () {
        var e = new Intl.NumberFormat(this.locale, { useGrouping: !0 })
        return (
          (this.groupChar = e
            .format(1e6)
            .trim()
            .replace(this._numeral, '')
            .charAt(0)),
          new RegExp('['.concat(this.groupChar, ']'), 'g')
        )
      }, 'getGroupingExpression'),
      getMinusSignExpression: __name(function () {
        var e = new Intl.NumberFormat(this.locale, { useGrouping: !1 })
        return new RegExp(
          '['.concat(e.format(-1).trim().replace(this._numeral, ''), ']'),
          'g'
        )
      }, 'getMinusSignExpression'),
      getCurrencyExpression: __name(function () {
        if (this.currency) {
          var e = new Intl.NumberFormat(this.locale, {
            style: 'currency',
            currency: this.currency,
            currencyDisplay: this.currencyDisplay,
            minimumFractionDigits: 0,
            maximumFractionDigits: 0,
            roundingMode: this.roundingMode
          })
          return new RegExp(
            '['.concat(
              e
                .format(1)
                .replace(/\s/g, '')
                .replace(this._numeral, '')
                .replace(this._group, ''),
              ']'
            ),
            'g'
          )
        }
        return new RegExp('[]', 'g')
      }, 'getCurrencyExpression'),
      getPrefixExpression: __name(function () {
        if (this.prefix) this.prefixChar = this.prefix
        else {
          var e = new Intl.NumberFormat(this.locale, {
            style: this.mode,
            currency: this.currency,
            currencyDisplay: this.currencyDisplay
          })
          this.prefixChar = e.format(1).split('1')[0]
        }
        return new RegExp(
          ''.concat(this.escapeRegExp(this.prefixChar || '')),
          'g'
        )
      }, 'getPrefixExpression'),
      getSuffixExpression: __name(function () {
        if (this.suffix) this.suffixChar = this.suffix
        else {
          var e = new Intl.NumberFormat(this.locale, {
            style: this.mode,
            currency: this.currency,
            currencyDisplay: this.currencyDisplay,
            minimumFractionDigits: 0,
            maximumFractionDigits: 0,
            roundingMode: this.roundingMode
          })
          this.suffixChar = e.format(1).split('1')[1]
        }
        return new RegExp(
          ''.concat(this.escapeRegExp(this.suffixChar || '')),
          'g'
        )
      }, 'getSuffixExpression'),
      formatValue: __name(function (e) {
        if (null != e) {
          if ('-' === e) return e
          if (this.format) {
            var t = new Intl.NumberFormat(
              this.locale,
              this.getOptions()
            ).format(e)
            return (
              this.prefix && (t = this.prefix + t),
              this.suffix && (t += this.suffix),
              t
            )
          }
          return e.toString()
        }
        return ''
      }, 'formatValue'),
      parseValue: __name(function (e) {
        var t = e
          .replace(this._suffix, '')
          .replace(this._prefix, '')
          .trim()
          .replace(/\s/g, '')
          .replace(this._currency, '')
          .replace(this._group, '')
          .replace(this._minusSign, '-')
          .replace(this._decimal, '.')
          .replace(this._numeral, this._index)
        if (t) {
          if ('-' === t) return t
          var n = +t
          return isNaN(n) ? null : n
        }
        return null
      }, 'parseValue'),
      repeat: __name(function (e, t, n) {
        var o = this
        if (!this.readonly) {
          var i = t || 500
          this.clearTimer(),
            (this.timer = setTimeout(function () {
              o.repeat(e, 40, n)
            }, i)),
            this.spin(e, n)
        }
      }, 'repeat'),
      spin: __name(function (e, t) {
        if (this.$refs.input) {
          var n = this.step * t,
            o = this.parseValue(this.$refs.input.$el.value) || 0,
            i = this.validateValue(o + n)
          this.updateInput(i, null, 'spin'),
            this.updateModel(e, i),
            this.handleOnInput(e, o, i)
        }
      }, 'spin'),
      onUpButtonMouseDown: __name(function (e) {
        this.disabled ||
          (this.$refs.input.$el.focus(),
          this.repeat(e, null, 1),
          e.preventDefault())
      }, 'onUpButtonMouseDown'),
      onUpButtonMouseUp: __name(function () {
        this.disabled || this.clearTimer()
      }, 'onUpButtonMouseUp'),
      onUpButtonMouseLeave: __name(function () {
        this.disabled || this.clearTimer()
      }, 'onUpButtonMouseLeave'),
      onUpButtonKeyUp: __name(function () {
        this.disabled || this.clearTimer()
      }, 'onUpButtonKeyUp'),
      onUpButtonKeyDown: __name(function (e) {
        ;('Space' !== e.code &&
          'Enter' !== e.code &&
          'NumpadEnter' !== e.code) ||
          this.repeat(e, null, 1)
      }, 'onUpButtonKeyDown'),
      onDownButtonMouseDown: __name(function (e) {
        this.disabled ||
          (this.$refs.input.$el.focus(),
          this.repeat(e, null, -1),
          e.preventDefault())
      }, 'onDownButtonMouseDown'),
      onDownButtonMouseUp: __name(function () {
        this.disabled || this.clearTimer()
      }, 'onDownButtonMouseUp'),
      onDownButtonMouseLeave: __name(function () {
        this.disabled || this.clearTimer()
      }, 'onDownButtonMouseLeave'),
      onDownButtonKeyUp: __name(function () {
        this.disabled || this.clearTimer()
      }, 'onDownButtonKeyUp'),
      onDownButtonKeyDown: __name(function (e) {
        ;('Space' !== e.code &&
          'Enter' !== e.code &&
          'NumpadEnter' !== e.code) ||
          this.repeat(e, null, -1)
      }, 'onDownButtonKeyDown'),
      onUserInput: __name(function () {
        this.isSpecialChar && (this.$refs.input.$el.value = this.lastValue),
          (this.isSpecialChar = !1)
      }, 'onUserInput'),
      onInputKeyDown: __name(function (e) {
        if (!this.readonly) {
          if (e.altKey || e.ctrlKey || e.metaKey)
            return (
              (this.isSpecialChar = !0),
              void (this.lastValue = this.$refs.input.$el.value)
            )
          this.lastValue = e.target.value
          var t = e.target.selectionStart,
            n = e.target.selectionEnd,
            o = n - t,
            i = e.target.value,
            r = null
          switch (e.code || e.key) {
            case 'ArrowUp':
              this.spin(e, 1), e.preventDefault()
              break
            case 'ArrowDown':
              this.spin(e, -1), e.preventDefault()
              break
            case 'ArrowLeft':
              if (o > 1) {
                var a = this.isNumeralChar(i.charAt(t)) ? t + 1 : t + 2
                this.$refs.input.$el.setSelectionRange(a, a)
              } else this.isNumeralChar(i.charAt(t - 1)) || e.preventDefault()
              break
            case 'ArrowRight':
              if (o > 1) {
                var s = n - 1
                this.$refs.input.$el.setSelectionRange(s, s)
              } else this.isNumeralChar(i.charAt(t)) || e.preventDefault()
              break
            case 'Tab':
            case 'Enter':
            case 'NumpadEnter':
              ;(r = this.validateValue(this.parseValue(i))),
                (this.$refs.input.$el.value = this.formatValue(r)),
                this.$refs.input.$el.setAttribute('aria-valuenow', r),
                this.updateModel(e, r)
              break
            case 'Backspace':
              if ((e.preventDefault(), t === n)) {
                var l = i.charAt(t - 1),
                  c = this.getDecimalCharIndexes(i),
                  d = c.decimalCharIndex,
                  u = c.decimalCharIndexWithoutPrefix
                if (this.isNumeralChar(l)) {
                  var p = this.getDecimalLength(i)
                  if (this._group.test(l))
                    (this._group.lastIndex = 0),
                      (r = i.slice(0, t - 2) + i.slice(t - 1))
                  else if (this._decimal.test(l))
                    (this._decimal.lastIndex = 0),
                      p
                        ? this.$refs.input.$el.setSelectionRange(t - 1, t - 1)
                        : (r = i.slice(0, t - 1) + i.slice(t))
                  else if (d > 0 && t > d) {
                    var h =
                      this.isDecimalMode() && (this.minFractionDigits || 0) < p
                        ? ''
                        : '0'
                    r = i.slice(0, t - 1) + h + i.slice(t)
                  } else
                    1 === u
                      ? ((r = i.slice(0, t - 1) + '0' + i.slice(t)),
                        (r = this.parseValue(r) > 0 ? r : ''))
                      : (r = i.slice(0, t - 1) + i.slice(t))
                }
                this.updateValue(e, r, null, 'delete-single')
              } else
                (r = this.deleteRange(i, t, n)),
                  this.updateValue(e, r, null, 'delete-range')
              break
            case 'Delete':
              if ((e.preventDefault(), t === n)) {
                var m = i.charAt(t),
                  f = this.getDecimalCharIndexes(i),
                  _ = f.decimalCharIndex,
                  g = f.decimalCharIndexWithoutPrefix
                if (this.isNumeralChar(m)) {
                  var v = this.getDecimalLength(i)
                  if (this._group.test(m))
                    (this._group.lastIndex = 0),
                      (r = i.slice(0, t) + i.slice(t + 2))
                  else if (this._decimal.test(m))
                    (this._decimal.lastIndex = 0),
                      v
                        ? this.$refs.input.$el.setSelectionRange(t + 1, t + 1)
                        : (r = i.slice(0, t) + i.slice(t + 1))
                  else if (_ > 0 && t > _) {
                    var y =
                      this.isDecimalMode() && (this.minFractionDigits || 0) < v
                        ? ''
                        : '0'
                    r = i.slice(0, t) + y + i.slice(t + 1)
                  } else
                    1 === g
                      ? ((r = i.slice(0, t) + '0' + i.slice(t + 1)),
                        (r = this.parseValue(r) > 0 ? r : ''))
                      : (r = i.slice(0, t) + i.slice(t + 1))
                }
                this.updateValue(e, r, null, 'delete-back-single')
              } else
                (r = this.deleteRange(i, t, n)),
                  this.updateValue(e, r, null, 'delete-range')
              break
            case 'Home':
              e.preventDefault(),
                isNotEmpty(this.min) && this.updateModel(e, this.min)
              break
            case 'End':
              e.preventDefault(),
                isNotEmpty(this.max) && this.updateModel(e, this.max)
          }
        }
      }, 'onInputKeyDown'),
      onInputKeyPress: __name(function (e) {
        if (!this.readonly) {
          var t = e.key,
            n = this.isDecimalSign(t),
            o = this.isMinusSign(t)
          'Enter' !== e.code && e.preventDefault(),
            ((Number(t) >= 0 && Number(t) <= 9) || o || n) &&
              this.insert(e, t, { isDecimalSign: n, isMinusSign: o })
        }
      }, 'onInputKeyPress'),
      onPaste: __name(function (e) {
        e.preventDefault()
        var t = (e.clipboardData || window.clipboardData).getData('Text')
        if (t) {
          var n = this.parseValue(t)
          null != n && this.insert(e, n.toString())
        }
      }, 'onPaste'),
      allowMinusSign: __name(function () {
        return null === this.min || this.min < 0
      }, 'allowMinusSign'),
      isMinusSign: __name(function (e) {
        return (
          !(!this._minusSign.test(e) && '-' !== e) &&
          ((this._minusSign.lastIndex = 0), !0)
        )
      }, 'isMinusSign'),
      isDecimalSign: __name(function (e) {
        return !!this._decimal.test(e) && ((this._decimal.lastIndex = 0), !0)
      }, 'isDecimalSign'),
      isDecimalMode: __name(function () {
        return 'decimal' === this.mode
      }, 'isDecimalMode'),
      getDecimalCharIndexes: __name(function (e) {
        var t = e.search(this._decimal)
        this._decimal.lastIndex = 0
        var n = e
          .replace(this._prefix, '')
          .trim()
          .replace(/\s/g, '')
          .replace(this._currency, '')
          .search(this._decimal)
        return (
          (this._decimal.lastIndex = 0),
          { decimalCharIndex: t, decimalCharIndexWithoutPrefix: n }
        )
      }, 'getDecimalCharIndexes'),
      getCharIndexes: __name(function (e) {
        var t = e.search(this._decimal)
        this._decimal.lastIndex = 0
        var n = e.search(this._minusSign)
        this._minusSign.lastIndex = 0
        var o = e.search(this._suffix)
        this._suffix.lastIndex = 0
        var i = e.search(this._currency)
        return (
          (this._currency.lastIndex = 0),
          {
            decimalCharIndex: t,
            minusCharIndex: n,
            suffixCharIndex: o,
            currencyCharIndex: i
          }
        )
      }, 'getCharIndexes'),
      insert: __name(function (e, t) {
        var n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : { isDecimalSign: !1, isMinusSign: !1 },
          o = t.search(this._minusSign)
        if (
          ((this._minusSign.lastIndex = 0), this.allowMinusSign() || -1 === o)
        ) {
          var i,
            r = this.$refs.input.$el.selectionStart,
            a = this.$refs.input.$el.selectionEnd,
            s = this.$refs.input.$el.value.trim(),
            l = this.getCharIndexes(s),
            c = l.decimalCharIndex,
            d = l.minusCharIndex,
            u = l.suffixCharIndex,
            p = l.currencyCharIndex
          if (n.isMinusSign)
            0 === r &&
              ((i = s),
              (-1 !== d && 0 === a) || (i = this.insertText(s, t, 0, a)),
              this.updateValue(e, i, t, 'insert'))
          else if (n.isDecimalSign)
            c > 0 && r === c
              ? this.updateValue(e, s, t, 'insert')
              : ((c > r && c < a) || (-1 === c && this.maxFractionDigits)) &&
                ((i = this.insertText(s, t, r, a)),
                this.updateValue(e, i, t, 'insert'))
          else {
            var h = this.numberFormat.resolvedOptions().maximumFractionDigits,
              m = r !== a ? 'range-insert' : 'insert'
            if (c > 0 && r > c) {
              if (r + t.length - (c + 1) <= h) {
                var f = p >= r ? p - 1 : u >= r ? u : s.length
                ;(i =
                  s.slice(0, r) + t + s.slice(r + t.length, f) + s.slice(f)),
                  this.updateValue(e, i, t, m)
              }
            } else
              (i = this.insertText(s, t, r, a)), this.updateValue(e, i, t, m)
          }
        }
      }, 'insert'),
      insertText: __name(function (e, t, n, o) {
        if (2 === ('.' === t ? t : t.split('.')).length) {
          var i = e.slice(n, o).search(this._decimal)
          return (
            (this._decimal.lastIndex = 0),
            i > 0
              ? e.slice(0, n) + this.formatValue(t) + e.slice(o)
              : this.formatValue(t) || e
          )
        }
        return o - n === e.length
          ? this.formatValue(t)
          : 0 === n
            ? t + e.slice(o)
            : o === e.length
              ? e.slice(0, n) + t
              : e.slice(0, n) + t + e.slice(o)
      }, 'insertText'),
      deleteRange: __name(function (e, t, n) {
        return n - t === e.length
          ? ''
          : 0 === t
            ? e.slice(n)
            : n === e.length
              ? e.slice(0, t)
              : e.slice(0, t) + e.slice(n)
      }, 'deleteRange'),
      initCursor: __name(function () {
        var e = this.$refs.input.$el.selectionStart,
          t = this.$refs.input.$el.value,
          n = t.length,
          o = null,
          i = (this.prefixChar || '').length
        e -= i
        var r = (t = t.replace(this._prefix, '')).charAt(e)
        if (this.isNumeralChar(r)) return e + i
        for (var a = e - 1; a >= 0; ) {
          if (((r = t.charAt(a)), this.isNumeralChar(r))) {
            o = a + i
            break
          }
          a--
        }
        if (null !== o) this.$refs.input.$el.setSelectionRange(o + 1, o + 1)
        else {
          for (a = e; a < n; ) {
            if (((r = t.charAt(a)), this.isNumeralChar(r))) {
              o = a + i
              break
            }
            a++
          }
          null !== o && this.$refs.input.$el.setSelectionRange(o, o)
        }
        return o || 0
      }, 'initCursor'),
      onInputClick: __name(function () {
        var e = this.$refs.input.$el.value
        this.readonly || e === getSelection() || this.initCursor()
      }, 'onInputClick'),
      isNumeralChar: __name(function (e) {
        return (
          !(
            1 !== e.length ||
            !(
              this._numeral.test(e) ||
              this._decimal.test(e) ||
              this._group.test(e) ||
              this._minusSign.test(e)
            )
          ) && (this.resetRegex(), !0)
        )
      }, 'isNumeralChar'),
      resetRegex: __name(function () {
        ;(this._numeral.lastIndex = 0),
          (this._decimal.lastIndex = 0),
          (this._group.lastIndex = 0),
          (this._minusSign.lastIndex = 0)
      }, 'resetRegex'),
      updateValue: __name(function (e, t, n, o) {
        var i = this.$refs.input.$el.value,
          r = null
        null != t &&
          ((r = (r = this.parseValue(t)) || this.allowEmpty ? r : 0),
          this.updateInput(r, n, o, t),
          this.handleOnInput(e, i, r))
      }, 'updateValue'),
      handleOnInput: __name(function (e, t, n) {
        var o, i
        this.isValueChanged(t, n) &&
          (this.$emit('input', {
            originalEvent: e,
            value: n,
            formattedValue: t
          }),
          null === (o = (i = this.formField).onInput) ||
            void 0 === o ||
            o.call(i, { originalEvent: e, value: n }))
      }, 'handleOnInput'),
      isValueChanged: __name(function (e, t) {
        return (
          (null === t && null !== e) ||
          (null != t && t !== ('string' == typeof e ? this.parseValue(e) : e))
        )
      }, 'isValueChanged'),
      validateValue: __name(function (e) {
        return '-' === e || null == e
          ? null
          : null != this.min && e < this.min
            ? this.min
            : null != this.max && e > this.max
              ? this.max
              : e
      }, 'validateValue'),
      updateInput: __name(function (e, t, n, o) {
        t = t || ''
        var i = this.$refs.input.$el.value,
          r = this.formatValue(e),
          a = i.length
        if ((r !== o && (r = this.concatValues(r, o)), 0 === a)) {
          ;(this.$refs.input.$el.value = r),
            this.$refs.input.$el.setSelectionRange(0, 0)
          var s = this.initCursor() + t.length
          this.$refs.input.$el.setSelectionRange(s, s)
        } else {
          var l = this.$refs.input.$el.selectionStart,
            c = this.$refs.input.$el.selectionEnd
          this.$refs.input.$el.value = r
          var d = r.length
          if ('range-insert' === n) {
            var u = this.parseValue((i || '').slice(0, l)),
              p = (null !== u ? u.toString() : '')
                .split('')
                .join('('.concat(this.groupChar, ')?')),
              h = new RegExp(p, 'g')
            h.test(r)
            var m = t.split('').join('('.concat(this.groupChar, ')?')),
              f = new RegExp(m, 'g')
            f.test(r.slice(h.lastIndex)),
              (c = h.lastIndex + f.lastIndex),
              this.$refs.input.$el.setSelectionRange(c, c)
          } else if (d === a)
            'insert' === n || 'delete-back-single' === n
              ? this.$refs.input.$el.setSelectionRange(c + 1, c + 1)
              : 'delete-single' === n
                ? this.$refs.input.$el.setSelectionRange(c - 1, c - 1)
                : ('delete-range' !== n && 'spin' !== n) ||
                  this.$refs.input.$el.setSelectionRange(c, c)
          else if ('delete-back-single' === n) {
            var _ = i.charAt(c - 1),
              g = i.charAt(c),
              v = a - d,
              y = this._group.test(g)
            y && 1 === v
              ? (c += 1)
              : !y && this.isNumeralChar(_) && (c += -1 * v + 1),
              (this._group.lastIndex = 0),
              this.$refs.input.$el.setSelectionRange(c, c)
          } else if ('-' === i && 'insert' === n) {
            this.$refs.input.$el.setSelectionRange(0, 0)
            var b = this.initCursor() + t.length + 1
            this.$refs.input.$el.setSelectionRange(b, b)
          } else (c += d - a), this.$refs.input.$el.setSelectionRange(c, c)
        }
        this.$refs.input.$el.setAttribute('aria-valuenow', e)
      }, 'updateInput'),
      concatValues: __name(function (e, t) {
        if (e && t) {
          var n = t.search(this._decimal)
          return (
            (this._decimal.lastIndex = 0),
            this.suffixChar
              ? -1 !== n
                ? e.replace(this.suffixChar, '').split(this._decimal)[0] +
                  t.replace(this.suffixChar, '').slice(n) +
                  this.suffixChar
                : e
              : -1 !== n
                ? e.split(this._decimal)[0] + t.slice(n)
                : e
          )
        }
        return e
      }, 'concatValues'),
      getDecimalLength: __name(function (e) {
        if (e) {
          var t = e.split(this._decimal)
          if (2 === t.length)
            return t[1]
              .replace(this._suffix, '')
              .trim()
              .replace(/\s/g, '')
              .replace(this._currency, '').length
        }
        return 0
      }, 'getDecimalLength'),
      updateModel: __name(function (e, t) {
        this.writeValue(t, e)
      }, 'updateModel'),
      onInputFocus: __name(function (e) {
        ;(this.focused = !0),
          this.disabled ||
            this.readonly ||
            this.$refs.input.$el.value === getSelection() ||
            !this.highlightOnFocus ||
            e.target.select(),
          this.$emit('focus', e)
      }, 'onInputFocus'),
      onInputBlur: __name(function (e) {
        var t, n
        this.focused = !1
        var o = e.target,
          i = this.validateValue(this.parseValue(o.value))
        this.$emit('blur', { originalEvent: e, value: o.value }),
          null === (t = (n = this.formField).onBlur) ||
            void 0 === t ||
            t.call(n, e),
          (o.value = this.formatValue(i)),
          o.setAttribute('aria-valuenow', i),
          this.updateModel(e, i),
          this.disabled ||
            this.readonly ||
            !this.highlightOnFocus ||
            clearSelection()
      }, 'onInputBlur'),
      clearTimer: __name(function () {
        this.timer && clearInterval(this.timer)
      }, 'clearTimer'),
      maxBoundry: __name(function () {
        return this.d_value >= this.max
      }, 'maxBoundry'),
      minBoundry: __name(function () {
        return this.d_value <= this.min
      }, 'minBoundry')
    },
    computed: {
      upButtonListeners: __name(function () {
        var e = this
        return {
          mousedown: __name(function (t) {
            return e.onUpButtonMouseDown(t)
          }, 'mousedown'),
          mouseup: __name(function (t) {
            return e.onUpButtonMouseUp(t)
          }, 'mouseup'),
          mouseleave: __name(function (t) {
            return e.onUpButtonMouseLeave(t)
          }, 'mouseleave'),
          keydown: __name(function (t) {
            return e.onUpButtonKeyDown(t)
          }, 'keydown'),
          keyup: __name(function (t) {
            return e.onUpButtonKeyUp(t)
          }, 'keyup')
        }
      }, 'upButtonListeners'),
      downButtonListeners: __name(function () {
        var e = this
        return {
          mousedown: __name(function (t) {
            return e.onDownButtonMouseDown(t)
          }, 'mousedown'),
          mouseup: __name(function (t) {
            return e.onDownButtonMouseUp(t)
          }, 'mouseup'),
          mouseleave: __name(function (t) {
            return e.onDownButtonMouseLeave(t)
          }, 'mouseleave'),
          keydown: __name(function (t) {
            return e.onDownButtonKeyDown(t)
          }, 'keydown'),
          keyup: __name(function (t) {
            return e.onDownButtonKeyUp(t)
          }, 'keyup')
        }
      }, 'downButtonListeners'),
      formattedValue: __name(function () {
        var e = this.d_value || this.allowEmpty ? this.d_value : 0
        return this.formatValue(e)
      }, 'formattedValue'),
      getFormatter: __name(function () {
        return this.numberFormat
      }, 'getFormatter')
    },
    components: {
      InputText: script$P,
      AngleUpIcon: script$A,
      AngleDownIcon: script$B
    }
  },
  _hoisted_1$T = ['disabled'],
  _hoisted_2$x = ['disabled'],
  _hoisted_3$l = ['disabled'],
  _hoisted_4$c = ['disabled']
function render$y(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('InputText')
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'span',
      Vue.mergeProps({ class: e.cx('root') }, e.ptmi('root')),
      [
        Vue.createVNode(
          a,
          {
            ref: 'input',
            id: e.inputId,
            role: 'spinbutton',
            class: Vue.normalizeClass([e.cx('pcInputText'), e.inputClass]),
            style: Vue.normalizeStyle(e.inputStyle),
            value: r.formattedValue,
            'aria-valuemin': e.min,
            'aria-valuemax': e.max,
            'aria-valuenow': e.d_value,
            inputmode:
              'decimal' !== e.mode || e.minFractionDigits
                ? 'decimal'
                : 'numeric',
            disabled: e.disabled,
            readonly: e.readonly,
            placeholder: e.placeholder,
            'aria-labelledby': e.ariaLabelledby,
            'aria-label': e.ariaLabel,
            size: e.size,
            invalid: e.invalid,
            variant: e.variant,
            onInput: r.onUserInput,
            onKeydown: r.onInputKeyDown,
            onKeypress: r.onInputKeyPress,
            onPaste: r.onPaste,
            onClick: r.onInputClick,
            onFocus: r.onInputFocus,
            onBlur: r.onInputBlur,
            pt: e.ptm('pcInputText'),
            unstyled: e.unstyled
          },
          null,
          8,
          [
            'id',
            'class',
            'style',
            'value',
            'aria-valuemin',
            'aria-valuemax',
            'aria-valuenow',
            'inputmode',
            'disabled',
            'readonly',
            'placeholder',
            'aria-labelledby',
            'aria-label',
            'size',
            'invalid',
            'variant',
            'onInput',
            'onKeydown',
            'onKeypress',
            'onPaste',
            'onClick',
            'onFocus',
            'onBlur',
            'pt',
            'unstyled'
          ]
        ),
        e.showButtons && 'stacked' === e.buttonLayout
          ? (Vue.openBlock(),
            Vue.createElementBlock(
              'span',
              Vue.mergeProps(
                { key: 0, class: e.cx('buttonGroup') },
                e.ptm('buttonGroup')
              ),
              [
                Vue.renderSlot(
                  e.$slots,
                  'incrementbutton',
                  { listeners: r.upButtonListeners },
                  function () {
                    return [
                      Vue.createElementVNode(
                        'button',
                        Vue.mergeProps(
                          {
                            class: [
                              e.cx('incrementButton'),
                              e.incrementButtonClass
                            ]
                          },
                          Vue.toHandlers(r.upButtonListeners, !0),
                          {
                            disabled: e.disabled,
                            tabindex: -1,
                            'aria-hidden': 'true',
                            type: 'button'
                          },
                          e.ptm('incrementButton')
                        ),
                        [
                          Vue.renderSlot(
                            e.$slots,
                            e.$slots.incrementicon
                              ? 'incrementicon'
                              : 'incrementbuttonicon',
                            {},
                            function () {
                              return [
                                (Vue.openBlock(),
                                Vue.createBlock(
                                  Vue.resolveDynamicComponent(
                                    e.incrementIcon || e.incrementButtonIcon
                                      ? 'span'
                                      : 'AngleUpIcon'
                                  ),
                                  Vue.mergeProps(
                                    {
                                      class: [
                                        e.incrementIcon,
                                        e.incrementButtonIcon
                                      ]
                                    },
                                    e.ptm('incrementIcon'),
                                    { 'data-pc-section': 'incrementicon' }
                                  ),
                                  null,
                                  16,
                                  ['class']
                                ))
                              ]
                            }
                          )
                        ],
                        16,
                        _hoisted_1$T
                      )
                    ]
                  }
                ),
                Vue.renderSlot(
                  e.$slots,
                  'decrementbutton',
                  { listeners: r.downButtonListeners },
                  function () {
                    return [
                      Vue.createElementVNode(
                        'button',
                        Vue.mergeProps(
                          {
                            class: [
                              e.cx('decrementButton'),
                              e.decrementButtonClass
                            ]
                          },
                          Vue.toHandlers(r.downButtonListeners, !0),
                          {
                            disabled: e.disabled,
                            tabindex: -1,
                            'aria-hidden': 'true',
                            type: 'button'
                          },
                          e.ptm('decrementButton')
                        ),
                        [
                          Vue.renderSlot(
                            e.$slots,
                            e.$slots.decrementicon
                              ? 'decrementicon'
                              : 'decrementbuttonicon',
                            {},
                            function () {
                              return [
                                (Vue.openBlock(),
                                Vue.createBlock(
                                  Vue.resolveDynamicComponent(
                                    e.decrementIcon || e.decrementButtonIcon
                                      ? 'span'
                                      : 'AngleDownIcon'
                                  ),
                                  Vue.mergeProps(
                                    {
                                      class: [
                                        e.decrementIcon,
                                        e.decrementButtonIcon
                                      ]
                                    },
                                    e.ptm('decrementIcon'),
                                    { 'data-pc-section': 'decrementicon' }
                                  ),
                                  null,
                                  16,
                                  ['class']
                                ))
                              ]
                            }
                          )
                        ],
                        16,
                        _hoisted_2$x
                      )
                    ]
                  }
                )
              ],
              16
            ))
          : Vue.createCommentVNode('', !0),
        Vue.renderSlot(
          e.$slots,
          'incrementbutton',
          { listeners: r.upButtonListeners },
          function () {
            return [
              e.showButtons && 'stacked' !== e.buttonLayout
                ? (Vue.openBlock(),
                  Vue.createElementBlock(
                    'button',
                    Vue.mergeProps(
                      {
                        key: 0,
                        class: [e.cx('incrementButton'), e.incrementButtonClass]
                      },
                      Vue.toHandlers(r.upButtonListeners, !0),
                      {
                        disabled: e.disabled,
                        tabindex: -1,
                        'aria-hidden': 'true',
                        type: 'button'
                      },
                      e.ptm('incrementButton')
                    ),
                    [
                      Vue.renderSlot(
                        e.$slots,
                        e.$slots.incrementicon
                          ? 'incrementicon'
                          : 'incrementbuttonicon',
                        {},
                        function () {
                          return [
                            (Vue.openBlock(),
                            Vue.createBlock(
                              Vue.resolveDynamicComponent(
                                e.incrementIcon || e.incrementButtonIcon
                                  ? 'span'
                                  : 'AngleUpIcon'
                              ),
                              Vue.mergeProps(
                                {
                                  class: [
                                    e.incrementIcon,
                                    e.incrementButtonIcon
                                  ]
                                },
                                e.ptm('incrementIcon'),
                                { 'data-pc-section': 'incrementicon' }
                              ),
                              null,
                              16,
                              ['class']
                            ))
                          ]
                        }
                      )
                    ],
                    16,
                    _hoisted_3$l
                  ))
                : Vue.createCommentVNode('', !0)
            ]
          }
        ),
        Vue.renderSlot(
          e.$slots,
          'decrementbutton',
          { listeners: r.downButtonListeners },
          function () {
            return [
              e.showButtons && 'stacked' !== e.buttonLayout
                ? (Vue.openBlock(),
                  Vue.createElementBlock(
                    'button',
                    Vue.mergeProps(
                      {
                        key: 0,
                        class: [e.cx('decrementButton'), e.decrementButtonClass]
                      },
                      Vue.toHandlers(r.downButtonListeners, !0),
                      {
                        disabled: e.disabled,
                        tabindex: -1,
                        'aria-hidden': 'true',
                        type: 'button'
                      },
                      e.ptm('decrementButton')
                    ),
                    [
                      Vue.renderSlot(
                        e.$slots,
                        e.$slots.decrementicon
                          ? 'decrementicon'
                          : 'decrementbuttonicon',
                        {},
                        function () {
                          return [
                            (Vue.openBlock(),
                            Vue.createBlock(
                              Vue.resolveDynamicComponent(
                                e.decrementIcon || e.decrementButtonIcon
                                  ? 'span'
                                  : 'AngleDownIcon'
                              ),
                              Vue.mergeProps(
                                {
                                  class: [
                                    e.decrementIcon,
                                    e.decrementButtonIcon
                                  ]
                                },
                                e.ptm('decrementIcon'),
                                { 'data-pc-section': 'decrementicon' }
                              ),
                              null,
                              16,
                              ['class']
                            ))
                          ]
                        }
                      )
                    ],
                    16,
                    _hoisted_4$c
                  ))
                : Vue.createCommentVNode('', !0)
            ]
          }
        )
      ],
      16
    )
  )
}
__name(render$y, 'render$y'), (script$z.render = render$y)
var script$y = { name: 'ChevronDownIcon', extends: script$X }
function render$x(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              d: 'M7.01744 10.398C6.91269 10.3985 6.8089 10.378 6.71215 10.3379C6.61541 10.2977 6.52766 10.2386 6.45405 10.1641L1.13907 4.84913C1.03306 4.69404 0.985221 4.5065 1.00399 4.31958C1.02276 4.13266 1.10693 3.95838 1.24166 3.82747C1.37639 3.69655 1.55301 3.61742 1.74039 3.60402C1.92777 3.59062 2.11386 3.64382 2.26584 3.75424L7.01744 8.47394L11.769 3.75424C11.9189 3.65709 12.097 3.61306 12.2748 3.62921C12.4527 3.64535 12.6199 3.72073 12.7498 3.84328C12.8797 3.96582 12.9647 4.12842 12.9912 4.30502C13.0177 4.48162 12.9841 4.662 12.8958 4.81724L7.58083 10.1322C7.50996 10.2125 7.42344 10.2775 7.32656 10.3232C7.22968 10.3689 7.12449 10.3944 7.01744 10.398Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$x, 'render$x'), (script$y.render = render$x)
var script$x = { name: 'TimesIcon', extends: script$X }
function render$w(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              d: 'M8.01186 7.00933L12.27 2.75116C12.341 2.68501 12.398 2.60524 12.4375 2.51661C12.4769 2.42798 12.4982 2.3323 12.4999 2.23529C12.5016 2.13827 12.4838 2.0419 12.4474 1.95194C12.4111 1.86197 12.357 1.78024 12.2884 1.71163C12.2198 1.64302 12.138 1.58893 12.0481 1.55259C11.9581 1.51625 11.8617 1.4984 11.7647 1.50011C11.6677 1.50182 11.572 1.52306 11.4834 1.56255C11.3948 1.60204 11.315 1.65898 11.2488 1.72997L6.99067 5.98814L2.7325 1.72997C2.59553 1.60234 2.41437 1.53286 2.22718 1.53616C2.03999 1.53946 1.8614 1.61529 1.72901 1.74767C1.59663 1.88006 1.5208 2.05865 1.5175 2.24584C1.5142 2.43303 1.58368 2.61419 1.71131 2.75116L5.96948 7.00933L1.71131 11.2675C1.576 11.403 1.5 11.5866 1.5 11.7781C1.5 11.9696 1.576 12.1532 1.71131 12.2887C1.84679 12.424 2.03043 12.5 2.2219 12.5C2.41338 12.5 2.59702 12.424 2.7325 12.2887L6.99067 8.03052L11.2488 12.2887C11.3843 12.424 11.568 12.5 11.7594 12.5C11.9509 12.5 12.1346 12.424 12.27 12.2887C12.4053 12.1532 12.4813 11.9696 12.4813 11.7781C12.4813 11.5866 12.4053 11.403 12.27 11.2675L8.01186 7.00933Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$w, 'render$w'), (script$x.render = render$w)
var OverlayEventBus = EventBus(),
  script$w = {
    name: 'Portal',
    props: {
      appendTo: { type: [String, Object], default: 'body' },
      disabled: { type: Boolean, default: !1 }
    },
    data: __name(function () {
      return { mounted: !1 }
    }, 'data'),
    mounted: __name(function () {
      this.mounted = isClient$1()
    }, 'mounted'),
    computed: {
      inline: __name(function () {
        return this.disabled || 'self' === this.appendTo
      }, 'inline')
    }
  }
function render$v(e, t, n, o, i, r) {
  return r.inline
    ? Vue.renderSlot(e.$slots, 'default', { key: 0 })
    : i.mounted
      ? (Vue.openBlock(),
        Vue.createBlock(
          Vue.Teleport,
          { key: 1, to: n.appendTo },
          [Vue.renderSlot(e.$slots, 'default')],
          8,
          ['to']
        ))
      : Vue.createCommentVNode('', !0)
}
__name(render$v, 'render$v'), (script$w.render = render$v)
var theme$l = __name(function (e) {
    var t = e.dt
    return '\n.p-select {\n    display: inline-flex;\n    cursor: pointer;\n    position: relative;\n    user-select: none;\n    background: '
      .concat(t('select.background'), ';\n    border: 1px solid ')
      .concat(t('select.border.color'), ';\n    transition: background ')
      .concat(t('select.transition.duration'), ', color ')
      .concat(t('select.transition.duration'), ', border-color ')
      .concat(t('select.transition.duration'), ',\n        outline-color ')
      .concat(t('select.transition.duration'), ', box-shadow ')
      .concat(t('select.transition.duration'), ';\n    border-radius: ')
      .concat(
        t('select.border.radius'),
        ';\n    outline-color: transparent;\n    box-shadow: '
      )
      .concat(
        t('select.shadow'),
        ';\n}\n\n.p-select:not(.p-disabled):hover {\n    border-color: '
      )
      .concat(
        t('select.hover.border.color'),
        ';\n}\n\n.p-select:not(.p-disabled).p-focus {\n    border-color: '
      )
      .concat(t('select.focus.border.color'), ';\n    box-shadow: ')
      .concat(t('select.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('select.focus.ring.width'), ' ')
      .concat(t('select.focus.ring.style'), ' ')
      .concat(t('select.focus.ring.color'), ';\n    outline-offset: ')
      .concat(
        t('select.focus.ring.offset'),
        ';\n}\n\n.p-select.p-variant-filled {\n    background: '
      )
      .concat(
        t('select.filled.background'),
        ';\n}\n\n.p-select.p-variant-filled:not(.p-disabled):hover {\n    background: '
      )
      .concat(
        t('select.filled.hover.background'),
        ';\n}\n\n.p-select.p-variant-filled:not(.p-disabled).p-focus {\n    background: '
      )
      .concat(
        t('select.filled.focus.background'),
        ';\n}\n\n.p-select.p-invalid {\n    border-color: '
      )
      .concat(
        t('select.invalid.border.color'),
        ';\n}\n\n.p-select.p-disabled {\n    opacity: 1;\n    background: '
      )
      .concat(
        t('select.disabled.background'),
        ';\n}\n\n.p-select-clear-icon {\n    position: absolute;\n    top: 50%;\n    margin-top: -0.5rem;\n    color: '
      )
      .concat(t('select.clear.icon.color'), ';\n    inset-inline-end: ')
      .concat(
        t('select.dropdown.width'),
        ';\n}\n\n.p-select-dropdown {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-shrink: 0;\n    background: transparent;\n    color: '
      )
      .concat(t('select.dropdown.color'), ';\n    width: ')
      .concat(t('select.dropdown.width'), ';\n    border-start-end-radius: ')
      .concat(t('select.border.radius'), ';\n    border-end-end-radius: ')
      .concat(
        t('select.border.radius'),
        ';\n}\n\n.p-select-label {\n    display: block;\n    white-space: nowrap;\n    overflow: hidden;\n    flex: 1 1 auto;\n    width: 1%;\n    padding: '
      )
      .concat(t('select.padding.y'), ' ')
      .concat(
        t('select.padding.x'),
        ';\n    text-overflow: ellipsis;\n    cursor: pointer;\n    color: '
      )
      .concat(
        t('select.color'),
        ';\n    background: transparent;\n    border: 0 none;\n    outline: 0 none;\n}\n\n.p-select-label.p-placeholder {\n    color: '
      )
      .concat(
        t('select.placeholder.color'),
        ';\n}\n\n.p-select.p-invalid .p-select-label.p-placeholder {\n    color: '
      )
      .concat(
        t('select.invalid.placeholder.color'),
        ';\n}\n\n.p-select:has(.p-select-clear-icon) .p-select-label {\n    padding-inline-end: calc(1rem + '
      )
      .concat(
        t('select.padding.x'),
        ');\n}\n\n.p-select.p-disabled .p-select-label {\n    color: '
      )
      .concat(
        t('select.disabled.color'),
        ';\n}\n\n.p-select-label-empty {\n    overflow: hidden;\n    opacity: 0;\n}\n\ninput.p-select-label {\n    cursor: default;\n}\n\n.p-select .p-select-overlay {\n    min-width: 100%;\n}\n\n.p-select-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    background: '
      )
      .concat(t('select.overlay.background'), ';\n    color: ')
      .concat(t('select.overlay.color'), ';\n    border: 1px solid ')
      .concat(t('select.overlay.border.color'), ';\n    border-radius: ')
      .concat(t('select.overlay.border.radius'), ';\n    box-shadow: ')
      .concat(
        t('select.overlay.shadow'),
        ';\n}\n\n.p-select-header {\n    padding: '
      )
      .concat(
        t('select.list.header.padding'),
        ';\n}\n\n.p-select-filter {\n    width: 100%;\n}\n\n.p-select-list-container {\n    overflow: auto;\n}\n\n.p-select-option-group {\n    cursor: auto;\n    margin: 0;\n    padding: '
      )
      .concat(t('select.option.group.padding'), ';\n    background: ')
      .concat(t('select.option.group.background'), ';\n    color: ')
      .concat(t('select.option.group.color'), ';\n    font-weight: ')
      .concat(
        t('select.option.group.font.weight'),
        ';\n}\n\n.p-select-list {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    padding: '
      )
      .concat(t('select.list.padding'), ';\n    gap: ')
      .concat(
        t('select.list.gap'),
        ';\n    display: flex;\n    flex-direction: column;\n}\n\n.p-select-option {\n    cursor: pointer;\n    font-weight: normal;\n    white-space: nowrap;\n    position: relative;\n    overflow: hidden;\n    display: flex;\n    align-items: center;\n    padding: '
      )
      .concat(t('select.option.padding'), ';\n    border: 0 none;\n    color: ')
      .concat(
        t('select.option.color'),
        ';\n    background: transparent;\n    transition: background '
      )
      .concat(t('select.transition.duration'), ', color ')
      .concat(t('select.transition.duration'), ', border-color ')
      .concat(t('select.transition.duration'), ',\n            box-shadow ')
      .concat(t('select.transition.duration'), ', outline-color ')
      .concat(t('select.transition.duration'), ';\n    border-radius: ')
      .concat(
        t('select.option.border.radius'),
        ';\n}\n\n.p-select-option:not(.p-select-option-selected):not(.p-disabled).p-focus {\n    background: '
      )
      .concat(t('select.option.focus.background'), ';\n    color: ')
      .concat(
        t('select.option.focus.color'),
        ';\n}\n\n.p-select-option.p-select-option-selected {\n    background: '
      )
      .concat(t('select.option.selected.background'), ';\n    color: ')
      .concat(
        t('select.option.selected.color'),
        ';\n}\n\n.p-select-option.p-select-option-selected.p-focus {\n    background: '
      )
      .concat(t('select.option.selected.focus.background'), ';\n    color: ')
      .concat(
        t('select.option.selected.focus.color'),
        ';\n}\n\n.p-select-option-check-icon {\n    position: relative;\n    margin-inline-start: '
      )
      .concat(t('select.checkmark.gutter.start'), ';\n    margin-inline-end: ')
      .concat(t('select.checkmark.gutter.end'), ';\n    color: ')
      .concat(
        t('select.checkmark.color'),
        ';\n}\n\n.p-select-empty-message {\n    padding: '
      )
      .concat(
        t('select.empty.message.padding'),
        ';\n}\n\n.p-select-fluid {\n    display: flex;\n}\n\n.p-select-sm .p-select-label {\n    font-size: '
      )
      .concat(t('select.sm.font.size'), ';\n    padding-block: ')
      .concat(t('select.sm.padding.y'), ';\n    padding-inline: ')
      .concat(
        t('select.sm.padding.x'),
        ';\n}\n\n.p-select-sm .p-select-dropdown .p-icon {\n    font-size: '
      )
      .concat(t('select.sm.font.size'), ';\n    width: ')
      .concat(t('select.sm.font.size'), ';\n    height: ')
      .concat(
        t('select.sm.font.size'),
        ';\n}\n\n.p-select-lg .p-select-label {\n    font-size: '
      )
      .concat(t('select.lg.font.size'), ';\n    padding-block: ')
      .concat(t('select.lg.padding.y'), ';\n    padding-inline: ')
      .concat(
        t('select.lg.padding.x'),
        ';\n}\n\n.p-select-lg .p-select-dropdown .p-icon {\n    font-size: '
      )
      .concat(t('select.lg.font.size'), ';\n    width: ')
      .concat(t('select.lg.font.size'), ';\n    height: ')
      .concat(t('select.lg.font.size'), ';\n}\n')
  }, 'theme'),
  classes$m = {
    root: __name(function (e) {
      var t = e.instance,
        n = e.props,
        o = e.state
      return [
        'p-select p-component p-inputwrapper',
        {
          'p-disabled': n.disabled,
          'p-invalid': t.$invalid,
          'p-variant-filled': 'filled' === t.$variant,
          'p-focus': o.focused,
          'p-inputwrapper-filled': t.$filled,
          'p-inputwrapper-focus': o.focused || o.overlayVisible,
          'p-select-open': o.overlayVisible,
          'p-select-fluid': t.$fluid,
          'p-select-sm p-inputfield-sm': 'small' === n.size,
          'p-select-lg p-inputfield-lg': 'large' === n.size
        }
      ]
    }, 'root'),
    label: __name(function (e) {
      var t = e.instance,
        n = e.props
      return [
        'p-select-label',
        {
          'p-placeholder': !n.editable && t.label === n.placeholder,
          'p-select-label-empty': !(
            n.editable ||
            t.$slots.value ||
            ('p-emptylabel' !== t.label && 0 !== t.label.length)
          )
        }
      ]
    }, 'label'),
    clearIcon: 'p-select-clear-icon',
    dropdown: 'p-select-dropdown',
    loadingicon: 'p-select-loading-icon',
    dropdownIcon: 'p-select-dropdown-icon',
    overlay: 'p-select-overlay p-component',
    header: 'p-select-header',
    pcFilter: 'p-select-filter',
    listContainer: 'p-select-list-container',
    list: 'p-select-list',
    optionGroup: 'p-select-option-group',
    optionGroupLabel: 'p-select-option-group-label',
    option: __name(function (e) {
      var t = e.instance,
        n = e.props,
        o = e.state,
        i = e.option,
        r = e.focusedOption
      return [
        'p-select-option',
        {
          'p-select-option-selected': t.isSelected(i) && n.highlightOnSelect,
          'p-focus': o.focusedOptionIndex === r,
          'p-disabled': t.isOptionDisabled(i)
        }
      ]
    }, 'option'),
    optionLabel: 'p-select-option-label',
    optionCheckIcon: 'p-select-option-check-icon',
    optionBlankIcon: 'p-select-option-blank-icon',
    emptyMessage: 'p-select-empty-message'
  },
  SelectStyle = BaseStyle.extend({
    name: 'select',
    theme: theme$l,
    classes: classes$m
  }),
  script$1$l = {
    name: 'BaseSelect',
    extends: script$Q,
    props: {
      options: Array,
      optionLabel: [String, Function],
      optionValue: [String, Function],
      optionDisabled: [String, Function],
      optionGroupLabel: [String, Function],
      optionGroupChildren: [String, Function],
      scrollHeight: { type: String, default: '14rem' },
      filter: Boolean,
      filterPlaceholder: String,
      filterLocale: String,
      filterMatchMode: { type: String, default: 'contains' },
      filterFields: { type: Array, default: null },
      editable: Boolean,
      placeholder: { type: String, default: null },
      dataKey: null,
      showClear: { type: Boolean, default: !1 },
      inputId: { type: String, default: null },
      inputClass: { type: [String, Object], default: null },
      inputStyle: { type: Object, default: null },
      labelId: { type: String, default: null },
      labelClass: { type: [String, Object], default: null },
      labelStyle: { type: Object, default: null },
      panelClass: { type: [String, Object], default: null },
      overlayStyle: { type: Object, default: null },
      overlayClass: { type: [String, Object], default: null },
      panelStyle: { type: Object, default: null },
      appendTo: { type: [String, Object], default: 'body' },
      loading: { type: Boolean, default: !1 },
      clearIcon: { type: String, default: void 0 },
      dropdownIcon: { type: String, default: void 0 },
      filterIcon: { type: String, default: void 0 },
      loadingIcon: { type: String, default: void 0 },
      resetFilterOnHide: { type: Boolean, default: !1 },
      resetFilterOnClear: { type: Boolean, default: !1 },
      virtualScrollerOptions: { type: Object, default: null },
      autoOptionFocus: { type: Boolean, default: !1 },
      autoFilterFocus: { type: Boolean, default: !1 },
      selectOnFocus: { type: Boolean, default: !1 },
      focusOnHover: { type: Boolean, default: !0 },
      highlightOnSelect: { type: Boolean, default: !0 },
      checkmark: { type: Boolean, default: !1 },
      filterMessage: { type: String, default: null },
      selectionMessage: { type: String, default: null },
      emptySelectionMessage: { type: String, default: null },
      emptyFilterMessage: { type: String, default: null },
      emptyMessage: { type: String, default: null },
      tabindex: { type: Number, default: 0 },
      ariaLabel: { type: String, default: null },
      ariaLabelledby: { type: String, default: null }
    },
    style: SelectStyle,
    provide: __name(function () {
      return { $pcSelect: this, $parentInstance: this }
    }, 'provide')
  }
function _typeof$b(e) {
  return (_typeof$b =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function _toConsumableArray$7(e) {
  return (
    _arrayWithoutHoles$7(e) ||
    _iterableToArray$7(e) ||
    _unsupportedIterableToArray$a(e) ||
    _nonIterableSpread$7()
  )
}
function _nonIterableSpread$7() {
  throw new TypeError(
    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$a(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$a(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$a(e, t)
          : void 0
    )
  }
}
function _iterableToArray$7(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _arrayWithoutHoles$7(e) {
  if (Array.isArray(e)) return _arrayLikeToArray$a(e)
}
function _arrayLikeToArray$a(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
function ownKeys$d(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$d(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$d(Object(n), !0).forEach(function (t) {
          _defineProperty$b(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$d(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$b(e, t, n) {
  return (
    (t = _toPropertyKey$a(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$a(e) {
  var t = _toPrimitive$a(e, 'string')
  return 'symbol' == _typeof$b(t) ? t : t + ''
}
function _toPrimitive$a(e, t) {
  if ('object' != _typeof$b(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$b(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$b, '_typeof$b'),
  __name(_toConsumableArray$7, '_toConsumableArray$7'),
  __name(_nonIterableSpread$7, '_nonIterableSpread$7'),
  __name(_unsupportedIterableToArray$a, '_unsupportedIterableToArray$a'),
  __name(_iterableToArray$7, '_iterableToArray$7'),
  __name(_arrayWithoutHoles$7, '_arrayWithoutHoles$7'),
  __name(_arrayLikeToArray$a, '_arrayLikeToArray$a'),
  __name(ownKeys$d, 'ownKeys$d'),
  __name(_objectSpread$d, '_objectSpread$d'),
  __name(_defineProperty$b, '_defineProperty$b'),
  __name(_toPropertyKey$a, '_toPropertyKey$a'),
  __name(_toPrimitive$a, '_toPrimitive$a')
var script$v = {
    name: 'Select',
    extends: script$1$l,
    inheritAttrs: !1,
    emits: [
      'change',
      'focus',
      'blur',
      'before-show',
      'before-hide',
      'show',
      'hide',
      'filter'
    ],
    outsideClickListener: null,
    scrollHandler: null,
    resizeListener: null,
    labelClickListener: null,
    overlay: null,
    list: null,
    virtualScroller: null,
    searchTimeout: null,
    searchValue: null,
    isModelValueChanged: !1,
    data: __name(function () {
      return {
        id: this.$attrs.id,
        clicked: !1,
        focused: !1,
        focusedOptionIndex: -1,
        filterValue: null,
        overlayVisible: !1
      }
    }, 'data'),
    watch: {
      '$attrs.id': __name(function (e) {
        this.id = e || UniqueComponentId()
      }, '$attrsId'),
      modelValue: __name(function () {
        this.isModelValueChanged = !0
      }, 'modelValue'),
      options: __name(function () {
        this.autoUpdateModel()
      }, 'options')
    },
    mounted: __name(function () {
      ;(this.id = this.id || UniqueComponentId()),
        this.autoUpdateModel(),
        this.bindLabelClickListener()
    }, 'mounted'),
    updated: __name(function () {
      this.overlayVisible &&
        this.isModelValueChanged &&
        this.scrollInView(this.findSelectedOptionIndex()),
        (this.isModelValueChanged = !1)
    }, 'updated'),
    beforeUnmount: __name(function () {
      this.unbindOutsideClickListener(),
        this.unbindResizeListener(),
        this.unbindLabelClickListener(),
        this.scrollHandler &&
          (this.scrollHandler.destroy(), (this.scrollHandler = null)),
        this.overlay && (ZIndex.clear(this.overlay), (this.overlay = null))
    }, 'beforeUnmount'),
    methods: {
      getOptionIndex: __name(function (e, t) {
        return this.virtualScrollerDisabled ? e : t && t(e).index
      }, 'getOptionIndex'),
      getOptionLabel: __name(function (e) {
        return this.optionLabel ? resolveFieldData(e, this.optionLabel) : e
      }, 'getOptionLabel'),
      getOptionValue: __name(function (e) {
        return this.optionValue ? resolveFieldData(e, this.optionValue) : e
      }, 'getOptionValue'),
      getOptionRenderKey: __name(function (e, t) {
        return (
          (this.dataKey
            ? resolveFieldData(e, this.dataKey)
            : this.getOptionLabel(e)) +
          '_' +
          t
        )
      }, 'getOptionRenderKey'),
      getPTItemOptions: __name(function (e, t, n, o) {
        return this.ptm(o, {
          context: {
            option: e,
            index: n,
            selected: this.isSelected(e),
            focused: this.focusedOptionIndex === this.getOptionIndex(n, t),
            disabled: this.isOptionDisabled(e)
          }
        })
      }, 'getPTItemOptions'),
      isOptionDisabled: __name(function (e) {
        return !!this.optionDisabled && resolveFieldData(e, this.optionDisabled)
      }, 'isOptionDisabled'),
      isOptionGroup: __name(function (e) {
        return this.optionGroupLabel && e.optionGroup && e.group
      }, 'isOptionGroup'),
      getOptionGroupLabel: __name(function (e) {
        return resolveFieldData(e, this.optionGroupLabel)
      }, 'getOptionGroupLabel'),
      getOptionGroupChildren: __name(function (e) {
        return resolveFieldData(e, this.optionGroupChildren)
      }, 'getOptionGroupChildren'),
      getAriaPosInset: __name(function (e) {
        var t = this
        return (
          (this.optionGroupLabel
            ? e -
              this.visibleOptions.slice(0, e).filter(function (e) {
                return t.isOptionGroup(e)
              }).length
            : e) + 1
        )
      }, 'getAriaPosInset'),
      show: __name(function (e) {
        this.$emit('before-show'),
          (this.overlayVisible = !0),
          (this.focusedOptionIndex =
            -1 !== this.focusedOptionIndex
              ? this.focusedOptionIndex
              : this.autoOptionFocus
                ? this.findFirstFocusedOptionIndex()
                : this.editable
                  ? -1
                  : this.findSelectedOptionIndex()),
          e && focus(this.$refs.focusInput)
      }, 'show'),
      hide: __name(function (e) {
        var t = this,
          n = __name(function () {
            t.$emit('before-hide'),
              (t.overlayVisible = !1),
              (t.clicked = !1),
              (t.focusedOptionIndex = -1),
              (t.searchValue = ''),
              t.resetFilterOnHide && (t.filterValue = null),
              e && focus(t.$refs.focusInput)
          }, '_hide')
        setTimeout(function () {
          n()
        }, 0)
      }, 'hide'),
      onFocus: __name(function (e) {
        this.disabled ||
          ((this.focused = !0),
          this.overlayVisible &&
            ((this.focusedOptionIndex =
              -1 !== this.focusedOptionIndex
                ? this.focusedOptionIndex
                : this.autoOptionFocus
                  ? this.findFirstFocusedOptionIndex()
                  : this.editable
                    ? -1
                    : this.findSelectedOptionIndex()),
            this.scrollInView(this.focusedOptionIndex)),
          this.$emit('focus', e))
      }, 'onFocus'),
      onBlur: __name(function (e) {
        var t, n
        ;(this.focused = !1),
          (this.focusedOptionIndex = -1),
          (this.searchValue = ''),
          this.$emit('blur', e),
          null === (t = (n = this.formField).onBlur) ||
            void 0 === t ||
            t.call(n, e)
      }, 'onBlur'),
      onKeyDown: __name(function (e) {
        if (this.disabled || isAndroid$1()) e.preventDefault()
        else {
          var t = e.metaKey || e.ctrlKey
          switch (e.code) {
            case 'ArrowDown':
              this.onArrowDownKey(e)
              break
            case 'ArrowUp':
              this.onArrowUpKey(e, this.editable)
              break
            case 'ArrowLeft':
            case 'ArrowRight':
              this.onArrowLeftKey(e, this.editable)
              break
            case 'Home':
              this.onHomeKey(e, this.editable)
              break
            case 'End':
              this.onEndKey(e, this.editable)
              break
            case 'PageDown':
              this.onPageDownKey(e)
              break
            case 'PageUp':
              this.onPageUpKey(e)
              break
            case 'Space':
              this.onSpaceKey(e, this.editable)
              break
            case 'Enter':
            case 'NumpadEnter':
              this.onEnterKey(e)
              break
            case 'Escape':
              this.onEscapeKey(e)
              break
            case 'Tab':
              this.onTabKey(e)
              break
            case 'Backspace':
              this.onBackspaceKey(e, this.editable)
              break
            case 'ShiftLeft':
            case 'ShiftRight':
              break
            default:
              !t &&
                isPrintableCharacter(e.key) &&
                (!this.overlayVisible && this.show(),
                !this.editable && this.searchOptions(e, e.key))
          }
          this.clicked = !1
        }
      }, 'onKeyDown'),
      onEditableInput: __name(function (e) {
        var t = e.target.value
        ;(this.searchValue = ''),
          !this.searchOptions(e, t) && (this.focusedOptionIndex = -1),
          this.updateModel(e, t),
          !this.overlayVisible && isNotEmpty(t) && this.show()
      }, 'onEditableInput'),
      onContainerClick: __name(function (e) {
        this.disabled ||
          this.loading ||
          'INPUT' === e.target.tagName ||
          'clearicon' === e.target.getAttribute('data-pc-section') ||
          e.target.closest('[data-pc-section="clearicon"]') ||
          ((this.overlay && this.overlay.contains(e.target)) ||
            (this.overlayVisible ? this.hide(!0) : this.show(!0)),
          (this.clicked = !0))
      }, 'onContainerClick'),
      onClearClick: __name(function (e) {
        this.updateModel(e, null),
          this.resetFilterOnClear && (this.filterValue = null)
      }, 'onClearClick'),
      onFirstHiddenFocus: __name(function (e) {
        focus(
          e.relatedTarget === this.$refs.focusInput
            ? getFirstFocusableElement(
                this.overlay,
                ':not([data-p-hidden-focusable="true"])'
              )
            : this.$refs.focusInput
        )
      }, 'onFirstHiddenFocus'),
      onLastHiddenFocus: __name(function (e) {
        focus(
          e.relatedTarget === this.$refs.focusInput
            ? getLastFocusableElement(
                this.overlay,
                ':not([data-p-hidden-focusable="true"])'
              )
            : this.$refs.focusInput
        )
      }, 'onLastHiddenFocus'),
      onOptionSelect: __name(function (e, t) {
        var n =
            !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
          o = this.getOptionValue(t)
        this.updateModel(e, o), n && this.hide(!0)
      }, 'onOptionSelect'),
      onOptionMouseMove: __name(function (e, t) {
        this.focusOnHover && this.changeFocusedOptionIndex(e, t)
      }, 'onOptionMouseMove'),
      onFilterChange: __name(function (e) {
        var t = e.target.value
        ;(this.filterValue = t),
          (this.focusedOptionIndex = -1),
          this.$emit('filter', { originalEvent: e, value: t }),
          !this.virtualScrollerDisabled && this.virtualScroller.scrollToIndex(0)
      }, 'onFilterChange'),
      onFilterKeyDown: __name(function (e) {
        if (!e.isComposing)
          switch (e.code) {
            case 'ArrowDown':
              this.onArrowDownKey(e)
              break
            case 'ArrowUp':
              this.onArrowUpKey(e, !0)
              break
            case 'ArrowLeft':
            case 'ArrowRight':
              this.onArrowLeftKey(e, !0)
              break
            case 'Home':
              this.onHomeKey(e, !0)
              break
            case 'End':
              this.onEndKey(e, !0)
              break
            case 'Enter':
            case 'NumpadEnter':
              this.onEnterKey(e)
              break
            case 'Escape':
              this.onEscapeKey(e)
              break
            case 'Tab':
              this.onTabKey(e, !0)
          }
      }, 'onFilterKeyDown'),
      onFilterBlur: __name(function () {
        this.focusedOptionIndex = -1
      }, 'onFilterBlur'),
      onFilterUpdated: __name(function () {
        this.overlayVisible && this.alignOverlay()
      }, 'onFilterUpdated'),
      onOverlayClick: __name(function (e) {
        OverlayEventBus.emit('overlay-click', {
          originalEvent: e,
          target: this.$el
        })
      }, 'onOverlayClick'),
      onOverlayKeyDown: __name(function (e) {
        if ('Escape' === e.code) this.onEscapeKey(e)
      }, 'onOverlayKeyDown'),
      onArrowDownKey: __name(function (e) {
        if (this.overlayVisible) {
          var t =
            -1 !== this.focusedOptionIndex
              ? this.findNextOptionIndex(this.focusedOptionIndex)
              : this.clicked
                ? this.findFirstOptionIndex()
                : this.findFirstFocusedOptionIndex()
          this.changeFocusedOptionIndex(e, t)
        } else
          this.show(),
            this.editable &&
              this.changeFocusedOptionIndex(e, this.findSelectedOptionIndex())
        e.preventDefault()
      }, 'onArrowDownKey'),
      onArrowUpKey: __name(function (e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
        if (e.altKey && !t)
          -1 !== this.focusedOptionIndex &&
            this.onOptionSelect(
              e,
              this.visibleOptions[this.focusedOptionIndex]
            ),
            this.overlayVisible && this.hide(),
            e.preventDefault()
        else {
          var n =
            -1 !== this.focusedOptionIndex
              ? this.findPrevOptionIndex(this.focusedOptionIndex)
              : this.clicked
                ? this.findLastOptionIndex()
                : this.findLastFocusedOptionIndex()
          this.changeFocusedOptionIndex(e, n),
            !this.overlayVisible && this.show(),
            e.preventDefault()
        }
      }, 'onArrowUpKey'),
      onArrowLeftKey: __name(function (e) {
        arguments.length > 1 &&
          void 0 !== arguments[1] &&
          arguments[1] &&
          (this.focusedOptionIndex = -1)
      }, 'onArrowLeftKey'),
      onHomeKey: __name(function (e) {
        if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) {
          var t = e.currentTarget
          e.shiftKey
            ? t.setSelectionRange(0, e.target.selectionStart)
            : (t.setSelectionRange(0, 0), (this.focusedOptionIndex = -1))
        } else
          this.changeFocusedOptionIndex(e, this.findFirstOptionIndex()),
            !this.overlayVisible && this.show()
        e.preventDefault()
      }, 'onHomeKey'),
      onEndKey: __name(function (e) {
        if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) {
          var t = e.currentTarget
          if (e.shiftKey)
            t.setSelectionRange(e.target.selectionStart, t.value.length)
          else {
            var n = t.value.length
            t.setSelectionRange(n, n), (this.focusedOptionIndex = -1)
          }
        } else
          this.changeFocusedOptionIndex(e, this.findLastOptionIndex()),
            !this.overlayVisible && this.show()
        e.preventDefault()
      }, 'onEndKey'),
      onPageUpKey: __name(function (e) {
        this.scrollInView(0), e.preventDefault()
      }, 'onPageUpKey'),
      onPageDownKey: __name(function (e) {
        this.scrollInView(this.visibleOptions.length - 1), e.preventDefault()
      }, 'onPageDownKey'),
      onEnterKey: __name(function (e) {
        this.overlayVisible
          ? (-1 !== this.focusedOptionIndex &&
              this.onOptionSelect(
                e,
                this.visibleOptions[this.focusedOptionIndex]
              ),
            this.hide())
          : ((this.focusedOptionIndex = -1), this.onArrowDownKey(e)),
          e.preventDefault()
      }, 'onEnterKey'),
      onSpaceKey: __name(function (e) {
        !(arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) &&
          this.onEnterKey(e)
      }, 'onSpaceKey'),
      onEscapeKey: __name(function (e) {
        this.overlayVisible && this.hide(!0),
          e.preventDefault(),
          e.stopPropagation()
      }, 'onEscapeKey'),
      onTabKey: __name(function (e) {
        ;(arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) ||
          (this.overlayVisible && this.hasFocusableElements()
            ? (focus(this.$refs.firstHiddenFocusableElementOnOverlay),
              e.preventDefault())
            : (-1 !== this.focusedOptionIndex &&
                this.onOptionSelect(
                  e,
                  this.visibleOptions[this.focusedOptionIndex]
                ),
              this.overlayVisible && this.hide(this.filter)))
      }, 'onTabKey'),
      onBackspaceKey: __name(function (e) {
        arguments.length > 1 &&
          void 0 !== arguments[1] &&
          arguments[1] &&
          !this.overlayVisible &&
          this.show()
      }, 'onBackspaceKey'),
      onOverlayEnter: __name(function (e) {
        var t = this
        ZIndex.set('overlay', e, this.$primevue.config.zIndex.overlay),
          addStyle(e, { position: 'absolute', top: '0', left: '0' }),
          this.alignOverlay(),
          this.scrollInView(),
          setTimeout(function () {
            t.autoFilterFocus && t.filter && focus(t.$refs.filterInput.$el)
          }, 1)
      }, 'onOverlayEnter'),
      onOverlayAfterEnter: __name(function () {
        this.bindOutsideClickListener(),
          this.bindScrollListener(),
          this.bindResizeListener(),
          this.$emit('show')
      }, 'onOverlayAfterEnter'),
      onOverlayLeave: __name(function () {
        var e = this
        this.unbindOutsideClickListener(),
          this.unbindScrollListener(),
          this.unbindResizeListener(),
          this.autoFilterFocus &&
            this.filter &&
            !this.editable &&
            this.$nextTick(function () {
              focus(e.$refs.filterInput.$el)
            }),
          this.$emit('hide'),
          (this.overlay = null)
      }, 'onOverlayLeave'),
      onOverlayAfterLeave: __name(function (e) {
        ZIndex.clear(e)
      }, 'onOverlayAfterLeave'),
      alignOverlay: __name(function () {
        'self' === this.appendTo
          ? relativePosition(this.overlay, this.$el)
          : ((this.overlay.style.minWidth = getOuterWidth(this.$el) + 'px'),
            absolutePosition(this.overlay, this.$el))
      }, 'alignOverlay'),
      bindOutsideClickListener: __name(function () {
        var e = this
        this.outsideClickListener ||
          ((this.outsideClickListener = function (t) {
            e.overlayVisible &&
              e.overlay &&
              !e.$el.contains(t.target) &&
              !e.overlay.contains(t.target) &&
              e.hide()
          }),
          document.addEventListener('click', this.outsideClickListener))
      }, 'bindOutsideClickListener'),
      unbindOutsideClickListener: __name(function () {
        this.outsideClickListener &&
          (document.removeEventListener('click', this.outsideClickListener),
          (this.outsideClickListener = null))
      }, 'unbindOutsideClickListener'),
      bindScrollListener: __name(function () {
        var e = this
        this.scrollHandler ||
          (this.scrollHandler = new ConnectedOverlayScrollHandler(
            this.$refs.container,
            function () {
              e.overlayVisible && e.hide()
            }
          )),
          this.scrollHandler.bindScrollListener()
      }, 'bindScrollListener'),
      unbindScrollListener: __name(function () {
        this.scrollHandler && this.scrollHandler.unbindScrollListener()
      }, 'unbindScrollListener'),
      bindResizeListener: __name(function () {
        var e = this
        this.resizeListener ||
          ((this.resizeListener = function () {
            e.overlayVisible && !isTouchDevice() && e.hide()
          }),
          window.addEventListener('resize', this.resizeListener))
      }, 'bindResizeListener'),
      unbindResizeListener: __name(function () {
        this.resizeListener &&
          (window.removeEventListener('resize', this.resizeListener),
          (this.resizeListener = null))
      }, 'unbindResizeListener'),
      bindLabelClickListener: __name(function () {
        var e = this
        if (!this.editable && !this.labelClickListener) {
          var t = document.querySelector(
            'label[for="'.concat(this.labelId, '"]')
          )
          t &&
            isVisible(t) &&
            ((this.labelClickListener = function () {
              focus(e.$refs.focusInput)
            }),
            t.addEventListener('click', this.labelClickListener))
        }
      }, 'bindLabelClickListener'),
      unbindLabelClickListener: __name(function () {
        if (this.labelClickListener) {
          var e = document.querySelector(
            'label[for="'.concat(this.labelId, '"]')
          )
          e &&
            isVisible(e) &&
            e.removeEventListener('click', this.labelClickListener)
        }
      }, 'unbindLabelClickListener'),
      hasFocusableElements: __name(function () {
        return (
          getFocusableElements(
            this.overlay,
            ':not([data-p-hidden-focusable="true"])'
          ).length > 0
        )
      }, 'hasFocusableElements'),
      isOptionMatched: __name(function (e) {
        var t
        return (
          this.isValidOption(e) &&
          'string' == typeof this.getOptionLabel(e) &&
          (null === (t = this.getOptionLabel(e)) || void 0 === t
            ? void 0
            : t
                .toLocaleLowerCase(this.filterLocale)
                .startsWith(
                  this.searchValue.toLocaleLowerCase(this.filterLocale)
                ))
        )
      }, 'isOptionMatched'),
      isValidOption: __name(function (e) {
        return (
          isNotEmpty(e) && !(this.isOptionDisabled(e) || this.isOptionGroup(e))
        )
      }, 'isValidOption'),
      isValidSelectedOption: __name(function (e) {
        return this.isValidOption(e) && this.isSelected(e)
      }, 'isValidSelectedOption'),
      isSelected: __name(function (e) {
        return equals(this.d_value, this.getOptionValue(e), this.equalityKey)
      }, 'isSelected'),
      findFirstOptionIndex: __name(function () {
        var e = this
        return this.visibleOptions.findIndex(function (t) {
          return e.isValidOption(t)
        })
      }, 'findFirstOptionIndex'),
      findLastOptionIndex: __name(function () {
        var e = this
        return findLastIndex(this.visibleOptions, function (t) {
          return e.isValidOption(t)
        })
      }, 'findLastOptionIndex'),
      findNextOptionIndex: __name(function (e) {
        var t = this,
          n =
            e < this.visibleOptions.length - 1
              ? this.visibleOptions.slice(e + 1).findIndex(function (e) {
                  return t.isValidOption(e)
                })
              : -1
        return n > -1 ? n + e + 1 : e
      }, 'findNextOptionIndex'),
      findPrevOptionIndex: __name(function (e) {
        var t = this,
          n =
            e > 0
              ? findLastIndex(this.visibleOptions.slice(0, e), function (e) {
                  return t.isValidOption(e)
                })
              : -1
        return n > -1 ? n : e
      }, 'findPrevOptionIndex'),
      findSelectedOptionIndex: __name(function () {
        var e = this
        return this.$filled
          ? this.visibleOptions.findIndex(function (t) {
              return e.isValidSelectedOption(t)
            })
          : -1
      }, 'findSelectedOptionIndex'),
      findFirstFocusedOptionIndex: __name(function () {
        var e = this.findSelectedOptionIndex()
        return e < 0 ? this.findFirstOptionIndex() : e
      }, 'findFirstFocusedOptionIndex'),
      findLastFocusedOptionIndex: __name(function () {
        var e = this.findSelectedOptionIndex()
        return e < 0 ? this.findLastOptionIndex() : e
      }, 'findLastFocusedOptionIndex'),
      searchOptions: __name(function (e, t) {
        var n = this
        this.searchValue = (this.searchValue || '') + t
        var o = -1,
          i = !1
        return (
          isNotEmpty(this.searchValue) &&
            (-1 !==
              (o =
                -1 !== this.focusedOptionIndex
                  ? -1 ===
                    (o = this.visibleOptions
                      .slice(this.focusedOptionIndex)
                      .findIndex(function (e) {
                        return n.isOptionMatched(e)
                      }))
                    ? this.visibleOptions
                        .slice(0, this.focusedOptionIndex)
                        .findIndex(function (e) {
                          return n.isOptionMatched(e)
                        })
                    : o + this.focusedOptionIndex
                  : this.visibleOptions.findIndex(function (e) {
                      return n.isOptionMatched(e)
                    })) && (i = !0),
            -1 === o &&
              -1 === this.focusedOptionIndex &&
              (o = this.findFirstFocusedOptionIndex()),
            -1 !== o && this.changeFocusedOptionIndex(e, o)),
          this.searchTimeout && clearTimeout(this.searchTimeout),
          (this.searchTimeout = setTimeout(function () {
            ;(n.searchValue = ''), (n.searchTimeout = null)
          }, 500)),
          i
        )
      }, 'searchOptions'),
      changeFocusedOptionIndex: __name(function (e, t) {
        this.focusedOptionIndex !== t &&
          ((this.focusedOptionIndex = t),
          this.scrollInView(),
          this.selectOnFocus &&
            this.onOptionSelect(e, this.visibleOptions[t], !1))
      }, 'changeFocusedOptionIndex'),
      scrollInView: __name(function () {
        var e = this,
          t =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1
        this.$nextTick(function () {
          var n = -1 !== t ? ''.concat(e.id, '_').concat(t) : e.focusedOptionId,
            o = findSingle(e.list, 'li[id="'.concat(n, '"]'))
          o
            ? o.scrollIntoView &&
              o.scrollIntoView({ block: 'nearest', inline: 'start' })
            : e.virtualScrollerDisabled ||
              (e.virtualScroller &&
                e.virtualScroller.scrollToIndex(
                  -1 !== t ? t : e.focusedOptionIndex
                ))
        })
      }, 'scrollInView'),
      autoUpdateModel: __name(function () {
        this.selectOnFocus &&
          this.autoOptionFocus &&
          !this.$filled &&
          ((this.focusedOptionIndex = this.findFirstFocusedOptionIndex()),
          this.onOptionSelect(
            null,
            this.visibleOptions[this.focusedOptionIndex],
            !1
          ))
      }, 'autoUpdateModel'),
      updateModel: __name(function (e, t) {
        this.writeValue(t, e),
          this.$emit('change', { originalEvent: e, value: t })
      }, 'updateModel'),
      flatOptions: __name(function (e) {
        var t = this
        return (e || []).reduce(function (e, n, o) {
          e.push({ optionGroup: n, group: !0, index: o })
          var i = t.getOptionGroupChildren(n)
          return (
            i &&
              i.forEach(function (t) {
                return e.push(t)
              }),
            e
          )
        }, [])
      }, 'flatOptions'),
      overlayRef: __name(function (e) {
        this.overlay = e
      }, 'overlayRef'),
      listRef: __name(function (e, t) {
        ;(this.list = e), t && t(e)
      }, 'listRef'),
      virtualScrollerRef: __name(function (e) {
        this.virtualScroller = e
      }, 'virtualScrollerRef')
    },
    computed: {
      visibleOptions: __name(function () {
        var e = this,
          t = this.optionGroupLabel
            ? this.flatOptions(this.options)
            : this.options || []
        if (this.filterValue) {
          var n = FilterService.filter(
            t,
            this.searchFields,
            this.filterValue,
            this.filterMatchMode,
            this.filterLocale
          )
          if (this.optionGroupLabel) {
            var o = this.options || [],
              i = []
            return (
              o.forEach(function (t) {
                var o = e.getOptionGroupChildren(t).filter(function (e) {
                  return n.includes(e)
                })
                o.length > 0 &&
                  i.push(
                    _objectSpread$d(
                      _objectSpread$d({}, t),
                      {},
                      _defineProperty$b(
                        {},
                        'string' == typeof e.optionGroupChildren
                          ? e.optionGroupChildren
                          : 'items',
                        _toConsumableArray$7(o)
                      )
                    )
                  )
              }),
              this.flatOptions(i)
            )
          }
          return n
        }
        return t
      }, 'visibleOptions'),
      hasSelectedOption: __name(function () {
        return this.$filled
      }, 'hasSelectedOption'),
      label: __name(function () {
        var e = this.findSelectedOptionIndex()
        return -1 !== e
          ? this.getOptionLabel(this.visibleOptions[e])
          : this.placeholder || 'p-emptylabel'
      }, 'label'),
      editableInputValue: __name(function () {
        var e = this.findSelectedOptionIndex()
        return -1 !== e
          ? this.getOptionLabel(this.visibleOptions[e])
          : this.d_value || ''
      }, 'editableInputValue'),
      equalityKey: __name(function () {
        return this.optionValue ? null : this.dataKey
      }, 'equalityKey'),
      searchFields: __name(function () {
        return this.filterFields || [this.optionLabel]
      }, 'searchFields'),
      filterResultMessageText: __name(function () {
        return isNotEmpty(this.visibleOptions)
          ? this.filterMessageText.replaceAll('{0}', this.visibleOptions.length)
          : this.emptyFilterMessageText
      }, 'filterResultMessageText'),
      filterMessageText: __name(function () {
        return (
          this.filterMessage || this.$primevue.config.locale.searchMessage || ''
        )
      }, 'filterMessageText'),
      emptyFilterMessageText: __name(function () {
        return (
          this.emptyFilterMessage ||
          this.$primevue.config.locale.emptySearchMessage ||
          this.$primevue.config.locale.emptyFilterMessage ||
          ''
        )
      }, 'emptyFilterMessageText'),
      emptyMessageText: __name(function () {
        return (
          this.emptyMessage || this.$primevue.config.locale.emptyMessage || ''
        )
      }, 'emptyMessageText'),
      selectionMessageText: __name(function () {
        return (
          this.selectionMessage ||
          this.$primevue.config.locale.selectionMessage ||
          ''
        )
      }, 'selectionMessageText'),
      emptySelectionMessageText: __name(function () {
        return (
          this.emptySelectionMessage ||
          this.$primevue.config.locale.emptySelectionMessage ||
          ''
        )
      }, 'emptySelectionMessageText'),
      selectedMessageText: __name(function () {
        return this.$filled
          ? this.selectionMessageText.replaceAll('{0}', '1')
          : this.emptySelectionMessageText
      }, 'selectedMessageText'),
      focusedOptionId: __name(function () {
        return -1 !== this.focusedOptionIndex
          ? ''.concat(this.id, '_').concat(this.focusedOptionIndex)
          : null
      }, 'focusedOptionId'),
      ariaSetSize: __name(function () {
        var e = this
        return this.visibleOptions.filter(function (t) {
          return !e.isOptionGroup(t)
        }).length
      }, 'ariaSetSize'),
      isClearIconVisible: __name(function () {
        return (
          this.showClear && null != this.d_value && isNotEmpty(this.options)
        )
      }, 'isClearIconVisible'),
      virtualScrollerDisabled: __name(function () {
        return !this.virtualScrollerOptions
      }, 'virtualScrollerDisabled')
    },
    directives: { ripple: Ripple },
    components: {
      InputText: script$P,
      VirtualScroller: script$N,
      Portal: script$w,
      InputIcon: script$S,
      IconField: script$T,
      TimesIcon: script$x,
      ChevronDownIcon: script$y,
      SpinnerIcon: script$O,
      SearchIcon: script$U,
      CheckIcon: script$V,
      BlankIcon: script$W
    }
  },
  _hoisted_1$S = ['id'],
  _hoisted_2$w = [
    'id',
    'value',
    'placeholder',
    'tabindex',
    'disabled',
    'aria-label',
    'aria-labelledby',
    'aria-expanded',
    'aria-controls',
    'aria-activedescendant',
    'aria-invalid'
  ],
  _hoisted_3$k = [
    'id',
    'tabindex',
    'aria-label',
    'aria-labelledby',
    'aria-expanded',
    'aria-controls',
    'aria-activedescendant',
    'aria-disabled'
  ],
  _hoisted_4$b = ['id'],
  _hoisted_5$9 = ['id'],
  _hoisted_6$6 = [
    'id',
    'aria-label',
    'aria-selected',
    'aria-disabled',
    'aria-setsize',
    'aria-posinset',
    'onClick',
    'onMousemove',
    'data-p-selected',
    'data-p-focused',
    'data-p-disabled'
  ]
function render$u(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('SpinnerIcon'),
    s = Vue.resolveComponent('InputText'),
    l = Vue.resolveComponent('SearchIcon'),
    c = Vue.resolveComponent('InputIcon'),
    d = Vue.resolveComponent('IconField'),
    u = Vue.resolveComponent('CheckIcon'),
    p = Vue.resolveComponent('BlankIcon'),
    h = Vue.resolveComponent('VirtualScroller'),
    m = Vue.resolveComponent('Portal'),
    f = Vue.resolveDirective('ripple')
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps(
        {
          ref: 'container',
          id: i.id,
          class: e.cx('root'),
          onClick:
            t[11] ||
            (t[11] = function () {
              return (
                r.onContainerClick && r.onContainerClick.apply(r, arguments)
              )
            })
        },
        e.ptmi('root')
      ),
      [
        e.editable
          ? (Vue.openBlock(),
            Vue.createElementBlock(
              'input',
              Vue.mergeProps(
                {
                  key: 0,
                  ref: 'focusInput',
                  id: e.labelId || e.inputId,
                  type: 'text',
                  class: [e.cx('label'), e.inputClass, e.labelClass],
                  style: [e.inputStyle, e.labelStyle],
                  value: r.editableInputValue,
                  placeholder: e.placeholder,
                  tabindex: e.disabled ? -1 : e.tabindex,
                  disabled: e.disabled,
                  autocomplete: 'off',
                  role: 'combobox',
                  'aria-label': e.ariaLabel,
                  'aria-labelledby': e.ariaLabelledby,
                  'aria-haspopup': 'listbox',
                  'aria-expanded': i.overlayVisible,
                  'aria-controls': i.id + '_list',
                  'aria-activedescendant': i.focused
                    ? r.focusedOptionId
                    : void 0,
                  'aria-invalid': e.invalid || void 0,
                  onFocus:
                    t[0] ||
                    (t[0] = function () {
                      return r.onFocus && r.onFocus.apply(r, arguments)
                    }),
                  onBlur:
                    t[1] ||
                    (t[1] = function () {
                      return r.onBlur && r.onBlur.apply(r, arguments)
                    }),
                  onKeydown:
                    t[2] ||
                    (t[2] = function () {
                      return r.onKeyDown && r.onKeyDown.apply(r, arguments)
                    }),
                  onInput:
                    t[3] ||
                    (t[3] = function () {
                      return (
                        r.onEditableInput &&
                        r.onEditableInput.apply(r, arguments)
                      )
                    })
                },
                e.ptm('label')
              ),
              null,
              16,
              _hoisted_2$w
            ))
          : (Vue.openBlock(),
            Vue.createElementBlock(
              'span',
              Vue.mergeProps(
                {
                  key: 1,
                  ref: 'focusInput',
                  id: e.labelId || e.inputId,
                  class: [e.cx('label'), e.inputClass, e.labelClass],
                  style: [e.inputStyle, e.labelStyle],
                  tabindex: e.disabled ? -1 : e.tabindex,
                  role: 'combobox',
                  'aria-label':
                    e.ariaLabel ||
                    ('p-emptylabel' === r.label ? void 0 : r.label),
                  'aria-labelledby': e.ariaLabelledby,
                  'aria-haspopup': 'listbox',
                  'aria-expanded': i.overlayVisible,
                  'aria-controls': i.id + '_list',
                  'aria-activedescendant': i.focused
                    ? r.focusedOptionId
                    : void 0,
                  'aria-disabled': e.disabled,
                  onFocus:
                    t[4] ||
                    (t[4] = function () {
                      return r.onFocus && r.onFocus.apply(r, arguments)
                    }),
                  onBlur:
                    t[5] ||
                    (t[5] = function () {
                      return r.onBlur && r.onBlur.apply(r, arguments)
                    }),
                  onKeydown:
                    t[6] ||
                    (t[6] = function () {
                      return r.onKeyDown && r.onKeyDown.apply(r, arguments)
                    })
                },
                e.ptm('label')
              ),
              [
                Vue.renderSlot(
                  e.$slots,
                  'value',
                  { value: e.d_value, placeholder: e.placeholder },
                  function () {
                    var e
                    return [
                      Vue.createTextVNode(
                        Vue.toDisplayString(
                          'p-emptylabel' === r.label
                            ? ' '
                            : null !== (e = r.label) && void 0 !== e
                              ? e
                              : 'empty'
                        ),
                        1
                      )
                    ]
                  }
                )
              ],
              16,
              _hoisted_3$k
            )),
        r.isClearIconVisible
          ? Vue.renderSlot(
              e.$slots,
              'clearicon',
              {
                key: 2,
                class: Vue.normalizeClass(e.cx('clearIcon')),
                clearCallback: r.onClearClick
              },
              function () {
                return [
                  (Vue.openBlock(),
                  Vue.createBlock(
                    Vue.resolveDynamicComponent(
                      e.clearIcon ? 'i' : 'TimesIcon'
                    ),
                    Vue.mergeProps(
                      {
                        ref: 'clearIcon',
                        class: [e.cx('clearIcon'), e.clearIcon],
                        onClick: r.onClearClick
                      },
                      e.ptm('clearIcon'),
                      { 'data-pc-section': 'clearicon' }
                    ),
                    null,
                    16,
                    ['class', 'onClick']
                  ))
                ]
              }
            )
          : Vue.createCommentVNode('', !0),
        Vue.createElementVNode(
          'div',
          Vue.mergeProps({ class: e.cx('dropdown') }, e.ptm('dropdown')),
          [
            e.loading
              ? Vue.renderSlot(
                  e.$slots,
                  'loadingicon',
                  { key: 0, class: Vue.normalizeClass(e.cx('loadingIcon')) },
                  function () {
                    return [
                      e.loadingIcon
                        ? (Vue.openBlock(),
                          Vue.createElementBlock(
                            'span',
                            Vue.mergeProps(
                              {
                                key: 0,
                                class: [
                                  e.cx('loadingIcon'),
                                  'pi-spin',
                                  e.loadingIcon
                                ],
                                'aria-hidden': 'true'
                              },
                              e.ptm('loadingIcon')
                            ),
                            null,
                            16
                          ))
                        : (Vue.openBlock(),
                          Vue.createBlock(
                            a,
                            Vue.mergeProps(
                              {
                                key: 1,
                                class: e.cx('loadingIcon'),
                                spin: '',
                                'aria-hidden': 'true'
                              },
                              e.ptm('loadingIcon')
                            ),
                            null,
                            16,
                            ['class']
                          ))
                    ]
                  }
                )
              : Vue.renderSlot(
                  e.$slots,
                  'dropdownicon',
                  { key: 1, class: Vue.normalizeClass(e.cx('dropdownIcon')) },
                  function () {
                    return [
                      (Vue.openBlock(),
                      Vue.createBlock(
                        Vue.resolveDynamicComponent(
                          e.dropdownIcon ? 'span' : 'ChevronDownIcon'
                        ),
                        Vue.mergeProps(
                          {
                            class: [e.cx('dropdownIcon'), e.dropdownIcon],
                            'aria-hidden': 'true'
                          },
                          e.ptm('dropdownIcon')
                        ),
                        null,
                        16,
                        ['class']
                      ))
                    ]
                  }
                )
          ],
          16
        ),
        Vue.createVNode(
          m,
          { appendTo: e.appendTo },
          {
            default: Vue.withCtx(function () {
              return [
                Vue.createVNode(
                  Vue.Transition,
                  Vue.mergeProps(
                    {
                      name: 'p-connected-overlay',
                      onEnter: r.onOverlayEnter,
                      onAfterEnter: r.onOverlayAfterEnter,
                      onLeave: r.onOverlayLeave,
                      onAfterLeave: r.onOverlayAfterLeave
                    },
                    e.ptm('transition')
                  ),
                  {
                    default: Vue.withCtx(function () {
                      return [
                        i.overlayVisible
                          ? (Vue.openBlock(),
                            Vue.createElementBlock(
                              'div',
                              Vue.mergeProps(
                                {
                                  key: 0,
                                  ref: r.overlayRef,
                                  class: [
                                    e.cx('overlay'),
                                    e.panelClass,
                                    e.overlayClass
                                  ],
                                  style: [e.panelStyle, e.overlayStyle],
                                  onClick:
                                    t[9] ||
                                    (t[9] = function () {
                                      return (
                                        r.onOverlayClick &&
                                        r.onOverlayClick.apply(r, arguments)
                                      )
                                    }),
                                  onKeydown:
                                    t[10] ||
                                    (t[10] = function () {
                                      return (
                                        r.onOverlayKeyDown &&
                                        r.onOverlayKeyDown.apply(r, arguments)
                                      )
                                    })
                                },
                                e.ptm('overlay')
                              ),
                              [
                                Vue.createElementVNode(
                                  'span',
                                  Vue.mergeProps(
                                    {
                                      ref: 'firstHiddenFocusableElementOnOverlay',
                                      role: 'presentation',
                                      'aria-hidden': 'true',
                                      class:
                                        'p-hidden-accessible p-hidden-focusable',
                                      tabindex: 0,
                                      onFocus:
                                        t[7] ||
                                        (t[7] = function () {
                                          return (
                                            r.onFirstHiddenFocus &&
                                            r.onFirstHiddenFocus.apply(
                                              r,
                                              arguments
                                            )
                                          )
                                        })
                                    },
                                    e.ptm('hiddenFirstFocusableEl'),
                                    {
                                      'data-p-hidden-accessible': !0,
                                      'data-p-hidden-focusable': !0
                                    }
                                  ),
                                  null,
                                  16
                                ),
                                Vue.renderSlot(e.$slots, 'header', {
                                  value: e.d_value,
                                  options: r.visibleOptions
                                }),
                                e.filter
                                  ? (Vue.openBlock(),
                                    Vue.createElementBlock(
                                      'div',
                                      Vue.mergeProps(
                                        { key: 0, class: e.cx('header') },
                                        e.ptm('header')
                                      ),
                                      [
                                        Vue.createVNode(
                                          d,
                                          {
                                            unstyled: e.unstyled,
                                            pt: e.ptm('pcFilterContainer')
                                          },
                                          {
                                            default: Vue.withCtx(function () {
                                              return [
                                                Vue.createVNode(
                                                  s,
                                                  {
                                                    ref: 'filterInput',
                                                    type: 'text',
                                                    value: i.filterValue,
                                                    onVnodeMounted:
                                                      r.onFilterUpdated,
                                                    onVnodeUpdated:
                                                      r.onFilterUpdated,
                                                    class: Vue.normalizeClass(
                                                      e.cx('pcFilter')
                                                    ),
                                                    placeholder:
                                                      e.filterPlaceholder,
                                                    variant: e.variant,
                                                    unstyled: e.unstyled,
                                                    role: 'searchbox',
                                                    autocomplete: 'off',
                                                    'aria-owns': i.id + '_list',
                                                    'aria-activedescendant':
                                                      r.focusedOptionId,
                                                    onKeydown:
                                                      r.onFilterKeyDown,
                                                    onBlur: r.onFilterBlur,
                                                    onInput: r.onFilterChange,
                                                    pt: e.ptm('pcFilter')
                                                  },
                                                  null,
                                                  8,
                                                  [
                                                    'value',
                                                    'onVnodeMounted',
                                                    'onVnodeUpdated',
                                                    'class',
                                                    'placeholder',
                                                    'variant',
                                                    'unstyled',
                                                    'aria-owns',
                                                    'aria-activedescendant',
                                                    'onKeydown',
                                                    'onBlur',
                                                    'onInput',
                                                    'pt'
                                                  ]
                                                ),
                                                Vue.createVNode(
                                                  c,
                                                  {
                                                    unstyled: e.unstyled,
                                                    pt: e.ptm(
                                                      'pcFilterIconContainer'
                                                    )
                                                  },
                                                  {
                                                    default: Vue.withCtx(
                                                      function () {
                                                        return [
                                                          Vue.renderSlot(
                                                            e.$slots,
                                                            'filtericon',
                                                            {},
                                                            function () {
                                                              return [
                                                                e.filterIcon
                                                                  ? (Vue.openBlock(),
                                                                    Vue.createElementBlock(
                                                                      'span',
                                                                      Vue.mergeProps(
                                                                        {
                                                                          key: 0,
                                                                          class:
                                                                            e.filterIcon
                                                                        },
                                                                        e.ptm(
                                                                          'filterIcon'
                                                                        )
                                                                      ),
                                                                      null,
                                                                      16
                                                                    ))
                                                                  : (Vue.openBlock(),
                                                                    Vue.createBlock(
                                                                      l,
                                                                      Vue.normalizeProps(
                                                                        Vue.mergeProps(
                                                                          {
                                                                            key: 1
                                                                          },
                                                                          e.ptm(
                                                                            'filterIcon'
                                                                          )
                                                                        )
                                                                      ),
                                                                      null,
                                                                      16
                                                                    ))
                                                              ]
                                                            }
                                                          )
                                                        ]
                                                      }
                                                    ),
                                                    _: 3
                                                  },
                                                  8,
                                                  ['unstyled', 'pt']
                                                )
                                              ]
                                            }),
                                            _: 3
                                          },
                                          8,
                                          ['unstyled', 'pt']
                                        ),
                                        Vue.createElementVNode(
                                          'span',
                                          Vue.mergeProps(
                                            {
                                              role: 'status',
                                              'aria-live': 'polite',
                                              class: 'p-hidden-accessible'
                                            },
                                            e.ptm('hiddenFilterResult'),
                                            { 'data-p-hidden-accessible': !0 }
                                          ),
                                          Vue.toDisplayString(
                                            r.filterResultMessageText
                                          ),
                                          17
                                        )
                                      ],
                                      16
                                    ))
                                  : Vue.createCommentVNode('', !0),
                                Vue.createElementVNode(
                                  'div',
                                  Vue.mergeProps(
                                    {
                                      class: e.cx('listContainer'),
                                      style: {
                                        'max-height': r.virtualScrollerDisabled
                                          ? e.scrollHeight
                                          : ''
                                      }
                                    },
                                    e.ptm('listContainer')
                                  ),
                                  [
                                    Vue.createVNode(
                                      h,
                                      Vue.mergeProps(
                                        { ref: r.virtualScrollerRef },
                                        e.virtualScrollerOptions,
                                        {
                                          items: r.visibleOptions,
                                          style: { height: e.scrollHeight },
                                          tabindex: -1,
                                          disabled: r.virtualScrollerDisabled,
                                          pt: e.ptm('virtualScroller')
                                        }
                                      ),
                                      Vue.createSlots(
                                        {
                                          content: Vue.withCtx(function (t) {
                                            var n = t.styleClass,
                                              o = t.contentRef,
                                              a = t.items,
                                              s = t.getItemOptions,
                                              l = t.contentStyle,
                                              c = t.itemSize
                                            return [
                                              Vue.createElementVNode(
                                                'ul',
                                                Vue.mergeProps(
                                                  {
                                                    ref: __name(function (e) {
                                                      return r.listRef(e, o)
                                                    }, 'ref'),
                                                    id: i.id + '_list',
                                                    class: [e.cx('list'), n],
                                                    style: l,
                                                    role: 'listbox'
                                                  },
                                                  e.ptm('list')
                                                ),
                                                [
                                                  (Vue.openBlock(!0),
                                                  Vue.createElementBlock(
                                                    Vue.Fragment,
                                                    null,
                                                    Vue.renderList(
                                                      a,
                                                      function (t, n) {
                                                        return (
                                                          Vue.openBlock(),
                                                          Vue.createElementBlock(
                                                            Vue.Fragment,
                                                            {
                                                              key: r.getOptionRenderKey(
                                                                t,
                                                                r.getOptionIndex(
                                                                  n,
                                                                  s
                                                                )
                                                              )
                                                            },
                                                            [
                                                              r.isOptionGroup(t)
                                                                ? (Vue.openBlock(),
                                                                  Vue.createElementBlock(
                                                                    'li',
                                                                    Vue.mergeProps(
                                                                      {
                                                                        key: 0,
                                                                        id:
                                                                          i.id +
                                                                          '_' +
                                                                          r.getOptionIndex(
                                                                            n,
                                                                            s
                                                                          ),
                                                                        style: {
                                                                          height:
                                                                            c
                                                                              ? c +
                                                                                'px'
                                                                              : void 0
                                                                        },
                                                                        class:
                                                                          e.cx(
                                                                            'optionGroup'
                                                                          ),
                                                                        role: 'option',
                                                                        ref_for:
                                                                          !0
                                                                      },
                                                                      e.ptm(
                                                                        'optionGroup'
                                                                      )
                                                                    ),
                                                                    [
                                                                      Vue.renderSlot(
                                                                        e.$slots,
                                                                        'optiongroup',
                                                                        {
                                                                          option:
                                                                            t.optionGroup,
                                                                          index:
                                                                            r.getOptionIndex(
                                                                              n,
                                                                              s
                                                                            )
                                                                        },
                                                                        function () {
                                                                          return [
                                                                            Vue.createElementVNode(
                                                                              'span',
                                                                              Vue.mergeProps(
                                                                                {
                                                                                  class:
                                                                                    e.cx(
                                                                                      'optionGroupLabel'
                                                                                    ),
                                                                                  ref_for:
                                                                                    !0
                                                                                },
                                                                                e.ptm(
                                                                                  'optionGroupLabel'
                                                                                )
                                                                              ),
                                                                              Vue.toDisplayString(
                                                                                r.getOptionGroupLabel(
                                                                                  t.optionGroup
                                                                                )
                                                                              ),
                                                                              17
                                                                            )
                                                                          ]
                                                                        }
                                                                      )
                                                                    ],
                                                                    16,
                                                                    _hoisted_5$9
                                                                  ))
                                                                : Vue.withDirectives(
                                                                    (Vue.openBlock(),
                                                                    Vue.createElementBlock(
                                                                      'li',
                                                                      Vue.mergeProps(
                                                                        {
                                                                          key: 1,
                                                                          id:
                                                                            i.id +
                                                                            '_' +
                                                                            r.getOptionIndex(
                                                                              n,
                                                                              s
                                                                            ),
                                                                          class:
                                                                            e.cx(
                                                                              'option',
                                                                              {
                                                                                option:
                                                                                  t,
                                                                                focusedOption:
                                                                                  r.getOptionIndex(
                                                                                    n,
                                                                                    s
                                                                                  )
                                                                              }
                                                                            ),
                                                                          style:
                                                                            {
                                                                              height:
                                                                                c
                                                                                  ? c +
                                                                                    'px'
                                                                                  : void 0
                                                                            },
                                                                          role: 'option',
                                                                          'aria-label':
                                                                            r.getOptionLabel(
                                                                              t
                                                                            ),
                                                                          'aria-selected':
                                                                            r.isSelected(
                                                                              t
                                                                            ),
                                                                          'aria-disabled':
                                                                            r.isOptionDisabled(
                                                                              t
                                                                            ),
                                                                          'aria-setsize':
                                                                            r.ariaSetSize,
                                                                          'aria-posinset':
                                                                            r.getAriaPosInset(
                                                                              r.getOptionIndex(
                                                                                n,
                                                                                s
                                                                              )
                                                                            ),
                                                                          onClick:
                                                                            __name(
                                                                              function (
                                                                                e
                                                                              ) {
                                                                                return r.onOptionSelect(
                                                                                  e,
                                                                                  t
                                                                                )
                                                                              },
                                                                              'onClick'
                                                                            ),
                                                                          onMousemove:
                                                                            __name(
                                                                              function (
                                                                                e
                                                                              ) {
                                                                                return r.onOptionMouseMove(
                                                                                  e,
                                                                                  r.getOptionIndex(
                                                                                    n,
                                                                                    s
                                                                                  )
                                                                                )
                                                                              },
                                                                              'onMousemove'
                                                                            ),
                                                                          'data-p-selected':
                                                                            r.isSelected(
                                                                              t
                                                                            ),
                                                                          'data-p-focused':
                                                                            i.focusedOptionIndex ===
                                                                            r.getOptionIndex(
                                                                              n,
                                                                              s
                                                                            ),
                                                                          'data-p-disabled':
                                                                            r.isOptionDisabled(
                                                                              t
                                                                            ),
                                                                          ref_for:
                                                                            !0
                                                                        },
                                                                        r.getPTItemOptions(
                                                                          t,
                                                                          s,
                                                                          n,
                                                                          'option'
                                                                        )
                                                                      ),
                                                                      [
                                                                        e.checkmark
                                                                          ? (Vue.openBlock(),
                                                                            Vue.createElementBlock(
                                                                              Vue.Fragment,
                                                                              {
                                                                                key: 0
                                                                              },
                                                                              [
                                                                                r.isSelected(
                                                                                  t
                                                                                )
                                                                                  ? (Vue.openBlock(),
                                                                                    Vue.createBlock(
                                                                                      u,
                                                                                      Vue.mergeProps(
                                                                                        {
                                                                                          key: 0,
                                                                                          class:
                                                                                            e.cx(
                                                                                              'optionCheckIcon'
                                                                                            ),
                                                                                          ref_for:
                                                                                            !0
                                                                                        },
                                                                                        e.ptm(
                                                                                          'optionCheckIcon'
                                                                                        )
                                                                                      ),
                                                                                      null,
                                                                                      16,
                                                                                      [
                                                                                        'class'
                                                                                      ]
                                                                                    ))
                                                                                  : (Vue.openBlock(),
                                                                                    Vue.createBlock(
                                                                                      p,
                                                                                      Vue.mergeProps(
                                                                                        {
                                                                                          key: 1,
                                                                                          class:
                                                                                            e.cx(
                                                                                              'optionBlankIcon'
                                                                                            ),
                                                                                          ref_for:
                                                                                            !0
                                                                                        },
                                                                                        e.ptm(
                                                                                          'optionBlankIcon'
                                                                                        )
                                                                                      ),
                                                                                      null,
                                                                                      16,
                                                                                      [
                                                                                        'class'
                                                                                      ]
                                                                                    ))
                                                                              ],
                                                                              64
                                                                            ))
                                                                          : Vue.createCommentVNode(
                                                                              '',
                                                                              !0
                                                                            ),
                                                                        Vue.renderSlot(
                                                                          e.$slots,
                                                                          'option',
                                                                          {
                                                                            option:
                                                                              t,
                                                                            selected:
                                                                              r.isSelected(
                                                                                t
                                                                              ),
                                                                            index:
                                                                              r.getOptionIndex(
                                                                                n,
                                                                                s
                                                                              )
                                                                          },
                                                                          function () {
                                                                            return [
                                                                              Vue.createElementVNode(
                                                                                'span',
                                                                                Vue.mergeProps(
                                                                                  {
                                                                                    class:
                                                                                      e.cx(
                                                                                        'optionLabel'
                                                                                      ),
                                                                                    ref_for:
                                                                                      !0
                                                                                  },
                                                                                  e.ptm(
                                                                                    'optionLabel'
                                                                                  )
                                                                                ),
                                                                                Vue.toDisplayString(
                                                                                  r.getOptionLabel(
                                                                                    t
                                                                                  )
                                                                                ),
                                                                                17
                                                                              )
                                                                            ]
                                                                          }
                                                                        )
                                                                      ],
                                                                      16,
                                                                      _hoisted_6$6
                                                                    )),
                                                                    [[f]]
                                                                  )
                                                            ],
                                                            64
                                                          )
                                                        )
                                                      }
                                                    ),
                                                    128
                                                  )),
                                                  i.filterValue &&
                                                  (!a || (a && 0 === a.length))
                                                    ? (Vue.openBlock(),
                                                      Vue.createElementBlock(
                                                        'li',
                                                        Vue.mergeProps(
                                                          {
                                                            key: 0,
                                                            class:
                                                              e.cx(
                                                                'emptyMessage'
                                                              ),
                                                            role: 'option'
                                                          },
                                                          e.ptm('emptyMessage'),
                                                          {
                                                            'data-p-hidden-accessible':
                                                              !0
                                                          }
                                                        ),
                                                        [
                                                          Vue.renderSlot(
                                                            e.$slots,
                                                            'emptyfilter',
                                                            {},
                                                            function () {
                                                              return [
                                                                Vue.createTextVNode(
                                                                  Vue.toDisplayString(
                                                                    r.emptyFilterMessageText
                                                                  ),
                                                                  1
                                                                )
                                                              ]
                                                            }
                                                          )
                                                        ],
                                                        16
                                                      ))
                                                    : !e.options ||
                                                        (e.options &&
                                                          0 ===
                                                            e.options.length)
                                                      ? (Vue.openBlock(),
                                                        Vue.createElementBlock(
                                                          'li',
                                                          Vue.mergeProps(
                                                            {
                                                              key: 1,
                                                              class:
                                                                e.cx(
                                                                  'emptyMessage'
                                                                ),
                                                              role: 'option'
                                                            },
                                                            e.ptm(
                                                              'emptyMessage'
                                                            ),
                                                            {
                                                              'data-p-hidden-accessible':
                                                                !0
                                                            }
                                                          ),
                                                          [
                                                            Vue.renderSlot(
                                                              e.$slots,
                                                              'empty',
                                                              {},
                                                              function () {
                                                                return [
                                                                  Vue.createTextVNode(
                                                                    Vue.toDisplayString(
                                                                      r.emptyMessageText
                                                                    ),
                                                                    1
                                                                  )
                                                                ]
                                                              }
                                                            )
                                                          ],
                                                          16
                                                        ))
                                                      : Vue.createCommentVNode(
                                                          '',
                                                          !0
                                                        )
                                                ],
                                                16,
                                                _hoisted_4$b
                                              )
                                            ]
                                          }),
                                          _: 2
                                        },
                                        [
                                          e.$slots.loader
                                            ? {
                                                name: 'loader',
                                                fn: Vue.withCtx(function (t) {
                                                  var n = t.options
                                                  return [
                                                    Vue.renderSlot(
                                                      e.$slots,
                                                      'loader',
                                                      { options: n }
                                                    )
                                                  ]
                                                }),
                                                key: '0'
                                              }
                                            : void 0
                                        ]
                                      ),
                                      1040,
                                      ['items', 'style', 'disabled', 'pt']
                                    )
                                  ],
                                  16
                                ),
                                Vue.renderSlot(e.$slots, 'footer', {
                                  value: e.d_value,
                                  options: r.visibleOptions
                                }),
                                !e.options ||
                                (e.options && 0 === e.options.length)
                                  ? (Vue.openBlock(),
                                    Vue.createElementBlock(
                                      'span',
                                      Vue.mergeProps(
                                        {
                                          key: 1,
                                          role: 'status',
                                          'aria-live': 'polite',
                                          class: 'p-hidden-accessible'
                                        },
                                        e.ptm('hiddenEmptyMessage'),
                                        { 'data-p-hidden-accessible': !0 }
                                      ),
                                      Vue.toDisplayString(r.emptyMessageText),
                                      17
                                    ))
                                  : Vue.createCommentVNode('', !0),
                                Vue.createElementVNode(
                                  'span',
                                  Vue.mergeProps(
                                    {
                                      role: 'status',
                                      'aria-live': 'polite',
                                      class: 'p-hidden-accessible'
                                    },
                                    e.ptm('hiddenSelectedMessage'),
                                    { 'data-p-hidden-accessible': !0 }
                                  ),
                                  Vue.toDisplayString(r.selectedMessageText),
                                  17
                                ),
                                Vue.createElementVNode(
                                  'span',
                                  Vue.mergeProps(
                                    {
                                      ref: 'lastHiddenFocusableElementOnOverlay',
                                      role: 'presentation',
                                      'aria-hidden': 'true',
                                      class:
                                        'p-hidden-accessible p-hidden-focusable',
                                      tabindex: 0,
                                      onFocus:
                                        t[8] ||
                                        (t[8] = function () {
                                          return (
                                            r.onLastHiddenFocus &&
                                            r.onLastHiddenFocus.apply(
                                              r,
                                              arguments
                                            )
                                          )
                                        })
                                    },
                                    e.ptm('hiddenLastFocusableEl'),
                                    {
                                      'data-p-hidden-accessible': !0,
                                      'data-p-hidden-focusable': !0
                                    }
                                  ),
                                  null,
                                  16
                                )
                              ],
                              16
                            ))
                          : Vue.createCommentVNode('', !0)
                      ]
                    }),
                    _: 3
                  },
                  16,
                  ['onEnter', 'onAfterEnter', 'onLeave', 'onAfterLeave']
                )
              ]
            }),
            _: 3
          },
          8,
          ['appendTo']
        )
      ],
      16,
      _hoisted_1$S
    )
  )
}
__name(render$u, 'render$u'), (script$v.render = render$u)
var theme$k = __name(function (e) {
    var t = e.dt
    return '\n.p-toggleswitch {\n    display: inline-block;\n    width: '
      .concat(t('toggleswitch.width'), ';\n    height: ')
      .concat(
        t('toggleswitch.height'),
        ';\n}\n\n.p-toggleswitch-input {\n    cursor: pointer;\n    appearance: none;\n    position: absolute;\n    top: 0;\n    inset-inline-start: 0;\n    width: 100%;\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    opacity: 0;\n    z-index: 1;\n    outline: 0 none;\n    border-radius: '
      )
      .concat(
        t('toggleswitch.border.radius'),
        ';\n}\n\n.p-toggleswitch-slider {\n    cursor: pointer;\n    width: 100%;\n    height: 100%;\n    border-width: '
      )
      .concat(
        t('toggleswitch.border.width'),
        ';\n    border-style: solid;\n    border-color: '
      )
      .concat(t('toggleswitch.border.color'), ';\n    background: ')
      .concat(t('toggleswitch.background'), ';\n    transition: background ')
      .concat(t('toggleswitch.transition.duration'), ', color ')
      .concat(t('toggleswitch.transition.duration'), ', border-color ')
      .concat(t('toggleswitch.transition.duration'), ', outline-color ')
      .concat(t('toggleswitch.transition.duration'), ', box-shadow ')
      .concat(t('toggleswitch.transition.duration'), ';\n    border-radius: ')
      .concat(
        t('toggleswitch.border.radius'),
        ';\n    outline-color: transparent;\n    box-shadow: '
      )
      .concat(
        t('toggleswitch.shadow'),
        ';\n}\n\n.p-toggleswitch-handle {\n    position: absolute;\n    top: 50%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    background: '
      )
      .concat(t('toggleswitch.handle.background'), ';\n    color: ')
      .concat(t('toggleswitch.handle.color'), ';\n    width: ')
      .concat(t('toggleswitch.handle.size'), ';\n    height: ')
      .concat(t('toggleswitch.handle.size'), ';\n    inset-inline-start: ')
      .concat(
        t('toggleswitch.gap'),
        ';\n    margin-block-start: calc(-1 * calc('
      )
      .concat(t('toggleswitch.handle.size'), ' / 2));\n    border-radius: ')
      .concat(
        t('toggleswitch.handle.border.radius'),
        ';\n    transition: background '
      )
      .concat(t('toggleswitch.transition.duration'), ', color ')
      .concat(t('toggleswitch.transition.duration'), ', inset-inline-start ')
      .concat(t('toggleswitch.slide.duration'), ', box-shadow ')
      .concat(
        t('toggleswitch.slide.duration'),
        ';\n}\n\n.p-toggleswitch.p-toggleswitch-checked .p-toggleswitch-slider {\n    background: '
      )
      .concat(t('toggleswitch.checked.background'), ';\n    border-color: ')
      .concat(
        t('toggleswitch.checked.border.color'),
        ';\n}\n\n.p-toggleswitch.p-toggleswitch-checked .p-toggleswitch-handle {\n    background: '
      )
      .concat(t('toggleswitch.handle.checked.background'), ';\n    color: ')
      .concat(
        t('toggleswitch.handle.checked.color'),
        ';\n    inset-inline-start: calc('
      )
      .concat(t('toggleswitch.width'), ' - calc(')
      .concat(t('toggleswitch.handle.size'), ' + ')
      .concat(
        t('toggleswitch.gap'),
        '));\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover) .p-toggleswitch-slider {\n    background: '
      )
      .concat(t('toggleswitch.hover.background'), ';\n    border-color: ')
      .concat(
        t('toggleswitch.hover.border.color'),
        ';\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover) .p-toggleswitch-handle {\n    background: '
      )
      .concat(t('toggleswitch.handle.hover.background'), ';\n    color: ')
      .concat(
        t('toggleswitch.handle.hover.color'),
        ';\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover).p-toggleswitch-checked .p-toggleswitch-slider {\n    background: '
      )
      .concat(
        t('toggleswitch.checked.hover.background'),
        ';\n    border-color: '
      )
      .concat(
        t('toggleswitch.checked.hover.border.color'),
        ';\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover).p-toggleswitch-checked .p-toggleswitch-handle {\n    background: '
      )
      .concat(
        t('toggleswitch.handle.checked.hover.background'),
        ';\n    color: '
      )
      .concat(
        t('toggleswitch.handle.checked.hover.color'),
        ';\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:focus-visible) .p-toggleswitch-slider {\n    box-shadow: '
      )
      .concat(t('toggleswitch.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('toggleswitch.focus.ring.width'), ' ')
      .concat(t('toggleswitch.focus.ring.style'), ' ')
      .concat(t('toggleswitch.focus.ring.color'), ';\n    outline-offset: ')
      .concat(
        t('toggleswitch.focus.ring.offset'),
        ';\n}\n\n.p-toggleswitch.p-invalid > .p-toggleswitch-slider {\n    border-color: '
      )
      .concat(
        t('toggleswitch.invalid.border.color'),
        ';\n}\n\n.p-toggleswitch.p-disabled {\n    opacity: 1;\n}\n\n.p-toggleswitch.p-disabled .p-toggleswitch-slider {\n    background: '
      )
      .concat(
        t('toggleswitch.disabled.background'),
        ';\n}\n\n.p-toggleswitch.p-disabled .p-toggleswitch-handle {\n    background: '
      )
      .concat(t('toggleswitch.handle.disabled.background'), ';\n}\n')
  }, 'theme'),
  inlineStyles$2 = { root: { position: 'relative' } },
  classes$l = {
    root: __name(function (e) {
      var t = e.instance,
        n = e.props
      return [
        'p-toggleswitch p-component',
        {
          'p-toggleswitch-checked': t.checked,
          'p-disabled': n.disabled,
          'p-invalid': t.$invalid
        }
      ]
    }, 'root'),
    input: 'p-toggleswitch-input',
    slider: 'p-toggleswitch-slider',
    handle: 'p-toggleswitch-handle'
  },
  ToggleSwitchStyle = BaseStyle.extend({
    name: 'toggleswitch',
    theme: theme$k,
    classes: classes$l,
    inlineStyles: inlineStyles$2
  }),
  script$1$k = {
    name: 'BaseToggleSwitch',
    extends: script$R,
    props: {
      trueValue: { type: null, default: !0 },
      falseValue: { type: null, default: !1 },
      readonly: { type: Boolean, default: !1 },
      tabindex: { type: Number, default: null },
      inputId: { type: String, default: null },
      inputClass: { type: [String, Object], default: null },
      inputStyle: { type: Object, default: null },
      ariaLabelledby: { type: String, default: null },
      ariaLabel: { type: String, default: null }
    },
    style: ToggleSwitchStyle,
    provide: __name(function () {
      return { $pcToggleSwitch: this, $parentInstance: this }
    }, 'provide')
  },
  script$u = {
    name: 'ToggleSwitch',
    extends: script$1$k,
    inheritAttrs: !1,
    emits: ['change', 'focus', 'blur'],
    methods: {
      getPTOptions: __name(function (e) {
        return ('root' === e ? this.ptmi : this.ptm)(e, {
          context: { checked: this.checked, disabled: this.disabled }
        })
      }, 'getPTOptions'),
      onChange: __name(function (e) {
        if (!this.disabled && !this.readonly) {
          var t = this.checked ? this.falseValue : this.trueValue
          this.writeValue(t, e), this.$emit('change', e)
        }
      }, 'onChange'),
      onFocus: __name(function (e) {
        this.$emit('focus', e)
      }, 'onFocus'),
      onBlur: __name(function (e) {
        var t, n
        this.$emit('blur', e),
          null === (t = (n = this.formField).onBlur) ||
            void 0 === t ||
            t.call(n, e)
      }, 'onBlur')
    },
    computed: {
      checked: __name(function () {
        return this.d_value === this.trueValue
      }, 'checked')
    }
  },
  _hoisted_1$R = ['data-p-checked', 'data-p-disabled'],
  _hoisted_2$v = [
    'id',
    'checked',
    'tabindex',
    'disabled',
    'readonly',
    'aria-checked',
    'aria-labelledby',
    'aria-label',
    'aria-invalid'
  ]
function render$t(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps(
        { class: e.cx('root'), style: e.sx('root') },
        r.getPTOptions('root'),
        { 'data-p-checked': r.checked, 'data-p-disabled': e.disabled }
      ),
      [
        Vue.createElementVNode(
          'input',
          Vue.mergeProps(
            {
              id: e.inputId,
              type: 'checkbox',
              role: 'switch',
              class: [e.cx('input'), e.inputClass],
              style: e.inputStyle,
              checked: r.checked,
              tabindex: e.tabindex,
              disabled: e.disabled,
              readonly: e.readonly,
              'aria-checked': r.checked,
              'aria-labelledby': e.ariaLabelledby,
              'aria-label': e.ariaLabel,
              'aria-invalid': e.invalid || void 0,
              onFocus:
                t[0] ||
                (t[0] = function () {
                  return r.onFocus && r.onFocus.apply(r, arguments)
                }),
              onBlur:
                t[1] ||
                (t[1] = function () {
                  return r.onBlur && r.onBlur.apply(r, arguments)
                }),
              onChange:
                t[2] ||
                (t[2] = function () {
                  return r.onChange && r.onChange.apply(r, arguments)
                })
            },
            r.getPTOptions('input')
          ),
          null,
          16,
          _hoisted_2$v
        ),
        Vue.createElementVNode(
          'div',
          Vue.mergeProps({ class: e.cx('slider') }, r.getPTOptions('slider')),
          [
            Vue.createElementVNode(
              'div',
              Vue.mergeProps(
                { class: e.cx('handle') },
                r.getPTOptions('handle')
              ),
              [Vue.renderSlot(e.$slots, 'handle', { checked: r.checked })],
              16
            )
          ],
          16
        )
      ],
      16,
      _hoisted_1$R
    )
  )
}
__name(render$t, 'render$t'), (script$u.render = render$t)
const _sfc_main$O = Vue.defineComponent({
  __name: 'CustomFormValue',
  props: { renderFunction: { type: Function } },
  setup(e) {
    const t = e,
      n = Vue.ref(null)
    function o() {
      if (n.value) {
        n.value.innerHTML = ''
        const e = t.renderFunction()
        n.value.appendChild(e)
      }
    }
    return (
      __name(o, 'renderContent'),
      Vue.onMounted(o),
      Vue.watch(() => t.renderFunction, o),
      (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock(
          'div',
          { ref_key: 'container', ref: n },
          null,
          512
        )
      )
    )
  }
})
var theme$j = __name(function (e) {
    var t = e.dt
    return '\n.p-slider {\n    position: relative;\n    background: '
      .concat(t('slider.track.background'), ';\n    border-radius: ')
      .concat(
        t('slider.track.border.radius'),
        ';\n}\n\n.p-slider-handle {\n    cursor: grab;\n    touch-action: none;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: '
      )
      .concat(t('slider.handle.height'), ';\n    width: ')
      .concat(t('slider.handle.width'), ';\n    background: ')
      .concat(t('slider.handle.background'), ';\n    border-radius: ')
      .concat(
        t('slider.handle.border.radius'),
        ';\n    transition: background '
      )
      .concat(t('slider.transition.duration'), ', color ')
      .concat(t('slider.transition.duration'), ', border-color ')
      .concat(t('slider.transition.duration'), ', box-shadow ')
      .concat(t('slider.transition.duration'), ', outline-color ')
      .concat(
        t('slider.transition.duration'),
        ';\n    outline-color: transparent;\n}\n\n.p-slider-handle::before {\n    content: "";\n    width: '
      )
      .concat(t('slider.handle.content.width'), ';\n    height: ')
      .concat(
        t('slider.handle.content.height'),
        ';\n    display: block;\n    background: '
      )
      .concat(t('slider.handle.content.background'), ';\n    border-radius: ')
      .concat(t('slider.handle.content.border.radius'), ';\n    box-shadow: ')
      .concat(
        t('slider.handle.content.shadow'),
        ';\n    transition: background '
      )
      .concat(
        t('slider.transition.duration'),
        ';\n}\n\n.p-slider:not(.p-disabled) .p-slider-handle:hover {\n    background: '
      )
      .concat(
        t('slider.handle.hover.background'),
        ';\n}\n\n.p-slider:not(.p-disabled) .p-slider-handle:hover::before {\n    background: '
      )
      .concat(
        t('slider.handle.content.hover.background'),
        ';\n}\n\n.p-slider-handle:focus-visible {\n    box-shadow: '
      )
      .concat(t('slider.handle.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('slider.handle.focus.ring.width'), ' ')
      .concat(t('slider.handle.focus.ring.style'), ' ')
      .concat(t('slider.handle.focus.ring.color'), ';\n    outline-offset: ')
      .concat(
        t('slider.handle.focus.ring.offset'),
        ';\n}\n\n.p-slider-range {\n    display: block;\n    background: '
      )
      .concat(t('slider.range.background'), ';\n    border-radius: ')
      .concat(
        t('slider.border.radius'),
        ';\n}\n\n.p-slider.p-slider-horizontal {\n    height: '
      )
      .concat(
        t('slider.track.size'),
        ';\n}\n\n.p-slider-horizontal .p-slider-range {\n    inset-block-start: 0;\n    inset-inline-start: 0;\n    height: 100%;\n}\n\n.p-slider-horizontal .p-slider-handle {\n    inset-block-start: 50%;\n    margin-block-start: calc(-1 * calc('
      )
      .concat(
        t('slider.handle.height'),
        ' / 2));\n    margin-inline-start: calc(-1 * calc('
      )
      .concat(
        t('slider.handle.width'),
        ' / 2));\n}\n\n.p-slider-vertical {\n    min-height: 100px;\n    width: '
      )
      .concat(
        t('slider.track.size'),
        ';\n}\n\n.p-slider-vertical .p-slider-handle {\n    inset-inline-start: 50%;\n    margin-inline-start: calc(-1 * calc('
      )
      .concat(
        t('slider.handle.width'),
        ' / 2));\n    margin-block-end: calc(-1 * calc('
      )
      .concat(
        t('slider.handle.height'),
        ' / 2));\n}\n\n.p-slider-vertical .p-slider-range {\n    inset-block-end: 0;\n    inset-inline-start: 0;\n    width: 100%;\n}\n'
      )
  }, 'theme'),
  inlineStyles$1 = {
    handle: { position: 'absolute' },
    range: { position: 'absolute' }
  },
  classes$k = {
    root: __name(function (e) {
      var t = e.instance,
        n = e.props
      return [
        'p-slider p-component',
        {
          'p-disabled': n.disabled,
          'p-invalid': t.$invalid,
          'p-slider-horizontal': 'horizontal' === n.orientation,
          'p-slider-vertical': 'vertical' === n.orientation
        }
      ]
    }, 'root'),
    range: 'p-slider-range',
    handle: 'p-slider-handle'
  },
  SliderStyle = BaseStyle.extend({
    name: 'slider',
    theme: theme$j,
    classes: classes$k,
    inlineStyles: inlineStyles$1
  }),
  script$1$j = {
    name: 'BaseSlider',
    extends: script$R,
    props: {
      min: { type: Number, default: 0 },
      max: { type: Number, default: 100 },
      orientation: { type: String, default: 'horizontal' },
      step: { type: Number, default: null },
      range: { type: Boolean, default: !1 },
      tabindex: { type: Number, default: 0 },
      ariaLabelledby: { type: String, default: null },
      ariaLabel: { type: String, default: null }
    },
    style: SliderStyle,
    provide: __name(function () {
      return { $pcSlider: this, $parentInstance: this }
    }, 'provide')
  }
function _toConsumableArray$6(e) {
  return (
    _arrayWithoutHoles$6(e) ||
    _iterableToArray$6(e) ||
    _unsupportedIterableToArray$9(e) ||
    _nonIterableSpread$6()
  )
}
function _nonIterableSpread$6() {
  throw new TypeError(
    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$9(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$9(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$9(e, t)
          : void 0
    )
  }
}
function _iterableToArray$6(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _arrayWithoutHoles$6(e) {
  if (Array.isArray(e)) return _arrayLikeToArray$9(e)
}
function _arrayLikeToArray$9(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
__name(_toConsumableArray$6, '_toConsumableArray$6'),
  __name(_nonIterableSpread$6, '_nonIterableSpread$6'),
  __name(_unsupportedIterableToArray$9, '_unsupportedIterableToArray$9'),
  __name(_iterableToArray$6, '_iterableToArray$6'),
  __name(_arrayWithoutHoles$6, '_arrayWithoutHoles$6'),
  __name(_arrayLikeToArray$9, '_arrayLikeToArray$9')
var script$t = {
    name: 'Slider',
    extends: script$1$j,
    inheritAttrs: !1,
    emits: ['change', 'slideend'],
    dragging: !1,
    handleIndex: null,
    initX: null,
    initY: null,
    barWidth: null,
    barHeight: null,
    dragListener: null,
    dragEndListener: null,
    beforeUnmount: __name(function () {
      this.unbindDragListeners()
    }, 'beforeUnmount'),
    methods: {
      updateDomData: __name(function () {
        var e = this.$el.getBoundingClientRect()
        ;(this.initX = e.left + getWindowScrollLeft()),
          (this.initY = e.top + getWindowScrollTop()),
          (this.barWidth = this.$el.offsetWidth),
          (this.barHeight = this.$el.offsetHeight)
      }, 'updateDomData'),
      setValue: __name(function (e) {
        var t,
          n = e.touches ? e.touches[0].pageX : e.pageX,
          o = e.touches ? e.touches[0].pageY : e.pageY
        t =
          'horizontal' === this.orientation
            ? isRTL(this.$el)
              ? (100 * (this.initX + this.barWidth - n)) / this.barWidth
              : (100 * (n - this.initX)) / this.barWidth
            : (100 * (this.initY + this.barHeight - o)) / this.barHeight
        var i = (this.max - this.min) * (t / 100) + this.min
        if (this.step) {
          var r = this.range ? this.value[this.handleIndex] : this.value,
            a = i - r
          a < 0
            ? (i = r + Math.ceil(i / this.step - r / this.step) * this.step)
            : a > 0 &&
              (i = r + Math.floor(i / this.step - r / this.step) * this.step)
        } else i = Math.floor(i)
        this.updateModel(e, i)
      }, 'setValue'),
      updateModel: __name(function (e, t) {
        var n,
          o = parseFloat(t.toFixed(10))
        this.range
          ? ((n = this.value ? _toConsumableArray$6(this.value) : []),
            0 == this.handleIndex
              ? (o < this.min
                  ? (o = this.min)
                  : o >= this.max && (o = this.max),
                (n[0] = o))
              : (o > this.max
                  ? (o = this.max)
                  : o <= this.min && (o = this.min),
                (n[1] = o)))
          : (o < this.min ? (o = this.min) : o > this.max && (o = this.max),
            (n = o)),
          this.writeValue(n, e),
          this.$emit('change', n)
      }, 'updateModel'),
      onDragStart: __name(function (e, t) {
        this.disabled ||
          (this.$el.setAttribute('data-p-sliding', !0),
          (this.dragging = !0),
          this.updateDomData(),
          this.range && this.value[0] === this.max
            ? (this.handleIndex = 0)
            : (this.handleIndex = t),
          e.currentTarget.focus())
      }, 'onDragStart'),
      onDrag: __name(function (e) {
        this.dragging && this.setValue(e)
      }, 'onDrag'),
      onDragEnd: __name(function (e) {
        this.dragging &&
          ((this.dragging = !1),
          this.$el.setAttribute('data-p-sliding', !1),
          this.$emit('slideend', { originalEvent: e, value: this.value }))
      }, 'onDragEnd'),
      onBarClick: __name(function (e) {
        this.disabled ||
          ('handle' !== getAttribute(e.target, 'data-pc-section') &&
            (this.updateDomData(), this.setValue(e)))
      }, 'onBarClick'),
      onMouseDown: __name(function (e, t) {
        this.bindDragListeners(), this.onDragStart(e, t)
      }, 'onMouseDown'),
      onKeyDown: __name(function (e, t) {
        switch (((this.handleIndex = t), e.code)) {
          case 'ArrowDown':
          case 'ArrowLeft':
            this.decrementValue(e, t), e.preventDefault()
            break
          case 'ArrowUp':
          case 'ArrowRight':
            this.incrementValue(e, t), e.preventDefault()
            break
          case 'PageDown':
            this.decrementValue(e, t, !0), e.preventDefault()
            break
          case 'PageUp':
            this.incrementValue(e, t, !0), e.preventDefault()
            break
          case 'Home':
            this.updateModel(e, this.min), e.preventDefault()
            break
          case 'End':
            this.updateModel(e, this.max), e.preventDefault()
        }
      }, 'onKeyDown'),
      onBlur: __name(function (e, t) {
        var n, o
        null === (n = (o = this.formField).onBlur) ||
          void 0 === n ||
          n.call(o, e)
      }, 'onBlur'),
      decrementValue: __name(function (e, t) {
        var n,
          o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
        ;(n = this.range
          ? this.step
            ? this.value[t] - this.step
            : this.value[t] - 1
          : this.step
            ? this.value - this.step
            : !this.step && o
              ? this.value - 10
              : this.value - 1),
          this.updateModel(e, n),
          e.preventDefault()
      }, 'decrementValue'),
      incrementValue: __name(function (e, t) {
        var n,
          o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
        ;(n = this.range
          ? this.step
            ? this.value[t] + this.step
            : this.value[t] + 1
          : this.step
            ? this.value + this.step
            : !this.step && o
              ? this.value + 10
              : this.value + 1),
          this.updateModel(e, n),
          e.preventDefault()
      }, 'incrementValue'),
      bindDragListeners: __name(function () {
        this.dragListener ||
          ((this.dragListener = this.onDrag.bind(this)),
          document.addEventListener('mousemove', this.dragListener)),
          this.dragEndListener ||
            ((this.dragEndListener = this.onDragEnd.bind(this)),
            document.addEventListener('mouseup', this.dragEndListener))
      }, 'bindDragListeners'),
      unbindDragListeners: __name(function () {
        this.dragListener &&
          (document.removeEventListener('mousemove', this.dragListener),
          (this.dragListener = null)),
          this.dragEndListener &&
            (document.removeEventListener('mouseup', this.dragEndListener),
            (this.dragEndListener = null))
      }, 'unbindDragListeners'),
      rangeStyle: __name(function () {
        if (this.range) {
          var e =
              this.rangeEndPosition > this.rangeStartPosition
                ? this.rangeEndPosition - this.rangeStartPosition
                : this.rangeStartPosition - this.rangeEndPosition,
            t =
              this.rangeEndPosition > this.rangeStartPosition
                ? this.rangeStartPosition
                : this.rangeEndPosition
          return this.horizontal
            ? { 'inset-inline-start': t + '%', width: e + '%' }
            : { bottom: t + '%', height: e + '%' }
        }
        return this.horizontal
          ? { width: this.handlePosition + '%' }
          : { height: this.handlePosition + '%' }
      }, 'rangeStyle'),
      handleStyle: __name(function () {
        return this.horizontal
          ? { 'inset-inline-start': this.handlePosition + '%' }
          : { bottom: this.handlePosition + '%' }
      }, 'handleStyle'),
      rangeStartHandleStyle: __name(function () {
        return this.horizontal
          ? { 'inset-inline-start': this.rangeStartPosition + '%' }
          : { bottom: this.rangeStartPosition + '%' }
      }, 'rangeStartHandleStyle'),
      rangeEndHandleStyle: __name(function () {
        return this.horizontal
          ? { 'inset-inline-start': this.rangeEndPosition + '%' }
          : { bottom: this.rangeEndPosition + '%' }
      }, 'rangeEndHandleStyle')
    },
    computed: {
      value: __name(function () {
        var e, t, n, o, i
        return this.range
          ? [
              null !==
                (t =
                  null === (n = this.d_value) || void 0 === n
                    ? void 0
                    : n[0]) && void 0 !== t
                ? t
                : this.min,
              null !==
                (o =
                  null === (i = this.d_value) || void 0 === i
                    ? void 0
                    : i[1]) && void 0 !== o
                ? o
                : this.max
            ]
          : null !== (e = this.d_value) && void 0 !== e
            ? e
            : this.min
      }, 'value'),
      horizontal: __name(function () {
        return 'horizontal' === this.orientation
      }, 'horizontal'),
      vertical: __name(function () {
        return 'vertical' === this.orientation
      }, 'vertical'),
      handlePosition: __name(function () {
        return this.value < this.min
          ? 0
          : this.value > this.max
            ? 100
            : (100 * (this.value - this.min)) / (this.max - this.min)
      }, 'handlePosition'),
      rangeStartPosition: __name(function () {
        return this.value && void 0 !== this.value[0]
          ? this.value[0] < this.min
            ? 0
            : (100 * (this.value[0] - this.min)) / (this.max - this.min)
          : 0
      }, 'rangeStartPosition'),
      rangeEndPosition: __name(function () {
        return this.value && 2 === this.value.length && void 0 !== this.value[1]
          ? this.value[1] > this.max
            ? 100
            : (100 * (this.value[1] - this.min)) / (this.max - this.min)
          : 100
      }, 'rangeEndPosition')
    }
  },
  _hoisted_1$Q = [
    'tabindex',
    'aria-valuemin',
    'aria-valuenow',
    'aria-valuemax',
    'aria-labelledby',
    'aria-label',
    'aria-orientation'
  ],
  _hoisted_2$u = [
    'tabindex',
    'aria-valuemin',
    'aria-valuenow',
    'aria-valuemax',
    'aria-labelledby',
    'aria-label',
    'aria-orientation'
  ],
  _hoisted_3$j = [
    'tabindex',
    'aria-valuemin',
    'aria-valuenow',
    'aria-valuemax',
    'aria-labelledby',
    'aria-label',
    'aria-orientation'
  ]
function render$s(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps(
        {
          class: e.cx('root'),
          onClick:
            t[18] ||
            (t[18] = function () {
              return r.onBarClick && r.onBarClick.apply(r, arguments)
            })
        },
        e.ptmi('root'),
        { 'data-p-sliding': !1 }
      ),
      [
        Vue.createElementVNode(
          'span',
          Vue.mergeProps(
            { class: e.cx('range'), style: [e.sx('range'), r.rangeStyle()] },
            e.ptm('range')
          ),
          null,
          16
        ),
        e.range
          ? Vue.createCommentVNode('', !0)
          : (Vue.openBlock(),
            Vue.createElementBlock(
              'span',
              Vue.mergeProps(
                {
                  key: 0,
                  class: e.cx('handle'),
                  style: [e.sx('handle'), r.handleStyle()],
                  onTouchstartPassive:
                    t[0] ||
                    (t[0] = function (e) {
                      return r.onDragStart(e)
                    }),
                  onTouchmovePassive:
                    t[1] ||
                    (t[1] = function (e) {
                      return r.onDrag(e)
                    }),
                  onTouchend:
                    t[2] ||
                    (t[2] = function (e) {
                      return r.onDragEnd(e)
                    }),
                  onMousedown:
                    t[3] ||
                    (t[3] = function (e) {
                      return r.onMouseDown(e)
                    }),
                  onKeydown:
                    t[4] ||
                    (t[4] = function (e) {
                      return r.onKeyDown(e)
                    }),
                  onBlur:
                    t[5] ||
                    (t[5] = function (e) {
                      return r.onBlur(e)
                    }),
                  tabindex: e.tabindex,
                  role: 'slider',
                  'aria-valuemin': e.min,
                  'aria-valuenow': e.d_value,
                  'aria-valuemax': e.max,
                  'aria-labelledby': e.ariaLabelledby,
                  'aria-label': e.ariaLabel,
                  'aria-orientation': e.orientation
                },
                e.ptm('handle')
              ),
              null,
              16,
              _hoisted_1$Q
            )),
        e.range
          ? (Vue.openBlock(),
            Vue.createElementBlock(
              'span',
              Vue.mergeProps(
                {
                  key: 1,
                  class: e.cx('handle'),
                  style: [e.sx('handle'), r.rangeStartHandleStyle()],
                  onTouchstartPassive:
                    t[6] ||
                    (t[6] = function (e) {
                      return r.onDragStart(e, 0)
                    }),
                  onTouchmovePassive:
                    t[7] ||
                    (t[7] = function (e) {
                      return r.onDrag(e)
                    }),
                  onTouchend:
                    t[8] ||
                    (t[8] = function (e) {
                      return r.onDragEnd(e)
                    }),
                  onMousedown:
                    t[9] ||
                    (t[9] = function (e) {
                      return r.onMouseDown(e, 0)
                    }),
                  onKeydown:
                    t[10] ||
                    (t[10] = function (e) {
                      return r.onKeyDown(e, 0)
                    }),
                  onBlur:
                    t[11] ||
                    (t[11] = function (e) {
                      return r.onBlur(e, 0)
                    }),
                  tabindex: e.tabindex,
                  role: 'slider',
                  'aria-valuemin': e.min,
                  'aria-valuenow': e.d_value ? e.d_value[0] : null,
                  'aria-valuemax': e.max,
                  'aria-labelledby': e.ariaLabelledby,
                  'aria-label': e.ariaLabel,
                  'aria-orientation': e.orientation
                },
                e.ptm('startHandler')
              ),
              null,
              16,
              _hoisted_2$u
            ))
          : Vue.createCommentVNode('', !0),
        e.range
          ? (Vue.openBlock(),
            Vue.createElementBlock(
              'span',
              Vue.mergeProps(
                {
                  key: 2,
                  class: e.cx('handle'),
                  style: [e.sx('handle'), r.rangeEndHandleStyle()],
                  onTouchstartPassive:
                    t[12] ||
                    (t[12] = function (e) {
                      return r.onDragStart(e, 1)
                    }),
                  onTouchmovePassive:
                    t[13] ||
                    (t[13] = function (e) {
                      return r.onDrag(e)
                    }),
                  onTouchend:
                    t[14] ||
                    (t[14] = function (e) {
                      return r.onDragEnd(e)
                    }),
                  onMousedown:
                    t[15] ||
                    (t[15] = function (e) {
                      return r.onMouseDown(e, 1)
                    }),
                  onKeydown:
                    t[16] ||
                    (t[16] = function (e) {
                      return r.onKeyDown(e, 1)
                    }),
                  onBlur:
                    t[17] ||
                    (t[17] = function (e) {
                      return r.onBlur(e, 1)
                    }),
                  tabindex: e.tabindex,
                  role: 'slider',
                  'aria-valuemin': e.min,
                  'aria-valuenow': e.d_value ? e.d_value[1] : null,
                  'aria-valuemax': e.max,
                  'aria-labelledby': e.ariaLabelledby,
                  'aria-label': e.ariaLabel,
                  'aria-orientation': e.orientation
                },
                e.ptm('endHandler')
              ),
              null,
              16,
              _hoisted_3$j
            ))
          : Vue.createCommentVNode('', !0)
      ],
      16
    )
  )
}
__name(render$s, 'render$s'), (script$t.render = render$s)
const _hoisted_1$P = { class: 'input-slider flex flex-row items-center gap-2' },
  _sfc_main$N = Vue.defineComponent({
    __name: 'InputSlider',
    props: {
      modelValue: {},
      inputClass: {},
      sliderClass: {},
      min: {},
      max: {},
      step: {}
    },
    emits: ['update:modelValue'],
    setup(e, { emit: t }) {
      const n = e,
        o = t,
        i = Vue.ref(n.modelValue)
      Vue.watch(
        () => n.modelValue,
        (e) => {
          i.value = e
        }
      )
      const r = __name((e) => {
        null === e && (e = Number(n.min) || 0)
        const t = Number(n.min ?? Number.NEGATIVE_INFINITY),
          r = Number(n.max ?? Number.POSITIVE_INFINITY),
          a = Number(n.step) || 1
        ;(e = Math.max(t, Math.min(r, e))),
          (e = Math.round(e / a) * a),
          (i.value = e),
          o('update:modelValue', e)
      }, 'updateValue')
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock('div', _hoisted_1$P, [
          Vue.createVNode(
            Vue.unref(script$t),
            {
              modelValue: e.modelValue,
              'onUpdate:modelValue': r,
              class: Vue.normalizeClass(['slider-part', e.sliderClass]),
              min: e.min,
              max: e.max,
              step: e.step
            },
            null,
            8,
            ['modelValue', 'class', 'min', 'max', 'step']
          ),
          Vue.createVNode(
            Vue.unref(script$z),
            {
              modelValue: e.modelValue,
              'onUpdate:modelValue': r,
              class: Vue.normalizeClass(['input-part', e.inputClass]),
              'max-fraction-digits': 3,
              min: e.min,
              max: e.max,
              step: e.step,
              allowEmpty: !1
            },
            null,
            8,
            ['modelValue', 'class', 'min', 'max', 'step']
          )
        ])
      )
    }
  }),
  _hoisted_1$O = { class: 'form-label flex flex-grow items-center' },
  _hoisted_2$t = { key: 0, class: 'pi pi-info-circle bg-transparent' },
  _hoisted_3$i = { class: 'form-input flex justify-end' },
  _sfc_main$M = Vue.defineComponent({
    __name: 'FormItem',
    props: Vue.mergeModels(
      { item: {}, id: {}, labelClass: {} },
      { formValue: {}, formValueModifiers: {} }
    ),
    emits: ['update:formValue'],
    setup(e) {
      const t = Vue.useModel(e, 'formValue'),
        n = e
      function o(e) {
        const o = { ...(e.attrs || {}) },
          i = e.type
        if (
          ('function' == typeof i &&
            (o.renderFunction = () =>
              i(n.item.name, (e) => (t.value = e), t.value, e.attrs)),
          'combo' === e.type)
        )
          (o.options =
            'function' == typeof e.options ? e.options(t.value) : e.options),
            'string' != typeof e.options[0] &&
              ((o.optionLabel = 'text'), (o.optionValue = 'value'))
        return o
      }
      function i(e) {
        if ('function' == typeof e.type) return _sfc_main$O
        switch (e.type) {
          case 'boolean':
            return script$u
          case 'number':
            return script$z
          case 'slider':
            return _sfc_main$N
          case 'combo':
            return script$v
          default:
            return script$P
        }
      }
      return (
        __name(o, 'getFormAttrs'),
        __name(i, 'getFormComponent'),
        (e, r) => {
          const a = Vue.resolveDirective('tooltip')
          return (
            Vue.openBlock(),
            Vue.createElementBlock(
              Vue.Fragment,
              null,
              [
                Vue.createElementVNode('div', _hoisted_1$O, [
                  Vue.createElementVNode(
                    'span',
                    { class: Vue.normalizeClass(['text-muted', n.labelClass]) },
                    [
                      Vue.renderSlot(e.$slots, 'name-prefix', {}, void 0, !0),
                      Vue.createTextVNode(
                        ' ' + Vue.toDisplayString(n.item.name) + ' ',
                        1
                      ),
                      n.item.tooltip
                        ? Vue.withDirectives(
                            (Vue.openBlock(),
                            Vue.createElementBlock(
                              'i',
                              _hoisted_2$t,
                              null,
                              512
                            )),
                            [[a, n.item.tooltip]]
                          )
                        : Vue.createCommentVNode('', !0),
                      Vue.renderSlot(e.$slots, 'name-suffix', {}, void 0, !0)
                    ],
                    2
                  )
                ]),
                Vue.createElementVNode('div', _hoisted_3$i, [
                  (Vue.openBlock(),
                  Vue.createBlock(
                    Vue.resolveDynamicComponent(Vue.markRaw(i(n.item))),
                    Vue.mergeProps(
                      {
                        id: n.id,
                        modelValue: t.value,
                        'onUpdate:modelValue':
                          r[0] || (r[0] = (e) => (t.value = e))
                      },
                      o(n.item)
                    ),
                    null,
                    16,
                    ['id', 'modelValue']
                  ))
                ])
              ],
              64
            )
          )
        }
      )
    }
  }),
  FormItem = _export_sfc(_sfc_main$M, [['__scopeId', 'data-v-4fbf09d8']]),
  _sfc_main$L = Vue.defineComponent({
    __name: 'SettingItem',
    props: { setting: {} },
    setup(e) {
      const t = e,
        { t: n } = VueI18n.useI18n(),
        o = Vue.computed(() => {
          const e = t.setting.id.replace(/\./g, '_')
          return {
            ...t.setting,
            name: n(`settingsDialog.${e}.name`, t.setting.name),
            tooltip: t.setting.tooltip
              ? n(`settingsDialog.${e}.tooltip`, t.setting.tooltip)
              : void 0
          }
        }),
        i = useSettingStore(),
        r = Vue.computed(() => i.get(t.setting.id)),
        a = __name((e) => {
          i.set(t.setting.id, e)
        }, 'updateSettingValue')
      return (e, t) => (
        Vue.openBlock(),
        Vue.createBlock(
          FormItem,
          {
            item: o.value,
            id: e.setting.id,
            formValue: r.value,
            'onUpdate:formValue': a
          },
          {
            'name-prefix': Vue.withCtx(() => [
              e.setting.experimental
                ? (Vue.openBlock(),
                  Vue.createBlock(
                    Vue.unref(script$C),
                    { key: 0, value: e.$t('experimental') },
                    null,
                    8,
                    ['value']
                  ))
                : Vue.createCommentVNode('', !0),
              e.setting.deprecated
                ? (Vue.openBlock(),
                  Vue.createBlock(
                    Vue.unref(script$C),
                    { key: 1, value: e.$t('deprecated'), severity: 'danger' },
                    null,
                    8,
                    ['value']
                  ))
                : Vue.createCommentVNode('', !0)
            ]),
            _: 1
          },
          8,
          ['item', 'id', 'formValue']
        )
      )
    }
  }),
  _hoisted_1$N = { class: 'setting-group' },
  _sfc_main$K = Vue.defineComponent({
    __name: 'SettingGroup',
    props: { group: {}, divider: { type: Boolean } },
    setup: (e) => (e, t) => (
      Vue.openBlock(),
      Vue.createElementBlock('div', _hoisted_1$N, [
        e.divider
          ? (Vue.openBlock(), Vue.createBlock(Vue.unref(script$G), { key: 0 }))
          : Vue.createCommentVNode('', !0),
        Vue.createElementVNode(
          'h3',
          null,
          Vue.toDisplayString(
            e.$t(
              `settingsCategories.${Vue.unref(normalizeI18nKey)(e.group.label)}`,
              e.group.label
            )
          ),
          1
        ),
        (Vue.openBlock(!0),
        Vue.createElementBlock(
          Vue.Fragment,
          null,
          Vue.renderList(
            e.group.settings,
            (e) => (
              Vue.openBlock(),
              Vue.createElementBlock(
                'div',
                { key: e.id, class: 'setting-item flex items-center mb-4' },
                [
                  Vue.createVNode(_sfc_main$L, { setting: e }, null, 8, [
                    'setting'
                  ])
                ]
              )
            )
          ),
          128
        ))
      ])
    )
  }),
  _hoisted_1$M = { key: 0 },
  _sfc_main$J = Vue.defineComponent({
    __name: 'SettingsPanel',
    props: { settingGroups: {} },
    setup(e) {
      const t = e
      return (e, n) =>
        t.settingGroups.length > 0
          ? (Vue.openBlock(),
            Vue.createElementBlock('div', _hoisted_1$M, [
              (Vue.openBlock(!0),
              Vue.createElementBlock(
                Vue.Fragment,
                null,
                Vue.renderList(
                  t.settingGroups,
                  (e, t) => (
                    Vue.openBlock(),
                    Vue.createBlock(
                      _sfc_main$K,
                      { key: e.label, divider: 0 !== t, group: e },
                      null,
                      8,
                      ['divider', 'group']
                    )
                  )
                ),
                128
              ))
            ]))
          : (Vue.openBlock(),
            Vue.createBlock(
              NoResultsPlaceholder,
              {
                key: 1,
                icon: 'pi pi-search',
                title: e.$t('noResultsFound'),
                message: e.$t('searchFailedMessage')
              },
              null,
              8,
              ['title', 'message']
            ))
    }
  })
var classes$j = {
    root: __name(function (e) {
      return ['p-tabpanel', { 'p-tabpanel-active': e.instance.active }]
    }, 'root')
  },
  TabPanelStyle = BaseStyle.extend({ name: 'tabpanel', classes: classes$j }),
  script$1$i = {
    name: 'BaseTabPanel',
    extends: script$Y,
    props: {
      value: { type: [String, Number], default: void 0 },
      as: { type: [String, Object], default: 'DIV' },
      asChild: { type: Boolean, default: !1 },
      header: null,
      headerStyle: null,
      headerClass: null,
      headerProps: null,
      headerActionProps: null,
      contentStyle: null,
      contentClass: null,
      contentProps: null,
      disabled: Boolean
    },
    style: TabPanelStyle,
    provide: __name(function () {
      return { $pcTabPanel: this, $parentInstance: this }
    }, 'provide')
  },
  script$s = {
    name: 'TabPanel',
    extends: script$1$i,
    inheritAttrs: !1,
    inject: ['$pcTabs'],
    computed: {
      active: __name(function () {
        var e
        return equals(
          null === (e = this.$pcTabs) || void 0 === e ? void 0 : e.d_value,
          this.value
        )
      }, 'active'),
      id: __name(function () {
        var e
        return ''
          .concat(
            null === (e = this.$pcTabs) || void 0 === e ? void 0 : e.id,
            '_tabpanel_'
          )
          .concat(this.value)
      }, 'id'),
      ariaLabelledby: __name(function () {
        var e
        return ''
          .concat(
            null === (e = this.$pcTabs) || void 0 === e ? void 0 : e.id,
            '_tab_'
          )
          .concat(this.value)
      }, 'ariaLabelledby'),
      attrs: __name(function () {
        return Vue.mergeProps(this.a11yAttrs, this.ptmi('root', this.ptParams))
      }, 'attrs'),
      a11yAttrs: __name(function () {
        var e
        return {
          id: this.id,
          tabindex:
            null === (e = this.$pcTabs) || void 0 === e ? void 0 : e.tabindex,
          role: 'tabpanel',
          'aria-labelledby': this.ariaLabelledby,
          'data-pc-name': 'tabpanel',
          'data-p-active': this.active
        }
      }, 'a11yAttrs'),
      ptParams: __name(function () {
        return { context: { active: this.active } }
      }, 'ptParams')
    }
  }
function render$r(e, t, n, o, i, r) {
  var a, s
  return r.$pcTabs
    ? (Vue.openBlock(),
      Vue.createElementBlock(
        Vue.Fragment,
        { key: 1 },
        [
          e.asChild
            ? Vue.renderSlot(e.$slots, 'default', {
                key: 1,
                class: Vue.normalizeClass(e.cx('root')),
                active: r.active,
                a11yAttrs: r.a11yAttrs
              })
            : (Vue.openBlock(),
              Vue.createElementBlock(
                Vue.Fragment,
                { key: 0 },
                [
                  null === (a = r.$pcTabs) ||
                  void 0 === a ||
                  !a.lazy ||
                  r.active
                    ? Vue.withDirectives(
                        (Vue.openBlock(),
                        Vue.createBlock(
                          Vue.resolveDynamicComponent(e.as),
                          Vue.mergeProps(
                            { key: 0, class: e.cx('root') },
                            r.attrs
                          ),
                          {
                            default: Vue.withCtx(function () {
                              return [Vue.renderSlot(e.$slots, 'default')]
                            }),
                            _: 3
                          },
                          16,
                          ['class']
                        )),
                        [
                          [
                            Vue.vShow,
                            !(
                              null === (s = r.$pcTabs) ||
                              void 0 === s ||
                              !s.lazy
                            ) || r.active
                          ]
                        ]
                      )
                    : Vue.createCommentVNode('', !0)
                ],
                64
              ))
        ],
        64
      ))
    : Vue.renderSlot(e.$slots, 'default', { key: 0 })
}
__name(render$r, 'render$r'), (script$s.render = render$r)
const _hoisted_1$L = { class: 'flex flex-col h-full w-full gap-2' },
  _sfc_main$I = Vue.defineComponent({
    __name: 'PanelTemplate',
    props: { value: {}, class: {} },
    setup(e) {
      const t = e
      return (e, n) => (
        Vue.openBlock(),
        Vue.createBlock(
          Vue.unref(script$s),
          {
            value: t.value,
            class: Vue.normalizeClass(['h-full w-full', t.class])
          },
          {
            default: Vue.withCtx(() => [
              Vue.createElementVNode('div', _hoisted_1$L, [
                Vue.renderSlot(e.$slots, 'header'),
                Vue.createVNode(
                  Vue.unref(script$F),
                  { class: 'flex-grow h-0 pr-2' },
                  {
                    default: Vue.withCtx(() => [
                      Vue.renderSlot(e.$slots, 'default')
                    ]),
                    _: 3
                  }
                ),
                Vue.renderSlot(e.$slots, 'footer')
              ])
            ]),
            _: 3
          },
          8,
          ['value', 'class']
        )
      )
    }
  }),
  useSystemStatsStore = defineStore('systemStats', () => {
    const e = Vue.ref(null),
      t = Vue.ref(!1),
      n = Vue.ref(null)
    async function o() {
      ;(t.value = !0), (n.value = null)
      try {
        e.value = await api.getSystemStats()
      } catch (o) {
        ;(n.value =
          o instanceof Error
            ? o.message
            : 'An error occurred while fetching system stats'),
          console.error('Error fetching system stats:', o)
      } finally {
        t.value = !1
      }
    }
    return (
      __name(o, 'fetchSystemStats'),
      { systemStats: e, isLoading: t, error: n, fetchSystemStats: o }
    )
  }),
  CORE_MENU_COMMANDS = [
    [['Workflow'], ['Comfy.NewBlankWorkflow']],
    [['Workflow'], ['Comfy.OpenWorkflow', 'Comfy.BrowseTemplates']],
    [
      ['Workflow'],
      [
        'Comfy.SaveWorkflow',
        'Comfy.SaveWorkflowAs',
        'Comfy.ExportWorkflow',
        'Comfy.ExportWorkflowAPI'
      ]
    ],
    [['Edit'], ['Comfy.Undo', 'Comfy.Redo']],
    [['Edit'], ['Comfy.RefreshNodeDefinitions']],
    [['Edit'], ['Comfy.ClearWorkflow']],
    [['Edit'], ['Comfy.OpenClipspace']],
    [
      ['Help'],
      [
        'Comfy.Help.OpenComfyUIIssues',
        'Comfy.Help.OpenComfyUIDocs',
        'Comfy.Help.OpenComfyOrgDiscord'
      ]
    ]
  ],
  useMenuItemStore = defineStore('menuItem', () => {
    const e = useCommandStore(),
      t = Vue.ref([]),
      n = __name((e, n) => {
        let o = t.value
        for (let t = 0; t < e.length; t++) {
          const n = e[t]
          let i = o.find((e) => e.label === n)
          i || ((i = { label: n, items: [] }), o.push(i)),
            i.items || (i.items = []),
            (o = i.items)
        }
        o.length > 0 && o.push({ separator: !0 }), o.push(...n)
      }, 'registerMenuGroup'),
      o = __name((t, o) => {
        const i = o
          .map((t) => e.getCommand(t))
          .map((t) => ({
            command: __name(() => e.execute(t.id), 'command'),
            label: t.menubarLabel,
            icon: t.icon,
            tooltip: t.tooltip,
            comfyCommand: t
          }))
        n(t, i)
      }, 'registerCommands'),
      i = __name((e) => {
        if (!e.menuCommands) return
        const t = new Set(e.commands?.map((e) => e.id) ?? [])
        e.menuCommands.forEach((e) => {
          const n = e.commands.filter((e) => t.has(e))
          n.length && o(e.path, n)
        })
      }, 'loadExtensionMenuCommands'),
      r = __name(() => {
        for (const [e, t] of CORE_MENU_COMMANDS) o(e, t)
      }, 'registerCoreMenuCommands')
    return {
      menuItems: t,
      registerMenuGroup: n,
      registerCommands: o,
      loadExtensionMenuCommands: i,
      registerCoreMenuCommands: r
    }
  }),
  useExecutionStore = defineStore('execution', () => {
    const e = Vue.ref(null),
      t = Vue.ref(null),
      n = Vue.ref({}),
      o = Vue.ref(null),
      i = Vue.computed(() => {
        if (!o.value) return null
        const e = s.value?.workflow
        if (!e) return null
        const t = e.changeTracker?.activeState ?? null
        return t
          ? (t.nodes.find((e) => String(e.id) === o.value) ?? null)
          : null
      }),
      r = Vue.ref(null),
      a = Vue.computed(() =>
        r.value ? Math.round((r.value.value / r.value.max) * 100) : null
      ),
      s = Vue.computed(() => n.value[t.value ?? '']),
      l = Vue.computed(() =>
        s.value ? Object.values(s.value.nodes).length : 0
      ),
      c = Vue.computed(() => !t.value),
      d = Vue.computed(() =>
        s.value ? Object.values(s.value.nodes).filter(Boolean).length : 0
      ),
      u = Vue.computed(() => {
        if (!s.value) return 0
        const e = l.value,
          t = d.value
        return Math.round((t / e) * 100)
      })
    function p() {
      api.addEventListener('execution_start', m),
        api.addEventListener('execution_cached', f),
        api.addEventListener('executed', _),
        api.addEventListener('executing', g),
        api.addEventListener('progress', v),
        api.addEventListener('status', y)
    }
    function h() {
      api.removeEventListener('execution_start', m),
        api.removeEventListener('execution_cached', f),
        api.removeEventListener('executed', _),
        api.removeEventListener('executing', g),
        api.removeEventListener('progress', v),
        api.removeEventListener('status', y)
    }
    function m(e) {
      ;(t.value = e.detail.prompt_id), (n.value[t.value] ??= { nodes: {} })
    }
    function f(e) {
      if (s.value) for (const t of e.detail.nodes) s.value.nodes[t] = !0
    }
    function _(e) {
      s.value && (s.value.nodes[e.detail.node] = !0)
    }
    function g(e) {
      ;(r.value = null),
        s.value &&
          (o.value && s.value && (s.value.nodes[o.value] = !0),
          (o.value = e.detail ? String(e.detail) : null),
          o.value || (t.value && delete n.value[t.value], (t.value = null)))
    }
    function v(e) {
      r.value = e.detail
    }
    function y(t) {
      api.clientId &&
        ((e.value = api.clientId), api.removeEventListener('status', y))
    }
    function b({ nodes: e, id: t, workflow: o }) {
      n.value[t] ??= { nodes: {} }
      const i = n.value[t]
      ;(i.nodes = { ...e.reduce((e, t) => ((e[t] = !1), e), {}), ...i.nodes }),
        (i.workflow = o),
        console.debug(
          `queued task ${t} with ${Object.values(i.nodes).length} nodes`
        )
    }
    return (
      __name(p, 'bindExecutionEvents'),
      __name(h, 'unbindExecutionEvents'),
      __name(m, 'handleExecutionStart'),
      __name(f, 'handleExecutionCached'),
      __name(_, 'handleExecuted'),
      __name(g, 'handleExecuting'),
      __name(v, 'handleProgress'),
      __name(y, 'handleStatus'),
      __name(b, 'storePrompt'),
      {
        isIdle: c,
        clientId: e,
        activePromptId: t,
        queuedPrompts: n,
        executingNodeId: o,
        activePrompt: s,
        totalNodesToExecute: l,
        nodesExecuted: d,
        executionProgress: u,
        executingNode: i,
        executingNodeProgress: a,
        bindExecutionEvents: p,
        unbindExecutionEvents: h,
        storePrompt: b
      }
    )
  })
function computedEager(e, t) {
  var n
  const o = shallowRef()
  return (
    watchEffect(
      () => {
        o.value = e()
      },
      { ...t, flush: null != (n = null == t ? void 0 : t.flush) ? n : 'sync' }
    ),
    readonly(o)
  )
}
function computedWithControl(e, t) {
  let n, o, i
  const r = ref(!0),
    a = __name(() => {
      ;(r.value = !0), i()
    }, 'update')
  watch(e, a, { flush: 'sync' })
  const s = 'function' == typeof t ? t : t.get,
    l = 'function' == typeof t ? void 0 : t.set,
    c = customRef(
      (e, t) => (
        (o = e),
        (i = t),
        {
          get: () => (r.value && ((n = s(n)), (r.value = !1)), o(), n),
          set(e) {
            null == l || l(e)
          }
        }
      )
    )
  return Object.isExtensible(c) && (c.trigger = a), c
}
function tryOnScopeDispose(e) {
  return !!getCurrentScope() && (onScopeDispose(e), !0)
}
function createEventHook() {
  const e = new Set(),
    t = __name((t) => {
      e.delete(t)
    }, 'off')
  return {
    on: __name((n) => {
      e.add(n)
      const o = __name(() => t(n), 'offFn')
      return tryOnScopeDispose(o), { off: o }
    }, 'on'),
    off: t,
    trigger: __name(
      (...t) => Promise.all(Array.from(e).map((e) => e(...t))),
      'trigger'
    )
  }
}
function createGlobalState(e) {
  let t,
    n = !1
  const o = effectScope(!0)
  return (...i) => (n || ((t = o.run(() => e(...i))), (n = !0)), t)
}
__name(computedEager, 'computedEager'),
  __name(computedWithControl, 'computedWithControl'),
  __name(tryOnScopeDispose, 'tryOnScopeDispose'),
  __name(createEventHook, 'createEventHook'),
  __name(createGlobalState, 'createGlobalState')
const localProvidedStateMap = new WeakMap(),
  injectLocal = __name((...e) => {
    var t
    const n = e[0],
      o = null == (t = getCurrentInstance()) ? void 0 : t.proxy
    if (null == o) throw new Error('injectLocal must be called in setup')
    return localProvidedStateMap.has(o) && n in localProvidedStateMap.get(o)
      ? localProvidedStateMap.get(o)[n]
      : inject(...e)
  }, 'injectLocal'),
  provideLocal = __name((e, t) => {
    var n
    const o = null == (n = getCurrentInstance()) ? void 0 : n.proxy
    if (null == o) throw new Error('provideLocal must be called in setup')
    localProvidedStateMap.has(o) ||
      localProvidedStateMap.set(o, Object.create(null))
    ;(localProvidedStateMap.get(o)[e] = t), provide(e, t)
  }, 'provideLocal')
function createInjectionState(e, t) {
  const n =
      (null == t ? void 0 : t.injectionKey) ||
      Symbol(e.name || 'InjectionState'),
    o = null == t ? void 0 : t.defaultValue
  return [
    __name((...t) => {
      const o = e(...t)
      return provideLocal(n, o), o
    }, 'useProvidingState'),
    __name(() => injectLocal(n, o), 'useInjectedState')
  ]
}
function createSharedComposable(e) {
  let t,
    n,
    o = 0
  const i = __name(() => {
    ;(o -= 1), n && o <= 0 && (n.stop(), (t = void 0), (n = void 0))
  }, 'dispose')
  return (...r) => (
    (o += 1),
    n || ((n = effectScope(!0)), (t = n.run(() => e(...r)))),
    tryOnScopeDispose(i),
    t
  )
}
function extendRef(e, t, { enumerable: n = !1, unwrap: o = !0 } = {}) {
  if (isVue3 || version.startsWith('2.7.')) {
    for (const [i, r] of Object.entries(t))
      'value' !== i &&
        (isRef(r) && o
          ? Object.defineProperty(e, i, {
              get: () => r.value,
              set(e) {
                r.value = e
              },
              enumerable: n
            })
          : Object.defineProperty(e, i, { value: r, enumerable: n }))
    return e
  }
}
function get$2(e, t) {
  return null == t ? unref(e) : unref(e)[t]
}
function isDefined$1(e) {
  return null != unref(e)
}
function makeDestructurable(e, t) {
  if ('undefined' != typeof Symbol) {
    const n = { ...e }
    return (
      Object.defineProperty(n, Symbol.iterator, {
        enumerable: !1,
        value() {
          let e = 0
          return {
            next: __name(() => ({ value: t[e++], done: e > t.length }), 'next')
          }
        }
      }),
      n
    )
  }
  return Object.assign([...t], e)
}
function toValue(e) {
  return 'function' == typeof e ? e() : unref(e)
}
__name(createInjectionState, 'createInjectionState'),
  __name(createSharedComposable, 'createSharedComposable'),
  __name(extendRef, 'extendRef'),
  __name(get$2, 'get$2'),
  __name(isDefined$1, 'isDefined$1'),
  __name(makeDestructurable, 'makeDestructurable'),
  __name(toValue, 'toValue')
const resolveUnref = toValue
function reactify(e, t) {
  const n = !1 === (null == t ? void 0 : t.computedGetter) ? unref : toValue
  return function (...t) {
    return computed(() =>
      e.apply(
        this,
        t.map((e) => n(e))
      )
    )
  }
}
function reactifyObject(e, t = {}) {
  let n,
    o = []
  if (Array.isArray(t)) o = t
  else {
    n = t
    const { includeOwnProperties: i = !0 } = t
    o.push(...Object.keys(e)), i && o.push(...Object.getOwnPropertyNames(e))
  }
  return Object.fromEntries(
    o.map((t) => {
      const o = e[t]
      return [t, 'function' == typeof o ? reactify(o.bind(e), n) : o]
    })
  )
}
function toReactive(e) {
  if (!isRef(e)) return reactive(e)
  return reactive(
    new Proxy(
      {},
      {
        get: (t, n, o) => unref(Reflect.get(e.value, n, o)),
        set: (t, n, o) => (
          isRef(e.value[n]) && !isRef(o)
            ? (e.value[n].value = o)
            : (e.value[n] = o),
          !0
        ),
        deleteProperty: (t, n) => Reflect.deleteProperty(e.value, n),
        has: (t, n) => Reflect.has(e.value, n),
        ownKeys: () => Object.keys(e.value),
        getOwnPropertyDescriptor: () => ({ enumerable: !0, configurable: !0 })
      }
    )
  )
}
function reactiveComputed(e) {
  return toReactive(computed(e))
}
function reactiveOmit(e, ...t) {
  const n = t.flat(),
    o = n[0]
  return reactiveComputed(() =>
    'function' == typeof o
      ? Object.fromEntries(
          Object.entries(toRefs$1(e)).filter(([e, t]) => !o(toValue(t), e))
        )
      : Object.fromEntries(
          Object.entries(toRefs$1(e)).filter((e) => !n.includes(e[0]))
        )
  )
}
__name(reactify, 'reactify'),
  __name(reactifyObject, 'reactifyObject'),
  __name(toReactive, 'toReactive'),
  __name(reactiveComputed, 'reactiveComputed'),
  __name(reactiveOmit, 'reactiveOmit')
const directiveHooks = {
    mounted: isVue3 ? 'mounted' : 'inserted',
    updated: isVue3 ? 'updated' : 'componentUpdated',
    unmounted: isVue3 ? 'unmounted' : 'unbind'
  },
  isClient = 'undefined' != typeof window && 'undefined' != typeof document,
  isWorker =
    'undefined' != typeof WorkerGlobalScope &&
    globalThis instanceof WorkerGlobalScope,
  isDef = __name((e) => void 0 !== e, 'isDef'),
  notNullish = __name((e) => null != e, 'notNullish'),
  assert = __name((e, ...t) => {
    e || console.warn(...t)
  }, 'assert'),
  toString$1 = Object.prototype.toString,
  isObject$1 = __name(
    (e) => '[object Object]' === toString$1.call(e),
    'isObject$1'
  ),
  now = __name(() => Date.now(), 'now'),
  timestamp = __name(() => +Date.now(), 'timestamp'),
  clamp = __name((e, t, n) => Math.min(n, Math.max(t, e)), 'clamp'),
  noop = __name(() => {}, 'noop'),
  rand = __name(
    (e, t) => (
      (e = Math.ceil(e)),
      (t = Math.floor(t)),
      Math.floor(Math.random() * (t - e + 1)) + e
    ),
    'rand'
  ),
  hasOwn$1 = __name(
    (e, t) => Object.prototype.hasOwnProperty.call(e, t),
    'hasOwn$1'
  ),
  isIOS = getIsIOS()
function getIsIOS() {
  var e, t
  return (
    isClient &&
    (null == (e = null == window ? void 0 : window.navigator)
      ? void 0
      : e.userAgent) &&
    (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) ||
      ((null == (t = null == window ? void 0 : window.navigator)
        ? void 0
        : t.maxTouchPoints) > 2 &&
        /iPad|Macintosh/.test(
          null == window ? void 0 : window.navigator.userAgent
        )))
  )
}
function createFilterWrapper(e, t) {
  function n(...n) {
    return new Promise((o, i) => {
      Promise.resolve(
        e(() => t.apply(this, n), { fn: t, thisArg: this, args: n })
      )
        .then(o)
        .catch(i)
    })
  }
  return __name(n, 'wrapper'), n
}
__name(getIsIOS, 'getIsIOS'), __name(createFilterWrapper, 'createFilterWrapper')
const bypassFilter = __name((e) => e(), 'bypassFilter')
function debounceFilter(e, t = {}) {
  let n,
    o,
    i = noop
  const r = __name((e) => {
    clearTimeout(e), i(), (i = noop)
  }, '_clearTimeout')
  return __name((a) => {
    const s = toValue(e),
      l = toValue(t.maxWait)
    return (
      n && r(n),
      s <= 0 || (void 0 !== l && l <= 0)
        ? (o && (r(o), (o = null)), Promise.resolve(a()))
        : new Promise((e, c) => {
            ;(i = t.rejectOnCancel ? c : e),
              l &&
                !o &&
                (o = setTimeout(() => {
                  n && r(n), (o = null), e(a())
                }, l)),
              (n = setTimeout(() => {
                o && r(o), (o = null), e(a())
              }, s))
          })
    )
  }, 'filter')
}
function throttleFilter(...e) {
  let t,
    n,
    o,
    i,
    r,
    a,
    s = 0,
    l = !0,
    c = noop
  isRef(e[0]) || 'object' != typeof e[0]
    ? ([o, i = !0, r = !0, a = !1] = e)
    : ({
        delay: o,
        trailing: i = !0,
        leading: r = !0,
        rejectOnCancel: a = !1
      } = e[0])
  const d = __name(() => {
    t && (clearTimeout(t), (t = void 0), c(), (c = noop))
  }, 'clear')
  return __name((e) => {
    const u = toValue(o),
      p = Date.now() - s,
      h = __name(() => (n = e()), 'invoke2')
    return (
      d(),
      u <= 0
        ? ((s = Date.now()), h())
        : (p > u && (r || !l)
            ? ((s = Date.now()), h())
            : i &&
              (n = new Promise((e, n) => {
                ;(c = a ? n : e),
                  (t = setTimeout(
                    () => {
                      ;(s = Date.now()), (l = !0), e(h()), d()
                    },
                    Math.max(0, u - p)
                  ))
              })),
          r || t || (t = setTimeout(() => (l = !0), u)),
          (l = !1),
          n)
    )
  }, 'filter')
}
function pausableFilter(e = bypassFilter) {
  const t = ref(!0)
  function n() {
    t.value = !1
  }
  function o() {
    t.value = !0
  }
  __name(n, 'pause'), __name(o, 'resume')
  const i = __name((...n) => {
    t.value && e(...n)
  }, 'eventFilter')
  return { isActive: readonly(t), pause: n, resume: o, eventFilter: i }
}
function cacheStringFunction(e) {
  const t = Object.create(null)
  return (n) => t[n] || (t[n] = e(n))
}
__name(debounceFilter, 'debounceFilter'),
  __name(throttleFilter, 'throttleFilter'),
  __name(pausableFilter, 'pausableFilter'),
  __name(cacheStringFunction, 'cacheStringFunction')
const hyphenateRE = /\B([A-Z])/g,
  hyphenate = cacheStringFunction((e) =>
    e.replace(hyphenateRE, '-$1').toLowerCase()
  ),
  camelizeRE = /-(\w)/g,
  camelize = cacheStringFunction((e) =>
    e.replace(camelizeRE, (e, t) => (t ? t.toUpperCase() : ''))
  )
function promiseTimeout(e, t = !1, n = 'Timeout') {
  return new Promise((o, i) => {
    t ? setTimeout(() => i(n), e) : setTimeout(o, e)
  })
}
function identity(e) {
  return e
}
function createSingletonPromise(e) {
  let t
  function n() {
    return t || (t = e()), t
  }
  return (
    __name(n, 'wrapper'),
    (n.reset = async () => {
      const e = t
      ;(t = void 0), e && (await e)
    }),
    n
  )
}
function invoke(e) {
  return e()
}
function containsProp(e, ...t) {
  return t.some((t) => t in e)
}
function increaseWithUnit(e, t) {
  var n
  if ('number' == typeof e) return e + t
  const o = (null == (n = e.match(/^-?\d+\.?\d*/)) ? void 0 : n[0]) || '',
    i = e.slice(o.length),
    r = Number.parseFloat(o) + t
  return Number.isNaN(r) ? e : r + i
}
function objectPick(e, t, n = !1) {
  return t.reduce(
    (t, o) => (o in e && ((n && void 0 === e[o]) || (t[o] = e[o])), t),
    {}
  )
}
function objectOmit(e, t, n = !1) {
  return Object.fromEntries(
    Object.entries(e).filter(
      ([e, o]) => !((n && void 0 === o) || t.includes(e))
    )
  )
}
function objectEntries(e) {
  return Object.entries(e)
}
function getLifeCycleTarget(e) {
  return e || getCurrentInstance()
}
function toRef(...e) {
  if (1 !== e.length) return toRef$1(...e)
  const t = e[0]
  return 'function' == typeof t
    ? readonly(customRef(() => ({ get: t, set: noop })))
    : ref(t)
}
__name(promiseTimeout, 'promiseTimeout'),
  __name(identity, 'identity'),
  __name(createSingletonPromise, 'createSingletonPromise'),
  __name(invoke, 'invoke'),
  __name(containsProp, 'containsProp'),
  __name(increaseWithUnit, 'increaseWithUnit'),
  __name(objectPick, 'objectPick'),
  __name(objectOmit, 'objectOmit'),
  __name(objectEntries, 'objectEntries'),
  __name(getLifeCycleTarget, 'getLifeCycleTarget'),
  __name(toRef, 'toRef')
const resolveRef = toRef
function reactivePick(e, ...t) {
  const n = t.flat(),
    o = n[0]
  return reactiveComputed(() =>
    'function' == typeof o
      ? Object.fromEntries(
          Object.entries(toRefs$1(e)).filter(([e, t]) => o(toValue(t), e))
        )
      : Object.fromEntries(n.map((t) => [t, toRef(e, t)]))
  )
}
function refAutoReset(e, t = 1e4) {
  return customRef((n, o) => {
    let i,
      r = toValue(e)
    const a = __name(
      () =>
        setTimeout(() => {
          ;(r = toValue(e)), o()
        }, toValue(t)),
      'resetAfter'
    )
    return (
      tryOnScopeDispose(() => {
        clearTimeout(i)
      }),
      {
        get: () => (n(), r),
        set(e) {
          ;(r = e), o(), clearTimeout(i), (i = a())
        }
      }
    )
  })
}
function useDebounceFn(e, t = 200, n = {}) {
  return createFilterWrapper(debounceFilter(t, n), e)
}
function refDebounced(e, t = 200, n = {}) {
  const o = ref(e.value),
    i = useDebounceFn(
      () => {
        o.value = e.value
      },
      t,
      n
    )
  return watch(e, () => i()), o
}
function refDefault(e, t) {
  return computed({
    get() {
      var n
      return null != (n = e.value) ? n : t
    },
    set(t) {
      e.value = t
    }
  })
}
function useThrottleFn(e, t = 200, n = !1, o = !0, i = !1) {
  return createFilterWrapper(throttleFilter(t, n, o, i), e)
}
function refThrottled(e, t = 200, n = !0, o = !0) {
  if (t <= 0) return e
  const i = ref(e.value),
    r = useThrottleFn(
      () => {
        i.value = e.value
      },
      t,
      n,
      o
    )
  return watch(e, () => r()), i
}
function refWithControl(e, t = {}) {
  let n,
    o,
    i = e
  const r = customRef(
    (e, t) => (
      (n = e),
      (o = t),
      {
        get: () => a(),
        set(e) {
          s(e)
        }
      }
    )
  )
  function a(e = !0) {
    return e && n(), i
  }
  function s(e, n = !0) {
    var r, a
    if (e === i) return
    const s = i
    !1 !== (null == (r = t.onBeforeChange) ? void 0 : r.call(t, e, s)) &&
      ((i = e), null == (a = t.onChanged) || a.call(t, e, s), n && o())
  }
  __name(a, 'get2'), __name(s, 'set2')
  const l = __name(() => a(!1), 'untrackedGet'),
    c = __name((e) => s(e, !1), 'silentSet'),
    d = __name(() => a(!1), 'peek'),
    u = __name((e) => s(e, !1), 'lay')
  return extendRef(
    r,
    { get: a, set: s, untrackedGet: l, silentSet: c, peek: d, lay: u },
    { enumerable: !0 }
  )
}
__name(reactivePick, 'reactivePick'),
  __name(refAutoReset, 'refAutoReset'),
  __name(useDebounceFn, 'useDebounceFn'),
  __name(refDebounced, 'refDebounced'),
  __name(refDefault, 'refDefault'),
  __name(useThrottleFn, 'useThrottleFn'),
  __name(refThrottled, 'refThrottled'),
  __name(refWithControl, 'refWithControl')
const controlledRef = refWithControl
function set(...e) {
  if (2 === e.length) {
    const [t, n] = e
    t.value = n
  }
  if (3 === e.length)
    if (isVue2) set$1(...e)
    else {
      const [t, n, o] = e
      t[n] = o
    }
}
function watchWithFilter(e, t, n = {}) {
  const { eventFilter: o = bypassFilter, ...i } = n
  return watch(e, createFilterWrapper(o, t), i)
}
function watchPausable(e, t, n = {}) {
  const { eventFilter: o, ...i } = n,
    { eventFilter: r, pause: a, resume: s, isActive: l } = pausableFilter(o)
  return {
    stop: watchWithFilter(e, t, { ...i, eventFilter: r }),
    pause: a,
    resume: s,
    isActive: l
  }
}
function syncRef(e, t, ...[n]) {
  const {
      flush: o = 'sync',
      deep: i = !1,
      immediate: r = !0,
      direction: a = 'both',
      transform: s = {}
    } = n || {},
    l = [],
    c = ('ltr' in s && s.ltr) || ((e) => e),
    d = ('rtl' in s && s.rtl) || ((e) => e)
  ;('both' !== a && 'ltr' !== a) ||
    l.push(
      watchPausable(
        e,
        (e) => {
          l.forEach((e) => e.pause()),
            (t.value = c(e)),
            l.forEach((e) => e.resume())
        },
        { flush: o, deep: i, immediate: r }
      )
    ),
    ('both' !== a && 'rtl' !== a) ||
      l.push(
        watchPausable(
          t,
          (t) => {
            l.forEach((e) => e.pause()),
              (e.value = d(t)),
              l.forEach((e) => e.resume())
          },
          { flush: o, deep: i, immediate: r }
        )
      )
  return __name(() => {
    l.forEach((e) => e.stop())
  }, 'stop')
}
function syncRefs(e, t, n = {}) {
  const { flush: o = 'sync', deep: i = !1, immediate: r = !0 } = n
  return (
    Array.isArray(t) || (t = [t]),
    watch(e, (e) => t.forEach((t) => (t.value = e)), {
      flush: o,
      deep: i,
      immediate: r
    })
  )
}
function toRefs(e, t = {}) {
  if (!isRef(e)) return toRefs$1(e)
  const n = Array.isArray(e.value) ? Array.from({ length: e.value.length }) : {}
  for (const o in e.value)
    n[o] = customRef(() => ({
      get: () => e.value[o],
      set(n) {
        var i
        if (null == (i = toValue(t.replaceRef)) || i)
          if (Array.isArray(e.value)) {
            const t = [...e.value]
            ;(t[o] = n), (e.value = t)
          } else {
            const t = { ...e.value, [o]: n }
            Object.setPrototypeOf(t, Object.getPrototypeOf(e.value)),
              (e.value = t)
          }
        else e.value[o] = n
      }
    }))
  return n
}
function tryOnBeforeMount(e, t = !0, n) {
  getLifeCycleTarget(n) ? onBeforeMount(e, n) : t ? e() : nextTick(e)
}
function tryOnBeforeUnmount(e, t) {
  getLifeCycleTarget(t) && onBeforeUnmount(e, t)
}
function tryOnMounted(e, t = !0, n) {
  getLifeCycleTarget() ? onMounted(e, n) : t ? e() : nextTick(e)
}
function tryOnUnmounted(e, t) {
  getLifeCycleTarget(t) && onUnmounted(e, t)
}
function createUntil(e, t = !1) {
  function n(
    n,
    { flush: o = 'sync', deep: i = !1, timeout: r, throwOnTimeout: a } = {}
  ) {
    let s = null
    const l = [
      new Promise((r) => {
        s = watch(
          e,
          (e) => {
            n(e) !== t &&
              (s ? s() : nextTick(() => (null == s ? void 0 : s())), r(e))
          },
          { flush: o, deep: i, immediate: !0 }
        )
      })
    ]
    return (
      null != r &&
        l.push(
          promiseTimeout(r, a)
            .then(() => toValue(e))
            .finally(() => (null == s ? void 0 : s()))
        ),
      Promise.race(l)
    )
  }
  function o(o, i) {
    if (!isRef(o)) return n((e) => e === o, i)
    const {
      flush: r = 'sync',
      deep: a = !1,
      timeout: s,
      throwOnTimeout: l
    } = null != i ? i : {}
    let c = null
    const d = [
      new Promise((n) => {
        c = watch(
          [e, o],
          ([e, o]) => {
            t !== (e === o) &&
              (c ? c() : nextTick(() => (null == c ? void 0 : c())), n(e))
          },
          { flush: r, deep: a, immediate: !0 }
        )
      })
    ]
    return (
      null != s &&
        d.push(
          promiseTimeout(s, l)
            .then(() => toValue(e))
            .finally(() => (null == c || c(), toValue(e)))
        ),
      Promise.race(d)
    )
  }
  function i(e) {
    return n((e) => Boolean(e), e)
  }
  function r(e) {
    return o(null, e)
  }
  function a(e) {
    return o(void 0, e)
  }
  function s(e) {
    return n(Number.isNaN, e)
  }
  function l(e, t) {
    return n((t) => {
      const n = Array.from(t)
      return n.includes(e) || n.includes(toValue(e))
    }, t)
  }
  function c(e) {
    return d(1, e)
  }
  function d(e = 1, t) {
    let o = -1
    return n(() => ((o += 1), o >= e), t)
  }
  if (
    (__name(n, 'toMatch'),
    __name(o, 'toBe'),
    __name(i, 'toBeTruthy'),
    __name(r, 'toBeNull'),
    __name(a, 'toBeUndefined'),
    __name(s, 'toBeNaN'),
    __name(l, 'toContains'),
    __name(c, 'changed'),
    __name(d, 'changedTimes'),
    Array.isArray(toValue(e)))
  ) {
    return {
      toMatch: n,
      toContains: l,
      changed: c,
      changedTimes: d,
      get not() {
        return createUntil(e, !t)
      }
    }
  }
  return {
    toMatch: n,
    toBe: o,
    toBeTruthy: i,
    toBeNull: r,
    toBeNaN: s,
    toBeUndefined: a,
    changed: c,
    changedTimes: d,
    get not() {
      return createUntil(e, !t)
    }
  }
}
function until(e) {
  return createUntil(e)
}
function defaultComparator(e, t) {
  return e === t
}
function useArrayDifference(...e) {
  var t
  const n = e[0],
    o = e[1]
  let i = null != (t = e[2]) ? t : defaultComparator
  if ('string' == typeof i) {
    const e = i
    i = __name((t, n) => t[e] === n[e], 'compareFn')
  }
  return computed(() =>
    toValue(n).filter((e) => -1 === toValue(o).findIndex((t) => i(e, t)))
  )
}
function useArrayEvery(e, t) {
  return computed(() => toValue(e).every((e, n, o) => t(toValue(e), n, o)))
}
function useArrayFilter(e, t) {
  return computed(() =>
    toValue(e)
      .map((e) => toValue(e))
      .filter(t)
  )
}
function useArrayFind(e, t) {
  return computed(() =>
    toValue(toValue(e).find((e, n, o) => t(toValue(e), n, o)))
  )
}
function useArrayFindIndex(e, t) {
  return computed(() => toValue(e).findIndex((e, n, o) => t(toValue(e), n, o)))
}
function findLast(e, t) {
  let n = e.length
  for (; n-- > 0; ) if (t(e[n], n, e)) return e[n]
}
function useArrayFindLast(e, t) {
  return computed(() =>
    toValue(
      Array.prototype.findLast
        ? toValue(e).findLast((e, n, o) => t(toValue(e), n, o))
        : findLast(toValue(e), (e, n, o) => t(toValue(e), n, o))
    )
  )
}
function isArrayIncludesOptions(e) {
  return isObject$1(e) && containsProp(e, 'formIndex', 'comparator')
}
function useArrayIncludes(...e) {
  var t
  const n = e[0],
    o = e[1]
  let i = e[2],
    r = 0
  if (
    (isArrayIncludesOptions(i) &&
      ((r = null != (t = i.fromIndex) ? t : 0), (i = i.comparator)),
    'string' == typeof i)
  ) {
    const e = i
    i = __name((t, n) => t[e] === toValue(n), 'comparator')
  }
  return (
    (i = null != i ? i : (e, t) => e === toValue(t)),
    computed(() =>
      toValue(n)
        .slice(r)
        .some((e, t, n) => i(toValue(e), toValue(o), t, toValue(n)))
    )
  )
}
function useArrayJoin(e, t) {
  return computed(() =>
    toValue(e)
      .map((e) => toValue(e))
      .join(toValue(t))
  )
}
function useArrayMap(e, t) {
  return computed(() =>
    toValue(e)
      .map((e) => toValue(e))
      .map(t)
  )
}
function useArrayReduce(e, t, ...n) {
  const o = __name((e, n, o) => t(toValue(e), toValue(n), o), 'reduceCallback')
  return computed(() => {
    const t = toValue(e)
    return n.length
      ? t.reduce(o, 'function' == typeof n[0] ? toValue(n[0]()) : toValue(n[0]))
      : t.reduce(o)
  })
}
function useArraySome(e, t) {
  return computed(() => toValue(e).some((e, n, o) => t(toValue(e), n, o)))
}
function uniq(e) {
  return Array.from(new Set(e))
}
function uniqueElementsBy(e, t) {
  return e.reduce((n, o) => (n.some((n) => t(o, n, e)) || n.push(o), n), [])
}
function useArrayUnique(e, t) {
  return computed(() => {
    const n = toValue(e).map((e) => toValue(e))
    return t ? uniqueElementsBy(n, t) : uniq(n)
  })
}
function useCounter(e = 0, t = {}) {
  let n = unref(e)
  const o = ref(e),
    { max: i = Number.POSITIVE_INFINITY, min: r = Number.NEGATIVE_INFINITY } =
      t,
    a = __name(
      (e = 1) => (o.value = Math.max(Math.min(i, o.value + e), r)),
      'inc'
    ),
    s = __name(
      (e = 1) => (o.value = Math.min(Math.max(r, o.value - e), i)),
      'dec'
    ),
    l = __name(() => o.value, 'get2'),
    c = __name((e) => (o.value = Math.max(r, Math.min(i, e))), 'set2'),
    d = __name((e = n) => ((n = e), c(e)), 'reset')
  return { count: o, inc: a, dec: s, get: l, set: c, reset: d }
}
__name(set, 'set'),
  __name(watchWithFilter, 'watchWithFilter'),
  __name(watchPausable, 'watchPausable'),
  __name(syncRef, 'syncRef'),
  __name(syncRefs, 'syncRefs'),
  __name(toRefs, 'toRefs'),
  __name(tryOnBeforeMount, 'tryOnBeforeMount'),
  __name(tryOnBeforeUnmount, 'tryOnBeforeUnmount'),
  __name(tryOnMounted, 'tryOnMounted'),
  __name(tryOnUnmounted, 'tryOnUnmounted'),
  __name(createUntil, 'createUntil'),
  __name(until, 'until'),
  __name(defaultComparator, 'defaultComparator'),
  __name(useArrayDifference, 'useArrayDifference'),
  __name(useArrayEvery, 'useArrayEvery'),
  __name(useArrayFilter, 'useArrayFilter'),
  __name(useArrayFind, 'useArrayFind'),
  __name(useArrayFindIndex, 'useArrayFindIndex'),
  __name(findLast, 'findLast'),
  __name(useArrayFindLast, 'useArrayFindLast'),
  __name(isArrayIncludesOptions, 'isArrayIncludesOptions'),
  __name(useArrayIncludes, 'useArrayIncludes'),
  __name(useArrayJoin, 'useArrayJoin'),
  __name(useArrayMap, 'useArrayMap'),
  __name(useArrayReduce, 'useArrayReduce'),
  __name(useArraySome, 'useArraySome'),
  __name(uniq, 'uniq'),
  __name(uniqueElementsBy, 'uniqueElementsBy'),
  __name(useArrayUnique, 'useArrayUnique'),
  __name(useCounter, 'useCounter')
const REGEX_PARSE =
    /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[T\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/i,
  REGEX_FORMAT =
    /[YMDHhms]o|\[([^\]]+)\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g
function defaultMeridiem(e, t, n, o) {
  let i = e < 12 ? 'AM' : 'PM'
  return (
    o && (i = i.split('').reduce((e, t) => e + `${t}.`, '')),
    n ? i.toLowerCase() : i
  )
}
function formatOrdinal(e) {
  const t = ['th', 'st', 'nd', 'rd'],
    n = e % 100
  return e + (t[(n - 20) % 10] || t[n] || t[0])
}
function formatDate$1(e, t, n = {}) {
  var o
  const i = e.getFullYear(),
    r = e.getMonth(),
    a = e.getDate(),
    s = e.getHours(),
    l = e.getMinutes(),
    c = e.getSeconds(),
    d = e.getMilliseconds(),
    u = e.getDay(),
    p = null != (o = n.customMeridiem) ? o : defaultMeridiem,
    h = {
      Yo: __name(() => formatOrdinal(i), 'Yo'),
      YY: __name(() => String(i).slice(-2), 'YY'),
      YYYY: __name(() => i, 'YYYY'),
      M: __name(() => r + 1, 'M'),
      Mo: __name(() => formatOrdinal(r + 1), 'Mo'),
      MM: __name(() => `${r + 1}`.padStart(2, '0'), 'MM'),
      MMM: __name(
        () => e.toLocaleDateString(toValue(n.locales), { month: 'short' }),
        'MMM'
      ),
      MMMM: __name(
        () => e.toLocaleDateString(toValue(n.locales), { month: 'long' }),
        'MMMM'
      ),
      D: __name(() => String(a), 'D'),
      Do: __name(() => formatOrdinal(a), 'Do'),
      DD: __name(() => `${a}`.padStart(2, '0'), 'DD'),
      H: __name(() => String(s), 'H'),
      Ho: __name(() => formatOrdinal(s), 'Ho'),
      HH: __name(() => `${s}`.padStart(2, '0'), 'HH'),
      h: __name(() => `${s % 12 || 12}`.padStart(1, '0'), 'h'),
      ho: __name(() => formatOrdinal(s % 12 || 12), 'ho'),
      hh: __name(() => `${s % 12 || 12}`.padStart(2, '0'), 'hh'),
      m: __name(() => String(l), 'm'),
      mo: __name(() => formatOrdinal(l), 'mo'),
      mm: __name(() => `${l}`.padStart(2, '0'), 'mm'),
      s: __name(() => String(c), 's'),
      so: __name(() => formatOrdinal(c), 'so'),
      ss: __name(() => `${c}`.padStart(2, '0'), 'ss'),
      SSS: __name(() => `${d}`.padStart(3, '0'), 'SSS'),
      d: __name(() => u, 'd'),
      dd: __name(
        () => e.toLocaleDateString(toValue(n.locales), { weekday: 'narrow' }),
        'dd'
      ),
      ddd: __name(
        () => e.toLocaleDateString(toValue(n.locales), { weekday: 'short' }),
        'ddd'
      ),
      dddd: __name(
        () => e.toLocaleDateString(toValue(n.locales), { weekday: 'long' }),
        'dddd'
      ),
      A: __name(() => p(s, l), 'A'),
      AA: __name(() => p(s, l, !1, !0), 'AA'),
      a: __name(() => p(s, l, !0), 'a'),
      aa: __name(() => p(s, l, !0, !0), 'aa')
    }
  return t.replace(REGEX_FORMAT, (e, t) => {
    var n, o
    return null != (o = null != t ? t : null == (n = h[e]) ? void 0 : n.call(h))
      ? o
      : e
  })
}
function normalizeDate(e) {
  if (null === e) return new Date(Number.NaN)
  if (void 0 === e) return new Date()
  if (e instanceof Date) return new Date(e)
  if ('string' == typeof e && !/Z$/i.test(e)) {
    const t = e.match(REGEX_PARSE)
    if (t) {
      const e = t[2] - 1 || 0,
        n = (t[7] || '0').substring(0, 3)
      return new Date(t[1], e, t[3] || 1, t[4] || 0, t[5] || 0, t[6] || 0, n)
    }
  }
  return new Date(e)
}
function useDateFormat(e, t = 'HH:mm:ss', n = {}) {
  return computed(() => formatDate$1(normalizeDate(toValue(e)), toValue(t), n))
}
function useIntervalFn(e, t = 1e3, n = {}) {
  const { immediate: o = !0, immediateCallback: i = !1 } = n
  let r = null
  const a = ref(!1)
  function s() {
    r && (clearInterval(r), (r = null))
  }
  function l() {
    ;(a.value = !1), s()
  }
  function c() {
    const n = toValue(t)
    n <= 0 ||
      ((a.value = !0), i && e(), s(), a.value && (r = setInterval(e, n)))
  }
  if (
    (__name(s, 'clean'),
    __name(l, 'pause'),
    __name(c, 'resume'),
    o && isClient && c(),
    isRef(t) || 'function' == typeof t)
  ) {
    tryOnScopeDispose(
      watch(t, () => {
        a.value && isClient && c()
      })
    )
  }
  return tryOnScopeDispose(l), { isActive: a, pause: l, resume: c }
}
function useInterval(e = 1e3, t = {}) {
  const { controls: n = !1, immediate: o = !0, callback: i } = t,
    r = ref(0),
    a = __name(() => (r.value += 1), 'update'),
    s = __name(() => {
      r.value = 0
    }, 'reset'),
    l = useIntervalFn(
      i
        ? () => {
            a(), i(r.value)
          }
        : a,
      e,
      { immediate: o }
    )
  return n ? { counter: r, reset: s, ...l } : r
}
function useLastChanged(e, t = {}) {
  var n
  const o = ref(null != (n = t.initialValue) ? n : null)
  return watch(e, () => (o.value = timestamp()), t), o
}
function useTimeoutFn(e, t, n = {}) {
  const { immediate: o = !0 } = n,
    i = ref(!1)
  let r = null
  function a() {
    r && (clearTimeout(r), (r = null))
  }
  function s() {
    ;(i.value = !1), a()
  }
  function l(...n) {
    a(),
      (i.value = !0),
      (r = setTimeout(() => {
        ;(i.value = !1), (r = null), e(...n)
      }, toValue(t)))
  }
  return (
    __name(a, 'clear'),
    __name(s, 'stop'),
    __name(l, 'start'),
    o && ((i.value = !0), isClient && l()),
    tryOnScopeDispose(s),
    { isPending: readonly(i), start: l, stop: s }
  )
}
function useTimeout(e = 1e3, t = {}) {
  const { controls: n = !1, callback: o } = t,
    i = useTimeoutFn(null != o ? o : noop, e, t),
    r = computed(() => !i.isPending.value)
  return n ? { ready: r, ...i } : r
}
function useToNumber(e, t = {}) {
  const { method: n = 'parseFloat', radix: o, nanToZero: i } = t
  return computed(() => {
    let t = toValue(e)
    return (
      'string' == typeof t && (t = Number[n](t, o)),
      i && Number.isNaN(t) && (t = 0),
      t
    )
  })
}
function useToString(e) {
  return computed(() => `${toValue(e)}`)
}
function useToggle(e = !1, t = {}) {
  const { truthyValue: n = !0, falsyValue: o = !1 } = t,
    i = isRef(e),
    r = ref(e)
  function a(e) {
    if (arguments.length) return (r.value = e), r.value
    {
      const e = toValue(n)
      return (r.value = r.value === e ? toValue(o) : e), r.value
    }
  }
  return __name(a, 'toggle'), i ? a : [r, a]
}
function watchArray(e, t, n) {
  let o = (null == n ? void 0 : n.immediate)
    ? []
    : [...(e instanceof Function ? e() : Array.isArray(e) ? e : toValue(e))]
  return watch(
    e,
    (e, n, i) => {
      const r = Array.from({ length: o.length }),
        a = []
      for (const t of e) {
        let e = !1
        for (let n = 0; n < o.length; n++)
          if (!r[n] && t === o[n]) {
            ;(r[n] = !0), (e = !0)
            break
          }
        e || a.push(t)
      }
      const s = o.filter((e, t) => !r[t])
      t(e, o, a, s, i), (o = [...e])
    },
    n
  )
}
function watchAtMost(e, t, n) {
  const { count: o, ...i } = n,
    r = ref(0),
    a = watchWithFilter(
      e,
      (...e) => {
        ;(r.value += 1), r.value >= toValue(o) && nextTick(() => a()), t(...e)
      },
      i
    )
  return { count: r, stop: a }
}
function watchDebounced(e, t, n = {}) {
  const { debounce: o = 0, maxWait: i, ...r } = n
  return watchWithFilter(e, t, {
    ...r,
    eventFilter: debounceFilter(o, { maxWait: i })
  })
}
function watchDeep(e, t, n) {
  return watch(e, t, { ...n, deep: !0 })
}
function watchIgnorable(e, t, n = {}) {
  const { eventFilter: o = bypassFilter, ...i } = n,
    r = createFilterWrapper(o, t)
  let a, s, l
  if ('sync' === i.flush) {
    const t = ref(!1)
    ;(s = __name(() => {}, 'ignorePrevAsyncUpdates')),
      (a = __name((e) => {
        ;(t.value = !0), e(), (t.value = !1)
      }, 'ignoreUpdates')),
      (l = watch(
        e,
        (...e) => {
          t.value || r(...e)
        },
        i
      ))
  } else {
    const t = [],
      n = ref(0),
      o = ref(0)
    ;(s = __name(() => {
      n.value = o.value
    }, 'ignorePrevAsyncUpdates')),
      t.push(
        watch(
          e,
          () => {
            o.value++
          },
          { ...i, flush: 'sync' }
        )
      ),
      (a = __name((e) => {
        const t = o.value
        e(), (n.value += o.value - t)
      }, 'ignoreUpdates')),
      t.push(
        watch(
          e,
          (...e) => {
            const t = n.value > 0 && n.value === o.value
            ;(n.value = 0), (o.value = 0), t || r(...e)
          },
          i
        )
      ),
      (l = __name(() => {
        t.forEach((e) => e())
      }, 'stop'))
  }
  return { stop: l, ignoreUpdates: a, ignorePrevAsyncUpdates: s }
}
function watchImmediate(e, t, n) {
  return watch(e, t, { ...n, immediate: !0 })
}
function watchOnce(e, t, n) {
  const o = watch(e, (...e) => (nextTick(() => o()), t(...e)), n)
  return o
}
function watchThrottled(e, t, n = {}) {
  const { throttle: o = 0, trailing: i = !0, leading: r = !0, ...a } = n
  return watchWithFilter(e, t, { ...a, eventFilter: throttleFilter(o, i, r) })
}
function watchTriggerable(e, t, n = {}) {
  let o
  function i() {
    if (!o) return
    const e = o
    ;(o = void 0), e()
  }
  function r(e) {
    o = e
  }
  __name(i, 'onEffect'), __name(r, 'onCleanup')
  const a = __name((e, n) => (i(), t(e, n, r)), '_cb'),
    s = watchIgnorable(e, a, n),
    { ignoreUpdates: l } = s,
    c = __name(() => {
      let t
      return (
        l(() => {
          t = a(getWatchSources(e), getOldValue(e))
        }),
        t
      )
    }, 'trigger')
  return { ...s, trigger: c }
}
function getWatchSources(e) {
  return isReactive(e)
    ? e
    : Array.isArray(e)
      ? e.map((e) => toValue(e))
      : toValue(e)
}
function getOldValue(e) {
  return Array.isArray(e) ? e.map(() => {}) : void 0
}
function whenever(e, t, n) {
  const o = watch(
    e,
    (e, i, r) => {
      e && ((null == n ? void 0 : n.once) && nextTick(() => o()), t(e, i, r))
    },
    { ...n, once: !1 }
  )
  return o
}
function computedAsync(e, t, n) {
  let o
  o = isRef(n) ? { evaluating: n } : n || {}
  const { lazy: i = !1, evaluating: r, shallow: a = !0, onError: s = noop } = o,
    l = ref(!i),
    c = a ? shallowRef(t) : ref(t)
  let d = 0
  return (
    watchEffect(async (t) => {
      if (!l.value) return
      d++
      const n = d
      let o = !1
      r &&
        Promise.resolve().then(() => {
          r.value = !0
        })
      try {
        const i = await e((e) => {
          t(() => {
            r && (r.value = !1), o || e()
          })
        })
        n === d && (c.value = i)
      } catch (e2) {
        s(e2)
      } finally {
        r && n === d && (r.value = !1), (o = !0)
      }
    }),
    i ? computed(() => ((l.value = !0), c.value)) : c
  )
}
function computedInject(e, t, n, o) {
  let i = inject(e)
  return (
    n && (i = inject(e, n)),
    o && (i = inject(e, n, o)),
    computed(
      'function' == typeof t
        ? (e) => t(i, e)
        : { get: __name((e) => t.get(i, e), 'get'), set: t.set }
    )
  )
}
function createReusableTemplate(e = {}) {
  if (!isVue3 && !version.startsWith('2.7.')) return void 0
  const { inheritAttrs: t = !0 } = e,
    n = shallowRef(),
    o = defineComponent({
      setup:
        (e, { slots: t }) =>
        () => {
          n.value = t.default
        }
    }),
    i = defineComponent({
      inheritAttrs: t,
      setup:
        (e, { attrs: o, slots: i }) =>
        () => {
          var e
          n.value
          const r =
            null == (e = n.value)
              ? void 0
              : e.call(n, { ...keysToCamelKebabCase(o), $slots: i })
          return t && 1 === (null == r ? void 0 : r.length) ? r[0] : r
        }
    })
  return makeDestructurable({ define: o, reuse: i }, [o, i])
}
function keysToCamelKebabCase(e) {
  const t = {}
  for (const n in e) t[camelize(n)] = e[n]
  return t
}
function createTemplatePromise(e = {}) {
  if (!isVue3) return void 0
  let t = 0
  const n = ref([])
  function o(...o) {
    const i = shallowReactive({
      key: t++,
      args: o,
      promise: void 0,
      resolve: __name(() => {}, 'resolve'),
      reject: __name(() => {}, 'reject'),
      isResolving: !1,
      options: e
    })
    return (
      n.value.push(i),
      (i.promise = new Promise((e, t) => {
        ;(i.resolve = (t) => ((i.isResolving = !0), e(t))), (i.reject = t)
      }).finally(() => {
        i.promise = void 0
        const e = n.value.indexOf(i)
        ;-1 !== e && n.value.splice(e, 1)
      })),
      i.promise
    )
  }
  function i(...t) {
    return e.singleton && n.value.length > 0 ? n.value[0].promise : o(...t)
  }
  __name(o, 'create'), __name(i, 'start')
  const r = defineComponent((t, { slots: o }) => {
    const i = __name(
      () =>
        n.value.map((e) => {
          var t
          return h(
            Fragment,
            { key: e.key },
            null == (t = o.default) ? void 0 : t.call(o, e)
          )
        }),
      'renderList'
    )
    return e.transition ? () => h(TransitionGroup, e.transition, i) : i
  })
  return (r.start = i), r
}
function createUnrefFn(e) {
  return function (...t) {
    return e.apply(
      this,
      t.map((e) => toValue(e))
    )
  }
}
__name(defaultMeridiem, 'defaultMeridiem'),
  __name(formatOrdinal, 'formatOrdinal'),
  __name(formatDate$1, 'formatDate$1'),
  __name(normalizeDate, 'normalizeDate'),
  __name(useDateFormat, 'useDateFormat'),
  __name(useIntervalFn, 'useIntervalFn'),
  __name(useInterval, 'useInterval'),
  __name(useLastChanged, 'useLastChanged'),
  __name(useTimeoutFn, 'useTimeoutFn'),
  __name(useTimeout, 'useTimeout'),
  __name(useToNumber, 'useToNumber'),
  __name(useToString, 'useToString'),
  __name(useToggle, 'useToggle'),
  __name(watchArray, 'watchArray'),
  __name(watchAtMost, 'watchAtMost'),
  __name(watchDebounced, 'watchDebounced'),
  __name(watchDeep, 'watchDeep'),
  __name(watchIgnorable, 'watchIgnorable'),
  __name(watchImmediate, 'watchImmediate'),
  __name(watchOnce, 'watchOnce'),
  __name(watchThrottled, 'watchThrottled'),
  __name(watchTriggerable, 'watchTriggerable'),
  __name(getWatchSources, 'getWatchSources'),
  __name(getOldValue, 'getOldValue'),
  __name(whenever, 'whenever'),
  __name(computedAsync, 'computedAsync'),
  __name(computedInject, 'computedInject'),
  __name(createReusableTemplate, 'createReusableTemplate'),
  __name(keysToCamelKebabCase, 'keysToCamelKebabCase'),
  __name(createTemplatePromise, 'createTemplatePromise'),
  __name(createUnrefFn, 'createUnrefFn')
const defaultWindow = isClient ? window : void 0,
  defaultDocument = isClient ? window.document : void 0,
  defaultNavigator = isClient ? window.navigator : void 0,
  defaultLocation = isClient ? window.location : void 0
function unrefElement(e) {
  var t
  const n = toValue(e)
  return null != (t = null == n ? void 0 : n.$el) ? t : n
}
function useEventListener(...e) {
  let t, n, o, i
  if (
    ('string' == typeof e[0] || Array.isArray(e[0])
      ? (([n, o, i] = e), (t = defaultWindow))
      : ([t, n, o, i] = e),
    !t)
  )
    return noop
  Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o])
  const r = [],
    a = __name(() => {
      r.forEach((e) => e()), (r.length = 0)
    }, 'cleanup'),
    s = __name(
      (e, t, n, o) => (
        e.addEventListener(t, n, o), () => e.removeEventListener(t, n, o)
      ),
      'register'
    ),
    l = watch(
      () => [unrefElement(t), toValue(i)],
      ([e, t]) => {
        if ((a(), !e)) return
        const i = isObject$1(t) ? { ...t } : t
        r.push(...n.flatMap((t) => o.map((n) => s(e, t, n, i))))
      },
      { immediate: !0, flush: 'post' }
    ),
    c = __name(() => {
      l(), a()
    }, 'stop')
  return tryOnScopeDispose(c), c
}
__name(unrefElement, 'unrefElement'),
  __name(useEventListener, 'useEventListener')
let _iOSWorkaround = !1
function onClickOutside(e, t, n = {}) {
  const {
    window: o = defaultWindow,
    ignore: i = [],
    capture: r = !0,
    detectIframe: a = !1
  } = n
  if (!o) return noop
  isIOS &&
    !_iOSWorkaround &&
    ((_iOSWorkaround = !0),
    Array.from(o.document.body.children).forEach((e) =>
      e.addEventListener('click', noop)
    ),
    o.document.documentElement.addEventListener('click', noop))
  let s = !0
  const l = __name(
    (e) =>
      toValue(i).some((t) => {
        if ('string' == typeof t)
          return Array.from(o.document.querySelectorAll(t)).some(
            (t) => t === e.target || e.composedPath().includes(t)
          )
        {
          const n = unrefElement(t)
          return n && (e.target === n || e.composedPath().includes(n))
        }
      }),
    'shouldIgnore'
  )
  function c(e) {
    const t = toValue(e)
    return t && 16 === t.$.subTree.shapeFlag
  }
  function d(e, t) {
    const n = toValue(e),
      o = n.$.subTree && n.$.subTree.children
    return (
      !(null == o || !Array.isArray(o)) &&
      o.some((e) => e.el === t.target || t.composedPath().includes(e.el))
    )
  }
  __name(c, 'hasMultipleRoots'), __name(d, 'checkMultipleRoots')
  const u = __name((n) => {
    const o = unrefElement(e)
    null != n.target &&
      (o instanceof Element || !c(e) || !d(e, n)) &&
      o &&
      o !== n.target &&
      !n.composedPath().includes(o) &&
      (0 === n.detail && (s = !l(n)), s ? t(n) : (s = !0))
  }, 'listener')
  let p = !1
  const h = [
    useEventListener(
      o,
      'click',
      (e) => {
        p ||
          ((p = !0),
          setTimeout(() => {
            p = !1
          }, 0),
          u(e))
      },
      { passive: !0, capture: r }
    ),
    useEventListener(
      o,
      'pointerdown',
      (t) => {
        const n = unrefElement(e)
        s = !l(t) && !(!n || t.composedPath().includes(n))
      },
      { passive: !0 }
    ),
    a &&
      useEventListener(o, 'blur', (n) => {
        setTimeout(() => {
          var i
          const r = unrefElement(e)
          'IFRAME' !==
            (null == (i = o.document.activeElement) ? void 0 : i.tagName) ||
            (null == r ? void 0 : r.contains(o.document.activeElement)) ||
            t(n)
        }, 0)
      })
  ].filter(Boolean)
  return __name(() => h.forEach((e) => e()), 'stop')
}
function createKeyPredicate(e) {
  return 'function' == typeof e
    ? e
    : 'string' == typeof e
      ? (t) => t.key === e
      : Array.isArray(e)
        ? (t) => e.includes(t.key)
        : () => !0
}
function onKeyStroke(...e) {
  let t,
    n,
    o = {}
  3 === e.length
    ? ((t = e[0]), (n = e[1]), (o = e[2]))
    : 2 === e.length
      ? 'object' == typeof e[1]
        ? ((t = !0), (n = e[0]), (o = e[1]))
        : ((t = e[0]), (n = e[1]))
      : ((t = !0), (n = e[0]))
  const {
      target: i = defaultWindow,
      eventName: r = 'keydown',
      passive: a = !1,
      dedupe: s = !1
    } = o,
    l = createKeyPredicate(t)
  return useEventListener(
    i,
    r,
    __name((e) => {
      ;(e.repeat && toValue(s)) || (l(e) && n(e))
    }, 'listener'),
    a
  )
}
function onKeyDown(e, t, n = {}) {
  return onKeyStroke(e, t, { ...n, eventName: 'keydown' })
}
function onKeyPressed(e, t, n = {}) {
  return onKeyStroke(e, t, { ...n, eventName: 'keypress' })
}
function onKeyUp(e, t, n = {}) {
  return onKeyStroke(e, t, { ...n, eventName: 'keyup' })
}
__name(onClickOutside, 'onClickOutside'),
  __name(createKeyPredicate, 'createKeyPredicate'),
  __name(onKeyStroke, 'onKeyStroke'),
  __name(onKeyDown, 'onKeyDown'),
  __name(onKeyPressed, 'onKeyPressed'),
  __name(onKeyUp, 'onKeyUp')
const DEFAULT_DELAY = 500,
  DEFAULT_THRESHOLD = 10
function onLongPress(e, t, n) {
  var o, i
  const r = computed(() => unrefElement(e))
  let a,
    s,
    l,
    c = !1
  function d() {
    a && (clearTimeout(a), (a = void 0)), (s = void 0), (l = void 0), (c = !1)
  }
  function u(e) {
    var t, o, i
    const [a, u, p] = [l, s, c]
    if ((d(), !(null == n ? void 0 : n.onMouseUp) || !u || !a)) return
    if (
      (null == (t = null == n ? void 0 : n.modifiers) ? void 0 : t.self) &&
      e.target !== r.value
    )
      return
    ;(null == (o = null == n ? void 0 : n.modifiers) ? void 0 : o.prevent) &&
      e.preventDefault(),
      (null == (i = null == n ? void 0 : n.modifiers) ? void 0 : i.stop) &&
        e.stopPropagation()
    const h = e.x - u.x,
      m = e.y - u.y,
      f = Math.sqrt(h * h + m * m)
    n.onMouseUp(e.timeStamp - a, f, p)
  }
  function p(e) {
    var o, i, u, p
    ;((null == (o = null == n ? void 0 : n.modifiers) ? void 0 : o.self) &&
      e.target !== r.value) ||
      (d(),
      (null == (i = null == n ? void 0 : n.modifiers) ? void 0 : i.prevent) &&
        e.preventDefault(),
      (null == (u = null == n ? void 0 : n.modifiers) ? void 0 : u.stop) &&
        e.stopPropagation(),
      (s = { x: e.x, y: e.y }),
      (l = e.timeStamp),
      (a = setTimeout(
        () => {
          ;(c = !0), t(e)
        },
        null != (p = null == n ? void 0 : n.delay) ? p : DEFAULT_DELAY
      )))
  }
  function h(e) {
    var t, o, i, a
    if (
      (null == (t = null == n ? void 0 : n.modifiers) ? void 0 : t.self) &&
      e.target !== r.value
    )
      return
    if (!s || !1 === (null == n ? void 0 : n.distanceThreshold)) return
    ;(null == (o = null == n ? void 0 : n.modifiers) ? void 0 : o.prevent) &&
      e.preventDefault(),
      (null == (i = null == n ? void 0 : n.modifiers) ? void 0 : i.stop) &&
        e.stopPropagation()
    const l = e.x - s.x,
      c = e.y - s.y
    Math.sqrt(l * l + c * c) >=
      (null != (a = null == n ? void 0 : n.distanceThreshold)
        ? a
        : DEFAULT_THRESHOLD) && d()
  }
  __name(d, 'clear'),
    __name(u, 'onRelease'),
    __name(p, 'onDown'),
    __name(h, 'onMove')
  const m = {
      capture:
        null == (o = null == n ? void 0 : n.modifiers) ? void 0 : o.capture,
      once: null == (i = null == n ? void 0 : n.modifiers) ? void 0 : i.once
    },
    f = [
      useEventListener(r, 'pointerdown', p, m),
      useEventListener(r, 'pointermove', h, m),
      useEventListener(r, ['pointerup', 'pointerleave'], u, m)
    ]
  return __name(() => f.forEach((e) => e()), 'stop')
}
function isFocusedElementEditable() {
  const { activeElement: e, body: t } = document
  if (!e) return !1
  if (e === t) return !1
  switch (e.tagName) {
    case 'INPUT':
    case 'TEXTAREA':
      return !0
  }
  return e.hasAttribute('contenteditable')
}
function isTypedCharValid({ keyCode: e, metaKey: t, ctrlKey: n, altKey: o }) {
  return (
    !(t || n || o) &&
    ((e >= 48 && e <= 57) || (e >= 65 && e <= 90) || (e >= 97 && e <= 122))
  )
}
function onStartTyping(e, t = {}) {
  const { document: n = defaultDocument } = t
  n &&
    useEventListener(
      n,
      'keydown',
      __name((t) => {
        !isFocusedElementEditable() && isTypedCharValid(t) && e(t)
      }, 'keydown'),
      { passive: !0 }
    )
}
function templateRef(e, t = null) {
  const n = getCurrentInstance()
  let o = __name(() => {}, '_trigger')
  const i = customRef(
    (i, r) => (
      (o = r),
      {
        get() {
          var o, r
          return (
            i(),
            null !=
            (r =
              null == (o = null == n ? void 0 : n.proxy) ? void 0 : o.$refs[e])
              ? r
              : t
          )
        },
        set() {}
      }
    )
  )
  return tryOnMounted(o), onUpdated(o), i
}
function useMounted() {
  const e = ref(!1),
    t = getCurrentInstance()
  return (
    t &&
      onMounted(
        () => {
          e.value = !0
        },
        isVue2 ? void 0 : t
      ),
    e
  )
}
function useSupported(e) {
  const t = useMounted()
  return computed(() => (t.value, Boolean(e())))
}
function useMutationObserver(e, t, n = {}) {
  const { window: o = defaultWindow, ...i } = n
  let r
  const a = useSupported(() => o && 'MutationObserver' in o),
    s = __name(() => {
      r && (r.disconnect(), (r = void 0))
    }, 'cleanup'),
    l = computed(() => {
      const t = toValue(e),
        n = (Array.isArray(t) ? t : [t]).map(unrefElement).filter(notNullish)
      return new Set(n)
    }),
    c = watch(
      () => l.value,
      (e) => {
        s(),
          a.value &&
            e.size &&
            ((r = new MutationObserver(t)), e.forEach((e) => r.observe(e, i)))
      },
      { immediate: !0, flush: 'post' }
    ),
    d = __name(() => (null == r ? void 0 : r.takeRecords()), 'takeRecords'),
    u = __name(() => {
      c(), s()
    }, 'stop')
  return tryOnScopeDispose(u), { isSupported: a, stop: u, takeRecords: d }
}
function useActiveElement(e = {}) {
  var t
  const {
      window: n = defaultWindow,
      deep: o = !0,
      triggerOnRemoval: i = !1
    } = e,
    r = null != (t = e.document) ? t : null == n ? void 0 : n.document,
    a = __name(() => {
      var e
      let t = null == r ? void 0 : r.activeElement
      if (o)
        for (; null == t ? void 0 : t.shadowRoot; )
          t =
            null == (e = null == t ? void 0 : t.shadowRoot)
              ? void 0
              : e.activeElement
      return t
    }, 'getDeepActiveElement'),
    s = ref(),
    l = __name(() => {
      s.value = a()
    }, 'trigger')
  return (
    n &&
      (useEventListener(
        n,
        'blur',
        (e) => {
          null === e.relatedTarget && l()
        },
        !0
      ),
      useEventListener(n, 'focus', l, !0)),
    i &&
      useMutationObserver(
        r,
        (e) => {
          e.filter((e) => e.removedNodes.length)
            .map((e) => Array.from(e.removedNodes))
            .flat()
            .forEach((e) => {
              e === s.value && l()
            })
        },
        { childList: !0, subtree: !0 }
      ),
    l(),
    s
  )
}
function useRafFn(e, t = {}) {
  const { immediate: n = !0, fpsLimit: o, window: i = defaultWindow } = t,
    r = ref(!1),
    a = o ? 1e3 / o : null
  let s = 0,
    l = null
  function c(t) {
    if (!r.value || !i) return
    s || (s = t)
    const n = t - s
    ;(a && n < a) || ((s = t), e({ delta: n, timestamp: t })),
      (l = i.requestAnimationFrame(c))
  }
  function d() {
    !r.value && i && ((r.value = !0), (s = 0), (l = i.requestAnimationFrame(c)))
  }
  function u() {
    ;(r.value = !1), null != l && i && (i.cancelAnimationFrame(l), (l = null))
  }
  return (
    __name(c, 'loop'),
    __name(d, 'resume'),
    __name(u, 'pause'),
    n && d(),
    tryOnScopeDispose(u),
    { isActive: readonly(r), pause: u, resume: d }
  )
}
function useAnimate(e, t, n) {
  let o, i
  isObject$1(n)
    ? ((o = n),
      (i = objectOmit(n, [
        'window',
        'immediate',
        'commitStyles',
        'persist',
        'onReady',
        'onError'
      ])))
    : ((o = { duration: n }), (i = n))
  const {
      window: r = defaultWindow,
      immediate: a = !0,
      commitStyles: s,
      persist: l,
      playbackRate: c = 1,
      onReady: d,
      onError: u = __name((e) => {
        console.error(e)
      }, 'onError')
    } = o,
    p = useSupported(
      () => r && HTMLElement && 'animate' in HTMLElement.prototype
    ),
    h = shallowRef(void 0),
    m = shallowReactive({
      startTime: null,
      currentTime: null,
      timeline: null,
      playbackRate: c,
      pending: !1,
      playState: a ? 'idle' : 'paused',
      replaceState: 'active'
    }),
    f = computed(() => m.pending),
    _ = computed(() => m.playState),
    g = computed(() => m.replaceState),
    v = computed({
      get: () => m.startTime,
      set(e) {
        ;(m.startTime = e), h.value && (h.value.startTime = e)
      }
    }),
    y = computed({
      get: () => m.currentTime,
      set(e) {
        ;(m.currentTime = e), h.value && ((h.value.currentTime = e), L())
      }
    }),
    b = computed({
      get: () => m.timeline,
      set(e) {
        ;(m.timeline = e), h.value && (h.value.timeline = e)
      }
    }),
    S = computed({
      get: () => m.playbackRate,
      set(e) {
        ;(m.playbackRate = e), h.value && (h.value.playbackRate = e)
      }
    }),
    C = __name(() => {
      if (h.value)
        try {
          h.value.play(), L()
        } catch (e2) {
          A(), u(e2)
        }
      else I()
    }, 'play'),
    w = __name(() => {
      var e
      try {
        null == (e = h.value) || e.pause(), A()
      } catch (e2) {
        u(e2)
      }
    }, 'pause'),
    k = __name(() => {
      var e
      h.value || I()
      try {
        null == (e = h.value) || e.reverse(), L()
      } catch (e2) {
        A(), u(e2)
      }
    }, 'reverse'),
    x = __name(() => {
      var e
      try {
        null == (e = h.value) || e.finish(), A()
      } catch (e2) {
        u(e2)
      }
    }, 'finish'),
    E = __name(() => {
      var e
      try {
        null == (e = h.value) || e.cancel(), A()
      } catch (e2) {
        u(e2)
      }
    }, 'cancel')
  function I(n) {
    const o = unrefElement(e)
    p.value &&
      o &&
      (h.value || (h.value = o.animate(toValue(t), i)),
      l && h.value.persist(),
      1 !== c && (h.value.playbackRate = c),
      n && !a ? h.value.pause() : L(),
      null == d || d(h.value))
  }
  watch(
    () => unrefElement(e),
    (e) => {
      e && I()
    }
  ),
    watch(
      () => t,
      (t) => {
        h.value && I(),
          !unrefElement(e) &&
            h.value &&
            (h.value.effect = new KeyframeEffect(
              unrefElement(e),
              toValue(t),
              i
            ))
      },
      { deep: !0 }
    ),
    tryOnMounted(() => I(!0), !1),
    tryOnScopeDispose(E),
    __name(I, 'update'),
    useEventListener(h, ['cancel', 'finish', 'remove'], A),
    useEventListener(h, 'finish', () => {
      var e
      s && (null == (e = h.value) || e.commitStyles())
    })
  const { resume: T, pause: $ } = useRafFn(
    () => {
      h.value &&
        ((m.pending = h.value.pending),
        (m.playState = h.value.playState),
        (m.replaceState = h.value.replaceState),
        (m.startTime = h.value.startTime),
        (m.currentTime = h.value.currentTime),
        (m.timeline = h.value.timeline),
        (m.playbackRate = h.value.playbackRate))
    },
    { immediate: !1 }
  )
  function L() {
    p.value && T()
  }
  function A() {
    p.value && r && r.requestAnimationFrame($)
  }
  return (
    __name(L, 'syncResume'),
    __name(A, 'syncPause'),
    {
      isSupported: p,
      animate: h,
      play: C,
      pause: w,
      reverse: k,
      finish: x,
      cancel: E,
      pending: f,
      playState: _,
      replaceState: g,
      startTime: v,
      currentTime: y,
      timeline: b,
      playbackRate: S
    }
  )
}
function useAsyncQueue(e, t) {
  const {
      interrupt: n = !0,
      onError: o = noop,
      onFinished: i = noop,
      signal: r
    } = t || {},
    a = 'aborted',
    s = 'fulfilled',
    l = 'pending',
    c = 'rejected',
    d = reactive(
      Array.from(Array.from({ length: e.length }), () => ({
        state: l,
        data: null
      }))
    ),
    u = ref(-1)
  if (!e || 0 === e.length) return i(), { activeIndex: u, result: d }
  function p(e, t) {
    u.value++, (d[u.value].data = t), (d[u.value].state = e)
  }
  return (
    __name(p, 'updateResult'),
    e.reduce(
      (t, l) =>
        t
          .then((t) => {
            var o
            if (null == r ? void 0 : r.aborted)
              return void p(a, new Error('aborted'))
            if ((null == (o = d[u.value]) ? void 0 : o.state) === c && n)
              return void i()
            const h = l(t).then(
              (t) => (p(s, t), u.value === e.length - 1 && i(), t)
            )
            return r ? Promise.race([h, whenAborted(r)]) : h
          })
          .catch((e) =>
            (null == r ? void 0 : r.aborted) ? (p(a, e), e) : (p(c, e), o(), e)
          ),
      Promise.resolve()
    ),
    { activeIndex: u, result: d }
  )
}
function whenAborted(e) {
  return new Promise((t, n) => {
    const o = new Error('aborted')
    e.aborted ? n(o) : e.addEventListener('abort', () => n(o), { once: !0 })
  })
}
function useAsyncState(e, t, n) {
  const {
      immediate: o = !0,
      delay: i = 0,
      onError: r = noop,
      onSuccess: a = noop,
      resetOnExecute: s = !0,
      shallow: l = !0,
      throwError: c
    } = null != n ? n : {},
    d = l ? shallowRef(t) : ref(t),
    u = ref(!1),
    p = ref(!1),
    h = shallowRef(void 0)
  async function m(n = 0, ...o) {
    s && (d.value = t),
      (h.value = void 0),
      (u.value = !1),
      (p.value = !0),
      n > 0 && (await promiseTimeout(n))
    const i = 'function' == typeof e ? e(...o) : e
    try {
      const e = await i
      ;(d.value = e), (u.value = !0), a(e)
    } catch (e2) {
      if (((h.value = e2), r(e2), c)) throw e2
    } finally {
      p.value = !1
    }
    return d.value
  }
  __name(m, 'execute'), o && m(i)
  const f = { state: d, isReady: u, isLoading: p, error: h, execute: m }
  function _() {
    return new Promise((e, t) => {
      until(p)
        .toBe(!1)
        .then(() => e(f))
        .catch(t)
    })
  }
  return (
    __name(_, 'waitUntilIsLoaded'), { ...f, then: (e, t) => _().then(e, t) }
  )
}
__name(onLongPress, 'onLongPress'),
  __name(isFocusedElementEditable, 'isFocusedElementEditable'),
  __name(isTypedCharValid, 'isTypedCharValid'),
  __name(onStartTyping, 'onStartTyping'),
  __name(templateRef, 'templateRef'),
  __name(useMounted, 'useMounted'),
  __name(useSupported, 'useSupported'),
  __name(useMutationObserver, 'useMutationObserver'),
  __name(useActiveElement, 'useActiveElement'),
  __name(useRafFn, 'useRafFn'),
  __name(useAnimate, 'useAnimate'),
  __name(useAsyncQueue, 'useAsyncQueue'),
  __name(whenAborted, 'whenAborted'),
  __name(useAsyncState, 'useAsyncState')
const defaults = {
  array: __name((e) => JSON.stringify(e), 'array'),
  object: __name((e) => JSON.stringify(e), 'object'),
  set: __name((e) => JSON.stringify(Array.from(e)), 'set'),
  map: __name((e) => JSON.stringify(Object.fromEntries(e)), 'map'),
  null: __name(() => '', 'null')
}
function getDefaultSerialization(e) {
  return e
    ? e instanceof Map
      ? defaults.map
      : e instanceof Set
        ? defaults.set
        : Array.isArray(e)
          ? defaults.array
          : defaults.object
    : defaults.null
}
function useBase64(e, t) {
  const n = ref(''),
    o = ref()
  function i() {
    if (isClient)
      return (
        (o.value = new Promise((n, o) => {
          try {
            const i = toValue(e)
            if (null == i) n('')
            else if ('string' == typeof i)
              n(blobToBase64(new Blob([i], { type: 'text/plain' })))
            else if (i instanceof Blob) n(blobToBase64(i))
            else if (i instanceof ArrayBuffer)
              n(window.btoa(String.fromCharCode(...new Uint8Array(i))))
            else if (i instanceof HTMLCanvasElement)
              n(
                i.toDataURL(
                  null == t ? void 0 : t.type,
                  null == t ? void 0 : t.quality
                )
              )
            else if (i instanceof HTMLImageElement) {
              const e = i.cloneNode(!1)
              ;(e.crossOrigin = 'Anonymous'),
                imgLoaded(e)
                  .then(() => {
                    const o = document.createElement('canvas'),
                      i = o.getContext('2d')
                    ;(o.width = e.width),
                      (o.height = e.height),
                      i.drawImage(e, 0, 0, o.width, o.height),
                      n(
                        o.toDataURL(
                          null == t ? void 0 : t.type,
                          null == t ? void 0 : t.quality
                        )
                      )
                  })
                  .catch(o)
            } else {
              if ('object' == typeof i) {
                const e = (
                  (null == t ? void 0 : t.serializer) ||
                  getDefaultSerialization(i)
                )(i)
                return n(
                  blobToBase64(new Blob([e], { type: 'application/json' }))
                )
              }
              o(new Error('target is unsupported types'))
            }
          } catch (i) {
            o(i)
          }
        })),
        o.value.then((e) => (n.value = e)),
        o.value
      )
  }
  return (
    __name(i, 'execute'),
    isRef(e) || 'function' == typeof e ? watch(e, i, { immediate: !0 }) : i(),
    { base64: n, promise: o, execute: i }
  )
}
function imgLoaded(e) {
  return new Promise((t, n) => {
    e.complete
      ? t()
      : ((e.onload = () => {
          t()
        }),
        (e.onerror = n))
  })
}
function blobToBase64(e) {
  return new Promise((t, n) => {
    const o = new FileReader()
    ;(o.onload = (e) => {
      t(e.target.result)
    }),
      (o.onerror = n),
      o.readAsDataURL(e)
  })
}
function useBattery(e = {}) {
  const { navigator: t = defaultNavigator } = e,
    n = [
      'chargingchange',
      'chargingtimechange',
      'dischargingtimechange',
      'levelchange'
    ],
    o = useSupported(
      () => t && 'getBattery' in t && 'function' == typeof t.getBattery
    ),
    i = ref(!1),
    r = ref(0),
    a = ref(0),
    s = ref(1)
  let l
  function c() {
    ;(i.value = this.charging),
      (r.value = this.chargingTime || 0),
      (a.value = this.dischargingTime || 0),
      (s.value = this.level)
  }
  return (
    __name(c, 'updateBatteryInfo'),
    o.value &&
      t.getBattery().then((e) => {
        ;(l = e), c.call(l), useEventListener(l, n, c, { passive: !0 })
      }),
    {
      isSupported: o,
      charging: i,
      chargingTime: r,
      dischargingTime: a,
      level: s
    }
  )
}
function useBluetooth(e) {
  let { acceptAllDevices: t = !1 } = e || {}
  const {
      filters: n,
      optionalServices: o,
      navigator: i = defaultNavigator
    } = e || {},
    r = useSupported(() => i && 'bluetooth' in i),
    a = shallowRef(void 0),
    s = shallowRef(null)
  async function l() {
    if (r.value) {
      ;(s.value = null), n && n.length > 0 && (t = !1)
      try {
        a.value = await (null == i
          ? void 0
          : i.bluetooth.requestDevice({
              acceptAllDevices: t,
              filters: n,
              optionalServices: o
            }))
      } catch (e) {
        s.value = e
      }
    }
  }
  watch(a, () => {
    u()
  }),
    __name(l, 'requestDevice')
  const c = ref(),
    d = computed(() => {
      var e
      return (null == (e = c.value) ? void 0 : e.connected) || !1
    })
  async function u() {
    if (((s.value = null), a.value && a.value.gatt)) {
      a.value.addEventListener('gattserverdisconnected', () => {})
      try {
        c.value = await a.value.gatt.connect()
      } catch (e) {
        s.value = e
      }
    }
  }
  return (
    __name(u, 'connectToBluetoothGATTServer'),
    tryOnMounted(() => {
      var e
      a.value && (null == (e = a.value.gatt) || e.connect())
    }),
    tryOnScopeDispose(() => {
      var e
      a.value && (null == (e = a.value.gatt) || e.disconnect())
    }),
    {
      isSupported: r,
      isConnected: d,
      device: a,
      requestDevice: l,
      server: c,
      error: s
    }
  )
}
function useMediaQuery(e, t = {}) {
  const { window: n = defaultWindow } = t,
    o = useSupported(
      () => n && 'matchMedia' in n && 'function' == typeof n.matchMedia
    )
  let i
  const r = ref(!1),
    a = __name((e) => {
      r.value = e.matches
    }, 'handler'),
    s = __name(() => {
      i &&
        ('removeEventListener' in i
          ? i.removeEventListener('change', a)
          : i.removeListener(a))
    }, 'cleanup'),
    l = watchEffect(() => {
      o.value &&
        (s(),
        (i = n.matchMedia(toValue(e))),
        'addEventListener' in i
          ? i.addEventListener('change', a)
          : i.addListener(a),
        (r.value = i.matches))
    })
  return (
    tryOnScopeDispose(() => {
      l(), s(), (i = void 0)
    }),
    r
  )
}
__name(getDefaultSerialization, 'getDefaultSerialization'),
  __name(useBase64, 'useBase64'),
  __name(imgLoaded, 'imgLoaded'),
  __name(blobToBase64, 'blobToBase64'),
  __name(useBattery, 'useBattery'),
  __name(useBluetooth, 'useBluetooth'),
  __name(useMediaQuery, 'useMediaQuery')
const breakpointsTailwind = {
    sm: 640,
    md: 768,
    lg: 1024,
    xl: 1280,
    '2xl': 1536
  },
  breakpointsBootstrapV5 = {
    xs: 0,
    sm: 576,
    md: 768,
    lg: 992,
    xl: 1200,
    xxl: 1400
  },
  breakpointsVuetifyV2 = { xs: 0, sm: 600, md: 960, lg: 1264, xl: 1904 },
  breakpointsVuetifyV3 = {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920,
    xxl: 2560
  },
  breakpointsVuetify = breakpointsVuetifyV2,
  breakpointsAntDesign = {
    xs: 480,
    sm: 576,
    md: 768,
    lg: 992,
    xl: 1200,
    xxl: 1600
  },
  breakpointsQuasar = { xs: 0, sm: 600, md: 1024, lg: 1440, xl: 1920 },
  breakpointsSematic = {
    mobileS: 320,
    mobileM: 375,
    mobileL: 425,
    tablet: 768,
    laptop: 1024,
    laptopL: 1440,
    desktop4K: 2560
  },
  breakpointsMasterCss = {
    '3xs': 360,
    '2xs': 480,
    xs: 600,
    sm: 768,
    md: 1024,
    lg: 1280,
    xl: 1440,
    '2xl': 1600,
    '3xl': 1920,
    '4xl': 2560
  },
  breakpointsPrimeFlex = { sm: 576, md: 768, lg: 992, xl: 1200 },
  breakpointsElement = { xs: 0, sm: 768, md: 992, lg: 1200, xl: 1920 }
function useBreakpoints(e, t = {}) {
  function n(t, n) {
    let o = toValue(e[toValue(t)])
    return (
      null != n && (o = increaseWithUnit(o, n)),
      'number' == typeof o && (o = `${o}px`),
      o
    )
  }
  __name(n, 'getValue2')
  const { window: o = defaultWindow, strategy: i = 'min-width' } = t
  function r(e) {
    return !!o && o.matchMedia(e).matches
  }
  __name(r, 'match')
  const a = __name(
      (e) => useMediaQuery(() => `(min-width: ${n(e)})`, t),
      'greaterOrEqual'
    ),
    s = __name(
      (e) => useMediaQuery(() => `(max-width: ${n(e)})`, t),
      'smallerOrEqual'
    ),
    l = Object.keys(e).reduce(
      (e, t) => (
        Object.defineProperty(e, t, {
          get: __name(() => ('min-width' === i ? a(t) : s(t)), 'get'),
          enumerable: !0,
          configurable: !0
        }),
        e
      ),
      {}
    )
  function c() {
    const t = Object.keys(e).map((e) => [e, a(e)])
    return computed(() => t.filter(([, e]) => e.value).map(([e]) => e))
  }
  return (
    __name(c, 'current'),
    Object.assign(l, {
      greaterOrEqual: a,
      smallerOrEqual: s,
      greater: (e) => useMediaQuery(() => `(min-width: ${n(e, 0.1)})`, t),
      smaller: (e) => useMediaQuery(() => `(max-width: ${n(e, -0.1)})`, t),
      between: (e, o) =>
        useMediaQuery(
          () => `(min-width: ${n(e)}) and (max-width: ${n(o, -0.1)})`,
          t
        ),
      isGreater: (e) => r(`(min-width: ${n(e, 0.1)})`),
      isGreaterOrEqual: (e) => r(`(min-width: ${n(e)})`),
      isSmaller: (e) => r(`(max-width: ${n(e, -0.1)})`),
      isSmallerOrEqual: (e) => r(`(max-width: ${n(e)})`),
      isInBetween: (e, t) =>
        r(`(min-width: ${n(e)}) and (max-width: ${n(t, -0.1)})`),
      current: c,
      active() {
        const e = c()
        return computed(() => (0 === e.value.length ? '' : e.value.at(-1)))
      }
    })
  )
}
function useBroadcastChannel(e) {
  const { name: t, window: n = defaultWindow } = e,
    o = useSupported(() => n && 'BroadcastChannel' in n),
    i = ref(!1),
    r = ref(),
    a = ref(),
    s = shallowRef(null),
    l = __name((e) => {
      r.value && r.value.postMessage(e)
    }, 'post'),
    c = __name(() => {
      r.value && r.value.close(), (i.value = !0)
    }, 'close')
  return (
    o.value &&
      tryOnMounted(() => {
        ;(s.value = null),
          (r.value = new BroadcastChannel(t)),
          r.value.addEventListener(
            'message',
            (e) => {
              a.value = e.data
            },
            { passive: !0 }
          ),
          r.value.addEventListener(
            'messageerror',
            (e) => {
              s.value = e
            },
            { passive: !0 }
          ),
          r.value.addEventListener('close', () => {
            i.value = !0
          })
      }),
    tryOnScopeDispose(() => {
      c()
    }),
    {
      isSupported: o,
      channel: r,
      data: a,
      post: l,
      close: c,
      error: s,
      isClosed: i
    }
  )
}
__name(useBreakpoints, 'useBreakpoints'),
  __name(useBroadcastChannel, 'useBroadcastChannel')
const WRITABLE_PROPERTIES = [
  'hash',
  'host',
  'hostname',
  'href',
  'pathname',
  'port',
  'protocol',
  'search'
]
function useBrowserLocation(e = {}) {
  const { window: t = defaultWindow } = e,
    n = Object.fromEntries(WRITABLE_PROPERTIES.map((e) => [e, ref()]))
  for (const [r, a] of objectEntries(n))
    watch(a, (e) => {
      ;(null == t ? void 0 : t.location) &&
        t.location[r] !== e &&
        (t.location[r] = e)
    })
  const o = __name((e) => {
      var o
      const { state: i, length: r } = (null == t ? void 0 : t.history) || {},
        { origin: a } = (null == t ? void 0 : t.location) || {}
      for (const s of WRITABLE_PROPERTIES)
        n[s].value =
          null == (o = null == t ? void 0 : t.location) ? void 0 : o[s]
      return reactive({ trigger: e, state: i, length: r, origin: a, ...n })
    }, 'buildState'),
    i = ref(o('load'))
  return (
    t &&
      (useEventListener(t, 'popstate', () => (i.value = o('popstate')), {
        passive: !0
      }),
      useEventListener(t, 'hashchange', () => (i.value = o('hashchange')), {
        passive: !0
      })),
    i
  )
}
function useCached(e, t = (e, t) => e === t, n) {
  const o = ref(e.value)
  return (
    watch(
      () => e.value,
      (e) => {
        t(e, o.value) || (o.value = e)
      },
      n
    ),
    o
  )
}
function usePermission(e, t = {}) {
  const { controls: n = !1, navigator: o = defaultNavigator } = t,
    i = useSupported(() => o && 'permissions' in o),
    r = shallowRef(),
    a = 'string' == typeof e ? { name: e } : e,
    s = shallowRef(),
    l = __name(() => {
      var e, t
      s.value =
        null != (t = null == (e = r.value) ? void 0 : e.state) ? t : 'prompt'
    }, 'update')
  useEventListener(r, 'change', l)
  const c = createSingletonPromise(async () => {
    if (i.value) {
      if (!r.value)
        try {
          r.value = await o.permissions.query(a)
        } catch (e2) {
          r.value = void 0
        } finally {
          l()
        }
      return n ? toRaw(r.value) : void 0
    }
  })
  return c(), n ? { state: s, isSupported: i, query: c } : s
}
function useClipboard(e = {}) {
  const {
      navigator: t = defaultNavigator,
      read: n = !1,
      source: o,
      copiedDuring: i = 1500,
      legacy: r = !1
    } = e,
    a = useSupported(() => t && 'clipboard' in t),
    s = usePermission('clipboard-read'),
    l = usePermission('clipboard-write'),
    c = computed(() => a.value || r),
    d = ref(''),
    u = ref(!1),
    p = useTimeoutFn(() => (u.value = !1), i)
  function h() {
    a.value && g(s.value)
      ? t.clipboard.readText().then((e) => {
          d.value = e
        })
      : (d.value = _())
  }
  async function m(e = toValue(o)) {
    c.value &&
      null != e &&
      (a.value && g(l.value) ? await t.clipboard.writeText(e) : f(e),
      (d.value = e),
      (u.value = !0),
      p.start())
  }
  function f(e) {
    const t = document.createElement('textarea')
    ;(t.value = null != e ? e : ''),
      (t.style.position = 'absolute'),
      (t.style.opacity = '0'),
      document.body.appendChild(t),
      t.select(),
      document.execCommand('copy'),
      t.remove()
  }
  function _() {
    var e, t, n
    return null !=
      (n =
        null ==
        (t =
          null == (e = null == document ? void 0 : document.getSelection)
            ? void 0
            : e.call(document))
          ? void 0
          : t.toString())
      ? n
      : ''
  }
  function g(e) {
    return 'granted' === e || 'prompt' === e
  }
  return (
    __name(h, 'updateText'),
    c.value && n && useEventListener(['copy', 'cut'], h),
    __name(m, 'copy'),
    __name(f, 'legacyCopy'),
    __name(_, 'legacyRead'),
    __name(g, 'isAllowed'),
    { isSupported: c, text: d, copied: u, copy: m }
  )
}
function useClipboardItems(e = {}) {
  const {
      navigator: t = defaultNavigator,
      read: n = !1,
      source: o,
      copiedDuring: i = 1500
    } = e,
    r = useSupported(() => t && 'clipboard' in t),
    a = ref([]),
    s = ref(!1),
    l = useTimeoutFn(() => (s.value = !1), i)
  function c() {
    r.value &&
      t.clipboard.read().then((e) => {
        a.value = e
      })
  }
  async function d(e = toValue(o)) {
    r.value &&
      null != e &&
      (await t.clipboard.write(e), (a.value = e), (s.value = !0), l.start())
  }
  return (
    __name(c, 'updateContent'),
    r.value && n && useEventListener(['copy', 'cut'], c),
    __name(d, 'copy'),
    { isSupported: r, content: a, copied: s, copy: d }
  )
}
function cloneFnJSON(e) {
  return JSON.parse(JSON.stringify(e))
}
function useCloned(e, t = {}) {
  const n = ref({}),
    { manual: o, clone: i = cloneFnJSON, deep: r = !0, immediate: a = !0 } = t
  function s() {
    n.value = i(toValue(e))
  }
  return (
    __name(s, 'sync'),
    o || (!isRef(e) && 'function' != typeof e)
      ? s()
      : watch(e, s, { ...t, deep: r, immediate: a }),
    { cloned: n, sync: s }
  )
}
__name(useBrowserLocation, 'useBrowserLocation'),
  __name(useCached, 'useCached'),
  __name(usePermission, 'usePermission'),
  __name(useClipboard, 'useClipboard'),
  __name(useClipboardItems, 'useClipboardItems'),
  __name(cloneFnJSON, 'cloneFnJSON'),
  __name(useCloned, 'useCloned')
const _global =
    'undefined' != typeof globalThis
      ? globalThis
      : 'undefined' != typeof window
        ? window
        : 'undefined' != typeof global
          ? global
          : 'undefined' != typeof self
            ? self
            : {},
  globalKey = '__vueuse_ssr_handlers__',
  handlers = getHandlers()
function getHandlers() {
  return (
    globalKey in _global || (_global[globalKey] = _global[globalKey] || {}),
    _global[globalKey]
  )
}
function getSSRHandler(e, t) {
  return handlers[e] || t
}
function setSSRHandler(e, t) {
  handlers[e] = t
}
function usePreferredDark(e) {
  return useMediaQuery('(prefers-color-scheme: dark)', e)
}
function guessSerializerType(e) {
  return null == e
    ? 'any'
    : e instanceof Set
      ? 'set'
      : e instanceof Map
        ? 'map'
        : e instanceof Date
          ? 'date'
          : 'boolean' == typeof e
            ? 'boolean'
            : 'string' == typeof e
              ? 'string'
              : 'object' == typeof e
                ? 'object'
                : Number.isNaN(e)
                  ? 'any'
                  : 'number'
}
__name(getHandlers, 'getHandlers'),
  __name(getSSRHandler, 'getSSRHandler'),
  __name(setSSRHandler, 'setSSRHandler'),
  __name(usePreferredDark, 'usePreferredDark'),
  __name(guessSerializerType, 'guessSerializerType')
const StorageSerializers = {
    boolean: {
      read: __name((e) => 'true' === e, 'read'),
      write: __name((e) => String(e), 'write')
    },
    object: {
      read: __name((e) => JSON.parse(e), 'read'),
      write: __name((e) => JSON.stringify(e), 'write')
    },
    number: {
      read: __name((e) => Number.parseFloat(e), 'read'),
      write: __name((e) => String(e), 'write')
    },
    any: {
      read: __name((e) => e, 'read'),
      write: __name((e) => String(e), 'write')
    },
    string: {
      read: __name((e) => e, 'read'),
      write: __name((e) => String(e), 'write')
    },
    map: {
      read: __name((e) => new Map(JSON.parse(e)), 'read'),
      write: __name((e) => JSON.stringify(Array.from(e.entries())), 'write')
    },
    set: {
      read: __name((e) => new Set(JSON.parse(e)), 'read'),
      write: __name((e) => JSON.stringify(Array.from(e)), 'write')
    },
    date: {
      read: __name((e) => new Date(e), 'read'),
      write: __name((e) => e.toISOString(), 'write')
    }
  },
  customStorageEventName = 'vueuse-storage'
function useStorage(e, t, n, o = {}) {
  var i
  const {
      flush: r = 'pre',
      deep: a = !0,
      listenToStorageChanges: s = !0,
      writeDefaults: l = !0,
      mergeDefaults: c = !1,
      shallow: d,
      window: u = defaultWindow,
      eventFilter: p,
      onError: h = __name((e) => {
        console.error(e)
      }, 'onError'),
      initOnMounted: m
    } = o,
    f = (d ? shallowRef : ref)('function' == typeof t ? t() : t)
  if (!n)
    try {
      n = getSSRHandler('getDefaultStorage', () => {
        var e
        return null == (e = defaultWindow) ? void 0 : e.localStorage
      })()
    } catch (e2) {
      h(e2)
    }
  if (!n) return f
  const _ = toValue(t),
    g = guessSerializerType(_),
    v = null != (i = o.serializer) ? i : StorageSerializers[g],
    { pause: y, resume: b } = watchPausable(f, () => C(f.value), {
      flush: r,
      deep: a,
      eventFilter: p
    })
  function S(t, o) {
    if (u) {
      const i = { key: e, oldValue: t, newValue: o, storageArea: n }
      u.dispatchEvent(
        n instanceof Storage
          ? new StorageEvent('storage', i)
          : new CustomEvent(customStorageEventName, { detail: i })
      )
    }
  }
  function C(t) {
    try {
      const o = n.getItem(e)
      if (null == t) S(o, null), n.removeItem(e)
      else {
        const i = v.write(t)
        o !== i && (n.setItem(e, i), S(o, i))
      }
    } catch (e2) {
      h(e2)
    }
  }
  function w(t) {
    const o = t ? t.newValue : n.getItem(e)
    if (null == o) return l && null != _ && n.setItem(e, v.write(_)), _
    if (!t && c) {
      const e = v.read(o)
      return 'function' == typeof c
        ? c(e, _)
        : 'object' !== g || Array.isArray(e)
          ? e
          : { ..._, ...e }
    }
    return 'string' != typeof o ? o : v.read(o)
  }
  function k(t) {
    if (!t || t.storageArea === n)
      if (t && null == t.key) f.value = _
      else if (!t || t.key === e) {
        y()
        try {
          ;(null == t ? void 0 : t.newValue) !== v.write(f.value) &&
            (f.value = w(t))
        } catch (e2) {
          h(e2)
        } finally {
          t ? nextTick(b) : b()
        }
      }
  }
  function x(e) {
    k(e.detail)
  }
  return (
    u &&
      s &&
      tryOnMounted(() => {
        n instanceof Storage
          ? useEventListener(u, 'storage', k)
          : useEventListener(u, customStorageEventName, x),
          m && k()
      }),
    m || k(),
    __name(S, 'dispatchWriteEvent'),
    __name(C, 'write'),
    __name(w, 'read'),
    __name(k, 'update'),
    __name(x, 'updateFromCustomEvent'),
    f
  )
}
__name(useStorage, 'useStorage')
const CSS_DISABLE_TRANS =
  '*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}'
function useColorMode(e = {}) {
  const {
      selector: t = 'html',
      attribute: n = 'class',
      initialValue: o = 'auto',
      window: i = defaultWindow,
      storage: r,
      storageKey: a = 'vueuse-color-scheme',
      listenToStorageChanges: s = !0,
      storageRef: l,
      emitAuto: c,
      disableTransition: d = !0
    } = e,
    u = { auto: '', light: 'light', dark: 'dark', ...(e.modes || {}) },
    p = usePreferredDark({ window: i }),
    h = computed(() => (p.value ? 'dark' : 'light')),
    m =
      l ||
      (null == a
        ? toRef(o)
        : useStorage(a, o, r, { window: i, listenToStorageChanges: s })),
    f = computed(() => ('auto' === m.value ? h.value : m.value)),
    _ = getSSRHandler('updateHTMLAttrs', (e, t, n) => {
      const o =
        'string' == typeof e
          ? null == i
            ? void 0
            : i.document.querySelector(e)
          : unrefElement(e)
      if (!o) return
      const r = new Set(),
        a = new Set()
      let s,
        l = null
      if ('class' === t) {
        const e = n.split(/\s/g)
        Object.values(u)
          .flatMap((e) => (e || '').split(/\s/g))
          .filter(Boolean)
          .forEach((t) => {
            e.includes(t) ? r.add(t) : a.add(t)
          })
      } else l = { key: t, value: n }
      if (0 !== r.size || 0 !== a.size || null !== l) {
        d &&
          ((s = i.document.createElement('style')),
          s.appendChild(document.createTextNode(CSS_DISABLE_TRANS)),
          i.document.head.appendChild(s))
        for (const e of r) o.classList.add(e)
        for (const e of a) o.classList.remove(e)
        l && o.setAttribute(l.key, l.value),
          d && (i.getComputedStyle(s).opacity, document.head.removeChild(s))
      }
    })
  function g(e) {
    var o
    _(t, n, null != (o = u[e]) ? o : e)
  }
  function v(t) {
    e.onChanged ? e.onChanged(t, g) : g(t)
  }
  __name(g, 'defaultOnChanged'),
    __name(v, 'onChanged'),
    watch(f, v, { flush: 'post', immediate: !0 }),
    tryOnMounted(() => v(f.value))
  const y = computed({
    get: () => (c ? m.value : f.value),
    set(e) {
      m.value = e
    }
  })
  try {
    return Object.assign(y, { store: m, system: h, state: f })
  } catch (e2) {
    return y
  }
}
function useConfirmDialog(e = ref(!1)) {
  const t = createEventHook(),
    n = createEventHook(),
    o = createEventHook()
  let i = noop
  const r = __name(
      (t) => (
        o.trigger(t),
        (e.value = !0),
        new Promise((e) => {
          i = e
        })
      ),
      'reveal'
    ),
    a = __name((n) => {
      ;(e.value = !1), t.trigger(n), i({ data: n, isCanceled: !1 })
    }, 'confirm'),
    s = __name((t) => {
      ;(e.value = !1), n.trigger(t), i({ data: t, isCanceled: !0 })
    }, 'cancel')
  return {
    isRevealed: computed(() => e.value),
    reveal: r,
    confirm: a,
    cancel: s,
    onReveal: o.on,
    onConfirm: t.on,
    onCancel: n.on
  }
}
function useCssVar(e, t, n = {}) {
  const { window: o = defaultWindow, initialValue: i, observe: r = !1 } = n,
    a = ref(i),
    s = computed(() => {
      var e
      return (
        unrefElement(t) ||
        (null == (e = null == o ? void 0 : o.document)
          ? void 0
          : e.documentElement)
      )
    })
  function l() {
    var t
    const n = toValue(e),
      r = toValue(s)
    if (r && o && n) {
      const e =
        null == (t = o.getComputedStyle(r).getPropertyValue(n))
          ? void 0
          : t.trim()
      a.value = e || i
    }
  }
  return (
    __name(l, 'updateCssVar'),
    r &&
      useMutationObserver(s, l, {
        attributeFilter: ['style', 'class'],
        window: o
      }),
    watch(
      [s, () => toValue(e)],
      (e, t) => {
        t[0] && t[1] && t[0].style.removeProperty(t[1]), l()
      },
      { immediate: !0 }
    ),
    watch(a, (t) => {
      var n
      const o = toValue(e)
      ;(null == (n = s.value) ? void 0 : n.style) &&
        o &&
        (null == t
          ? s.value.style.removeProperty(o)
          : s.value.style.setProperty(o, t))
    }),
    a
  )
}
function useCurrentElement(e) {
  const t = getCurrentInstance(),
    n = computedWithControl(
      () => null,
      () => (e ? unrefElement(e) : t.proxy.$el)
    )
  return onUpdated(n.trigger), onMounted(n.trigger), n
}
function useCycleList(e, t) {
  const n = shallowRef(c()),
    o = toRef(e),
    i = computed({
      get() {
        var e
        const i = o.value
        let r = (null == t ? void 0 : t.getIndexOf)
          ? t.getIndexOf(n.value, i)
          : i.indexOf(n.value)
        return (
          r < 0 &&
            (r = null != (e = null == t ? void 0 : t.fallbackIndex) ? e : 0),
          r
        )
      },
      set(e) {
        r(e)
      }
    })
  function r(e) {
    const t = o.value,
      i = t.length,
      r = t[((e % i) + i) % i]
    return (n.value = r), r
  }
  function a(e = 1) {
    return r(i.value + e)
  }
  function s(e = 1) {
    return a(e)
  }
  function l(e = 1) {
    return a(-e)
  }
  function c() {
    var n, o
    return null !=
      (o = toValue(
        null != (n = null == t ? void 0 : t.initialValue) ? n : toValue(e)[0]
      ))
      ? o
      : void 0
  }
  return (
    __name(r, 'set2'),
    __name(a, 'shift'),
    __name(s, 'next'),
    __name(l, 'prev'),
    __name(c, 'getInitialValue'),
    watch(o, () => r(i.value)),
    { state: n, index: i, next: s, prev: l, go: r }
  )
}
function useDark(e = {}) {
  const {
      valueDark: t = 'dark',
      valueLight: n = '',
      window: o = defaultWindow
    } = e,
    i = useColorMode({
      ...e,
      onChanged: __name((t, n) => {
        var o
        e.onChanged
          ? null == (o = e.onChanged) || o.call(e, 'dark' === t, n, t)
          : n(t)
      }, 'onChanged'),
      modes: { dark: t, light: n }
    }),
    r = computed(() => {
      if (i.system) return i.system.value
      return usePreferredDark({ window: o }).value ? 'dark' : 'light'
    })
  return computed({
    get: () => 'dark' === i.value,
    set(e) {
      const t = e ? 'dark' : 'light'
      r.value === t ? (i.value = 'auto') : (i.value = t)
    }
  })
}
function fnBypass(e) {
  return e
}
function fnSetSource(e, t) {
  return (e.value = t)
}
function defaultDump(e) {
  return e ? ('function' == typeof e ? e : cloneFnJSON) : fnBypass
}
function defaultParse(e) {
  return e ? ('function' == typeof e ? e : cloneFnJSON) : fnBypass
}
function useManualRefHistory(e, t = {}) {
  const {
    clone: n = !1,
    dump: o = defaultDump(n),
    parse: i = defaultParse(n),
    setSource: r = fnSetSource
  } = t
  function a() {
    return markRaw({ snapshot: o(e.value), timestamp: timestamp() })
  }
  __name(a, '_createHistoryRecord')
  const s = ref(a()),
    l = ref([]),
    c = ref([]),
    d = __name((t) => {
      r(e, i(t.snapshot)), (s.value = t)
    }, '_setSource'),
    u = __name(() => {
      l.value.unshift(s.value),
        (s.value = a()),
        t.capacity &&
          l.value.length > t.capacity &&
          l.value.splice(t.capacity, Number.POSITIVE_INFINITY),
        c.value.length && c.value.splice(0, c.value.length)
    }, 'commit'),
    p = __name(() => {
      l.value.splice(0, l.value.length), c.value.splice(0, c.value.length)
    }, 'clear'),
    h = __name(() => {
      const e = l.value.shift()
      e && (c.value.unshift(s.value), d(e))
    }, 'undo'),
    m = __name(() => {
      const e = c.value.shift()
      e && (l.value.unshift(s.value), d(e))
    }, 'redo'),
    f = __name(() => {
      d(s.value)
    }, 'reset'),
    _ = computed(() => [s.value, ...l.value]),
    g = computed(() => l.value.length > 0),
    v = computed(() => c.value.length > 0)
  return {
    source: e,
    undoStack: l,
    redoStack: c,
    last: s,
    history: _,
    canUndo: g,
    canRedo: v,
    clear: p,
    commit: u,
    reset: f,
    undo: h,
    redo: m
  }
}
function useRefHistory(e, t = {}) {
  const { deep: n = !1, flush: o = 'pre', eventFilter: i } = t,
    { eventFilter: r, pause: a, resume: s, isActive: l } = pausableFilter(i),
    {
      ignoreUpdates: c,
      ignorePrevAsyncUpdates: d,
      stop: u
    } = watchIgnorable(e, _, { deep: n, flush: o, eventFilter: r })
  function p(e, t) {
    d(),
      c(() => {
        e.value = t
      })
  }
  __name(p, 'setSource')
  const h = useManualRefHistory(e, { ...t, clone: t.clone || n, setSource: p }),
    { clear: m, commit: f } = h
  function _() {
    d(), f()
  }
  function g(e) {
    s(), e && _()
  }
  function v(e) {
    let t = !1
    const n = __name(() => (t = !0), 'cancel')
    c(() => {
      e(n)
    }),
      t || _()
  }
  function y() {
    u(), m()
  }
  return (
    __name(_, 'commit'),
    __name(g, 'resume'),
    __name(v, 'batch'),
    __name(y, 'dispose'),
    {
      ...h,
      isTracking: l,
      pause: a,
      resume: g,
      commit: _,
      batch: v,
      dispose: y
    }
  )
}
function useDebouncedRefHistory(e, t = {}) {
  const n = t.debounce ? debounceFilter(t.debounce) : void 0
  return { ...useRefHistory(e, { ...t, eventFilter: n }) }
}
function useDeviceMotion(e = {}) {
  const { window: t = defaultWindow, eventFilter: n = bypassFilter } = e,
    o = ref({ x: null, y: null, z: null }),
    i = ref({ alpha: null, beta: null, gamma: null }),
    r = ref(0),
    a = ref({ x: null, y: null, z: null })
  if (t) {
    useEventListener(
      t,
      'devicemotion',
      createFilterWrapper(n, (e) => {
        ;(o.value = e.acceleration),
          (a.value = e.accelerationIncludingGravity),
          (i.value = e.rotationRate),
          (r.value = e.interval)
      })
    )
  }
  return {
    acceleration: o,
    accelerationIncludingGravity: a,
    rotationRate: i,
    interval: r
  }
}
function useDeviceOrientation(e = {}) {
  const { window: t = defaultWindow } = e,
    n = useSupported(() => t && 'DeviceOrientationEvent' in t),
    o = ref(!1),
    i = ref(null),
    r = ref(null),
    a = ref(null)
  return (
    t &&
      n.value &&
      useEventListener(t, 'deviceorientation', (e) => {
        ;(o.value = e.absolute),
          (i.value = e.alpha),
          (r.value = e.beta),
          (a.value = e.gamma)
      }),
    { isSupported: n, isAbsolute: o, alpha: i, beta: r, gamma: a }
  )
}
function useDevicePixelRatio(e = {}) {
  const { window: t = defaultWindow } = e,
    n = ref(1)
  if (t) {
    let e,
      o = __name(function () {
        ;(n.value = t.devicePixelRatio),
          i(),
          (e = t.matchMedia(`(resolution: ${n.value}dppx)`)),
          e.addEventListener('change', o, { once: !0 })
      }, 'observe2'),
      i = __name(function () {
        null == e || e.removeEventListener('change', o)
      }, 'cleanup2')
    o(), tryOnScopeDispose(i)
  }
  return { pixelRatio: n }
}
function useDevicesList(e = {}) {
  const {
      navigator: t = defaultNavigator,
      requestPermissions: n = !1,
      constraints: o = { audio: !0, video: !0 },
      onUpdated: i
    } = e,
    r = ref([]),
    a = computed(() => r.value.filter((e) => 'videoinput' === e.kind)),
    s = computed(() => r.value.filter((e) => 'audioinput' === e.kind)),
    l = computed(() => r.value.filter((e) => 'audiooutput' === e.kind)),
    c = useSupported(
      () => t && t.mediaDevices && t.mediaDevices.enumerateDevices
    ),
    d = ref(!1)
  let u
  async function p() {
    c.value &&
      ((r.value = await t.mediaDevices.enumerateDevices()),
      null == i || i(r.value),
      u && (u.getTracks().forEach((e) => e.stop()), (u = null)))
  }
  async function h() {
    if (!c.value) return !1
    if (d.value) return !0
    const { state: e, query: n } = usePermission('camera', { controls: !0 })
    if ((await n(), 'granted' !== e.value)) {
      let e = !0
      try {
        u = await t.mediaDevices.getUserMedia(o)
      } catch (e2) {
        ;(u = null), (e = !1)
      }
      p(), (d.value = e)
    } else d.value = !0
    return d.value
  }
  return (
    __name(p, 'update'),
    __name(h, 'ensurePermissions'),
    c.value &&
      (n && h(), useEventListener(t.mediaDevices, 'devicechange', p), p()),
    {
      devices: r,
      ensurePermissions: h,
      permissionGranted: d,
      videoInputs: a,
      audioInputs: s,
      audioOutputs: l,
      isSupported: c
    }
  )
}
function useDisplayMedia(e = {}) {
  var t
  const n = ref(null != (t = e.enabled) && t),
    o = e.video,
    i = e.audio,
    { navigator: r = defaultNavigator } = e,
    a = useSupported(() => {
      var e
      return null == (e = null == r ? void 0 : r.mediaDevices)
        ? void 0
        : e.getDisplayMedia
    }),
    s = { audio: i, video: o },
    l = shallowRef()
  async function c() {
    var e
    if (a.value && !l.value)
      return (
        (l.value = await r.mediaDevices.getDisplayMedia(s)),
        null == (e = l.value) ||
          e.getTracks().forEach((e) => e.addEventListener('ended', u)),
        l.value
      )
  }
  async function d() {
    var e
    null == (e = l.value) || e.getTracks().forEach((e) => e.stop()),
      (l.value = void 0)
  }
  function u() {
    d(), (n.value = !1)
  }
  async function p() {
    return await c(), l.value && (n.value = !0), l.value
  }
  return (
    __name(c, '_start'),
    __name(d, '_stop'),
    __name(u, 'stop'),
    __name(p, 'start'),
    watch(
      n,
      (e) => {
        e ? c() : d()
      },
      { immediate: !0 }
    ),
    { isSupported: a, stream: l, start: p, stop: u, enabled: n }
  )
}
function useDocumentVisibility(e = {}) {
  const { document: t = defaultDocument } = e
  if (!t) return ref('visible')
  const n = ref(t.visibilityState)
  return (
    useEventListener(t, 'visibilitychange', () => {
      n.value = t.visibilityState
    }),
    n
  )
}
function useDraggable(e, t = {}) {
  var n, o
  const {
      pointerTypes: i,
      preventDefault: r,
      stopPropagation: a,
      exact: s,
      onMove: l,
      onEnd: c,
      onStart: d,
      initialValue: u,
      axis: p = 'both',
      draggingElement: h = defaultWindow,
      containerElement: m,
      handle: f = e,
      buttons: _ = [0]
    } = t,
    g = ref(null != (n = toValue(u)) ? n : { x: 0, y: 0 }),
    v = ref(),
    y = __name((e) => !i || i.includes(e.pointerType), 'filterEvent'),
    b = __name((e) => {
      toValue(r) && e.preventDefault(), toValue(a) && e.stopPropagation()
    }, 'handleEvent'),
    S = __name((n) => {
      var o
      if (!toValue(_).includes(n.button)) return
      if (toValue(t.disabled) || !y(n)) return
      if (toValue(s) && n.target !== toValue(e)) return
      const i = toValue(m),
        r =
          null == (o = null == i ? void 0 : i.getBoundingClientRect)
            ? void 0
            : o.call(i),
        a = toValue(e).getBoundingClientRect(),
        l = {
          x: n.clientX - (i ? a.left - r.left + i.scrollLeft : a.left),
          y: n.clientY - (i ? a.top - r.top + i.scrollTop : a.top)
        }
      !1 !== (null == d ? void 0 : d(l, n)) && ((v.value = l), b(n))
    }, 'start'),
    C = __name((n) => {
      if (toValue(t.disabled) || !y(n)) return
      if (!v.value) return
      const o = toValue(m),
        i = toValue(e).getBoundingClientRect()
      let { x: r, y: a } = g.value
      ;('x' !== p && 'both' !== p) ||
        ((r = n.clientX - v.value.x),
        o && (r = Math.min(Math.max(0, r), o.scrollWidth - i.width))),
        ('y' !== p && 'both' !== p) ||
          ((a = n.clientY - v.value.y),
          o && (a = Math.min(Math.max(0, a), o.scrollHeight - i.height))),
        (g.value = { x: r, y: a }),
        null == l || l(g.value, n),
        b(n)
    }, 'move'),
    w = __name((e) => {
      !toValue(t.disabled) &&
        y(e) &&
        v.value &&
        ((v.value = void 0), null == c || c(g.value, e), b(e))
    }, 'end')
  if (isClient) {
    const e = { capture: null == (o = t.capture) || o }
    useEventListener(f, 'pointerdown', S, e),
      useEventListener(h, 'pointermove', C, e),
      useEventListener(h, 'pointerup', w, e)
  }
  return {
    ...toRefs(g),
    position: g,
    isDragging: computed(() => !!v.value),
    style: computed(() => `left:${g.value.x}px;top:${g.value.y}px;`)
  }
}
function useDropZone(e, t = {}) {
  var n, o
  const i = ref(!1),
    r = shallowRef(null)
  let a = 0,
    s = !0
  if (isClient) {
    const l = 'function' == typeof t ? { onDrop: t } : t,
      c = null == (n = l.multiple) || n,
      d = null != (o = l.preventDefaultForUnhandled) && o,
      u = __name((e) => {
        var t, n
        const o = Array.from(
          null != (n = null == (t = e.dataTransfer) ? void 0 : t.files) ? n : []
        )
        return 0 === o.length ? null : c ? o : [o[0]]
      }, 'getFiles'),
      p = __name((e) => {
        if (l.dataTypes) {
          const t = unref(l.dataTypes)
          return 'function' == typeof t
            ? t(e)
            : !t || t.some((t) => e.includes(t))
        }
        return !0
      }, 'checkDataTypes'),
      h = __name((e) => {
        var t, n
        const o = Array.from(
            null != (n = null == (t = e.dataTransfer) ? void 0 : t.items)
              ? n
              : []
          ),
          i = o.map((e) => e.type),
          r = p(i),
          a = c || o.length <= 1
        return r && a
      }, 'checkValidity'),
      m = __name((e, t) => {
        var n, o, c, p
        if (((s = h(e)), !s))
          return (
            d && e.preventDefault(),
            void (e.dataTransfer && (e.dataTransfer.dropEffect = 'none'))
          )
        e.preventDefault(),
          e.dataTransfer && (e.dataTransfer.dropEffect = 'copy')
        const m = u(e)
        switch (t) {
          case 'enter':
            ;(a += 1),
              (i.value = !0),
              null == (n = l.onEnter) || n.call(l, null, e)
            break
          case 'over':
            null == (o = l.onOver) || o.call(l, null, e)
            break
          case 'leave':
            ;(a -= 1),
              0 === a && (i.value = !1),
              null == (c = l.onLeave) || c.call(l, null, e)
            break
          case 'drop':
            ;(a = 0),
              (i.value = !1),
              s && ((r.value = m), null == (p = l.onDrop) || p.call(l, m, e))
        }
      }, 'handleDragEvent')
    useEventListener(e, 'dragenter', (e) => m(e, 'enter')),
      useEventListener(e, 'dragover', (e) => m(e, 'over')),
      useEventListener(e, 'dragleave', (e) => m(e, 'leave')),
      useEventListener(e, 'drop', (e) => m(e, 'drop'))
  }
  return { files: r, isOverDropZone: i }
}
function useResizeObserver(e, t, n = {}) {
  const { window: o = defaultWindow, ...i } = n
  let r
  const a = useSupported(() => o && 'ResizeObserver' in o),
    s = __name(() => {
      r && (r.disconnect(), (r = void 0))
    }, 'cleanup'),
    l = watch(
      computed(() => {
        const t = toValue(e)
        return Array.isArray(t)
          ? t.map((e) => unrefElement(e))
          : [unrefElement(t)]
      }),
      (e) => {
        if ((s(), a.value && o)) {
          r = new ResizeObserver(t)
          for (const t of e) t && r.observe(t, i)
        }
      },
      { immediate: !0, flush: 'post' }
    ),
    c = __name(() => {
      s(), l()
    }, 'stop')
  return tryOnScopeDispose(c), { isSupported: a, stop: c }
}
function useElementBounding(e, t = {}) {
  const {
      reset: n = !0,
      windowResize: o = !0,
      windowScroll: i = !0,
      immediate: r = !0,
      updateTiming: a = 'sync'
    } = t,
    s = ref(0),
    l = ref(0),
    c = ref(0),
    d = ref(0),
    u = ref(0),
    p = ref(0),
    h = ref(0),
    m = ref(0)
  function f() {
    const t = unrefElement(e)
    if (!t)
      return void (
        n &&
        ((s.value = 0),
        (l.value = 0),
        (c.value = 0),
        (d.value = 0),
        (u.value = 0),
        (p.value = 0),
        (h.value = 0),
        (m.value = 0))
      )
    const o = t.getBoundingClientRect()
    ;(s.value = o.height),
      (l.value = o.bottom),
      (c.value = o.left),
      (d.value = o.right),
      (u.value = o.top),
      (p.value = o.width),
      (h.value = o.x),
      (m.value = o.y)
  }
  function _() {
    'sync' === a ? f() : 'next-frame' === a && requestAnimationFrame(() => f())
  }
  return (
    __name(f, 'recalculate'),
    __name(_, 'update'),
    useResizeObserver(e, _),
    watch(
      () => unrefElement(e),
      (e) => !e && _()
    ),
    useMutationObserver(e, _, { attributeFilter: ['style', 'class'] }),
    i && useEventListener('scroll', _, { capture: !0, passive: !0 }),
    o && useEventListener('resize', _, { passive: !0 }),
    tryOnMounted(() => {
      r && _()
    }),
    {
      height: s,
      bottom: l,
      left: c,
      right: d,
      top: u,
      width: p,
      x: h,
      y: m,
      update: _
    }
  )
}
function useElementByPoint(e) {
  const {
      x: t,
      y: n,
      document: o = defaultDocument,
      multiple: i,
      interval: r = 'requestAnimationFrame',
      immediate: a = !0
    } = e,
    s = useSupported(() =>
      toValue(i) ? o && 'elementsFromPoint' in o : o && 'elementFromPoint' in o
    ),
    l = ref(null),
    c = __name(() => {
      var e, r
      l.value = toValue(i)
        ? null !=
          (e = null == o ? void 0 : o.elementsFromPoint(toValue(t), toValue(n)))
          ? e
          : []
        : null !=
            (r =
              null == o ? void 0 : o.elementFromPoint(toValue(t), toValue(n)))
          ? r
          : null
    }, 'cb'),
    d =
      'requestAnimationFrame' === r
        ? useRafFn(c, { immediate: a })
        : useIntervalFn(c, r, { immediate: a })
  return { isSupported: s, element: l, ...d }
}
function useElementHover(e, t = {}) {
  const { delayEnter: n = 0, delayLeave: o = 0, window: i = defaultWindow } = t,
    r = ref(!1)
  let a
  const s = __name((e) => {
    const t = e ? n : o
    a && (clearTimeout(a), (a = void 0)),
      t ? (a = setTimeout(() => (r.value = e), t)) : (r.value = e)
  }, 'toggle')
  return i
    ? (useEventListener(e, 'mouseenter', () => s(!0), { passive: !0 }),
      useEventListener(e, 'mouseleave', () => s(!1), { passive: !0 }),
      r)
    : r
}
function useElementSize(e, t = { width: 0, height: 0 }, n = {}) {
  const { window: o = defaultWindow, box: i = 'content-box' } = n,
    r = computed(() => {
      var t, n
      return null ==
        (n = null == (t = unrefElement(e)) ? void 0 : t.namespaceURI)
        ? void 0
        : n.includes('svg')
    }),
    a = ref(t.width),
    s = ref(t.height),
    { stop: l } = useResizeObserver(
      e,
      ([t]) => {
        const n =
          'border-box' === i
            ? t.borderBoxSize
            : 'content-box' === i
              ? t.contentBoxSize
              : t.devicePixelContentBoxSize
        if (o && r.value) {
          const t = unrefElement(e)
          if (t) {
            const e = t.getBoundingClientRect()
            ;(a.value = e.width), (s.value = e.height)
          }
        } else if (n) {
          const e = Array.isArray(n) ? n : [n]
          ;(a.value = e.reduce((e, { inlineSize: t }) => e + t, 0)),
            (s.value = e.reduce((e, { blockSize: t }) => e + t, 0))
        } else (a.value = t.contentRect.width), (s.value = t.contentRect.height)
      },
      n
    )
  tryOnMounted(() => {
    const n = unrefElement(e)
    n &&
      ((a.value = 'offsetWidth' in n ? n.offsetWidth : t.width),
      (s.value = 'offsetHeight' in n ? n.offsetHeight : t.height))
  })
  const c = watch(
    () => unrefElement(e),
    (e) => {
      ;(a.value = e ? t.width : 0), (s.value = e ? t.height : 0)
    }
  )
  function d() {
    l(), c()
  }
  return __name(d, 'stop'), { width: a, height: s, stop: d }
}
function useIntersectionObserver(e, t, n = {}) {
  const {
      root: o,
      rootMargin: i = '0px',
      threshold: r = 0,
      window: a = defaultWindow,
      immediate: s = !0
    } = n,
    l = useSupported(() => a && 'IntersectionObserver' in a),
    c = computed(() => {
      const t = toValue(e)
      return (Array.isArray(t) ? t : [t]).map(unrefElement).filter(notNullish)
    })
  let d = noop
  const u = ref(s),
    p = l.value
      ? watch(
          () => [c.value, unrefElement(o), u.value],
          ([e, n]) => {
            if ((d(), !u.value)) return
            if (!e.length) return
            const o = new IntersectionObserver(t, {
              root: unrefElement(n),
              rootMargin: i,
              threshold: r
            })
            e.forEach((e) => e && o.observe(e)),
              (d = __name(() => {
                o.disconnect(), (d = noop)
              }, 'cleanup'))
          },
          { immediate: s, flush: 'post' }
        )
      : noop,
    h = __name(() => {
      d(), p(), (u.value = !1)
    }, 'stop')
  return (
    tryOnScopeDispose(h),
    {
      isSupported: l,
      isActive: u,
      pause() {
        d(), (u.value = !1)
      },
      resume() {
        u.value = !0
      },
      stop: h
    }
  )
}
function useElementVisibility(e, t = {}) {
  const { window: n = defaultWindow, scrollTarget: o, threshold: i = 0 } = t,
    r = ref(!1)
  return (
    useIntersectionObserver(
      e,
      (e) => {
        let t = r.value,
          n = 0
        for (const o of e) o.time >= n && ((n = o.time), (t = o.isIntersecting))
        r.value = t
      },
      { root: o, window: n, threshold: i }
    ),
    r
  )
}
__name(useColorMode, 'useColorMode'),
  __name(useConfirmDialog, 'useConfirmDialog'),
  __name(useCssVar, 'useCssVar'),
  __name(useCurrentElement, 'useCurrentElement'),
  __name(useCycleList, 'useCycleList'),
  __name(useDark, 'useDark'),
  __name(fnBypass, 'fnBypass'),
  __name(fnSetSource, 'fnSetSource'),
  __name(defaultDump, 'defaultDump'),
  __name(defaultParse, 'defaultParse'),
  __name(useManualRefHistory, 'useManualRefHistory'),
  __name(useRefHistory, 'useRefHistory'),
  __name(useDebouncedRefHistory, 'useDebouncedRefHistory'),
  __name(useDeviceMotion, 'useDeviceMotion'),
  __name(useDeviceOrientation, 'useDeviceOrientation'),
  __name(useDevicePixelRatio, 'useDevicePixelRatio'),
  __name(useDevicesList, 'useDevicesList'),
  __name(useDisplayMedia, 'useDisplayMedia'),
  __name(useDocumentVisibility, 'useDocumentVisibility'),
  __name(useDraggable, 'useDraggable'),
  __name(useDropZone, 'useDropZone'),
  __name(useResizeObserver, 'useResizeObserver'),
  __name(useElementBounding, 'useElementBounding'),
  __name(useElementByPoint, 'useElementByPoint'),
  __name(useElementHover, 'useElementHover'),
  __name(useElementSize, 'useElementSize'),
  __name(useIntersectionObserver, 'useIntersectionObserver'),
  __name(useElementVisibility, 'useElementVisibility')
const events = new Map()
function useEventBus(e) {
  const t = getCurrentScope()
  function n(n) {
    var o
    const r = events.get(e) || new Set()
    r.add(n), events.set(e, r)
    const a = __name(() => i(n), '_off')
    return null == (o = null == t ? void 0 : t.cleanups) || o.push(a), a
  }
  function o(e) {
    function t(...n) {
      i(t), e(...n)
    }
    return __name(t, '_listener'), n(t)
  }
  function i(t) {
    const n = events.get(e)
    n && (n.delete(t), n.size || r())
  }
  function r() {
    events.delete(e)
  }
  function a(t, n) {
    var o
    null == (o = events.get(e)) || o.forEach((e) => e(t, n))
  }
  return (
    __name(n, 'on'),
    __name(o, 'once'),
    __name(i, 'off'),
    __name(r, 'reset'),
    __name(a, 'emit'),
    { on: n, once: o, off: i, emit: a, reset: r }
  )
}
function resolveNestedOptions$1(e) {
  return !0 === e ? {} : e
}
function useEventSource(e, t = [], n = {}) {
  const o = ref(null),
    i = ref(null),
    r = ref('CONNECTING'),
    a = ref(null),
    s = shallowRef(null),
    l = toRef(e),
    c = shallowRef(null)
  let d = !1,
    u = 0
  const { withCredentials: p = !1, immediate: h = !0 } = n,
    m = __name(() => {
      isClient &&
        a.value &&
        (a.value.close(), (a.value = null), (r.value = 'CLOSED'), (d = !0))
    }, 'close'),
    f = __name(() => {
      if (d || void 0 === l.value) return
      const e = new EventSource(l.value, { withCredentials: p })
      ;(r.value = 'CONNECTING'),
        (a.value = e),
        (e.onopen = () => {
          ;(r.value = 'OPEN'), (s.value = null)
        }),
        (e.onerror = (t) => {
          if (
            ((r.value = 'CLOSED'),
            (s.value = t),
            2 === e.readyState && !d && n.autoReconnect)
          ) {
            e.close()
            const {
              retries: t = -1,
              delay: o = 1e3,
              onFailed: i
            } = resolveNestedOptions$1(n.autoReconnect)
            ;(u += 1),
              ('number' == typeof t && (t < 0 || u < t)) ||
              ('function' == typeof t && t())
                ? setTimeout(f, o)
                : null == i || i()
          }
        }),
        (e.onmessage = (e) => {
          ;(o.value = null), (i.value = e.data), (c.value = e.lastEventId)
        })
      for (const n of t)
        useEventListener(e, n, (e) => {
          ;(o.value = n), (i.value = e.data || null)
        })
    }, '_init'),
    _ = __name(() => {
      isClient && (m(), (d = !1), (u = 0), f())
    }, 'open')
  return (
    h && watch(l, _, { immediate: !0 }),
    tryOnScopeDispose(m),
    {
      eventSource: a,
      event: o,
      data: i,
      status: r,
      error: s,
      open: _,
      close: m,
      lastEventId: c
    }
  )
}
function useEyeDropper(e = {}) {
  const { initialValue: t = '' } = e,
    n = useSupported(
      () => 'undefined' != typeof window && 'EyeDropper' in window
    ),
    o = ref(t)
  async function i(e) {
    if (!n.value) return
    const t = new window.EyeDropper(),
      i = await t.open(e)
    return (o.value = i.sRGBHex), i
  }
  return __name(i, 'open'), { isSupported: n, sRGBHex: o, open: i }
}
function useFavicon(e = null, t = {}) {
  const { baseUrl: n = '', rel: o = 'icon', document: i = defaultDocument } = t,
    r = toRef(e),
    a = __name((e) => {
      const t =
        null == i ? void 0 : i.head.querySelectorAll(`link[rel*="${o}"]`)
      if (t && 0 !== t.length)
        null == t || t.forEach((t) => (t.href = `${n}${e}`))
      else {
        const t = null == i ? void 0 : i.createElement('link')
        t &&
          ((t.rel = o),
          (t.href = `${n}${e}`),
          (t.type = `image/${e.split('.').pop()}`),
          null == i || i.head.append(t))
      }
    }, 'applyIcon')
  return (
    watch(
      r,
      (e, t) => {
        'string' == typeof e && e !== t && a(e)
      },
      { immediate: !0 }
    ),
    r
  )
}
__name(useEventBus, 'useEventBus'),
  __name(resolveNestedOptions$1, 'resolveNestedOptions$1'),
  __name(useEventSource, 'useEventSource'),
  __name(useEyeDropper, 'useEyeDropper'),
  __name(useFavicon, 'useFavicon')
const payloadMapping = { json: 'application/json', text: 'text/plain' }
function isFetchOptions(e) {
  return (
    e &&
    containsProp(
      e,
      'immediate',
      'refetch',
      'initialData',
      'timeout',
      'beforeFetch',
      'afterFetch',
      'onFetchError',
      'fetch',
      'updateDataOnError'
    )
  )
}
__name(isFetchOptions, 'isFetchOptions')
const reAbsolute = /^(?:[a-z][a-z\d+\-.]*:)?\/\//i
function isAbsoluteURL(e) {
  return reAbsolute.test(e)
}
function headersToObject(e) {
  return 'undefined' != typeof Headers && e instanceof Headers
    ? Object.fromEntries(e.entries())
    : e
}
function combineCallbacks(e, ...t) {
  return 'overwrite' === e
    ? async (e) => {
        const n = t[t.length - 1]
        return n ? { ...e, ...(await n(e)) } : e
      }
    : async (e) => {
        for (const n of t) n && (e = { ...e, ...(await n(e)) })
        return e
      }
}
function createFetch(e = {}) {
  const t = e.combination || 'chain',
    n = e.options || {},
    o = e.fetchOptions || {}
  function i(i, ...r) {
    const a = computed(() => {
      const t = toValue(e.baseUrl),
        n = toValue(i)
      return t && !isAbsoluteURL(n) ? joinPaths(t, n) : n
    })
    let s = n,
      l = o
    return (
      r.length > 0 &&
        (isFetchOptions(r[0])
          ? (s = {
              ...s,
              ...r[0],
              beforeFetch: combineCallbacks(t, n.beforeFetch, r[0].beforeFetch),
              afterFetch: combineCallbacks(t, n.afterFetch, r[0].afterFetch),
              onFetchError: combineCallbacks(
                t,
                n.onFetchError,
                r[0].onFetchError
              )
            })
          : (l = {
              ...l,
              ...r[0],
              headers: {
                ...(headersToObject(l.headers) || {}),
                ...(headersToObject(r[0].headers) || {})
              }
            })),
      r.length > 1 &&
        isFetchOptions(r[1]) &&
        (s = {
          ...s,
          ...r[1],
          beforeFetch: combineCallbacks(t, n.beforeFetch, r[1].beforeFetch),
          afterFetch: combineCallbacks(t, n.afterFetch, r[1].afterFetch),
          onFetchError: combineCallbacks(t, n.onFetchError, r[1].onFetchError)
        }),
      useFetch(a, l, s)
    )
  }
  return __name(i, 'useFactoryFetch'), i
}
function useFetch(e, ...t) {
  var n
  const o = 'function' == typeof AbortController
  let i = {},
    r = { immediate: !0, refetch: !1, timeout: 0, updateDataOnError: !1 }
  const a = { method: 'GET', type: 'text', payload: void 0 }
  t.length > 0 && (isFetchOptions(t[0]) ? (r = { ...r, ...t[0] }) : (i = t[0])),
    t.length > 1 && isFetchOptions(t[1]) && (r = { ...r, ...t[1] })
  const {
      fetch: s = null == (n = defaultWindow) ? void 0 : n.fetch,
      initialData: l,
      timeout: c
    } = r,
    d = createEventHook(),
    u = createEventHook(),
    p = createEventHook(),
    h = ref(!1),
    m = ref(!1),
    f = ref(!1),
    _ = ref(null),
    g = shallowRef(null),
    v = shallowRef(null),
    y = shallowRef(l || null),
    b = computed(() => o && m.value)
  let S, C
  const w = __name(() => {
      o &&
        (null == S || S.abort(),
        (S = new AbortController()),
        (S.signal.onabort = () => (f.value = !0)),
        (i = { ...i, signal: S.signal }))
    }, 'abort'),
    k = __name((e) => {
      ;(m.value = e), (h.value = !e)
    }, 'loading')
  c && (C = useTimeoutFn(w, c, { immediate: !1 }))
  let x = 0
  const E = __name(async (t = !1) => {
      var n, o
      w(), k(!0), (v.value = null), (_.value = null), (f.value = !1), (x += 1)
      const c = x,
        h = { method: a.method, headers: {} }
      if (a.payload) {
        const e = headersToObject(h.headers),
          t = toValue(a.payload),
          o = Object.getPrototypeOf(t)
        a.payloadType ||
          !t ||
          (o !== Object.prototype && !Array.isArray(o)) ||
          t instanceof FormData ||
          (a.payloadType = 'json'),
          a.payloadType &&
            (e['Content-Type'] =
              null != (n = payloadMapping[a.payloadType]) ? n : a.payloadType),
          (h.body = 'json' === a.payloadType ? JSON.stringify(t) : t)
      }
      let m = !1
      const b = {
        url: toValue(e),
        options: { ...h, ...i },
        cancel: __name(() => {
          m = !0
        }, 'cancel')
      }
      if ((r.beforeFetch && Object.assign(b, await r.beforeFetch(b)), m || !s))
        return k(!1), Promise.resolve(null)
      let S = null
      return (
        C && C.start(),
        s(b.url, {
          ...h,
          ...b.options,
          headers: {
            ...headersToObject(h.headers),
            ...headersToObject(null == (o = b.options) ? void 0 : o.headers)
          }
        })
          .then(async (e) => {
            if (
              ((g.value = e),
              (_.value = e.status),
              (S = await e.clone()[a.type]()),
              !e.ok)
            )
              throw ((y.value = l || null), new Error(e.statusText))
            return (
              r.afterFetch &&
                ({ data: S } = await r.afterFetch({ data: S, response: e })),
              (y.value = S),
              d.trigger(e),
              e
            )
          })
          .catch(async (e) => {
            let n = e.message || e.name
            if (
              (r.onFetchError &&
                ({ error: n, data: S } = await r.onFetchError({
                  data: S,
                  error: e,
                  response: g.value
                })),
              (v.value = n),
              r.updateDataOnError && (y.value = S),
              u.trigger(e),
              t)
            )
              throw e
            return null
          })
          .finally(() => {
            c === x && k(!1), C && C.stop(), p.trigger(null)
          })
      )
    }, 'execute'),
    I = toRef(r.refetch)
  watch([I, toRef(e)], ([e]) => e && E(), { deep: !0 })
  const T = {
    isFinished: readonly(h),
    isFetching: readonly(m),
    statusCode: _,
    response: g,
    error: v,
    data: y,
    canAbort: b,
    aborted: f,
    abort: w,
    execute: E,
    onFetchResponse: d.on,
    onFetchError: u.on,
    onFetchFinally: p.on,
    get: $('GET'),
    put: $('PUT'),
    post: $('POST'),
    delete: $('DELETE'),
    patch: $('PATCH'),
    head: $('HEAD'),
    options: $('OPTIONS'),
    json: A('json'),
    text: A('text'),
    blob: A('blob'),
    arrayBuffer: A('arrayBuffer'),
    formData: A('formData')
  }
  function $(e) {
    return (t, n) => {
      if (!m.value)
        return (
          (a.method = e),
          (a.payload = t),
          (a.payloadType = n),
          isRef(a.payload) &&
            watch([I, toRef(a.payload)], ([e]) => e && E(), { deep: !0 }),
          { ...T, then: (e, t) => L().then(e, t) }
        )
    }
  }
  function L() {
    return new Promise((e, t) => {
      until(h)
        .toBe(!0)
        .then(() => e(T))
        .catch(t)
    })
  }
  function A(e) {
    return () => {
      if (!m.value)
        return (a.type = e), { ...T, then: (e, t) => L().then(e, t) }
    }
  }
  return (
    __name($, 'setMethod'),
    __name(L, 'waitUntilFinished'),
    __name(A, 'setType'),
    r.immediate && Promise.resolve().then(() => E()),
    { ...T, then: (e, t) => L().then(e, t) }
  )
}
function joinPaths(e, t) {
  return e.endsWith('/') || t.startsWith('/')
    ? e.endsWith('/') && t.startsWith('/')
      ? `${e.slice(0, -1)}${t}`
      : `${e}${t}`
    : `${e}/${t}`
}
__name(isAbsoluteURL, 'isAbsoluteURL'),
  __name(headersToObject, 'headersToObject'),
  __name(combineCallbacks, 'combineCallbacks'),
  __name(createFetch, 'createFetch'),
  __name(useFetch, 'useFetch'),
  __name(joinPaths, 'joinPaths')
const DEFAULT_OPTIONS = { multiple: !0, accept: '*', reset: !1, directory: !1 }
function useFileDialog(e = {}) {
  const { document: t = defaultDocument } = e,
    n = ref(null),
    { on: o, trigger: i } = createEventHook(),
    { on: r, trigger: a } = createEventHook()
  let s
  t &&
    ((s = t.createElement('input')),
    (s.type = 'file'),
    (s.onchange = (e) => {
      const t = e.target
      ;(n.value = t.files), i(n.value)
    }),
    (s.oncancel = () => {
      a()
    }))
  const l = __name(() => {
      ;(n.value = null), s && s.value && ((s.value = ''), i(null))
    }, 'reset'),
    c = __name((t) => {
      if (!s) return
      const n = { ...DEFAULT_OPTIONS, ...e, ...t }
      ;(s.multiple = n.multiple),
        (s.accept = n.accept),
        (s.webkitdirectory = n.directory),
        hasOwn$1(n, 'capture') && (s.capture = n.capture),
        n.reset && l(),
        s.click()
    }, 'open')
  return { files: readonly(n), open: c, reset: l, onCancel: r, onChange: o }
}
function useFileSystemAccess(e = {}) {
  const { window: t = defaultWindow, dataType: n = 'Text' } = e,
    o = t,
    i = useSupported(
      () => o && 'showSaveFilePicker' in o && 'showOpenFilePicker' in o
    ),
    r = ref(),
    a = ref(),
    s = ref(),
    l = computed(() => {
      var e, t
      return null != (t = null == (e = s.value) ? void 0 : e.name) ? t : ''
    }),
    c = computed(() => {
      var e, t
      return null != (t = null == (e = s.value) ? void 0 : e.type) ? t : ''
    }),
    d = computed(() => {
      var e, t
      return null != (t = null == (e = s.value) ? void 0 : e.size) ? t : 0
    }),
    u = computed(() => {
      var e, t
      return null != (t = null == (e = s.value) ? void 0 : e.lastModified)
        ? t
        : 0
    })
  async function p(t = {}) {
    if (!i.value) return
    const [n] = await o.showOpenFilePicker({ ...toValue(e), ...t })
    ;(r.value = n), await g()
  }
  async function h(t = {}) {
    i.value &&
      ((r.value = await o.showSaveFilePicker({ ...e, ...t })),
      (a.value = void 0),
      await g())
  }
  async function m(e = {}) {
    if (i.value) {
      if (!r.value) return f(e)
      if (a.value) {
        const e = await r.value.createWritable()
        await e.write(a.value), await e.close()
      }
      await _()
    }
  }
  async function f(t = {}) {
    if (i.value) {
      if (((r.value = await o.showSaveFilePicker({ ...e, ...t })), a.value)) {
        const e = await r.value.createWritable()
        await e.write(a.value), await e.close()
      }
      await _()
    }
  }
  async function _() {
    var e
    s.value = await (null == (e = r.value) ? void 0 : e.getFile())
  }
  async function g() {
    var e, t
    await _()
    const o = toValue(n)
    'Text' === o
      ? (a.value = await (null == (e = s.value) ? void 0 : e.text()))
      : 'ArrayBuffer' === o
        ? (a.value = await (null == (t = s.value) ? void 0 : t.arrayBuffer()))
        : 'Blob' === o && (a.value = s.value)
  }
  return (
    __name(p, 'open'),
    __name(h, 'create'),
    __name(m, 'save'),
    __name(f, 'saveAs'),
    __name(_, 'updateFile'),
    __name(g, 'updateData'),
    watch(() => toValue(n), g),
    {
      isSupported: i,
      data: a,
      file: s,
      fileName: l,
      fileMIME: c,
      fileSize: d,
      fileLastModified: u,
      open: p,
      create: h,
      save: m,
      saveAs: f,
      updateData: g
    }
  )
}
function useFocus(e, t = {}) {
  const {
      initialValue: n = !1,
      focusVisible: o = !1,
      preventScroll: i = !1
    } = t,
    r = ref(!1),
    a = computed(() => unrefElement(e))
  useEventListener(a, 'focus', (e) => {
    var t, n
    ;(o &&
      !(null == (n = (t = e.target).matches)
        ? void 0
        : n.call(t, ':focus-visible'))) ||
      (r.value = !0)
  }),
    useEventListener(a, 'blur', () => (r.value = !1))
  const s = computed({
    get: __name(() => r.value, 'get'),
    set(e) {
      var t, n
      !e && r.value
        ? null == (t = a.value) || t.blur()
        : e &&
          !r.value &&
          (null == (n = a.value) || n.focus({ preventScroll: i }))
    }
  })
  return (
    watch(
      a,
      () => {
        s.value = n
      },
      { immediate: !0, flush: 'post' }
    ),
    { focused: s }
  )
}
__name(useFileDialog, 'useFileDialog'),
  __name(useFileSystemAccess, 'useFileSystemAccess'),
  __name(useFocus, 'useFocus')
const EVENT_FOCUS_IN = 'focusin',
  EVENT_FOCUS_OUT = 'focusout'
function useFocusWithin(e, t = {}) {
  const { window: n = defaultWindow } = t,
    o = computed(() => unrefElement(e)),
    i = ref(!1),
    r = computed(() => i.value),
    a = useActiveElement(t)
  return n && a.value
    ? (useEventListener(o, EVENT_FOCUS_IN, () => (i.value = !0)),
      useEventListener(o, EVENT_FOCUS_OUT, () => (i.value = !1)),
      { focused: r })
    : { focused: r }
}
function useFps(e) {
  var t
  const n = ref(0)
  if ('undefined' == typeof performance) return n
  const o = null != (t = null == e ? void 0 : e.every) ? t : 10
  let i = performance.now(),
    r = 0
  return (
    useRafFn(() => {
      if (((r += 1), r >= o)) {
        const e = performance.now(),
          t = e - i
        ;(n.value = Math.round(1e3 / (t / r))), (i = e), (r = 0)
      }
    }),
    n
  )
}
__name(useFocusWithin, 'useFocusWithin'), __name(useFps, 'useFps')
const eventHandlers = [
  'fullscreenchange',
  'webkitfullscreenchange',
  'webkitendfullscreen',
  'mozfullscreenchange',
  'MSFullscreenChange'
]
function useFullscreen(e, t = {}) {
  const { document: n = defaultDocument, autoExit: o = !1 } = t,
    i = computed(() => {
      var t
      return null != (t = unrefElement(e))
        ? t
        : null == n
          ? void 0
          : n.querySelector('html')
    }),
    r = ref(!1),
    a = computed(() =>
      [
        'requestFullscreen',
        'webkitRequestFullscreen',
        'webkitEnterFullscreen',
        'webkitEnterFullScreen',
        'webkitRequestFullScreen',
        'mozRequestFullScreen',
        'msRequestFullscreen'
      ].find((e) => (n && e in n) || (i.value && e in i.value))
    ),
    s = computed(() =>
      [
        'exitFullscreen',
        'webkitExitFullscreen',
        'webkitExitFullScreen',
        'webkitCancelFullScreen',
        'mozCancelFullScreen',
        'msExitFullscreen'
      ].find((e) => (n && e in n) || (i.value && e in i.value))
    ),
    l = computed(() =>
      [
        'fullScreen',
        'webkitIsFullScreen',
        'webkitDisplayingFullscreen',
        'mozFullScreen',
        'msFullscreenElement'
      ].find((e) => (n && e in n) || (i.value && e in i.value))
    ),
    c = [
      'fullscreenElement',
      'webkitFullscreenElement',
      'mozFullScreenElement',
      'msFullscreenElement'
    ].find((e) => n && e in n),
    d = useSupported(
      () =>
        i.value &&
        n &&
        void 0 !== a.value &&
        void 0 !== s.value &&
        void 0 !== l.value
    ),
    u = __name(
      () => !!c && (null == n ? void 0 : n[c]) === i.value,
      'isCurrentElementFullScreen'
    ),
    p = __name(() => {
      if (l.value) {
        if (n && null != n[l.value]) return n[l.value]
        {
          const e = i.value
          if (null != (null == e ? void 0 : e[l.value]))
            return Boolean(e[l.value])
        }
      }
      return !1
    }, 'isElementFullScreen')
  async function h() {
    if (d.value && r.value) {
      if (s.value)
        if (null != (null == n ? void 0 : n[s.value])) await n[s.value]()
        else {
          const e = i.value
          null != (null == e ? void 0 : e[s.value]) && (await e[s.value]())
        }
      r.value = !1
    }
  }
  async function m() {
    if (!d.value || r.value) return
    p() && (await h())
    const e = i.value
    a.value &&
      null != (null == e ? void 0 : e[a.value]) &&
      (await e[a.value](), (r.value = !0))
  }
  async function f() {
    await (r.value ? h() : m())
  }
  __name(h, 'exit'), __name(m, 'enter'), __name(f, 'toggle')
  const _ = __name(() => {
    const e = p()
    ;(!e || (e && u())) && (r.value = e)
  }, 'handlerCallback')
  return (
    useEventListener(n, eventHandlers, _, !1),
    useEventListener(() => unrefElement(i), eventHandlers, _, !1),
    o && tryOnScopeDispose(h),
    { isSupported: d, isFullscreen: r, enter: m, exit: h, toggle: f }
  )
}
function mapGamepadToXbox360Controller(e) {
  return computed(() =>
    e.value
      ? {
          buttons: {
            a: e.value.buttons[0],
            b: e.value.buttons[1],
            x: e.value.buttons[2],
            y: e.value.buttons[3]
          },
          bumper: { left: e.value.buttons[4], right: e.value.buttons[5] },
          triggers: { left: e.value.buttons[6], right: e.value.buttons[7] },
          stick: {
            left: {
              horizontal: e.value.axes[0],
              vertical: e.value.axes[1],
              button: e.value.buttons[10]
            },
            right: {
              horizontal: e.value.axes[2],
              vertical: e.value.axes[3],
              button: e.value.buttons[11]
            }
          },
          dpad: {
            up: e.value.buttons[12],
            down: e.value.buttons[13],
            left: e.value.buttons[14],
            right: e.value.buttons[15]
          },
          back: e.value.buttons[8],
          start: e.value.buttons[9]
        }
      : null
  )
}
function useGamepad(e = {}) {
  const { navigator: t = defaultNavigator } = e,
    n = useSupported(() => t && 'getGamepads' in t),
    o = ref([]),
    i = createEventHook(),
    r = createEventHook(),
    a = __name((e) => {
      const t = [],
        n = 'vibrationActuator' in e ? e.vibrationActuator : null
      return (
        n && t.push(n),
        e.hapticActuators && t.push(...e.hapticActuators),
        {
          id: e.id,
          index: e.index,
          connected: e.connected,
          mapping: e.mapping,
          timestamp: e.timestamp,
          vibrationActuator: e.vibrationActuator,
          hapticActuators: t,
          axes: e.axes.map((e) => e),
          buttons: e.buttons.map((e) => ({
            pressed: e.pressed,
            touched: e.touched,
            value: e.value
          }))
        }
      )
    }, 'stateFromGamepad'),
    s = __name(() => {
      const e = (null == t ? void 0 : t.getGamepads()) || []
      for (const t of e) t && o.value[t.index] && (o.value[t.index] = a(t))
    }, 'updateGamepadState'),
    { isActive: l, pause: c, resume: d } = useRafFn(s),
    u = __name((e) => {
      o.value.some(({ index: t }) => t === e.index) ||
        (o.value.push(a(e)), i.trigger(e.index)),
        d()
    }, 'onGamepadConnected'),
    p = __name((e) => {
      ;(o.value = o.value.filter((t) => t.index !== e.index)),
        r.trigger(e.index)
    }, 'onGamepadDisconnected')
  return (
    useEventListener('gamepadconnected', (e) => u(e.gamepad)),
    useEventListener('gamepaddisconnected', (e) => p(e.gamepad)),
    tryOnMounted(() => {
      const e = (null == t ? void 0 : t.getGamepads()) || []
      for (const t of e) t && o.value[t.index] && u(t)
    }),
    c(),
    {
      isSupported: n,
      onConnected: i.on,
      onDisconnected: r.on,
      gamepads: o,
      pause: c,
      resume: d,
      isActive: l
    }
  )
}
function useGeolocation(e = {}) {
  const {
      enableHighAccuracy: t = !0,
      maximumAge: n = 3e4,
      timeout: o = 27e3,
      navigator: i = defaultNavigator,
      immediate: r = !0
    } = e,
    a = useSupported(() => i && 'geolocation' in i),
    s = ref(null),
    l = shallowRef(null),
    c = ref({
      accuracy: 0,
      latitude: Number.POSITIVE_INFINITY,
      longitude: Number.POSITIVE_INFINITY,
      altitude: null,
      altitudeAccuracy: null,
      heading: null,
      speed: null
    })
  function d(e) {
    ;(s.value = e.timestamp), (c.value = e.coords), (l.value = null)
  }
  let u
  function p() {
    a.value &&
      (u = i.geolocation.watchPosition(d, (e) => (l.value = e), {
        enableHighAccuracy: t,
        maximumAge: n,
        timeout: o
      }))
  }
  function h() {
    u && i && i.geolocation.clearWatch(u)
  }
  return (
    __name(d, 'updatePosition'),
    __name(p, 'resume'),
    r && p(),
    __name(h, 'pause'),
    tryOnScopeDispose(() => {
      h()
    }),
    { isSupported: a, coords: c, locatedAt: s, error: l, resume: p, pause: h }
  )
}
__name(useFullscreen, 'useFullscreen'),
  __name(mapGamepadToXbox360Controller, 'mapGamepadToXbox360Controller'),
  __name(useGamepad, 'useGamepad'),
  __name(useGeolocation, 'useGeolocation')
const defaultEvents$1 = [
    'mousemove',
    'mousedown',
    'resize',
    'keydown',
    'touchstart',
    'wheel'
  ],
  oneMinute = 6e4
function useIdle(e = oneMinute, t = {}) {
  const {
      initialState: n = !1,
      listenForVisibilityChange: o = !0,
      events: i = defaultEvents$1,
      window: r = defaultWindow,
      eventFilter: a = throttleFilter(50)
    } = t,
    s = ref(n),
    l = ref(timestamp())
  let c
  const d = __name(() => {
      ;(s.value = !1),
        clearTimeout(c),
        (c = setTimeout(() => (s.value = !0), e))
    }, 'reset'),
    u = createFilterWrapper(a, () => {
      ;(l.value = timestamp()), d()
    })
  if (r) {
    const e = r.document
    for (const t of i) useEventListener(r, t, u, { passive: !0 })
    o &&
      useEventListener(e, 'visibilitychange', () => {
        e.hidden || u()
      }),
      d()
  }
  return { idle: s, lastActive: l, reset: d }
}
async function loadImage(e) {
  return new Promise((t, n) => {
    const o = new Image(),
      {
        src: i,
        srcset: r,
        sizes: a,
        class: s,
        loading: l,
        crossorigin: c,
        referrerPolicy: d
      } = e
    ;(o.src = i),
      r && (o.srcset = r),
      a && (o.sizes = a),
      s && (o.className = s),
      l && (o.loading = l),
      c && (o.crossOrigin = c),
      d && (o.referrerPolicy = d),
      (o.onload = () => t(o)),
      (o.onerror = n)
  })
}
function useImage(e, t = {}) {
  const n = useAsyncState(() => loadImage(toValue(e)), void 0, {
    resetOnExecute: !0,
    ...t
  })
  return (
    watch(
      () => toValue(e),
      () => n.execute(t.delay),
      { deep: !0 }
    ),
    n
  )
}
function resolveElement(e) {
  return 'undefined' != typeof Window && e instanceof Window
    ? e.document.documentElement
    : 'undefined' != typeof Document && e instanceof Document
      ? e.documentElement
      : e
}
__name(useIdle, 'useIdle'),
  __name(loadImage, 'loadImage'),
  __name(useImage, 'useImage'),
  __name(resolveElement, 'resolveElement')
const ARRIVED_STATE_THRESHOLD_PIXELS = 1
function useScroll(e, t = {}) {
  const {
      throttle: n = 0,
      idle: o = 200,
      onStop: i = noop,
      onScroll: r = noop,
      offset: a = { left: 0, right: 0, top: 0, bottom: 0 },
      eventListenerOptions: s = { capture: !1, passive: !0 },
      behavior: l = 'auto',
      window: c = defaultWindow,
      onError: d = __name((e) => {
        console.error(e)
      }, 'onError')
    } = t,
    u = ref(0),
    p = ref(0),
    h = computed({
      get: () => u.value,
      set(e) {
        f(e, void 0)
      }
    }),
    m = computed({
      get: () => p.value,
      set(e) {
        f(void 0, e)
      }
    })
  function f(t, n) {
    var o, i, r, a
    if (!c) return
    const s = toValue(e)
    if (!s) return
    null == (r = s instanceof Document ? c.document.body : s) ||
      r.scrollTo({
        top: null != (o = toValue(n)) ? o : m.value,
        left: null != (i = toValue(t)) ? i : h.value,
        behavior: toValue(l)
      })
    const d =
      (null == (a = null == s ? void 0 : s.document)
        ? void 0
        : a.documentElement) ||
      (null == s ? void 0 : s.documentElement) ||
      s
    null != h && (u.value = d.scrollLeft), null != m && (p.value = d.scrollTop)
  }
  __name(f, 'scrollTo2')
  const _ = ref(!1),
    g = reactive({ left: !0, right: !1, top: !0, bottom: !1 }),
    v = reactive({ left: !1, right: !1, top: !1, bottom: !1 }),
    y = __name((e) => {
      _.value &&
        ((_.value = !1),
        (v.left = !1),
        (v.right = !1),
        (v.top = !1),
        (v.bottom = !1),
        i(e))
    }, 'onScrollEnd'),
    b = useDebounceFn(y, n + o),
    S = __name((e) => {
      var t
      if (!c) return
      const n =
          (null == (t = null == e ? void 0 : e.document)
            ? void 0
            : t.documentElement) ||
          (null == e ? void 0 : e.documentElement) ||
          unrefElement(e),
        { display: o, flexDirection: i } = getComputedStyle(n),
        r = n.scrollLeft
      ;(v.left = r < u.value), (v.right = r > u.value)
      const s = Math.abs(r) <= (a.left || 0),
        l =
          Math.abs(r) + n.clientWidth >=
          n.scrollWidth - (a.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS
      'flex' === o && 'row-reverse' === i
        ? ((g.left = l), (g.right = s))
        : ((g.left = s), (g.right = l)),
        (u.value = r)
      let d = n.scrollTop
      e !== c.document || d || (d = c.document.body.scrollTop),
        (v.top = d < p.value),
        (v.bottom = d > p.value)
      const h = Math.abs(d) <= (a.top || 0),
        m =
          Math.abs(d) + n.clientHeight >=
          n.scrollHeight - (a.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS
      'flex' === o && 'column-reverse' === i
        ? ((g.top = m), (g.bottom = h))
        : ((g.top = h), (g.bottom = m)),
        (p.value = d)
    }, 'setArrivedState'),
    C = __name((e) => {
      var t
      if (!c) return
      const n = null != (t = e.target.documentElement) ? t : e.target
      S(n), (_.value = !0), b(e), r(e)
    }, 'onScrollHandler')
  return (
    useEventListener(e, 'scroll', n ? useThrottleFn(C, n, !0, !1) : C, s),
    tryOnMounted(() => {
      try {
        const t = toValue(e)
        if (!t) return
        S(t)
      } catch (e2) {
        d(e2)
      }
    }),
    useEventListener(e, 'scrollend', y, s),
    {
      x: h,
      y: m,
      isScrolling: _,
      arrivedState: g,
      directions: v,
      measure() {
        const t = toValue(e)
        c && t && S(t)
      }
    }
  )
}
function useInfiniteScroll(e, t, n = {}) {
  var o
  const {
      direction: i = 'bottom',
      interval: r = 100,
      canLoadMore: a = __name(() => !0, 'canLoadMore')
    } = n,
    s = reactive(
      useScroll(e, {
        ...n,
        offset: { [i]: null != (o = n.distance) ? o : 0, ...n.offset }
      })
    ),
    l = ref(),
    c = computed(() => !!l.value),
    d = computed(() => resolveElement(toValue(e))),
    u = useElementVisibility(d)
  function p() {
    if ((s.measure(), !d.value || !u.value || !a(d.value))) return
    const {
        scrollHeight: e,
        clientHeight: n,
        scrollWidth: o,
        clientWidth: c
      } = d.value,
      h = 'bottom' === i || 'top' === i ? e <= n : o <= c
    ;(s.arrivedState[i] || h) &&
      (l.value ||
        (l.value = Promise.all([
          t(s),
          new Promise((e) => setTimeout(e, r))
        ]).finally(() => {
          ;(l.value = null), nextTick(() => p())
        })))
  }
  __name(p, 'checkAndLoad')
  return (
    tryOnUnmounted(
      watch(() => [s.arrivedState[i], u.value], p, { immediate: !0 })
    ),
    {
      isLoading: c,
      reset() {
        nextTick(() => p())
      }
    }
  )
}
__name(useScroll, 'useScroll'), __name(useInfiniteScroll, 'useInfiniteScroll')
const defaultEvents = ['mousedown', 'mouseup', 'keydown', 'keyup']
function useKeyModifier(e, t = {}) {
  const {
      events: n = defaultEvents,
      document: o = defaultDocument,
      initial: i = null
    } = t,
    r = ref(i)
  return (
    o &&
      n.forEach((t) => {
        useEventListener(o, t, (t) => {
          'function' == typeof t.getModifierState &&
            (r.value = t.getModifierState(e))
        })
      }),
    r
  )
}
function useLocalStorage(e, t, n = {}) {
  const { window: o = defaultWindow } = n
  return useStorage(e, t, null == o ? void 0 : o.localStorage, n)
}
__name(useKeyModifier, 'useKeyModifier'),
  __name(useLocalStorage, 'useLocalStorage')
const DefaultMagicKeysAliasMap = {
  ctrl: 'control',
  command: 'meta',
  cmd: 'meta',
  option: 'alt',
  up: 'arrowup',
  down: 'arrowdown',
  left: 'arrowleft',
  right: 'arrowright'
}
function useMagicKeys(e = {}) {
  const {
      reactive: t = !1,
      target: n = defaultWindow,
      aliasMap: o = DefaultMagicKeysAliasMap,
      passive: i = !0,
      onEventFired: r = noop
    } = e,
    a = reactive(new Set()),
    s = { toJSON: () => ({}), current: a },
    l = t ? reactive(s) : s,
    c = new Set(),
    d = new Set()
  function u(e, n) {
    e in l && (t ? (l[e] = n) : (l[e].value = n))
  }
  function p() {
    a.clear()
    for (const e of d) u(e, !1)
  }
  function h(e, t) {
    var n, o
    const i = null == (n = e.key) ? void 0 : n.toLowerCase(),
      r = [null == (o = e.code) ? void 0 : o.toLowerCase(), i].filter(Boolean)
    i && (t ? a.add(i) : a.delete(i))
    for (const a of r) d.add(a), u(a, t)
    'meta' !== i || t
      ? 'function' == typeof e.getModifierState &&
        e.getModifierState('Meta') &&
        t &&
        [...a, ...r].forEach((e) => c.add(e))
      : (c.forEach((e) => {
          a.delete(e), u(e, !1)
        }),
        c.clear())
  }
  __name(u, 'setRefs'),
    __name(p, 'reset'),
    __name(h, 'updateRefs'),
    useEventListener(n, 'keydown', (e) => (h(e, !0), r(e)), { passive: i }),
    useEventListener(n, 'keyup', (e) => (h(e, !1), r(e)), { passive: i }),
    useEventListener('blur', p, { passive: !0 }),
    useEventListener('focus', p, { passive: !0 })
  const m = new Proxy(l, {
    get(e, n, i) {
      if ('string' != typeof n) return Reflect.get(e, n, i)
      if (((n = n.toLowerCase()) in o && (n = o[n]), !(n in l)))
        if (/[+_-]/.test(n)) {
          const e = n.split(/[+_-]/g).map((e) => e.trim())
          l[n] = computed(() => e.every((e) => toValue(m[e])))
        } else l[n] = ref(!1)
      const r = Reflect.get(e, n, i)
      return t ? toValue(r) : r
    }
  })
  return m
}
function usingElRef(e, t) {
  toValue(e) && t(toValue(e))
}
function timeRangeToArray(e) {
  let t = []
  for (let n = 0; n < e.length; ++n) t = [...t, [e.start(n), e.end(n)]]
  return t
}
function tracksToArray(e) {
  return Array.from(e).map(
    (
      {
        label: e,
        kind: t,
        language: n,
        mode: o,
        activeCues: i,
        cues: r,
        inBandMetadataTrackDispatchType: a
      },
      s
    ) => ({
      id: s,
      label: e,
      kind: t,
      language: n,
      mode: o,
      activeCues: i,
      cues: r,
      inBandMetadataTrackDispatchType: a
    })
  )
}
__name(useMagicKeys, 'useMagicKeys'),
  __name(usingElRef, 'usingElRef'),
  __name(timeRangeToArray, 'timeRangeToArray'),
  __name(tracksToArray, 'tracksToArray')
const defaultOptions$1 = { src: '', tracks: [] }
function useMediaControls(e, t = {}) {
  ;(e = toRef(e)), (t = { ...defaultOptions$1, ...t })
  const { document: n = defaultDocument } = t,
    o = ref(0),
    i = ref(0),
    r = ref(!1),
    a = ref(1),
    s = ref(!1),
    l = ref(!1),
    c = ref(!1),
    d = ref(1),
    u = ref(!1),
    p = ref([]),
    h = ref([]),
    m = ref(-1),
    f = ref(!1),
    _ = ref(!1),
    g = n && 'pictureInPictureEnabled' in n,
    v = createEventHook(),
    y = createEventHook(),
    b = __name((t) => {
      usingElRef(e, (e) => {
        if (t) {
          const n = 'number' == typeof t ? t : t.id
          e.textTracks[n].mode = 'disabled'
        } else
          for (let t = 0; t < e.textTracks.length; ++t)
            e.textTracks[t].mode = 'disabled'
        m.value = -1
      })
    }, 'disableTrack'),
    S = __name((t, n = !0) => {
      usingElRef(e, (e) => {
        const o = 'number' == typeof t ? t : t.id
        n && b(), (e.textTracks[o].mode = 'showing'), (m.value = o)
      })
    }, 'enableTrack'),
    C = __name(
      () =>
        new Promise((t, o) => {
          usingElRef(e, async (e) => {
            g &&
              (f.value
                ? n.exitPictureInPicture().then(t).catch(o)
                : e.requestPictureInPicture().then(t).catch(o))
          })
        }),
      'togglePictureInPicture'
    )
  watchEffect(() => {
    if (!n) return
    const o = toValue(e)
    if (!o) return
    const i = toValue(t.src)
    let r = []
    i &&
      ('string' == typeof i
        ? (r = [{ src: i }])
        : Array.isArray(i)
          ? (r = i)
          : isObject$1(i) && (r = [i]),
      o.querySelectorAll('source').forEach((e) => {
        e.removeEventListener('error', v.trigger), e.remove()
      }),
      r.forEach(({ src: e, type: t }) => {
        const i = n.createElement('source')
        i.setAttribute('src', e),
          i.setAttribute('type', t || ''),
          i.addEventListener('error', v.trigger),
          o.appendChild(i)
      }),
      o.load())
  }),
    tryOnScopeDispose(() => {
      const t = toValue(e)
      t &&
        t
          .querySelectorAll('source')
          .forEach((e) => e.removeEventListener('error', v.trigger))
    }),
    watch([e, a], () => {
      const t = toValue(e)
      t && (t.volume = a.value)
    }),
    watch([e, _], () => {
      const t = toValue(e)
      t && (t.muted = _.value)
    }),
    watch([e, d], () => {
      const t = toValue(e)
      t && (t.playbackRate = d.value)
    }),
    watchEffect(() => {
      if (!n) return
      const o = toValue(t.tracks),
        i = toValue(e)
      o &&
        o.length &&
        i &&
        (i.querySelectorAll('track').forEach((e) => e.remove()),
        o.forEach(
          ({ default: e, kind: t, label: o, src: r, srcLang: a }, s) => {
            const l = n.createElement('track')
            ;(l.default = e || !1),
              (l.kind = t),
              (l.label = o),
              (l.src = r),
              (l.srclang = a),
              l.default && (m.value = s),
              i.appendChild(l)
          }
        ))
    })
  const { ignoreUpdates: w } = watchIgnorable(o, (t) => {
      const n = toValue(e)
      n && (n.currentTime = t)
    }),
    { ignoreUpdates: k } = watchIgnorable(c, (t) => {
      const n = toValue(e)
      n &&
        (t
          ? n.play().catch((e) => {
              throw (y.trigger(e), e)
            })
          : n.pause())
    })
  useEventListener(e, 'timeupdate', () =>
    w(() => (o.value = toValue(e).currentTime))
  ),
    useEventListener(
      e,
      'durationchange',
      () => (i.value = toValue(e).duration)
    ),
    useEventListener(
      e,
      'progress',
      () => (p.value = timeRangeToArray(toValue(e).buffered))
    ),
    useEventListener(e, 'seeking', () => (r.value = !0)),
    useEventListener(e, 'seeked', () => (r.value = !1)),
    useEventListener(e, ['waiting', 'loadstart'], () => {
      ;(s.value = !0), k(() => (c.value = !1))
    }),
    useEventListener(e, 'loadeddata', () => (s.value = !1)),
    useEventListener(e, 'playing', () => {
      ;(s.value = !1), (l.value = !1), k(() => (c.value = !0))
    }),
    useEventListener(
      e,
      'ratechange',
      () => (d.value = toValue(e).playbackRate)
    ),
    useEventListener(e, 'stalled', () => (u.value = !0)),
    useEventListener(e, 'ended', () => (l.value = !0)),
    useEventListener(e, 'pause', () => k(() => (c.value = !1))),
    useEventListener(e, 'play', () => k(() => (c.value = !0))),
    useEventListener(e, 'enterpictureinpicture', () => (f.value = !0)),
    useEventListener(e, 'leavepictureinpicture', () => (f.value = !1)),
    useEventListener(e, 'volumechange', () => {
      const t = toValue(e)
      t && ((a.value = t.volume), (_.value = t.muted))
    })
  const x = [],
    E = watch([e], () => {
      const t = toValue(e)
      t &&
        (E(),
        (x[0] = useEventListener(
          t.textTracks,
          'addtrack',
          () => (h.value = tracksToArray(t.textTracks))
        )),
        (x[1] = useEventListener(
          t.textTracks,
          'removetrack',
          () => (h.value = tracksToArray(t.textTracks))
        )),
        (x[2] = useEventListener(
          t.textTracks,
          'change',
          () => (h.value = tracksToArray(t.textTracks))
        )))
    })
  return (
    tryOnScopeDispose(() => x.forEach((e) => e())),
    {
      currentTime: o,
      duration: i,
      waiting: s,
      seeking: r,
      ended: l,
      stalled: u,
      buffered: p,
      playing: c,
      rate: d,
      volume: a,
      muted: _,
      tracks: h,
      selectedTrack: m,
      enableTrack: S,
      disableTrack: b,
      supportsPictureInPicture: g,
      togglePictureInPicture: C,
      isPictureInPicture: f,
      onSourceError: v.on,
      onPlaybackError: y.on
    }
  )
}
function getMapVue2Compat() {
  const e = shallowReactive({})
  return {
    get: __name((t) => e[t], 'get'),
    set: __name((t, n) => set$1(e, t, n), 'set'),
    has: __name((t) => hasOwn$1(e, t), 'has'),
    delete: __name((t) => del(e, t), 'delete'),
    clear: __name(() => {
      Object.keys(e).forEach((t) => {
        del(e, t)
      })
    }, 'clear')
  }
}
function useMemoize(e, t) {
  const n = __name(
      () =>
        (null == t ? void 0 : t.cache)
          ? shallowReactive(t.cache)
          : isVue2
            ? getMapVue2Compat()
            : shallowReactive(new Map()),
      'initCache'
    )(),
    o = __name(
      (...e) =>
        (null == t ? void 0 : t.getKey) ? t.getKey(...e) : JSON.stringify(e),
      'generateKey'
    ),
    i = __name((t, ...o) => (n.set(t, e(...o)), n.get(t)), '_loadData'),
    r = __name((...e) => i(o(...e), ...e), 'loadData'),
    a = __name((...e) => {
      n.delete(o(...e))
    }, 'deleteData'),
    s = __name(() => {
      n.clear()
    }, 'clearData'),
    l = __name((...e) => {
      const t = o(...e)
      return n.has(t) ? n.get(t) : i(t, ...e)
    }, 'memoized')
  return (
    (l.load = r),
    (l.delete = a),
    (l.clear = s),
    (l.generateKey = o),
    (l.cache = n),
    l
  )
}
function useMemory(e = {}) {
  const t = ref(),
    n = useSupported(
      () => 'undefined' != typeof performance && 'memory' in performance
    )
  if (n.value) {
    const { interval: n = 1e3 } = e
    useIntervalFn(
      () => {
        t.value = performance.memory
      },
      n,
      { immediate: e.immediate, immediateCallback: e.immediateCallback }
    )
  }
  return { isSupported: n, memory: t }
}
__name(useMediaControls, 'useMediaControls'),
  __name(getMapVue2Compat, 'getMapVue2Compat'),
  __name(useMemoize, 'useMemoize'),
  __name(useMemory, 'useMemory')
const UseMouseBuiltinExtractors = {
  page: __name((e) => [e.pageX, e.pageY], 'page'),
  client: __name((e) => [e.clientX, e.clientY], 'client'),
  screen: __name((e) => [e.screenX, e.screenY], 'screen'),
  movement: __name(
    (e) => (e instanceof Touch ? null : [e.movementX, e.movementY]),
    'movement'
  )
}
function useMouse(e = {}) {
  const {
    type: t = 'page',
    touch: n = !0,
    resetOnTouchEnds: o = !1,
    initialValue: i = { x: 0, y: 0 },
    window: r = defaultWindow,
    target: a = r,
    scroll: s = !0,
    eventFilter: l
  } = e
  let c = null,
    d = 0,
    u = 0
  const p = ref(i.x),
    h = ref(i.y),
    m = ref(null),
    f = 'function' == typeof t ? t : UseMouseBuiltinExtractors[t],
    _ = __name((e) => {
      const t = f(e)
      ;(c = e),
        t && (([p.value, h.value] = t), (m.value = 'mouse')),
        r && ((d = r.scrollX), (u = r.scrollY))
    }, 'mouseHandler'),
    g = __name((e) => {
      if (e.touches.length > 0) {
        const t = f(e.touches[0])
        t && (([p.value, h.value] = t), (m.value = 'touch'))
      }
    }, 'touchHandler'),
    v = __name(() => {
      if (!c || !r) return
      const e = f(c)
      c instanceof MouseEvent &&
        e &&
        ((p.value = e[0] + r.scrollX - d), (h.value = e[1] + r.scrollY - u))
    }, 'scrollHandler'),
    y = __name(() => {
      ;(p.value = i.x), (h.value = i.y)
    }, 'reset'),
    b = l ? (e) => l(() => _(e), {}) : (e) => _(e),
    S = l ? (e) => l(() => g(e), {}) : (e) => g(e),
    C = l ? () => l(() => v(), {}) : () => v()
  if (a) {
    const e = { passive: !0 }
    useEventListener(a, ['mousemove', 'dragover'], b, e),
      n &&
        'movement' !== t &&
        (useEventListener(a, ['touchstart', 'touchmove'], S, e),
        o && useEventListener(a, 'touchend', y, e)),
      s && 'page' === t && useEventListener(r, 'scroll', C, { passive: !0 })
  }
  return { x: p, y: h, sourceType: m }
}
function useMouseInElement(e, t = {}) {
  const { handleOutside: n = !0, window: o = defaultWindow } = t,
    i = t.type || 'page',
    { x: r, y: a, sourceType: s } = useMouse(t),
    l = ref(null != e ? e : null == o ? void 0 : o.document.body),
    c = ref(0),
    d = ref(0),
    u = ref(0),
    p = ref(0),
    h = ref(0),
    m = ref(0),
    f = ref(!0)
  let _ = __name(() => {}, 'stop')
  return (
    o &&
      ((_ = watch(
        [l, r, a],
        () => {
          const e = unrefElement(l)
          if (!(e && e instanceof Element)) return
          const {
            left: t,
            top: s,
            width: _,
            height: g
          } = e.getBoundingClientRect()
          ;(u.value = t + ('page' === i ? o.pageXOffset : 0)),
            (p.value = s + ('page' === i ? o.pageYOffset : 0)),
            (h.value = g),
            (m.value = _)
          const v = r.value - u.value,
            y = a.value - p.value
          ;(f.value = 0 === _ || 0 === g || v < 0 || y < 0 || v > _ || y > g),
            (!n && f.value) || ((c.value = v), (d.value = y))
        },
        { immediate: !0 }
      )),
      useEventListener(document, 'mouseleave', () => {
        f.value = !0
      })),
    {
      x: r,
      y: a,
      sourceType: s,
      elementX: c,
      elementY: d,
      elementPositionX: u,
      elementPositionY: p,
      elementHeight: h,
      elementWidth: m,
      isOutside: f,
      stop: _
    }
  )
}
function useMousePressed(e = {}) {
  const {
      touch: t = !0,
      drag: n = !0,
      capture: o = !1,
      initialValue: i = !1,
      window: r = defaultWindow
    } = e,
    a = ref(i),
    s = ref(null)
  if (!r) return { pressed: a, sourceType: s }
  const l = __name(
      (e) => () => {
        ;(a.value = !0), (s.value = e)
      },
      'onPressed'
    ),
    c = __name(() => {
      ;(a.value = !1), (s.value = null)
    }, 'onReleased'),
    d = computed(() => unrefElement(e.target) || r)
  return (
    useEventListener(d, 'mousedown', l('mouse'), { passive: !0, capture: o }),
    useEventListener(r, 'mouseleave', c, { passive: !0, capture: o }),
    useEventListener(r, 'mouseup', c, { passive: !0, capture: o }),
    n &&
      (useEventListener(d, 'dragstart', l('mouse'), {
        passive: !0,
        capture: o
      }),
      useEventListener(r, 'drop', c, { passive: !0, capture: o }),
      useEventListener(r, 'dragend', c, { passive: !0, capture: o })),
    t &&
      (useEventListener(d, 'touchstart', l('touch'), {
        passive: !0,
        capture: o
      }),
      useEventListener(r, 'touchend', c, { passive: !0, capture: o }),
      useEventListener(r, 'touchcancel', c, { passive: !0, capture: o })),
    { pressed: a, sourceType: s }
  )
}
function useNavigatorLanguage(e = {}) {
  const { window: t = defaultWindow } = e,
    n = null == t ? void 0 : t.navigator,
    o = useSupported(() => n && 'language' in n),
    i = ref(null == n ? void 0 : n.language)
  return (
    useEventListener(t, 'languagechange', () => {
      n && (i.value = n.language)
    }),
    { isSupported: o, language: i }
  )
}
function useNetwork(e = {}) {
  const { window: t = defaultWindow } = e,
    n = null == t ? void 0 : t.navigator,
    o = useSupported(() => n && 'connection' in n),
    i = ref(!0),
    r = ref(!1),
    a = ref(void 0),
    s = ref(void 0),
    l = ref(void 0),
    c = ref(void 0),
    d = ref(void 0),
    u = ref(void 0),
    p = ref('unknown'),
    h = o.value && n.connection
  function m() {
    n &&
      ((i.value = n.onLine),
      (a.value = i.value ? void 0 : Date.now()),
      (s.value = i.value ? Date.now() : void 0),
      h &&
        ((l.value = h.downlink),
        (c.value = h.downlinkMax),
        (u.value = h.effectiveType),
        (d.value = h.rtt),
        (r.value = h.saveData),
        (p.value = h.type)))
  }
  return (
    __name(m, 'updateNetworkInformation'),
    t &&
      (useEventListener(t, 'offline', () => {
        ;(i.value = !1), (a.value = Date.now())
      }),
      useEventListener(t, 'online', () => {
        ;(i.value = !0), (s.value = Date.now())
      })),
    h && useEventListener(h, 'change', m, !1),
    m(),
    {
      isSupported: readonly(o),
      isOnline: readonly(i),
      saveData: readonly(r),
      offlineAt: readonly(a),
      onlineAt: readonly(s),
      downlink: readonly(l),
      downlinkMax: readonly(c),
      effectiveType: readonly(u),
      rtt: readonly(d),
      type: readonly(p)
    }
  )
}
function useNow(e = {}) {
  const { controls: t = !1, interval: n = 'requestAnimationFrame' } = e,
    o = ref(new Date()),
    i = __name(() => (o.value = new Date()), 'update'),
    r =
      'requestAnimationFrame' === n
        ? useRafFn(i, { immediate: !0 })
        : useIntervalFn(i, n, { immediate: !0 })
  return t ? { now: o, ...r } : o
}
function useObjectUrl(e) {
  const t = ref(),
    n = __name(() => {
      t.value && URL.revokeObjectURL(t.value), (t.value = void 0)
    }, 'release')
  return (
    watch(
      () => toValue(e),
      (e) => {
        n(), e && (t.value = URL.createObjectURL(e))
      },
      { immediate: !0 }
    ),
    tryOnScopeDispose(n),
    readonly(t)
  )
}
function useClamp(e, t, n) {
  if ('function' == typeof e || isReadonly(e))
    return computed(() => clamp(toValue(e), toValue(t), toValue(n)))
  const o = ref(e)
  return computed({
    get: () => (o.value = clamp(o.value, toValue(t), toValue(n))),
    set(e) {
      o.value = clamp(e, toValue(t), toValue(n))
    }
  })
}
function useOffsetPagination(e) {
  const {
      total: t = Number.POSITIVE_INFINITY,
      pageSize: n = 10,
      page: o = 1,
      onPageChange: i = noop,
      onPageSizeChange: r = noop,
      onPageCountChange: a = noop
    } = e,
    s = useClamp(n, 1, Number.POSITIVE_INFINITY),
    l = computed(() => Math.max(1, Math.ceil(toValue(t) / toValue(s)))),
    c = useClamp(o, 1, l),
    d = computed(() => 1 === c.value),
    u = computed(() => c.value === l.value)
  function p() {
    c.value--
  }
  function h() {
    c.value++
  }
  isRef(o) && syncRef(o, c, { direction: isReadonly(o) ? 'ltr' : 'both' }),
    isRef(n) && syncRef(n, s, { direction: isReadonly(n) ? 'ltr' : 'both' }),
    __name(p, 'prev'),
    __name(h, 'next')
  const m = {
    currentPage: c,
    currentPageSize: s,
    pageCount: l,
    isFirstPage: d,
    isLastPage: u,
    prev: p,
    next: h
  }
  return (
    watch(c, () => {
      i(reactive(m))
    }),
    watch(s, () => {
      r(reactive(m))
    }),
    watch(l, () => {
      a(reactive(m))
    }),
    m
  )
}
function useOnline(e = {}) {
  const { isOnline: t } = useNetwork(e)
  return t
}
function usePageLeave(e = {}) {
  const { window: t = defaultWindow } = e,
    n = ref(!1),
    o = __name((e) => {
      if (!t) return
      const o = (e = e || t.event).relatedTarget || e.toElement
      n.value = !o
    }, 'handler')
  return (
    t &&
      (useEventListener(t, 'mouseout', o, { passive: !0 }),
      useEventListener(t.document, 'mouseleave', o, { passive: !0 }),
      useEventListener(t.document, 'mouseenter', o, { passive: !0 })),
    n
  )
}
function useScreenOrientation(e = {}) {
  const { window: t = defaultWindow } = e,
    n = useSupported(() => t && 'screen' in t && 'orientation' in t.screen),
    o = n.value ? t.screen.orientation : {},
    i = ref(o.type),
    r = ref(o.angle || 0)
  n.value &&
    useEventListener(t, 'orientationchange', () => {
      ;(i.value = o.type), (r.value = o.angle)
    })
  return {
    isSupported: n,
    orientation: i,
    angle: r,
    lockOrientation: __name(
      (e) =>
        n.value && 'function' == typeof o.lock
          ? o.lock(e)
          : Promise.reject(new Error('Not supported')),
      'lockOrientation'
    ),
    unlockOrientation: __name(() => {
      n.value && 'function' == typeof o.unlock && o.unlock()
    }, 'unlockOrientation')
  }
}
function useParallax(e, t = {}) {
  const {
      deviceOrientationTiltAdjust: n = __name(
        (e) => e,
        'deviceOrientationTiltAdjust'
      ),
      deviceOrientationRollAdjust: o = __name(
        (e) => e,
        'deviceOrientationRollAdjust'
      ),
      mouseTiltAdjust: i = __name((e) => e, 'mouseTiltAdjust'),
      mouseRollAdjust: r = __name((e) => e, 'mouseRollAdjust'),
      window: a = defaultWindow
    } = t,
    s = reactive(useDeviceOrientation({ window: a })),
    l = reactive(useScreenOrientation({ window: a })),
    {
      elementX: c,
      elementY: d,
      elementWidth: u,
      elementHeight: p
    } = useMouseInElement(e, { handleOutside: !1, window: a }),
    h = computed(() =>
      s.isSupported &&
      ((null != s.alpha && 0 !== s.alpha) || (null != s.gamma && 0 !== s.gamma))
        ? 'deviceOrientation'
        : 'mouse'
    )
  return {
    roll: computed(() => {
      if ('deviceOrientation' === h.value) {
        let e
        switch (l.orientation) {
          case 'landscape-primary':
            e = s.gamma / 90
            break
          case 'landscape-secondary':
            e = -s.gamma / 90
            break
          case 'portrait-primary':
          default:
            e = -s.beta / 90
            break
          case 'portrait-secondary':
            e = s.beta / 90
        }
        return o(e)
      }
      {
        const e = -(d.value - p.value / 2) / p.value
        return r(e)
      }
    }),
    tilt: computed(() => {
      if ('deviceOrientation' === h.value) {
        let e
        switch (l.orientation) {
          case 'landscape-primary':
            e = s.beta / 90
            break
          case 'landscape-secondary':
            e = -s.beta / 90
            break
          case 'portrait-primary':
          default:
            e = s.gamma / 90
            break
          case 'portrait-secondary':
            e = -s.gamma / 90
        }
        return n(e)
      }
      {
        const e = (c.value - u.value / 2) / u.value
        return i(e)
      }
    }),
    source: h
  }
}
function useParentElement(e = useCurrentElement()) {
  const t = shallowRef(),
    n = __name(() => {
      const n = unrefElement(e)
      n && (t.value = n.parentElement)
    }, 'update')
  return tryOnMounted(n), watch(() => toValue(e), n), t
}
function usePerformanceObserver(e, t) {
  const { window: n = defaultWindow, immediate: o = !0, ...i } = e,
    r = useSupported(() => n && 'PerformanceObserver' in n)
  let a
  const s = __name(() => {
      null == a || a.disconnect()
    }, 'stop'),
    l = __name(() => {
      r.value && (s(), (a = new PerformanceObserver(t)), a.observe(i))
    }, 'start')
  return tryOnScopeDispose(s), o && l(), { isSupported: r, start: l, stop: s }
}
__name(useMouse, 'useMouse'),
  __name(useMouseInElement, 'useMouseInElement'),
  __name(useMousePressed, 'useMousePressed'),
  __name(useNavigatorLanguage, 'useNavigatorLanguage'),
  __name(useNetwork, 'useNetwork'),
  __name(useNow, 'useNow'),
  __name(useObjectUrl, 'useObjectUrl'),
  __name(useClamp, 'useClamp'),
  __name(useOffsetPagination, 'useOffsetPagination'),
  __name(useOnline, 'useOnline'),
  __name(usePageLeave, 'usePageLeave'),
  __name(useScreenOrientation, 'useScreenOrientation'),
  __name(useParallax, 'useParallax'),
  __name(useParentElement, 'useParentElement'),
  __name(usePerformanceObserver, 'usePerformanceObserver')
const defaultState = {
    x: 0,
    y: 0,
    pointerId: 0,
    pressure: 0,
    tiltX: 0,
    tiltY: 0,
    width: 0,
    height: 0,
    twist: 0,
    pointerType: null
  },
  keys = Object.keys(defaultState)
function usePointer(e = {}) {
  const { target: t = defaultWindow } = e,
    n = ref(!1),
    o = ref(e.initialValue || {})
  Object.assign(o.value, defaultState, o.value)
  if (t) {
    const i = { passive: !0 }
    useEventListener(
      t,
      ['pointerdown', 'pointermove', 'pointerup'],
      __name((t) => {
        ;(n.value = !0),
          (e.pointerTypes && !e.pointerTypes.includes(t.pointerType)) ||
            (o.value = objectPick(t, keys, !1))
      }, 'handler'),
      i
    ),
      useEventListener(t, 'pointerleave', () => (n.value = !1), i)
  }
  return { ...toRefs(o), isInside: n }
}
function usePointerLock(e, t = {}) {
  const { document: n = defaultDocument } = t,
    o = useSupported(() => n && 'pointerLockElement' in n),
    i = ref(),
    r = ref()
  let a
  async function s(t) {
    var n
    if (!o.value)
      throw new Error('Pointer Lock API is not supported by your browser.')
    if (
      ((r.value = t instanceof Event ? t.currentTarget : null),
      (a =
        t instanceof Event
          ? null != (n = unrefElement(e))
            ? n
            : r.value
          : unrefElement(t)),
      !a)
    )
      throw new Error('Target element undefined.')
    return a.requestPointerLock(), await until(i).toBe(a)
  }
  async function l() {
    return !!i.value && (n.exitPointerLock(), await until(i).toBeNull(), !0)
  }
  return (
    o.value &&
      (useEventListener(n, 'pointerlockchange', () => {
        var e
        const t = null != (e = n.pointerLockElement) ? e : i.value
        a &&
          t === a &&
          ((i.value = n.pointerLockElement), i.value || (a = r.value = null))
      }),
      useEventListener(n, 'pointerlockerror', () => {
        var e
        const t = null != (e = n.pointerLockElement) ? e : i.value
        if (a && t === a) {
          const e = n.pointerLockElement ? 'release' : 'acquire'
          throw new Error(`Failed to ${e} pointer lock.`)
        }
      })),
    __name(s, 'lock'),
    __name(l, 'unlock'),
    { isSupported: o, element: i, triggerElement: r, lock: s, unlock: l }
  )
}
function usePointerSwipe(e, t = {}) {
  const n = toRef(e),
    {
      threshold: o = 50,
      onSwipe: i,
      onSwipeEnd: r,
      onSwipeStart: a,
      disableTextSelect: s = !1
    } = t,
    l = reactive({ x: 0, y: 0 }),
    c = __name((e, t) => {
      ;(l.x = e), (l.y = t)
    }, 'updatePosStart'),
    d = reactive({ x: 0, y: 0 }),
    u = __name((e, t) => {
      ;(d.x = e), (d.y = t)
    }, 'updatePosEnd'),
    p = computed(() => l.x - d.x),
    h = computed(() => l.y - d.y),
    { max: m, abs: f } = Math,
    _ = computed(() => m(f(p.value), f(h.value)) >= o),
    g = ref(!1),
    v = ref(!1),
    y = computed(() =>
      _.value
        ? f(p.value) > f(h.value)
          ? p.value > 0
            ? 'left'
            : 'right'
          : h.value > 0
            ? 'up'
            : 'down'
        : 'none'
    ),
    b = __name((e) => {
      var n, o, i
      const r = 0 === e.buttons,
        a = 1 === e.buttons
      return (
        null ==
          (i =
            null !=
            (o =
              null == (n = t.pointerTypes) ? void 0 : n.includes(e.pointerType))
              ? o
              : r || a) || i
      )
    }, 'eventIsAllowed'),
    S = [
      useEventListener(e, 'pointerdown', (e) => {
        if (!b(e)) return
        v.value = !0
        const t = e.target
        null == t || t.setPointerCapture(e.pointerId)
        const { clientX: n, clientY: o } = e
        c(n, o), u(n, o), null == a || a(e)
      }),
      useEventListener(e, 'pointermove', (e) => {
        if (!b(e)) return
        if (!v.value) return
        const { clientX: t, clientY: n } = e
        u(t, n),
          !g.value && _.value && (g.value = !0),
          g.value && (null == i || i(e))
      }),
      useEventListener(e, 'pointerup', (e) => {
        b(e) &&
          (g.value && (null == r || r(e, y.value)),
          (v.value = !1),
          (g.value = !1))
      })
    ]
  tryOnMounted(() => {
    var e, t, o, i, r, a, l, c
    null == (t = null == (e = n.value) ? void 0 : e.style) ||
      t.setProperty('touch-action', 'none'),
      s &&
        (null == (i = null == (o = n.value) ? void 0 : o.style) ||
          i.setProperty('-webkit-user-select', 'none'),
        null == (a = null == (r = n.value) ? void 0 : r.style) ||
          a.setProperty('-ms-user-select', 'none'),
        null == (c = null == (l = n.value) ? void 0 : l.style) ||
          c.setProperty('user-select', 'none'))
  })
  const C = __name(() => S.forEach((e) => e()), 'stop')
  return {
    isSwiping: readonly(g),
    direction: readonly(y),
    posStart: readonly(l),
    posEnd: readonly(d),
    distanceX: p,
    distanceY: h,
    stop: C
  }
}
function usePreferredColorScheme(e) {
  const t = useMediaQuery('(prefers-color-scheme: light)', e),
    n = useMediaQuery('(prefers-color-scheme: dark)', e)
  return computed(() =>
    n.value ? 'dark' : t.value ? 'light' : 'no-preference'
  )
}
function usePreferredContrast(e) {
  const t = useMediaQuery('(prefers-contrast: more)', e),
    n = useMediaQuery('(prefers-contrast: less)', e),
    o = useMediaQuery('(prefers-contrast: custom)', e)
  return computed(() =>
    t.value ? 'more' : n.value ? 'less' : o.value ? 'custom' : 'no-preference'
  )
}
function usePreferredLanguages(e = {}) {
  const { window: t = defaultWindow } = e
  if (!t) return ref(['en'])
  const n = t.navigator,
    o = ref(n.languages)
  return (
    useEventListener(t, 'languagechange', () => {
      o.value = n.languages
    }),
    o
  )
}
function usePreferredReducedMotion(e) {
  const t = useMediaQuery('(prefers-reduced-motion: reduce)', e)
  return computed(() => (t.value ? 'reduce' : 'no-preference'))
}
function usePrevious(e, t) {
  const n = shallowRef(t)
  return (
    watch(
      toRef(e),
      (e, t) => {
        n.value = t
      },
      { flush: 'sync' }
    ),
    readonly(n)
  )
}
__name(usePointer, 'usePointer'),
  __name(usePointerLock, 'usePointerLock'),
  __name(usePointerSwipe, 'usePointerSwipe'),
  __name(usePreferredColorScheme, 'usePreferredColorScheme'),
  __name(usePreferredContrast, 'usePreferredContrast'),
  __name(usePreferredLanguages, 'usePreferredLanguages'),
  __name(usePreferredReducedMotion, 'usePreferredReducedMotion'),
  __name(usePrevious, 'usePrevious')
const topVarName = '--vueuse-safe-area-top',
  rightVarName = '--vueuse-safe-area-right',
  bottomVarName = '--vueuse-safe-area-bottom',
  leftVarName = '--vueuse-safe-area-left'
function useScreenSafeArea() {
  const e = ref(''),
    t = ref(''),
    n = ref(''),
    o = ref('')
  if (isClient) {
    const e = useCssVar(topVarName),
      t = useCssVar(rightVarName),
      n = useCssVar(bottomVarName),
      o = useCssVar(leftVarName)
    ;(e.value = 'env(safe-area-inset-top, 0px)'),
      (t.value = 'env(safe-area-inset-right, 0px)'),
      (n.value = 'env(safe-area-inset-bottom, 0px)'),
      (o.value = 'env(safe-area-inset-left, 0px)'),
      i(),
      useEventListener('resize', useDebounceFn(i))
  }
  function i() {
    ;(e.value = getValue(topVarName)),
      (t.value = getValue(rightVarName)),
      (n.value = getValue(bottomVarName)),
      (o.value = getValue(leftVarName))
  }
  return (
    __name(i, 'update'), { top: e, right: t, bottom: n, left: o, update: i }
  )
}
function getValue(e) {
  return getComputedStyle(document.documentElement).getPropertyValue(e)
}
function useScriptTag(e, t = noop, n = {}) {
  const {
      immediate: o = !0,
      manual: i = !1,
      type: r = 'text/javascript',
      async: a = !0,
      crossOrigin: s,
      referrerPolicy: l,
      noModule: c,
      defer: d,
      document: u = defaultDocument,
      attrs: p = {}
    } = n,
    h = ref(null)
  let m = null
  const f = __name(
      (n) =>
        new Promise((o, i) => {
          const m = __name(
            (e) => ((h.value = e), o(e), e),
            'resolveWithElement'
          )
          if (!u) return void o(!1)
          let f = !1,
            _ = u.querySelector(`script[src="${toValue(e)}"]`)
          _
            ? _.hasAttribute('data-loaded') && m(_)
            : ((_ = u.createElement('script')),
              (_.type = r),
              (_.async = a),
              (_.src = toValue(e)),
              d && (_.defer = d),
              s && (_.crossOrigin = s),
              c && (_.noModule = c),
              l && (_.referrerPolicy = l),
              Object.entries(p).forEach(([e, t]) =>
                null == _ ? void 0 : _.setAttribute(e, t)
              ),
              (f = !0)),
            _.addEventListener('error', (e) => i(e)),
            _.addEventListener('abort', (e) => i(e)),
            _.addEventListener('load', () => {
              _.setAttribute('data-loaded', 'true'), t(_), m(_)
            }),
            f && (_ = u.head.appendChild(_)),
            n || m(_)
        }),
      'loadScript'
    ),
    _ = __name((e = !0) => (m || (m = f(e)), m), 'load'),
    g = __name(() => {
      if (!u) return
      ;(m = null), h.value && (h.value = null)
      const t = u.querySelector(`script[src="${toValue(e)}"]`)
      t && u.head.removeChild(t)
    }, 'unload')
  return (
    o && !i && tryOnMounted(_),
    i || tryOnUnmounted(g),
    { scriptTag: h, load: _, unload: g }
  )
}
function checkOverflowScroll(e) {
  const t = window.getComputedStyle(e)
  if (
    'scroll' === t.overflowX ||
    'scroll' === t.overflowY ||
    ('auto' === t.overflowX && e.clientWidth < e.scrollWidth) ||
    ('auto' === t.overflowY && e.clientHeight < e.scrollHeight)
  )
    return !0
  {
    const t = e.parentNode
    return !(!t || 'BODY' === t.tagName) && checkOverflowScroll(t)
  }
}
function preventDefault(e) {
  const t = e || window.event
  return (
    !checkOverflowScroll(t.target) &&
    (t.touches.length > 1 || (t.preventDefault && t.preventDefault(), !1))
  )
}
__name(useScreenSafeArea, 'useScreenSafeArea'),
  __name(getValue, 'getValue'),
  __name(useScriptTag, 'useScriptTag'),
  __name(checkOverflowScroll, 'checkOverflowScroll'),
  __name(preventDefault, 'preventDefault')
const elInitialOverflow = new WeakMap()
function useScrollLock(e, t = !1) {
  const n = ref(t)
  let o = null,
    i = ''
  watch(
    toRef(e),
    (e) => {
      const t = resolveElement(toValue(e))
      if (t) {
        const e = t
        if (
          (elInitialOverflow.get(e) ||
            elInitialOverflow.set(e, e.style.overflow),
          'hidden' !== e.style.overflow && (i = e.style.overflow),
          'hidden' === e.style.overflow)
        )
          return (n.value = !0)
        if (n.value) return (e.style.overflow = 'hidden')
      }
    },
    { immediate: !0 }
  )
  const r = __name(() => {
      const t = resolveElement(toValue(e))
      t &&
        !n.value &&
        (isIOS &&
          (o = useEventListener(
            t,
            'touchmove',
            (e) => {
              preventDefault(e)
            },
            { passive: !1 }
          )),
        (t.style.overflow = 'hidden'),
        (n.value = !0))
    }, 'lock'),
    a = __name(() => {
      const t = resolveElement(toValue(e))
      t &&
        n.value &&
        (isIOS && (null == o || o()),
        (t.style.overflow = i),
        elInitialOverflow.delete(t),
        (n.value = !1))
    }, 'unlock')
  return (
    tryOnScopeDispose(a),
    computed({
      get: () => n.value,
      set(e) {
        e ? r() : a()
      }
    })
  )
}
function useSessionStorage(e, t, n = {}) {
  const { window: o = defaultWindow } = n
  return useStorage(e, t, null == o ? void 0 : o.sessionStorage, n)
}
function useShare(e = {}, t = {}) {
  const { navigator: n = defaultNavigator } = t,
    o = n,
    i = useSupported(() => o && 'canShare' in o)
  return {
    isSupported: i,
    share: __name(async (t = {}) => {
      if (i.value) {
        const n = { ...toValue(e), ...toValue(t) }
        let i = !0
        if ((n.files && o.canShare && (i = o.canShare({ files: n.files })), i))
          return o.share(n)
      }
    }, 'share')
  }
}
__name(useScrollLock, 'useScrollLock'),
  __name(useSessionStorage, 'useSessionStorage'),
  __name(useShare, 'useShare')
const defaultSortFn = __name((e, t) => e.sort(t), 'defaultSortFn'),
  defaultCompare = __name((e, t) => e - t, 'defaultCompare')
function useSorted(...e) {
  var t, n, o, i
  const [r] = e
  let a = defaultCompare,
    s = {}
  2 === e.length
    ? 'object' == typeof e[1]
      ? ((s = e[1]), (a = null != (t = s.compareFn) ? t : defaultCompare))
      : (a = null != (n = e[1]) ? n : defaultCompare)
    : e.length > 2 &&
      ((a = null != (o = e[1]) ? o : defaultCompare),
      (s = null != (i = e[2]) ? i : {}))
  const { dirty: l = !1, sortFn: c = defaultSortFn } = s
  return l
    ? (watchEffect(() => {
        const e = c(toValue(r), a)
        isRef(r) ? (r.value = e) : r.splice(0, r.length, ...e)
      }),
      r)
    : computed(() => c([...toValue(r)], a))
}
function useSpeechRecognition(e = {}) {
  const {
      interimResults: t = !0,
      continuous: n = !0,
      maxAlternatives: o = 1,
      window: i = defaultWindow
    } = e,
    r = toRef(e.lang || 'en-US'),
    a = ref(!1),
    s = ref(!1),
    l = ref(''),
    c = shallowRef(void 0),
    d = __name((e = !a.value) => {
      a.value = e
    }, 'toggle'),
    u = __name(() => {
      a.value = !0
    }, 'start'),
    p = __name(() => {
      a.value = !1
    }, 'stop'),
    h = i && (i.SpeechRecognition || i.webkitSpeechRecognition),
    m = useSupported(() => h)
  let f
  return (
    m.value &&
      ((f = new h()),
      (f.continuous = n),
      (f.interimResults = t),
      (f.lang = toValue(r)),
      (f.maxAlternatives = o),
      (f.onstart = () => {
        s.value = !1
      }),
      watch(r, (e) => {
        f && !a.value && (f.lang = e)
      }),
      (f.onresult = (e) => {
        const t = e.results[e.resultIndex],
          { transcript: n } = t[0]
        ;(s.value = t.isFinal), (l.value = n), (c.value = void 0)
      }),
      (f.onerror = (e) => {
        c.value = e
      }),
      (f.onend = () => {
        ;(a.value = !1), (f.lang = toValue(r))
      }),
      watch(a, () => {
        a.value ? f.start() : f.stop()
      })),
    tryOnScopeDispose(() => {
      a.value = !1
    }),
    {
      isSupported: m,
      isListening: a,
      isFinal: s,
      recognition: f,
      result: l,
      error: c,
      toggle: d,
      start: u,
      stop: p
    }
  )
}
function useSpeechSynthesis(e, t = {}) {
  const {
      pitch: n = 1,
      rate: o = 1,
      volume: i = 1,
      window: r = defaultWindow
    } = t,
    a = r && r.speechSynthesis,
    s = useSupported(() => a),
    l = ref(!1),
    c = ref('init'),
    d = toRef(e || ''),
    u = toRef(t.lang || 'en-US'),
    p = shallowRef(void 0),
    h = __name((e = !l.value) => {
      l.value = e
    }, 'toggle'),
    m = __name((e) => {
      ;(e.lang = toValue(u)),
        (e.voice = toValue(t.voice) || null),
        (e.pitch = toValue(n)),
        (e.rate = toValue(o)),
        (e.volume = i),
        (e.onstart = () => {
          ;(l.value = !0), (c.value = 'play')
        }),
        (e.onpause = () => {
          ;(l.value = !1), (c.value = 'pause')
        }),
        (e.onresume = () => {
          ;(l.value = !0), (c.value = 'play')
        }),
        (e.onend = () => {
          ;(l.value = !1), (c.value = 'end')
        }),
        (e.onerror = (e) => {
          p.value = e
        })
    }, 'bindEventsForUtterance'),
    f = computed(() => {
      ;(l.value = !1), (c.value = 'init')
      const e = new SpeechSynthesisUtterance(d.value)
      return m(e), e
    }),
    _ = __name(() => {
      a.cancel(), f && a.speak(f.value)
    }, 'speak'),
    g = __name(() => {
      a.cancel(), (l.value = !1)
    }, 'stop')
  return (
    s.value &&
      (m(f.value),
      watch(u, (e) => {
        f.value && !l.value && (f.value.lang = e)
      }),
      t.voice &&
        watch(t.voice, () => {
          a.cancel()
        }),
      watch(l, () => {
        l.value ? a.resume() : a.pause()
      })),
    tryOnScopeDispose(() => {
      l.value = !1
    }),
    {
      isSupported: s,
      isPlaying: l,
      status: c,
      utterance: f,
      error: p,
      stop: g,
      toggle: h,
      speak: _
    }
  )
}
function useStepper(e, t) {
  const n = ref(e),
    o = computed(() =>
      Array.isArray(n.value) ? n.value : Object.keys(n.value)
    ),
    i = ref(o.value.indexOf(null != t ? t : o.value[0])),
    r = computed(() => d(i.value)),
    a = computed(() => 0 === i.value),
    s = computed(() => i.value === o.value.length - 1),
    l = computed(() => o.value[i.value + 1]),
    c = computed(() => o.value[i.value - 1])
  function d(e) {
    return Array.isArray(n.value) ? n.value[e] : n.value[o.value[e]]
  }
  function u(e) {
    if (o.value.includes(e)) return d(o.value.indexOf(e))
  }
  function p(e) {
    o.value.includes(e) && (i.value = o.value.indexOf(e))
  }
  function h() {
    s.value || i.value++
  }
  function m() {
    a.value || i.value--
  }
  function f(e) {
    b(e) && p(e)
  }
  function _(e) {
    return o.value.indexOf(e) === i.value + 1
  }
  function g(e) {
    return o.value.indexOf(e) === i.value - 1
  }
  function v(e) {
    return o.value.indexOf(e) === i.value
  }
  function y(e) {
    return i.value < o.value.indexOf(e)
  }
  function b(e) {
    return i.value > o.value.indexOf(e)
  }
  return (
    __name(d, 'at'),
    __name(u, 'get'),
    __name(p, 'goTo'),
    __name(h, 'goToNext'),
    __name(m, 'goToPrevious'),
    __name(f, 'goBackTo'),
    __name(_, 'isNext'),
    __name(g, 'isPrevious'),
    __name(v, 'isCurrent'),
    __name(y, 'isBefore'),
    __name(b, 'isAfter'),
    {
      steps: n,
      stepNames: o,
      index: i,
      current: r,
      next: l,
      previous: c,
      isFirst: a,
      isLast: s,
      at: d,
      get: u,
      goTo: p,
      goToNext: h,
      goToPrevious: m,
      goBackTo: f,
      isNext: _,
      isPrevious: g,
      isCurrent: v,
      isBefore: y,
      isAfter: b
    }
  )
}
function useStorageAsync(e, t, n, o = {}) {
  var i
  const {
      flush: r = 'pre',
      deep: a = !0,
      listenToStorageChanges: s = !0,
      writeDefaults: l = !0,
      mergeDefaults: c = !1,
      shallow: d,
      window: u = defaultWindow,
      eventFilter: p,
      onError: h = __name((e) => {
        console.error(e)
      }, 'onError')
    } = o,
    m = toValue(t),
    f = guessSerializerType(m),
    _ = (d ? shallowRef : ref)(t),
    g = null != (i = o.serializer) ? i : StorageSerializers[f]
  if (!n)
    try {
      n = getSSRHandler('getDefaultStorageAsync', () => {
        var e
        return null == (e = defaultWindow) ? void 0 : e.localStorage
      })()
    } catch (e2) {
      h(e2)
    }
  async function v(t) {
    if (n && (!t || t.key === e))
      try {
        const o = t ? t.newValue : await n.getItem(e)
        if (null == o)
          (_.value = m),
            l && null !== m && (await n.setItem(e, await g.write(m)))
        else if (c) {
          const e = await g.read(o)
          'function' == typeof c
            ? (_.value = c(e, m))
            : 'object' !== f || Array.isArray(e)
              ? (_.value = e)
              : (_.value = { ...m, ...e })
        } else _.value = await g.read(o)
      } catch (e2) {
        h(e2)
      }
  }
  return (
    __name(v, 'read'),
    v(),
    u &&
      s &&
      useEventListener(u, 'storage', (e) => Promise.resolve().then(() => v(e))),
    n &&
      watchWithFilter(
        _,
        async () => {
          try {
            null == _.value
              ? await n.removeItem(e)
              : await n.setItem(e, await g.write(_.value))
          } catch (e2) {
            h(e2)
          }
        },
        { flush: r, deep: a, eventFilter: p }
      ),
    _
  )
}
__name(useSorted, 'useSorted'),
  __name(useSpeechRecognition, 'useSpeechRecognition'),
  __name(useSpeechSynthesis, 'useSpeechSynthesis'),
  __name(useStepper, 'useStepper'),
  __name(useStorageAsync, 'useStorageAsync')
let _id = 0
function useStyleTag(e, t = {}) {
  const n = ref(!1),
    {
      document: o = defaultDocument,
      immediate: i = !0,
      manual: r = !1,
      id: a = 'vueuse_styletag_' + ++_id
    } = t,
    s = ref(e)
  let l = __name(() => {}, 'stop')
  const c = __name(() => {
      if (!o) return
      const e = o.getElementById(a) || o.createElement('style')
      e.isConnected ||
        ((e.id = a), t.media && (e.media = t.media), o.head.appendChild(e)),
        n.value ||
          ((l = watch(
            s,
            (t) => {
              e.textContent = t
            },
            { immediate: !0 }
          )),
          (n.value = !0))
    }, 'load'),
    d = __name(() => {
      o &&
        n.value &&
        (l(), o.head.removeChild(o.getElementById(a)), (n.value = !1))
    }, 'unload')
  return (
    i && !r && tryOnMounted(c),
    r || tryOnScopeDispose(d),
    { id: a, css: s, unload: d, load: c, isLoaded: readonly(n) }
  )
}
function useSwipe(e, t = {}) {
  const {
      threshold: n = 50,
      onSwipe: o,
      onSwipeEnd: i,
      onSwipeStart: r,
      passive: a = !0,
      window: s = defaultWindow
    } = t,
    l = reactive({ x: 0, y: 0 }),
    c = reactive({ x: 0, y: 0 }),
    d = computed(() => l.x - c.x),
    u = computed(() => l.y - c.y),
    { max: p, abs: h } = Math,
    m = computed(() => p(h(d.value), h(u.value)) >= n),
    f = ref(!1),
    _ = computed(() =>
      m.value
        ? h(d.value) > h(u.value)
          ? d.value > 0
            ? 'left'
            : 'right'
          : u.value > 0
            ? 'up'
            : 'down'
        : 'none'
    ),
    g = __name(
      (e) => [e.touches[0].clientX, e.touches[0].clientY],
      'getTouchEventCoords'
    ),
    v = __name((e, t) => {
      ;(l.x = e), (l.y = t)
    }, 'updateCoordsStart'),
    y = __name((e, t) => {
      ;(c.x = e), (c.y = t)
    }, 'updateCoordsEnd')
  let b
  const S = checkPassiveEventSupport(null == s ? void 0 : s.document)
  b = a
    ? S
      ? { passive: !0 }
      : { capture: !1 }
    : S
      ? { passive: !1, capture: !0 }
      : { capture: !0 }
  const C = __name((e) => {
      f.value && (null == i || i(e, _.value)), (f.value = !1)
    }, 'onTouchEnd'),
    w = [
      useEventListener(
        e,
        'touchstart',
        (e) => {
          if (1 !== e.touches.length) return
          const [t, n] = g(e)
          v(t, n), y(t, n), null == r || r(e)
        },
        b
      ),
      useEventListener(
        e,
        'touchmove',
        (e) => {
          if (1 !== e.touches.length) return
          const [t, n] = g(e)
          y(t, n),
            b.capture &&
              !b.passive &&
              Math.abs(d.value) > Math.abs(u.value) &&
              e.preventDefault(),
            !f.value && m.value && (f.value = !0),
            f.value && (null == o || o(e))
        },
        b
      ),
      useEventListener(e, ['touchend', 'touchcancel'], C, b)
    ]
  return {
    isPassiveEventSupported: S,
    isSwiping: f,
    direction: _,
    coordsStart: l,
    coordsEnd: c,
    lengthX: d,
    lengthY: u,
    stop: __name(() => w.forEach((e) => e()), 'stop')
  }
}
function checkPassiveEventSupport(e) {
  if (!e) return !1
  let t = !1
  const n = {
    get passive() {
      return (t = !0), !1
    }
  }
  return e.addEventListener('x', noop, n), e.removeEventListener('x', noop), t
}
function useTemplateRefsList() {
  const e = ref([])
  return (
    (e.value.set = (t) => {
      t && e.value.push(t)
    }),
    onBeforeUpdate(() => {
      e.value.length = 0
    }),
    e
  )
}
function useTextDirection(e = {}) {
  const {
    document: t = defaultDocument,
    selector: n = 'html',
    observe: o = !1,
    initialValue: i = 'ltr'
  } = e
  function r() {
    var e, o
    return null !=
      (o =
        null == (e = null == t ? void 0 : t.querySelector(n))
          ? void 0
          : e.getAttribute('dir'))
      ? o
      : i
  }
  __name(r, 'getValue2')
  const a = ref(r())
  return (
    tryOnMounted(() => (a.value = r())),
    o &&
      t &&
      useMutationObserver(t.querySelector(n), () => (a.value = r()), {
        attributes: !0
      }),
    computed({
      get: () => a.value,
      set(e) {
        var o, i
        ;(a.value = e),
          t &&
            (a.value
              ? null == (o = t.querySelector(n)) ||
                o.setAttribute('dir', a.value)
              : null == (i = t.querySelector(n)) || i.removeAttribute('dir'))
      }
    })
  )
}
function getRangesFromSelection(e) {
  var t
  const n = null != (t = e.rangeCount) ? t : 0
  return Array.from({ length: n }, (t, n) => e.getRangeAt(n))
}
function useTextSelection(e = {}) {
  const { window: t = defaultWindow } = e,
    n = ref(null),
    o = computed(() => {
      var e, t
      return null != (t = null == (e = n.value) ? void 0 : e.toString())
        ? t
        : ''
    }),
    i = computed(() => (n.value ? getRangesFromSelection(n.value) : [])),
    r = computed(() => i.value.map((e) => e.getBoundingClientRect()))
  function a() {
    ;(n.value = null), t && (n.value = t.getSelection())
  }
  return (
    __name(a, 'onSelectionChange'),
    t && useEventListener(t.document, 'selectionchange', a),
    { text: o, rects: r, ranges: i, selection: n }
  )
}
function useTextareaAutosize(e) {
  var t
  const n = ref(null == e ? void 0 : e.element),
    o = ref(null == e ? void 0 : e.input),
    i = null != (t = null == e ? void 0 : e.styleProp) ? t : 'height',
    r = ref(1),
    a = ref(0)
  function s() {
    var t
    if (!n.value) return
    let o = ''
    ;(n.value.style[i] = '1px'),
      (r.value = null == (t = n.value) ? void 0 : t.scrollHeight)
    const a = toValue(null == e ? void 0 : e.styleTarget)
    a ? (a.style[i] = `${r.value}px`) : (o = `${r.value}px`),
      (n.value.style[i] = o)
  }
  return (
    __name(s, 'triggerResize'),
    watch([o, n], () => nextTick(s), { immediate: !0 }),
    watch(r, () => {
      var t
      return null == (t = null == e ? void 0 : e.onResize) ? void 0 : t.call(e)
    }),
    useResizeObserver(n, ([{ contentRect: e }]) => {
      a.value !== e.width && ((a.value = e.width), s())
    }),
    (null == e ? void 0 : e.watch) &&
      watch(e.watch, s, { immediate: !0, deep: !0 }),
    { textarea: n, input: o, triggerResize: s }
  )
}
function useThrottledRefHistory(e, t = {}) {
  const { throttle: n = 200, trailing: o = !0 } = t,
    i = throttleFilter(n, o)
  return { ...useRefHistory(e, { ...t, eventFilter: i }) }
}
__name(useStyleTag, 'useStyleTag'),
  __name(useSwipe, 'useSwipe'),
  __name(checkPassiveEventSupport, 'checkPassiveEventSupport'),
  __name(useTemplateRefsList, 'useTemplateRefsList'),
  __name(useTextDirection, 'useTextDirection'),
  __name(getRangesFromSelection, 'getRangesFromSelection'),
  __name(useTextSelection, 'useTextSelection'),
  __name(useTextareaAutosize, 'useTextareaAutosize'),
  __name(useThrottledRefHistory, 'useThrottledRefHistory')
const DEFAULT_UNITS = [
    { max: 6e4, value: 1e3, name: 'second' },
    { max: 276e4, value: 6e4, name: 'minute' },
    { max: 72e6, value: 36e5, name: 'hour' },
    { max: 5184e5, value: 864e5, name: 'day' },
    { max: 24192e5, value: 6048e5, name: 'week' },
    { max: 28512e6, value: 2592e6, name: 'month' },
    { max: Number.POSITIVE_INFINITY, value: 31536e6, name: 'year' }
  ],
  DEFAULT_MESSAGES = {
    justNow: 'just now',
    past: __name((e) => (e.match(/\d/) ? `${e} ago` : e), 'past'),
    future: __name((e) => (e.match(/\d/) ? `in ${e}` : e), 'future'),
    month: __name(
      (e, t) =>
        1 === e
          ? t
            ? 'last month'
            : 'next month'
          : `${e} month${e > 1 ? 's' : ''}`,
      'month'
    ),
    year: __name(
      (e, t) =>
        1 === e
          ? t
            ? 'last year'
            : 'next year'
          : `${e} year${e > 1 ? 's' : ''}`,
      'year'
    ),
    day: __name(
      (e, t) =>
        1 === e
          ? t
            ? 'yesterday'
            : 'tomorrow'
          : `${e} day${e > 1 ? 's' : ''}`,
      'day'
    ),
    week: __name(
      (e, t) =>
        1 === e
          ? t
            ? 'last week'
            : 'next week'
          : `${e} week${e > 1 ? 's' : ''}`,
      'week'
    ),
    hour: __name((e) => `${e} hour${e > 1 ? 's' : ''}`, 'hour'),
    minute: __name((e) => `${e} minute${e > 1 ? 's' : ''}`, 'minute'),
    second: __name((e) => `${e} second${e > 1 ? 's' : ''}`, 'second'),
    invalid: ''
  }
function DEFAULT_FORMATTER(e) {
  return e.toISOString().slice(0, 10)
}
function useTimeAgo(e, t = {}) {
  const { controls: n = !1, updateInterval: o = 3e4 } = t,
    { now: i, ...r } = useNow({ interval: o, controls: !0 }),
    a = computed(() => formatTimeAgo(new Date(toValue(e)), t, toValue(i)))
  return n ? { timeAgo: a, ...r } : a
}
function formatTimeAgo(e, t = {}, n = Date.now()) {
  var o
  const {
      max: i,
      messages: r = DEFAULT_MESSAGES,
      fullDateFormatter: a = DEFAULT_FORMATTER,
      units: s = DEFAULT_UNITS,
      showSecond: l = !1,
      rounding: c = 'round'
    } = t,
    d = 'number' == typeof c ? (e) => +e.toFixed(c) : Math[c],
    u = +n - +e,
    p = Math.abs(u)
  function h(e, t) {
    return d(Math.abs(e) / t.value)
  }
  function m(e, t) {
    const n = h(e, t),
      o = e > 0,
      i = f(t.name, n, o)
    return f(o ? 'past' : 'future', i, o)
  }
  function f(e, t, n) {
    const o = r[e]
    return 'function' == typeof o ? o(t, n) : o.replace('{0}', t.toString())
  }
  if (
    (__name(h, 'getValue2'),
    __name(m, 'format'),
    __name(f, 'applyFormat'),
    p < 6e4 && !l)
  )
    return r.justNow
  if ('number' == typeof i && p > i) return a(new Date(e))
  if ('string' == typeof i) {
    const t = null == (o = s.find((e) => e.name === i)) ? void 0 : o.max
    if (t && p > t) return a(new Date(e))
  }
  for (const [_, g] of s.entries()) {
    if (h(u, g) <= 0 && s[_ - 1]) return m(u, s[_ - 1])
    if (p < g.max) return m(u, g)
  }
  return r.invalid
}
function useTimeoutPoll(e, t, n) {
  const { start: o } = useTimeoutFn(r, t, { immediate: !1 }),
    i = ref(!1)
  async function r() {
    i.value && (await e(), o())
  }
  function a() {
    i.value || ((i.value = !0), r())
  }
  function s() {
    i.value = !1
  }
  return (
    __name(r, 'loop'),
    __name(a, 'resume'),
    __name(s, 'pause'),
    (null == n ? void 0 : n.immediate) && a(),
    tryOnScopeDispose(s),
    { isActive: i, pause: s, resume: a }
  )
}
function useTimestamp(e = {}) {
  const {
      controls: t = !1,
      offset: n = 0,
      immediate: o = !0,
      interval: i = 'requestAnimationFrame',
      callback: r
    } = e,
    a = ref(timestamp() + n),
    s = __name(() => (a.value = timestamp() + n), 'update'),
    l = r
      ? () => {
          s(), r(a.value)
        }
      : s,
    c =
      'requestAnimationFrame' === i
        ? useRafFn(l, { immediate: o })
        : useIntervalFn(l, i, { immediate: o })
  return t ? { timestamp: a, ...c } : a
}
function useTitle(e = null, t = {}) {
  var n, o, i
  const {
      document: r = defaultDocument,
      restoreOnUnmount: a = __name((e) => e, 'restoreOnUnmount')
    } = t,
    s = null != (n = null == r ? void 0 : r.title) ? n : '',
    l = toRef(
      null != (o = null != e ? e : null == r ? void 0 : r.title) ? o : null
    ),
    c = e && 'function' == typeof e
  function d(e) {
    if (!('titleTemplate' in t)) return e
    const n = t.titleTemplate || '%s'
    return 'function' == typeof n ? n(e) : toValue(n).replace(/%s/g, e)
  }
  return (
    __name(d, 'format'),
    watch(
      l,
      (e, t) => {
        e !== t && r && (r.title = d('string' == typeof e ? e : ''))
      },
      { immediate: !0 }
    ),
    t.observe &&
      !t.titleTemplate &&
      r &&
      !c &&
      useMutationObserver(
        null == (i = r.head) ? void 0 : i.querySelector('title'),
        () => {
          r && r.title !== l.value && (l.value = d(r.title))
        },
        { childList: !0 }
      ),
    tryOnBeforeUnmount(() => {
      if (a) {
        const e = a(s, l.value || '')
        null != e && r && (r.title = e)
      }
    }),
    l
  )
}
__name(DEFAULT_FORMATTER, 'DEFAULT_FORMATTER'),
  __name(useTimeAgo, 'useTimeAgo'),
  __name(formatTimeAgo, 'formatTimeAgo'),
  __name(useTimeoutPoll, 'useTimeoutPoll'),
  __name(useTimestamp, 'useTimestamp'),
  __name(useTitle, 'useTitle')
const _TransitionPresets = {
    easeInSine: [0.12, 0, 0.39, 0],
    easeOutSine: [0.61, 1, 0.88, 1],
    easeInOutSine: [0.37, 0, 0.63, 1],
    easeInQuad: [0.11, 0, 0.5, 0],
    easeOutQuad: [0.5, 1, 0.89, 1],
    easeInOutQuad: [0.45, 0, 0.55, 1],
    easeInCubic: [0.32, 0, 0.67, 0],
    easeOutCubic: [0.33, 1, 0.68, 1],
    easeInOutCubic: [0.65, 0, 0.35, 1],
    easeInQuart: [0.5, 0, 0.75, 0],
    easeOutQuart: [0.25, 1, 0.5, 1],
    easeInOutQuart: [0.76, 0, 0.24, 1],
    easeInQuint: [0.64, 0, 0.78, 0],
    easeOutQuint: [0.22, 1, 0.36, 1],
    easeInOutQuint: [0.83, 0, 0.17, 1],
    easeInExpo: [0.7, 0, 0.84, 0],
    easeOutExpo: [0.16, 1, 0.3, 1],
    easeInOutExpo: [0.87, 0, 0.13, 1],
    easeInCirc: [0.55, 0, 1, 0.45],
    easeOutCirc: [0, 0.55, 0.45, 1],
    easeInOutCirc: [0.85, 0, 0.15, 1],
    easeInBack: [0.36, 0, 0.66, -0.56],
    easeOutBack: [0.34, 1.56, 0.64, 1],
    easeInOutBack: [0.68, -0.6, 0.32, 1.6]
  },
  TransitionPresets = Object.assign(
    {},
    { linear: identity },
    _TransitionPresets
  )
function createEasingFunction([e, t, n, o]) {
  const i = __name((e, t) => 1 - 3 * t + 3 * e, 'a'),
    r = __name((e, t) => 3 * t - 6 * e, 'b'),
    a = __name((e) => 3 * e, 'c'),
    s = __name(
      (e, t, n) => ((i(t, n) * e + r(t, n)) * e + a(t)) * e,
      'calcBezier'
    ),
    l = __name(
      (e, t, n) => 3 * i(t, n) * e * e + 2 * r(t, n) * e + a(t),
      'getSlope'
    ),
    c = __name((t) => {
      let o = t
      for (let i = 0; i < 4; ++i) {
        const i = l(o, e, n)
        if (0 === i) return o
        o -= (s(o, e, n) - t) / i
      }
      return o
    }, 'getTforX')
  return (i) => (e === t && n === o ? i : s(c(i), t, o))
}
function lerp(e, t, n) {
  return e + n * (t - e)
}
function toVec(e) {
  return ('number' == typeof e ? [e] : e) || []
}
function executeTransition(e, t, n, o = {}) {
  var i, r
  const a = toValue(t),
    s = toValue(n),
    l = toVec(a),
    c = toVec(s),
    d = null != (i = toValue(o.duration)) ? i : 1e3,
    u = Date.now(),
    p = Date.now() + d,
    h =
      'function' == typeof o.transition
        ? o.transition
        : null != (r = toValue(o.transition))
          ? r
          : identity,
    m = 'function' == typeof h ? h : createEasingFunction(h)
  return new Promise((t) => {
    e.value = a
    const n = __name(() => {
      var i
      if (null == (i = o.abort) ? void 0 : i.call(o)) return void t()
      const r = Date.now(),
        a = m((r - u) / d),
        h = toVec(e.value).map((e, t) => lerp(l[t], c[t], a))
      Array.isArray(e.value)
        ? (e.value = h.map((e, t) => {
            var n, o
            return lerp(
              null != (n = l[t]) ? n : 0,
              null != (o = c[t]) ? o : 0,
              a
            )
          }))
        : 'number' == typeof e.value && (e.value = h[0]),
        r < p ? requestAnimationFrame(n) : ((e.value = s), t())
    }, 'tick')
    n()
  })
}
function useTransition(e, t = {}) {
  let n = 0
  const o = __name(() => {
      const t = toValue(e)
      return 'number' == typeof t ? t : t.map(toValue)
    }, 'sourceVal'),
    i = ref(o())
  return (
    watch(
      o,
      async (e) => {
        var o, r
        if (toValue(t.disabled)) return
        const a = ++n
        if ((t.delay && (await promiseTimeout(toValue(t.delay))), a !== n))
          return
        const s = Array.isArray(e) ? e.map(toValue) : toValue(e)
        null == (o = t.onStarted) || o.call(t),
          await executeTransition(i, i.value, s, {
            ...t,
            abort: __name(() => {
              var e
              return a !== n || (null == (e = t.abort) ? void 0 : e.call(t))
            }, 'abort')
          }),
          null == (r = t.onFinished) || r.call(t)
      },
      { deep: !0 }
    ),
    watch(
      () => toValue(t.disabled),
      (e) => {
        e && (n++, (i.value = o()))
      }
    ),
    tryOnScopeDispose(() => {
      n++
    }),
    computed(() => (toValue(t.disabled) ? o() : i.value))
  )
}
function useUrlSearchParams(e = 'history', t = {}) {
  const {
    initialValue: n = {},
    removeNullishValues: o = !0,
    removeFalsyValues: i = !1,
    write: r = !0,
    window: a = defaultWindow
  } = t
  if (!a) return reactive(n)
  const s = reactive({})
  function l() {
    if ('history' === e) return a.location.search || ''
    if ('hash' === e) {
      const e = a.location.hash || '',
        t = e.indexOf('?')
      return t > 0 ? e.slice(t) : ''
    }
    return (a.location.hash || '').replace(/^#/, '')
  }
  function c(t) {
    const n = t.toString()
    if ('history' === e) return `${n ? `?${n}` : ''}${a.location.hash || ''}`
    if ('hash-params' === e)
      return `${a.location.search || ''}${n ? `#${n}` : ''}`
    const o = a.location.hash || '#',
      i = o.indexOf('?')
    return i > 0
      ? `${a.location.search || ''}${o.slice(0, i)}${n ? `?${n}` : ''}`
      : `${a.location.search || ''}${o}${n ? `?${n}` : ''}`
  }
  function d() {
    return new URLSearchParams(l())
  }
  function u(e) {
    const t = new Set(Object.keys(s))
    for (const n of e.keys()) {
      const o = e.getAll(n)
      ;(s[n] = o.length > 1 ? o : e.get(n) || ''), t.delete(n)
    }
    Array.from(t).forEach((e) => delete s[e])
  }
  __name(l, 'getRawParams'),
    __name(c, 'constructQuery'),
    __name(d, 'read'),
    __name(u, 'updateState')
  const { pause: p, resume: h } = watchPausable(
    s,
    () => {
      const e = new URLSearchParams('')
      Object.keys(s).forEach((t) => {
        const n = s[t]
        Array.isArray(n)
          ? n.forEach((n) => e.append(t, n))
          : (o && null == n) || (i && !n)
            ? e.delete(t)
            : e.set(t, n)
      }),
        m(e)
    },
    { deep: !0 }
  )
  function m(e, t) {
    p(),
      t && u(e),
      a.history.replaceState(
        a.history.state,
        a.document.title,
        a.location.pathname + c(e)
      ),
      h()
  }
  function f() {
    r && m(d(), !0)
  }
  __name(m, 'write'),
    __name(f, 'onChanged'),
    useEventListener(a, 'popstate', f, !1),
    'history' !== e && useEventListener(a, 'hashchange', f, !1)
  const _ = d()
  return _.keys().next().value ? u(_) : Object.assign(s, n), s
}
function useUserMedia(e = {}) {
  var t, n
  const o = ref(null != (t = e.enabled) && t),
    i = ref(null == (n = e.autoSwitch) || n),
    r = ref(e.constraints),
    { navigator: a = defaultNavigator } = e,
    s = useSupported(() => {
      var e
      return null == (e = null == a ? void 0 : a.mediaDevices)
        ? void 0
        : e.getUserMedia
    }),
    l = shallowRef()
  function c(e) {
    switch (e) {
      case 'video':
        if (r.value) return r.value.video || !1
        break
      case 'audio':
        if (r.value) return r.value.audio || !1
    }
  }
  async function d() {
    if (s.value && !l.value)
      return (
        (l.value = await a.mediaDevices.getUserMedia({
          video: c('video'),
          audio: c('audio')
        })),
        l.value
      )
  }
  function u() {
    var e
    null == (e = l.value) || e.getTracks().forEach((e) => e.stop()),
      (l.value = void 0)
  }
  function p() {
    u(), (o.value = !1)
  }
  async function h() {
    return await d(), l.value && (o.value = !0), l.value
  }
  async function m() {
    return u(), await h()
  }
  return (
    __name(c, 'getDeviceOptions'),
    __name(d, '_start'),
    __name(u, '_stop'),
    __name(p, 'stop'),
    __name(h, 'start'),
    __name(m, 'restart'),
    watch(
      o,
      (e) => {
        e ? d() : u()
      },
      { immediate: !0 }
    ),
    watch(
      r,
      () => {
        i.value && l.value && m()
      },
      { immediate: !0 }
    ),
    tryOnScopeDispose(() => {
      p()
    }),
    {
      isSupported: s,
      stream: l,
      start: h,
      stop: p,
      restart: m,
      constraints: r,
      enabled: o,
      autoSwitch: i
    }
  )
}
function useVModel(e, t, n, o = {}) {
  var i, r, a, s, l
  const {
      clone: c = !1,
      passive: d = !1,
      eventName: u,
      deep: p = !1,
      defaultValue: h,
      shouldEmit: m
    } = o,
    f = getCurrentInstance(),
    _ =
      n ||
      (null == f ? void 0 : f.emit) ||
      (null == (i = null == f ? void 0 : f.$emit) ? void 0 : i.bind(f)) ||
      (null ==
      (a = null == (r = null == f ? void 0 : f.proxy) ? void 0 : r.$emit)
        ? void 0
        : a.bind(null == f ? void 0 : f.proxy))
  let g = u
  if (!t)
    if (isVue2) {
      const e =
        null ==
        (l = null == (s = null == f ? void 0 : f.proxy) ? void 0 : s.$options)
          ? void 0
          : l.model
      ;(t = (null == e ? void 0 : e.value) || 'value'),
        u || (g = (null == e ? void 0 : e.event) || 'input')
    } else t = 'modelValue'
  g = g || `update:${t.toString()}`
  const v = __name(
      (e) => (c ? ('function' == typeof c ? c(e) : cloneFnJSON(e)) : e),
      'cloneFn'
    ),
    y = __name(() => (isDef(e[t]) ? v(e[t]) : h), 'getValue2'),
    b = __name((e) => {
      m ? m(e) && _(g, e) : _(g, e)
    }, 'triggerEmit')
  if (d) {
    const n = ref(y())
    let o = !1
    return (
      watch(
        () => e[t],
        (e) => {
          o || ((o = !0), (n.value = v(e)), nextTick(() => (o = !1)))
        }
      ),
      watch(
        n,
        (n) => {
          o || (n === e[t] && !p) || b(n)
        },
        { deep: p }
      ),
      n
    )
  }
  return computed({
    get: () => y(),
    set(e) {
      b(e)
    }
  })
}
function useVModels(e, t, n = {}) {
  const o = {}
  for (const i in e) o[i] = useVModel(e, i, t, n)
  return o
}
function useVibrate(e) {
  const {
      pattern: t = [],
      interval: n = 0,
      navigator: o = defaultNavigator
    } = e || {},
    i = useSupported(() => void 0 !== o && 'vibrate' in o),
    r = toRef(t)
  let a
  const s = __name((e = r.value) => {
      i.value && o.vibrate(e)
    }, 'vibrate'),
    l = __name(() => {
      i.value && o.vibrate(0), null == a || a.pause()
    }, 'stop')
  return (
    n > 0 &&
      (a = useIntervalFn(s, n, { immediate: !1, immediateCallback: !1 })),
    { isSupported: i, pattern: t, intervalControls: a, vibrate: s, stop: l }
  )
}
function useVirtualList(e, t) {
  const {
    containerStyle: n,
    wrapperProps: o,
    scrollTo: i,
    calculateRange: r,
    currentList: a,
    containerRef: s
  } = 'itemHeight' in t
    ? useVerticalVirtualList(t, e)
    : useHorizontalVirtualList(t, e)
  return {
    list: a,
    scrollTo: i,
    containerProps: {
      ref: s,
      onScroll: __name(() => {
        r()
      }, 'onScroll'),
      style: n
    },
    wrapperProps: o
  }
}
function useVirtualListResources(e) {
  const t = ref(null),
    n = useElementSize(t),
    o = ref([]),
    i = shallowRef(e)
  return {
    state: ref({ start: 0, end: 10 }),
    source: i,
    currentList: o,
    size: n,
    containerRef: t
  }
}
function createGetViewCapacity(e, t, n) {
  return (o) => {
    if ('number' == typeof n) return Math.ceil(o / n)
    const { start: i = 0 } = e.value
    let r = 0,
      a = 0
    for (let e = i; e < t.value.length; e++) {
      if (((r += n(e)), (a = e), r > o)) break
    }
    return a - i
  }
}
function createGetOffset(e, t) {
  return (n) => {
    if ('number' == typeof t) return Math.floor(n / t) + 1
    let o = 0,
      i = 0
    for (let r = 0; r < e.value.length; r++) {
      if (((o += t(r)), o >= n)) {
        i = r
        break
      }
    }
    return i + 1
  }
}
function createCalculateRange(
  e,
  t,
  n,
  o,
  { containerRef: i, state: r, currentList: a, source: s }
) {
  return () => {
    const l = i.value
    if (l) {
      const i = n('vertical' === e ? l.scrollTop : l.scrollLeft),
        c = o('vertical' === e ? l.clientHeight : l.clientWidth),
        d = i - t,
        u = i + c + t
      ;(r.value = {
        start: d < 0 ? 0 : d,
        end: u > s.value.length ? s.value.length : u
      }),
        (a.value = s.value
          .slice(r.value.start, r.value.end)
          .map((e, t) => ({ data: e, index: t + r.value.start })))
    }
  }
}
function createGetDistance(e, t) {
  return (n) => {
    if ('number' == typeof e) {
      return n * e
    }
    return t.value.slice(0, n).reduce((t, n, o) => t + e(o), 0)
  }
}
function useWatchForSizes(e, t, n, o) {
  watch([e.width, e.height, t, n], () => {
    o()
  })
}
function createComputedTotalSize(e, t) {
  return computed(() =>
    'number' == typeof e
      ? t.value.length * e
      : t.value.reduce((t, n, o) => t + e(o), 0)
  )
}
__name(createEasingFunction, 'createEasingFunction'),
  __name(lerp, 'lerp'),
  __name(toVec, 'toVec'),
  __name(executeTransition, 'executeTransition'),
  __name(useTransition, 'useTransition'),
  __name(useUrlSearchParams, 'useUrlSearchParams'),
  __name(useUserMedia, 'useUserMedia'),
  __name(useVModel, 'useVModel'),
  __name(useVModels, 'useVModels'),
  __name(useVibrate, 'useVibrate'),
  __name(useVirtualList, 'useVirtualList'),
  __name(useVirtualListResources, 'useVirtualListResources'),
  __name(createGetViewCapacity, 'createGetViewCapacity'),
  __name(createGetOffset, 'createGetOffset'),
  __name(createCalculateRange, 'createCalculateRange'),
  __name(createGetDistance, 'createGetDistance'),
  __name(useWatchForSizes, 'useWatchForSizes'),
  __name(createComputedTotalSize, 'createComputedTotalSize')
const scrollToDictionaryForElementScrollKey = {
  horizontal: 'scrollLeft',
  vertical: 'scrollTop'
}
function createScrollTo(e, t, n, o) {
  return (i) => {
    o.value && ((o.value[scrollToDictionaryForElementScrollKey[e]] = n(i)), t())
  }
}
function useHorizontalVirtualList(e, t) {
  const n = useVirtualListResources(t),
    { state: o, source: i, currentList: r, size: a, containerRef: s } = n,
    { itemWidth: l, overscan: c = 5 } = e,
    d = createGetViewCapacity(o, i, l),
    u = createCalculateRange('horizontal', c, createGetOffset(i, l), d, n),
    p = createGetDistance(l, i),
    h = computed(() => p(o.value.start)),
    m = createComputedTotalSize(l, i)
  useWatchForSizes(a, t, s, u)
  return {
    scrollTo: createScrollTo('horizontal', u, p, s),
    calculateRange: u,
    wrapperProps: computed(() => ({
      style: {
        height: '100%',
        width: m.value - h.value + 'px',
        marginLeft: `${h.value}px`,
        display: 'flex'
      }
    })),
    containerStyle: { overflowX: 'auto' },
    currentList: r,
    containerRef: s
  }
}
function useVerticalVirtualList(e, t) {
  const n = useVirtualListResources(t),
    { state: o, source: i, currentList: r, size: a, containerRef: s } = n,
    { itemHeight: l, overscan: c = 5 } = e,
    d = createGetViewCapacity(o, i, l),
    u = createCalculateRange('vertical', c, createGetOffset(i, l), d, n),
    p = createGetDistance(l, i),
    h = computed(() => p(o.value.start)),
    m = createComputedTotalSize(l, i)
  useWatchForSizes(a, t, s, u)
  return {
    calculateRange: u,
    scrollTo: createScrollTo('vertical', u, p, s),
    containerStyle: { overflowY: 'auto' },
    wrapperProps: computed(() => ({
      style: {
        width: '100%',
        height: m.value - h.value + 'px',
        marginTop: `${h.value}px`
      }
    })),
    currentList: r,
    containerRef: s
  }
}
function useWakeLock(e = {}) {
  const { navigator: t = defaultNavigator, document: n = defaultDocument } = e,
    o = ref(!1),
    i = shallowRef(null),
    r = useDocumentVisibility({ document: n }),
    a = useSupported(() => t && 'wakeLock' in t),
    s = computed(() => !!i.value && 'visible' === r.value)
  async function l(e) {
    var n
    await (null == (n = i.value) ? void 0 : n.release()),
      (i.value = a.value ? await t.wakeLock.request(e) : null)
  }
  async function c(e) {
    'visible' === r.value ? await l(e) : (o.value = e)
  }
  async function d() {
    o.value = !1
    const e = i.value
    ;(i.value = null), await (null == e ? void 0 : e.release())
  }
  return (
    a.value &&
      (useEventListener(i, 'release', () => {
        var e, t
        o.value = null != (t = null == (e = i.value) ? void 0 : e.type) && t
      }),
      whenever(
        () =>
          'visible' === r.value &&
          'visible' === (null == n ? void 0 : n.visibilityState) &&
          o.value,
        (e) => {
          ;(o.value = !1), l(e)
        }
      )),
    __name(l, 'forceRequest'),
    __name(c, 'request'),
    __name(d, 'release'),
    {
      sentinel: i,
      isSupported: a,
      isActive: s,
      request: c,
      forceRequest: l,
      release: d
    }
  )
}
function useWebNotification(e = {}) {
  const { window: t = defaultWindow, requestPermissions: n = !0 } = e,
    o = e,
    i = useSupported(() => {
      if (!t || !('Notification' in t)) return !1
      try {
        new Notification('')
      } catch (e2) {
        return !1
      }
      return !0
    }),
    r = ref(
      i.value &&
        'permission' in Notification &&
        'granted' === Notification.permission
    ),
    a = ref(null),
    s = __name(async () => {
      if (i.value) {
        if (!r.value && 'denied' !== Notification.permission) {
          'granted' === (await Notification.requestPermission()) &&
            (r.value = !0)
        }
        return r.value
      }
    }, 'ensurePermissions'),
    { on: l, trigger: c } = createEventHook(),
    { on: d, trigger: u } = createEventHook(),
    { on: p, trigger: h } = createEventHook(),
    { on: m, trigger: f } = createEventHook(),
    _ = __name(async (e) => {
      if (!i.value || !r.value) return
      const t = Object.assign({}, o, e)
      return (
        (a.value = new Notification(t.title || '', t)),
        (a.value.onclick = c),
        (a.value.onshow = u),
        (a.value.onerror = h),
        (a.value.onclose = f),
        a.value
      )
    }, 'show'),
    g = __name(() => {
      a.value && a.value.close(), (a.value = null)
    }, 'close')
  if ((n && tryOnMounted(s), tryOnScopeDispose(g), i.value && t)) {
    const e = t.document
    useEventListener(e, 'visibilitychange', (t) => {
      t.preventDefault(), 'visible' === e.visibilityState && g()
    })
  }
  return {
    isSupported: i,
    notification: a,
    ensurePermissions: s,
    permissionGranted: r,
    show: _,
    close: g,
    onClick: l,
    onShow: d,
    onError: p,
    onClose: m
  }
}
__name(createScrollTo, 'createScrollTo'),
  __name(useHorizontalVirtualList, 'useHorizontalVirtualList'),
  __name(useVerticalVirtualList, 'useVerticalVirtualList'),
  __name(useWakeLock, 'useWakeLock'),
  __name(useWebNotification, 'useWebNotification')
const DEFAULT_PING_MESSAGE = 'ping'
function resolveNestedOptions(e) {
  return !0 === e ? {} : e
}
function useWebSocket(e, t = {}) {
  const {
      onConnected: n,
      onDisconnected: o,
      onError: i,
      onMessage: r,
      immediate: a = !0,
      autoClose: s = !0,
      protocols: l = []
    } = t,
    c = ref(null),
    d = ref('CLOSED'),
    u = ref(),
    p = toRef(e)
  let h,
    m,
    f,
    _ = !1,
    g = 0,
    v = []
  const y = __name(() => {
      if (v.length && u.value && 'OPEN' === d.value) {
        for (const e of v) u.value.send(e)
        v = []
      }
    }, '_sendBuffer'),
    b = __name(() => {
      clearTimeout(f), (f = void 0)
    }, 'resetHeartbeat'),
    S = __name((e = 1e3, t) => {
      isClient &&
        u.value &&
        ((_ = !0),
        b(),
        null == h || h(),
        u.value.close(e, t),
        (u.value = void 0))
    }, 'close'),
    C = __name(
      (e, t = !0) =>
        u.value && 'OPEN' === d.value
          ? (y(), u.value.send(e), !0)
          : (t && v.push(e), !1),
      'send'
    ),
    w = __name(() => {
      if (_ || void 0 === p.value) return
      const e = new WebSocket(p.value, l)
      ;(u.value = e),
        (d.value = 'CONNECTING'),
        (e.onopen = () => {
          ;(d.value = 'OPEN'), (g = 0), null == n || n(e), null == m || m(), y()
        }),
        (e.onclose = (n) => {
          if (
            ((d.value = 'CLOSED'),
            null == o || o(e, n),
            !_ && t.autoReconnect && (null == u.value || e === u.value))
          ) {
            const {
              retries: e = -1,
              delay: n = 1e3,
              onFailed: o
            } = resolveNestedOptions(t.autoReconnect)
            'number' == typeof e && (e < 0 || g < e)
              ? ((g += 1), setTimeout(w, n))
              : 'function' == typeof e && e()
                ? setTimeout(w, n)
                : null == o || o()
          }
        }),
        (e.onerror = (t) => {
          null == i || i(e, t)
        }),
        (e.onmessage = (n) => {
          if (t.heartbeat) {
            b()
            const {
              message: e = DEFAULT_PING_MESSAGE,
              responseMessage: o = e
            } = resolveNestedOptions(t.heartbeat)
            if (n.data === o) return
          }
          ;(c.value = n.data), null == r || r(e, n)
        })
    }, '_init')
  if (t.heartbeat) {
    const {
        message: e = DEFAULT_PING_MESSAGE,
        interval: n = 1e3,
        pongTimeout: o = 1e3
      } = resolveNestedOptions(t.heartbeat),
      { pause: i, resume: r } = useIntervalFn(
        () => {
          C(e, !1),
            null == f &&
              (f = setTimeout(() => {
                S(), (_ = !1)
              }, o))
        },
        n,
        { immediate: !1 }
      )
    ;(h = i), (m = r)
  }
  s &&
    (isClient && useEventListener('beforeunload', () => S()),
    tryOnScopeDispose(S))
  const k = __name(() => {
    ;(isClient || isWorker) && (S(), (_ = !1), (g = 0), w())
  }, 'open')
  return (
    a && k(),
    watch(p, k),
    { data: c, status: d, close: S, send: C, open: k, ws: u }
  )
}
function useWebWorker(e, t, n) {
  const { window: o = defaultWindow } = null != n ? n : {},
    i = ref(null),
    r = shallowRef(),
    a = __name((...e) => {
      r.value && r.value.postMessage(...e)
    }, 'post'),
    s = __name(function () {
      r.value && r.value.terminate()
    }, 'terminate2')
  return (
    o &&
      ((r.value =
        'string' == typeof e
          ? new Worker(e, t)
          : 'function' == typeof e
            ? e()
            : e),
      (r.value.onmessage = (e) => {
        i.value = e.data
      }),
      tryOnScopeDispose(() => {
        r.value && r.value.terminate()
      })),
    { data: i, post: a, terminate: s, worker: r }
  )
}
function depsParser(e, t) {
  if (0 === e.length && 0 === t.length) return ''
  const n = e.map((e) => `'${e}'`).toString(),
    o = t
      .filter((e) => 'function' == typeof e)
      .map((e) => {
        const t = e.toString()
        if (t.trim().startsWith('function')) return t
        return `const ${e.name} = ${t}`
      })
      .join(';'),
    i = `importScripts(${n});`
  return `${'' === n.trim() ? '' : i} ${o}`
}
function jobRunner(e) {
  return (t) => {
    const n = t.data[0]
    return Promise.resolve(e.apply(void 0, n))
      .then((e) => {
        postMessage(['SUCCESS', e])
      })
      .catch((e) => {
        postMessage(['ERROR', e])
      })
  }
}
function createWorkerBlobUrl(e, t, n) {
  const o = `${depsParser(t, n)}; onmessage=(${jobRunner})(${e})`,
    i = new Blob([o], { type: 'text/javascript' })
  return URL.createObjectURL(i)
}
function useWebWorkerFn(e, t = {}) {
  const {
      dependencies: n = [],
      localDependencies: o = [],
      timeout: i,
      window: r = defaultWindow
    } = t,
    a = ref(),
    s = ref('PENDING'),
    l = ref({}),
    c = ref(),
    d = __name((e = 'PENDING') => {
      a.value &&
        a.value._url &&
        r &&
        (a.value.terminate(),
        URL.revokeObjectURL(a.value._url),
        (l.value = {}),
        (a.value = void 0),
        r.clearTimeout(c.value),
        (s.value = e))
    }, 'workerTerminate')
  d(), tryOnScopeDispose(d)
  const u = __name(() => {
      const t = createWorkerBlobUrl(e, n, o),
        r = new Worker(t)
      return (
        (r._url = t),
        (r.onmessage = (e) => {
          const {
              resolve: t = __name(() => {}, 'resolve'),
              reject: n = __name(() => {}, 'reject')
            } = l.value,
            [o, i] = e.data
          if ('SUCCESS' === o) t(i), d(o)
          else n(i), d('ERROR')
        }),
        (r.onerror = (e) => {
          const { reject: t = __name(() => {}, 'reject') } = l.value
          e.preventDefault(), t(e), d('ERROR')
        }),
        i && (c.value = setTimeout(() => d('TIMEOUT_EXPIRED'), i)),
        r
      )
    }, 'generateWorker'),
    p = __name(
      (...e) =>
        new Promise((t, n) => {
          var o
          ;(l.value = { resolve: t, reject: n }),
            null == (o = a.value) || o.postMessage([[...e]]),
            (s.value = 'RUNNING')
        }),
      'callWorker'
    )
  return {
    workerFn: __name(
      (...e) =>
        'RUNNING' === s.value
          ? (console.error(
              '[useWebWorkerFn] You can only run one instance of the worker at a time.'
            ),
            Promise.reject())
          : ((a.value = u()), p(...e)),
      'workerFn'
    ),
    workerStatus: s,
    workerTerminate: d
  }
}
function useWindowFocus(e = {}) {
  const { window: t = defaultWindow } = e
  if (!t) return ref(!1)
  const n = ref(t.document.hasFocus())
  return (
    useEventListener(t, 'blur', () => {
      n.value = !1
    }),
    useEventListener(t, 'focus', () => {
      n.value = !0
    }),
    n
  )
}
function useWindowScroll(e = {}) {
  const { window: t = defaultWindow, behavior: n = 'auto' } = e
  if (!t) return { x: ref(0), y: ref(0) }
  const o = ref(t.scrollX),
    i = ref(t.scrollY),
    r = computed({
      get: () => o.value,
      set(e) {
        scrollTo({ left: e, behavior: n })
      }
    }),
    a = computed({
      get: () => i.value,
      set(e) {
        scrollTo({ top: e, behavior: n })
      }
    })
  return (
    useEventListener(
      t,
      'scroll',
      () => {
        ;(o.value = t.scrollX), (i.value = t.scrollY)
      },
      { capture: !1, passive: !0 }
    ),
    { x: r, y: a }
  )
}
function useWindowSize(e = {}) {
  const {
      window: t = defaultWindow,
      initialWidth: n = Number.POSITIVE_INFINITY,
      initialHeight: o = Number.POSITIVE_INFINITY,
      listenOrientation: i = !0,
      includeScrollbar: r = !0,
      type: a = 'inner'
    } = e,
    s = ref(n),
    l = ref(o),
    c = __name(() => {
      t &&
        ('outer' === a
          ? ((s.value = t.outerWidth), (l.value = t.outerHeight))
          : r
            ? ((s.value = t.innerWidth), (l.value = t.innerHeight))
            : ((s.value = t.document.documentElement.clientWidth),
              (l.value = t.document.documentElement.clientHeight)))
    }, 'update')
  if (
    (c(), tryOnMounted(c), useEventListener('resize', c, { passive: !0 }), i)
  ) {
    watch(useMediaQuery('(orientation: portrait)'), () => c())
  }
  return { width: s, height: l }
}
__name(resolveNestedOptions, 'resolveNestedOptions'),
  __name(useWebSocket, 'useWebSocket'),
  __name(useWebWorker, 'useWebWorker'),
  __name(depsParser, 'depsParser'),
  __name(jobRunner, 'jobRunner'),
  __name(createWorkerBlobUrl, 'createWorkerBlobUrl'),
  __name(useWebWorkerFn, 'useWebWorkerFn'),
  __name(useWindowFocus, 'useWindowFocus'),
  __name(useWindowScroll, 'useWindowScroll'),
  __name(useWindowSize, 'useWindowSize')
var commonjsGlobal =
  'undefined' != typeof globalThis
    ? globalThis
    : 'undefined' != typeof window
      ? window
      : 'undefined' != typeof global
        ? global
        : 'undefined' != typeof self
          ? self
          : {}
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default')
    ? e.default
    : e
}
function getDefaultExportFromNamespaceIfPresent(e) {
  return e && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e
}
function getDefaultExportFromNamespaceIfNotNamed(e) {
  return e &&
    Object.prototype.hasOwnProperty.call(e, 'default') &&
    1 === Object.keys(e).length
    ? e.default
    : e
}
function getAugmentedNamespace(e) {
  if (e.__esModule) return e
  var t = e.default
  if ('function' == typeof t) {
    var n = __name(function e() {
      return this instanceof e
        ? Reflect.construct(t, arguments, this.constructor)
        : t.apply(this, arguments)
    }, 'a')
    n.prototype = t.prototype
  } else n = {}
  return (
    Object.defineProperty(n, '__esModule', { value: !0 }),
    Object.keys(e).forEach(function (t) {
      var o = Object.getOwnPropertyDescriptor(e, t)
      Object.defineProperty(
        n,
        t,
        o.get
          ? o
          : {
              enumerable: !0,
              get: __name(function () {
                return e[t]
              }, 'get')
            }
      )
    }),
    n
  )
}
__name(getDefaultExportFromCjs, 'getDefaultExportFromCjs'),
  __name(
    getDefaultExportFromNamespaceIfPresent,
    'getDefaultExportFromNamespaceIfPresent'
  ),
  __name(
    getDefaultExportFromNamespaceIfNotNamed,
    'getDefaultExportFromNamespaceIfNotNamed'
  ),
  __name(getAugmentedNamespace, 'getAugmentedNamespace')
var addonFit$2 = { exports: {} },
  addonFit = addonFit$2.exports,
  module,
  t2
;(module = addonFit$2),
  addonFit$2.exports,
  self,
  (t2 = () => {
    return (
      (e = t = {}),
      Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.FitAddon = void 0),
      (e.FitAddon = class {
        activate(e) {
          this._terminal = e
        }
        dispose() {}
        fit() {
          const e = this.proposeDimensions()
          if (!e || !this._terminal || isNaN(e.cols) || isNaN(e.rows)) return
          const t = this._terminal._core
          ;(this._terminal.rows === e.rows && this._terminal.cols === e.cols) ||
            (t._renderService.clear(), this._terminal.resize(e.cols, e.rows))
        }
        proposeDimensions() {
          if (!this._terminal) return
          if (!this._terminal.element || !this._terminal.element.parentElement)
            return
          const e = this._terminal._core,
            t = e._renderService.dimensions
          if (0 === t.css.cell.width || 0 === t.css.cell.height) return
          const n =
              0 === this._terminal.options.scrollback
                ? 0
                : e.viewport.scrollBarWidth,
            o = window.getComputedStyle(this._terminal.element.parentElement),
            i = parseInt(o.getPropertyValue('height')),
            r = Math.max(0, parseInt(o.getPropertyValue('width'))),
            a = window.getComputedStyle(this._terminal.element),
            s =
              i -
              (parseInt(a.getPropertyValue('padding-top')) +
                parseInt(a.getPropertyValue('padding-bottom'))),
            l =
              r -
              (parseInt(a.getPropertyValue('padding-right')) +
                parseInt(a.getPropertyValue('padding-left'))) -
              n
          return {
            cols: Math.max(2, Math.floor(l / t.css.cell.width)),
            rows: Math.max(1, Math.floor(s / t.css.cell.height))
          }
        }
      }),
      t
    )
    var e, t
  }),
  (module.exports = t2())
var addonFitExports = addonFit$2.exports
const addonFit$1 = getDefaultExportFromCjs(addonFitExports)
var xterm$2 = { exports: {} },
  xterm = xterm$2.exports
!(function (e, t) {
  !(function (t, n) {
    e.exports = n()
  })(globalThis, () =>
    (() => {
      var e = {
          4567: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.AccessibilityManager = void 0)
            const r = n(9042),
              a = n(9924),
              s = n(844),
              l = n(4725),
              c = n(2585),
              d = n(3656)
            let u = (t.AccessibilityManager = class extends s.Disposable {
              constructor(e, t, n, o) {
                super(),
                  (this._terminal = e),
                  (this._coreBrowserService = n),
                  (this._renderService = o),
                  (this._rowColumns = new WeakMap()),
                  (this._liveRegionLineCount = 0),
                  (this._charsToConsume = []),
                  (this._charsToAnnounce = ''),
                  (this._accessibilityContainer =
                    this._coreBrowserService.mainDocument.createElement('div')),
                  this._accessibilityContainer.classList.add(
                    'xterm-accessibility'
                  ),
                  (this._rowContainer =
                    this._coreBrowserService.mainDocument.createElement('div')),
                  this._rowContainer.setAttribute('role', 'list'),
                  this._rowContainer.classList.add('xterm-accessibility-tree'),
                  (this._rowElements = [])
                for (let i = 0; i < this._terminal.rows; i++)
                  (this._rowElements[i] = this._createAccessibilityTreeNode()),
                    this._rowContainer.appendChild(this._rowElements[i])
                if (
                  ((this._topBoundaryFocusListener = (e) =>
                    this._handleBoundaryFocus(e, 0)),
                  (this._bottomBoundaryFocusListener = (e) =>
                    this._handleBoundaryFocus(e, 1)),
                  this._rowElements[0].addEventListener(
                    'focus',
                    this._topBoundaryFocusListener
                  ),
                  this._rowElements[
                    this._rowElements.length - 1
                  ].addEventListener(
                    'focus',
                    this._bottomBoundaryFocusListener
                  ),
                  this._refreshRowsDimensions(),
                  this._accessibilityContainer.appendChild(this._rowContainer),
                  (this._liveRegion =
                    this._coreBrowserService.mainDocument.createElement('div')),
                  this._liveRegion.classList.add('live-region'),
                  this._liveRegion.setAttribute('aria-live', 'assertive'),
                  this._accessibilityContainer.appendChild(this._liveRegion),
                  (this._liveRegionDebouncer = this.register(
                    new a.TimeBasedDebouncer(this._renderRows.bind(this))
                  )),
                  !this._terminal.element)
                )
                  throw new Error(
                    'Cannot enable accessibility before Terminal.open'
                  )
                this._terminal.element.insertAdjacentElement(
                  'afterbegin',
                  this._accessibilityContainer
                ),
                  this.register(
                    this._terminal.onResize((e) => this._handleResize(e.rows))
                  ),
                  this.register(
                    this._terminal.onRender((e) =>
                      this._refreshRows(e.start, e.end)
                    )
                  ),
                  this.register(
                    this._terminal.onScroll(() => this._refreshRows())
                  ),
                  this.register(
                    this._terminal.onA11yChar((e) => this._handleChar(e))
                  ),
                  this.register(
                    this._terminal.onLineFeed(() => this._handleChar('\n'))
                  ),
                  this.register(
                    this._terminal.onA11yTab((e) => this._handleTab(e))
                  ),
                  this.register(
                    this._terminal.onKey((e) => this._handleKey(e.key))
                  ),
                  this.register(
                    this._terminal.onBlur(() => this._clearLiveRegion())
                  ),
                  this.register(
                    this._renderService.onDimensionsChange(() =>
                      this._refreshRowsDimensions()
                    )
                  ),
                  this.register(
                    (0, d.addDisposableDomListener)(
                      document,
                      'selectionchange',
                      () => this._handleSelectionChange()
                    )
                  ),
                  this.register(
                    this._coreBrowserService.onDprChange(() =>
                      this._refreshRowsDimensions()
                    )
                  ),
                  this._refreshRows(),
                  this.register(
                    (0, s.toDisposable)(() => {
                      this._accessibilityContainer.remove(),
                        (this._rowElements.length = 0)
                    })
                  )
              }
              _handleTab(e) {
                for (let t = 0; t < e; t++) this._handleChar(' ')
              }
              _handleChar(e) {
                this._liveRegionLineCount < 21 &&
                  (this._charsToConsume.length > 0
                    ? this._charsToConsume.shift() !== e &&
                      (this._charsToAnnounce += e)
                    : (this._charsToAnnounce += e),
                  '\n' === e &&
                    (this._liveRegionLineCount++,
                    21 === this._liveRegionLineCount &&
                      (this._liveRegion.textContent += r.tooMuchOutput)))
              }
              _clearLiveRegion() {
                ;(this._liveRegion.textContent = ''),
                  (this._liveRegionLineCount = 0)
              }
              _handleKey(e) {
                this._clearLiveRegion(),
                  /\p{Control}/u.test(e) || this._charsToConsume.push(e)
              }
              _refreshRows(e, t) {
                this._liveRegionDebouncer.refresh(e, t, this._terminal.rows)
              }
              _renderRows(e, t) {
                const n = this._terminal.buffer,
                  o = n.lines.length.toString()
                for (let i = e; i <= t; i++) {
                  const e = n.lines.get(n.ydisp + i),
                    t = [],
                    r = e?.translateToString(!0, void 0, void 0, t) || '',
                    a = (n.ydisp + i + 1).toString(),
                    s = this._rowElements[i]
                  s &&
                    (0 === r.length
                      ? ((s.innerText = ' '), this._rowColumns.set(s, [0, 1]))
                      : ((s.textContent = r), this._rowColumns.set(s, t)),
                    s.setAttribute('aria-posinset', a),
                    s.setAttribute('aria-setsize', o))
                }
                this._announceCharacters()
              }
              _announceCharacters() {
                0 !== this._charsToAnnounce.length &&
                  ((this._liveRegion.textContent += this._charsToAnnounce),
                  (this._charsToAnnounce = ''))
              }
              _handleBoundaryFocus(e, t) {
                const n = e.target,
                  o =
                    this._rowElements[
                      0 === t ? 1 : this._rowElements.length - 2
                    ]
                if (
                  n.getAttribute('aria-posinset') ===
                  (0 === t ? '1' : `${this._terminal.buffer.lines.length}`)
                )
                  return
                if (e.relatedTarget !== o) return
                let i, r
                if (
                  (0 === t
                    ? ((i = n),
                      (r = this._rowElements.pop()),
                      this._rowContainer.removeChild(r))
                    : ((i = this._rowElements.shift()),
                      (r = n),
                      this._rowContainer.removeChild(i)),
                  i.removeEventListener(
                    'focus',
                    this._topBoundaryFocusListener
                  ),
                  r.removeEventListener(
                    'focus',
                    this._bottomBoundaryFocusListener
                  ),
                  0 === t)
                ) {
                  const e = this._createAccessibilityTreeNode()
                  this._rowElements.unshift(e),
                    this._rowContainer.insertAdjacentElement('afterbegin', e)
                } else {
                  const e = this._createAccessibilityTreeNode()
                  this._rowElements.push(e), this._rowContainer.appendChild(e)
                }
                this._rowElements[0].addEventListener(
                  'focus',
                  this._topBoundaryFocusListener
                ),
                  this._rowElements[
                    this._rowElements.length - 1
                  ].addEventListener(
                    'focus',
                    this._bottomBoundaryFocusListener
                  ),
                  this._terminal.scrollLines(0 === t ? -1 : 1),
                  this._rowElements[
                    0 === t ? 1 : this._rowElements.length - 2
                  ].focus(),
                  e.preventDefault(),
                  e.stopImmediatePropagation()
              }
              _handleSelectionChange() {
                if (0 === this._rowElements.length) return
                const e = document.getSelection()
                if (!e) return
                if (e.isCollapsed)
                  return void (
                    this._rowContainer.contains(e.anchorNode) &&
                    this._terminal.clearSelection()
                  )
                if (!e.anchorNode || !e.focusNode)
                  return void console.error(
                    'anchorNode and/or focusNode are null'
                  )
                let t = { node: e.anchorNode, offset: e.anchorOffset },
                  n = { node: e.focusNode, offset: e.focusOffset }
                if (
                  ((t.node.compareDocumentPosition(n.node) &
                    Node.DOCUMENT_POSITION_PRECEDING ||
                    (t.node === n.node && t.offset > n.offset)) &&
                    ([t, n] = [n, t]),
                  t.node.compareDocumentPosition(this._rowElements[0]) &
                    (Node.DOCUMENT_POSITION_CONTAINED_BY |
                      Node.DOCUMENT_POSITION_FOLLOWING) &&
                    (t = {
                      node: this._rowElements[0].childNodes[0],
                      offset: 0
                    }),
                  !this._rowContainer.contains(t.node))
                )
                  return
                const o = this._rowElements.slice(-1)[0]
                if (
                  (n.node.compareDocumentPosition(o) &
                    (Node.DOCUMENT_POSITION_CONTAINED_BY |
                      Node.DOCUMENT_POSITION_PRECEDING) &&
                    (n = { node: o, offset: o.textContent?.length ?? 0 }),
                  !this._rowContainer.contains(n.node))
                )
                  return
                const i = __name(({ node: e, offset: t }) => {
                    const n = e instanceof Text ? e.parentNode : e
                    let o = parseInt(n?.getAttribute('aria-posinset'), 10) - 1
                    if (isNaN(o))
                      return (
                        console.warn('row is invalid. Race condition?'), null
                      )
                    const i = this._rowColumns.get(n)
                    if (!i)
                      return (
                        console.warn('columns is null. Race condition?'), null
                      )
                    let r = t < i.length ? i[t] : i.slice(-1)[0] + 1
                    return (
                      r >= this._terminal.cols && (++o, (r = 0)),
                      { row: o, column: r }
                    )
                  }, 'r'),
                  r = i(t),
                  a = i(n)
                if (r && a) {
                  if (
                    r.row > a.row ||
                    (r.row === a.row && r.column >= a.column)
                  )
                    throw new Error('invalid range')
                  this._terminal.select(
                    r.column,
                    r.row,
                    (a.row - r.row) * this._terminal.cols - r.column + a.column
                  )
                }
              }
              _handleResize(e) {
                this._rowElements[
                  this._rowElements.length - 1
                ].removeEventListener(
                  'focus',
                  this._bottomBoundaryFocusListener
                )
                for (
                  let t = this._rowContainer.children.length;
                  t < this._terminal.rows;
                  t++
                )
                  (this._rowElements[t] = this._createAccessibilityTreeNode()),
                    this._rowContainer.appendChild(this._rowElements[t])
                for (; this._rowElements.length > e; )
                  this._rowContainer.removeChild(this._rowElements.pop())
                this._rowElements[
                  this._rowElements.length - 1
                ].addEventListener('focus', this._bottomBoundaryFocusListener),
                  this._refreshRowsDimensions()
              }
              _createAccessibilityTreeNode() {
                const e =
                  this._coreBrowserService.mainDocument.createElement('div')
                return (
                  e.setAttribute('role', 'listitem'),
                  (e.tabIndex = -1),
                  this._refreshRowDimensions(e),
                  e
                )
              }
              _refreshRowsDimensions() {
                if (this._renderService.dimensions.css.cell.height) {
                  ;(this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`),
                    this._rowElements.length !== this._terminal.rows &&
                      this._handleResize(this._terminal.rows)
                  for (let e = 0; e < this._terminal.rows; e++)
                    this._refreshRowDimensions(this._rowElements[e])
                }
              }
              _refreshRowDimensions(e) {
                e.style.height = `${this._renderService.dimensions.css.cell.height}px`
              }
            })
            t.AccessibilityManager = u = o(
              [
                i(1, c.IInstantiationService),
                i(2, l.ICoreBrowserService),
                i(3, l.IRenderService)
              ],
              u
            )
          },
          3614: (e, t) => {
            function n(e) {
              return e.replace(/\r?\n/g, '\r')
            }
            function o(e, t) {
              return t ? '[200~' + e + '[201~' : e
            }
            function i(e, t, i, r) {
              ;(e = o(
                (e = n(e)),
                i.decPrivateModes.bracketedPasteMode &&
                  !0 !== r.rawOptions.ignoreBracketedPasteMode
              )),
                i.triggerDataEvent(e, !0),
                (t.value = '')
            }
            function r(e, t, n) {
              const o = n.getBoundingClientRect(),
                i = e.clientX - o.left - 10,
                r = e.clientY - o.top - 10
              ;(t.style.width = '20px'),
                (t.style.height = '20px'),
                (t.style.left = `${i}px`),
                (t.style.top = `${r}px`),
                (t.style.zIndex = '1000'),
                t.focus()
            }
            __name(n, 'i'),
              __name(o, 's'),
              __name(i, 'r'),
              __name(r, 'n'),
              Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.rightClickHandler =
                t.moveTextAreaUnderMouseCursor =
                t.paste =
                t.handlePasteEvent =
                t.copyHandler =
                t.bracketTextForPaste =
                t.prepareTextForTerminal =
                  void 0),
              (t.prepareTextForTerminal = n),
              (t.bracketTextForPaste = o),
              (t.copyHandler = function (e, t) {
                e.clipboardData &&
                  e.clipboardData.setData('text/plain', t.selectionText),
                  e.preventDefault()
              }),
              (t.handlePasteEvent = function (e, t, n, o) {
                e.stopPropagation(),
                  e.clipboardData &&
                    i(e.clipboardData.getData('text/plain'), t, n, o)
              }),
              (t.paste = i),
              (t.moveTextAreaUnderMouseCursor = r),
              (t.rightClickHandler = function (e, t, n, o, i) {
                r(e, t, n),
                  i && o.rightClickSelect(e),
                  (t.value = o.selectionText),
                  t.select()
              })
          },
          7239: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ColorContrastCache = void 0)
            const o = n(1505)
            t.ColorContrastCache = class {
              constructor() {
                ;(this._color = new o.TwoKeyMap()),
                  (this._css = new o.TwoKeyMap())
              }
              setCss(e, t, n) {
                this._css.set(e, t, n)
              }
              getCss(e, t) {
                return this._css.get(e, t)
              }
              setColor(e, t, n) {
                this._color.set(e, t, n)
              }
              getColor(e, t) {
                return this._color.get(e, t)
              }
              clear() {
                this._color.clear(), this._css.clear()
              }
            }
          },
          3656: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.addDisposableDomListener = void 0),
              (t.addDisposableDomListener = function (e, t, n, o) {
                e.addEventListener(t, n, o)
                let i = !1
                return {
                  dispose: __name(() => {
                    i || ((i = !0), e.removeEventListener(t, n, o))
                  }, 'dispose')
                }
              })
          },
          3551: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.Linkifier = void 0)
            const r = n(3656),
              a = n(8460),
              s = n(844),
              l = n(2585),
              c = n(4725)
            let d = (t.Linkifier = class extends s.Disposable {
              get currentLink() {
                return this._currentLink
              }
              constructor(e, t, n, o, i) {
                super(),
                  (this._element = e),
                  (this._mouseService = t),
                  (this._renderService = n),
                  (this._bufferService = o),
                  (this._linkProviderService = i),
                  (this._linkCacheDisposables = []),
                  (this._isMouseOut = !0),
                  (this._wasResized = !1),
                  (this._activeLine = -1),
                  (this._onShowLinkUnderline = this.register(
                    new a.EventEmitter()
                  )),
                  (this.onShowLinkUnderline = this._onShowLinkUnderline.event),
                  (this._onHideLinkUnderline = this.register(
                    new a.EventEmitter()
                  )),
                  (this.onHideLinkUnderline = this._onHideLinkUnderline.event),
                  this.register(
                    (0, s.getDisposeArrayDisposable)(this._linkCacheDisposables)
                  ),
                  this.register(
                    (0, s.toDisposable)(() => {
                      ;(this._lastMouseEvent = void 0),
                        this._activeProviderReplies?.clear()
                    })
                  ),
                  this.register(
                    this._bufferService.onResize(() => {
                      this._clearCurrentLink(), (this._wasResized = !0)
                    })
                  ),
                  this.register(
                    (0, r.addDisposableDomListener)(
                      this._element,
                      'mouseleave',
                      () => {
                        ;(this._isMouseOut = !0), this._clearCurrentLink()
                      }
                    )
                  ),
                  this.register(
                    (0, r.addDisposableDomListener)(
                      this._element,
                      'mousemove',
                      this._handleMouseMove.bind(this)
                    )
                  ),
                  this.register(
                    (0, r.addDisposableDomListener)(
                      this._element,
                      'mousedown',
                      this._handleMouseDown.bind(this)
                    )
                  ),
                  this.register(
                    (0, r.addDisposableDomListener)(
                      this._element,
                      'mouseup',
                      this._handleMouseUp.bind(this)
                    )
                  )
              }
              _handleMouseMove(e) {
                this._lastMouseEvent = e
                const t = this._positionFromMouseEvent(
                  e,
                  this._element,
                  this._mouseService
                )
                if (!t) return
                this._isMouseOut = !1
                const n = e.composedPath()
                for (let o = 0; o < n.length; o++) {
                  const e = n[o]
                  if (e.classList.contains('xterm')) break
                  if (e.classList.contains('xterm-hover')) return
                }
                ;(this._lastBufferCell &&
                  t.x === this._lastBufferCell.x &&
                  t.y === this._lastBufferCell.y) ||
                  (this._handleHover(t), (this._lastBufferCell = t))
              }
              _handleHover(e) {
                if (this._activeLine !== e.y || this._wasResized)
                  return (
                    this._clearCurrentLink(),
                    this._askForLink(e, !1),
                    void (this._wasResized = !1)
                  )
                ;(this._currentLink &&
                  this._linkAtPosition(this._currentLink.link, e)) ||
                  (this._clearCurrentLink(), this._askForLink(e, !0))
              }
              _askForLink(e, t) {
                ;(this._activeProviderReplies && t) ||
                  (this._activeProviderReplies?.forEach((e) => {
                    e?.forEach((e) => {
                      e.link.dispose && e.link.dispose()
                    })
                  }),
                  (this._activeProviderReplies = new Map()),
                  (this._activeLine = e.y))
                let n = !1
                for (const [
                  o,
                  i
                ] of this._linkProviderService.linkProviders.entries())
                  if (t) {
                    const t = this._activeProviderReplies?.get(o)
                    t && (n = this._checkLinkProviderResult(o, e, n))
                  } else
                    i.provideLinks(e.y, (t) => {
                      if (this._isMouseOut) return
                      const i = t?.map((e) => ({ link: e }))
                      this._activeProviderReplies?.set(o, i),
                        (n = this._checkLinkProviderResult(o, e, n)),
                        this._activeProviderReplies?.size ===
                          this._linkProviderService.linkProviders.length &&
                          this._removeIntersectingLinks(
                            e.y,
                            this._activeProviderReplies
                          )
                    })
              }
              _removeIntersectingLinks(e, t) {
                const n = new Set()
                for (let o = 0; o < t.size; o++) {
                  const i = t.get(o)
                  if (i)
                    for (let t = 0; t < i.length; t++) {
                      const o = i[t],
                        r = o.link.range.start.y < e ? 0 : o.link.range.start.x,
                        a =
                          o.link.range.end.y > e
                            ? this._bufferService.cols
                            : o.link.range.end.x
                      for (let e = r; e <= a; e++) {
                        if (n.has(e)) {
                          i.splice(t--, 1)
                          break
                        }
                        n.add(e)
                      }
                    }
                }
              }
              _checkLinkProviderResult(e, t, n) {
                if (!this._activeProviderReplies) return n
                const o = this._activeProviderReplies.get(e)
                let i = !1
                for (let r = 0; r < e; r++)
                  (this._activeProviderReplies.has(r) &&
                    !this._activeProviderReplies.get(r)) ||
                    (i = !0)
                if (!i && o) {
                  const e = o.find((e) => this._linkAtPosition(e.link, t))
                  e && ((n = !0), this._handleNewLink(e))
                }
                if (
                  this._activeProviderReplies.size ===
                    this._linkProviderService.linkProviders.length &&
                  !n
                )
                  for (let r = 0; r < this._activeProviderReplies.size; r++) {
                    const e = this._activeProviderReplies
                      .get(r)
                      ?.find((e) => this._linkAtPosition(e.link, t))
                    if (e) {
                      ;(n = !0), this._handleNewLink(e)
                      break
                    }
                  }
                return n
              }
              _handleMouseDown() {
                this._mouseDownLink = this._currentLink
              }
              _handleMouseUp(e) {
                if (!this._currentLink) return
                const t = this._positionFromMouseEvent(
                  e,
                  this._element,
                  this._mouseService
                )
                t &&
                  this._mouseDownLink === this._currentLink &&
                  this._linkAtPosition(this._currentLink.link, t) &&
                  this._currentLink.link.activate(
                    e,
                    this._currentLink.link.text
                  )
              }
              _clearCurrentLink(e, t) {
                this._currentLink &&
                  this._lastMouseEvent &&
                  (!e ||
                    !t ||
                    (this._currentLink.link.range.start.y >= e &&
                      this._currentLink.link.range.end.y <= t)) &&
                  (this._linkLeave(
                    this._element,
                    this._currentLink.link,
                    this._lastMouseEvent
                  ),
                  (this._currentLink = void 0),
                  (0, s.disposeArray)(this._linkCacheDisposables))
              }
              _handleNewLink(e) {
                if (!this._lastMouseEvent) return
                const t = this._positionFromMouseEvent(
                  this._lastMouseEvent,
                  this._element,
                  this._mouseService
                )
                t &&
                  this._linkAtPosition(e.link, t) &&
                  ((this._currentLink = e),
                  (this._currentLink.state = {
                    decorations: {
                      underline:
                        void 0 === e.link.decorations ||
                        e.link.decorations.underline,
                      pointerCursor:
                        void 0 === e.link.decorations ||
                        e.link.decorations.pointerCursor
                    },
                    isHovered: !0
                  }),
                  this._linkHover(this._element, e.link, this._lastMouseEvent),
                  (e.link.decorations = {}),
                  Object.defineProperties(e.link.decorations, {
                    pointerCursor: {
                      get: __name(
                        () =>
                          this._currentLink?.state?.decorations.pointerCursor,
                        'get'
                      ),
                      set: __name((e) => {
                        this._currentLink?.state &&
                          this._currentLink.state.decorations.pointerCursor !==
                            e &&
                          ((this._currentLink.state.decorations.pointerCursor =
                            e),
                          this._currentLink.state.isHovered &&
                            this._element.classList.toggle(
                              'xterm-cursor-pointer',
                              e
                            ))
                      }, 'set')
                    },
                    underline: {
                      get: __name(
                        () => this._currentLink?.state?.decorations.underline,
                        'get'
                      ),
                      set: __name((t) => {
                        this._currentLink?.state &&
                          this._currentLink?.state?.decorations.underline !==
                            t &&
                          ((this._currentLink.state.decorations.underline = t),
                          this._currentLink.state.isHovered &&
                            this._fireUnderlineEvent(e.link, t))
                      }, 'set')
                    }
                  }),
                  this._linkCacheDisposables.push(
                    this._renderService.onRenderedViewportChange((e) => {
                      if (!this._currentLink) return
                      const t =
                          0 === e.start
                            ? 0
                            : e.start + 1 + this._bufferService.buffer.ydisp,
                        n = this._bufferService.buffer.ydisp + 1 + e.end
                      if (
                        this._currentLink.link.range.start.y >= t &&
                        this._currentLink.link.range.end.y <= n &&
                        (this._clearCurrentLink(t, n), this._lastMouseEvent)
                      ) {
                        const e = this._positionFromMouseEvent(
                          this._lastMouseEvent,
                          this._element,
                          this._mouseService
                        )
                        e && this._askForLink(e, !1)
                      }
                    })
                  ))
              }
              _linkHover(e, t, n) {
                this._currentLink?.state &&
                  ((this._currentLink.state.isHovered = !0),
                  this._currentLink.state.decorations.underline &&
                    this._fireUnderlineEvent(t, !0),
                  this._currentLink.state.decorations.pointerCursor &&
                    e.classList.add('xterm-cursor-pointer')),
                  t.hover && t.hover(n, t.text)
              }
              _fireUnderlineEvent(e, t) {
                const n = e.range,
                  o = this._bufferService.buffer.ydisp,
                  i = this._createLinkUnderlineEvent(
                    n.start.x - 1,
                    n.start.y - o - 1,
                    n.end.x,
                    n.end.y - o - 1,
                    void 0
                  )
                ;(t
                  ? this._onShowLinkUnderline
                  : this._onHideLinkUnderline
                ).fire(i)
              }
              _linkLeave(e, t, n) {
                this._currentLink?.state &&
                  ((this._currentLink.state.isHovered = !1),
                  this._currentLink.state.decorations.underline &&
                    this._fireUnderlineEvent(t, !1),
                  this._currentLink.state.decorations.pointerCursor &&
                    e.classList.remove('xterm-cursor-pointer')),
                  t.leave && t.leave(n, t.text)
              }
              _linkAtPosition(e, t) {
                const n =
                    e.range.start.y * this._bufferService.cols +
                    e.range.start.x,
                  o = e.range.end.y * this._bufferService.cols + e.range.end.x,
                  i = t.y * this._bufferService.cols + t.x
                return n <= i && i <= o
              }
              _positionFromMouseEvent(e, t, n) {
                const o = n.getCoords(
                  e,
                  t,
                  this._bufferService.cols,
                  this._bufferService.rows
                )
                if (o)
                  return { x: o[0], y: o[1] + this._bufferService.buffer.ydisp }
              }
              _createLinkUnderlineEvent(e, t, n, o, i) {
                return {
                  x1: e,
                  y1: t,
                  x2: n,
                  y2: o,
                  cols: this._bufferService.cols,
                  fg: i
                }
              }
            })
            t.Linkifier = d = o(
              [
                i(1, c.IMouseService),
                i(2, c.IRenderService),
                i(3, l.IBufferService),
                i(4, c.ILinkProviderService)
              ],
              d
            )
          },
          9042: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.tooMuchOutput = t.promptLabel = void 0),
              (t.promptLabel = 'Terminal input'),
              (t.tooMuchOutput =
                'Too much output to announce, navigate to rows manually to read')
          },
          3730: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.OscLinkProvider = void 0)
            const r = n(511),
              a = n(2585)
            let s = (t.OscLinkProvider = class {
              constructor(e, t, n) {
                ;(this._bufferService = e),
                  (this._optionsService = t),
                  (this._oscLinkService = n)
              }
              provideLinks(e, t) {
                const n = this._bufferService.buffer.lines.get(e - 1)
                if (!n) return void t(void 0)
                const o = [],
                  i = this._optionsService.rawOptions.linkHandler,
                  a = new r.CellData(),
                  s = n.getTrimmedLength()
                let c = -1,
                  d = -1,
                  u = !1
                for (let r = 0; r < s; r++)
                  if (-1 !== d || n.hasContent(r)) {
                    if (
                      (n.loadCell(r, a),
                      a.hasExtendedAttrs() && a.extended.urlId)
                    ) {
                      if (-1 === d) {
                        ;(d = r), (c = a.extended.urlId)
                        continue
                      }
                      u = a.extended.urlId !== c
                    } else -1 !== d && (u = !0)
                    if (u || (-1 !== d && r === s - 1)) {
                      const t = this._oscLinkService.getLinkData(c)?.uri
                      if (t) {
                        const n = {
                          start: { x: d + 1, y: e },
                          end: { x: r + (u || r !== s - 1 ? 0 : 1), y: e }
                        }
                        let a = !1
                        if (!i?.allowNonHttpProtocols)
                          try {
                            const e = new URL(t)
                            ;['http:', 'https:'].includes(e.protocol) ||
                              (a = !0)
                          } catch (p) {
                            a = !0
                          }
                        a ||
                          o.push({
                            text: t,
                            range: n,
                            activate: __name(
                              (e, t) => (i ? i.activate(e, t, n) : l(0, t)),
                              'activate'
                            ),
                            hover: __name(
                              (e, t) => i?.hover?.(e, t, n),
                              'hover'
                            ),
                            leave: __name(
                              (e, t) => i?.leave?.(e, t, n),
                              'leave'
                            )
                          })
                      }
                      ;(u = !1),
                        a.hasExtendedAttrs() && a.extended.urlId
                          ? ((d = r), (c = a.extended.urlId))
                          : ((d = -1), (c = -1))
                    }
                  }
                t(o)
              }
            })
            function l(e, t) {
              if (
                confirm(
                  `Do you want to navigate to ${t}?\n\nWARNING: This link could potentially be dangerous`
                )
              ) {
                const e = window.open()
                if (e) {
                  try {
                    e.opener = null
                  } catch {}
                  e.location.href = t
                } else
                  console.warn(
                    'Opening link blocked as opener could not be cleared'
                  )
              }
            }
            __name(l, 'h'),
              (t.OscLinkProvider = s =
                o(
                  [
                    i(0, a.IBufferService),
                    i(1, a.IOptionsService),
                    i(2, a.IOscLinkService)
                  ],
                  s
                ))
          },
          6193: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.RenderDebouncer = void 0),
              (t.RenderDebouncer = class {
                constructor(e, t) {
                  ;(this._renderCallback = e),
                    (this._coreBrowserService = t),
                    (this._refreshCallbacks = [])
                }
                dispose() {
                  this._animationFrame &&
                    (this._coreBrowserService.window.cancelAnimationFrame(
                      this._animationFrame
                    ),
                    (this._animationFrame = void 0))
                }
                addRefreshCallback(e) {
                  return (
                    this._refreshCallbacks.push(e),
                    this._animationFrame ||
                      (this._animationFrame =
                        this._coreBrowserService.window.requestAnimationFrame(
                          () => this._innerRefresh()
                        )),
                    this._animationFrame
                  )
                }
                refresh(e, t, n) {
                  ;(this._rowCount = n),
                    (e = void 0 !== e ? e : 0),
                    (t = void 0 !== t ? t : this._rowCount - 1),
                    (this._rowStart =
                      void 0 !== this._rowStart
                        ? Math.min(this._rowStart, e)
                        : e),
                    (this._rowEnd =
                      void 0 !== this._rowEnd ? Math.max(this._rowEnd, t) : t),
                    this._animationFrame ||
                      (this._animationFrame =
                        this._coreBrowserService.window.requestAnimationFrame(
                          () => this._innerRefresh()
                        ))
                }
                _innerRefresh() {
                  if (
                    ((this._animationFrame = void 0),
                    void 0 === this._rowStart ||
                      void 0 === this._rowEnd ||
                      void 0 === this._rowCount)
                  )
                    return void this._runRefreshCallbacks()
                  const e = Math.max(this._rowStart, 0),
                    t = Math.min(this._rowEnd, this._rowCount - 1)
                  ;(this._rowStart = void 0),
                    (this._rowEnd = void 0),
                    this._renderCallback(e, t),
                    this._runRefreshCallbacks()
                }
                _runRefreshCallbacks() {
                  for (const e of this._refreshCallbacks) e(0)
                  this._refreshCallbacks = []
                }
              })
          },
          3236: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.Terminal = void 0)
            const o = n(3614),
              i = n(3656),
              r = n(3551),
              a = n(9042),
              s = n(3730),
              l = n(1680),
              c = n(3107),
              d = n(5744),
              u = n(2950),
              p = n(1296),
              h = n(428),
              m = n(4269),
              f = n(5114),
              _ = n(8934),
              g = n(3230),
              v = n(9312),
              y = n(4725),
              b = n(6731),
              S = n(8055),
              C = n(8969),
              w = n(8460),
              k = n(844),
              x = n(6114),
              E = n(8437),
              I = n(2584),
              T = n(7399),
              $ = n(5941),
              L = n(9074),
              A = n(2585),
              O = n(5435),
              P = n(4567),
              V = n(779)
            class D extends C.CoreTerminal {
              static {
                __name(this, 'P')
              }
              get onFocus() {
                return this._onFocus.event
              }
              get onBlur() {
                return this._onBlur.event
              }
              get onA11yChar() {
                return this._onA11yCharEmitter.event
              }
              get onA11yTab() {
                return this._onA11yTabEmitter.event
              }
              get onWillOpen() {
                return this._onWillOpen.event
              }
              constructor(e = {}) {
                super(e),
                  (this.browser = x),
                  (this._keyDownHandled = !1),
                  (this._keyDownSeen = !1),
                  (this._keyPressHandled = !1),
                  (this._unprocessedDeadKey = !1),
                  (this._accessibilityManager = this.register(
                    new k.MutableDisposable()
                  )),
                  (this._onCursorMove = this.register(new w.EventEmitter())),
                  (this.onCursorMove = this._onCursorMove.event),
                  (this._onKey = this.register(new w.EventEmitter())),
                  (this.onKey = this._onKey.event),
                  (this._onRender = this.register(new w.EventEmitter())),
                  (this.onRender = this._onRender.event),
                  (this._onSelectionChange = this.register(
                    new w.EventEmitter()
                  )),
                  (this.onSelectionChange = this._onSelectionChange.event),
                  (this._onTitleChange = this.register(new w.EventEmitter())),
                  (this.onTitleChange = this._onTitleChange.event),
                  (this._onBell = this.register(new w.EventEmitter())),
                  (this.onBell = this._onBell.event),
                  (this._onFocus = this.register(new w.EventEmitter())),
                  (this._onBlur = this.register(new w.EventEmitter())),
                  (this._onA11yCharEmitter = this.register(
                    new w.EventEmitter()
                  )),
                  (this._onA11yTabEmitter = this.register(
                    new w.EventEmitter()
                  )),
                  (this._onWillOpen = this.register(new w.EventEmitter())),
                  this._setup(),
                  (this._decorationService =
                    this._instantiationService.createInstance(
                      L.DecorationService
                    )),
                  this._instantiationService.setService(
                    A.IDecorationService,
                    this._decorationService
                  ),
                  (this._linkProviderService =
                    this._instantiationService.createInstance(
                      V.LinkProviderService
                    )),
                  this._instantiationService.setService(
                    y.ILinkProviderService,
                    this._linkProviderService
                  ),
                  this._linkProviderService.registerLinkProvider(
                    this._instantiationService.createInstance(s.OscLinkProvider)
                  ),
                  this.register(
                    this._inputHandler.onRequestBell(() => this._onBell.fire())
                  ),
                  this.register(
                    this._inputHandler.onRequestRefreshRows((e, t) =>
                      this.refresh(e, t)
                    )
                  ),
                  this.register(
                    this._inputHandler.onRequestSendFocus(() =>
                      this._reportFocus()
                    )
                  ),
                  this.register(
                    this._inputHandler.onRequestReset(() => this.reset())
                  ),
                  this.register(
                    this._inputHandler.onRequestWindowsOptionsReport((e) =>
                      this._reportWindowsOptions(e)
                    )
                  ),
                  this.register(
                    this._inputHandler.onColor((e) => this._handleColorEvent(e))
                  ),
                  this.register(
                    (0, w.forwardEvent)(
                      this._inputHandler.onCursorMove,
                      this._onCursorMove
                    )
                  ),
                  this.register(
                    (0, w.forwardEvent)(
                      this._inputHandler.onTitleChange,
                      this._onTitleChange
                    )
                  ),
                  this.register(
                    (0, w.forwardEvent)(
                      this._inputHandler.onA11yChar,
                      this._onA11yCharEmitter
                    )
                  ),
                  this.register(
                    (0, w.forwardEvent)(
                      this._inputHandler.onA11yTab,
                      this._onA11yTabEmitter
                    )
                  ),
                  this.register(
                    this._bufferService.onResize((e) =>
                      this._afterResize(e.cols, e.rows)
                    )
                  ),
                  this.register(
                    (0, k.toDisposable)(() => {
                      ;(this._customKeyEventHandler = void 0),
                        this.element?.parentNode?.removeChild(this.element)
                    })
                  )
              }
              _handleColorEvent(e) {
                if (this._themeService)
                  for (const t of e) {
                    let e,
                      n = ''
                    switch (t.index) {
                      case 256:
                        ;(e = 'foreground'), (n = '10')
                        break
                      case 257:
                        ;(e = 'background'), (n = '11')
                        break
                      case 258:
                        ;(e = 'cursor'), (n = '12')
                        break
                      default:
                        ;(e = 'ansi'), (n = '4;' + t.index)
                    }
                    switch (t.type) {
                      case 0:
                        const o = S.color.toColorRGB(
                          'ansi' === e
                            ? this._themeService.colors.ansi[t.index]
                            : this._themeService.colors[e]
                        )
                        this.coreService.triggerDataEvent(
                          `${I.C0.ESC}]${n};${(0, $.toRgbString)(o)}${I.C1_ESCAPED.ST}`
                        )
                        break
                      case 1:
                        if ('ansi' === e)
                          this._themeService.modifyColors(
                            (e) =>
                              (e.ansi[t.index] = S.channels.toColor(...t.color))
                          )
                        else {
                          const n = e
                          this._themeService.modifyColors(
                            (e) => (e[n] = S.channels.toColor(...t.color))
                          )
                        }
                        break
                      case 2:
                        this._themeService.restoreColor(t.index)
                    }
                  }
              }
              _setup() {
                super._setup(), (this._customKeyEventHandler = void 0)
              }
              get buffer() {
                return this.buffers.active
              }
              focus() {
                this.textarea && this.textarea.focus({ preventScroll: !0 })
              }
              _handleScreenReaderModeOptionChange(e) {
                e
                  ? !this._accessibilityManager.value &&
                    this._renderService &&
                    (this._accessibilityManager.value =
                      this._instantiationService.createInstance(
                        P.AccessibilityManager,
                        this
                      ))
                  : this._accessibilityManager.clear()
              }
              _handleTextAreaFocus(e) {
                this.coreService.decPrivateModes.sendFocus &&
                  this.coreService.triggerDataEvent(I.C0.ESC + '[I'),
                  this.element.classList.add('focus'),
                  this._showCursor(),
                  this._onFocus.fire()
              }
              blur() {
                return this.textarea?.blur()
              }
              _handleTextAreaBlur() {
                ;(this.textarea.value = ''),
                  this.refresh(this.buffer.y, this.buffer.y),
                  this.coreService.decPrivateModes.sendFocus &&
                    this.coreService.triggerDataEvent(I.C0.ESC + '[O'),
                  this.element.classList.remove('focus'),
                  this._onBlur.fire()
              }
              _syncTextArea() {
                if (
                  !this.textarea ||
                  !this.buffer.isCursorInViewport ||
                  this._compositionHelper.isComposing ||
                  !this._renderService
                )
                  return
                const e = this.buffer.ybase + this.buffer.y,
                  t = this.buffer.lines.get(e)
                if (!t) return
                const n = Math.min(this.buffer.x, this.cols - 1),
                  o = this._renderService.dimensions.css.cell.height,
                  i = t.getWidth(n),
                  r = this._renderService.dimensions.css.cell.width * i,
                  a =
                    this.buffer.y *
                    this._renderService.dimensions.css.cell.height,
                  s = n * this._renderService.dimensions.css.cell.width
                ;(this.textarea.style.left = s + 'px'),
                  (this.textarea.style.top = a + 'px'),
                  (this.textarea.style.width = r + 'px'),
                  (this.textarea.style.height = o + 'px'),
                  (this.textarea.style.lineHeight = o + 'px'),
                  (this.textarea.style.zIndex = '-5')
              }
              _initGlobal() {
                this._bindKeys(),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      this.element,
                      'copy',
                      (e) => {
                        this.hasSelection() &&
                          (0, o.copyHandler)(e, this._selectionService)
                      }
                    )
                  )
                const e = __name(
                  (e) =>
                    (0, o.handlePasteEvent)(
                      e,
                      this.textarea,
                      this.coreService,
                      this.optionsService
                    ),
                  'e'
                )
                this.register(
                  (0, i.addDisposableDomListener)(this.textarea, 'paste', e)
                ),
                  this.register(
                    (0, i.addDisposableDomListener)(this.element, 'paste', e)
                  ),
                  x.isFirefox
                    ? this.register(
                        (0, i.addDisposableDomListener)(
                          this.element,
                          'mousedown',
                          (e) => {
                            2 === e.button &&
                              (0, o.rightClickHandler)(
                                e,
                                this.textarea,
                                this.screenElement,
                                this._selectionService,
                                this.options.rightClickSelectsWord
                              )
                          }
                        )
                      )
                    : this.register(
                        (0, i.addDisposableDomListener)(
                          this.element,
                          'contextmenu',
                          (e) => {
                            ;(0, o.rightClickHandler)(
                              e,
                              this.textarea,
                              this.screenElement,
                              this._selectionService,
                              this.options.rightClickSelectsWord
                            )
                          }
                        )
                      ),
                  x.isLinux &&
                    this.register(
                      (0, i.addDisposableDomListener)(
                        this.element,
                        'auxclick',
                        (e) => {
                          1 === e.button &&
                            (0, o.moveTextAreaUnderMouseCursor)(
                              e,
                              this.textarea,
                              this.screenElement
                            )
                        }
                      )
                    )
              }
              _bindKeys() {
                this.register(
                  (0, i.addDisposableDomListener)(
                    this.textarea,
                    'keyup',
                    (e) => this._keyUp(e),
                    !0
                  )
                ),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      this.textarea,
                      'keydown',
                      (e) => this._keyDown(e),
                      !0
                    )
                  ),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      this.textarea,
                      'keypress',
                      (e) => this._keyPress(e),
                      !0
                    )
                  ),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      this.textarea,
                      'compositionstart',
                      () => this._compositionHelper.compositionstart()
                    )
                  ),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      this.textarea,
                      'compositionupdate',
                      (e) => this._compositionHelper.compositionupdate(e)
                    )
                  ),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      this.textarea,
                      'compositionend',
                      () => this._compositionHelper.compositionend()
                    )
                  ),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      this.textarea,
                      'input',
                      (e) => this._inputEvent(e),
                      !0
                    )
                  ),
                  this.register(
                    this.onRender(() =>
                      this._compositionHelper.updateCompositionElements()
                    )
                  )
              }
              open(e) {
                if (!e) throw new Error('Terminal requires a parent element.')
                if (
                  (e.isConnected ||
                    this._logService.debug(
                      'Terminal.open was called on an element that was not attached to the DOM'
                    ),
                  this.element?.ownerDocument.defaultView &&
                    this._coreBrowserService)
                )
                  return void (
                    this.element.ownerDocument.defaultView !==
                      this._coreBrowserService.window &&
                    (this._coreBrowserService.window =
                      this.element.ownerDocument.defaultView)
                  )
                ;(this._document = e.ownerDocument),
                  this.options.documentOverride &&
                    this.options.documentOverride instanceof Document &&
                    (this._document =
                      this.optionsService.rawOptions.documentOverride),
                  (this.element = this._document.createElement('div')),
                  (this.element.dir = 'ltr'),
                  this.element.classList.add('terminal'),
                  this.element.classList.add('xterm'),
                  e.appendChild(this.element)
                const t = this._document.createDocumentFragment()
                ;(this._viewportElement = this._document.createElement('div')),
                  this._viewportElement.classList.add('xterm-viewport'),
                  t.appendChild(this._viewportElement),
                  (this._viewportScrollArea =
                    this._document.createElement('div')),
                  this._viewportScrollArea.classList.add('xterm-scroll-area'),
                  this._viewportElement.appendChild(this._viewportScrollArea),
                  (this.screenElement = this._document.createElement('div')),
                  this.screenElement.classList.add('xterm-screen'),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      this.screenElement,
                      'mousemove',
                      (e) => this.updateCursorStyle(e)
                    )
                  ),
                  (this._helperContainer = this._document.createElement('div')),
                  this._helperContainer.classList.add('xterm-helpers'),
                  this.screenElement.appendChild(this._helperContainer),
                  t.appendChild(this.screenElement),
                  (this.textarea = this._document.createElement('textarea')),
                  this.textarea.classList.add('xterm-helper-textarea'),
                  this.textarea.setAttribute('aria-label', a.promptLabel),
                  x.isChromeOS ||
                    this.textarea.setAttribute('aria-multiline', 'false'),
                  this.textarea.setAttribute('autocorrect', 'off'),
                  this.textarea.setAttribute('autocapitalize', 'off'),
                  this.textarea.setAttribute('spellcheck', 'false'),
                  (this.textarea.tabIndex = 0),
                  (this._coreBrowserService = this.register(
                    this._instantiationService.createInstance(
                      f.CoreBrowserService,
                      this.textarea,
                      e.ownerDocument.defaultView ?? window,
                      (this._document ?? 'undefined' != typeof window)
                        ? window.document
                        : null
                    )
                  )),
                  this._instantiationService.setService(
                    y.ICoreBrowserService,
                    this._coreBrowserService
                  ),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      this.textarea,
                      'focus',
                      (e) => this._handleTextAreaFocus(e)
                    )
                  ),
                  this.register(
                    (0, i.addDisposableDomListener)(this.textarea, 'blur', () =>
                      this._handleTextAreaBlur()
                    )
                  ),
                  this._helperContainer.appendChild(this.textarea),
                  (this._charSizeService =
                    this._instantiationService.createInstance(
                      h.CharSizeService,
                      this._document,
                      this._helperContainer
                    )),
                  this._instantiationService.setService(
                    y.ICharSizeService,
                    this._charSizeService
                  ),
                  (this._themeService =
                    this._instantiationService.createInstance(b.ThemeService)),
                  this._instantiationService.setService(
                    y.IThemeService,
                    this._themeService
                  ),
                  (this._characterJoinerService =
                    this._instantiationService.createInstance(
                      m.CharacterJoinerService
                    )),
                  this._instantiationService.setService(
                    y.ICharacterJoinerService,
                    this._characterJoinerService
                  ),
                  (this._renderService = this.register(
                    this._instantiationService.createInstance(
                      g.RenderService,
                      this.rows,
                      this.screenElement
                    )
                  )),
                  this._instantiationService.setService(
                    y.IRenderService,
                    this._renderService
                  ),
                  this.register(
                    this._renderService.onRenderedViewportChange((e) =>
                      this._onRender.fire(e)
                    )
                  ),
                  this.onResize((e) =>
                    this._renderService.resize(e.cols, e.rows)
                  ),
                  (this._compositionView = this._document.createElement('div')),
                  this._compositionView.classList.add('composition-view'),
                  (this._compositionHelper =
                    this._instantiationService.createInstance(
                      u.CompositionHelper,
                      this.textarea,
                      this._compositionView
                    )),
                  this._helperContainer.appendChild(this._compositionView),
                  (this._mouseService =
                    this._instantiationService.createInstance(_.MouseService)),
                  this._instantiationService.setService(
                    y.IMouseService,
                    this._mouseService
                  ),
                  (this.linkifier = this.register(
                    this._instantiationService.createInstance(
                      r.Linkifier,
                      this.screenElement
                    )
                  )),
                  this.element.appendChild(t)
                try {
                  this._onWillOpen.fire(this.element)
                } catch {}
                this._renderService.hasRenderer() ||
                  this._renderService.setRenderer(this._createRenderer()),
                  (this.viewport = this._instantiationService.createInstance(
                    l.Viewport,
                    this._viewportElement,
                    this._viewportScrollArea
                  )),
                  this.viewport.onRequestScrollLines((e) =>
                    this.scrollLines(e.amount, e.suppressScrollEvent, 1)
                  ),
                  this.register(
                    this._inputHandler.onRequestSyncScrollBar(() =>
                      this.viewport.syncScrollArea()
                    )
                  ),
                  this.register(this.viewport),
                  this.register(
                    this.onCursorMove(() => {
                      this._renderService.handleCursorMove(),
                        this._syncTextArea()
                    })
                  ),
                  this.register(
                    this.onResize(() =>
                      this._renderService.handleResize(this.cols, this.rows)
                    )
                  ),
                  this.register(
                    this.onBlur(() => this._renderService.handleBlur())
                  ),
                  this.register(
                    this.onFocus(() => this._renderService.handleFocus())
                  ),
                  this.register(
                    this._renderService.onDimensionsChange(() =>
                      this.viewport.syncScrollArea()
                    )
                  ),
                  (this._selectionService = this.register(
                    this._instantiationService.createInstance(
                      v.SelectionService,
                      this.element,
                      this.screenElement,
                      this.linkifier
                    )
                  )),
                  this._instantiationService.setService(
                    y.ISelectionService,
                    this._selectionService
                  ),
                  this.register(
                    this._selectionService.onRequestScrollLines((e) =>
                      this.scrollLines(e.amount, e.suppressScrollEvent)
                    )
                  ),
                  this.register(
                    this._selectionService.onSelectionChange(() =>
                      this._onSelectionChange.fire()
                    )
                  ),
                  this.register(
                    this._selectionService.onRequestRedraw((e) =>
                      this._renderService.handleSelectionChanged(
                        e.start,
                        e.end,
                        e.columnSelectMode
                      )
                    )
                  ),
                  this.register(
                    this._selectionService.onLinuxMouseSelection((e) => {
                      ;(this.textarea.value = e),
                        this.textarea.focus(),
                        this.textarea.select()
                    })
                  ),
                  this.register(
                    this._onScroll.event((e) => {
                      this.viewport.syncScrollArea(),
                        this._selectionService.refresh()
                    })
                  ),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      this._viewportElement,
                      'scroll',
                      () => this._selectionService.refresh()
                    )
                  ),
                  this.register(
                    this._instantiationService.createInstance(
                      c.BufferDecorationRenderer,
                      this.screenElement
                    )
                  ),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      this.element,
                      'mousedown',
                      (e) => this._selectionService.handleMouseDown(e)
                    )
                  ),
                  this.coreMouseService.areMouseEventsActive
                    ? (this._selectionService.disable(),
                      this.element.classList.add('enable-mouse-events'))
                    : this._selectionService.enable(),
                  this.options.screenReaderMode &&
                    (this._accessibilityManager.value =
                      this._instantiationService.createInstance(
                        P.AccessibilityManager,
                        this
                      )),
                  this.register(
                    this.optionsService.onSpecificOptionChange(
                      'screenReaderMode',
                      (e) => this._handleScreenReaderModeOptionChange(e)
                    )
                  ),
                  this.options.overviewRulerWidth &&
                    (this._overviewRulerRenderer = this.register(
                      this._instantiationService.createInstance(
                        d.OverviewRulerRenderer,
                        this._viewportElement,
                        this.screenElement
                      )
                    )),
                  this.optionsService.onSpecificOptionChange(
                    'overviewRulerWidth',
                    (e) => {
                      !this._overviewRulerRenderer &&
                        e &&
                        this._viewportElement &&
                        this.screenElement &&
                        (this._overviewRulerRenderer = this.register(
                          this._instantiationService.createInstance(
                            d.OverviewRulerRenderer,
                            this._viewportElement,
                            this.screenElement
                          )
                        ))
                    }
                  ),
                  this._charSizeService.measure(),
                  this.refresh(0, this.rows - 1),
                  this._initGlobal(),
                  this.bindMouse()
              }
              _createRenderer() {
                return this._instantiationService.createInstance(
                  p.DomRenderer,
                  this,
                  this._document,
                  this.element,
                  this.screenElement,
                  this._viewportElement,
                  this._helperContainer,
                  this.linkifier
                )
              }
              bindMouse() {
                const e = this,
                  t = this.element
                function n(t) {
                  const n = e._mouseService.getMouseReportCoords(
                    t,
                    e.screenElement
                  )
                  if (!n) return !1
                  let o, i
                  switch (t.overrideType || t.type) {
                    case 'mousemove':
                      ;(i = 32),
                        void 0 === t.buttons
                          ? ((o = 3),
                            void 0 !== t.button &&
                              (o = t.button < 3 ? t.button : 3))
                          : (o =
                              1 & t.buttons
                                ? 0
                                : 4 & t.buttons
                                  ? 1
                                  : 2 & t.buttons
                                    ? 2
                                    : 3)
                      break
                    case 'mouseup':
                      ;(i = 0), (o = t.button < 3 ? t.button : 3)
                      break
                    case 'mousedown':
                      ;(i = 1), (o = t.button < 3 ? t.button : 3)
                      break
                    case 'wheel':
                      if (
                        e._customWheelEventHandler &&
                        !1 === e._customWheelEventHandler(t)
                      )
                        return !1
                      if (0 === e.viewport.getLinesScrolled(t)) return !1
                      ;(i = t.deltaY < 0 ? 0 : 1), (o = 4)
                      break
                    default:
                      return !1
                  }
                  return (
                    !(void 0 === i || void 0 === o || o > 4) &&
                    e.coreMouseService.triggerMouseEvent({
                      col: n.col,
                      row: n.row,
                      x: n.x,
                      y: n.y,
                      button: o,
                      action: i,
                      ctrl: t.ctrlKey,
                      alt: t.altKey,
                      shift: t.shiftKey
                    })
                  )
                }
                __name(n, 'i')
                const o = {
                    mouseup: null,
                    wheel: null,
                    mousedrag: null,
                    mousemove: null
                  },
                  r = {
                    mouseup: __name(
                      (e) => (
                        n(e),
                        e.buttons ||
                          (this._document.removeEventListener(
                            'mouseup',
                            o.mouseup
                          ),
                          o.mousedrag &&
                            this._document.removeEventListener(
                              'mousemove',
                              o.mousedrag
                            )),
                        this.cancel(e)
                      ),
                      'mouseup'
                    ),
                    wheel: __name((e) => (n(e), this.cancel(e, !0)), 'wheel'),
                    mousedrag: __name((e) => {
                      e.buttons && n(e)
                    }, 'mousedrag'),
                    mousemove: __name((e) => {
                      e.buttons || n(e)
                    }, 'mousemove')
                  }
                this.register(
                  this.coreMouseService.onProtocolChange((e) => {
                    e
                      ? ('debug' === this.optionsService.rawOptions.logLevel &&
                          this._logService.debug(
                            'Binding to mouse events:',
                            this.coreMouseService.explainEvents(e)
                          ),
                        this.element.classList.add('enable-mouse-events'),
                        this._selectionService.disable())
                      : (this._logService.debug('Unbinding from mouse events.'),
                        this.element.classList.remove('enable-mouse-events'),
                        this._selectionService.enable()),
                      8 & e
                        ? o.mousemove ||
                          (t.addEventListener('mousemove', r.mousemove),
                          (o.mousemove = r.mousemove))
                        : (t.removeEventListener('mousemove', o.mousemove),
                          (o.mousemove = null)),
                      16 & e
                        ? o.wheel ||
                          (t.addEventListener('wheel', r.wheel, {
                            passive: !1
                          }),
                          (o.wheel = r.wheel))
                        : (t.removeEventListener('wheel', o.wheel),
                          (o.wheel = null)),
                      2 & e
                        ? o.mouseup || (o.mouseup = r.mouseup)
                        : (this._document.removeEventListener(
                            'mouseup',
                            o.mouseup
                          ),
                          (o.mouseup = null)),
                      4 & e
                        ? o.mousedrag || (o.mousedrag = r.mousedrag)
                        : (this._document.removeEventListener(
                            'mousemove',
                            o.mousedrag
                          ),
                          (o.mousedrag = null))
                  })
                ),
                  (this.coreMouseService.activeProtocol =
                    this.coreMouseService.activeProtocol),
                  this.register(
                    (0, i.addDisposableDomListener)(t, 'mousedown', (e) => {
                      if (
                        (e.preventDefault(),
                        this.focus(),
                        this.coreMouseService.areMouseEventsActive &&
                          !this._selectionService.shouldForceSelection(e))
                      )
                        return (
                          n(e),
                          o.mouseup &&
                            this._document.addEventListener(
                              'mouseup',
                              o.mouseup
                            ),
                          o.mousedrag &&
                            this._document.addEventListener(
                              'mousemove',
                              o.mousedrag
                            ),
                          this.cancel(e)
                        )
                    })
                  ),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      t,
                      'wheel',
                      (e) => {
                        if (!o.wheel) {
                          if (
                            this._customWheelEventHandler &&
                            !1 === this._customWheelEventHandler(e)
                          )
                            return !1
                          if (!this.buffer.hasScrollback) {
                            const t = this.viewport.getLinesScrolled(e)
                            if (0 === t) return
                            const n =
                              I.C0.ESC +
                              (this.coreService.decPrivateModes
                                .applicationCursorKeys
                                ? 'O'
                                : '[') +
                              (e.deltaY < 0 ? 'A' : 'B')
                            let o = ''
                            for (let e = 0; e < Math.abs(t); e++) o += n
                            return (
                              this.coreService.triggerDataEvent(o, !0),
                              this.cancel(e, !0)
                            )
                          }
                          return this.viewport.handleWheel(e)
                            ? this.cancel(e)
                            : void 0
                        }
                      },
                      { passive: !1 }
                    )
                  ),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      t,
                      'touchstart',
                      (e) => {
                        if (!this.coreMouseService.areMouseEventsActive)
                          return (
                            this.viewport.handleTouchStart(e), this.cancel(e)
                          )
                      },
                      { passive: !0 }
                    )
                  ),
                  this.register(
                    (0, i.addDisposableDomListener)(
                      t,
                      'touchmove',
                      (e) => {
                        if (!this.coreMouseService.areMouseEventsActive)
                          return this.viewport.handleTouchMove(e)
                            ? void 0
                            : this.cancel(e)
                      },
                      { passive: !1 }
                    )
                  )
              }
              refresh(e, t) {
                this._renderService?.refreshRows(e, t)
              }
              updateCursorStyle(e) {
                this._selectionService?.shouldColumnSelect(e)
                  ? this.element.classList.add('column-select')
                  : this.element.classList.remove('column-select')
              }
              _showCursor() {
                this.coreService.isCursorInitialized ||
                  ((this.coreService.isCursorInitialized = !0),
                  this.refresh(this.buffer.y, this.buffer.y))
              }
              scrollLines(e, t, n = 0) {
                1 === n
                  ? (super.scrollLines(e, t, n), this.refresh(0, this.rows - 1))
                  : this.viewport?.scrollLines(e)
              }
              paste(e) {
                ;(0, o.paste)(
                  e,
                  this.textarea,
                  this.coreService,
                  this.optionsService
                )
              }
              attachCustomKeyEventHandler(e) {
                this._customKeyEventHandler = e
              }
              attachCustomWheelEventHandler(e) {
                this._customWheelEventHandler = e
              }
              registerLinkProvider(e) {
                return this._linkProviderService.registerLinkProvider(e)
              }
              registerCharacterJoiner(e) {
                if (!this._characterJoinerService)
                  throw new Error('Terminal must be opened first')
                const t = this._characterJoinerService.register(e)
                return this.refresh(0, this.rows - 1), t
              }
              deregisterCharacterJoiner(e) {
                if (!this._characterJoinerService)
                  throw new Error('Terminal must be opened first')
                this._characterJoinerService.deregister(e) &&
                  this.refresh(0, this.rows - 1)
              }
              get markers() {
                return this.buffer.markers
              }
              registerMarker(e) {
                return this.buffer.addMarker(
                  this.buffer.ybase + this.buffer.y + e
                )
              }
              registerDecoration(e) {
                return this._decorationService.registerDecoration(e)
              }
              hasSelection() {
                return (
                  !!this._selectionService &&
                  this._selectionService.hasSelection
                )
              }
              select(e, t, n) {
                this._selectionService.setSelection(e, t, n)
              }
              getSelection() {
                return this._selectionService
                  ? this._selectionService.selectionText
                  : ''
              }
              getSelectionPosition() {
                if (
                  this._selectionService &&
                  this._selectionService.hasSelection
                )
                  return {
                    start: {
                      x: this._selectionService.selectionStart[0],
                      y: this._selectionService.selectionStart[1]
                    },
                    end: {
                      x: this._selectionService.selectionEnd[0],
                      y: this._selectionService.selectionEnd[1]
                    }
                  }
              }
              clearSelection() {
                this._selectionService?.clearSelection()
              }
              selectAll() {
                this._selectionService?.selectAll()
              }
              selectLines(e, t) {
                this._selectionService?.selectLines(e, t)
              }
              _keyDown(e) {
                if (
                  ((this._keyDownHandled = !1),
                  (this._keyDownSeen = !0),
                  this._customKeyEventHandler &&
                    !1 === this._customKeyEventHandler(e))
                )
                  return !1
                const t =
                  this.browser.isMac && this.options.macOptionIsMeta && e.altKey
                if (!t && !this._compositionHelper.keydown(e))
                  return (
                    this.options.scrollOnUserInput &&
                      this.buffer.ybase !== this.buffer.ydisp &&
                      this.scrollToBottom(),
                    !1
                  )
                t ||
                  ('Dead' !== e.key && 'AltGraph' !== e.key) ||
                  (this._unprocessedDeadKey = !0)
                const n = (0, T.evaluateKeyboardEvent)(
                  e,
                  this.coreService.decPrivateModes.applicationCursorKeys,
                  this.browser.isMac,
                  this.options.macOptionIsMeta
                )
                if ((this.updateCursorStyle(e), 3 === n.type || 2 === n.type)) {
                  const t = this.rows - 1
                  return (
                    this.scrollLines(2 === n.type ? -t : t), this.cancel(e, !0)
                  )
                }
                return (
                  1 === n.type && this.selectAll(),
                  !!this._isThirdLevelShift(this.browser, e) ||
                    (n.cancel && this.cancel(e, !0),
                    !n.key ||
                      !!(
                        e.key &&
                        !e.ctrlKey &&
                        !e.altKey &&
                        !e.metaKey &&
                        1 === e.key.length &&
                        e.key.charCodeAt(0) >= 65 &&
                        e.key.charCodeAt(0) <= 90
                      ) ||
                      (this._unprocessedDeadKey
                        ? ((this._unprocessedDeadKey = !1), !0)
                        : ((n.key !== I.C0.ETX && n.key !== I.C0.CR) ||
                            (this.textarea.value = ''),
                          this._onKey.fire({ key: n.key, domEvent: e }),
                          this._showCursor(),
                          this.coreService.triggerDataEvent(n.key, !0),
                          !this.optionsService.rawOptions.screenReaderMode ||
                          e.altKey ||
                          e.ctrlKey
                            ? this.cancel(e, !0)
                            : void (this._keyDownHandled = !0))))
                )
              }
              _isThirdLevelShift(e, t) {
                const n =
                  (e.isMac &&
                    !this.options.macOptionIsMeta &&
                    t.altKey &&
                    !t.ctrlKey &&
                    !t.metaKey) ||
                  (e.isWindows && t.altKey && t.ctrlKey && !t.metaKey) ||
                  (e.isWindows && t.getModifierState('AltGraph'))
                return 'keypress' === t.type
                  ? n
                  : n && (!t.keyCode || t.keyCode > 47)
              }
              _keyUp(e) {
                var t
                ;(this._keyDownSeen = !1),
                  (this._customKeyEventHandler &&
                    !1 === this._customKeyEventHandler(e)) ||
                    (16 === (t = e).keyCode ||
                      17 === t.keyCode ||
                      18 === t.keyCode ||
                      this.focus(),
                    this.updateCursorStyle(e),
                    (this._keyPressHandled = !1))
              }
              _keyPress(e) {
                let t
                if (((this._keyPressHandled = !1), this._keyDownHandled))
                  return !1
                if (
                  this._customKeyEventHandler &&
                  !1 === this._customKeyEventHandler(e)
                )
                  return !1
                if ((this.cancel(e), e.charCode)) t = e.charCode
                else if (null === e.which || void 0 === e.which) t = e.keyCode
                else {
                  if (0 === e.which || 0 === e.charCode) return !1
                  t = e.which
                }
                return !(
                  !t ||
                  ((e.altKey || e.ctrlKey || e.metaKey) &&
                    !this._isThirdLevelShift(this.browser, e)) ||
                  ((t = String.fromCharCode(t)),
                  this._onKey.fire({ key: t, domEvent: e }),
                  this._showCursor(),
                  this.coreService.triggerDataEvent(t, !0),
                  (this._keyPressHandled = !0),
                  (this._unprocessedDeadKey = !1),
                  0)
                )
              }
              _inputEvent(e) {
                if (
                  e.data &&
                  'insertText' === e.inputType &&
                  (!e.composed || !this._keyDownSeen) &&
                  !this.optionsService.rawOptions.screenReaderMode
                ) {
                  if (this._keyPressHandled) return !1
                  this._unprocessedDeadKey = !1
                  const t = e.data
                  return (
                    this.coreService.triggerDataEvent(t, !0), this.cancel(e), !0
                  )
                }
                return !1
              }
              resize(e, t) {
                e !== this.cols || t !== this.rows
                  ? super.resize(e, t)
                  : this._charSizeService &&
                    !this._charSizeService.hasValidSize &&
                    this._charSizeService.measure()
              }
              _afterResize(e, t) {
                this._charSizeService?.measure(),
                  this.viewport?.syncScrollArea(!0)
              }
              clear() {
                if (0 !== this.buffer.ybase || 0 !== this.buffer.y) {
                  this.buffer.clearAllMarkers(),
                    this.buffer.lines.set(
                      0,
                      this.buffer.lines.get(this.buffer.ybase + this.buffer.y)
                    ),
                    (this.buffer.lines.length = 1),
                    (this.buffer.ydisp = 0),
                    (this.buffer.ybase = 0),
                    (this.buffer.y = 0)
                  for (let e = 1; e < this.rows; e++)
                    this.buffer.lines.push(
                      this.buffer.getBlankLine(E.DEFAULT_ATTR_DATA)
                    )
                  this._onScroll.fire({
                    position: this.buffer.ydisp,
                    source: 0
                  }),
                    this.viewport?.reset(),
                    this.refresh(0, this.rows - 1)
                }
              }
              reset() {
                ;(this.options.rows = this.rows),
                  (this.options.cols = this.cols)
                const e = this._customKeyEventHandler
                this._setup(),
                  super.reset(),
                  this._selectionService?.reset(),
                  this._decorationService.reset(),
                  this.viewport?.reset(),
                  (this._customKeyEventHandler = e),
                  this.refresh(0, this.rows - 1)
              }
              clearTextureAtlas() {
                this._renderService?.clearTextureAtlas()
              }
              _reportFocus() {
                this.element?.classList.contains('focus')
                  ? this.coreService.triggerDataEvent(I.C0.ESC + '[I')
                  : this.coreService.triggerDataEvent(I.C0.ESC + '[O')
              }
              _reportWindowsOptions(e) {
                if (this._renderService)
                  switch (e) {
                    case O.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                      const e =
                          this._renderService.dimensions.css.canvas.width.toFixed(
                            0
                          ),
                        t =
                          this._renderService.dimensions.css.canvas.height.toFixed(
                            0
                          )
                      this.coreService.triggerDataEvent(
                        `${I.C0.ESC}[4;${t};${e}t`
                      )
                      break
                    case O.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                      const n =
                          this._renderService.dimensions.css.cell.width.toFixed(
                            0
                          ),
                        o =
                          this._renderService.dimensions.css.cell.height.toFixed(
                            0
                          )
                      this.coreService.triggerDataEvent(
                        `${I.C0.ESC}[6;${o};${n}t`
                      )
                  }
              }
              cancel(e, t) {
                if (this.options.cancelEvents || t)
                  return e.preventDefault(), e.stopPropagation(), !1
              }
            }
            t.Terminal = D
          },
          9924: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.TimeBasedDebouncer = void 0),
              (t.TimeBasedDebouncer = class {
                constructor(e, t = 1e3) {
                  ;(this._renderCallback = e),
                    (this._debounceThresholdMS = t),
                    (this._lastRefreshMs = 0),
                    (this._additionalRefreshRequested = !1)
                }
                dispose() {
                  this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID)
                }
                refresh(e, t, n) {
                  ;(this._rowCount = n),
                    (e = void 0 !== e ? e : 0),
                    (t = void 0 !== t ? t : this._rowCount - 1),
                    (this._rowStart =
                      void 0 !== this._rowStart
                        ? Math.min(this._rowStart, e)
                        : e),
                    (this._rowEnd =
                      void 0 !== this._rowEnd ? Math.max(this._rowEnd, t) : t)
                  const o = Date.now()
                  if (o - this._lastRefreshMs >= this._debounceThresholdMS)
                    (this._lastRefreshMs = o), this._innerRefresh()
                  else if (!this._additionalRefreshRequested) {
                    const e = o - this._lastRefreshMs,
                      t = this._debounceThresholdMS - e
                    ;(this._additionalRefreshRequested = !0),
                      (this._refreshTimeoutID = window.setTimeout(() => {
                        ;(this._lastRefreshMs = Date.now()),
                          this._innerRefresh(),
                          (this._additionalRefreshRequested = !1),
                          (this._refreshTimeoutID = void 0)
                      }, t))
                  }
                }
                _innerRefresh() {
                  if (
                    void 0 === this._rowStart ||
                    void 0 === this._rowEnd ||
                    void 0 === this._rowCount
                  )
                    return
                  const e = Math.max(this._rowStart, 0),
                    t = Math.min(this._rowEnd, this._rowCount - 1)
                  ;(this._rowStart = void 0),
                    (this._rowEnd = void 0),
                    this._renderCallback(e, t)
                }
              })
          },
          1680: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.Viewport = void 0)
            const r = n(3656),
              a = n(4725),
              s = n(8460),
              l = n(844),
              c = n(2585)
            let d = (t.Viewport = class extends l.Disposable {
              constructor(e, t, n, o, i, a, l, c) {
                super(),
                  (this._viewportElement = e),
                  (this._scrollArea = t),
                  (this._bufferService = n),
                  (this._optionsService = o),
                  (this._charSizeService = i),
                  (this._renderService = a),
                  (this._coreBrowserService = l),
                  (this.scrollBarWidth = 0),
                  (this._currentRowHeight = 0),
                  (this._currentDeviceCellHeight = 0),
                  (this._lastRecordedBufferLength = 0),
                  (this._lastRecordedViewportHeight = 0),
                  (this._lastRecordedBufferHeight = 0),
                  (this._lastTouchY = 0),
                  (this._lastScrollTop = 0),
                  (this._wheelPartialScroll = 0),
                  (this._refreshAnimationFrame = null),
                  (this._ignoreNextScrollEvent = !1),
                  (this._smoothScrollState = {
                    startTime: 0,
                    origin: -1,
                    target: -1
                  }),
                  (this._onRequestScrollLines = this.register(
                    new s.EventEmitter()
                  )),
                  (this.onRequestScrollLines =
                    this._onRequestScrollLines.event),
                  (this.scrollBarWidth =
                    this._viewportElement.offsetWidth -
                      this._scrollArea.offsetWidth || 15),
                  this.register(
                    (0, r.addDisposableDomListener)(
                      this._viewportElement,
                      'scroll',
                      this._handleScroll.bind(this)
                    )
                  ),
                  (this._activeBuffer = this._bufferService.buffer),
                  this.register(
                    this._bufferService.buffers.onBufferActivate(
                      (e) => (this._activeBuffer = e.activeBuffer)
                    )
                  ),
                  (this._renderDimensions = this._renderService.dimensions),
                  this.register(
                    this._renderService.onDimensionsChange(
                      (e) => (this._renderDimensions = e)
                    )
                  ),
                  this._handleThemeChange(c.colors),
                  this.register(
                    c.onChangeColors((e) => this._handleThemeChange(e))
                  ),
                  this.register(
                    this._optionsService.onSpecificOptionChange(
                      'scrollback',
                      () => this.syncScrollArea()
                    )
                  ),
                  setTimeout(() => this.syncScrollArea())
              }
              _handleThemeChange(e) {
                this._viewportElement.style.backgroundColor = e.background.css
              }
              reset() {
                ;(this._currentRowHeight = 0),
                  (this._currentDeviceCellHeight = 0),
                  (this._lastRecordedBufferLength = 0),
                  (this._lastRecordedViewportHeight = 0),
                  (this._lastRecordedBufferHeight = 0),
                  (this._lastTouchY = 0),
                  (this._lastScrollTop = 0),
                  this._coreBrowserService.window.requestAnimationFrame(() =>
                    this.syncScrollArea()
                  )
              }
              _refresh(e) {
                if (e)
                  return (
                    this._innerRefresh(),
                    void (
                      null !== this._refreshAnimationFrame &&
                      this._coreBrowserService.window.cancelAnimationFrame(
                        this._refreshAnimationFrame
                      )
                    )
                  )
                null === this._refreshAnimationFrame &&
                  (this._refreshAnimationFrame =
                    this._coreBrowserService.window.requestAnimationFrame(() =>
                      this._innerRefresh()
                    ))
              }
              _innerRefresh() {
                if (this._charSizeService.height > 0) {
                  ;(this._currentRowHeight =
                    this._renderDimensions.device.cell.height /
                    this._coreBrowserService.dpr),
                    (this._currentDeviceCellHeight =
                      this._renderDimensions.device.cell.height),
                    (this._lastRecordedViewportHeight =
                      this._viewportElement.offsetHeight)
                  const e =
                    Math.round(
                      this._currentRowHeight * this._lastRecordedBufferLength
                    ) +
                    (this._lastRecordedViewportHeight -
                      this._renderDimensions.css.canvas.height)
                  this._lastRecordedBufferHeight !== e &&
                    ((this._lastRecordedBufferHeight = e),
                    (this._scrollArea.style.height =
                      this._lastRecordedBufferHeight + 'px'))
                }
                const e =
                  this._bufferService.buffer.ydisp * this._currentRowHeight
                this._viewportElement.scrollTop !== e &&
                  ((this._ignoreNextScrollEvent = !0),
                  (this._viewportElement.scrollTop = e)),
                  (this._refreshAnimationFrame = null)
              }
              syncScrollArea(e = !1) {
                if (
                  this._lastRecordedBufferLength !==
                  this._bufferService.buffer.lines.length
                )
                  return (
                    (this._lastRecordedBufferLength =
                      this._bufferService.buffer.lines.length),
                    void this._refresh(e)
                  )
                ;(this._lastRecordedViewportHeight ===
                  this._renderService.dimensions.css.canvas.height &&
                  this._lastScrollTop ===
                    this._activeBuffer.ydisp * this._currentRowHeight &&
                  this._renderDimensions.device.cell.height ===
                    this._currentDeviceCellHeight) ||
                  this._refresh(e)
              }
              _handleScroll(e) {
                if (
                  ((this._lastScrollTop = this._viewportElement.scrollTop),
                  !this._viewportElement.offsetParent)
                )
                  return
                if (this._ignoreNextScrollEvent)
                  return (
                    (this._ignoreNextScrollEvent = !1),
                    void this._onRequestScrollLines.fire({
                      amount: 0,
                      suppressScrollEvent: !0
                    })
                  )
                const t =
                  Math.round(this._lastScrollTop / this._currentRowHeight) -
                  this._bufferService.buffer.ydisp
                this._onRequestScrollLines.fire({
                  amount: t,
                  suppressScrollEvent: !0
                })
              }
              _smoothScroll() {
                if (
                  this._isDisposed ||
                  -1 === this._smoothScrollState.origin ||
                  -1 === this._smoothScrollState.target
                )
                  return
                const e = this._smoothScrollPercent()
                ;(this._viewportElement.scrollTop =
                  this._smoothScrollState.origin +
                  Math.round(
                    e *
                      (this._smoothScrollState.target -
                        this._smoothScrollState.origin)
                  )),
                  e < 1
                    ? this._coreBrowserService.window.requestAnimationFrame(
                        () => this._smoothScroll()
                      )
                    : this._clearSmoothScrollState()
              }
              _smoothScrollPercent() {
                return this._optionsService.rawOptions.smoothScrollDuration &&
                  this._smoothScrollState.startTime
                  ? Math.max(
                      Math.min(
                        (Date.now() - this._smoothScrollState.startTime) /
                          this._optionsService.rawOptions.smoothScrollDuration,
                        1
                      ),
                      0
                    )
                  : 1
              }
              _clearSmoothScrollState() {
                ;(this._smoothScrollState.startTime = 0),
                  (this._smoothScrollState.origin = -1),
                  (this._smoothScrollState.target = -1)
              }
              _bubbleScroll(e, t) {
                const n =
                  this._viewportElement.scrollTop +
                  this._lastRecordedViewportHeight
                return (
                  !(
                    (t < 0 && 0 !== this._viewportElement.scrollTop) ||
                    (t > 0 && n < this._lastRecordedBufferHeight)
                  ) || (e.cancelable && e.preventDefault(), !1)
                )
              }
              handleWheel(e) {
                const t = this._getPixelsScrolled(e)
                return (
                  0 !== t &&
                  (this._optionsService.rawOptions.smoothScrollDuration
                    ? ((this._smoothScrollState.startTime = Date.now()),
                      this._smoothScrollPercent() < 1
                        ? ((this._smoothScrollState.origin =
                            this._viewportElement.scrollTop),
                          -1 === this._smoothScrollState.target
                            ? (this._smoothScrollState.target =
                                this._viewportElement.scrollTop + t)
                            : (this._smoothScrollState.target += t),
                          (this._smoothScrollState.target = Math.max(
                            Math.min(
                              this._smoothScrollState.target,
                              this._viewportElement.scrollHeight
                            ),
                            0
                          )),
                          this._smoothScroll())
                        : this._clearSmoothScrollState())
                    : (this._viewportElement.scrollTop += t),
                  this._bubbleScroll(e, t))
                )
              }
              scrollLines(e) {
                if (0 !== e)
                  if (this._optionsService.rawOptions.smoothScrollDuration) {
                    const t = e * this._currentRowHeight
                    ;(this._smoothScrollState.startTime = Date.now()),
                      this._smoothScrollPercent() < 1
                        ? ((this._smoothScrollState.origin =
                            this._viewportElement.scrollTop),
                          (this._smoothScrollState.target =
                            this._smoothScrollState.origin + t),
                          (this._smoothScrollState.target = Math.max(
                            Math.min(
                              this._smoothScrollState.target,
                              this._viewportElement.scrollHeight
                            ),
                            0
                          )),
                          this._smoothScroll())
                        : this._clearSmoothScrollState()
                  } else
                    this._onRequestScrollLines.fire({
                      amount: e,
                      suppressScrollEvent: !1
                    })
              }
              _getPixelsScrolled(e) {
                if (0 === e.deltaY || e.shiftKey) return 0
                let t = this._applyScrollModifier(e.deltaY, e)
                return (
                  e.deltaMode === WheelEvent.DOM_DELTA_LINE
                    ? (t *= this._currentRowHeight)
                    : e.deltaMode === WheelEvent.DOM_DELTA_PAGE &&
                      (t *= this._currentRowHeight * this._bufferService.rows),
                  t
                )
              }
              getBufferElements(e, t) {
                let n,
                  o = ''
                const i = [],
                  r = t ?? this._bufferService.buffer.lines.length,
                  a = this._bufferService.buffer.lines
                for (let s = e; s < r; s++) {
                  const e = a.get(s)
                  if (!e) continue
                  const t = a.get(s + 1)?.isWrapped
                  if (
                    ((o += e.translateToString(!t)), !t || s === a.length - 1)
                  ) {
                    const e = document.createElement('div')
                    ;(e.textContent = o),
                      i.push(e),
                      o.length > 0 && (n = e),
                      (o = '')
                  }
                }
                return { bufferElements: i, cursorElement: n }
              }
              getLinesScrolled(e) {
                if (0 === e.deltaY || e.shiftKey) return 0
                let t = this._applyScrollModifier(e.deltaY, e)
                return (
                  e.deltaMode === WheelEvent.DOM_DELTA_PIXEL
                    ? ((t /= this._currentRowHeight + 0),
                      (this._wheelPartialScroll += t),
                      (t =
                        Math.floor(Math.abs(this._wheelPartialScroll)) *
                        (this._wheelPartialScroll > 0 ? 1 : -1)),
                      (this._wheelPartialScroll %= 1))
                    : e.deltaMode === WheelEvent.DOM_DELTA_PAGE &&
                      (t *= this._bufferService.rows),
                  t
                )
              }
              _applyScrollModifier(e, t) {
                const n = this._optionsService.rawOptions.fastScrollModifier
                return ('alt' === n && t.altKey) ||
                  ('ctrl' === n && t.ctrlKey) ||
                  ('shift' === n && t.shiftKey)
                  ? e *
                      this._optionsService.rawOptions.fastScrollSensitivity *
                      this._optionsService.rawOptions.scrollSensitivity
                  : e * this._optionsService.rawOptions.scrollSensitivity
              }
              handleTouchStart(e) {
                this._lastTouchY = e.touches[0].pageY
              }
              handleTouchMove(e) {
                const t = this._lastTouchY - e.touches[0].pageY
                return (
                  (this._lastTouchY = e.touches[0].pageY),
                  0 !== t &&
                    ((this._viewportElement.scrollTop += t),
                    this._bubbleScroll(e, t))
                )
              }
            })
            t.Viewport = d = o(
              [
                i(2, c.IBufferService),
                i(3, c.IOptionsService),
                i(4, a.ICharSizeService),
                i(5, a.IRenderService),
                i(6, a.ICoreBrowserService),
                i(7, a.IThemeService)
              ],
              d
            )
          },
          3107: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.BufferDecorationRenderer = void 0)
            const r = n(4725),
              a = n(844),
              s = n(2585)
            let l = (t.BufferDecorationRenderer = class extends a.Disposable {
              constructor(e, t, n, o, i) {
                super(),
                  (this._screenElement = e),
                  (this._bufferService = t),
                  (this._coreBrowserService = n),
                  (this._decorationService = o),
                  (this._renderService = i),
                  (this._decorationElements = new Map()),
                  (this._altBufferIsActive = !1),
                  (this._dimensionsChanged = !1),
                  (this._container = document.createElement('div')),
                  this._container.classList.add('xterm-decoration-container'),
                  this._screenElement.appendChild(this._container),
                  this.register(
                    this._renderService.onRenderedViewportChange(() =>
                      this._doRefreshDecorations()
                    )
                  ),
                  this.register(
                    this._renderService.onDimensionsChange(() => {
                      ;(this._dimensionsChanged = !0), this._queueRefresh()
                    })
                  ),
                  this.register(
                    this._coreBrowserService.onDprChange(() =>
                      this._queueRefresh()
                    )
                  ),
                  this.register(
                    this._bufferService.buffers.onBufferActivate(() => {
                      this._altBufferIsActive =
                        this._bufferService.buffer ===
                        this._bufferService.buffers.alt
                    })
                  ),
                  this.register(
                    this._decorationService.onDecorationRegistered(() =>
                      this._queueRefresh()
                    )
                  ),
                  this.register(
                    this._decorationService.onDecorationRemoved((e) =>
                      this._removeDecoration(e)
                    )
                  ),
                  this.register(
                    (0, a.toDisposable)(() => {
                      this._container.remove(), this._decorationElements.clear()
                    })
                  )
              }
              _queueRefresh() {
                void 0 === this._animationFrame &&
                  (this._animationFrame =
                    this._renderService.addRefreshCallback(() => {
                      this._doRefreshDecorations(),
                        (this._animationFrame = void 0)
                    }))
              }
              _doRefreshDecorations() {
                for (const e of this._decorationService.decorations)
                  this._renderDecoration(e)
                this._dimensionsChanged = !1
              }
              _renderDecoration(e) {
                this._refreshStyle(e),
                  this._dimensionsChanged && this._refreshXPosition(e)
              }
              _createElement(e) {
                const t =
                  this._coreBrowserService.mainDocument.createElement('div')
                t.classList.add('xterm-decoration'),
                  t.classList.toggle(
                    'xterm-decoration-top-layer',
                    'top' === e?.options?.layer
                  ),
                  (t.style.width = `${Math.round((e.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`),
                  (t.style.height =
                    (e.options.height || 1) *
                      this._renderService.dimensions.css.cell.height +
                    'px'),
                  (t.style.top =
                    (e.marker.line - this._bufferService.buffers.active.ydisp) *
                      this._renderService.dimensions.css.cell.height +
                    'px'),
                  (t.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`)
                const n = e.options.x ?? 0
                return (
                  n &&
                    n > this._bufferService.cols &&
                    (t.style.display = 'none'),
                  this._refreshXPosition(e, t),
                  t
                )
              }
              _refreshStyle(e) {
                const t =
                  e.marker.line - this._bufferService.buffers.active.ydisp
                if (t < 0 || t >= this._bufferService.rows)
                  e.element &&
                    ((e.element.style.display = 'none'),
                    e.onRenderEmitter.fire(e.element))
                else {
                  let n = this._decorationElements.get(e)
                  n ||
                    ((n = this._createElement(e)),
                    (e.element = n),
                    this._decorationElements.set(e, n),
                    this._container.appendChild(n),
                    e.onDispose(() => {
                      this._decorationElements.delete(e), n.remove()
                    })),
                    (n.style.top =
                      t * this._renderService.dimensions.css.cell.height +
                      'px'),
                    (n.style.display = this._altBufferIsActive
                      ? 'none'
                      : 'block'),
                    e.onRenderEmitter.fire(n)
                }
              }
              _refreshXPosition(e, t = e.element) {
                if (!t) return
                const n = e.options.x ?? 0
                'right' === (e.options.anchor || 'left')
                  ? (t.style.right = n
                      ? n * this._renderService.dimensions.css.cell.width + 'px'
                      : '')
                  : (t.style.left = n
                      ? n * this._renderService.dimensions.css.cell.width + 'px'
                      : '')
              }
              _removeDecoration(e) {
                this._decorationElements.get(e)?.remove(),
                  this._decorationElements.delete(e),
                  e.dispose()
              }
            })
            t.BufferDecorationRenderer = l = o(
              [
                i(1, s.IBufferService),
                i(2, r.ICoreBrowserService),
                i(3, s.IDecorationService),
                i(4, r.IRenderService)
              ],
              l
            )
          },
          5871: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ColorZoneStore = void 0),
              (t.ColorZoneStore = class {
                constructor() {
                  ;(this._zones = []),
                    (this._zonePool = []),
                    (this._zonePoolIndex = 0),
                    (this._linePadding = {
                      full: 0,
                      left: 0,
                      center: 0,
                      right: 0
                    })
                }
                get zones() {
                  return (
                    (this._zonePool.length = Math.min(
                      this._zonePool.length,
                      this._zones.length
                    )),
                    this._zones
                  )
                }
                clear() {
                  ;(this._zones.length = 0), (this._zonePoolIndex = 0)
                }
                addDecoration(e) {
                  if (e.options.overviewRulerOptions) {
                    for (const t of this._zones)
                      if (
                        t.color === e.options.overviewRulerOptions.color &&
                        t.position === e.options.overviewRulerOptions.position
                      ) {
                        if (this._lineIntersectsZone(t, e.marker.line)) return
                        if (
                          this._lineAdjacentToZone(
                            t,
                            e.marker.line,
                            e.options.overviewRulerOptions.position
                          )
                        )
                          return void this._addLineToZone(t, e.marker.line)
                      }
                    if (this._zonePoolIndex < this._zonePool.length)
                      return (
                        (this._zonePool[this._zonePoolIndex].color =
                          e.options.overviewRulerOptions.color),
                        (this._zonePool[this._zonePoolIndex].position =
                          e.options.overviewRulerOptions.position),
                        (this._zonePool[this._zonePoolIndex].startBufferLine =
                          e.marker.line),
                        (this._zonePool[this._zonePoolIndex].endBufferLine =
                          e.marker.line),
                        void this._zones.push(
                          this._zonePool[this._zonePoolIndex++]
                        )
                      )
                    this._zones.push({
                      color: e.options.overviewRulerOptions.color,
                      position: e.options.overviewRulerOptions.position,
                      startBufferLine: e.marker.line,
                      endBufferLine: e.marker.line
                    }),
                      this._zonePool.push(this._zones[this._zones.length - 1]),
                      this._zonePoolIndex++
                  }
                }
                setPadding(e) {
                  this._linePadding = e
                }
                _lineIntersectsZone(e, t) {
                  return t >= e.startBufferLine && t <= e.endBufferLine
                }
                _lineAdjacentToZone(e, t, n) {
                  return (
                    t >= e.startBufferLine - this._linePadding[n || 'full'] &&
                    t <= e.endBufferLine + this._linePadding[n || 'full']
                  )
                }
                _addLineToZone(e, t) {
                  ;(e.startBufferLine = Math.min(e.startBufferLine, t)),
                    (e.endBufferLine = Math.max(e.endBufferLine, t))
                }
              })
          },
          5744: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.OverviewRulerRenderer = void 0)
            const r = n(5871),
              a = n(4725),
              s = n(844),
              l = n(2585),
              c = { full: 0, left: 0, center: 0, right: 0 },
              d = { full: 0, left: 0, center: 0, right: 0 },
              u = { full: 0, left: 0, center: 0, right: 0 }
            let p = (t.OverviewRulerRenderer = class extends s.Disposable {
              get _width() {
                return this._optionsService.options.overviewRulerWidth || 0
              }
              constructor(e, t, n, o, i, a, l) {
                super(),
                  (this._viewportElement = e),
                  (this._screenElement = t),
                  (this._bufferService = n),
                  (this._decorationService = o),
                  (this._renderService = i),
                  (this._optionsService = a),
                  (this._coreBrowserService = l),
                  (this._colorZoneStore = new r.ColorZoneStore()),
                  (this._shouldUpdateDimensions = !0),
                  (this._shouldUpdateAnchor = !0),
                  (this._lastKnownBufferLength = 0),
                  (this._canvas =
                    this._coreBrowserService.mainDocument.createElement(
                      'canvas'
                    )),
                  this._canvas.classList.add('xterm-decoration-overview-ruler'),
                  this._refreshCanvasDimensions(),
                  this._viewportElement.parentElement?.insertBefore(
                    this._canvas,
                    this._viewportElement
                  )
                const c = this._canvas.getContext('2d')
                if (!c) throw new Error('Ctx cannot be null')
                ;(this._ctx = c),
                  this._registerDecorationListeners(),
                  this._registerBufferChangeListeners(),
                  this._registerDimensionChangeListeners(),
                  this.register(
                    (0, s.toDisposable)(() => {
                      this._canvas?.remove()
                    })
                  )
              }
              _registerDecorationListeners() {
                this.register(
                  this._decorationService.onDecorationRegistered(() =>
                    this._queueRefresh(void 0, !0)
                  )
                ),
                  this.register(
                    this._decorationService.onDecorationRemoved(() =>
                      this._queueRefresh(void 0, !0)
                    )
                  )
              }
              _registerBufferChangeListeners() {
                this.register(
                  this._renderService.onRenderedViewportChange(() =>
                    this._queueRefresh()
                  )
                ),
                  this.register(
                    this._bufferService.buffers.onBufferActivate(() => {
                      this._canvas.style.display =
                        this._bufferService.buffer ===
                        this._bufferService.buffers.alt
                          ? 'none'
                          : 'block'
                    })
                  ),
                  this.register(
                    this._bufferService.onScroll(() => {
                      this._lastKnownBufferLength !==
                        this._bufferService.buffers.normal.lines.length &&
                        (this._refreshDrawHeightConstants(),
                        this._refreshColorZonePadding())
                    })
                  )
              }
              _registerDimensionChangeListeners() {
                this.register(
                  this._renderService.onRender(() => {
                    ;(this._containerHeight &&
                      this._containerHeight ===
                        this._screenElement.clientHeight) ||
                      (this._queueRefresh(!0),
                      (this._containerHeight =
                        this._screenElement.clientHeight))
                  })
                ),
                  this.register(
                    this._optionsService.onSpecificOptionChange(
                      'overviewRulerWidth',
                      () => this._queueRefresh(!0)
                    )
                  ),
                  this.register(
                    this._coreBrowserService.onDprChange(() =>
                      this._queueRefresh(!0)
                    )
                  ),
                  this._queueRefresh(!0)
              }
              _refreshDrawConstants() {
                const e = Math.floor(this._canvas.width / 3),
                  t = Math.ceil(this._canvas.width / 3)
                ;(d.full = this._canvas.width),
                  (d.left = e),
                  (d.center = t),
                  (d.right = e),
                  this._refreshDrawHeightConstants(),
                  (u.full = 0),
                  (u.left = 0),
                  (u.center = d.left),
                  (u.right = d.left + d.center)
              }
              _refreshDrawHeightConstants() {
                c.full = Math.round(2 * this._coreBrowserService.dpr)
                const e =
                    this._canvas.height /
                    this._bufferService.buffer.lines.length,
                  t = Math.round(
                    Math.max(Math.min(e, 12), 6) * this._coreBrowserService.dpr
                  )
                ;(c.left = t), (c.center = t), (c.right = t)
              }
              _refreshColorZonePadding() {
                this._colorZoneStore.setPadding({
                  full: Math.floor(
                    (this._bufferService.buffers.active.lines.length /
                      (this._canvas.height - 1)) *
                      c.full
                  ),
                  left: Math.floor(
                    (this._bufferService.buffers.active.lines.length /
                      (this._canvas.height - 1)) *
                      c.left
                  ),
                  center: Math.floor(
                    (this._bufferService.buffers.active.lines.length /
                      (this._canvas.height - 1)) *
                      c.center
                  ),
                  right: Math.floor(
                    (this._bufferService.buffers.active.lines.length /
                      (this._canvas.height - 1)) *
                      c.right
                  )
                }),
                  (this._lastKnownBufferLength =
                    this._bufferService.buffers.normal.lines.length)
              }
              _refreshCanvasDimensions() {
                ;(this._canvas.style.width = `${this._width}px`),
                  (this._canvas.width = Math.round(
                    this._width * this._coreBrowserService.dpr
                  )),
                  (this._canvas.style.height = `${this._screenElement.clientHeight}px`),
                  (this._canvas.height = Math.round(
                    this._screenElement.clientHeight *
                      this._coreBrowserService.dpr
                  )),
                  this._refreshDrawConstants(),
                  this._refreshColorZonePadding()
              }
              _refreshDecorations() {
                this._shouldUpdateDimensions && this._refreshCanvasDimensions(),
                  this._ctx.clearRect(
                    0,
                    0,
                    this._canvas.width,
                    this._canvas.height
                  ),
                  this._colorZoneStore.clear()
                for (const t of this._decorationService.decorations)
                  this._colorZoneStore.addDecoration(t)
                this._ctx.lineWidth = 1
                const e = this._colorZoneStore.zones
                for (const t of e)
                  'full' !== t.position && this._renderColorZone(t)
                for (const t of e)
                  'full' === t.position && this._renderColorZone(t)
                ;(this._shouldUpdateDimensions = !1),
                  (this._shouldUpdateAnchor = !1)
              }
              _renderColorZone(e) {
                ;(this._ctx.fillStyle = e.color),
                  this._ctx.fillRect(
                    u[e.position || 'full'],
                    Math.round(
                      (this._canvas.height - 1) *
                        (e.startBufferLine /
                          this._bufferService.buffers.active.lines.length) -
                        c[e.position || 'full'] / 2
                    ),
                    d[e.position || 'full'],
                    Math.round(
                      (this._canvas.height - 1) *
                        ((e.endBufferLine - e.startBufferLine) /
                          this._bufferService.buffers.active.lines.length) +
                        c[e.position || 'full']
                    )
                  )
              }
              _queueRefresh(e, t) {
                ;(this._shouldUpdateDimensions =
                  e || this._shouldUpdateDimensions),
                  (this._shouldUpdateAnchor = t || this._shouldUpdateAnchor),
                  void 0 === this._animationFrame &&
                    (this._animationFrame =
                      this._coreBrowserService.window.requestAnimationFrame(
                        () => {
                          this._refreshDecorations(),
                            (this._animationFrame = void 0)
                        }
                      ))
              }
            })
            t.OverviewRulerRenderer = p = o(
              [
                i(2, l.IBufferService),
                i(3, l.IDecorationService),
                i(4, a.IRenderService),
                i(5, l.IOptionsService),
                i(6, a.ICoreBrowserService)
              ],
              p
            )
          },
          2950: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.CompositionHelper = void 0)
            const r = n(4725),
              a = n(2585),
              s = n(2584)
            let l = (t.CompositionHelper = class {
              get isComposing() {
                return this._isComposing
              }
              constructor(e, t, n, o, i, r) {
                ;(this._textarea = e),
                  (this._compositionView = t),
                  (this._bufferService = n),
                  (this._optionsService = o),
                  (this._coreService = i),
                  (this._renderService = r),
                  (this._isComposing = !1),
                  (this._isSendingComposition = !1),
                  (this._compositionPosition = { start: 0, end: 0 }),
                  (this._dataAlreadySent = '')
              }
              compositionstart() {
                ;(this._isComposing = !0),
                  (this._compositionPosition.start =
                    this._textarea.value.length),
                  (this._compositionView.textContent = ''),
                  (this._dataAlreadySent = ''),
                  this._compositionView.classList.add('active')
              }
              compositionupdate(e) {
                ;(this._compositionView.textContent = e.data),
                  this.updateCompositionElements(),
                  setTimeout(() => {
                    this._compositionPosition.end = this._textarea.value.length
                  }, 0)
              }
              compositionend() {
                this._finalizeComposition(!0)
              }
              keydown(e) {
                if (this._isComposing || this._isSendingComposition) {
                  if (229 === e.keyCode) return !1
                  if (16 === e.keyCode || 17 === e.keyCode || 18 === e.keyCode)
                    return !1
                  this._finalizeComposition(!1)
                }
                return (
                  229 !== e.keyCode || (this._handleAnyTextareaChanges(), !1)
                )
              }
              _finalizeComposition(e) {
                if (
                  (this._compositionView.classList.remove('active'),
                  (this._isComposing = !1),
                  e)
                ) {
                  const e = {
                    start: this._compositionPosition.start,
                    end: this._compositionPosition.end
                  }
                  ;(this._isSendingComposition = !0),
                    setTimeout(() => {
                      if (this._isSendingComposition) {
                        let t
                        ;(this._isSendingComposition = !1),
                          (e.start += this._dataAlreadySent.length),
                          (t = this._isComposing
                            ? this._textarea.value.substring(e.start, e.end)
                            : this._textarea.value.substring(e.start)),
                          t.length > 0 &&
                            this._coreService.triggerDataEvent(t, !0)
                      }
                    }, 0)
                } else {
                  this._isSendingComposition = !1
                  const e = this._textarea.value.substring(
                    this._compositionPosition.start,
                    this._compositionPosition.end
                  )
                  this._coreService.triggerDataEvent(e, !0)
                }
              }
              _handleAnyTextareaChanges() {
                const e = this._textarea.value
                setTimeout(() => {
                  if (!this._isComposing) {
                    const t = this._textarea.value,
                      n = t.replace(e, '')
                    ;(this._dataAlreadySent = n),
                      t.length > e.length
                        ? this._coreService.triggerDataEvent(n, !0)
                        : t.length < e.length
                          ? this._coreService.triggerDataEvent(
                              `${s.C0.DEL}`,
                              !0
                            )
                          : t.length === e.length &&
                            t !== e &&
                            this._coreService.triggerDataEvent(t, !0)
                  }
                }, 0)
              }
              updateCompositionElements(e) {
                if (this._isComposing) {
                  if (this._bufferService.buffer.isCursorInViewport) {
                    const e = Math.min(
                        this._bufferService.buffer.x,
                        this._bufferService.cols - 1
                      ),
                      t = this._renderService.dimensions.css.cell.height,
                      n =
                        this._bufferService.buffer.y *
                        this._renderService.dimensions.css.cell.height,
                      o = e * this._renderService.dimensions.css.cell.width
                    ;(this._compositionView.style.left = o + 'px'),
                      (this._compositionView.style.top = n + 'px'),
                      (this._compositionView.style.height = t + 'px'),
                      (this._compositionView.style.lineHeight = t + 'px'),
                      (this._compositionView.style.fontFamily =
                        this._optionsService.rawOptions.fontFamily),
                      (this._compositionView.style.fontSize =
                        this._optionsService.rawOptions.fontSize + 'px')
                    const i = this._compositionView.getBoundingClientRect()
                    ;(this._textarea.style.left = o + 'px'),
                      (this._textarea.style.top = n + 'px'),
                      (this._textarea.style.width =
                        Math.max(i.width, 1) + 'px'),
                      (this._textarea.style.height =
                        Math.max(i.height, 1) + 'px'),
                      (this._textarea.style.lineHeight = i.height + 'px')
                  }
                  e || setTimeout(() => this.updateCompositionElements(!0), 0)
                }
              }
            })
            t.CompositionHelper = l = o(
              [
                i(2, a.IBufferService),
                i(3, a.IOptionsService),
                i(4, a.ICoreService),
                i(5, r.IRenderService)
              ],
              l
            )
          },
          9806: (e, t) => {
            function n(e, t, n) {
              const o = n.getBoundingClientRect(),
                i = e.getComputedStyle(n),
                r = parseInt(i.getPropertyValue('padding-left')),
                a = parseInt(i.getPropertyValue('padding-top'))
              return [t.clientX - o.left - r, t.clientY - o.top - a]
            }
            __name(n, 'i'),
              Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.getCoords = t.getCoordsRelativeToElement = void 0),
              (t.getCoordsRelativeToElement = n),
              (t.getCoords = function (e, t, o, i, r, a, s, l, c) {
                if (!a) return
                const d = n(e, t, o)
                return d
                  ? ((d[0] = Math.ceil((d[0] + (c ? s / 2 : 0)) / s)),
                    (d[1] = Math.ceil(d[1] / l)),
                    (d[0] = Math.min(Math.max(d[0], 1), i + (c ? 1 : 0))),
                    (d[1] = Math.min(Math.max(d[1], 1), r)),
                    d)
                  : void 0
              })
          },
          9504: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.moveToCellSequence = void 0)
            const o = n(2584)
            function i(e, t, n, o) {
              const i = e - r(e, n),
                s = t - r(t, n)
              return c(
                Math.abs(i - s) -
                  (function (e, t, n) {
                    let o = 0
                    const i = e - r(e, n),
                      s = t - r(t, n)
                    for (let r = 0; r < Math.abs(i - s); r++) {
                      const s = 'A' === a(e, t) ? -1 : 1,
                        l = n.buffer.lines.get(i + s * r)
                      l?.isWrapped && o++
                    }
                    return o
                  })(e, t, n),
                l(a(e, t), o)
              )
            }
            function r(e, t) {
              let n = 0,
                o = t.buffer.lines.get(e),
                i = o?.isWrapped
              for (; i && e >= 0 && e < t.rows; )
                n++, (o = t.buffer.lines.get(--e)), (i = o?.isWrapped)
              return n
            }
            function a(e, t) {
              return e > t ? 'A' : 'B'
            }
            function s(e, t, n, o, i, r) {
              let a = e,
                s = t,
                l = ''
              for (; a !== n || s !== o; )
                (a += i ? 1 : -1),
                  i && a > r.cols - 1
                    ? ((l += r.buffer.translateBufferLineToString(s, !1, e, a)),
                      (a = 0),
                      (e = 0),
                      s++)
                    : !i &&
                      a < 0 &&
                      ((l += r.buffer.translateBufferLineToString(
                        s,
                        !1,
                        0,
                        e + 1
                      )),
                      (a = r.cols - 1),
                      (e = a),
                      s--)
              return l + r.buffer.translateBufferLineToString(s, !1, e, a)
            }
            function l(e, t) {
              const n = t ? 'O' : '['
              return o.C0.ESC + n + e
            }
            function c(e, t) {
              e = Math.floor(e)
              let n = ''
              for (let o = 0; o < e; o++) n += t
              return n
            }
            __name(i, 'r'),
              __name(r, 'n'),
              __name(a, 'o'),
              __name(s, 'a'),
              __name(l, 'h'),
              __name(c, 'c'),
              (t.moveToCellSequence = function (e, t, n, o) {
                const a = n.buffer.x,
                  d = n.buffer.y
                if (!n.buffer.hasScrollback)
                  return (
                    (u = a),
                    (0 === i((p = d), t, (h = n), (m = o)).length
                      ? ''
                      : c(s(u, p, u, p - r(p, h), !1, h).length, l('D', m))) +
                      i(d, t, n, o) +
                      (function (e, t, n, o, a, d) {
                        let u
                        u = i(t, o, a, d).length > 0 ? o - r(o, a) : t
                        const p = o,
                          h = (function (e, t, n, o, a, s) {
                            let l
                            return (
                              (l = i(n, o, a, s).length > 0 ? o - r(o, a) : t),
                              (e < n && l <= o) || (e >= n && l < o) ? 'C' : 'D'
                            )
                          })(e, t, n, o, a, d)
                        return c(s(e, u, n, p, 'C' === h, a).length, l(h, d))
                      })(a, d, e, t, n, o)
                  )
                var u, p, h, m
                let f
                if (d === t)
                  return (f = a > e ? 'D' : 'C'), c(Math.abs(a - e), l(f, o))
                f = d > t ? 'D' : 'C'
                const _ = Math.abs(d - t)
                return c(
                  (function (e, t) {
                    return t.cols - e
                  })(d > t ? e : a, n) +
                    (_ - 1) * n.cols +
                    1 +
                    ((d > t ? a : e) - 1),
                  l(f, o)
                )
              })
          },
          1296: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.DomRenderer = void 0)
            const r = n(3787),
              a = n(2550),
              s = n(2223),
              l = n(6171),
              c = n(6052),
              d = n(4725),
              u = n(8055),
              p = n(8460),
              h = n(844),
              m = n(2585),
              f = 'xterm-dom-renderer-owner-',
              _ = 'xterm-rows',
              g = 'xterm-fg-',
              v = 'xterm-bg-',
              y = 'xterm-focus',
              b = 'xterm-selection'
            let S = 1,
              C = (t.DomRenderer = class extends h.Disposable {
                constructor(e, t, n, o, i, s, d, u, m, g, v, y, C) {
                  super(),
                    (this._terminal = e),
                    (this._document = t),
                    (this._element = n),
                    (this._screenElement = o),
                    (this._viewportElement = i),
                    (this._helperContainer = s),
                    (this._linkifier2 = d),
                    (this._charSizeService = m),
                    (this._optionsService = g),
                    (this._bufferService = v),
                    (this._coreBrowserService = y),
                    (this._themeService = C),
                    (this._terminalClass = S++),
                    (this._rowElements = []),
                    (this._selectionRenderModel = (0,
                    c.createSelectionRenderModel)()),
                    (this.onRequestRedraw = this.register(
                      new p.EventEmitter()
                    ).event),
                    (this._rowContainer = this._document.createElement('div')),
                    this._rowContainer.classList.add(_),
                    (this._rowContainer.style.lineHeight = 'normal'),
                    this._rowContainer.setAttribute('aria-hidden', 'true'),
                    this._refreshRowElements(
                      this._bufferService.cols,
                      this._bufferService.rows
                    ),
                    (this._selectionContainer =
                      this._document.createElement('div')),
                    this._selectionContainer.classList.add(b),
                    this._selectionContainer.setAttribute(
                      'aria-hidden',
                      'true'
                    ),
                    (this.dimensions = (0, l.createRenderDimensions)()),
                    this._updateDimensions(),
                    this.register(
                      this._optionsService.onOptionChange(() =>
                        this._handleOptionsChanged()
                      )
                    ),
                    this.register(
                      this._themeService.onChangeColors((e) =>
                        this._injectCss(e)
                      )
                    ),
                    this._injectCss(this._themeService.colors),
                    (this._rowFactory = u.createInstance(
                      r.DomRendererRowFactory,
                      document
                    )),
                    this._element.classList.add(f + this._terminalClass),
                    this._screenElement.appendChild(this._rowContainer),
                    this._screenElement.appendChild(this._selectionContainer),
                    this.register(
                      this._linkifier2.onShowLinkUnderline((e) =>
                        this._handleLinkHover(e)
                      )
                    ),
                    this.register(
                      this._linkifier2.onHideLinkUnderline((e) =>
                        this._handleLinkLeave(e)
                      )
                    ),
                    this.register(
                      (0, h.toDisposable)(() => {
                        this._element.classList.remove(f + this._terminalClass),
                          this._rowContainer.remove(),
                          this._selectionContainer.remove(),
                          this._widthCache.dispose(),
                          this._themeStyleElement.remove(),
                          this._dimensionsStyleElement.remove()
                      })
                    ),
                    (this._widthCache = new a.WidthCache(
                      this._document,
                      this._helperContainer
                    )),
                    this._widthCache.setFont(
                      this._optionsService.rawOptions.fontFamily,
                      this._optionsService.rawOptions.fontSize,
                      this._optionsService.rawOptions.fontWeight,
                      this._optionsService.rawOptions.fontWeightBold
                    ),
                    this._setDefaultSpacing()
                }
                _updateDimensions() {
                  const e = this._coreBrowserService.dpr
                  ;(this.dimensions.device.char.width =
                    this._charSizeService.width * e),
                    (this.dimensions.device.char.height = Math.ceil(
                      this._charSizeService.height * e
                    )),
                    (this.dimensions.device.cell.width =
                      this.dimensions.device.char.width +
                      Math.round(
                        this._optionsService.rawOptions.letterSpacing
                      )),
                    (this.dimensions.device.cell.height = Math.floor(
                      this.dimensions.device.char.height *
                        this._optionsService.rawOptions.lineHeight
                    )),
                    (this.dimensions.device.char.left = 0),
                    (this.dimensions.device.char.top = 0),
                    (this.dimensions.device.canvas.width =
                      this.dimensions.device.cell.width *
                      this._bufferService.cols),
                    (this.dimensions.device.canvas.height =
                      this.dimensions.device.cell.height *
                      this._bufferService.rows),
                    (this.dimensions.css.canvas.width = Math.round(
                      this.dimensions.device.canvas.width / e
                    )),
                    (this.dimensions.css.canvas.height = Math.round(
                      this.dimensions.device.canvas.height / e
                    )),
                    (this.dimensions.css.cell.width =
                      this.dimensions.css.canvas.width /
                      this._bufferService.cols),
                    (this.dimensions.css.cell.height =
                      this.dimensions.css.canvas.height /
                      this._bufferService.rows)
                  for (const n of this._rowElements)
                    (n.style.width = `${this.dimensions.css.canvas.width}px`),
                      (n.style.height = `${this.dimensions.css.cell.height}px`),
                      (n.style.lineHeight = `${this.dimensions.css.cell.height}px`),
                      (n.style.overflow = 'hidden')
                  this._dimensionsStyleElement ||
                    ((this._dimensionsStyleElement =
                      this._document.createElement('style')),
                    this._screenElement.appendChild(
                      this._dimensionsStyleElement
                    ))
                  const t = `${this._terminalSelector} .${_} span { display: inline-block; height: 100%; vertical-align: top;}`
                  ;(this._dimensionsStyleElement.textContent = t),
                    (this._selectionContainer.style.height =
                      this._viewportElement.style.height),
                    (this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`),
                    (this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`)
                }
                _injectCss(e) {
                  this._themeStyleElement ||
                    ((this._themeStyleElement =
                      this._document.createElement('style')),
                    this._screenElement.appendChild(this._themeStyleElement))
                  let t = `${this._terminalSelector} .${_} { color: ${e.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`
                  ;(t += `${this._terminalSelector} .${_} .xterm-dim { color: ${u.color.multiplyOpacity(e.foreground, 0.5).css};}`),
                    (t += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`)
                  const n = `blink_underline_${this._terminalClass}`,
                    o = `blink_bar_${this._terminalClass}`,
                    i = `blink_block_${this._terminalClass}`
                  ;(t += `@keyframes ${n} { 50% {  border-bottom-style: hidden; }}`),
                    (t += `@keyframes ${o} { 50% {  box-shadow: none; }}`),
                    (t += `@keyframes ${i} { 0% {  background-color: ${e.cursor.css};  color: ${e.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${e.cursor.css}; }}`),
                    (t += `${this._terminalSelector} .${_}.${y} .xterm-cursor.xterm-cursor-blink.xterm-cursor-underline { animation: ${n} 1s step-end infinite;}${this._terminalSelector} .${_}.${y} .xterm-cursor.xterm-cursor-blink.xterm-cursor-bar { animation: ${o} 1s step-end infinite;}${this._terminalSelector} .${_}.${y} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: ${i} 1s step-end infinite;}${this._terminalSelector} .${_} .xterm-cursor.xterm-cursor-block { background-color: ${e.cursor.css}; color: ${e.cursorAccent.css};}${this._terminalSelector} .${_} .xterm-cursor.xterm-cursor-block:not(.xterm-cursor-blink) { background-color: ${e.cursor.css} !important; color: ${e.cursorAccent.css} !important;}${this._terminalSelector} .${_} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${e.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${_} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${e.cursor.css} inset;}${this._terminalSelector} .${_} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${e.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`),
                    (t += `${this._terminalSelector} .${b} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${b} div { position: absolute; background-color: ${e.selectionBackgroundOpaque.css};}${this._terminalSelector} .${b} div { position: absolute; background-color: ${e.selectionInactiveBackgroundOpaque.css};}`)
                  for (const [r, a] of e.ansi.entries())
                    t += `${this._terminalSelector} .${g}${r} { color: ${a.css}; }${this._terminalSelector} .${g}${r}.xterm-dim { color: ${u.color.multiplyOpacity(a, 0.5).css}; }${this._terminalSelector} .${v}${r} { background-color: ${a.css}; }`
                  ;(t += `${this._terminalSelector} .${g}${s.INVERTED_DEFAULT_COLOR} { color: ${u.color.opaque(e.background).css}; }${this._terminalSelector} .${g}${s.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${u.color.multiplyOpacity(u.color.opaque(e.background), 0.5).css}; }${this._terminalSelector} .${v}${s.INVERTED_DEFAULT_COLOR} { background-color: ${e.foreground.css}; }`),
                    (this._themeStyleElement.textContent = t)
                }
                _setDefaultSpacing() {
                  const e =
                    this.dimensions.css.cell.width -
                    this._widthCache.get('W', !1, !1)
                  ;(this._rowContainer.style.letterSpacing = `${e}px`),
                    (this._rowFactory.defaultSpacing = e)
                }
                handleDevicePixelRatioChange() {
                  this._updateDimensions(),
                    this._widthCache.clear(),
                    this._setDefaultSpacing()
                }
                _refreshRowElements(e, t) {
                  for (let n = this._rowElements.length; n <= t; n++) {
                    const e = this._document.createElement('div')
                    this._rowContainer.appendChild(e), this._rowElements.push(e)
                  }
                  for (; this._rowElements.length > t; )
                    this._rowContainer.removeChild(this._rowElements.pop())
                }
                handleResize(e, t) {
                  this._refreshRowElements(e, t),
                    this._updateDimensions(),
                    this.handleSelectionChanged(
                      this._selectionRenderModel.selectionStart,
                      this._selectionRenderModel.selectionEnd,
                      this._selectionRenderModel.columnSelectMode
                    )
                }
                handleCharSizeChanged() {
                  this._updateDimensions(),
                    this._widthCache.clear(),
                    this._setDefaultSpacing()
                }
                handleBlur() {
                  this._rowContainer.classList.remove(y),
                    this.renderRows(0, this._bufferService.rows - 1)
                }
                handleFocus() {
                  this._rowContainer.classList.add(y),
                    this.renderRows(
                      this._bufferService.buffer.y,
                      this._bufferService.buffer.y
                    )
                }
                handleSelectionChanged(e, t, n) {
                  if (
                    (this._selectionContainer.replaceChildren(),
                    this._rowFactory.handleSelectionChanged(e, t, n),
                    this.renderRows(0, this._bufferService.rows - 1),
                    !e || !t)
                  )
                    return
                  this._selectionRenderModel.update(this._terminal, e, t, n)
                  const o = this._selectionRenderModel.viewportStartRow,
                    i = this._selectionRenderModel.viewportEndRow,
                    r = this._selectionRenderModel.viewportCappedStartRow,
                    a = this._selectionRenderModel.viewportCappedEndRow
                  if (r >= this._bufferService.rows || a < 0) return
                  const s = this._document.createDocumentFragment()
                  if (n) {
                    const n = e[0] > t[0]
                    s.appendChild(
                      this._createSelectionElement(
                        r,
                        n ? t[0] : e[0],
                        n ? e[0] : t[0],
                        a - r + 1
                      )
                    )
                  } else {
                    const n = o === r ? e[0] : 0,
                      l = r === i ? t[0] : this._bufferService.cols
                    s.appendChild(this._createSelectionElement(r, n, l))
                    const c = a - r - 1
                    if (
                      (s.appendChild(
                        this._createSelectionElement(
                          r + 1,
                          0,
                          this._bufferService.cols,
                          c
                        )
                      ),
                      r !== a)
                    ) {
                      const e = i === a ? t[0] : this._bufferService.cols
                      s.appendChild(this._createSelectionElement(a, 0, e))
                    }
                  }
                  this._selectionContainer.appendChild(s)
                }
                _createSelectionElement(e, t, n, o = 1) {
                  const i = this._document.createElement('div'),
                    r = t * this.dimensions.css.cell.width
                  let a = this.dimensions.css.cell.width * (n - t)
                  return (
                    r + a > this.dimensions.css.canvas.width &&
                      (a = this.dimensions.css.canvas.width - r),
                    (i.style.height =
                      o * this.dimensions.css.cell.height + 'px'),
                    (i.style.top = e * this.dimensions.css.cell.height + 'px'),
                    (i.style.left = `${r}px`),
                    (i.style.width = `${a}px`),
                    i
                  )
                }
                handleCursorMove() {}
                _handleOptionsChanged() {
                  this._updateDimensions(),
                    this._injectCss(this._themeService.colors),
                    this._widthCache.setFont(
                      this._optionsService.rawOptions.fontFamily,
                      this._optionsService.rawOptions.fontSize,
                      this._optionsService.rawOptions.fontWeight,
                      this._optionsService.rawOptions.fontWeightBold
                    ),
                    this._setDefaultSpacing()
                }
                clear() {
                  for (const e of this._rowElements) e.replaceChildren()
                }
                renderRows(e, t) {
                  const n = this._bufferService.buffer,
                    o = n.ybase + n.y,
                    i = Math.min(n.x, this._bufferService.cols - 1),
                    r = this._optionsService.rawOptions.cursorBlink,
                    a = this._optionsService.rawOptions.cursorStyle,
                    s = this._optionsService.rawOptions.cursorInactiveStyle
                  for (let l = e; l <= t; l++) {
                    const e = l + n.ydisp,
                      t = this._rowElements[l],
                      c = n.lines.get(e)
                    if (!t || !c) break
                    t.replaceChildren(
                      ...this._rowFactory.createRow(
                        c,
                        e,
                        e === o,
                        a,
                        s,
                        i,
                        r,
                        this.dimensions.css.cell.width,
                        this._widthCache,
                        -1,
                        -1
                      )
                    )
                  }
                }
                get _terminalSelector() {
                  return `.${f}${this._terminalClass}`
                }
                _handleLinkHover(e) {
                  this._setCellUnderline(e.x1, e.x2, e.y1, e.y2, e.cols, !0)
                }
                _handleLinkLeave(e) {
                  this._setCellUnderline(e.x1, e.x2, e.y1, e.y2, e.cols, !1)
                }
                _setCellUnderline(e, t, n, o, i, r) {
                  n < 0 && (e = 0), o < 0 && (t = 0)
                  const a = this._bufferService.rows - 1
                  ;(n = Math.max(Math.min(n, a), 0)),
                    (o = Math.max(Math.min(o, a), 0)),
                    (i = Math.min(i, this._bufferService.cols))
                  const s = this._bufferService.buffer,
                    l = s.ybase + s.y,
                    c = Math.min(s.x, i - 1),
                    d = this._optionsService.rawOptions.cursorBlink,
                    u = this._optionsService.rawOptions.cursorStyle,
                    p = this._optionsService.rawOptions.cursorInactiveStyle
                  for (let h = n; h <= o; ++h) {
                    const a = h + s.ydisp,
                      m = this._rowElements[h],
                      f = s.lines.get(a)
                    if (!m || !f) break
                    m.replaceChildren(
                      ...this._rowFactory.createRow(
                        f,
                        a,
                        a === l,
                        u,
                        p,
                        c,
                        d,
                        this.dimensions.css.cell.width,
                        this._widthCache,
                        r ? (h === n ? e : 0) : -1,
                        r ? (h === o ? t : i) - 1 : -1
                      )
                    )
                  }
                }
              })
            t.DomRenderer = C = o(
              [
                i(7, m.IInstantiationService),
                i(8, d.ICharSizeService),
                i(9, m.IOptionsService),
                i(10, m.IBufferService),
                i(11, d.ICoreBrowserService),
                i(12, d.IThemeService)
              ],
              C
            )
          },
          3787: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.DomRendererRowFactory = void 0)
            const r = n(2223),
              a = n(643),
              s = n(511),
              l = n(2585),
              c = n(8055),
              d = n(4725),
              u = n(4269),
              p = n(6171),
              h = n(3734)
            let m = (t.DomRendererRowFactory = class {
              constructor(e, t, n, o, i, r, a) {
                ;(this._document = e),
                  (this._characterJoinerService = t),
                  (this._optionsService = n),
                  (this._coreBrowserService = o),
                  (this._coreService = i),
                  (this._decorationService = r),
                  (this._themeService = a),
                  (this._workCell = new s.CellData()),
                  (this._columnSelectMode = !1),
                  (this.defaultSpacing = 0)
              }
              handleSelectionChanged(e, t, n) {
                ;(this._selectionStart = e),
                  (this._selectionEnd = t),
                  (this._columnSelectMode = n)
              }
              createRow(e, t, n, o, i, s, l, d, p, m, _) {
                const g = [],
                  v = this._characterJoinerService.getJoinedCharacters(t),
                  y = this._themeService.colors
                let b,
                  S = e.getNoBgTrimmedLength()
                n && S < s + 1 && (S = s + 1)
                let C = 0,
                  w = '',
                  k = 0,
                  x = 0,
                  E = 0,
                  I = !1,
                  T = 0,
                  $ = !1,
                  L = 0
                const A = [],
                  O = -1 !== m && -1 !== _
                for (let P = 0; P < S; P++) {
                  e.loadCell(P, this._workCell)
                  let S = this._workCell.getWidth()
                  if (0 === S) continue
                  let V = !1,
                    D = P,
                    R = this._workCell
                  if (v.length > 0 && P === v[0][0]) {
                    V = !0
                    const t = v.shift()
                    ;(R = new u.JoinedCellData(
                      this._workCell,
                      e.translateToString(!0, t[0], t[1]),
                      t[1] - t[0]
                    )),
                      (D = t[1] - 1),
                      (S = R.getWidth())
                  }
                  const N = this._isCellInSelection(P, t),
                    M = n && P === s,
                    B = O && P >= m && P <= _
                  let F = !1
                  this._decorationService.forEachDecorationAtCell(
                    P,
                    t,
                    void 0,
                    (e) => {
                      F = !0
                    }
                  )
                  let z = R.getChars() || a.WHITESPACE_CELL_CHAR
                  if (
                    (' ' === z &&
                      (R.isUnderline() || R.isOverline()) &&
                      (z = ' '),
                    (L = S * d - p.get(z, R.isBold(), R.isItalic())),
                    b)
                  ) {
                    if (
                      C &&
                      ((N && $) || (!N && !$ && R.bg === k)) &&
                      ((N && $ && y.selectionForeground) || R.fg === x) &&
                      R.extended.ext === E &&
                      B === I &&
                      L === T &&
                      !M &&
                      !V &&
                      !F
                    ) {
                      R.isInvisible()
                        ? (w += a.WHITESPACE_CELL_CHAR)
                        : (w += z),
                        C++
                      continue
                    }
                    C && (b.textContent = w),
                      (b = this._document.createElement('span')),
                      (C = 0),
                      (w = '')
                  } else b = this._document.createElement('span')
                  if (
                    ((k = R.bg),
                    (x = R.fg),
                    (E = R.extended.ext),
                    (I = B),
                    (T = L),
                    ($ = N),
                    V && s >= P && s <= D && (s = P),
                    !this._coreService.isCursorHidden &&
                      M &&
                      this._coreService.isCursorInitialized)
                  )
                    if (
                      (A.push('xterm-cursor'),
                      this._coreBrowserService.isFocused)
                    )
                      l && A.push('xterm-cursor-blink'),
                        A.push(
                          'bar' === o
                            ? 'xterm-cursor-bar'
                            : 'underline' === o
                              ? 'xterm-cursor-underline'
                              : 'xterm-cursor-block'
                        )
                    else if (i)
                      switch (i) {
                        case 'outline':
                          A.push('xterm-cursor-outline')
                          break
                        case 'block':
                          A.push('xterm-cursor-block')
                          break
                        case 'bar':
                          A.push('xterm-cursor-bar')
                          break
                        case 'underline':
                          A.push('xterm-cursor-underline')
                      }
                  if (
                    (R.isBold() && A.push('xterm-bold'),
                    R.isItalic() && A.push('xterm-italic'),
                    R.isDim() && A.push('xterm-dim'),
                    (w = R.isInvisible()
                      ? a.WHITESPACE_CELL_CHAR
                      : R.getChars() || a.WHITESPACE_CELL_CHAR),
                    R.isUnderline() &&
                      (A.push(`xterm-underline-${R.extended.underlineStyle}`),
                      ' ' === w && (w = ' '),
                      !R.isUnderlineColorDefault()))
                  )
                    if (R.isUnderlineColorRGB())
                      b.style.textDecorationColor = `rgb(${h.AttributeData.toColorRGB(R.getUnderlineColor()).join(',')})`
                    else {
                      let e = R.getUnderlineColor()
                      this._optionsService.rawOptions
                        .drawBoldTextInBrightColors &&
                        R.isBold() &&
                        e < 8 &&
                        (e += 8),
                        (b.style.textDecorationColor = y.ansi[e].css)
                    }
                  R.isOverline() &&
                    (A.push('xterm-overline'), ' ' === w && (w = ' ')),
                    R.isStrikethrough() && A.push('xterm-strikethrough'),
                    B && (b.style.textDecoration = 'underline')
                  let H = R.getFgColor(),
                    j = R.getFgColorMode(),
                    U = R.getBgColor(),
                    G = R.getBgColorMode()
                  const W = !!R.isInverse()
                  if (W) {
                    const e = H
                    ;(H = U), (U = e)
                    const t = j
                    ;(j = G), (G = t)
                  }
                  let K,
                    Z,
                    q,
                    Y = !1
                  switch (
                    (this._decorationService.forEachDecorationAtCell(
                      P,
                      t,
                      void 0,
                      (e) => {
                        ;('top' !== e.options.layer && Y) ||
                          (e.backgroundColorRGB &&
                            ((G = 50331648),
                            (U = (e.backgroundColorRGB.rgba >> 8) & 16777215),
                            (K = e.backgroundColorRGB)),
                          e.foregroundColorRGB &&
                            ((j = 50331648),
                            (H = (e.foregroundColorRGB.rgba >> 8) & 16777215),
                            (Z = e.foregroundColorRGB)),
                          (Y = 'top' === e.options.layer))
                      }
                    ),
                    !Y &&
                      N &&
                      ((K = this._coreBrowserService.isFocused
                        ? y.selectionBackgroundOpaque
                        : y.selectionInactiveBackgroundOpaque),
                      (U = (K.rgba >> 8) & 16777215),
                      (G = 50331648),
                      (Y = !0),
                      y.selectionForeground &&
                        ((j = 50331648),
                        (H = (y.selectionForeground.rgba >> 8) & 16777215),
                        (Z = y.selectionForeground))),
                    Y && A.push('xterm-decoration-top'),
                    G)
                  ) {
                    case 16777216:
                    case 33554432:
                      ;(q = y.ansi[U]), A.push(`xterm-bg-${U}`)
                      break
                    case 50331648:
                      ;(q = c.channels.toColor(
                        U >> 16,
                        (U >> 8) & 255,
                        255 & U
                      )),
                        this._addStyle(
                          b,
                          `background-color:#${f((U >>> 0).toString(16), '0', 6)}`
                        )
                      break
                    default:
                      W
                        ? ((q = y.foreground),
                          A.push(`xterm-bg-${r.INVERTED_DEFAULT_COLOR}`))
                        : (q = y.background)
                  }
                  switch (
                    (K || (R.isDim() && (K = c.color.multiplyOpacity(q, 0.5))),
                    j)
                  ) {
                    case 16777216:
                    case 33554432:
                      R.isBold() &&
                        H < 8 &&
                        this._optionsService.rawOptions
                          .drawBoldTextInBrightColors &&
                        (H += 8),
                        this._applyMinimumContrast(
                          b,
                          q,
                          y.ansi[H],
                          R,
                          K,
                          void 0
                        ) || A.push(`xterm-fg-${H}`)
                      break
                    case 50331648:
                      const e = c.channels.toColor(
                        (H >> 16) & 255,
                        (H >> 8) & 255,
                        255 & H
                      )
                      this._applyMinimumContrast(b, q, e, R, K, Z) ||
                        this._addStyle(b, `color:#${f(H.toString(16), '0', 6)}`)
                      break
                    default:
                      this._applyMinimumContrast(b, q, y.foreground, R, K, Z) ||
                        (W && A.push(`xterm-fg-${r.INVERTED_DEFAULT_COLOR}`))
                  }
                  A.length && ((b.className = A.join(' ')), (A.length = 0)),
                    M || V || F ? (b.textContent = w) : C++,
                    L !== this.defaultSpacing &&
                      (b.style.letterSpacing = `${L}px`),
                    g.push(b),
                    (P = D)
                }
                return b && C && (b.textContent = w), g
              }
              _applyMinimumContrast(e, t, n, o, i, r) {
                if (
                  1 === this._optionsService.rawOptions.minimumContrastRatio ||
                  (0, p.treatGlyphAsBackgroundColor)(o.getCode())
                )
                  return !1
                const a = this._getContrastCache(o)
                let s
                if (
                  (i || r || (s = a.getColor(t.rgba, n.rgba)), void 0 === s)
                ) {
                  const e =
                    this._optionsService.rawOptions.minimumContrastRatio /
                    (o.isDim() ? 2 : 1)
                  ;(s = c.color.ensureContrastRatio(i || t, r || n, e)),
                    a.setColor((i || t).rgba, (r || n).rgba, s ?? null)
                }
                return !!s && (this._addStyle(e, `color:${s.css}`), !0)
              }
              _getContrastCache(e) {
                return e.isDim()
                  ? this._themeService.colors.halfContrastCache
                  : this._themeService.colors.contrastCache
              }
              _addStyle(e, t) {
                e.setAttribute('style', `${e.getAttribute('style') || ''}${t};`)
              }
              _isCellInSelection(e, t) {
                const n = this._selectionStart,
                  o = this._selectionEnd
                return (
                  !(!n || !o) &&
                  (this._columnSelectMode
                    ? n[0] <= o[0]
                      ? e >= n[0] && t >= n[1] && e < o[0] && t <= o[1]
                      : e < n[0] && t >= n[1] && e >= o[0] && t <= o[1]
                    : (t > n[1] && t < o[1]) ||
                      (n[1] === o[1] && t === n[1] && e >= n[0] && e < o[0]) ||
                      (n[1] < o[1] && t === o[1] && e < o[0]) ||
                      (n[1] < o[1] && t === n[1] && e >= n[0]))
                )
              }
            })
            function f(e, t, n) {
              for (; e.length < n; ) e = t + e
              return e
            }
            __name(f, 'v'),
              (t.DomRendererRowFactory = m =
                o(
                  [
                    i(1, d.ICharacterJoinerService),
                    i(2, l.IOptionsService),
                    i(3, d.ICoreBrowserService),
                    i(4, l.ICoreService),
                    i(5, l.IDecorationService),
                    i(6, d.IThemeService)
                  ],
                  m
                ))
          },
          2550: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.WidthCache = void 0),
              (t.WidthCache = class {
                constructor(e, t) {
                  ;(this._flat = new Float32Array(256)),
                    (this._font = ''),
                    (this._fontSize = 0),
                    (this._weight = 'normal'),
                    (this._weightBold = 'bold'),
                    (this._measureElements = []),
                    (this._container = e.createElement('div')),
                    this._container.classList.add(
                      'xterm-width-cache-measure-container'
                    ),
                    this._container.setAttribute('aria-hidden', 'true'),
                    (this._container.style.whiteSpace = 'pre'),
                    (this._container.style.fontKerning = 'none')
                  const n = e.createElement('span')
                  n.classList.add('xterm-char-measure-element')
                  const o = e.createElement('span')
                  o.classList.add('xterm-char-measure-element'),
                    (o.style.fontWeight = 'bold')
                  const i = e.createElement('span')
                  i.classList.add('xterm-char-measure-element'),
                    (i.style.fontStyle = 'italic')
                  const r = e.createElement('span')
                  r.classList.add('xterm-char-measure-element'),
                    (r.style.fontWeight = 'bold'),
                    (r.style.fontStyle = 'italic'),
                    (this._measureElements = [n, o, i, r]),
                    this._container.appendChild(n),
                    this._container.appendChild(o),
                    this._container.appendChild(i),
                    this._container.appendChild(r),
                    t.appendChild(this._container),
                    this.clear()
                }
                dispose() {
                  this._container.remove(),
                    (this._measureElements.length = 0),
                    (this._holey = void 0)
                }
                clear() {
                  this._flat.fill(-9999), (this._holey = new Map())
                }
                setFont(e, t, n, o) {
                  ;(e === this._font &&
                    t === this._fontSize &&
                    n === this._weight &&
                    o === this._weightBold) ||
                    ((this._font = e),
                    (this._fontSize = t),
                    (this._weight = n),
                    (this._weightBold = o),
                    (this._container.style.fontFamily = this._font),
                    (this._container.style.fontSize = `${this._fontSize}px`),
                    (this._measureElements[0].style.fontWeight = `${n}`),
                    (this._measureElements[1].style.fontWeight = `${o}`),
                    (this._measureElements[2].style.fontWeight = `${n}`),
                    (this._measureElements[3].style.fontWeight = `${o}`),
                    this.clear())
                }
                get(e, t, n) {
                  let o = 0
                  if (
                    !t &&
                    !n &&
                    1 === e.length &&
                    (o = e.charCodeAt(0)) < 256
                  ) {
                    if (-9999 !== this._flat[o]) return this._flat[o]
                    const t = this._measure(e, 0)
                    return t > 0 && (this._flat[o] = t), t
                  }
                  let i = e
                  t && (i += 'B'), n && (i += 'I')
                  let r = this._holey.get(i)
                  if (void 0 === r) {
                    let o = 0
                    t && (o |= 1),
                      n && (o |= 2),
                      (r = this._measure(e, o)),
                      r > 0 && this._holey.set(i, r)
                  }
                  return r
                }
                _measure(e, t) {
                  const n = this._measureElements[t]
                  return (n.textContent = e.repeat(32)), n.offsetWidth / 32
                }
              })
          },
          2223: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.TEXT_BASELINE =
                t.DIM_OPACITY =
                t.INVERTED_DEFAULT_COLOR =
                  void 0)
            const o = n(6114)
            ;(t.INVERTED_DEFAULT_COLOR = 257),
              (t.DIM_OPACITY = 0.5),
              (t.TEXT_BASELINE =
                o.isFirefox || o.isLegacyEdge ? 'bottom' : 'ideographic')
          },
          6171: (e, t) => {
            function n(e) {
              return 57508 <= e && e <= 57558
            }
            function o(e) {
              return (
                (e >= 128512 && e <= 128591) ||
                (e >= 127744 && e <= 128511) ||
                (e >= 128640 && e <= 128767) ||
                (e >= 9728 && e <= 9983) ||
                (e >= 9984 && e <= 10175) ||
                (e >= 65024 && e <= 65039) ||
                (e >= 129280 && e <= 129535) ||
                (e >= 127462 && e <= 127487)
              )
            }
            __name(n, 'i'),
              __name(o, 's'),
              Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.computeNextVariantOffset =
                t.createRenderDimensions =
                t.treatGlyphAsBackgroundColor =
                t.allowRescaling =
                t.isEmoji =
                t.isRestrictedPowerlineGlyph =
                t.isPowerlineGlyph =
                t.throwIfFalsy =
                  void 0),
              (t.throwIfFalsy = function (e) {
                if (!e) throw new Error('value must not be falsy')
                return e
              }),
              (t.isPowerlineGlyph = n),
              (t.isRestrictedPowerlineGlyph = function (e) {
                return 57520 <= e && e <= 57527
              }),
              (t.isEmoji = o),
              (t.allowRescaling = function (e, t, i, r) {
                return (
                  1 === t &&
                  i > Math.ceil(1.5 * r) &&
                  void 0 !== e &&
                  e > 255 &&
                  !o(e) &&
                  !n(e) &&
                  !(57344 <= (a = e) && a <= 63743)
                )
                var a
              }),
              (t.treatGlyphAsBackgroundColor = function (e) {
                return n(e) || (9472 <= (t = e) && t <= 9631)
                var t
              }),
              (t.createRenderDimensions = function () {
                return {
                  css: {
                    canvas: { width: 0, height: 0 },
                    cell: { width: 0, height: 0 }
                  },
                  device: {
                    canvas: { width: 0, height: 0 },
                    cell: { width: 0, height: 0 },
                    char: { width: 0, height: 0, left: 0, top: 0 }
                  }
                }
              }),
              (t.computeNextVariantOffset = function (e, t, n = 0) {
                return (e - (2 * Math.round(t) - n)) % (2 * Math.round(t))
              })
          },
          6052: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.createSelectionRenderModel = void 0)
            class n {
              static {
                __name(this, 'i')
              }
              constructor() {
                this.clear()
              }
              clear() {
                ;(this.hasSelection = !1),
                  (this.columnSelectMode = !1),
                  (this.viewportStartRow = 0),
                  (this.viewportEndRow = 0),
                  (this.viewportCappedStartRow = 0),
                  (this.viewportCappedEndRow = 0),
                  (this.startCol = 0),
                  (this.endCol = 0),
                  (this.selectionStart = void 0),
                  (this.selectionEnd = void 0)
              }
              update(e, t, n, o = !1) {
                if (
                  ((this.selectionStart = t),
                  (this.selectionEnd = n),
                  !t || !n || (t[0] === n[0] && t[1] === n[1]))
                )
                  return void this.clear()
                const i = e.buffers.active.ydisp,
                  r = t[1] - i,
                  a = n[1] - i,
                  s = Math.max(r, 0),
                  l = Math.min(a, e.rows - 1)
                s >= e.rows || l < 0
                  ? this.clear()
                  : ((this.hasSelection = !0),
                    (this.columnSelectMode = o),
                    (this.viewportStartRow = r),
                    (this.viewportEndRow = a),
                    (this.viewportCappedStartRow = s),
                    (this.viewportCappedEndRow = l),
                    (this.startCol = t[0]),
                    (this.endCol = n[0]))
              }
              isCellSelected(e, t, n) {
                return (
                  !!this.hasSelection &&
                  ((n -= e.buffer.active.viewportY),
                  this.columnSelectMode
                    ? this.startCol <= this.endCol
                      ? t >= this.startCol &&
                        n >= this.viewportCappedStartRow &&
                        t < this.endCol &&
                        n <= this.viewportCappedEndRow
                      : t < this.startCol &&
                        n >= this.viewportCappedStartRow &&
                        t >= this.endCol &&
                        n <= this.viewportCappedEndRow
                    : (n > this.viewportStartRow && n < this.viewportEndRow) ||
                      (this.viewportStartRow === this.viewportEndRow &&
                        n === this.viewportStartRow &&
                        t >= this.startCol &&
                        t < this.endCol) ||
                      (this.viewportStartRow < this.viewportEndRow &&
                        n === this.viewportEndRow &&
                        t < this.endCol) ||
                      (this.viewportStartRow < this.viewportEndRow &&
                        n === this.viewportStartRow &&
                        t >= this.startCol))
                )
              }
            }
            t.createSelectionRenderModel = function () {
              return new n()
            }
          },
          456: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.SelectionModel = void 0),
              (t.SelectionModel = class {
                constructor(e) {
                  ;(this._bufferService = e),
                    (this.isSelectAllActive = !1),
                    (this.selectionStartLength = 0)
                }
                clearSelection() {
                  ;(this.selectionStart = void 0),
                    (this.selectionEnd = void 0),
                    (this.isSelectAllActive = !1),
                    (this.selectionStartLength = 0)
                }
                get finalSelectionStart() {
                  return this.isSelectAllActive
                    ? [0, 0]
                    : this.selectionEnd &&
                        this.selectionStart &&
                        this.areSelectionValuesReversed()
                      ? this.selectionEnd
                      : this.selectionStart
                }
                get finalSelectionEnd() {
                  if (this.isSelectAllActive)
                    return [
                      this._bufferService.cols,
                      this._bufferService.buffer.ybase +
                        this._bufferService.rows -
                        1
                    ]
                  if (this.selectionStart) {
                    if (
                      !this.selectionEnd ||
                      this.areSelectionValuesReversed()
                    ) {
                      const e =
                        this.selectionStart[0] + this.selectionStartLength
                      return e > this._bufferService.cols
                        ? e % this._bufferService.cols == 0
                          ? [
                              this._bufferService.cols,
                              this.selectionStart[1] +
                                Math.floor(e / this._bufferService.cols) -
                                1
                            ]
                          : [
                              e % this._bufferService.cols,
                              this.selectionStart[1] +
                                Math.floor(e / this._bufferService.cols)
                            ]
                        : [e, this.selectionStart[1]]
                    }
                    if (
                      this.selectionStartLength &&
                      this.selectionEnd[1] === this.selectionStart[1]
                    ) {
                      const e =
                        this.selectionStart[0] + this.selectionStartLength
                      return e > this._bufferService.cols
                        ? [
                            e % this._bufferService.cols,
                            this.selectionStart[1] +
                              Math.floor(e / this._bufferService.cols)
                          ]
                        : [
                            Math.max(e, this.selectionEnd[0]),
                            this.selectionEnd[1]
                          ]
                    }
                    return this.selectionEnd
                  }
                }
                areSelectionValuesReversed() {
                  const e = this.selectionStart,
                    t = this.selectionEnd
                  return (
                    !(!e || !t) &&
                    (e[1] > t[1] || (e[1] === t[1] && e[0] > t[0]))
                  )
                }
                handleTrim(e) {
                  return (
                    this.selectionStart && (this.selectionStart[1] -= e),
                    this.selectionEnd && (this.selectionEnd[1] -= e),
                    this.selectionEnd && this.selectionEnd[1] < 0
                      ? (this.clearSelection(), !0)
                      : (this.selectionStart &&
                          this.selectionStart[1] < 0 &&
                          (this.selectionStart[1] = 0),
                        !1)
                  )
                }
              })
          },
          428: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.CharSizeService = void 0)
            const r = n(2585),
              a = n(8460),
              s = n(844)
            let l = (t.CharSizeService = class extends s.Disposable {
              get hasValidSize() {
                return this.width > 0 && this.height > 0
              }
              constructor(e, t, n) {
                super(),
                  (this._optionsService = n),
                  (this.width = 0),
                  (this.height = 0),
                  (this._onCharSizeChange = this.register(
                    new a.EventEmitter()
                  )),
                  (this.onCharSizeChange = this._onCharSizeChange.event)
                try {
                  this._measureStrategy = this.register(
                    new u(this._optionsService)
                  )
                } catch {
                  this._measureStrategy = this.register(
                    new d(e, t, this._optionsService)
                  )
                }
                this.register(
                  this._optionsService.onMultipleOptionChange(
                    ['fontFamily', 'fontSize'],
                    () => this.measure()
                  )
                )
              }
              measure() {
                const e = this._measureStrategy.measure()
                ;(e.width === this.width && e.height === this.height) ||
                  ((this.width = e.width),
                  (this.height = e.height),
                  this._onCharSizeChange.fire())
              }
            })
            t.CharSizeService = l = o([i(2, r.IOptionsService)], l)
            class c extends s.Disposable {
              static {
                __name(this, 'c')
              }
              constructor() {
                super(...arguments), (this._result = { width: 0, height: 0 })
              }
              _validateAndSet(e, t) {
                void 0 !== e &&
                  e > 0 &&
                  void 0 !== t &&
                  t > 0 &&
                  ((this._result.width = e), (this._result.height = t))
              }
            }
            class d extends c {
              static {
                __name(this, 'l')
              }
              constructor(e, t, n) {
                super(),
                  (this._document = e),
                  (this._parentElement = t),
                  (this._optionsService = n),
                  (this._measureElement = this._document.createElement('span')),
                  this._measureElement.classList.add(
                    'xterm-char-measure-element'
                  ),
                  (this._measureElement.textContent = 'W'.repeat(32)),
                  this._measureElement.setAttribute('aria-hidden', 'true'),
                  (this._measureElement.style.whiteSpace = 'pre'),
                  (this._measureElement.style.fontKerning = 'none'),
                  this._parentElement.appendChild(this._measureElement)
              }
              measure() {
                return (
                  (this._measureElement.style.fontFamily =
                    this._optionsService.rawOptions.fontFamily),
                  (this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`),
                  this._validateAndSet(
                    Number(this._measureElement.offsetWidth) / 32,
                    Number(this._measureElement.offsetHeight)
                  ),
                  this._result
                )
              }
            }
            class u extends c {
              static {
                __name(this, 'd')
              }
              constructor(e) {
                super(),
                  (this._optionsService = e),
                  (this._canvas = new OffscreenCanvas(100, 100)),
                  (this._ctx = this._canvas.getContext('2d'))
                const t = this._ctx.measureText('W')
                if (
                  !(
                    'width' in t &&
                    'fontBoundingBoxAscent' in t &&
                    'fontBoundingBoxDescent' in t
                  )
                )
                  throw new Error('Required font metrics not supported')
              }
              measure() {
                this._ctx.font = `${this._optionsService.rawOptions.fontSize}px ${this._optionsService.rawOptions.fontFamily}`
                const e = this._ctx.measureText('W')
                return (
                  this._validateAndSet(
                    e.width,
                    e.fontBoundingBoxAscent + e.fontBoundingBoxDescent
                  ),
                  this._result
                )
              }
            }
          },
          4269: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.CharacterJoinerService = t.JoinedCellData = void 0)
            const r = n(3734),
              a = n(643),
              s = n(511),
              l = n(2585)
            class c extends r.AttributeData {
              static {
                __name(this, 'c')
              }
              constructor(e, t, n) {
                super(),
                  (this.content = 0),
                  (this.combinedData = ''),
                  (this.fg = e.fg),
                  (this.bg = e.bg),
                  (this.combinedData = t),
                  (this._width = n)
              }
              isCombined() {
                return 2097152
              }
              getWidth() {
                return this._width
              }
              getChars() {
                return this.combinedData
              }
              getCode() {
                return 2097151
              }
              setFromCharData(e) {
                throw new Error('not implemented')
              }
              getAsCharData() {
                return [
                  this.fg,
                  this.getChars(),
                  this.getWidth(),
                  this.getCode()
                ]
              }
            }
            t.JoinedCellData = c
            let d = (t.CharacterJoinerService = class e {
              static {
                __name(this, 'e')
              }
              constructor(e) {
                ;(this._bufferService = e),
                  (this._characterJoiners = []),
                  (this._nextCharacterJoinerId = 0),
                  (this._workCell = new s.CellData())
              }
              register(e) {
                const t = { id: this._nextCharacterJoinerId++, handler: e }
                return this._characterJoiners.push(t), t.id
              }
              deregister(e) {
                for (let t = 0; t < this._characterJoiners.length; t++)
                  if (this._characterJoiners[t].id === e)
                    return this._characterJoiners.splice(t, 1), !0
                return !1
              }
              getJoinedCharacters(e) {
                if (0 === this._characterJoiners.length) return []
                const t = this._bufferService.buffer.lines.get(e)
                if (!t || 0 === t.length) return []
                const n = [],
                  o = t.translateToString(!0)
                let i = 0,
                  r = 0,
                  s = 0,
                  l = t.getFg(0),
                  c = t.getBg(0)
                for (let d = 0; d < t.getTrimmedLength(); d++)
                  if (
                    (t.loadCell(d, this._workCell),
                    0 !== this._workCell.getWidth())
                  ) {
                    if (this._workCell.fg !== l || this._workCell.bg !== c) {
                      if (d - i > 1) {
                        const e = this._getJoinedRanges(o, s, r, t, i)
                        for (let t = 0; t < e.length; t++) n.push(e[t])
                      }
                      ;(i = d),
                        (s = r),
                        (l = this._workCell.fg),
                        (c = this._workCell.bg)
                    }
                    r +=
                      this._workCell.getChars().length ||
                      a.WHITESPACE_CELL_CHAR.length
                  }
                if (this._bufferService.cols - i > 1) {
                  const e = this._getJoinedRanges(o, s, r, t, i)
                  for (let t = 0; t < e.length; t++) n.push(e[t])
                }
                return n
              }
              _getJoinedRanges(t, n, o, i, r) {
                const a = t.substring(n, o)
                let s = []
                try {
                  s = this._characterJoiners[0].handler(a)
                } catch (l) {
                  console.error(l)
                }
                for (let c = 1; c < this._characterJoiners.length; c++)
                  try {
                    const t = this._characterJoiners[c].handler(a)
                    for (let n = 0; n < t.length; n++) e._mergeRanges(s, t[n])
                  } catch (l) {
                    console.error(l)
                  }
                return this._stringRangesToCellRanges(s, i, r), s
              }
              _stringRangesToCellRanges(e, t, n) {
                let o = 0,
                  i = !1,
                  r = 0,
                  s = e[o]
                if (s) {
                  for (let l = n; l < this._bufferService.cols; l++) {
                    const n = t.getWidth(l),
                      c = t.getString(l).length || a.WHITESPACE_CELL_CHAR.length
                    if (0 !== n) {
                      if (
                        (!i && s[0] <= r && ((s[0] = l), (i = !0)), s[1] <= r)
                      ) {
                        if (((s[1] = l), (s = e[++o]), !s)) break
                        s[0] <= r ? ((s[0] = l), (i = !0)) : (i = !1)
                      }
                      r += c
                    }
                  }
                  s && (s[1] = this._bufferService.cols)
                }
              }
              static _mergeRanges(e, t) {
                let n = !1
                for (let o = 0; o < e.length; o++) {
                  const i = e[o]
                  if (n) {
                    if (t[1] <= i[0]) return (e[o - 1][1] = t[1]), e
                    if (t[1] <= i[1])
                      return (
                        (e[o - 1][1] = Math.max(t[1], i[1])), e.splice(o, 1), e
                      )
                    e.splice(o, 1), o--
                  } else {
                    if (t[1] <= i[0]) return e.splice(o, 0, t), e
                    if (t[1] <= i[1]) return (i[0] = Math.min(t[0], i[0])), e
                    t[0] < i[1] && ((i[0] = Math.min(t[0], i[0])), (n = !0))
                  }
                }
                return n ? (e[e.length - 1][1] = t[1]) : e.push(t), e
              }
            })
            t.CharacterJoinerService = d = o([i(0, l.IBufferService)], d)
          },
          5114: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.CoreBrowserService = void 0)
            const o = n(844),
              i = n(8460),
              r = n(3656)
            class a extends o.Disposable {
              static {
                __name(this, 'o')
              }
              constructor(e, t, n) {
                super(),
                  (this._textarea = e),
                  (this._window = t),
                  (this.mainDocument = n),
                  (this._isFocused = !1),
                  (this._cachedIsFocused = void 0),
                  (this._screenDprMonitor = new s(this._window)),
                  (this._onDprChange = this.register(new i.EventEmitter())),
                  (this.onDprChange = this._onDprChange.event),
                  (this._onWindowChange = this.register(new i.EventEmitter())),
                  (this.onWindowChange = this._onWindowChange.event),
                  this.register(
                    this.onWindowChange((e) =>
                      this._screenDprMonitor.setWindow(e)
                    )
                  ),
                  this.register(
                    (0, i.forwardEvent)(
                      this._screenDprMonitor.onDprChange,
                      this._onDprChange
                    )
                  ),
                  this._textarea.addEventListener(
                    'focus',
                    () => (this._isFocused = !0)
                  ),
                  this._textarea.addEventListener(
                    'blur',
                    () => (this._isFocused = !1)
                  )
              }
              get window() {
                return this._window
              }
              set window(e) {
                this._window !== e &&
                  ((this._window = e), this._onWindowChange.fire(this._window))
              }
              get dpr() {
                return this.window.devicePixelRatio
              }
              get isFocused() {
                return (
                  void 0 === this._cachedIsFocused &&
                    ((this._cachedIsFocused =
                      this._isFocused &&
                      this._textarea.ownerDocument.hasFocus()),
                    queueMicrotask(() => (this._cachedIsFocused = void 0))),
                  this._cachedIsFocused
                )
              }
            }
            t.CoreBrowserService = a
            class s extends o.Disposable {
              static {
                __name(this, 'a')
              }
              constructor(e) {
                super(),
                  (this._parentWindow = e),
                  (this._windowResizeListener = this.register(
                    new o.MutableDisposable()
                  )),
                  (this._onDprChange = this.register(new i.EventEmitter())),
                  (this.onDprChange = this._onDprChange.event),
                  (this._outerListener = () => this._setDprAndFireIfDiffers()),
                  (this._currentDevicePixelRatio =
                    this._parentWindow.devicePixelRatio),
                  this._updateDpr(),
                  this._setWindowResizeListener(),
                  this.register((0, o.toDisposable)(() => this.clearListener()))
              }
              setWindow(e) {
                ;(this._parentWindow = e),
                  this._setWindowResizeListener(),
                  this._setDprAndFireIfDiffers()
              }
              _setWindowResizeListener() {
                this._windowResizeListener.value = (0,
                r.addDisposableDomListener)(this._parentWindow, 'resize', () =>
                  this._setDprAndFireIfDiffers()
                )
              }
              _setDprAndFireIfDiffers() {
                this._parentWindow.devicePixelRatio !==
                  this._currentDevicePixelRatio &&
                  this._onDprChange.fire(this._parentWindow.devicePixelRatio),
                  this._updateDpr()
              }
              _updateDpr() {
                this._outerListener &&
                  (this._resolutionMediaMatchList?.removeListener(
                    this._outerListener
                  ),
                  (this._currentDevicePixelRatio =
                    this._parentWindow.devicePixelRatio),
                  (this._resolutionMediaMatchList =
                    this._parentWindow.matchMedia(
                      `screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`
                    )),
                  this._resolutionMediaMatchList.addListener(
                    this._outerListener
                  ))
              }
              clearListener() {
                this._resolutionMediaMatchList &&
                  this._outerListener &&
                  (this._resolutionMediaMatchList.removeListener(
                    this._outerListener
                  ),
                  (this._resolutionMediaMatchList = void 0),
                  (this._outerListener = void 0))
              }
            }
          },
          779: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.LinkProviderService = void 0)
            const o = n(844)
            class i extends o.Disposable {
              static {
                __name(this, 'r')
              }
              constructor() {
                super(),
                  (this.linkProviders = []),
                  this.register(
                    (0, o.toDisposable)(() => (this.linkProviders.length = 0))
                  )
              }
              registerLinkProvider(e) {
                return (
                  this.linkProviders.push(e),
                  {
                    dispose: __name(() => {
                      const t = this.linkProviders.indexOf(e)
                      ;-1 !== t && this.linkProviders.splice(t, 1)
                    }, 'dispose')
                  }
                )
              }
            }
            t.LinkProviderService = i
          },
          8934: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.MouseService = void 0)
            const r = n(4725),
              a = n(9806)
            let s = (t.MouseService = class {
              constructor(e, t) {
                ;(this._renderService = e), (this._charSizeService = t)
              }
              getCoords(e, t, n, o, i) {
                return (0, a.getCoords)(
                  window,
                  e,
                  t,
                  n,
                  o,
                  this._charSizeService.hasValidSize,
                  this._renderService.dimensions.css.cell.width,
                  this._renderService.dimensions.css.cell.height,
                  i
                )
              }
              getMouseReportCoords(e, t) {
                const n = (0, a.getCoordsRelativeToElement)(window, e, t)
                if (this._charSizeService.hasValidSize)
                  return (
                    (n[0] = Math.min(
                      Math.max(n[0], 0),
                      this._renderService.dimensions.css.canvas.width - 1
                    )),
                    (n[1] = Math.min(
                      Math.max(n[1], 0),
                      this._renderService.dimensions.css.canvas.height - 1
                    )),
                    {
                      col: Math.floor(
                        n[0] / this._renderService.dimensions.css.cell.width
                      ),
                      row: Math.floor(
                        n[1] / this._renderService.dimensions.css.cell.height
                      ),
                      x: Math.floor(n[0]),
                      y: Math.floor(n[1])
                    }
                  )
              }
            })
            t.MouseService = s = o(
              [i(0, r.IRenderService), i(1, r.ICharSizeService)],
              s
            )
          },
          3230: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.RenderService = void 0)
            const r = n(6193),
              a = n(4725),
              s = n(8460),
              l = n(844),
              c = n(7226),
              d = n(2585)
            let u = (t.RenderService = class extends l.Disposable {
              get dimensions() {
                return this._renderer.value.dimensions
              }
              constructor(e, t, n, o, i, a, d, u) {
                super(),
                  (this._rowCount = e),
                  (this._charSizeService = o),
                  (this._renderer = this.register(new l.MutableDisposable())),
                  (this._pausedResizeTask = new c.DebouncedIdleTask()),
                  (this._observerDisposable = this.register(
                    new l.MutableDisposable()
                  )),
                  (this._isPaused = !1),
                  (this._needsFullRefresh = !1),
                  (this._isNextRenderRedrawOnly = !0),
                  (this._needsSelectionRefresh = !1),
                  (this._canvasWidth = 0),
                  (this._canvasHeight = 0),
                  (this._selectionState = {
                    start: void 0,
                    end: void 0,
                    columnSelectMode: !1
                  }),
                  (this._onDimensionsChange = this.register(
                    new s.EventEmitter()
                  )),
                  (this.onDimensionsChange = this._onDimensionsChange.event),
                  (this._onRenderedViewportChange = this.register(
                    new s.EventEmitter()
                  )),
                  (this.onRenderedViewportChange =
                    this._onRenderedViewportChange.event),
                  (this._onRender = this.register(new s.EventEmitter())),
                  (this.onRender = this._onRender.event),
                  (this._onRefreshRequest = this.register(
                    new s.EventEmitter()
                  )),
                  (this.onRefreshRequest = this._onRefreshRequest.event),
                  (this._renderDebouncer = new r.RenderDebouncer(
                    (e, t) => this._renderRows(e, t),
                    d
                  )),
                  this.register(this._renderDebouncer),
                  this.register(
                    d.onDprChange(() => this.handleDevicePixelRatioChange())
                  ),
                  this.register(a.onResize(() => this._fullRefresh())),
                  this.register(
                    a.buffers.onBufferActivate(() =>
                      this._renderer.value?.clear()
                    )
                  ),
                  this.register(
                    n.onOptionChange(() => this._handleOptionsChanged())
                  ),
                  this.register(
                    this._charSizeService.onCharSizeChange(() =>
                      this.handleCharSizeChanged()
                    )
                  ),
                  this.register(
                    i.onDecorationRegistered(() => this._fullRefresh())
                  ),
                  this.register(
                    i.onDecorationRemoved(() => this._fullRefresh())
                  ),
                  this.register(
                    n.onMultipleOptionChange(
                      [
                        'customGlyphs',
                        'drawBoldTextInBrightColors',
                        'letterSpacing',
                        'lineHeight',
                        'fontFamily',
                        'fontSize',
                        'fontWeight',
                        'fontWeightBold',
                        'minimumContrastRatio',
                        'rescaleOverlappingGlyphs'
                      ],
                      () => {
                        this.clear(),
                          this.handleResize(a.cols, a.rows),
                          this._fullRefresh()
                      }
                    )
                  ),
                  this.register(
                    n.onMultipleOptionChange(
                      ['cursorBlink', 'cursorStyle'],
                      () => this.refreshRows(a.buffer.y, a.buffer.y, !0)
                    )
                  ),
                  this.register(u.onChangeColors(() => this._fullRefresh())),
                  this._registerIntersectionObserver(d.window, t),
                  this.register(
                    d.onWindowChange((e) =>
                      this._registerIntersectionObserver(e, t)
                    )
                  )
              }
              _registerIntersectionObserver(e, t) {
                if ('IntersectionObserver' in e) {
                  const n = new e.IntersectionObserver(
                    (e) => this._handleIntersectionChange(e[e.length - 1]),
                    { threshold: 0 }
                  )
                  n.observe(t),
                    (this._observerDisposable.value = (0, l.toDisposable)(() =>
                      n.disconnect()
                    ))
                }
              }
              _handleIntersectionChange(e) {
                ;(this._isPaused =
                  void 0 === e.isIntersecting
                    ? 0 === e.intersectionRatio
                    : !e.isIntersecting),
                  this._isPaused ||
                    this._charSizeService.hasValidSize ||
                    this._charSizeService.measure(),
                  !this._isPaused &&
                    this._needsFullRefresh &&
                    (this._pausedResizeTask.flush(),
                    this.refreshRows(0, this._rowCount - 1),
                    (this._needsFullRefresh = !1))
              }
              refreshRows(e, t, n = !1) {
                this._isPaused
                  ? (this._needsFullRefresh = !0)
                  : (n || (this._isNextRenderRedrawOnly = !1),
                    this._renderDebouncer.refresh(e, t, this._rowCount))
              }
              _renderRows(e, t) {
                this._renderer.value &&
                  ((e = Math.min(e, this._rowCount - 1)),
                  (t = Math.min(t, this._rowCount - 1)),
                  this._renderer.value.renderRows(e, t),
                  this._needsSelectionRefresh &&
                    (this._renderer.value.handleSelectionChanged(
                      this._selectionState.start,
                      this._selectionState.end,
                      this._selectionState.columnSelectMode
                    ),
                    (this._needsSelectionRefresh = !1)),
                  this._isNextRenderRedrawOnly ||
                    this._onRenderedViewportChange.fire({ start: e, end: t }),
                  this._onRender.fire({ start: e, end: t }),
                  (this._isNextRenderRedrawOnly = !0))
              }
              resize(e, t) {
                ;(this._rowCount = t), this._fireOnCanvasResize()
              }
              _handleOptionsChanged() {
                this._renderer.value &&
                  (this.refreshRows(0, this._rowCount - 1),
                  this._fireOnCanvasResize())
              }
              _fireOnCanvasResize() {
                this._renderer.value &&
                  ((this._renderer.value.dimensions.css.canvas.width ===
                    this._canvasWidth &&
                    this._renderer.value.dimensions.css.canvas.height ===
                      this._canvasHeight) ||
                    this._onDimensionsChange.fire(
                      this._renderer.value.dimensions
                    ))
              }
              hasRenderer() {
                return !!this._renderer.value
              }
              setRenderer(e) {
                ;(this._renderer.value = e),
                  this._renderer.value &&
                    (this._renderer.value.onRequestRedraw((e) =>
                      this.refreshRows(e.start, e.end, !0)
                    ),
                    (this._needsSelectionRefresh = !0),
                    this._fullRefresh())
              }
              addRefreshCallback(e) {
                return this._renderDebouncer.addRefreshCallback(e)
              }
              _fullRefresh() {
                this._isPaused
                  ? (this._needsFullRefresh = !0)
                  : this.refreshRows(0, this._rowCount - 1)
              }
              clearTextureAtlas() {
                this._renderer.value &&
                  (this._renderer.value.clearTextureAtlas?.(),
                  this._fullRefresh())
              }
              handleDevicePixelRatioChange() {
                this._charSizeService.measure(),
                  this._renderer.value &&
                    (this._renderer.value.handleDevicePixelRatioChange(),
                    this.refreshRows(0, this._rowCount - 1))
              }
              handleResize(e, t) {
                this._renderer.value &&
                  (this._isPaused
                    ? this._pausedResizeTask.set(() =>
                        this._renderer.value?.handleResize(e, t)
                      )
                    : this._renderer.value.handleResize(e, t),
                  this._fullRefresh())
              }
              handleCharSizeChanged() {
                this._renderer.value?.handleCharSizeChanged()
              }
              handleBlur() {
                this._renderer.value?.handleBlur()
              }
              handleFocus() {
                this._renderer.value?.handleFocus()
              }
              handleSelectionChanged(e, t, n) {
                ;(this._selectionState.start = e),
                  (this._selectionState.end = t),
                  (this._selectionState.columnSelectMode = n),
                  this._renderer.value?.handleSelectionChanged(e, t, n)
              }
              handleCursorMove() {
                this._renderer.value?.handleCursorMove()
              }
              clear() {
                this._renderer.value?.clear()
              }
            })
            t.RenderService = u = o(
              [
                i(2, d.IOptionsService),
                i(3, a.ICharSizeService),
                i(4, d.IDecorationService),
                i(5, d.IBufferService),
                i(6, a.ICoreBrowserService),
                i(7, a.IThemeService)
              ],
              u
            )
          },
          9312: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.SelectionService = void 0)
            const r = n(9806),
              a = n(9504),
              s = n(456),
              l = n(4725),
              c = n(8460),
              d = n(844),
              u = n(6114),
              p = n(4841),
              h = n(511),
              m = n(2585),
              f = String.fromCharCode(160),
              _ = new RegExp(f, 'g')
            let g = (t.SelectionService = class extends d.Disposable {
              constructor(e, t, n, o, i, r, a, l, u) {
                super(),
                  (this._element = e),
                  (this._screenElement = t),
                  (this._linkifier = n),
                  (this._bufferService = o),
                  (this._coreService = i),
                  (this._mouseService = r),
                  (this._optionsService = a),
                  (this._renderService = l),
                  (this._coreBrowserService = u),
                  (this._dragScrollAmount = 0),
                  (this._enabled = !0),
                  (this._workCell = new h.CellData()),
                  (this._mouseDownTimeStamp = 0),
                  (this._oldHasSelection = !1),
                  (this._oldSelectionStart = void 0),
                  (this._oldSelectionEnd = void 0),
                  (this._onLinuxMouseSelection = this.register(
                    new c.EventEmitter()
                  )),
                  (this.onLinuxMouseSelection =
                    this._onLinuxMouseSelection.event),
                  (this._onRedrawRequest = this.register(new c.EventEmitter())),
                  (this.onRequestRedraw = this._onRedrawRequest.event),
                  (this._onSelectionChange = this.register(
                    new c.EventEmitter()
                  )),
                  (this.onSelectionChange = this._onSelectionChange.event),
                  (this._onRequestScrollLines = this.register(
                    new c.EventEmitter()
                  )),
                  (this.onRequestScrollLines =
                    this._onRequestScrollLines.event),
                  (this._mouseMoveListener = (e) => this._handleMouseMove(e)),
                  (this._mouseUpListener = (e) => this._handleMouseUp(e)),
                  this._coreService.onUserInput(() => {
                    this.hasSelection && this.clearSelection()
                  }),
                  (this._trimListener = this._bufferService.buffer.lines.onTrim(
                    (e) => this._handleTrim(e)
                  )),
                  this.register(
                    this._bufferService.buffers.onBufferActivate((e) =>
                      this._handleBufferActivate(e)
                    )
                  ),
                  this.enable(),
                  (this._model = new s.SelectionModel(this._bufferService)),
                  (this._activeSelectionMode = 0),
                  this.register(
                    (0, d.toDisposable)(() => {
                      this._removeMouseDownListeners()
                    })
                  )
              }
              reset() {
                this.clearSelection()
              }
              disable() {
                this.clearSelection(), (this._enabled = !1)
              }
              enable() {
                this._enabled = !0
              }
              get selectionStart() {
                return this._model.finalSelectionStart
              }
              get selectionEnd() {
                return this._model.finalSelectionEnd
              }
              get hasSelection() {
                const e = this._model.finalSelectionStart,
                  t = this._model.finalSelectionEnd
                return !(!e || !t || (e[0] === t[0] && e[1] === t[1]))
              }
              get selectionText() {
                const e = this._model.finalSelectionStart,
                  t = this._model.finalSelectionEnd
                if (!e || !t) return ''
                const n = this._bufferService.buffer,
                  o = []
                if (3 === this._activeSelectionMode) {
                  if (e[0] === t[0]) return ''
                  const i = e[0] < t[0] ? e[0] : t[0],
                    r = e[0] < t[0] ? t[0] : e[0]
                  for (let a = e[1]; a <= t[1]; a++) {
                    const e = n.translateBufferLineToString(a, !0, i, r)
                    o.push(e)
                  }
                } else {
                  const i = e[1] === t[1] ? t[0] : void 0
                  o.push(n.translateBufferLineToString(e[1], !0, e[0], i))
                  for (let r = e[1] + 1; r <= t[1] - 1; r++) {
                    const e = n.lines.get(r),
                      t = n.translateBufferLineToString(r, !0)
                    e?.isWrapped ? (o[o.length - 1] += t) : o.push(t)
                  }
                  if (e[1] !== t[1]) {
                    const e = n.lines.get(t[1]),
                      i = n.translateBufferLineToString(t[1], !0, 0, t[0])
                    e && e.isWrapped ? (o[o.length - 1] += i) : o.push(i)
                  }
                }
                return o
                  .map((e) => e.replace(_, ' '))
                  .join(u.isWindows ? '\r\n' : '\n')
              }
              clearSelection() {
                this._model.clearSelection(),
                  this._removeMouseDownListeners(),
                  this.refresh(),
                  this._onSelectionChange.fire()
              }
              refresh(e) {
                this._refreshAnimationFrame ||
                  (this._refreshAnimationFrame =
                    this._coreBrowserService.window.requestAnimationFrame(() =>
                      this._refresh()
                    )),
                  u.isLinux &&
                    e &&
                    this.selectionText.length &&
                    this._onLinuxMouseSelection.fire(this.selectionText)
              }
              _refresh() {
                ;(this._refreshAnimationFrame = void 0),
                  this._onRedrawRequest.fire({
                    start: this._model.finalSelectionStart,
                    end: this._model.finalSelectionEnd,
                    columnSelectMode: 3 === this._activeSelectionMode
                  })
              }
              _isClickInSelection(e) {
                const t = this._getMouseBufferCoords(e),
                  n = this._model.finalSelectionStart,
                  o = this._model.finalSelectionEnd
                return !!(n && o && t) && this._areCoordsInSelection(t, n, o)
              }
              isCellInSelection(e, t) {
                const n = this._model.finalSelectionStart,
                  o = this._model.finalSelectionEnd
                return !(!n || !o) && this._areCoordsInSelection([e, t], n, o)
              }
              _areCoordsInSelection(e, t, n) {
                return (
                  (e[1] > t[1] && e[1] < n[1]) ||
                  (t[1] === n[1] &&
                    e[1] === t[1] &&
                    e[0] >= t[0] &&
                    e[0] < n[0]) ||
                  (t[1] < n[1] && e[1] === n[1] && e[0] < n[0]) ||
                  (t[1] < n[1] && e[1] === t[1] && e[0] >= t[0])
                )
              }
              _selectWordAtCursor(e, t) {
                const n = this._linkifier.currentLink?.link?.range
                if (n)
                  return (
                    (this._model.selectionStart = [
                      n.start.x - 1,
                      n.start.y - 1
                    ]),
                    (this._model.selectionStartLength = (0, p.getRangeLength)(
                      n,
                      this._bufferService.cols
                    )),
                    (this._model.selectionEnd = void 0),
                    !0
                  )
                const o = this._getMouseBufferCoords(e)
                return (
                  !!o &&
                  (this._selectWordAt(o, t),
                  (this._model.selectionEnd = void 0),
                  !0)
                )
              }
              selectAll() {
                ;(this._model.isSelectAllActive = !0),
                  this.refresh(),
                  this._onSelectionChange.fire()
              }
              selectLines(e, t) {
                this._model.clearSelection(),
                  (e = Math.max(e, 0)),
                  (t = Math.min(
                    t,
                    this._bufferService.buffer.lines.length - 1
                  )),
                  (this._model.selectionStart = [0, e]),
                  (this._model.selectionEnd = [this._bufferService.cols, t]),
                  this.refresh(),
                  this._onSelectionChange.fire()
              }
              _handleTrim(e) {
                this._model.handleTrim(e) && this.refresh()
              }
              _getMouseBufferCoords(e) {
                const t = this._mouseService.getCoords(
                  e,
                  this._screenElement,
                  this._bufferService.cols,
                  this._bufferService.rows,
                  !0
                )
                if (t)
                  return (
                    t[0]--,
                    t[1]--,
                    (t[1] += this._bufferService.buffer.ydisp),
                    t
                  )
              }
              _getMouseEventScrollAmount(e) {
                let t = (0, r.getCoordsRelativeToElement)(
                  this._coreBrowserService.window,
                  e,
                  this._screenElement
                )[1]
                const n = this._renderService.dimensions.css.canvas.height
                return t >= 0 && t <= n
                  ? 0
                  : (t > n && (t -= n),
                    (t = Math.min(Math.max(t, -50), 50)),
                    (t /= 50),
                    t / Math.abs(t) + Math.round(14 * t))
              }
              shouldForceSelection(e) {
                return u.isMac
                  ? e.altKey &&
                      this._optionsService.rawOptions
                        .macOptionClickForcesSelection
                  : e.shiftKey
              }
              handleMouseDown(e) {
                if (
                  ((this._mouseDownTimeStamp = e.timeStamp),
                  (2 !== e.button || !this.hasSelection) && 0 === e.button)
                ) {
                  if (!this._enabled) {
                    if (!this.shouldForceSelection(e)) return
                    e.stopPropagation()
                  }
                  e.preventDefault(),
                    (this._dragScrollAmount = 0),
                    this._enabled && e.shiftKey
                      ? this._handleIncrementalClick(e)
                      : 1 === e.detail
                        ? this._handleSingleClick(e)
                        : 2 === e.detail
                          ? this._handleDoubleClick(e)
                          : 3 === e.detail && this._handleTripleClick(e),
                    this._addMouseDownListeners(),
                    this.refresh(!0)
                }
              }
              _addMouseDownListeners() {
                this._screenElement.ownerDocument &&
                  (this._screenElement.ownerDocument.addEventListener(
                    'mousemove',
                    this._mouseMoveListener
                  ),
                  this._screenElement.ownerDocument.addEventListener(
                    'mouseup',
                    this._mouseUpListener
                  )),
                  (this._dragScrollIntervalTimer =
                    this._coreBrowserService.window.setInterval(
                      () => this._dragScroll(),
                      50
                    ))
              }
              _removeMouseDownListeners() {
                this._screenElement.ownerDocument &&
                  (this._screenElement.ownerDocument.removeEventListener(
                    'mousemove',
                    this._mouseMoveListener
                  ),
                  this._screenElement.ownerDocument.removeEventListener(
                    'mouseup',
                    this._mouseUpListener
                  )),
                  this._coreBrowserService.window.clearInterval(
                    this._dragScrollIntervalTimer
                  ),
                  (this._dragScrollIntervalTimer = void 0)
              }
              _handleIncrementalClick(e) {
                this._model.selectionStart &&
                  (this._model.selectionEnd = this._getMouseBufferCoords(e))
              }
              _handleSingleClick(e) {
                if (
                  ((this._model.selectionStartLength = 0),
                  (this._model.isSelectAllActive = !1),
                  (this._activeSelectionMode = this.shouldColumnSelect(e)
                    ? 3
                    : 0),
                  (this._model.selectionStart = this._getMouseBufferCoords(e)),
                  !this._model.selectionStart)
                )
                  return
                this._model.selectionEnd = void 0
                const t = this._bufferService.buffer.lines.get(
                  this._model.selectionStart[1]
                )
                t &&
                  t.length !== this._model.selectionStart[0] &&
                  0 === t.hasWidth(this._model.selectionStart[0]) &&
                  this._model.selectionStart[0]++
              }
              _handleDoubleClick(e) {
                this._selectWordAtCursor(e, !0) &&
                  (this._activeSelectionMode = 1)
              }
              _handleTripleClick(e) {
                const t = this._getMouseBufferCoords(e)
                t && ((this._activeSelectionMode = 2), this._selectLineAt(t[1]))
              }
              shouldColumnSelect(e) {
                return (
                  e.altKey &&
                  !(
                    u.isMac &&
                    this._optionsService.rawOptions
                      .macOptionClickForcesSelection
                  )
                )
              }
              _handleMouseMove(e) {
                if ((e.stopImmediatePropagation(), !this._model.selectionStart))
                  return
                const t = this._model.selectionEnd
                  ? [this._model.selectionEnd[0], this._model.selectionEnd[1]]
                  : null
                if (
                  ((this._model.selectionEnd = this._getMouseBufferCoords(e)),
                  !this._model.selectionEnd)
                )
                  return void this.refresh(!0)
                2 === this._activeSelectionMode
                  ? this._model.selectionEnd[1] < this._model.selectionStart[1]
                    ? (this._model.selectionEnd[0] = 0)
                    : (this._model.selectionEnd[0] = this._bufferService.cols)
                  : 1 === this._activeSelectionMode &&
                    this._selectToWordAt(this._model.selectionEnd),
                  (this._dragScrollAmount = this._getMouseEventScrollAmount(e)),
                  3 !== this._activeSelectionMode &&
                    (this._dragScrollAmount > 0
                      ? (this._model.selectionEnd[0] = this._bufferService.cols)
                      : this._dragScrollAmount < 0 &&
                        (this._model.selectionEnd[0] = 0))
                const n = this._bufferService.buffer
                if (this._model.selectionEnd[1] < n.lines.length) {
                  const e = n.lines.get(this._model.selectionEnd[1])
                  e &&
                    0 === e.hasWidth(this._model.selectionEnd[0]) &&
                    this._model.selectionEnd[0] < this._bufferService.cols &&
                    this._model.selectionEnd[0]++
                }
                ;(t &&
                  t[0] === this._model.selectionEnd[0] &&
                  t[1] === this._model.selectionEnd[1]) ||
                  this.refresh(!0)
              }
              _dragScroll() {
                if (
                  this._model.selectionEnd &&
                  this._model.selectionStart &&
                  this._dragScrollAmount
                ) {
                  this._onRequestScrollLines.fire({
                    amount: this._dragScrollAmount,
                    suppressScrollEvent: !1
                  })
                  const e = this._bufferService.buffer
                  this._dragScrollAmount > 0
                    ? (3 !== this._activeSelectionMode &&
                        (this._model.selectionEnd[0] =
                          this._bufferService.cols),
                      (this._model.selectionEnd[1] = Math.min(
                        e.ydisp + this._bufferService.rows,
                        e.lines.length - 1
                      )))
                    : (3 !== this._activeSelectionMode &&
                        (this._model.selectionEnd[0] = 0),
                      (this._model.selectionEnd[1] = e.ydisp)),
                    this.refresh()
                }
              }
              _handleMouseUp(e) {
                const t = e.timeStamp - this._mouseDownTimeStamp
                if (
                  (this._removeMouseDownListeners(),
                  this.selectionText.length <= 1 &&
                    t < 500 &&
                    e.altKey &&
                    this._optionsService.rawOptions.altClickMovesCursor)
                ) {
                  if (
                    this._bufferService.buffer.ybase ===
                    this._bufferService.buffer.ydisp
                  ) {
                    const t = this._mouseService.getCoords(
                      e,
                      this._element,
                      this._bufferService.cols,
                      this._bufferService.rows,
                      !1
                    )
                    if (t && void 0 !== t[0] && void 0 !== t[1]) {
                      const e = (0, a.moveToCellSequence)(
                        t[0] - 1,
                        t[1] - 1,
                        this._bufferService,
                        this._coreService.decPrivateModes.applicationCursorKeys
                      )
                      this._coreService.triggerDataEvent(e, !0)
                    }
                  }
                } else this._fireEventIfSelectionChanged()
              }
              _fireEventIfSelectionChanged() {
                const e = this._model.finalSelectionStart,
                  t = this._model.finalSelectionEnd,
                  n = !(!e || !t || (e[0] === t[0] && e[1] === t[1]))
                n
                  ? e &&
                    t &&
                    ((this._oldSelectionStart &&
                      this._oldSelectionEnd &&
                      e[0] === this._oldSelectionStart[0] &&
                      e[1] === this._oldSelectionStart[1] &&
                      t[0] === this._oldSelectionEnd[0] &&
                      t[1] === this._oldSelectionEnd[1]) ||
                      this._fireOnSelectionChange(e, t, n))
                  : this._oldHasSelection &&
                    this._fireOnSelectionChange(e, t, n)
              }
              _fireOnSelectionChange(e, t, n) {
                ;(this._oldSelectionStart = e),
                  (this._oldSelectionEnd = t),
                  (this._oldHasSelection = n),
                  this._onSelectionChange.fire()
              }
              _handleBufferActivate(e) {
                this.clearSelection(),
                  this._trimListener.dispose(),
                  (this._trimListener = e.activeBuffer.lines.onTrim((e) =>
                    this._handleTrim(e)
                  ))
              }
              _convertViewportColToCharacterIndex(e, t) {
                let n = t
                for (let o = 0; t >= o; o++) {
                  const i = e.loadCell(o, this._workCell).getChars().length
                  0 === this._workCell.getWidth()
                    ? n--
                    : i > 1 && t !== o && (n += i - 1)
                }
                return n
              }
              setSelection(e, t, n) {
                this._model.clearSelection(),
                  this._removeMouseDownListeners(),
                  (this._model.selectionStart = [e, t]),
                  (this._model.selectionStartLength = n),
                  this.refresh(),
                  this._fireEventIfSelectionChanged()
              }
              rightClickSelect(e) {
                this._isClickInSelection(e) ||
                  (this._selectWordAtCursor(e, !1) && this.refresh(!0),
                  this._fireEventIfSelectionChanged())
              }
              _getWordAt(e, t, n = !0, o = !0) {
                if (e[0] >= this._bufferService.cols) return
                const i = this._bufferService.buffer,
                  r = i.lines.get(e[1])
                if (!r) return
                const a = i.translateBufferLineToString(e[1], !1)
                let s = this._convertViewportColToCharacterIndex(r, e[0]),
                  l = s
                const c = e[0] - s
                let d = 0,
                  u = 0,
                  p = 0,
                  h = 0
                if (' ' === a.charAt(s)) {
                  for (; s > 0 && ' ' === a.charAt(s - 1); ) s--
                  for (; l < a.length && ' ' === a.charAt(l + 1); ) l++
                } else {
                  let t = e[0],
                    n = e[0]
                  0 === r.getWidth(t) && (d++, t--),
                    2 === r.getWidth(n) && (u++, n++)
                  const o = r.getString(n).length
                  for (
                    o > 1 && ((h += o - 1), (l += o - 1));
                    t > 0 &&
                    s > 0 &&
                    !this._isCharWordSeparator(
                      r.loadCell(t - 1, this._workCell)
                    );

                  ) {
                    r.loadCell(t - 1, this._workCell)
                    const e = this._workCell.getChars().length
                    0 === this._workCell.getWidth()
                      ? (d++, t--)
                      : e > 1 && ((p += e - 1), (s -= e - 1)),
                      s--,
                      t--
                  }
                  for (
                    ;
                    n < r.length &&
                    l + 1 < a.length &&
                    !this._isCharWordSeparator(
                      r.loadCell(n + 1, this._workCell)
                    );

                  ) {
                    r.loadCell(n + 1, this._workCell)
                    const e = this._workCell.getChars().length
                    2 === this._workCell.getWidth()
                      ? (u++, n++)
                      : e > 1 && ((h += e - 1), (l += e - 1)),
                      l++,
                      n++
                  }
                }
                l++
                let m = s + c - d + p,
                  f = Math.min(this._bufferService.cols, l - s + d + u - p - h)
                if (t || '' !== a.slice(s, l).trim()) {
                  if (n && 0 === m && 32 !== r.getCodePoint(0)) {
                    const t = i.lines.get(e[1] - 1)
                    if (
                      t &&
                      r.isWrapped &&
                      32 !== t.getCodePoint(this._bufferService.cols - 1)
                    ) {
                      const t = this._getWordAt(
                        [this._bufferService.cols - 1, e[1] - 1],
                        !1,
                        !0,
                        !1
                      )
                      if (t) {
                        const e = this._bufferService.cols - t.start
                        ;(m -= e), (f += e)
                      }
                    }
                  }
                  if (
                    o &&
                    m + f === this._bufferService.cols &&
                    32 !== r.getCodePoint(this._bufferService.cols - 1)
                  ) {
                    const t = i.lines.get(e[1] + 1)
                    if (t?.isWrapped && 32 !== t.getCodePoint(0)) {
                      const t = this._getWordAt([0, e[1] + 1], !1, !1, !0)
                      t && (f += t.length)
                    }
                  }
                  return { start: m, length: f }
                }
              }
              _selectWordAt(e, t) {
                const n = this._getWordAt(e, t)
                if (n) {
                  for (; n.start < 0; )
                    (n.start += this._bufferService.cols), e[1]--
                  ;(this._model.selectionStart = [n.start, e[1]]),
                    (this._model.selectionStartLength = n.length)
                }
              }
              _selectToWordAt(e) {
                const t = this._getWordAt(e, !0)
                if (t) {
                  let n = e[1]
                  for (; t.start < 0; )
                    (t.start += this._bufferService.cols), n--
                  if (!this._model.areSelectionValuesReversed())
                    for (; t.start + t.length > this._bufferService.cols; )
                      (t.length -= this._bufferService.cols), n++
                  this._model.selectionEnd = [
                    this._model.areSelectionValuesReversed()
                      ? t.start
                      : t.start + t.length,
                    n
                  ]
                }
              }
              _isCharWordSeparator(e) {
                return (
                  0 !== e.getWidth() &&
                  this._optionsService.rawOptions.wordSeparator.indexOf(
                    e.getChars()
                  ) >= 0
                )
              }
              _selectLineAt(e) {
                const t = this._bufferService.buffer.getWrappedRangeForLine(e),
                  n = {
                    start: { x: 0, y: t.first },
                    end: { x: this._bufferService.cols - 1, y: t.last }
                  }
                ;(this._model.selectionStart = [0, t.first]),
                  (this._model.selectionEnd = void 0),
                  (this._model.selectionStartLength = (0, p.getRangeLength)(
                    n,
                    this._bufferService.cols
                  ))
              }
            })
            t.SelectionService = g = o(
              [
                i(3, m.IBufferService),
                i(4, m.ICoreService),
                i(5, l.IMouseService),
                i(6, m.IOptionsService),
                i(7, l.IRenderService),
                i(8, l.ICoreBrowserService)
              ],
              g
            )
          },
          4725: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ILinkProviderService =
                t.IThemeService =
                t.ICharacterJoinerService =
                t.ISelectionService =
                t.IRenderService =
                t.IMouseService =
                t.ICoreBrowserService =
                t.ICharSizeService =
                  void 0)
            const o = n(8343)
            ;(t.ICharSizeService = (0, o.createDecorator)('CharSizeService')),
              (t.ICoreBrowserService = (0, o.createDecorator)(
                'CoreBrowserService'
              )),
              (t.IMouseService = (0, o.createDecorator)('MouseService')),
              (t.IRenderService = (0, o.createDecorator)('RenderService')),
              (t.ISelectionService = (0, o.createDecorator)(
                'SelectionService'
              )),
              (t.ICharacterJoinerService = (0, o.createDecorator)(
                'CharacterJoinerService'
              )),
              (t.IThemeService = (0, o.createDecorator)('ThemeService')),
              (t.ILinkProviderService = (0, o.createDecorator)(
                'LinkProviderService'
              ))
          },
          6731: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ThemeService = t.DEFAULT_ANSI_COLORS = void 0)
            const r = n(7239),
              a = n(8055),
              s = n(8460),
              l = n(844),
              c = n(2585),
              d = a.css.toColor('#ffffff'),
              u = a.css.toColor('#000000'),
              p = a.css.toColor('#ffffff'),
              h = a.css.toColor('#000000'),
              m = { css: 'rgba(255, 255, 255, 0.3)', rgba: 4294967117 }
            t.DEFAULT_ANSI_COLORS = Object.freeze(
              (() => {
                const e = [
                    a.css.toColor('#2e3436'),
                    a.css.toColor('#cc0000'),
                    a.css.toColor('#4e9a06'),
                    a.css.toColor('#c4a000'),
                    a.css.toColor('#3465a4'),
                    a.css.toColor('#75507b'),
                    a.css.toColor('#06989a'),
                    a.css.toColor('#d3d7cf'),
                    a.css.toColor('#555753'),
                    a.css.toColor('#ef2929'),
                    a.css.toColor('#8ae234'),
                    a.css.toColor('#fce94f'),
                    a.css.toColor('#729fcf'),
                    a.css.toColor('#ad7fa8'),
                    a.css.toColor('#34e2e2'),
                    a.css.toColor('#eeeeec')
                  ],
                  t = [0, 95, 135, 175, 215, 255]
                for (let n = 0; n < 216; n++) {
                  const o = t[(n / 36) % 6 | 0],
                    i = t[(n / 6) % 6 | 0],
                    r = t[n % 6]
                  e.push({
                    css: a.channels.toCss(o, i, r),
                    rgba: a.channels.toRgba(o, i, r)
                  })
                }
                for (let n = 0; n < 24; n++) {
                  const t = 8 + 10 * n
                  e.push({
                    css: a.channels.toCss(t, t, t),
                    rgba: a.channels.toRgba(t, t, t)
                  })
                }
                return e
              })()
            )
            let f = (t.ThemeService = class extends l.Disposable {
              get colors() {
                return this._colors
              }
              constructor(e) {
                super(),
                  (this._optionsService = e),
                  (this._contrastCache = new r.ColorContrastCache()),
                  (this._halfContrastCache = new r.ColorContrastCache()),
                  (this._onChangeColors = this.register(new s.EventEmitter())),
                  (this.onChangeColors = this._onChangeColors.event),
                  (this._colors = {
                    foreground: d,
                    background: u,
                    cursor: p,
                    cursorAccent: h,
                    selectionForeground: void 0,
                    selectionBackgroundTransparent: m,
                    selectionBackgroundOpaque: a.color.blend(u, m),
                    selectionInactiveBackgroundTransparent: m,
                    selectionInactiveBackgroundOpaque: a.color.blend(u, m),
                    ansi: t.DEFAULT_ANSI_COLORS.slice(),
                    contrastCache: this._contrastCache,
                    halfContrastCache: this._halfContrastCache
                  }),
                  this._updateRestoreColors(),
                  this._setTheme(this._optionsService.rawOptions.theme),
                  this.register(
                    this._optionsService.onSpecificOptionChange(
                      'minimumContrastRatio',
                      () => this._contrastCache.clear()
                    )
                  ),
                  this.register(
                    this._optionsService.onSpecificOptionChange('theme', () =>
                      this._setTheme(this._optionsService.rawOptions.theme)
                    )
                  )
              }
              _setTheme(e = {}) {
                const n = this._colors
                if (
                  ((n.foreground = _(e.foreground, d)),
                  (n.background = _(e.background, u)),
                  (n.cursor = _(e.cursor, p)),
                  (n.cursorAccent = _(e.cursorAccent, h)),
                  (n.selectionBackgroundTransparent = _(
                    e.selectionBackground,
                    m
                  )),
                  (n.selectionBackgroundOpaque = a.color.blend(
                    n.background,
                    n.selectionBackgroundTransparent
                  )),
                  (n.selectionInactiveBackgroundTransparent = _(
                    e.selectionInactiveBackground,
                    n.selectionBackgroundTransparent
                  )),
                  (n.selectionInactiveBackgroundOpaque = a.color.blend(
                    n.background,
                    n.selectionInactiveBackgroundTransparent
                  )),
                  (n.selectionForeground = e.selectionForeground
                    ? _(e.selectionForeground, a.NULL_COLOR)
                    : void 0),
                  n.selectionForeground === a.NULL_COLOR &&
                    (n.selectionForeground = void 0),
                  a.color.isOpaque(n.selectionBackgroundTransparent))
                ) {
                  const e = 0.3
                  n.selectionBackgroundTransparent = a.color.opacity(
                    n.selectionBackgroundTransparent,
                    e
                  )
                }
                if (
                  a.color.isOpaque(n.selectionInactiveBackgroundTransparent)
                ) {
                  const e = 0.3
                  n.selectionInactiveBackgroundTransparent = a.color.opacity(
                    n.selectionInactiveBackgroundTransparent,
                    e
                  )
                }
                if (
                  ((n.ansi = t.DEFAULT_ANSI_COLORS.slice()),
                  (n.ansi[0] = _(e.black, t.DEFAULT_ANSI_COLORS[0])),
                  (n.ansi[1] = _(e.red, t.DEFAULT_ANSI_COLORS[1])),
                  (n.ansi[2] = _(e.green, t.DEFAULT_ANSI_COLORS[2])),
                  (n.ansi[3] = _(e.yellow, t.DEFAULT_ANSI_COLORS[3])),
                  (n.ansi[4] = _(e.blue, t.DEFAULT_ANSI_COLORS[4])),
                  (n.ansi[5] = _(e.magenta, t.DEFAULT_ANSI_COLORS[5])),
                  (n.ansi[6] = _(e.cyan, t.DEFAULT_ANSI_COLORS[6])),
                  (n.ansi[7] = _(e.white, t.DEFAULT_ANSI_COLORS[7])),
                  (n.ansi[8] = _(e.brightBlack, t.DEFAULT_ANSI_COLORS[8])),
                  (n.ansi[9] = _(e.brightRed, t.DEFAULT_ANSI_COLORS[9])),
                  (n.ansi[10] = _(e.brightGreen, t.DEFAULT_ANSI_COLORS[10])),
                  (n.ansi[11] = _(e.brightYellow, t.DEFAULT_ANSI_COLORS[11])),
                  (n.ansi[12] = _(e.brightBlue, t.DEFAULT_ANSI_COLORS[12])),
                  (n.ansi[13] = _(e.brightMagenta, t.DEFAULT_ANSI_COLORS[13])),
                  (n.ansi[14] = _(e.brightCyan, t.DEFAULT_ANSI_COLORS[14])),
                  (n.ansi[15] = _(e.brightWhite, t.DEFAULT_ANSI_COLORS[15])),
                  e.extendedAnsi)
                ) {
                  const o = Math.min(n.ansi.length - 16, e.extendedAnsi.length)
                  for (let i = 0; i < o; i++)
                    n.ansi[i + 16] = _(
                      e.extendedAnsi[i],
                      t.DEFAULT_ANSI_COLORS[i + 16]
                    )
                }
                this._contrastCache.clear(),
                  this._halfContrastCache.clear(),
                  this._updateRestoreColors(),
                  this._onChangeColors.fire(this.colors)
              }
              restoreColor(e) {
                this._restoreColor(e), this._onChangeColors.fire(this.colors)
              }
              _restoreColor(e) {
                if (void 0 !== e)
                  switch (e) {
                    case 256:
                      this._colors.foreground = this._restoreColors.foreground
                      break
                    case 257:
                      this._colors.background = this._restoreColors.background
                      break
                    case 258:
                      this._colors.cursor = this._restoreColors.cursor
                      break
                    default:
                      this._colors.ansi[e] = this._restoreColors.ansi[e]
                  }
                else
                  for (let t = 0; t < this._restoreColors.ansi.length; ++t)
                    this._colors.ansi[t] = this._restoreColors.ansi[t]
              }
              modifyColors(e) {
                e(this._colors), this._onChangeColors.fire(this.colors)
              }
              _updateRestoreColors() {
                this._restoreColors = {
                  foreground: this._colors.foreground,
                  background: this._colors.background,
                  cursor: this._colors.cursor,
                  ansi: this._colors.ansi.slice()
                }
              }
            })
            function _(e, t) {
              if (void 0 !== e)
                try {
                  return a.css.toColor(e)
                } catch {}
              return t
            }
            __name(_, 'p'),
              (t.ThemeService = f = o([i(0, c.IOptionsService)], f))
          },
          6349: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.CircularList = void 0)
            const o = n(8460),
              i = n(844)
            class r extends i.Disposable {
              static {
                __name(this, 'n')
              }
              constructor(e) {
                super(),
                  (this._maxLength = e),
                  (this.onDeleteEmitter = this.register(new o.EventEmitter())),
                  (this.onDelete = this.onDeleteEmitter.event),
                  (this.onInsertEmitter = this.register(new o.EventEmitter())),
                  (this.onInsert = this.onInsertEmitter.event),
                  (this.onTrimEmitter = this.register(new o.EventEmitter())),
                  (this.onTrim = this.onTrimEmitter.event),
                  (this._array = new Array(this._maxLength)),
                  (this._startIndex = 0),
                  (this._length = 0)
              }
              get maxLength() {
                return this._maxLength
              }
              set maxLength(e) {
                if (this._maxLength === e) return
                const t = new Array(e)
                for (let n = 0; n < Math.min(e, this.length); n++)
                  t[n] = this._array[this._getCyclicIndex(n)]
                ;(this._array = t),
                  (this._maxLength = e),
                  (this._startIndex = 0)
              }
              get length() {
                return this._length
              }
              set length(e) {
                if (e > this._length)
                  for (let t = this._length; t < e; t++) this._array[t] = void 0
                this._length = e
              }
              get(e) {
                return this._array[this._getCyclicIndex(e)]
              }
              set(e, t) {
                this._array[this._getCyclicIndex(e)] = t
              }
              push(e) {
                ;(this._array[this._getCyclicIndex(this._length)] = e),
                  this._length === this._maxLength
                    ? ((this._startIndex =
                        ++this._startIndex % this._maxLength),
                      this.onTrimEmitter.fire(1))
                    : this._length++
              }
              recycle() {
                if (this._length !== this._maxLength)
                  throw new Error('Can only recycle when the buffer is full')
                return (
                  (this._startIndex = ++this._startIndex % this._maxLength),
                  this.onTrimEmitter.fire(1),
                  this._array[this._getCyclicIndex(this._length - 1)]
                )
              }
              get isFull() {
                return this._length === this._maxLength
              }
              pop() {
                return this._array[this._getCyclicIndex(this._length-- - 1)]
              }
              splice(e, t, ...n) {
                if (t) {
                  for (let n = e; n < this._length - t; n++)
                    this._array[this._getCyclicIndex(n)] =
                      this._array[this._getCyclicIndex(n + t)]
                  ;(this._length -= t),
                    this.onDeleteEmitter.fire({ index: e, amount: t })
                }
                for (let o = this._length - 1; o >= e; o--)
                  this._array[this._getCyclicIndex(o + n.length)] =
                    this._array[this._getCyclicIndex(o)]
                for (let o = 0; o < n.length; o++)
                  this._array[this._getCyclicIndex(e + o)] = n[o]
                if (
                  (n.length &&
                    this.onInsertEmitter.fire({ index: e, amount: n.length }),
                  this._length + n.length > this._maxLength)
                ) {
                  const e = this._length + n.length - this._maxLength
                  ;(this._startIndex += e),
                    (this._length = this._maxLength),
                    this.onTrimEmitter.fire(e)
                } else this._length += n.length
              }
              trimStart(e) {
                e > this._length && (e = this._length),
                  (this._startIndex += e),
                  (this._length -= e),
                  this.onTrimEmitter.fire(e)
              }
              shiftElements(e, t, n) {
                if (!(t <= 0)) {
                  if (e < 0 || e >= this._length)
                    throw new Error('start argument out of range')
                  if (e + n < 0)
                    throw new Error(
                      'Cannot shift elements in list beyond index 0'
                    )
                  if (n > 0) {
                    for (let i = t - 1; i >= 0; i--)
                      this.set(e + i + n, this.get(e + i))
                    const o = e + t + n - this._length
                    if (o > 0)
                      for (this._length += o; this._length > this._maxLength; )
                        this._length--,
                          this._startIndex++,
                          this.onTrimEmitter.fire(1)
                  } else
                    for (let o = 0; o < t; o++)
                      this.set(e + o + n, this.get(e + o))
                }
              }
              _getCyclicIndex(e) {
                return (this._startIndex + e) % this._maxLength
              }
            }
            t.CircularList = r
          },
          1439: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.clone = void 0),
              (t.clone = __name(function e(t, n = 5) {
                if ('object' != typeof t) return t
                const o = Array.isArray(t) ? [] : {}
                for (const i in t) o[i] = n <= 1 ? t[i] : t[i] && e(t[i], n - 1)
                return o
              }, 'e'))
          },
          8055: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.contrastRatio =
                t.toPaddedHex =
                t.rgba =
                t.rgb =
                t.css =
                t.color =
                t.channels =
                t.NULL_COLOR =
                  void 0)
            let n = 0,
              o = 0,
              i = 0,
              r = 0
            var a, s, l, c, d, u
            function p(e) {
              const t = e.toString(16)
              return t.length < 2 ? '0' + t : t
            }
            function h(e, t) {
              return e < t ? (t + 0.05) / (e + 0.05) : (e + 0.05) / (t + 0.05)
            }
            __name(p, 'd'),
              __name(h, '_'),
              (t.NULL_COLOR = { css: '#00000000', rgba: 0 }),
              ((u = a || (t.channels = a = {})).toCss = function (e, t, n, o) {
                return void 0 !== o
                  ? `#${p(e)}${p(t)}${p(n)}${p(o)}`
                  : `#${p(e)}${p(t)}${p(n)}`
              }),
              (u.toRgba = function (e, t, n, o = 255) {
                return ((e << 24) | (t << 16) | (n << 8) | o) >>> 0
              }),
              (u.toColor = function (e, t, n, o) {
                return { css: u.toCss(e, t, n, o), rgba: u.toRgba(e, t, n, o) }
              }),
              (function (e) {
                function t(e, t) {
                  return (
                    (r = Math.round(255 * t)),
                    ([n, o, i] = d.toChannels(e.rgba)),
                    { css: a.toCss(n, o, i, r), rgba: a.toRgba(n, o, i, r) }
                  )
                }
                __name(t, 't'),
                  (e.blend = function (e, t) {
                    if (((r = (255 & t.rgba) / 255), 1 === r))
                      return { css: t.css, rgba: t.rgba }
                    const s = (t.rgba >> 24) & 255,
                      l = (t.rgba >> 16) & 255,
                      c = (t.rgba >> 8) & 255,
                      d = (e.rgba >> 24) & 255,
                      u = (e.rgba >> 16) & 255,
                      p = (e.rgba >> 8) & 255
                    return (
                      (n = d + Math.round((s - d) * r)),
                      (o = u + Math.round((l - u) * r)),
                      (i = p + Math.round((c - p) * r)),
                      { css: a.toCss(n, o, i), rgba: a.toRgba(n, o, i) }
                    )
                  }),
                  (e.isOpaque = function (e) {
                    return !(255 & ~e.rgba)
                  }),
                  (e.ensureContrastRatio = function (e, t, n) {
                    const o = d.ensureContrastRatio(e.rgba, t.rgba, n)
                    if (o)
                      return a.toColor(
                        (o >> 24) & 255,
                        (o >> 16) & 255,
                        (o >> 8) & 255
                      )
                  }),
                  (e.opaque = function (e) {
                    const t = (255 | e.rgba) >>> 0
                    return (
                      ([n, o, i] = d.toChannels(t)),
                      { css: a.toCss(n, o, i), rgba: t }
                    )
                  }),
                  (e.opacity = t),
                  (e.multiplyOpacity = function (e, n) {
                    return (r = 255 & e.rgba), t(e, (r * n) / 255)
                  }),
                  (e.toColorRGB = function (e) {
                    return [
                      (e.rgba >> 24) & 255,
                      (e.rgba >> 16) & 255,
                      (e.rgba >> 8) & 255
                    ]
                  })
              })(s || (t.color = s = {})),
              (function (e) {
                let t, s
                try {
                  const e = document.createElement('canvas')
                  ;(e.width = 1), (e.height = 1)
                  const n = e.getContext('2d', { willReadFrequently: !0 })
                  n &&
                    ((t = n),
                    (t.globalCompositeOperation = 'copy'),
                    (s = t.createLinearGradient(0, 0, 1, 1)))
                } catch {}
                e.toColor = function (e) {
                  if (e.match(/#[\da-f]{3,8}/i))
                    switch (e.length) {
                      case 4:
                        return (
                          (n = parseInt(e.slice(1, 2).repeat(2), 16)),
                          (o = parseInt(e.slice(2, 3).repeat(2), 16)),
                          (i = parseInt(e.slice(3, 4).repeat(2), 16)),
                          a.toColor(n, o, i)
                        )
                      case 5:
                        return (
                          (n = parseInt(e.slice(1, 2).repeat(2), 16)),
                          (o = parseInt(e.slice(2, 3).repeat(2), 16)),
                          (i = parseInt(e.slice(3, 4).repeat(2), 16)),
                          (r = parseInt(e.slice(4, 5).repeat(2), 16)),
                          a.toColor(n, o, i, r)
                        )
                      case 7:
                        return {
                          css: e,
                          rgba: ((parseInt(e.slice(1), 16) << 8) | 255) >>> 0
                        }
                      case 9:
                        return { css: e, rgba: parseInt(e.slice(1), 16) >>> 0 }
                    }
                  const l = e.match(
                    /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/
                  )
                  if (l)
                    return (
                      (n = parseInt(l[1])),
                      (o = parseInt(l[2])),
                      (i = parseInt(l[3])),
                      (r = Math.round(
                        255 * (void 0 === l[5] ? 1 : parseFloat(l[5]))
                      )),
                      a.toColor(n, o, i, r)
                    )
                  if (!t || !s)
                    throw new Error('css.toColor: Unsupported css format')
                  if (
                    ((t.fillStyle = s),
                    (t.fillStyle = e),
                    'string' != typeof t.fillStyle)
                  )
                    throw new Error('css.toColor: Unsupported css format')
                  if (
                    (t.fillRect(0, 0, 1, 1),
                    ([n, o, i, r] = t.getImageData(0, 0, 1, 1).data),
                    255 !== r)
                  )
                    throw new Error('css.toColor: Unsupported css format')
                  return { rgba: a.toRgba(n, o, i, r), css: e }
                }
              })(l || (t.css = l = {})),
              (function (e) {
                function t(e, t, n) {
                  const o = e / 255,
                    i = t / 255,
                    r = n / 255
                  return (
                    0.2126 *
                      (o <= 0.03928
                        ? o / 12.92
                        : Math.pow((o + 0.055) / 1.055, 2.4)) +
                    0.7152 *
                      (i <= 0.03928
                        ? i / 12.92
                        : Math.pow((i + 0.055) / 1.055, 2.4)) +
                    0.0722 *
                      (r <= 0.03928
                        ? r / 12.92
                        : Math.pow((r + 0.055) / 1.055, 2.4))
                  )
                }
                __name(t, 't'),
                  (e.relativeLuminance = function (e) {
                    return t((e >> 16) & 255, (e >> 8) & 255, 255 & e)
                  }),
                  (e.relativeLuminance2 = t)
              })(c || (t.rgb = c = {})),
              (function (e) {
                function t(e, t, n) {
                  const o = (e >> 24) & 255,
                    i = (e >> 16) & 255,
                    r = (e >> 8) & 255
                  let a = (t >> 24) & 255,
                    s = (t >> 16) & 255,
                    l = (t >> 8) & 255,
                    d = h(
                      c.relativeLuminance2(a, s, l),
                      c.relativeLuminance2(o, i, r)
                    )
                  for (; d < n && (a > 0 || s > 0 || l > 0); )
                    (a -= Math.max(0, Math.ceil(0.1 * a))),
                      (s -= Math.max(0, Math.ceil(0.1 * s))),
                      (l -= Math.max(0, Math.ceil(0.1 * l))),
                      (d = h(
                        c.relativeLuminance2(a, s, l),
                        c.relativeLuminance2(o, i, r)
                      ))
                  return ((a << 24) | (s << 16) | (l << 8) | 255) >>> 0
                }
                function s(e, t, n) {
                  const o = (e >> 24) & 255,
                    i = (e >> 16) & 255,
                    r = (e >> 8) & 255
                  let a = (t >> 24) & 255,
                    s = (t >> 16) & 255,
                    l = (t >> 8) & 255,
                    d = h(
                      c.relativeLuminance2(a, s, l),
                      c.relativeLuminance2(o, i, r)
                    )
                  for (; d < n && (a < 255 || s < 255 || l < 255); )
                    (a = Math.min(255, a + Math.ceil(0.1 * (255 - a)))),
                      (s = Math.min(255, s + Math.ceil(0.1 * (255 - s)))),
                      (l = Math.min(255, l + Math.ceil(0.1 * (255 - l)))),
                      (d = h(
                        c.relativeLuminance2(a, s, l),
                        c.relativeLuminance2(o, i, r)
                      ))
                  return ((a << 24) | (s << 16) | (l << 8) | 255) >>> 0
                }
                __name(t, 't'),
                  __name(s, 'a'),
                  (e.blend = function (e, t) {
                    if (((r = (255 & t) / 255), 1 === r)) return t
                    const s = (t >> 24) & 255,
                      l = (t >> 16) & 255,
                      c = (t >> 8) & 255,
                      d = (e >> 24) & 255,
                      u = (e >> 16) & 255,
                      p = (e >> 8) & 255
                    return (
                      (n = d + Math.round((s - d) * r)),
                      (o = u + Math.round((l - u) * r)),
                      (i = p + Math.round((c - p) * r)),
                      a.toRgba(n, o, i)
                    )
                  }),
                  (e.ensureContrastRatio = function (e, n, o) {
                    const i = c.relativeLuminance(e >> 8),
                      r = c.relativeLuminance(n >> 8)
                    if (h(i, r) < o) {
                      if (r < i) {
                        const r = t(e, n, o),
                          a = h(i, c.relativeLuminance(r >> 8))
                        if (a < o) {
                          const t = s(e, n, o)
                          return a > h(i, c.relativeLuminance(t >> 8)) ? r : t
                        }
                        return r
                      }
                      const a = s(e, n, o),
                        l = h(i, c.relativeLuminance(a >> 8))
                      if (l < o) {
                        const r = t(e, n, o)
                        return l > h(i, c.relativeLuminance(r >> 8)) ? a : r
                      }
                      return a
                    }
                  }),
                  (e.reduceLuminance = t),
                  (e.increaseLuminance = s),
                  (e.toChannels = function (e) {
                    return [
                      (e >> 24) & 255,
                      (e >> 16) & 255,
                      (e >> 8) & 255,
                      255 & e
                    ]
                  })
              })(d || (t.rgba = d = {})),
              (t.toPaddedHex = p),
              (t.contrastRatio = h)
          },
          8969: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.CoreTerminal = void 0)
            const o = n(844),
              i = n(2585),
              r = n(4348),
              a = n(7866),
              s = n(744),
              l = n(7302),
              c = n(6975),
              d = n(8460),
              u = n(1753),
              p = n(1480),
              h = n(7994),
              m = n(9282),
              f = n(5435),
              _ = n(5981),
              g = n(2660)
            let v = !1
            class y extends o.Disposable {
              static {
                __name(this, 'S')
              }
              get onScroll() {
                return (
                  this._onScrollApi ||
                    ((this._onScrollApi = this.register(new d.EventEmitter())),
                    this._onScroll.event((e) => {
                      this._onScrollApi?.fire(e.position)
                    })),
                  this._onScrollApi.event
                )
              }
              get cols() {
                return this._bufferService.cols
              }
              get rows() {
                return this._bufferService.rows
              }
              get buffers() {
                return this._bufferService.buffers
              }
              get options() {
                return this.optionsService.options
              }
              set options(e) {
                for (const t in e) this.optionsService.options[t] = e[t]
              }
              constructor(e) {
                super(),
                  (this._windowsWrappingHeuristics = this.register(
                    new o.MutableDisposable()
                  )),
                  (this._onBinary = this.register(new d.EventEmitter())),
                  (this.onBinary = this._onBinary.event),
                  (this._onData = this.register(new d.EventEmitter())),
                  (this.onData = this._onData.event),
                  (this._onLineFeed = this.register(new d.EventEmitter())),
                  (this.onLineFeed = this._onLineFeed.event),
                  (this._onResize = this.register(new d.EventEmitter())),
                  (this.onResize = this._onResize.event),
                  (this._onWriteParsed = this.register(new d.EventEmitter())),
                  (this.onWriteParsed = this._onWriteParsed.event),
                  (this._onScroll = this.register(new d.EventEmitter())),
                  (this._instantiationService = new r.InstantiationService()),
                  (this.optionsService = this.register(
                    new l.OptionsService(e)
                  )),
                  this._instantiationService.setService(
                    i.IOptionsService,
                    this.optionsService
                  ),
                  (this._bufferService = this.register(
                    this._instantiationService.createInstance(s.BufferService)
                  )),
                  this._instantiationService.setService(
                    i.IBufferService,
                    this._bufferService
                  ),
                  (this._logService = this.register(
                    this._instantiationService.createInstance(a.LogService)
                  )),
                  this._instantiationService.setService(
                    i.ILogService,
                    this._logService
                  ),
                  (this.coreService = this.register(
                    this._instantiationService.createInstance(c.CoreService)
                  )),
                  this._instantiationService.setService(
                    i.ICoreService,
                    this.coreService
                  ),
                  (this.coreMouseService = this.register(
                    this._instantiationService.createInstance(
                      u.CoreMouseService
                    )
                  )),
                  this._instantiationService.setService(
                    i.ICoreMouseService,
                    this.coreMouseService
                  ),
                  (this.unicodeService = this.register(
                    this._instantiationService.createInstance(p.UnicodeService)
                  )),
                  this._instantiationService.setService(
                    i.IUnicodeService,
                    this.unicodeService
                  ),
                  (this._charsetService =
                    this._instantiationService.createInstance(
                      h.CharsetService
                    )),
                  this._instantiationService.setService(
                    i.ICharsetService,
                    this._charsetService
                  ),
                  (this._oscLinkService =
                    this._instantiationService.createInstance(
                      g.OscLinkService
                    )),
                  this._instantiationService.setService(
                    i.IOscLinkService,
                    this._oscLinkService
                  ),
                  (this._inputHandler = this.register(
                    new f.InputHandler(
                      this._bufferService,
                      this._charsetService,
                      this.coreService,
                      this._logService,
                      this.optionsService,
                      this._oscLinkService,
                      this.coreMouseService,
                      this.unicodeService
                    )
                  )),
                  this.register(
                    (0, d.forwardEvent)(
                      this._inputHandler.onLineFeed,
                      this._onLineFeed
                    )
                  ),
                  this.register(this._inputHandler),
                  this.register(
                    (0, d.forwardEvent)(
                      this._bufferService.onResize,
                      this._onResize
                    )
                  ),
                  this.register(
                    (0, d.forwardEvent)(this.coreService.onData, this._onData)
                  ),
                  this.register(
                    (0, d.forwardEvent)(
                      this.coreService.onBinary,
                      this._onBinary
                    )
                  ),
                  this.register(
                    this.coreService.onRequestScrollToBottom(() =>
                      this.scrollToBottom()
                    )
                  ),
                  this.register(
                    this.coreService.onUserInput(() =>
                      this._writeBuffer.handleUserInput()
                    )
                  ),
                  this.register(
                    this.optionsService.onMultipleOptionChange(
                      ['windowsMode', 'windowsPty'],
                      () => this._handleWindowsPtyOptionChange()
                    )
                  ),
                  this.register(
                    this._bufferService.onScroll((e) => {
                      this._onScroll.fire({
                        position: this._bufferService.buffer.ydisp,
                        source: 0
                      }),
                        this._inputHandler.markRangeDirty(
                          this._bufferService.buffer.scrollTop,
                          this._bufferService.buffer.scrollBottom
                        )
                    })
                  ),
                  this.register(
                    this._inputHandler.onScroll((e) => {
                      this._onScroll.fire({
                        position: this._bufferService.buffer.ydisp,
                        source: 0
                      }),
                        this._inputHandler.markRangeDirty(
                          this._bufferService.buffer.scrollTop,
                          this._bufferService.buffer.scrollBottom
                        )
                    })
                  ),
                  (this._writeBuffer = this.register(
                    new _.WriteBuffer((e, t) => this._inputHandler.parse(e, t))
                  )),
                  this.register(
                    (0, d.forwardEvent)(
                      this._writeBuffer.onWriteParsed,
                      this._onWriteParsed
                    )
                  )
              }
              write(e, t) {
                this._writeBuffer.write(e, t)
              }
              writeSync(e, t) {
                this._logService.logLevel <= i.LogLevelEnum.WARN &&
                  !v &&
                  (this._logService.warn(
                    'writeSync is unreliable and will be removed soon.'
                  ),
                  (v = !0)),
                  this._writeBuffer.writeSync(e, t)
              }
              input(e, t = !0) {
                this.coreService.triggerDataEvent(e, t)
              }
              resize(e, t) {
                isNaN(e) ||
                  isNaN(t) ||
                  ((e = Math.max(e, s.MINIMUM_COLS)),
                  (t = Math.max(t, s.MINIMUM_ROWS)),
                  this._bufferService.resize(e, t))
              }
              scroll(e, t = !1) {
                this._bufferService.scroll(e, t)
              }
              scrollLines(e, t, n) {
                this._bufferService.scrollLines(e, t, n)
              }
              scrollPages(e) {
                this.scrollLines(e * (this.rows - 1))
              }
              scrollToTop() {
                this.scrollLines(-this._bufferService.buffer.ydisp)
              }
              scrollToBottom() {
                this.scrollLines(
                  this._bufferService.buffer.ybase -
                    this._bufferService.buffer.ydisp
                )
              }
              scrollToLine(e) {
                const t = e - this._bufferService.buffer.ydisp
                0 !== t && this.scrollLines(t)
              }
              registerEscHandler(e, t) {
                return this._inputHandler.registerEscHandler(e, t)
              }
              registerDcsHandler(e, t) {
                return this._inputHandler.registerDcsHandler(e, t)
              }
              registerCsiHandler(e, t) {
                return this._inputHandler.registerCsiHandler(e, t)
              }
              registerOscHandler(e, t) {
                return this._inputHandler.registerOscHandler(e, t)
              }
              _setup() {
                this._handleWindowsPtyOptionChange()
              }
              reset() {
                this._inputHandler.reset(),
                  this._bufferService.reset(),
                  this._charsetService.reset(),
                  this.coreService.reset(),
                  this.coreMouseService.reset()
              }
              _handleWindowsPtyOptionChange() {
                let e = !1
                const t = this.optionsService.rawOptions.windowsPty
                t && void 0 !== t.buildNumber && void 0 !== t.buildNumber
                  ? (e = !!('conpty' === t.backend && t.buildNumber < 21376))
                  : this.optionsService.rawOptions.windowsMode && (e = !0),
                  e
                    ? this._enableWindowsWrappingHeuristics()
                    : this._windowsWrappingHeuristics.clear()
              }
              _enableWindowsWrappingHeuristics() {
                if (!this._windowsWrappingHeuristics.value) {
                  const e = []
                  e.push(
                    this.onLineFeed(
                      m.updateWindowsModeWrappedState.bind(
                        null,
                        this._bufferService
                      )
                    )
                  ),
                    e.push(
                      this.registerCsiHandler(
                        { final: 'H' },
                        () => (
                          (0, m.updateWindowsModeWrappedState)(
                            this._bufferService
                          ),
                          !1
                        )
                      )
                    ),
                    (this._windowsWrappingHeuristics.value = (0,
                    o.toDisposable)(() => {
                      for (const t of e) t.dispose()
                    }))
                }
              }
            }
            t.CoreTerminal = y
          },
          8460: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.runAndSubscribe = t.forwardEvent = t.EventEmitter = void 0),
              (t.EventEmitter = class {
                constructor() {
                  ;(this._listeners = []), (this._disposed = !1)
                }
                get event() {
                  return (
                    this._event ||
                      (this._event = (e) => (
                        this._listeners.push(e),
                        {
                          dispose: __name(() => {
                            if (!this._disposed)
                              for (let t = 0; t < this._listeners.length; t++)
                                if (this._listeners[t] === e)
                                  return void this._listeners.splice(t, 1)
                          }, 'dispose')
                        }
                      )),
                    this._event
                  )
                }
                fire(e, t) {
                  const n = []
                  for (let o = 0; o < this._listeners.length; o++)
                    n.push(this._listeners[o])
                  for (let o = 0; o < n.length; o++) n[o].call(void 0, e, t)
                }
                dispose() {
                  this.clearListeners(), (this._disposed = !0)
                }
                clearListeners() {
                  this._listeners && (this._listeners.length = 0)
                }
              }),
              (t.forwardEvent = function (e, t) {
                return e((e) => t.fire(e))
              }),
              (t.runAndSubscribe = function (e, t) {
                return t(void 0), e((e) => t(e))
              })
          },
          5435: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.InputHandler = t.WindowsOptionsReportType = void 0)
            const r = n(2584),
              a = n(7116),
              s = n(2015),
              l = n(844),
              c = n(482),
              d = n(8437),
              u = n(8460),
              p = n(643),
              h = n(511),
              m = n(3734),
              f = n(2585),
              _ = n(1480),
              g = n(6242),
              v = n(6351),
              y = n(5941),
              b = { '(': 0, ')': 1, '*': 2, '+': 3, '-': 1, '.': 2 },
              S = 131072
            function C(e, t) {
              if (e > 24) return t.setWinLines || !1
              switch (e) {
                case 1:
                  return !!t.restoreWin
                case 2:
                  return !!t.minimizeWin
                case 3:
                  return !!t.setWinPosition
                case 4:
                  return !!t.setWinSizePixels
                case 5:
                  return !!t.raiseWin
                case 6:
                  return !!t.lowerWin
                case 7:
                  return !!t.refreshWin
                case 8:
                  return !!t.setWinSizeChars
                case 9:
                  return !!t.maximizeWin
                case 10:
                  return !!t.fullscreenWin
                case 11:
                  return !!t.getWinState
                case 13:
                  return !!t.getWinPosition
                case 14:
                  return !!t.getWinSizePixels
                case 15:
                  return !!t.getScreenSizePixels
                case 16:
                  return !!t.getCellSizePixels
                case 18:
                  return !!t.getWinSizeChars
                case 19:
                  return !!t.getScreenSizeChars
                case 20:
                  return !!t.getIconTitle
                case 21:
                  return !!t.getWinTitle
                case 22:
                  return !!t.pushTitle
                case 23:
                  return !!t.popTitle
                case 24:
                  return !!t.setWinLines
              }
              return !1
            }
            var w, k
            __name(C, 'w'),
              ((k = w || (t.WindowsOptionsReportType = w = {}))[
                (k.GET_WIN_SIZE_PIXELS = 0)
              ] = 'GET_WIN_SIZE_PIXELS'),
              (k[(k.GET_CELL_SIZE_PIXELS = 1)] = 'GET_CELL_SIZE_PIXELS')
            let x = 0
            class E extends l.Disposable {
              static {
                __name(this, 'k')
              }
              getAttrData() {
                return this._curAttrData
              }
              constructor(
                e,
                t,
                n,
                o,
                i,
                l,
                p,
                m,
                f = new s.EscapeSequenceParser()
              ) {
                super(),
                  (this._bufferService = e),
                  (this._charsetService = t),
                  (this._coreService = n),
                  (this._logService = o),
                  (this._optionsService = i),
                  (this._oscLinkService = l),
                  (this._coreMouseService = p),
                  (this._unicodeService = m),
                  (this._parser = f),
                  (this._parseBuffer = new Uint32Array(4096)),
                  (this._stringDecoder = new c.StringToUtf32()),
                  (this._utf8Decoder = new c.Utf8ToUtf32()),
                  (this._workCell = new h.CellData()),
                  (this._windowTitle = ''),
                  (this._iconName = ''),
                  (this._windowTitleStack = []),
                  (this._iconNameStack = []),
                  (this._curAttrData = d.DEFAULT_ATTR_DATA.clone()),
                  (this._eraseAttrDataInternal = d.DEFAULT_ATTR_DATA.clone()),
                  (this._onRequestBell = this.register(new u.EventEmitter())),
                  (this.onRequestBell = this._onRequestBell.event),
                  (this._onRequestRefreshRows = this.register(
                    new u.EventEmitter()
                  )),
                  (this.onRequestRefreshRows =
                    this._onRequestRefreshRows.event),
                  (this._onRequestReset = this.register(new u.EventEmitter())),
                  (this.onRequestReset = this._onRequestReset.event),
                  (this._onRequestSendFocus = this.register(
                    new u.EventEmitter()
                  )),
                  (this.onRequestSendFocus = this._onRequestSendFocus.event),
                  (this._onRequestSyncScrollBar = this.register(
                    new u.EventEmitter()
                  )),
                  (this.onRequestSyncScrollBar =
                    this._onRequestSyncScrollBar.event),
                  (this._onRequestWindowsOptionsReport = this.register(
                    new u.EventEmitter()
                  )),
                  (this.onRequestWindowsOptionsReport =
                    this._onRequestWindowsOptionsReport.event),
                  (this._onA11yChar = this.register(new u.EventEmitter())),
                  (this.onA11yChar = this._onA11yChar.event),
                  (this._onA11yTab = this.register(new u.EventEmitter())),
                  (this.onA11yTab = this._onA11yTab.event),
                  (this._onCursorMove = this.register(new u.EventEmitter())),
                  (this.onCursorMove = this._onCursorMove.event),
                  (this._onLineFeed = this.register(new u.EventEmitter())),
                  (this.onLineFeed = this._onLineFeed.event),
                  (this._onScroll = this.register(new u.EventEmitter())),
                  (this.onScroll = this._onScroll.event),
                  (this._onTitleChange = this.register(new u.EventEmitter())),
                  (this.onTitleChange = this._onTitleChange.event),
                  (this._onColor = this.register(new u.EventEmitter())),
                  (this.onColor = this._onColor.event),
                  (this._parseStack = {
                    paused: !1,
                    cursorStartX: 0,
                    cursorStartY: 0,
                    decodedLength: 0,
                    position: 0
                  }),
                  (this._specialColors = [256, 257, 258]),
                  this.register(this._parser),
                  (this._dirtyRowTracker = new I(this._bufferService)),
                  (this._activeBuffer = this._bufferService.buffer),
                  this.register(
                    this._bufferService.buffers.onBufferActivate(
                      (e) => (this._activeBuffer = e.activeBuffer)
                    )
                  ),
                  this._parser.setCsiHandlerFallback((e, t) => {
                    this._logService.debug('Unknown CSI code: ', {
                      identifier: this._parser.identToString(e),
                      params: t.toArray()
                    })
                  }),
                  this._parser.setEscHandlerFallback((e) => {
                    this._logService.debug('Unknown ESC code: ', {
                      identifier: this._parser.identToString(e)
                    })
                  }),
                  this._parser.setExecuteHandlerFallback((e) => {
                    this._logService.debug('Unknown EXECUTE code: ', {
                      code: e
                    })
                  }),
                  this._parser.setOscHandlerFallback((e, t, n) => {
                    this._logService.debug('Unknown OSC code: ', {
                      identifier: e,
                      action: t,
                      data: n
                    })
                  }),
                  this._parser.setDcsHandlerFallback((e, t, n) => {
                    'HOOK' === t && (n = n.toArray()),
                      this._logService.debug('Unknown DCS code: ', {
                        identifier: this._parser.identToString(e),
                        action: t,
                        payload: n
                      })
                  }),
                  this._parser.setPrintHandler((e, t, n) =>
                    this.print(e, t, n)
                  ),
                  this._parser.registerCsiHandler({ final: '@' }, (e) =>
                    this.insertChars(e)
                  ),
                  this._parser.registerCsiHandler(
                    { intermediates: ' ', final: '@' },
                    (e) => this.scrollLeft(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'A' }, (e) =>
                    this.cursorUp(e)
                  ),
                  this._parser.registerCsiHandler(
                    { intermediates: ' ', final: 'A' },
                    (e) => this.scrollRight(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'B' }, (e) =>
                    this.cursorDown(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'C' }, (e) =>
                    this.cursorForward(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'D' }, (e) =>
                    this.cursorBackward(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'E' }, (e) =>
                    this.cursorNextLine(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'F' }, (e) =>
                    this.cursorPrecedingLine(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'G' }, (e) =>
                    this.cursorCharAbsolute(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'H' }, (e) =>
                    this.cursorPosition(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'I' }, (e) =>
                    this.cursorForwardTab(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'J' }, (e) =>
                    this.eraseInDisplay(e, !1)
                  ),
                  this._parser.registerCsiHandler(
                    { prefix: '?', final: 'J' },
                    (e) => this.eraseInDisplay(e, !0)
                  ),
                  this._parser.registerCsiHandler({ final: 'K' }, (e) =>
                    this.eraseInLine(e, !1)
                  ),
                  this._parser.registerCsiHandler(
                    { prefix: '?', final: 'K' },
                    (e) => this.eraseInLine(e, !0)
                  ),
                  this._parser.registerCsiHandler({ final: 'L' }, (e) =>
                    this.insertLines(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'M' }, (e) =>
                    this.deleteLines(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'P' }, (e) =>
                    this.deleteChars(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'S' }, (e) =>
                    this.scrollUp(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'T' }, (e) =>
                    this.scrollDown(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'X' }, (e) =>
                    this.eraseChars(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'Z' }, (e) =>
                    this.cursorBackwardTab(e)
                  ),
                  this._parser.registerCsiHandler({ final: '`' }, (e) =>
                    this.charPosAbsolute(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'a' }, (e) =>
                    this.hPositionRelative(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'b' }, (e) =>
                    this.repeatPrecedingCharacter(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'c' }, (e) =>
                    this.sendDeviceAttributesPrimary(e)
                  ),
                  this._parser.registerCsiHandler(
                    { prefix: '>', final: 'c' },
                    (e) => this.sendDeviceAttributesSecondary(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'd' }, (e) =>
                    this.linePosAbsolute(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'e' }, (e) =>
                    this.vPositionRelative(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'f' }, (e) =>
                    this.hVPosition(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'g' }, (e) =>
                    this.tabClear(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'h' }, (e) =>
                    this.setMode(e)
                  ),
                  this._parser.registerCsiHandler(
                    { prefix: '?', final: 'h' },
                    (e) => this.setModePrivate(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'l' }, (e) =>
                    this.resetMode(e)
                  ),
                  this._parser.registerCsiHandler(
                    { prefix: '?', final: 'l' },
                    (e) => this.resetModePrivate(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'm' }, (e) =>
                    this.charAttributes(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'n' }, (e) =>
                    this.deviceStatus(e)
                  ),
                  this._parser.registerCsiHandler(
                    { prefix: '?', final: 'n' },
                    (e) => this.deviceStatusPrivate(e)
                  ),
                  this._parser.registerCsiHandler(
                    { intermediates: '!', final: 'p' },
                    (e) => this.softReset(e)
                  ),
                  this._parser.registerCsiHandler(
                    { intermediates: ' ', final: 'q' },
                    (e) => this.setCursorStyle(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'r' }, (e) =>
                    this.setScrollRegion(e)
                  ),
                  this._parser.registerCsiHandler({ final: 's' }, (e) =>
                    this.saveCursor(e)
                  ),
                  this._parser.registerCsiHandler({ final: 't' }, (e) =>
                    this.windowOptions(e)
                  ),
                  this._parser.registerCsiHandler({ final: 'u' }, (e) =>
                    this.restoreCursor(e)
                  ),
                  this._parser.registerCsiHandler(
                    { intermediates: "'", final: '}' },
                    (e) => this.insertColumns(e)
                  ),
                  this._parser.registerCsiHandler(
                    { intermediates: "'", final: '~' },
                    (e) => this.deleteColumns(e)
                  ),
                  this._parser.registerCsiHandler(
                    { intermediates: '"', final: 'q' },
                    (e) => this.selectProtected(e)
                  ),
                  this._parser.registerCsiHandler(
                    { intermediates: '$', final: 'p' },
                    (e) => this.requestMode(e, !0)
                  ),
                  this._parser.registerCsiHandler(
                    { prefix: '?', intermediates: '$', final: 'p' },
                    (e) => this.requestMode(e, !1)
                  ),
                  this._parser.setExecuteHandler(r.C0.BEL, () => this.bell()),
                  this._parser.setExecuteHandler(r.C0.LF, () =>
                    this.lineFeed()
                  ),
                  this._parser.setExecuteHandler(r.C0.VT, () =>
                    this.lineFeed()
                  ),
                  this._parser.setExecuteHandler(r.C0.FF, () =>
                    this.lineFeed()
                  ),
                  this._parser.setExecuteHandler(r.C0.CR, () =>
                    this.carriageReturn()
                  ),
                  this._parser.setExecuteHandler(r.C0.BS, () =>
                    this.backspace()
                  ),
                  this._parser.setExecuteHandler(r.C0.HT, () => this.tab()),
                  this._parser.setExecuteHandler(r.C0.SO, () =>
                    this.shiftOut()
                  ),
                  this._parser.setExecuteHandler(r.C0.SI, () => this.shiftIn()),
                  this._parser.setExecuteHandler(r.C1.IND, () => this.index()),
                  this._parser.setExecuteHandler(r.C1.NEL, () =>
                    this.nextLine()
                  ),
                  this._parser.setExecuteHandler(r.C1.HTS, () => this.tabSet()),
                  this._parser.registerOscHandler(
                    0,
                    new g.OscHandler(
                      (e) => (this.setTitle(e), this.setIconName(e), !0)
                    )
                  ),
                  this._parser.registerOscHandler(
                    1,
                    new g.OscHandler((e) => this.setIconName(e))
                  ),
                  this._parser.registerOscHandler(
                    2,
                    new g.OscHandler((e) => this.setTitle(e))
                  ),
                  this._parser.registerOscHandler(
                    4,
                    new g.OscHandler((e) => this.setOrReportIndexedColor(e))
                  ),
                  this._parser.registerOscHandler(
                    8,
                    new g.OscHandler((e) => this.setHyperlink(e))
                  ),
                  this._parser.registerOscHandler(
                    10,
                    new g.OscHandler((e) => this.setOrReportFgColor(e))
                  ),
                  this._parser.registerOscHandler(
                    11,
                    new g.OscHandler((e) => this.setOrReportBgColor(e))
                  ),
                  this._parser.registerOscHandler(
                    12,
                    new g.OscHandler((e) => this.setOrReportCursorColor(e))
                  ),
                  this._parser.registerOscHandler(
                    104,
                    new g.OscHandler((e) => this.restoreIndexedColor(e))
                  ),
                  this._parser.registerOscHandler(
                    110,
                    new g.OscHandler((e) => this.restoreFgColor(e))
                  ),
                  this._parser.registerOscHandler(
                    111,
                    new g.OscHandler((e) => this.restoreBgColor(e))
                  ),
                  this._parser.registerOscHandler(
                    112,
                    new g.OscHandler((e) => this.restoreCursorColor(e))
                  ),
                  this._parser.registerEscHandler({ final: '7' }, () =>
                    this.saveCursor()
                  ),
                  this._parser.registerEscHandler({ final: '8' }, () =>
                    this.restoreCursor()
                  ),
                  this._parser.registerEscHandler({ final: 'D' }, () =>
                    this.index()
                  ),
                  this._parser.registerEscHandler({ final: 'E' }, () =>
                    this.nextLine()
                  ),
                  this._parser.registerEscHandler({ final: 'H' }, () =>
                    this.tabSet()
                  ),
                  this._parser.registerEscHandler({ final: 'M' }, () =>
                    this.reverseIndex()
                  ),
                  this._parser.registerEscHandler({ final: '=' }, () =>
                    this.keypadApplicationMode()
                  ),
                  this._parser.registerEscHandler({ final: '>' }, () =>
                    this.keypadNumericMode()
                  ),
                  this._parser.registerEscHandler({ final: 'c' }, () =>
                    this.fullReset()
                  ),
                  this._parser.registerEscHandler({ final: 'n' }, () =>
                    this.setgLevel(2)
                  ),
                  this._parser.registerEscHandler({ final: 'o' }, () =>
                    this.setgLevel(3)
                  ),
                  this._parser.registerEscHandler({ final: '|' }, () =>
                    this.setgLevel(3)
                  ),
                  this._parser.registerEscHandler({ final: '}' }, () =>
                    this.setgLevel(2)
                  ),
                  this._parser.registerEscHandler({ final: '~' }, () =>
                    this.setgLevel(1)
                  ),
                  this._parser.registerEscHandler(
                    { intermediates: '%', final: '@' },
                    () => this.selectDefaultCharset()
                  ),
                  this._parser.registerEscHandler(
                    { intermediates: '%', final: 'G' },
                    () => this.selectDefaultCharset()
                  )
                for (const r in a.CHARSETS)
                  this._parser.registerEscHandler(
                    { intermediates: '(', final: r },
                    () => this.selectCharset('(' + r)
                  ),
                    this._parser.registerEscHandler(
                      { intermediates: ')', final: r },
                      () => this.selectCharset(')' + r)
                    ),
                    this._parser.registerEscHandler(
                      { intermediates: '*', final: r },
                      () => this.selectCharset('*' + r)
                    ),
                    this._parser.registerEscHandler(
                      { intermediates: '+', final: r },
                      () => this.selectCharset('+' + r)
                    ),
                    this._parser.registerEscHandler(
                      { intermediates: '-', final: r },
                      () => this.selectCharset('-' + r)
                    ),
                    this._parser.registerEscHandler(
                      { intermediates: '.', final: r },
                      () => this.selectCharset('.' + r)
                    ),
                    this._parser.registerEscHandler(
                      { intermediates: '/', final: r },
                      () => this.selectCharset('/' + r)
                    )
                this._parser.registerEscHandler(
                  { intermediates: '#', final: '8' },
                  () => this.screenAlignmentPattern()
                ),
                  this._parser.setErrorHandler(
                    (e) => (this._logService.error('Parsing error: ', e), e)
                  ),
                  this._parser.registerDcsHandler(
                    { intermediates: '$', final: 'q' },
                    new v.DcsHandler((e, t) => this.requestStatusString(e, t))
                  )
              }
              _preserveStack(e, t, n, o) {
                ;(this._parseStack.paused = !0),
                  (this._parseStack.cursorStartX = e),
                  (this._parseStack.cursorStartY = t),
                  (this._parseStack.decodedLength = n),
                  (this._parseStack.position = o)
              }
              _logSlowResolvingAsync(e) {
                this._logService.logLevel <= f.LogLevelEnum.WARN &&
                  Promise.race([
                    e,
                    new Promise((e, t) =>
                      setTimeout(() => t('#SLOW_TIMEOUT'), 5e3)
                    )
                  ]).catch((e) => {
                    if ('#SLOW_TIMEOUT' !== e) throw e
                    console.warn(
                      'async parser handler taking longer than 5000 ms'
                    )
                  })
              }
              _getCurrentLinkId() {
                return this._curAttrData.extended.urlId
              }
              parse(e, t) {
                let n,
                  o = this._activeBuffer.x,
                  i = this._activeBuffer.y,
                  r = 0
                const a = this._parseStack.paused
                if (a) {
                  if (
                    (n = this._parser.parse(
                      this._parseBuffer,
                      this._parseStack.decodedLength,
                      t
                    ))
                  )
                    return this._logSlowResolvingAsync(n), n
                  ;(o = this._parseStack.cursorStartX),
                    (i = this._parseStack.cursorStartY),
                    (this._parseStack.paused = !1),
                    e.length > S && (r = this._parseStack.position + S)
                }
                if (
                  (this._logService.logLevel <= f.LogLevelEnum.DEBUG &&
                    this._logService.debug(
                      'parsing data' +
                        ('string' == typeof e
                          ? ` "${e}"`
                          : ` "${Array.prototype.map.call(e, (e) => String.fromCharCode(e)).join('')}"`),
                      'string' == typeof e
                        ? e.split('').map((e) => e.charCodeAt(0))
                        : e
                    ),
                  this._parseBuffer.length < e.length &&
                    this._parseBuffer.length < S &&
                    (this._parseBuffer = new Uint32Array(
                      Math.min(e.length, S)
                    )),
                  a || this._dirtyRowTracker.clearRange(),
                  e.length > S)
                )
                  for (let c = r; c < e.length; c += S) {
                    const t = c + S < e.length ? c + S : e.length,
                      r =
                        'string' == typeof e
                          ? this._stringDecoder.decode(
                              e.substring(c, t),
                              this._parseBuffer
                            )
                          : this._utf8Decoder.decode(
                              e.subarray(c, t),
                              this._parseBuffer
                            )
                    if ((n = this._parser.parse(this._parseBuffer, r)))
                      return (
                        this._preserveStack(o, i, r, c),
                        this._logSlowResolvingAsync(n),
                        n
                      )
                  }
                else if (!a) {
                  const t =
                    'string' == typeof e
                      ? this._stringDecoder.decode(e, this._parseBuffer)
                      : this._utf8Decoder.decode(e, this._parseBuffer)
                  if ((n = this._parser.parse(this._parseBuffer, t)))
                    return (
                      this._preserveStack(o, i, t, 0),
                      this._logSlowResolvingAsync(n),
                      n
                    )
                }
                ;(this._activeBuffer.x === o && this._activeBuffer.y === i) ||
                  this._onCursorMove.fire()
                const s =
                    this._dirtyRowTracker.end +
                    (this._bufferService.buffer.ybase -
                      this._bufferService.buffer.ydisp),
                  l =
                    this._dirtyRowTracker.start +
                    (this._bufferService.buffer.ybase -
                      this._bufferService.buffer.ydisp)
                l < this._bufferService.rows &&
                  this._onRequestRefreshRows.fire(
                    Math.min(l, this._bufferService.rows - 1),
                    Math.min(s, this._bufferService.rows - 1)
                  )
              }
              print(e, t, n) {
                let o, i
                const r = this._charsetService.charset,
                  a = this._optionsService.rawOptions.screenReaderMode,
                  s = this._bufferService.cols,
                  l = this._coreService.decPrivateModes.wraparound,
                  u = this._coreService.modes.insertMode,
                  h = this._curAttrData
                let m = this._activeBuffer.lines.get(
                  this._activeBuffer.ybase + this._activeBuffer.y
                )
                this._dirtyRowTracker.markDirty(this._activeBuffer.y),
                  this._activeBuffer.x &&
                    n - t > 0 &&
                    2 === m.getWidth(this._activeBuffer.x - 1) &&
                    m.setCellFromCodepoint(this._activeBuffer.x - 1, 0, 1, h)
                let f = this._parser.precedingJoinState
                for (let g = t; g < n; ++g) {
                  if (((o = e[g]), o < 127 && r)) {
                    const e = r[String.fromCharCode(o)]
                    e && (o = e.charCodeAt(0))
                  }
                  const t = this._unicodeService.charProperties(o, f)
                  i = _.UnicodeService.extractWidth(t)
                  const n = _.UnicodeService.extractShouldJoin(t),
                    v = n ? _.UnicodeService.extractWidth(f) : 0
                  if (
                    ((f = t),
                    a && this._onA11yChar.fire((0, c.stringFromCodePoint)(o)),
                    this._getCurrentLinkId() &&
                      this._oscLinkService.addLineToLink(
                        this._getCurrentLinkId(),
                        this._activeBuffer.ybase + this._activeBuffer.y
                      ),
                    this._activeBuffer.x + i - v > s)
                  )
                    if (l) {
                      const e = m
                      let t = this._activeBuffer.x - v
                      for (
                        this._activeBuffer.x = v,
                          this._activeBuffer.y++,
                          this._activeBuffer.y ===
                          this._activeBuffer.scrollBottom + 1
                            ? (this._activeBuffer.y--,
                              this._bufferService.scroll(
                                this._eraseAttrData(),
                                !0
                              ))
                            : (this._activeBuffer.y >=
                                this._bufferService.rows &&
                                (this._activeBuffer.y =
                                  this._bufferService.rows - 1),
                              (this._activeBuffer.lines.get(
                                this._activeBuffer.ybase + this._activeBuffer.y
                              ).isWrapped = !0)),
                          m = this._activeBuffer.lines.get(
                            this._activeBuffer.ybase + this._activeBuffer.y
                          ),
                          v > 0 &&
                            m instanceof d.BufferLine &&
                            m.copyCellsFrom(e, t, 0, v, !1);
                        t < s;

                      )
                        e.setCellFromCodepoint(t++, 0, 1, h)
                    } else if (((this._activeBuffer.x = s - 1), 2 === i))
                      continue
                  if (n && this._activeBuffer.x) {
                    const e = m.getWidth(this._activeBuffer.x - 1) ? 1 : 2
                    m.addCodepointToCell(this._activeBuffer.x - e, o, i)
                    for (let t = i - v; --t >= 0; )
                      m.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, h)
                  } else if (
                    (u &&
                      (m.insertCells(
                        this._activeBuffer.x,
                        i - v,
                        this._activeBuffer.getNullCell(h)
                      ),
                      2 === m.getWidth(s - 1) &&
                        m.setCellFromCodepoint(
                          s - 1,
                          p.NULL_CELL_CODE,
                          p.NULL_CELL_WIDTH,
                          h
                        )),
                    m.setCellFromCodepoint(this._activeBuffer.x++, o, i, h),
                    i > 0)
                  )
                    for (; --i; )
                      m.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, h)
                }
                ;(this._parser.precedingJoinState = f),
                  this._activeBuffer.x < s &&
                    n - t > 0 &&
                    0 === m.getWidth(this._activeBuffer.x) &&
                    !m.hasContent(this._activeBuffer.x) &&
                    m.setCellFromCodepoint(this._activeBuffer.x, 0, 1, h),
                  this._dirtyRowTracker.markDirty(this._activeBuffer.y)
              }
              registerCsiHandler(e, t) {
                return 't' !== e.final || e.prefix || e.intermediates
                  ? this._parser.registerCsiHandler(e, t)
                  : this._parser.registerCsiHandler(
                      e,
                      (e) =>
                        !C(
                          e.params[0],
                          this._optionsService.rawOptions.windowOptions
                        ) || t(e)
                    )
              }
              registerDcsHandler(e, t) {
                return this._parser.registerDcsHandler(e, new v.DcsHandler(t))
              }
              registerEscHandler(e, t) {
                return this._parser.registerEscHandler(e, t)
              }
              registerOscHandler(e, t) {
                return this._parser.registerOscHandler(e, new g.OscHandler(t))
              }
              bell() {
                return this._onRequestBell.fire(), !0
              }
              lineFeed() {
                return (
                  this._dirtyRowTracker.markDirty(this._activeBuffer.y),
                  this._optionsService.rawOptions.convertEol &&
                    (this._activeBuffer.x = 0),
                  this._activeBuffer.y++,
                  this._activeBuffer.y === this._activeBuffer.scrollBottom + 1
                    ? (this._activeBuffer.y--,
                      this._bufferService.scroll(this._eraseAttrData()))
                    : this._activeBuffer.y >= this._bufferService.rows
                      ? (this._activeBuffer.y = this._bufferService.rows - 1)
                      : (this._activeBuffer.lines.get(
                          this._activeBuffer.ybase + this._activeBuffer.y
                        ).isWrapped = !1),
                  this._activeBuffer.x >= this._bufferService.cols &&
                    this._activeBuffer.x--,
                  this._dirtyRowTracker.markDirty(this._activeBuffer.y),
                  this._onLineFeed.fire(),
                  !0
                )
              }
              carriageReturn() {
                return (this._activeBuffer.x = 0), !0
              }
              backspace() {
                if (!this._coreService.decPrivateModes.reverseWraparound)
                  return (
                    this._restrictCursor(),
                    this._activeBuffer.x > 0 && this._activeBuffer.x--,
                    !0
                  )
                if (
                  (this._restrictCursor(this._bufferService.cols),
                  this._activeBuffer.x > 0)
                )
                  this._activeBuffer.x--
                else if (
                  0 === this._activeBuffer.x &&
                  this._activeBuffer.y > this._activeBuffer.scrollTop &&
                  this._activeBuffer.y <= this._activeBuffer.scrollBottom &&
                  this._activeBuffer.lines.get(
                    this._activeBuffer.ybase + this._activeBuffer.y
                  )?.isWrapped
                ) {
                  ;(this._activeBuffer.lines.get(
                    this._activeBuffer.ybase + this._activeBuffer.y
                  ).isWrapped = !1),
                    this._activeBuffer.y--,
                    (this._activeBuffer.x = this._bufferService.cols - 1)
                  const e = this._activeBuffer.lines.get(
                    this._activeBuffer.ybase + this._activeBuffer.y
                  )
                  e.hasWidth(this._activeBuffer.x) &&
                    !e.hasContent(this._activeBuffer.x) &&
                    this._activeBuffer.x--
                }
                return this._restrictCursor(), !0
              }
              tab() {
                if (this._activeBuffer.x >= this._bufferService.cols) return !0
                const e = this._activeBuffer.x
                return (
                  (this._activeBuffer.x = this._activeBuffer.nextStop()),
                  this._optionsService.rawOptions.screenReaderMode &&
                    this._onA11yTab.fire(this._activeBuffer.x - e),
                  !0
                )
              }
              shiftOut() {
                return this._charsetService.setgLevel(1), !0
              }
              shiftIn() {
                return this._charsetService.setgLevel(0), !0
              }
              _restrictCursor(e = this._bufferService.cols - 1) {
                ;(this._activeBuffer.x = Math.min(
                  e,
                  Math.max(0, this._activeBuffer.x)
                )),
                  (this._activeBuffer.y = this._coreService.decPrivateModes
                    .origin
                    ? Math.min(
                        this._activeBuffer.scrollBottom,
                        Math.max(
                          this._activeBuffer.scrollTop,
                          this._activeBuffer.y
                        )
                      )
                    : Math.min(
                        this._bufferService.rows - 1,
                        Math.max(0, this._activeBuffer.y)
                      )),
                  this._dirtyRowTracker.markDirty(this._activeBuffer.y)
              }
              _setCursor(e, t) {
                this._dirtyRowTracker.markDirty(this._activeBuffer.y),
                  this._coreService.decPrivateModes.origin
                    ? ((this._activeBuffer.x = e),
                      (this._activeBuffer.y = this._activeBuffer.scrollTop + t))
                    : ((this._activeBuffer.x = e), (this._activeBuffer.y = t)),
                  this._restrictCursor(),
                  this._dirtyRowTracker.markDirty(this._activeBuffer.y)
              }
              _moveCursor(e, t) {
                this._restrictCursor(),
                  this._setCursor(
                    this._activeBuffer.x + e,
                    this._activeBuffer.y + t
                  )
              }
              cursorUp(e) {
                const t = this._activeBuffer.y - this._activeBuffer.scrollTop
                return (
                  t >= 0
                    ? this._moveCursor(0, -Math.min(t, e.params[0] || 1))
                    : this._moveCursor(0, -(e.params[0] || 1)),
                  !0
                )
              }
              cursorDown(e) {
                const t = this._activeBuffer.scrollBottom - this._activeBuffer.y
                return (
                  t >= 0
                    ? this._moveCursor(0, Math.min(t, e.params[0] || 1))
                    : this._moveCursor(0, e.params[0] || 1),
                  !0
                )
              }
              cursorForward(e) {
                return this._moveCursor(e.params[0] || 1, 0), !0
              }
              cursorBackward(e) {
                return this._moveCursor(-(e.params[0] || 1), 0), !0
              }
              cursorNextLine(e) {
                return this.cursorDown(e), (this._activeBuffer.x = 0), !0
              }
              cursorPrecedingLine(e) {
                return this.cursorUp(e), (this._activeBuffer.x = 0), !0
              }
              cursorCharAbsolute(e) {
                return (
                  this._setCursor((e.params[0] || 1) - 1, this._activeBuffer.y),
                  !0
                )
              }
              cursorPosition(e) {
                return (
                  this._setCursor(
                    e.length >= 2 ? (e.params[1] || 1) - 1 : 0,
                    (e.params[0] || 1) - 1
                  ),
                  !0
                )
              }
              charPosAbsolute(e) {
                return (
                  this._setCursor((e.params[0] || 1) - 1, this._activeBuffer.y),
                  !0
                )
              }
              hPositionRelative(e) {
                return this._moveCursor(e.params[0] || 1, 0), !0
              }
              linePosAbsolute(e) {
                return (
                  this._setCursor(this._activeBuffer.x, (e.params[0] || 1) - 1),
                  !0
                )
              }
              vPositionRelative(e) {
                return this._moveCursor(0, e.params[0] || 1), !0
              }
              hVPosition(e) {
                return this.cursorPosition(e), !0
              }
              tabClear(e) {
                const t = e.params[0]
                return (
                  0 === t
                    ? delete this._activeBuffer.tabs[this._activeBuffer.x]
                    : 3 === t && (this._activeBuffer.tabs = {}),
                  !0
                )
              }
              cursorForwardTab(e) {
                if (this._activeBuffer.x >= this._bufferService.cols) return !0
                let t = e.params[0] || 1
                for (; t--; )
                  this._activeBuffer.x = this._activeBuffer.nextStop()
                return !0
              }
              cursorBackwardTab(e) {
                if (this._activeBuffer.x >= this._bufferService.cols) return !0
                let t = e.params[0] || 1
                for (; t--; )
                  this._activeBuffer.x = this._activeBuffer.prevStop()
                return !0
              }
              selectProtected(e) {
                const t = e.params[0]
                return (
                  1 === t && (this._curAttrData.bg |= 536870912),
                  (2 !== t && 0 !== t) || (this._curAttrData.bg &= -536870913),
                  !0
                )
              }
              _eraseInBufferLine(e, t, n, o = !1, i = !1) {
                const r = this._activeBuffer.lines.get(
                  this._activeBuffer.ybase + e
                )
                r.replaceCells(
                  t,
                  n,
                  this._activeBuffer.getNullCell(this._eraseAttrData()),
                  i
                ),
                  o && (r.isWrapped = !1)
              }
              _resetBufferLine(e, t = !1) {
                const n = this._activeBuffer.lines.get(
                  this._activeBuffer.ybase + e
                )
                n &&
                  (n.fill(
                    this._activeBuffer.getNullCell(this._eraseAttrData()),
                    t
                  ),
                  this._bufferService.buffer.clearMarkers(
                    this._activeBuffer.ybase + e
                  ),
                  (n.isWrapped = !1))
              }
              eraseInDisplay(e, t = !1) {
                let n
                switch (
                  (this._restrictCursor(this._bufferService.cols), e.params[0])
                ) {
                  case 0:
                    for (
                      n = this._activeBuffer.y,
                        this._dirtyRowTracker.markDirty(n),
                        this._eraseInBufferLine(
                          n++,
                          this._activeBuffer.x,
                          this._bufferService.cols,
                          0 === this._activeBuffer.x,
                          t
                        );
                      n < this._bufferService.rows;
                      n++
                    )
                      this._resetBufferLine(n, t)
                    this._dirtyRowTracker.markDirty(n)
                    break
                  case 1:
                    for (
                      n = this._activeBuffer.y,
                        this._dirtyRowTracker.markDirty(n),
                        this._eraseInBufferLine(
                          n,
                          0,
                          this._activeBuffer.x + 1,
                          !0,
                          t
                        ),
                        this._activeBuffer.x + 1 >= this._bufferService.cols &&
                          (this._activeBuffer.lines.get(n + 1).isWrapped = !1);
                      n--;

                    )
                      this._resetBufferLine(n, t)
                    this._dirtyRowTracker.markDirty(0)
                    break
                  case 2:
                    for (
                      n = this._bufferService.rows,
                        this._dirtyRowTracker.markDirty(n - 1);
                      n--;

                    )
                      this._resetBufferLine(n, t)
                    this._dirtyRowTracker.markDirty(0)
                    break
                  case 3:
                    const e =
                      this._activeBuffer.lines.length - this._bufferService.rows
                    e > 0 &&
                      (this._activeBuffer.lines.trimStart(e),
                      (this._activeBuffer.ybase = Math.max(
                        this._activeBuffer.ybase - e,
                        0
                      )),
                      (this._activeBuffer.ydisp = Math.max(
                        this._activeBuffer.ydisp - e,
                        0
                      )),
                      this._onScroll.fire(0))
                }
                return !0
              }
              eraseInLine(e, t = !1) {
                switch (
                  (this._restrictCursor(this._bufferService.cols), e.params[0])
                ) {
                  case 0:
                    this._eraseInBufferLine(
                      this._activeBuffer.y,
                      this._activeBuffer.x,
                      this._bufferService.cols,
                      0 === this._activeBuffer.x,
                      t
                    )
                    break
                  case 1:
                    this._eraseInBufferLine(
                      this._activeBuffer.y,
                      0,
                      this._activeBuffer.x + 1,
                      !1,
                      t
                    )
                    break
                  case 2:
                    this._eraseInBufferLine(
                      this._activeBuffer.y,
                      0,
                      this._bufferService.cols,
                      !0,
                      t
                    )
                }
                return this._dirtyRowTracker.markDirty(this._activeBuffer.y), !0
              }
              insertLines(e) {
                this._restrictCursor()
                let t = e.params[0] || 1
                if (
                  this._activeBuffer.y > this._activeBuffer.scrollBottom ||
                  this._activeBuffer.y < this._activeBuffer.scrollTop
                )
                  return !0
                const n = this._activeBuffer.ybase + this._activeBuffer.y,
                  o =
                    this._bufferService.rows -
                    1 -
                    this._activeBuffer.scrollBottom,
                  i =
                    this._bufferService.rows -
                    1 +
                    this._activeBuffer.ybase -
                    o +
                    1
                for (; t--; )
                  this._activeBuffer.lines.splice(i - 1, 1),
                    this._activeBuffer.lines.splice(
                      n,
                      0,
                      this._activeBuffer.getBlankLine(this._eraseAttrData())
                    )
                return (
                  this._dirtyRowTracker.markRangeDirty(
                    this._activeBuffer.y,
                    this._activeBuffer.scrollBottom
                  ),
                  (this._activeBuffer.x = 0),
                  !0
                )
              }
              deleteLines(e) {
                this._restrictCursor()
                let t = e.params[0] || 1
                if (
                  this._activeBuffer.y > this._activeBuffer.scrollBottom ||
                  this._activeBuffer.y < this._activeBuffer.scrollTop
                )
                  return !0
                const n = this._activeBuffer.ybase + this._activeBuffer.y
                let o
                for (
                  o =
                    this._bufferService.rows -
                    1 -
                    this._activeBuffer.scrollBottom,
                    o =
                      this._bufferService.rows -
                      1 +
                      this._activeBuffer.ybase -
                      o;
                  t--;

                )
                  this._activeBuffer.lines.splice(n, 1),
                    this._activeBuffer.lines.splice(
                      o,
                      0,
                      this._activeBuffer.getBlankLine(this._eraseAttrData())
                    )
                return (
                  this._dirtyRowTracker.markRangeDirty(
                    this._activeBuffer.y,
                    this._activeBuffer.scrollBottom
                  ),
                  (this._activeBuffer.x = 0),
                  !0
                )
              }
              insertChars(e) {
                this._restrictCursor()
                const t = this._activeBuffer.lines.get(
                  this._activeBuffer.ybase + this._activeBuffer.y
                )
                return (
                  t &&
                    (t.insertCells(
                      this._activeBuffer.x,
                      e.params[0] || 1,
                      this._activeBuffer.getNullCell(this._eraseAttrData())
                    ),
                    this._dirtyRowTracker.markDirty(this._activeBuffer.y)),
                  !0
                )
              }
              deleteChars(e) {
                this._restrictCursor()
                const t = this._activeBuffer.lines.get(
                  this._activeBuffer.ybase + this._activeBuffer.y
                )
                return (
                  t &&
                    (t.deleteCells(
                      this._activeBuffer.x,
                      e.params[0] || 1,
                      this._activeBuffer.getNullCell(this._eraseAttrData())
                    ),
                    this._dirtyRowTracker.markDirty(this._activeBuffer.y)),
                  !0
                )
              }
              scrollUp(e) {
                let t = e.params[0] || 1
                for (; t--; )
                  this._activeBuffer.lines.splice(
                    this._activeBuffer.ybase + this._activeBuffer.scrollTop,
                    1
                  ),
                    this._activeBuffer.lines.splice(
                      this._activeBuffer.ybase +
                        this._activeBuffer.scrollBottom,
                      0,
                      this._activeBuffer.getBlankLine(this._eraseAttrData())
                    )
                return (
                  this._dirtyRowTracker.markRangeDirty(
                    this._activeBuffer.scrollTop,
                    this._activeBuffer.scrollBottom
                  ),
                  !0
                )
              }
              scrollDown(e) {
                let t = e.params[0] || 1
                for (; t--; )
                  this._activeBuffer.lines.splice(
                    this._activeBuffer.ybase + this._activeBuffer.scrollBottom,
                    1
                  ),
                    this._activeBuffer.lines.splice(
                      this._activeBuffer.ybase + this._activeBuffer.scrollTop,
                      0,
                      this._activeBuffer.getBlankLine(d.DEFAULT_ATTR_DATA)
                    )
                return (
                  this._dirtyRowTracker.markRangeDirty(
                    this._activeBuffer.scrollTop,
                    this._activeBuffer.scrollBottom
                  ),
                  !0
                )
              }
              scrollLeft(e) {
                if (
                  this._activeBuffer.y > this._activeBuffer.scrollBottom ||
                  this._activeBuffer.y < this._activeBuffer.scrollTop
                )
                  return !0
                const t = e.params[0] || 1
                for (
                  let n = this._activeBuffer.scrollTop;
                  n <= this._activeBuffer.scrollBottom;
                  ++n
                ) {
                  const e = this._activeBuffer.lines.get(
                    this._activeBuffer.ybase + n
                  )
                  e.deleteCells(
                    0,
                    t,
                    this._activeBuffer.getNullCell(this._eraseAttrData())
                  ),
                    (e.isWrapped = !1)
                }
                return (
                  this._dirtyRowTracker.markRangeDirty(
                    this._activeBuffer.scrollTop,
                    this._activeBuffer.scrollBottom
                  ),
                  !0
                )
              }
              scrollRight(e) {
                if (
                  this._activeBuffer.y > this._activeBuffer.scrollBottom ||
                  this._activeBuffer.y < this._activeBuffer.scrollTop
                )
                  return !0
                const t = e.params[0] || 1
                for (
                  let n = this._activeBuffer.scrollTop;
                  n <= this._activeBuffer.scrollBottom;
                  ++n
                ) {
                  const e = this._activeBuffer.lines.get(
                    this._activeBuffer.ybase + n
                  )
                  e.insertCells(
                    0,
                    t,
                    this._activeBuffer.getNullCell(this._eraseAttrData())
                  ),
                    (e.isWrapped = !1)
                }
                return (
                  this._dirtyRowTracker.markRangeDirty(
                    this._activeBuffer.scrollTop,
                    this._activeBuffer.scrollBottom
                  ),
                  !0
                )
              }
              insertColumns(e) {
                if (
                  this._activeBuffer.y > this._activeBuffer.scrollBottom ||
                  this._activeBuffer.y < this._activeBuffer.scrollTop
                )
                  return !0
                const t = e.params[0] || 1
                for (
                  let n = this._activeBuffer.scrollTop;
                  n <= this._activeBuffer.scrollBottom;
                  ++n
                ) {
                  const e = this._activeBuffer.lines.get(
                    this._activeBuffer.ybase + n
                  )
                  e.insertCells(
                    this._activeBuffer.x,
                    t,
                    this._activeBuffer.getNullCell(this._eraseAttrData())
                  ),
                    (e.isWrapped = !1)
                }
                return (
                  this._dirtyRowTracker.markRangeDirty(
                    this._activeBuffer.scrollTop,
                    this._activeBuffer.scrollBottom
                  ),
                  !0
                )
              }
              deleteColumns(e) {
                if (
                  this._activeBuffer.y > this._activeBuffer.scrollBottom ||
                  this._activeBuffer.y < this._activeBuffer.scrollTop
                )
                  return !0
                const t = e.params[0] || 1
                for (
                  let n = this._activeBuffer.scrollTop;
                  n <= this._activeBuffer.scrollBottom;
                  ++n
                ) {
                  const e = this._activeBuffer.lines.get(
                    this._activeBuffer.ybase + n
                  )
                  e.deleteCells(
                    this._activeBuffer.x,
                    t,
                    this._activeBuffer.getNullCell(this._eraseAttrData())
                  ),
                    (e.isWrapped = !1)
                }
                return (
                  this._dirtyRowTracker.markRangeDirty(
                    this._activeBuffer.scrollTop,
                    this._activeBuffer.scrollBottom
                  ),
                  !0
                )
              }
              eraseChars(e) {
                this._restrictCursor()
                const t = this._activeBuffer.lines.get(
                  this._activeBuffer.ybase + this._activeBuffer.y
                )
                return (
                  t &&
                    (t.replaceCells(
                      this._activeBuffer.x,
                      this._activeBuffer.x + (e.params[0] || 1),
                      this._activeBuffer.getNullCell(this._eraseAttrData())
                    ),
                    this._dirtyRowTracker.markDirty(this._activeBuffer.y)),
                  !0
                )
              }
              repeatPrecedingCharacter(e) {
                const t = this._parser.precedingJoinState
                if (!t) return !0
                const n = e.params[0] || 1,
                  o = _.UnicodeService.extractWidth(t),
                  i = this._activeBuffer.x - o,
                  r = this._activeBuffer.lines
                    .get(this._activeBuffer.ybase + this._activeBuffer.y)
                    .getString(i),
                  a = new Uint32Array(r.length * n)
                let s = 0
                for (let c = 0; c < r.length; ) {
                  const e = r.codePointAt(c) || 0
                  ;(a[s++] = e), (c += e > 65535 ? 2 : 1)
                }
                let l = s
                for (let c = 1; c < n; ++c) a.copyWithin(l, 0, s), (l += s)
                return this.print(a, 0, l), !0
              }
              sendDeviceAttributesPrimary(e) {
                return (
                  e.params[0] > 0 ||
                    (this._is('xterm') ||
                    this._is('rxvt-unicode') ||
                    this._is('screen')
                      ? this._coreService.triggerDataEvent(r.C0.ESC + '[?1;2c')
                      : this._is('linux') &&
                        this._coreService.triggerDataEvent(r.C0.ESC + '[?6c')),
                  !0
                )
              }
              sendDeviceAttributesSecondary(e) {
                return (
                  e.params[0] > 0 ||
                    (this._is('xterm')
                      ? this._coreService.triggerDataEvent(
                          r.C0.ESC + '[>0;276;0c'
                        )
                      : this._is('rxvt-unicode')
                        ? this._coreService.triggerDataEvent(
                            r.C0.ESC + '[>85;95;0c'
                          )
                        : this._is('linux')
                          ? this._coreService.triggerDataEvent(
                              e.params[0] + 'c'
                            )
                          : this._is('screen') &&
                            this._coreService.triggerDataEvent(
                              r.C0.ESC + '[>83;40003;0c'
                            )),
                  !0
                )
              }
              _is(e) {
                return (
                  0 ===
                  (this._optionsService.rawOptions.termName + '').indexOf(e)
                )
              }
              setMode(e) {
                for (let t = 0; t < e.length; t++)
                  switch (e.params[t]) {
                    case 4:
                      this._coreService.modes.insertMode = !0
                      break
                    case 20:
                      this._optionsService.options.convertEol = !0
                  }
                return !0
              }
              setModePrivate(e) {
                for (let t = 0; t < e.length; t++)
                  switch (e.params[t]) {
                    case 1:
                      this._coreService.decPrivateModes.applicationCursorKeys =
                        !0
                      break
                    case 2:
                      this._charsetService.setgCharset(0, a.DEFAULT_CHARSET),
                        this._charsetService.setgCharset(1, a.DEFAULT_CHARSET),
                        this._charsetService.setgCharset(2, a.DEFAULT_CHARSET),
                        this._charsetService.setgCharset(3, a.DEFAULT_CHARSET)
                      break
                    case 3:
                      this._optionsService.rawOptions.windowOptions
                        .setWinLines &&
                        (this._bufferService.resize(
                          132,
                          this._bufferService.rows
                        ),
                        this._onRequestReset.fire())
                      break
                    case 6:
                      ;(this._coreService.decPrivateModes.origin = !0),
                        this._setCursor(0, 0)
                      break
                    case 7:
                      this._coreService.decPrivateModes.wraparound = !0
                      break
                    case 12:
                      this._optionsService.options.cursorBlink = !0
                      break
                    case 45:
                      this._coreService.decPrivateModes.reverseWraparound = !0
                      break
                    case 66:
                      this._logService.debug(
                        'Serial port requested application keypad.'
                      ),
                        (this._coreService.decPrivateModes.applicationKeypad =
                          !0),
                        this._onRequestSyncScrollBar.fire()
                      break
                    case 9:
                      this._coreMouseService.activeProtocol = 'X10'
                      break
                    case 1e3:
                      this._coreMouseService.activeProtocol = 'VT200'
                      break
                    case 1002:
                      this._coreMouseService.activeProtocol = 'DRAG'
                      break
                    case 1003:
                      this._coreMouseService.activeProtocol = 'ANY'
                      break
                    case 1004:
                      ;(this._coreService.decPrivateModes.sendFocus = !0),
                        this._onRequestSendFocus.fire()
                      break
                    case 1005:
                      this._logService.debug(
                        'DECSET 1005 not supported (see #2507)'
                      )
                      break
                    case 1006:
                      this._coreMouseService.activeEncoding = 'SGR'
                      break
                    case 1015:
                      this._logService.debug(
                        'DECSET 1015 not supported (see #2507)'
                      )
                      break
                    case 1016:
                      this._coreMouseService.activeEncoding = 'SGR_PIXELS'
                      break
                    case 25:
                      this._coreService.isCursorHidden = !1
                      break
                    case 1048:
                      this.saveCursor()
                      break
                    case 1049:
                      this.saveCursor()
                    case 47:
                    case 1047:
                      this._bufferService.buffers.activateAltBuffer(
                        this._eraseAttrData()
                      ),
                        (this._coreService.isCursorInitialized = !0),
                        this._onRequestRefreshRows.fire(
                          0,
                          this._bufferService.rows - 1
                        ),
                        this._onRequestSyncScrollBar.fire()
                      break
                    case 2004:
                      this._coreService.decPrivateModes.bracketedPasteMode = !0
                  }
                return !0
              }
              resetMode(e) {
                for (let t = 0; t < e.length; t++)
                  switch (e.params[t]) {
                    case 4:
                      this._coreService.modes.insertMode = !1
                      break
                    case 20:
                      this._optionsService.options.convertEol = !1
                  }
                return !0
              }
              resetModePrivate(e) {
                for (let t = 0; t < e.length; t++)
                  switch (e.params[t]) {
                    case 1:
                      this._coreService.decPrivateModes.applicationCursorKeys =
                        !1
                      break
                    case 3:
                      this._optionsService.rawOptions.windowOptions
                        .setWinLines &&
                        (this._bufferService.resize(
                          80,
                          this._bufferService.rows
                        ),
                        this._onRequestReset.fire())
                      break
                    case 6:
                      ;(this._coreService.decPrivateModes.origin = !1),
                        this._setCursor(0, 0)
                      break
                    case 7:
                      this._coreService.decPrivateModes.wraparound = !1
                      break
                    case 12:
                      this._optionsService.options.cursorBlink = !1
                      break
                    case 45:
                      this._coreService.decPrivateModes.reverseWraparound = !1
                      break
                    case 66:
                      this._logService.debug(
                        'Switching back to normal keypad.'
                      ),
                        (this._coreService.decPrivateModes.applicationKeypad =
                          !1),
                        this._onRequestSyncScrollBar.fire()
                      break
                    case 9:
                    case 1e3:
                    case 1002:
                    case 1003:
                      this._coreMouseService.activeProtocol = 'NONE'
                      break
                    case 1004:
                      this._coreService.decPrivateModes.sendFocus = !1
                      break
                    case 1005:
                      this._logService.debug(
                        'DECRST 1005 not supported (see #2507)'
                      )
                      break
                    case 1006:
                    case 1016:
                      this._coreMouseService.activeEncoding = 'DEFAULT'
                      break
                    case 1015:
                      this._logService.debug(
                        'DECRST 1015 not supported (see #2507)'
                      )
                      break
                    case 25:
                      this._coreService.isCursorHidden = !0
                      break
                    case 1048:
                      this.restoreCursor()
                      break
                    case 1049:
                    case 47:
                    case 1047:
                      this._bufferService.buffers.activateNormalBuffer(),
                        1049 === e.params[t] && this.restoreCursor(),
                        (this._coreService.isCursorInitialized = !0),
                        this._onRequestRefreshRows.fire(
                          0,
                          this._bufferService.rows - 1
                        ),
                        this._onRequestSyncScrollBar.fire()
                      break
                    case 2004:
                      this._coreService.decPrivateModes.bracketedPasteMode = !1
                  }
                return !0
              }
              requestMode(e, t) {
                const n = this._coreService.decPrivateModes,
                  { activeProtocol: o, activeEncoding: i } =
                    this._coreMouseService,
                  a = this._coreService,
                  { buffers: s, cols: l } = this._bufferService,
                  { active: c, alt: d } = s,
                  u = this._optionsService.rawOptions,
                  p = __name((e) => (e ? 1 : 2), '_'),
                  h = e.params[0]
                return (
                  (m = h),
                  (f = t
                    ? 2 === h
                      ? 4
                      : 4 === h
                        ? p(a.modes.insertMode)
                        : 12 === h
                          ? 3
                          : 20 === h
                            ? p(u.convertEol)
                            : 0
                    : 1 === h
                      ? p(n.applicationCursorKeys)
                      : 3 === h
                        ? u.windowOptions.setWinLines
                          ? 80 === l
                            ? 2
                            : 132 === l
                              ? 1
                              : 0
                          : 0
                        : 6 === h
                          ? p(n.origin)
                          : 7 === h
                            ? p(n.wraparound)
                            : 8 === h
                              ? 3
                              : 9 === h
                                ? p('X10' === o)
                                : 12 === h
                                  ? p(u.cursorBlink)
                                  : 25 === h
                                    ? p(!a.isCursorHidden)
                                    : 45 === h
                                      ? p(n.reverseWraparound)
                                      : 66 === h
                                        ? p(n.applicationKeypad)
                                        : 67 === h
                                          ? 4
                                          : 1e3 === h
                                            ? p('VT200' === o)
                                            : 1002 === h
                                              ? p('DRAG' === o)
                                              : 1003 === h
                                                ? p('ANY' === o)
                                                : 1004 === h
                                                  ? p(n.sendFocus)
                                                  : 1005 === h
                                                    ? 4
                                                    : 1006 === h
                                                      ? p('SGR' === i)
                                                      : 1015 === h
                                                        ? 4
                                                        : 1016 === h
                                                          ? p(
                                                              'SGR_PIXELS' === i
                                                            )
                                                          : 1048 === h
                                                            ? 1
                                                            : 47 === h ||
                                                                1047 === h ||
                                                                1049 === h
                                                              ? p(c === d)
                                                              : 2004 === h
                                                                ? p(
                                                                    n.bracketedPasteMode
                                                                  )
                                                                : 0),
                  a.triggerDataEvent(`${r.C0.ESC}[${t ? '' : '?'}${m};${f}$y`),
                  !0
                )
                var m, f
              }
              _updateAttrColor(e, t, n, o, i) {
                return (
                  2 === t
                    ? ((e |= 50331648),
                      (e &= -16777216),
                      (e |= m.AttributeData.fromColorRGB([n, o, i])))
                    : 5 === t &&
                      ((e &= -50331904), (e |= 33554432 | (255 & n))),
                  e
                )
              }
              _extractColor(e, t, n) {
                const o = [0, 0, -1, 0, 0, 0]
                let i = 0,
                  r = 0
                do {
                  if (((o[r + i] = e.params[t + r]), e.hasSubParams(t + r))) {
                    const n = e.getSubParams(t + r)
                    let a = 0
                    do {
                      5 === o[1] && (i = 1), (o[r + a + 1 + i] = n[a])
                    } while (++a < n.length && a + r + 1 + i < o.length)
                    break
                  }
                  if ((5 === o[1] && r + i >= 2) || (2 === o[1] && r + i >= 5))
                    break
                  o[1] && (i = 1)
                } while (++r + t < e.length && r + i < o.length)
                for (let a = 2; a < o.length; ++a) -1 === o[a] && (o[a] = 0)
                switch (o[0]) {
                  case 38:
                    n.fg = this._updateAttrColor(n.fg, o[1], o[3], o[4], o[5])
                    break
                  case 48:
                    n.bg = this._updateAttrColor(n.bg, o[1], o[3], o[4], o[5])
                    break
                  case 58:
                    ;(n.extended = n.extended.clone()),
                      (n.extended.underlineColor = this._updateAttrColor(
                        n.extended.underlineColor,
                        o[1],
                        o[3],
                        o[4],
                        o[5]
                      ))
                }
                return r
              }
              _processUnderline(e, t) {
                ;(t.extended = t.extended.clone()),
                  (!~e || e > 5) && (e = 1),
                  (t.extended.underlineStyle = e),
                  (t.fg |= 268435456),
                  0 === e && (t.fg &= -268435457),
                  t.updateExtended()
              }
              _processSGR0(e) {
                ;(e.fg = d.DEFAULT_ATTR_DATA.fg),
                  (e.bg = d.DEFAULT_ATTR_DATA.bg),
                  (e.extended = e.extended.clone()),
                  (e.extended.underlineStyle = 0),
                  (e.extended.underlineColor &= -67108864),
                  e.updateExtended()
              }
              charAttributes(e) {
                if (1 === e.length && 0 === e.params[0])
                  return this._processSGR0(this._curAttrData), !0
                const t = e.length
                let n
                const o = this._curAttrData
                for (let i = 0; i < t; i++)
                  (n = e.params[i]),
                    n >= 30 && n <= 37
                      ? ((o.fg &= -50331904), (o.fg |= 16777216 | (n - 30)))
                      : n >= 40 && n <= 47
                        ? ((o.bg &= -50331904), (o.bg |= 16777216 | (n - 40)))
                        : n >= 90 && n <= 97
                          ? ((o.fg &= -50331904), (o.fg |= 16777224 | (n - 90)))
                          : n >= 100 && n <= 107
                            ? ((o.bg &= -50331904),
                              (o.bg |= 16777224 | (n - 100)))
                            : 0 === n
                              ? this._processSGR0(o)
                              : 1 === n
                                ? (o.fg |= 134217728)
                                : 3 === n
                                  ? (o.bg |= 67108864)
                                  : 4 === n
                                    ? ((o.fg |= 268435456),
                                      this._processUnderline(
                                        e.hasSubParams(i)
                                          ? e.getSubParams(i)[0]
                                          : 1,
                                        o
                                      ))
                                    : 5 === n
                                      ? (o.fg |= 536870912)
                                      : 7 === n
                                        ? (o.fg |= 67108864)
                                        : 8 === n
                                          ? (o.fg |= 1073741824)
                                          : 9 === n
                                            ? (o.fg |= 2147483648)
                                            : 2 === n
                                              ? (o.bg |= 134217728)
                                              : 21 === n
                                                ? this._processUnderline(2, o)
                                                : 22 === n
                                                  ? ((o.fg &= -134217729),
                                                    (o.bg &= -134217729))
                                                  : 23 === n
                                                    ? (o.bg &= -67108865)
                                                    : 24 === n
                                                      ? ((o.fg &= -268435457),
                                                        this._processUnderline(
                                                          0,
                                                          o
                                                        ))
                                                      : 25 === n
                                                        ? (o.fg &= -536870913)
                                                        : 27 === n
                                                          ? (o.fg &= -67108865)
                                                          : 28 === n
                                                            ? (o.fg &=
                                                                -1073741825)
                                                            : 29 === n
                                                              ? (o.fg &= 2147483647)
                                                              : 39 === n
                                                                ? ((o.fg &=
                                                                    -67108864),
                                                                  (o.fg |=
                                                                    16777215 &
                                                                    d
                                                                      .DEFAULT_ATTR_DATA
                                                                      .fg))
                                                                : 49 === n
                                                                  ? ((o.bg &=
                                                                      -67108864),
                                                                    (o.bg |=
                                                                      16777215 &
                                                                      d
                                                                        .DEFAULT_ATTR_DATA
                                                                        .bg))
                                                                  : 38 === n ||
                                                                      48 ===
                                                                        n ||
                                                                      58 === n
                                                                    ? (i +=
                                                                        this._extractColor(
                                                                          e,
                                                                          i,
                                                                          o
                                                                        ))
                                                                    : 53 === n
                                                                      ? (o.bg |= 1073741824)
                                                                      : 55 === n
                                                                        ? (o.bg &=
                                                                            -1073741825)
                                                                        : 59 ===
                                                                            n
                                                                          ? ((o.extended =
                                                                              o.extended.clone()),
                                                                            (o.extended.underlineColor =
                                                                              -1),
                                                                            o.updateExtended())
                                                                          : 100 ===
                                                                              n
                                                                            ? ((o.fg &=
                                                                                -67108864),
                                                                              (o.fg |=
                                                                                16777215 &
                                                                                d
                                                                                  .DEFAULT_ATTR_DATA
                                                                                  .fg),
                                                                              (o.bg &=
                                                                                -67108864),
                                                                              (o.bg |=
                                                                                16777215 &
                                                                                d
                                                                                  .DEFAULT_ATTR_DATA
                                                                                  .bg))
                                                                            : this._logService.debug(
                                                                                'Unknown SGR attribute: %d.',
                                                                                n
                                                                              )
                return !0
              }
              deviceStatus(e) {
                switch (e.params[0]) {
                  case 5:
                    this._coreService.triggerDataEvent(`${r.C0.ESC}[0n`)
                    break
                  case 6:
                    const e = this._activeBuffer.y + 1,
                      t = this._activeBuffer.x + 1
                    this._coreService.triggerDataEvent(`${r.C0.ESC}[${e};${t}R`)
                }
                return !0
              }
              deviceStatusPrivate(e) {
                if (6 === e.params[0]) {
                  const e = this._activeBuffer.y + 1,
                    t = this._activeBuffer.x + 1
                  this._coreService.triggerDataEvent(`${r.C0.ESC}[?${e};${t}R`)
                }
                return !0
              }
              softReset(e) {
                return (
                  (this._coreService.isCursorHidden = !1),
                  this._onRequestSyncScrollBar.fire(),
                  (this._activeBuffer.scrollTop = 0),
                  (this._activeBuffer.scrollBottom =
                    this._bufferService.rows - 1),
                  (this._curAttrData = d.DEFAULT_ATTR_DATA.clone()),
                  this._coreService.reset(),
                  this._charsetService.reset(),
                  (this._activeBuffer.savedX = 0),
                  (this._activeBuffer.savedY = this._activeBuffer.ybase),
                  (this._activeBuffer.savedCurAttrData.fg =
                    this._curAttrData.fg),
                  (this._activeBuffer.savedCurAttrData.bg =
                    this._curAttrData.bg),
                  (this._activeBuffer.savedCharset =
                    this._charsetService.charset),
                  (this._coreService.decPrivateModes.origin = !1),
                  !0
                )
              }
              setCursorStyle(e) {
                const t = e.params[0] || 1
                switch (t) {
                  case 1:
                  case 2:
                    this._optionsService.options.cursorStyle = 'block'
                    break
                  case 3:
                  case 4:
                    this._optionsService.options.cursorStyle = 'underline'
                    break
                  case 5:
                  case 6:
                    this._optionsService.options.cursorStyle = 'bar'
                }
                const n = t % 2 == 1
                return (this._optionsService.options.cursorBlink = n), !0
              }
              setScrollRegion(e) {
                const t = e.params[0] || 1
                let n
                return (
                  (e.length < 2 ||
                    (n = e.params[1]) > this._bufferService.rows ||
                    0 === n) &&
                    (n = this._bufferService.rows),
                  n > t &&
                    ((this._activeBuffer.scrollTop = t - 1),
                    (this._activeBuffer.scrollBottom = n - 1),
                    this._setCursor(0, 0)),
                  !0
                )
              }
              windowOptions(e) {
                if (
                  !C(e.params[0], this._optionsService.rawOptions.windowOptions)
                )
                  return !0
                const t = e.length > 1 ? e.params[1] : 0
                switch (e.params[0]) {
                  case 14:
                    2 !== t &&
                      this._onRequestWindowsOptionsReport.fire(
                        w.GET_WIN_SIZE_PIXELS
                      )
                    break
                  case 16:
                    this._onRequestWindowsOptionsReport.fire(
                      w.GET_CELL_SIZE_PIXELS
                    )
                    break
                  case 18:
                    this._bufferService &&
                      this._coreService.triggerDataEvent(
                        `${r.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`
                      )
                    break
                  case 22:
                    ;(0 !== t && 2 !== t) ||
                      (this._windowTitleStack.push(this._windowTitle),
                      this._windowTitleStack.length > 10 &&
                        this._windowTitleStack.shift()),
                      (0 !== t && 1 !== t) ||
                        (this._iconNameStack.push(this._iconName),
                        this._iconNameStack.length > 10 &&
                          this._iconNameStack.shift())
                    break
                  case 23:
                    ;(0 !== t && 2 !== t) ||
                      (this._windowTitleStack.length &&
                        this.setTitle(this._windowTitleStack.pop())),
                      (0 !== t && 1 !== t) ||
                        (this._iconNameStack.length &&
                          this.setIconName(this._iconNameStack.pop()))
                }
                return !0
              }
              saveCursor(e) {
                return (
                  (this._activeBuffer.savedX = this._activeBuffer.x),
                  (this._activeBuffer.savedY =
                    this._activeBuffer.ybase + this._activeBuffer.y),
                  (this._activeBuffer.savedCurAttrData.fg =
                    this._curAttrData.fg),
                  (this._activeBuffer.savedCurAttrData.bg =
                    this._curAttrData.bg),
                  (this._activeBuffer.savedCharset =
                    this._charsetService.charset),
                  !0
                )
              }
              restoreCursor(e) {
                return (
                  (this._activeBuffer.x = this._activeBuffer.savedX || 0),
                  (this._activeBuffer.y = Math.max(
                    this._activeBuffer.savedY - this._activeBuffer.ybase,
                    0
                  )),
                  (this._curAttrData.fg =
                    this._activeBuffer.savedCurAttrData.fg),
                  (this._curAttrData.bg =
                    this._activeBuffer.savedCurAttrData.bg),
                  (this._charsetService.charset = this._savedCharset),
                  this._activeBuffer.savedCharset &&
                    (this._charsetService.charset =
                      this._activeBuffer.savedCharset),
                  this._restrictCursor(),
                  !0
                )
              }
              setTitle(e) {
                return (this._windowTitle = e), this._onTitleChange.fire(e), !0
              }
              setIconName(e) {
                return (this._iconName = e), !0
              }
              setOrReportIndexedColor(e) {
                const t = [],
                  n = e.split(';')
                for (; n.length > 1; ) {
                  const e = n.shift(),
                    o = n.shift()
                  if (/^\d+$/.exec(e)) {
                    const n = parseInt(e)
                    if (T(n))
                      if ('?' === o) t.push({ type: 0, index: n })
                      else {
                        const e = (0, y.parseColor)(o)
                        e && t.push({ type: 1, index: n, color: e })
                      }
                  }
                }
                return t.length && this._onColor.fire(t), !0
              }
              setHyperlink(e) {
                const t = e.split(';')
                return (
                  !(t.length < 2) &&
                  (t[1]
                    ? this._createHyperlink(t[0], t[1])
                    : !t[0] && this._finishHyperlink())
                )
              }
              _createHyperlink(e, t) {
                this._getCurrentLinkId() && this._finishHyperlink()
                const n = e.split(':')
                let o
                const i = n.findIndex((e) => e.startsWith('id='))
                return (
                  -1 !== i && (o = n[i].slice(3) || void 0),
                  (this._curAttrData.extended =
                    this._curAttrData.extended.clone()),
                  (this._curAttrData.extended.urlId =
                    this._oscLinkService.registerLink({ id: o, uri: t })),
                  this._curAttrData.updateExtended(),
                  !0
                )
              }
              _finishHyperlink() {
                return (
                  (this._curAttrData.extended =
                    this._curAttrData.extended.clone()),
                  (this._curAttrData.extended.urlId = 0),
                  this._curAttrData.updateExtended(),
                  !0
                )
              }
              _setOrReportSpecialColor(e, t) {
                const n = e.split(';')
                for (
                  let o = 0;
                  o < n.length && !(t >= this._specialColors.length);
                  ++o, ++t
                )
                  if ('?' === n[o])
                    this._onColor.fire([
                      { type: 0, index: this._specialColors[t] }
                    ])
                  else {
                    const e = (0, y.parseColor)(n[o])
                    e &&
                      this._onColor.fire([
                        { type: 1, index: this._specialColors[t], color: e }
                      ])
                  }
                return !0
              }
              setOrReportFgColor(e) {
                return this._setOrReportSpecialColor(e, 0)
              }
              setOrReportBgColor(e) {
                return this._setOrReportSpecialColor(e, 1)
              }
              setOrReportCursorColor(e) {
                return this._setOrReportSpecialColor(e, 2)
              }
              restoreIndexedColor(e) {
                if (!e) return this._onColor.fire([{ type: 2 }]), !0
                const t = [],
                  n = e.split(';')
                for (let o = 0; o < n.length; ++o)
                  if (/^\d+$/.exec(n[o])) {
                    const e = parseInt(n[o])
                    T(e) && t.push({ type: 2, index: e })
                  }
                return t.length && this._onColor.fire(t), !0
              }
              restoreFgColor(e) {
                return this._onColor.fire([{ type: 2, index: 256 }]), !0
              }
              restoreBgColor(e) {
                return this._onColor.fire([{ type: 2, index: 257 }]), !0
              }
              restoreCursorColor(e) {
                return this._onColor.fire([{ type: 2, index: 258 }]), !0
              }
              nextLine() {
                return (this._activeBuffer.x = 0), this.index(), !0
              }
              keypadApplicationMode() {
                return (
                  this._logService.debug(
                    'Serial port requested application keypad.'
                  ),
                  (this._coreService.decPrivateModes.applicationKeypad = !0),
                  this._onRequestSyncScrollBar.fire(),
                  !0
                )
              }
              keypadNumericMode() {
                return (
                  this._logService.debug('Switching back to normal keypad.'),
                  (this._coreService.decPrivateModes.applicationKeypad = !1),
                  this._onRequestSyncScrollBar.fire(),
                  !0
                )
              }
              selectDefaultCharset() {
                return (
                  this._charsetService.setgLevel(0),
                  this._charsetService.setgCharset(0, a.DEFAULT_CHARSET),
                  !0
                )
              }
              selectCharset(e) {
                return 2 !== e.length
                  ? (this.selectDefaultCharset(), !0)
                  : ('/' === e[0] ||
                      this._charsetService.setgCharset(
                        b[e[0]],
                        a.CHARSETS[e[1]] || a.DEFAULT_CHARSET
                      ),
                    !0)
              }
              index() {
                return (
                  this._restrictCursor(),
                  this._activeBuffer.y++,
                  this._activeBuffer.y === this._activeBuffer.scrollBottom + 1
                    ? (this._activeBuffer.y--,
                      this._bufferService.scroll(this._eraseAttrData()))
                    : this._activeBuffer.y >= this._bufferService.rows &&
                      (this._activeBuffer.y = this._bufferService.rows - 1),
                  this._restrictCursor(),
                  !0
                )
              }
              tabSet() {
                return (this._activeBuffer.tabs[this._activeBuffer.x] = !0), !0
              }
              reverseIndex() {
                if (
                  (this._restrictCursor(),
                  this._activeBuffer.y === this._activeBuffer.scrollTop)
                ) {
                  const e =
                    this._activeBuffer.scrollBottom -
                    this._activeBuffer.scrollTop
                  this._activeBuffer.lines.shiftElements(
                    this._activeBuffer.ybase + this._activeBuffer.y,
                    e,
                    1
                  ),
                    this._activeBuffer.lines.set(
                      this._activeBuffer.ybase + this._activeBuffer.y,
                      this._activeBuffer.getBlankLine(this._eraseAttrData())
                    ),
                    this._dirtyRowTracker.markRangeDirty(
                      this._activeBuffer.scrollTop,
                      this._activeBuffer.scrollBottom
                    )
                } else this._activeBuffer.y--, this._restrictCursor()
                return !0
              }
              fullReset() {
                return this._parser.reset(), this._onRequestReset.fire(), !0
              }
              reset() {
                ;(this._curAttrData = d.DEFAULT_ATTR_DATA.clone()),
                  (this._eraseAttrDataInternal = d.DEFAULT_ATTR_DATA.clone())
              }
              _eraseAttrData() {
                return (
                  (this._eraseAttrDataInternal.bg &= -67108864),
                  (this._eraseAttrDataInternal.bg |=
                    67108863 & this._curAttrData.bg),
                  this._eraseAttrDataInternal
                )
              }
              setgLevel(e) {
                return this._charsetService.setgLevel(e), !0
              }
              screenAlignmentPattern() {
                const e = new h.CellData()
                ;(e.content = (1 << 22) | 'E'.charCodeAt(0)),
                  (e.fg = this._curAttrData.fg),
                  (e.bg = this._curAttrData.bg),
                  this._setCursor(0, 0)
                for (let t = 0; t < this._bufferService.rows; ++t) {
                  const n = this._activeBuffer.ybase + this._activeBuffer.y + t,
                    o = this._activeBuffer.lines.get(n)
                  o && (o.fill(e), (o.isWrapped = !1))
                }
                return (
                  this._dirtyRowTracker.markAllDirty(),
                  this._setCursor(0, 0),
                  !0
                )
              }
              requestStatusString(e, t) {
                const n = this._bufferService.buffer,
                  o = this._optionsService.rawOptions
                return ((e) => (
                  this._coreService.triggerDataEvent(
                    `${r.C0.ESC}${e}${r.C0.ESC}\\`
                  ),
                  !0
                ))(
                  '"q' === e
                    ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q`
                    : '"p' === e
                      ? 'P1$r61;1"p'
                      : 'r' === e
                        ? `P1$r${n.scrollTop + 1};${n.scrollBottom + 1}r`
                        : 'm' === e
                          ? 'P1$r0m'
                          : ' q' === e
                            ? `P1$r${{ block: 2, underline: 4, bar: 6 }[o.cursorStyle] - (o.cursorBlink ? 1 : 0)} q`
                            : 'P0$r'
                )
              }
              markRangeDirty(e, t) {
                this._dirtyRowTracker.markRangeDirty(e, t)
              }
            }
            t.InputHandler = E
            let I = class {
              static {
                __name(this, 'L')
              }
              constructor(e) {
                ;(this._bufferService = e), this.clearRange()
              }
              clearRange() {
                ;(this.start = this._bufferService.buffer.y),
                  (this.end = this._bufferService.buffer.y)
              }
              markDirty(e) {
                e < this.start
                  ? (this.start = e)
                  : e > this.end && (this.end = e)
              }
              markRangeDirty(e, t) {
                e > t && ((x = e), (e = t), (t = x)),
                  e < this.start && (this.start = e),
                  t > this.end && (this.end = t)
              }
              markAllDirty() {
                this.markRangeDirty(0, this._bufferService.rows - 1)
              }
            }
            function T(e) {
              return 0 <= e && e < 256
            }
            __name(T, 'D'), (I = o([i(0, f.IBufferService)], I))
          },
          844: (e, t) => {
            function n(e) {
              for (const t of e) t.dispose()
              e.length = 0
            }
            __name(n, 'i'),
              Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.getDisposeArrayDisposable =
                t.disposeArray =
                t.toDisposable =
                t.MutableDisposable =
                t.Disposable =
                  void 0),
              (t.Disposable = class {
                constructor() {
                  ;(this._disposables = []), (this._isDisposed = !1)
                }
                dispose() {
                  this._isDisposed = !0
                  for (const e of this._disposables) e.dispose()
                  this._disposables.length = 0
                }
                register(e) {
                  return this._disposables.push(e), e
                }
                unregister(e) {
                  const t = this._disposables.indexOf(e)
                  ;-1 !== t && this._disposables.splice(t, 1)
                }
              }),
              (t.MutableDisposable = class {
                constructor() {
                  this._isDisposed = !1
                }
                get value() {
                  return this._isDisposed ? void 0 : this._value
                }
                set value(e) {
                  this._isDisposed ||
                    e === this._value ||
                    (this._value?.dispose(), (this._value = e))
                }
                clear() {
                  this.value = void 0
                }
                dispose() {
                  ;(this._isDisposed = !0),
                    this._value?.dispose(),
                    (this._value = void 0)
                }
              }),
              (t.toDisposable = function (e) {
                return { dispose: e }
              }),
              (t.disposeArray = n),
              (t.getDisposeArrayDisposable = function (e) {
                return { dispose: __name(() => n(e), 'dispose') }
              })
          },
          1505: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.FourKeyMap = t.TwoKeyMap = void 0)
            class n {
              static {
                __name(this, 'i')
              }
              constructor() {
                this._data = {}
              }
              set(e, t, n) {
                this._data[e] || (this._data[e] = {}), (this._data[e][t] = n)
              }
              get(e, t) {
                return this._data[e] ? this._data[e][t] : void 0
              }
              clear() {
                this._data = {}
              }
            }
            ;(t.TwoKeyMap = n),
              (t.FourKeyMap = class {
                constructor() {
                  this._data = new n()
                }
                set(e, t, o, i, r) {
                  this._data.get(e, t) || this._data.set(e, t, new n()),
                    this._data.get(e, t).set(o, i, r)
                }
                get(e, t, n, o) {
                  return this._data.get(e, t)?.get(n, o)
                }
                clear() {
                  this._data.clear()
                }
              })
          },
          6114: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.isChromeOS =
                t.isLinux =
                t.isWindows =
                t.isIphone =
                t.isIpad =
                t.isMac =
                t.getSafariVersion =
                t.isSafari =
                t.isLegacyEdge =
                t.isFirefox =
                t.isNode =
                  void 0),
              (t.isNode = 'undefined' != typeof process && 'title' in process)
            const n = t.isNode ? 'node' : navigator.userAgent,
              o = t.isNode ? 'node' : navigator.platform
            ;(t.isFirefox = n.includes('Firefox')),
              (t.isLegacyEdge = n.includes('Edge')),
              (t.isSafari = /^((?!chrome|android).)*safari/i.test(n)),
              (t.getSafariVersion = function () {
                if (!t.isSafari) return 0
                const e = n.match(/Version\/(\d+)/)
                return null === e || e.length < 2 ? 0 : parseInt(e[1])
              }),
              (t.isMac = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'].includes(
                o
              )),
              (t.isIpad = 'iPad' === o),
              (t.isIphone = 'iPhone' === o),
              (t.isWindows = ['Windows', 'Win16', 'Win32', 'WinCE'].includes(
                o
              )),
              (t.isLinux = o.indexOf('Linux') >= 0),
              (t.isChromeOS = /\bCrOS\b/.test(n))
          },
          6106: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.SortedList = void 0)
            let n = 0
            t.SortedList = class {
              constructor(e) {
                ;(this._getKey = e), (this._array = [])
              }
              clear() {
                this._array.length = 0
              }
              insert(e) {
                0 !== this._array.length
                  ? ((n = this._search(this._getKey(e))),
                    this._array.splice(n, 0, e))
                  : this._array.push(e)
              }
              delete(e) {
                if (0 === this._array.length) return !1
                const t = this._getKey(e)
                if (void 0 === t) return !1
                if (((n = this._search(t)), -1 === n)) return !1
                if (this._getKey(this._array[n]) !== t) return !1
                do {
                  if (this._array[n] === e) return this._array.splice(n, 1), !0
                } while (
                  ++n < this._array.length &&
                  this._getKey(this._array[n]) === t
                )
                return !1
              }
              *getKeyIterator(e) {
                if (
                  0 !== this._array.length &&
                  ((n = this._search(e)),
                  !(n < 0 || n >= this._array.length) &&
                    this._getKey(this._array[n]) === e)
                )
                  do {
                    yield this._array[n]
                  } while (
                    ++n < this._array.length &&
                    this._getKey(this._array[n]) === e
                  )
              }
              forEachByKey(e, t) {
                if (
                  0 !== this._array.length &&
                  ((n = this._search(e)),
                  !(n < 0 || n >= this._array.length) &&
                    this._getKey(this._array[n]) === e)
                )
                  do {
                    t(this._array[n])
                  } while (
                    ++n < this._array.length &&
                    this._getKey(this._array[n]) === e
                  )
              }
              values() {
                return [...this._array].values()
              }
              _search(e) {
                let t = 0,
                  n = this._array.length - 1
                for (; n >= t; ) {
                  let o = (t + n) >> 1
                  const i = this._getKey(this._array[o])
                  if (i > e) n = o - 1
                  else {
                    if (!(i < e)) {
                      for (; o > 0 && this._getKey(this._array[o - 1]) === e; )
                        o--
                      return o
                    }
                    t = o + 1
                  }
                }
                return t
              }
            }
          },
          7226: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.DebouncedIdleTask =
                t.IdleTaskQueue =
                t.PriorityTaskQueue =
                  void 0)
            const o = n(6114)
            class i {
              static {
                __name(this, 'r')
              }
              constructor() {
                ;(this._tasks = []), (this._i = 0)
              }
              enqueue(e) {
                this._tasks.push(e), this._start()
              }
              flush() {
                for (; this._i < this._tasks.length; )
                  this._tasks[this._i]() || this._i++
                this.clear()
              }
              clear() {
                this._idleCallback &&
                  (this._cancelCallback(this._idleCallback),
                  (this._idleCallback = void 0)),
                  (this._i = 0),
                  (this._tasks.length = 0)
              }
              _start() {
                this._idleCallback ||
                  (this._idleCallback = this._requestCallback(
                    this._process.bind(this)
                  ))
              }
              _process(e) {
                this._idleCallback = void 0
                let t = 0,
                  n = 0,
                  o = e.timeRemaining(),
                  i = 0
                for (; this._i < this._tasks.length; ) {
                  if (
                    ((t = Date.now()),
                    this._tasks[this._i]() || this._i++,
                    (t = Math.max(1, Date.now() - t)),
                    (n = Math.max(t, n)),
                    (i = e.timeRemaining()),
                    1.5 * n > i)
                  )
                    return (
                      o - t < -20 &&
                        console.warn(
                          `task queue exceeded allotted deadline by ${Math.abs(Math.round(o - t))}ms`
                        ),
                      void this._start()
                    )
                  o = i
                }
                this.clear()
              }
            }
            class r extends i {
              static {
                __name(this, 'n')
              }
              _requestCallback(e) {
                return setTimeout(() => e(this._createDeadline(16)))
              }
              _cancelCallback(e) {
                clearTimeout(e)
              }
              _createDeadline(e) {
                const t = Date.now() + e
                return {
                  timeRemaining: __name(
                    () => Math.max(0, t - Date.now()),
                    'timeRemaining'
                  )
                }
              }
            }
            ;(t.PriorityTaskQueue = r),
              (t.IdleTaskQueue =
                !o.isNode && 'requestIdleCallback' in window
                  ? class extends i {
                      _requestCallback(e) {
                        return requestIdleCallback(e)
                      }
                      _cancelCallback(e) {
                        cancelIdleCallback(e)
                      }
                    }
                  : r),
              (t.DebouncedIdleTask = class {
                constructor() {
                  this._queue = new t.IdleTaskQueue()
                }
                set(e) {
                  this._queue.clear(), this._queue.enqueue(e)
                }
                flush() {
                  this._queue.flush()
                }
              })
          },
          9282: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.updateWindowsModeWrappedState = void 0)
            const o = n(643)
            t.updateWindowsModeWrappedState = function (e) {
              const t = e.buffer.lines.get(e.buffer.ybase + e.buffer.y - 1),
                n = t?.get(e.cols - 1),
                i = e.buffer.lines.get(e.buffer.ybase + e.buffer.y)
              i &&
                n &&
                (i.isWrapped =
                  n[o.CHAR_DATA_CODE_INDEX] !== o.NULL_CELL_CODE &&
                  n[o.CHAR_DATA_CODE_INDEX] !== o.WHITESPACE_CELL_CODE)
            }
          },
          3734: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ExtendedAttrs = t.AttributeData = void 0)
            class n {
              static {
                __name(this, 'i')
              }
              constructor() {
                ;(this.fg = 0), (this.bg = 0), (this.extended = new o())
              }
              static toColorRGB(e) {
                return [(e >>> 16) & 255, (e >>> 8) & 255, 255 & e]
              }
              static fromColorRGB(e) {
                return ((255 & e[0]) << 16) | ((255 & e[1]) << 8) | (255 & e[2])
              }
              clone() {
                const e = new n()
                return (
                  (e.fg = this.fg),
                  (e.bg = this.bg),
                  (e.extended = this.extended.clone()),
                  e
                )
              }
              isInverse() {
                return 67108864 & this.fg
              }
              isBold() {
                return 134217728 & this.fg
              }
              isUnderline() {
                return this.hasExtendedAttrs() &&
                  0 !== this.extended.underlineStyle
                  ? 1
                  : 268435456 & this.fg
              }
              isBlink() {
                return 536870912 & this.fg
              }
              isInvisible() {
                return 1073741824 & this.fg
              }
              isItalic() {
                return 67108864 & this.bg
              }
              isDim() {
                return 134217728 & this.bg
              }
              isStrikethrough() {
                return 2147483648 & this.fg
              }
              isProtected() {
                return 536870912 & this.bg
              }
              isOverline() {
                return 1073741824 & this.bg
              }
              getFgColorMode() {
                return 50331648 & this.fg
              }
              getBgColorMode() {
                return 50331648 & this.bg
              }
              isFgRGB() {
                return !(50331648 & ~this.fg)
              }
              isBgRGB() {
                return !(50331648 & ~this.bg)
              }
              isFgPalette() {
                return (
                  16777216 == (50331648 & this.fg) ||
                  33554432 == (50331648 & this.fg)
                )
              }
              isBgPalette() {
                return (
                  16777216 == (50331648 & this.bg) ||
                  33554432 == (50331648 & this.bg)
                )
              }
              isFgDefault() {
                return !(50331648 & this.fg)
              }
              isBgDefault() {
                return !(50331648 & this.bg)
              }
              isAttributeDefault() {
                return 0 === this.fg && 0 === this.bg
              }
              getFgColor() {
                switch (50331648 & this.fg) {
                  case 16777216:
                  case 33554432:
                    return 255 & this.fg
                  case 50331648:
                    return 16777215 & this.fg
                  default:
                    return -1
                }
              }
              getBgColor() {
                switch (50331648 & this.bg) {
                  case 16777216:
                  case 33554432:
                    return 255 & this.bg
                  case 50331648:
                    return 16777215 & this.bg
                  default:
                    return -1
                }
              }
              hasExtendedAttrs() {
                return 268435456 & this.bg
              }
              updateExtended() {
                this.extended.isEmpty()
                  ? (this.bg &= -268435457)
                  : (this.bg |= 268435456)
              }
              getUnderlineColor() {
                if (268435456 & this.bg && ~this.extended.underlineColor)
                  switch (50331648 & this.extended.underlineColor) {
                    case 16777216:
                    case 33554432:
                      return 255 & this.extended.underlineColor
                    case 50331648:
                      return 16777215 & this.extended.underlineColor
                    default:
                      return this.getFgColor()
                  }
                return this.getFgColor()
              }
              getUnderlineColorMode() {
                return 268435456 & this.bg && ~this.extended.underlineColor
                  ? 50331648 & this.extended.underlineColor
                  : this.getFgColorMode()
              }
              isUnderlineColorRGB() {
                return 268435456 & this.bg && ~this.extended.underlineColor
                  ? !(50331648 & ~this.extended.underlineColor)
                  : this.isFgRGB()
              }
              isUnderlineColorPalette() {
                return 268435456 & this.bg && ~this.extended.underlineColor
                  ? 16777216 == (50331648 & this.extended.underlineColor) ||
                      33554432 == (50331648 & this.extended.underlineColor)
                  : this.isFgPalette()
              }
              isUnderlineColorDefault() {
                return 268435456 & this.bg && ~this.extended.underlineColor
                  ? !(50331648 & this.extended.underlineColor)
                  : this.isFgDefault()
              }
              getUnderlineStyle() {
                return 268435456 & this.fg
                  ? 268435456 & this.bg
                    ? this.extended.underlineStyle
                    : 1
                  : 0
              }
              getUnderlineVariantOffset() {
                return this.extended.underlineVariantOffset
              }
            }
            t.AttributeData = n
            class o {
              static {
                __name(this, 's')
              }
              get ext() {
                return this._urlId
                  ? (-469762049 & this._ext) | (this.underlineStyle << 26)
                  : this._ext
              }
              set ext(e) {
                this._ext = e
              }
              get underlineStyle() {
                return this._urlId ? 5 : (469762048 & this._ext) >> 26
              }
              set underlineStyle(e) {
                ;(this._ext &= -469762049), (this._ext |= (e << 26) & 469762048)
              }
              get underlineColor() {
                return 67108863 & this._ext
              }
              set underlineColor(e) {
                ;(this._ext &= -67108864), (this._ext |= 67108863 & e)
              }
              get urlId() {
                return this._urlId
              }
              set urlId(e) {
                this._urlId = e
              }
              get underlineVariantOffset() {
                const e = (3758096384 & this._ext) >> 29
                return e < 0 ? 4294967288 ^ e : e
              }
              set underlineVariantOffset(e) {
                ;(this._ext &= 536870911), (this._ext |= (e << 29) & 3758096384)
              }
              constructor(e = 0, t = 0) {
                ;(this._ext = 0),
                  (this._urlId = 0),
                  (this._ext = e),
                  (this._urlId = t)
              }
              clone() {
                return new o(this._ext, this._urlId)
              }
              isEmpty() {
                return 0 === this.underlineStyle && 0 === this._urlId
              }
            }
            t.ExtendedAttrs = o
          },
          9092: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.Buffer = t.MAX_BUFFER_SIZE = void 0)
            const o = n(6349),
              i = n(7226),
              r = n(3734),
              a = n(8437),
              s = n(4634),
              l = n(511),
              c = n(643),
              d = n(4863),
              u = n(7116)
            ;(t.MAX_BUFFER_SIZE = 4294967295),
              (t.Buffer = class {
                constructor(e, t, n) {
                  ;(this._hasScrollback = e),
                    (this._optionsService = t),
                    (this._bufferService = n),
                    (this.ydisp = 0),
                    (this.ybase = 0),
                    (this.y = 0),
                    (this.x = 0),
                    (this.tabs = {}),
                    (this.savedY = 0),
                    (this.savedX = 0),
                    (this.savedCurAttrData = a.DEFAULT_ATTR_DATA.clone()),
                    (this.savedCharset = u.DEFAULT_CHARSET),
                    (this.markers = []),
                    (this._nullCell = l.CellData.fromCharData([
                      0,
                      c.NULL_CELL_CHAR,
                      c.NULL_CELL_WIDTH,
                      c.NULL_CELL_CODE
                    ])),
                    (this._whitespaceCell = l.CellData.fromCharData([
                      0,
                      c.WHITESPACE_CELL_CHAR,
                      c.WHITESPACE_CELL_WIDTH,
                      c.WHITESPACE_CELL_CODE
                    ])),
                    (this._isClearing = !1),
                    (this._memoryCleanupQueue = new i.IdleTaskQueue()),
                    (this._memoryCleanupPosition = 0),
                    (this._cols = this._bufferService.cols),
                    (this._rows = this._bufferService.rows),
                    (this.lines = new o.CircularList(
                      this._getCorrectBufferLength(this._rows)
                    )),
                    (this.scrollTop = 0),
                    (this.scrollBottom = this._rows - 1),
                    this.setupTabStops()
                }
                getNullCell(e) {
                  return (
                    e
                      ? ((this._nullCell.fg = e.fg),
                        (this._nullCell.bg = e.bg),
                        (this._nullCell.extended = e.extended))
                      : ((this._nullCell.fg = 0),
                        (this._nullCell.bg = 0),
                        (this._nullCell.extended = new r.ExtendedAttrs())),
                    this._nullCell
                  )
                }
                getWhitespaceCell(e) {
                  return (
                    e
                      ? ((this._whitespaceCell.fg = e.fg),
                        (this._whitespaceCell.bg = e.bg),
                        (this._whitespaceCell.extended = e.extended))
                      : ((this._whitespaceCell.fg = 0),
                        (this._whitespaceCell.bg = 0),
                        (this._whitespaceCell.extended =
                          new r.ExtendedAttrs())),
                    this._whitespaceCell
                  )
                }
                getBlankLine(e, t) {
                  return new a.BufferLine(
                    this._bufferService.cols,
                    this.getNullCell(e),
                    t
                  )
                }
                get hasScrollback() {
                  return (
                    this._hasScrollback && this.lines.maxLength > this._rows
                  )
                }
                get isCursorInViewport() {
                  const e = this.ybase + this.y - this.ydisp
                  return e >= 0 && e < this._rows
                }
                _getCorrectBufferLength(e) {
                  if (!this._hasScrollback) return e
                  const n = e + this._optionsService.rawOptions.scrollback
                  return n > t.MAX_BUFFER_SIZE ? t.MAX_BUFFER_SIZE : n
                }
                fillViewportRows(e) {
                  if (0 === this.lines.length) {
                    void 0 === e && (e = a.DEFAULT_ATTR_DATA)
                    let t = this._rows
                    for (; t--; ) this.lines.push(this.getBlankLine(e))
                  }
                }
                clear() {
                  ;(this.ydisp = 0),
                    (this.ybase = 0),
                    (this.y = 0),
                    (this.x = 0),
                    (this.lines = new o.CircularList(
                      this._getCorrectBufferLength(this._rows)
                    )),
                    (this.scrollTop = 0),
                    (this.scrollBottom = this._rows - 1),
                    this.setupTabStops()
                }
                resize(e, t) {
                  const n = this.getNullCell(a.DEFAULT_ATTR_DATA)
                  let o = 0
                  const i = this._getCorrectBufferLength(t)
                  if (
                    (i > this.lines.maxLength && (this.lines.maxLength = i),
                    this.lines.length > 0)
                  ) {
                    if (this._cols < e)
                      for (let t = 0; t < this.lines.length; t++)
                        o += +this.lines.get(t).resize(e, n)
                    let r = 0
                    if (this._rows < t)
                      for (let o = this._rows; o < t; o++)
                        this.lines.length < t + this.ybase &&
                          (this._optionsService.rawOptions.windowsMode ||
                          void 0 !==
                            this._optionsService.rawOptions.windowsPty
                              .backend ||
                          void 0 !==
                            this._optionsService.rawOptions.windowsPty
                              .buildNumber
                            ? this.lines.push(new a.BufferLine(e, n))
                            : this.ybase > 0 &&
                                this.lines.length <= this.ybase + this.y + r + 1
                              ? (this.ybase--,
                                r++,
                                this.ydisp > 0 && this.ydisp--)
                              : this.lines.push(new a.BufferLine(e, n)))
                    else
                      for (let e = this._rows; e > t; e--)
                        this.lines.length > t + this.ybase &&
                          (this.lines.length > this.ybase + this.y + 1
                            ? this.lines.pop()
                            : (this.ybase++, this.ydisp++))
                    if (i < this.lines.maxLength) {
                      const e = this.lines.length - i
                      e > 0 &&
                        (this.lines.trimStart(e),
                        (this.ybase = Math.max(this.ybase - e, 0)),
                        (this.ydisp = Math.max(this.ydisp - e, 0)),
                        (this.savedY = Math.max(this.savedY - e, 0))),
                        (this.lines.maxLength = i)
                    }
                    ;(this.x = Math.min(this.x, e - 1)),
                      (this.y = Math.min(this.y, t - 1)),
                      r && (this.y += r),
                      (this.savedX = Math.min(this.savedX, e - 1)),
                      (this.scrollTop = 0)
                  }
                  if (
                    ((this.scrollBottom = t - 1),
                    this._isReflowEnabled &&
                      (this._reflow(e, t), this._cols > e))
                  )
                    for (let r = 0; r < this.lines.length; r++)
                      o += +this.lines.get(r).resize(e, n)
                  ;(this._cols = e),
                    (this._rows = t),
                    this._memoryCleanupQueue.clear(),
                    o > 0.1 * this.lines.length &&
                      ((this._memoryCleanupPosition = 0),
                      this._memoryCleanupQueue.enqueue(() =>
                        this._batchedMemoryCleanup()
                      ))
                }
                _batchedMemoryCleanup() {
                  let e = !0
                  this._memoryCleanupPosition >= this.lines.length &&
                    ((this._memoryCleanupPosition = 0), (e = !1))
                  let t = 0
                  for (; this._memoryCleanupPosition < this.lines.length; )
                    if (
                      ((t += this.lines
                        .get(this._memoryCleanupPosition++)
                        .cleanupMemory()),
                      t > 100)
                    )
                      return !0
                  return e
                }
                get _isReflowEnabled() {
                  const e = this._optionsService.rawOptions.windowsPty
                  return e && e.buildNumber
                    ? this._hasScrollback &&
                        'conpty' === e.backend &&
                        e.buildNumber >= 21376
                    : this._hasScrollback &&
                        !this._optionsService.rawOptions.windowsMode
                }
                _reflow(e, t) {
                  this._cols !== e &&
                    (e > this._cols
                      ? this._reflowLarger(e, t)
                      : this._reflowSmaller(e, t))
                }
                _reflowLarger(e, t) {
                  const n = (0, s.reflowLargerGetLinesToRemove)(
                    this.lines,
                    this._cols,
                    e,
                    this.ybase + this.y,
                    this.getNullCell(a.DEFAULT_ATTR_DATA)
                  )
                  if (n.length > 0) {
                    const o = (0, s.reflowLargerCreateNewLayout)(this.lines, n)
                    ;(0, s.reflowLargerApplyNewLayout)(this.lines, o.layout),
                      this._reflowLargerAdjustViewport(e, t, o.countRemoved)
                  }
                }
                _reflowLargerAdjustViewport(e, t, n) {
                  const o = this.getNullCell(a.DEFAULT_ATTR_DATA)
                  let i = n
                  for (; i-- > 0; )
                    0 === this.ybase
                      ? (this.y > 0 && this.y--,
                        this.lines.length < t &&
                          this.lines.push(new a.BufferLine(e, o)))
                      : (this.ydisp === this.ybase && this.ydisp--,
                        this.ybase--)
                  this.savedY = Math.max(this.savedY - n, 0)
                }
                _reflowSmaller(e, t) {
                  const n = this.getNullCell(a.DEFAULT_ATTR_DATA),
                    o = []
                  let i = 0
                  for (let r = this.lines.length - 1; r >= 0; r--) {
                    let l = this.lines.get(r)
                    if (!l || (!l.isWrapped && l.getTrimmedLength() <= e))
                      continue
                    const c = [l]
                    for (; l.isWrapped && r > 0; )
                      (l = this.lines.get(--r)), c.unshift(l)
                    const d = this.ybase + this.y
                    if (d >= r && d < r + c.length) continue
                    const u = c[c.length - 1].getTrimmedLength(),
                      p = (0, s.reflowSmallerGetNewLineLengths)(
                        c,
                        this._cols,
                        e
                      ),
                      h = p.length - c.length
                    let m
                    m =
                      0 === this.ybase && this.y !== this.lines.length - 1
                        ? Math.max(0, this.y - this.lines.maxLength + h)
                        : Math.max(
                            0,
                            this.lines.length - this.lines.maxLength + h
                          )
                    const f = []
                    for (let e = 0; e < h; e++) {
                      const e = this.getBlankLine(a.DEFAULT_ATTR_DATA, !0)
                      f.push(e)
                    }
                    f.length > 0 &&
                      (o.push({ start: r + c.length + i, newLines: f }),
                      (i += f.length)),
                      c.push(...f)
                    let _ = p.length - 1,
                      g = p[_]
                    0 === g && (_--, (g = p[_]))
                    let v = c.length - h - 1,
                      y = u
                    for (; v >= 0; ) {
                      const e = Math.min(y, g)
                      if (void 0 === c[_]) break
                      if (
                        (c[_].copyCellsFrom(c[v], y - e, g - e, e, !0),
                        (g -= e),
                        0 === g && (_--, (g = p[_])),
                        (y -= e),
                        0 === y)
                      ) {
                        v--
                        const e = Math.max(v, 0)
                        y = (0, s.getWrappedLineTrimmedLength)(c, e, this._cols)
                      }
                    }
                    for (let t = 0; t < c.length; t++)
                      p[t] < e && c[t].setCell(p[t], n)
                    let b = h - m
                    for (; b-- > 0; )
                      0 === this.ybase
                        ? this.y < t - 1
                          ? (this.y++, this.lines.pop())
                          : (this.ybase++, this.ydisp++)
                        : this.ybase <
                            Math.min(
                              this.lines.maxLength,
                              this.lines.length + i
                            ) -
                              t &&
                          (this.ybase === this.ydisp && this.ydisp++,
                          this.ybase++)
                    this.savedY = Math.min(this.savedY + h, this.ybase + t - 1)
                  }
                  if (o.length > 0) {
                    const e = [],
                      t = []
                    for (let o = 0; o < this.lines.length; o++)
                      t.push(this.lines.get(o))
                    const n = this.lines.length
                    let r = n - 1,
                      a = 0,
                      s = o[a]
                    this.lines.length = Math.min(
                      this.lines.maxLength,
                      this.lines.length + i
                    )
                    let l = 0
                    for (
                      let u = Math.min(this.lines.maxLength - 1, n + i - 1);
                      u >= 0;
                      u--
                    )
                      if (s && s.start > r + l) {
                        for (let e = s.newLines.length - 1; e >= 0; e--)
                          this.lines.set(u--, s.newLines[e])
                        u++,
                          e.push({ index: r + 1, amount: s.newLines.length }),
                          (l += s.newLines.length),
                          (s = o[++a])
                      } else this.lines.set(u, t[r--])
                    let c = 0
                    for (let o = e.length - 1; o >= 0; o--)
                      (e[o].index += c),
                        this.lines.onInsertEmitter.fire(e[o]),
                        (c += e[o].amount)
                    const d = Math.max(0, n + i - this.lines.maxLength)
                    d > 0 && this.lines.onTrimEmitter.fire(d)
                  }
                }
                translateBufferLineToString(e, t, n = 0, o) {
                  const i = this.lines.get(e)
                  return i ? i.translateToString(t, n, o) : ''
                }
                getWrappedRangeForLine(e) {
                  let t = e,
                    n = e
                  for (; t > 0 && this.lines.get(t).isWrapped; ) t--
                  for (
                    ;
                    n + 1 < this.lines.length &&
                    this.lines.get(n + 1).isWrapped;

                  )
                    n++
                  return { first: t, last: n }
                }
                setupTabStops(e) {
                  for (
                    null != e
                      ? this.tabs[e] || (e = this.prevStop(e))
                      : ((this.tabs = {}), (e = 0));
                    e < this._cols;
                    e += this._optionsService.rawOptions.tabStopWidth
                  )
                    this.tabs[e] = !0
                }
                prevStop(e) {
                  for (null == e && (e = this.x); !this.tabs[--e] && e > 0; );
                  return e >= this._cols ? this._cols - 1 : e < 0 ? 0 : e
                }
                nextStop(e) {
                  for (
                    null == e && (e = this.x);
                    !this.tabs[++e] && e < this._cols;

                  );
                  return e >= this._cols ? this._cols - 1 : e < 0 ? 0 : e
                }
                clearMarkers(e) {
                  this._isClearing = !0
                  for (let t = 0; t < this.markers.length; t++)
                    this.markers[t].line === e &&
                      (this.markers[t].dispose(), this.markers.splice(t--, 1))
                  this._isClearing = !1
                }
                clearAllMarkers() {
                  this._isClearing = !0
                  for (let e = 0; e < this.markers.length; e++)
                    this.markers[e].dispose(), this.markers.splice(e--, 1)
                  this._isClearing = !1
                }
                addMarker(e) {
                  const t = new d.Marker(e)
                  return (
                    this.markers.push(t),
                    t.register(
                      this.lines.onTrim((e) => {
                        ;(t.line -= e), t.line < 0 && t.dispose()
                      })
                    ),
                    t.register(
                      this.lines.onInsert((e) => {
                        t.line >= e.index && (t.line += e.amount)
                      })
                    ),
                    t.register(
                      this.lines.onDelete((e) => {
                        t.line >= e.index &&
                          t.line < e.index + e.amount &&
                          t.dispose(),
                          t.line > e.index && (t.line -= e.amount)
                      })
                    ),
                    t.register(t.onDispose(() => this._removeMarker(t))),
                    t
                  )
                }
                _removeMarker(e) {
                  this._isClearing ||
                    this.markers.splice(this.markers.indexOf(e), 1)
                }
              })
          },
          8437: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.BufferLine = t.DEFAULT_ATTR_DATA = void 0)
            const o = n(3734),
              i = n(511),
              r = n(643),
              a = n(482)
            t.DEFAULT_ATTR_DATA = Object.freeze(new o.AttributeData())
            let s = 0
            class l {
              static {
                __name(this, 'h')
              }
              constructor(e, t, n = !1) {
                ;(this.isWrapped = n),
                  (this._combined = {}),
                  (this._extendedAttrs = {}),
                  (this._data = new Uint32Array(3 * e))
                const o =
                  t ||
                  i.CellData.fromCharData([
                    0,
                    r.NULL_CELL_CHAR,
                    r.NULL_CELL_WIDTH,
                    r.NULL_CELL_CODE
                  ])
                for (let i = 0; i < e; ++i) this.setCell(i, o)
                this.length = e
              }
              get(e) {
                const t = this._data[3 * e + 0],
                  n = 2097151 & t
                return [
                  this._data[3 * e + 1],
                  2097152 & t
                    ? this._combined[e]
                    : n
                      ? (0, a.stringFromCodePoint)(n)
                      : '',
                  t >> 22,
                  2097152 & t
                    ? this._combined[e].charCodeAt(this._combined[e].length - 1)
                    : n
                ]
              }
              set(e, t) {
                ;(this._data[3 * e + 1] = t[r.CHAR_DATA_ATTR_INDEX]),
                  t[r.CHAR_DATA_CHAR_INDEX].length > 1
                    ? ((this._combined[e] = t[1]),
                      (this._data[3 * e + 0] =
                        2097152 | e | (t[r.CHAR_DATA_WIDTH_INDEX] << 22)))
                    : (this._data[3 * e + 0] =
                        t[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) |
                        (t[r.CHAR_DATA_WIDTH_INDEX] << 22))
              }
              getWidth(e) {
                return this._data[3 * e + 0] >> 22
              }
              hasWidth(e) {
                return 12582912 & this._data[3 * e + 0]
              }
              getFg(e) {
                return this._data[3 * e + 1]
              }
              getBg(e) {
                return this._data[3 * e + 2]
              }
              hasContent(e) {
                return 4194303 & this._data[3 * e + 0]
              }
              getCodePoint(e) {
                const t = this._data[3 * e + 0]
                return 2097152 & t
                  ? this._combined[e].charCodeAt(this._combined[e].length - 1)
                  : 2097151 & t
              }
              isCombined(e) {
                return 2097152 & this._data[3 * e + 0]
              }
              getString(e) {
                const t = this._data[3 * e + 0]
                return 2097152 & t
                  ? this._combined[e]
                  : 2097151 & t
                    ? (0, a.stringFromCodePoint)(2097151 & t)
                    : ''
              }
              isProtected(e) {
                return 536870912 & this._data[3 * e + 2]
              }
              loadCell(e, t) {
                return (
                  (s = 3 * e),
                  (t.content = this._data[s + 0]),
                  (t.fg = this._data[s + 1]),
                  (t.bg = this._data[s + 2]),
                  2097152 & t.content && (t.combinedData = this._combined[e]),
                  268435456 & t.bg && (t.extended = this._extendedAttrs[e]),
                  t
                )
              }
              setCell(e, t) {
                2097152 & t.content && (this._combined[e] = t.combinedData),
                  268435456 & t.bg && (this._extendedAttrs[e] = t.extended),
                  (this._data[3 * e + 0] = t.content),
                  (this._data[3 * e + 1] = t.fg),
                  (this._data[3 * e + 2] = t.bg)
              }
              setCellFromCodepoint(e, t, n, o) {
                268435456 & o.bg && (this._extendedAttrs[e] = o.extended),
                  (this._data[3 * e + 0] = t | (n << 22)),
                  (this._data[3 * e + 1] = o.fg),
                  (this._data[3 * e + 2] = o.bg)
              }
              addCodepointToCell(e, t, n) {
                let o = this._data[3 * e + 0]
                2097152 & o
                  ? (this._combined[e] += (0, a.stringFromCodePoint)(t))
                  : 2097151 & o
                    ? ((this._combined[e] =
                        (0, a.stringFromCodePoint)(2097151 & o) +
                        (0, a.stringFromCodePoint)(t)),
                      (o &= -2097152),
                      (o |= 2097152))
                    : (o = t | (1 << 22)),
                  n && ((o &= -12582913), (o |= n << 22)),
                  (this._data[3 * e + 0] = o)
              }
              insertCells(e, t, n) {
                if (
                  ((e %= this.length) &&
                    2 === this.getWidth(e - 1) &&
                    this.setCellFromCodepoint(e - 1, 0, 1, n),
                  t < this.length - e)
                ) {
                  const o = new i.CellData()
                  for (let n = this.length - e - t - 1; n >= 0; --n)
                    this.setCell(e + t + n, this.loadCell(e + n, o))
                  for (let i = 0; i < t; ++i) this.setCell(e + i, n)
                } else for (let o = e; o < this.length; ++o) this.setCell(o, n)
                2 === this.getWidth(this.length - 1) &&
                  this.setCellFromCodepoint(this.length - 1, 0, 1, n)
              }
              deleteCells(e, t, n) {
                if (((e %= this.length), t < this.length - e)) {
                  const o = new i.CellData()
                  for (let n = 0; n < this.length - e - t; ++n)
                    this.setCell(e + n, this.loadCell(e + t + n, o))
                  for (let e = this.length - t; e < this.length; ++e)
                    this.setCell(e, n)
                } else for (let o = e; o < this.length; ++o) this.setCell(o, n)
                e &&
                  2 === this.getWidth(e - 1) &&
                  this.setCellFromCodepoint(e - 1, 0, 1, n),
                  0 !== this.getWidth(e) ||
                    this.hasContent(e) ||
                    this.setCellFromCodepoint(e, 0, 1, n)
              }
              replaceCells(e, t, n, o = !1) {
                if (o)
                  for (
                    e &&
                      2 === this.getWidth(e - 1) &&
                      !this.isProtected(e - 1) &&
                      this.setCellFromCodepoint(e - 1, 0, 1, n),
                      t < this.length &&
                        2 === this.getWidth(t - 1) &&
                        !this.isProtected(t) &&
                        this.setCellFromCodepoint(t, 0, 1, n);
                    e < t && e < this.length;

                  )
                    this.isProtected(e) || this.setCell(e, n), e++
                else
                  for (
                    e &&
                      2 === this.getWidth(e - 1) &&
                      this.setCellFromCodepoint(e - 1, 0, 1, n),
                      t < this.length &&
                        2 === this.getWidth(t - 1) &&
                        this.setCellFromCodepoint(t, 0, 1, n);
                    e < t && e < this.length;

                  )
                    this.setCell(e++, n)
              }
              resize(e, t) {
                if (e === this.length)
                  return (
                    4 * this._data.length * 2 < this._data.buffer.byteLength
                  )
                const n = 3 * e
                if (e > this.length) {
                  if (this._data.buffer.byteLength >= 4 * n)
                    this._data = new Uint32Array(this._data.buffer, 0, n)
                  else {
                    const e = new Uint32Array(n)
                    e.set(this._data), (this._data = e)
                  }
                  for (let n = this.length; n < e; ++n) this.setCell(n, t)
                } else {
                  this._data = this._data.subarray(0, n)
                  const t = Object.keys(this._combined)
                  for (let n = 0; n < t.length; n++) {
                    const o = parseInt(t[n], 10)
                    o >= e && delete this._combined[o]
                  }
                  const o = Object.keys(this._extendedAttrs)
                  for (let n = 0; n < o.length; n++) {
                    const t = parseInt(o[n], 10)
                    t >= e && delete this._extendedAttrs[t]
                  }
                }
                return (
                  (this.length = e), 4 * n * 2 < this._data.buffer.byteLength
                )
              }
              cleanupMemory() {
                if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
                  const e = new Uint32Array(this._data.length)
                  return e.set(this._data), (this._data = e), 1
                }
                return 0
              }
              fill(e, t = !1) {
                if (t)
                  for (let n = 0; n < this.length; ++n)
                    this.isProtected(n) || this.setCell(n, e)
                else {
                  ;(this._combined = {}), (this._extendedAttrs = {})
                  for (let t = 0; t < this.length; ++t) this.setCell(t, e)
                }
              }
              copyFrom(e) {
                this.length !== e.length
                  ? (this._data = new Uint32Array(e._data))
                  : this._data.set(e._data),
                  (this.length = e.length),
                  (this._combined = {})
                for (const t in e._combined) this._combined[t] = e._combined[t]
                this._extendedAttrs = {}
                for (const t in e._extendedAttrs)
                  this._extendedAttrs[t] = e._extendedAttrs[t]
                this.isWrapped = e.isWrapped
              }
              clone() {
                const e = new l(0)
                ;(e._data = new Uint32Array(this._data)),
                  (e.length = this.length)
                for (const t in this._combined)
                  e._combined[t] = this._combined[t]
                for (const t in this._extendedAttrs)
                  e._extendedAttrs[t] = this._extendedAttrs[t]
                return (e.isWrapped = this.isWrapped), e
              }
              getTrimmedLength() {
                for (let e = this.length - 1; e >= 0; --e)
                  if (4194303 & this._data[3 * e + 0])
                    return e + (this._data[3 * e + 0] >> 22)
                return 0
              }
              getNoBgTrimmedLength() {
                for (let e = this.length - 1; e >= 0; --e)
                  if (
                    4194303 & this._data[3 * e + 0] ||
                    50331648 & this._data[3 * e + 2]
                  )
                    return e + (this._data[3 * e + 0] >> 22)
                return 0
              }
              copyCellsFrom(e, t, n, o, i) {
                const r = e._data
                if (i)
                  for (let s = o - 1; s >= 0; s--) {
                    for (let e = 0; e < 3; e++)
                      this._data[3 * (n + s) + e] = r[3 * (t + s) + e]
                    268435456 & r[3 * (t + s) + 2] &&
                      (this._extendedAttrs[n + s] = e._extendedAttrs[t + s])
                  }
                else
                  for (let s = 0; s < o; s++) {
                    for (let e = 0; e < 3; e++)
                      this._data[3 * (n + s) + e] = r[3 * (t + s) + e]
                    268435456 & r[3 * (t + s) + 2] &&
                      (this._extendedAttrs[n + s] = e._extendedAttrs[t + s])
                  }
                const a = Object.keys(e._combined)
                for (let s = 0; s < a.length; s++) {
                  const o = parseInt(a[s], 10)
                  o >= t && (this._combined[o - t + n] = e._combined[o])
                }
              }
              translateToString(e, t, n, o) {
                ;(t = t ?? 0),
                  (n = n ?? this.length),
                  e && (n = Math.min(n, this.getTrimmedLength())),
                  o && (o.length = 0)
                let i = ''
                for (; t < n; ) {
                  const e = this._data[3 * t + 0],
                    n = 2097151 & e,
                    s =
                      2097152 & e
                        ? this._combined[t]
                        : n
                          ? (0, a.stringFromCodePoint)(n)
                          : r.WHITESPACE_CELL_CHAR
                  if (((i += s), o))
                    for (let i = 0; i < s.length; ++i) o.push(t)
                  t += e >> 22 || 1
                }
                return o && o.push(t), i
              }
            }
            t.BufferLine = l
          },
          4841: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.getRangeLength = void 0),
              (t.getRangeLength = function (e, t) {
                if (e.start.y > e.end.y)
                  throw new Error(
                    `Buffer range end (${e.end.x}, ${e.end.y}) cannot be before start (${e.start.x}, ${e.start.y})`
                  )
                return t * (e.end.y - e.start.y) + (e.end.x - e.start.x + 1)
              })
          },
          4634: (e, t) => {
            function n(e, t, n) {
              if (t === e.length - 1) return e[t].getTrimmedLength()
              const o = !e[t].hasContent(n - 1) && 1 === e[t].getWidth(n - 1),
                i = 2 === e[t + 1].getWidth(0)
              return o && i ? n - 1 : n
            }
            __name(n, 'i'),
              Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.getWrappedLineTrimmedLength =
                t.reflowSmallerGetNewLineLengths =
                t.reflowLargerApplyNewLayout =
                t.reflowLargerCreateNewLayout =
                t.reflowLargerGetLinesToRemove =
                  void 0),
              (t.reflowLargerGetLinesToRemove = function (e, t, o, i, r) {
                const a = []
                for (let s = 0; s < e.length - 1; s++) {
                  let l = s,
                    c = e.get(++l)
                  if (!c.isWrapped) continue
                  const d = [e.get(s)]
                  for (; l < e.length && c.isWrapped; )
                    d.push(c), (c = e.get(++l))
                  if (i >= s && i < l) {
                    s += d.length - 1
                    continue
                  }
                  let u = 0,
                    p = n(d, u, t),
                    h = 1,
                    m = 0
                  for (; h < d.length; ) {
                    const e = n(d, h, t),
                      i = e - m,
                      a = o - p,
                      s = Math.min(i, a)
                    d[u].copyCellsFrom(d[h], m, p, s, !1),
                      (p += s),
                      p === o && (u++, (p = 0)),
                      (m += s),
                      m === e && (h++, (m = 0)),
                      0 === p &&
                        0 !== u &&
                        2 === d[u - 1].getWidth(o - 1) &&
                        (d[u].copyCellsFrom(d[u - 1], o - 1, p++, 1, !1),
                        d[u - 1].setCell(o - 1, r))
                  }
                  d[u].replaceCells(p, o, r)
                  let f = 0
                  for (
                    let e = d.length - 1;
                    e > 0 && (e > u || 0 === d[e].getTrimmedLength());
                    e--
                  )
                    f++
                  f > 0 && (a.push(s + d.length - f), a.push(f)),
                    (s += d.length - 1)
                }
                return a
              }),
              (t.reflowLargerCreateNewLayout = function (e, t) {
                const n = []
                let o = 0,
                  i = t[o],
                  r = 0
                for (let a = 0; a < e.length; a++)
                  if (i === a) {
                    const n = t[++o]
                    e.onDeleteEmitter.fire({ index: a - r, amount: n }),
                      (a += n - 1),
                      (r += n),
                      (i = t[++o])
                  } else n.push(a)
                return { layout: n, countRemoved: r }
              }),
              (t.reflowLargerApplyNewLayout = function (e, t) {
                const n = []
                for (let o = 0; o < t.length; o++) n.push(e.get(t[o]))
                for (let o = 0; o < n.length; o++) e.set(o, n[o])
                e.length = t.length
              }),
              (t.reflowSmallerGetNewLineLengths = function (e, t, o) {
                const i = [],
                  r = e.map((o, i) => n(e, i, t)).reduce((e, t) => e + t)
                let a = 0,
                  s = 0,
                  l = 0
                for (; l < r; ) {
                  if (r - l < o) {
                    i.push(r - l)
                    break
                  }
                  a += o
                  const c = n(e, s, t)
                  a > c && ((a -= c), s++)
                  const d = 2 === e[s].getWidth(a - 1)
                  d && a--
                  const u = d ? o - 1 : o
                  i.push(u), (l += u)
                }
                return i
              }),
              (t.getWrappedLineTrimmedLength = n)
          },
          5295: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.BufferSet = void 0)
            const o = n(8460),
              i = n(844),
              r = n(9092)
            class a extends i.Disposable {
              static {
                __name(this, 'o')
              }
              constructor(e, t) {
                super(),
                  (this._optionsService = e),
                  (this._bufferService = t),
                  (this._onBufferActivate = this.register(
                    new o.EventEmitter()
                  )),
                  (this.onBufferActivate = this._onBufferActivate.event),
                  this.reset(),
                  this.register(
                    this._optionsService.onSpecificOptionChange(
                      'scrollback',
                      () =>
                        this.resize(
                          this._bufferService.cols,
                          this._bufferService.rows
                        )
                    )
                  ),
                  this.register(
                    this._optionsService.onSpecificOptionChange(
                      'tabStopWidth',
                      () => this.setupTabStops()
                    )
                  )
              }
              reset() {
                ;(this._normal = new r.Buffer(
                  !0,
                  this._optionsService,
                  this._bufferService
                )),
                  this._normal.fillViewportRows(),
                  (this._alt = new r.Buffer(
                    !1,
                    this._optionsService,
                    this._bufferService
                  )),
                  (this._activeBuffer = this._normal),
                  this._onBufferActivate.fire({
                    activeBuffer: this._normal,
                    inactiveBuffer: this._alt
                  }),
                  this.setupTabStops()
              }
              get alt() {
                return this._alt
              }
              get active() {
                return this._activeBuffer
              }
              get normal() {
                return this._normal
              }
              activateNormalBuffer() {
                this._activeBuffer !== this._normal &&
                  ((this._normal.x = this._alt.x),
                  (this._normal.y = this._alt.y),
                  this._alt.clearAllMarkers(),
                  this._alt.clear(),
                  (this._activeBuffer = this._normal),
                  this._onBufferActivate.fire({
                    activeBuffer: this._normal,
                    inactiveBuffer: this._alt
                  }))
              }
              activateAltBuffer(e) {
                this._activeBuffer !== this._alt &&
                  (this._alt.fillViewportRows(e),
                  (this._alt.x = this._normal.x),
                  (this._alt.y = this._normal.y),
                  (this._activeBuffer = this._alt),
                  this._onBufferActivate.fire({
                    activeBuffer: this._alt,
                    inactiveBuffer: this._normal
                  }))
              }
              resize(e, t) {
                this._normal.resize(e, t),
                  this._alt.resize(e, t),
                  this.setupTabStops(e)
              }
              setupTabStops(e) {
                this._normal.setupTabStops(e), this._alt.setupTabStops(e)
              }
            }
            t.BufferSet = a
          },
          511: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.CellData = void 0)
            const o = n(482),
              i = n(643),
              r = n(3734)
            class a extends r.AttributeData {
              static {
                __name(this, 'o')
              }
              constructor() {
                super(...arguments),
                  (this.content = 0),
                  (this.fg = 0),
                  (this.bg = 0),
                  (this.extended = new r.ExtendedAttrs()),
                  (this.combinedData = '')
              }
              static fromCharData(e) {
                const t = new a()
                return t.setFromCharData(e), t
              }
              isCombined() {
                return 2097152 & this.content
              }
              getWidth() {
                return this.content >> 22
              }
              getChars() {
                return 2097152 & this.content
                  ? this.combinedData
                  : 2097151 & this.content
                    ? (0, o.stringFromCodePoint)(2097151 & this.content)
                    : ''
              }
              getCode() {
                return this.isCombined()
                  ? this.combinedData.charCodeAt(this.combinedData.length - 1)
                  : 2097151 & this.content
              }
              setFromCharData(e) {
                ;(this.fg = e[i.CHAR_DATA_ATTR_INDEX]), (this.bg = 0)
                let t = !1
                if (e[i.CHAR_DATA_CHAR_INDEX].length > 2) t = !0
                else if (2 === e[i.CHAR_DATA_CHAR_INDEX].length) {
                  const n = e[i.CHAR_DATA_CHAR_INDEX].charCodeAt(0)
                  if (55296 <= n && n <= 56319) {
                    const o = e[i.CHAR_DATA_CHAR_INDEX].charCodeAt(1)
                    56320 <= o && o <= 57343
                      ? (this.content =
                          (1024 * (n - 55296) + o - 56320 + 65536) |
                          (e[i.CHAR_DATA_WIDTH_INDEX] << 22))
                      : (t = !0)
                  } else t = !0
                } else
                  this.content =
                    e[i.CHAR_DATA_CHAR_INDEX].charCodeAt(0) |
                    (e[i.CHAR_DATA_WIDTH_INDEX] << 22)
                t &&
                  ((this.combinedData = e[i.CHAR_DATA_CHAR_INDEX]),
                  (this.content = 2097152 | (e[i.CHAR_DATA_WIDTH_INDEX] << 22)))
              }
              getAsCharData() {
                return [
                  this.fg,
                  this.getChars(),
                  this.getWidth(),
                  this.getCode()
                ]
              }
            }
            t.CellData = a
          },
          643: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.WHITESPACE_CELL_CODE =
                t.WHITESPACE_CELL_WIDTH =
                t.WHITESPACE_CELL_CHAR =
                t.NULL_CELL_CODE =
                t.NULL_CELL_WIDTH =
                t.NULL_CELL_CHAR =
                t.CHAR_DATA_CODE_INDEX =
                t.CHAR_DATA_WIDTH_INDEX =
                t.CHAR_DATA_CHAR_INDEX =
                t.CHAR_DATA_ATTR_INDEX =
                t.DEFAULT_EXT =
                t.DEFAULT_ATTR =
                t.DEFAULT_COLOR =
                  void 0),
              (t.DEFAULT_COLOR = 0),
              (t.DEFAULT_ATTR = 256 | (t.DEFAULT_COLOR << 9)),
              (t.DEFAULT_EXT = 0),
              (t.CHAR_DATA_ATTR_INDEX = 0),
              (t.CHAR_DATA_CHAR_INDEX = 1),
              (t.CHAR_DATA_WIDTH_INDEX = 2),
              (t.CHAR_DATA_CODE_INDEX = 3),
              (t.NULL_CELL_CHAR = ''),
              (t.NULL_CELL_WIDTH = 1),
              (t.NULL_CELL_CODE = 0),
              (t.WHITESPACE_CELL_CHAR = ' '),
              (t.WHITESPACE_CELL_WIDTH = 1),
              (t.WHITESPACE_CELL_CODE = 32)
          },
          4863: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.Marker = void 0)
            const o = n(8460),
              i = n(844)
            class r {
              static {
                __name(this, 'n')
              }
              get id() {
                return this._id
              }
              constructor(e) {
                ;(this.line = e),
                  (this.isDisposed = !1),
                  (this._disposables = []),
                  (this._id = r._nextId++),
                  (this._onDispose = this.register(new o.EventEmitter())),
                  (this.onDispose = this._onDispose.event)
              }
              dispose() {
                this.isDisposed ||
                  ((this.isDisposed = !0),
                  (this.line = -1),
                  this._onDispose.fire(),
                  (0, i.disposeArray)(this._disposables),
                  (this._disposables.length = 0))
              }
              register(e) {
                return this._disposables.push(e), e
              }
            }
            ;(t.Marker = r), (r._nextId = 1)
          },
          7116: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.DEFAULT_CHARSET = t.CHARSETS = void 0),
              (t.CHARSETS = {}),
              (t.DEFAULT_CHARSET = t.CHARSETS.B),
              (t.CHARSETS[0] = {
                '`': '◆',
                a: '▒',
                b: '␉',
                c: '␌',
                d: '␍',
                e: '␊',
                f: '°',
                g: '±',
                h: '␤',
                i: '␋',
                j: '┘',
                k: '┐',
                l: '┌',
                m: '└',
                n: '┼',
                o: '⎺',
                p: '⎻',
                q: '─',
                r: '⎼',
                s: '⎽',
                t: '├',
                u: '┤',
                v: '┴',
                w: '┬',
                x: '│',
                y: '≤',
                z: '≥',
                '{': 'π',
                '|': '≠',
                '}': '£',
                '~': '·'
              }),
              (t.CHARSETS.A = { '#': '£' }),
              (t.CHARSETS.B = void 0),
              (t.CHARSETS[4] = {
                '#': '£',
                '@': '¾',
                '[': 'ij',
                '\\': '½',
                ']': '|',
                '{': '¨',
                '|': 'f',
                '}': '¼',
                '~': '´'
              }),
              (t.CHARSETS.C = t.CHARSETS[5] =
                {
                  '[': 'Ä',
                  '\\': 'Ö',
                  ']': 'Å',
                  '^': 'Ü',
                  '`': 'é',
                  '{': 'ä',
                  '|': 'ö',
                  '}': 'å',
                  '~': 'ü'
                }),
              (t.CHARSETS.R = {
                '#': '£',
                '@': 'à',
                '[': '°',
                '\\': 'ç',
                ']': '§',
                '{': 'é',
                '|': 'ù',
                '}': 'è',
                '~': '¨'
              }),
              (t.CHARSETS.Q = {
                '@': 'à',
                '[': 'â',
                '\\': 'ç',
                ']': 'ê',
                '^': 'î',
                '`': 'ô',
                '{': 'é',
                '|': 'ù',
                '}': 'è',
                '~': 'û'
              }),
              (t.CHARSETS.K = {
                '@': '§',
                '[': 'Ä',
                '\\': 'Ö',
                ']': 'Ü',
                '{': 'ä',
                '|': 'ö',
                '}': 'ü',
                '~': 'ß'
              }),
              (t.CHARSETS.Y = {
                '#': '£',
                '@': '§',
                '[': '°',
                '\\': 'ç',
                ']': 'é',
                '`': 'ù',
                '{': 'à',
                '|': 'ò',
                '}': 'è',
                '~': 'ì'
              }),
              (t.CHARSETS.E = t.CHARSETS[6] =
                {
                  '@': 'Ä',
                  '[': 'Æ',
                  '\\': 'Ø',
                  ']': 'Å',
                  '^': 'Ü',
                  '`': 'ä',
                  '{': 'æ',
                  '|': 'ø',
                  '}': 'å',
                  '~': 'ü'
                }),
              (t.CHARSETS.Z = {
                '#': '£',
                '@': '§',
                '[': '¡',
                '\\': 'Ñ',
                ']': '¿',
                '{': '°',
                '|': 'ñ',
                '}': 'ç'
              }),
              (t.CHARSETS.H = t.CHARSETS[7] =
                {
                  '@': 'É',
                  '[': 'Ä',
                  '\\': 'Ö',
                  ']': 'Å',
                  '^': 'Ü',
                  '`': 'é',
                  '{': 'ä',
                  '|': 'ö',
                  '}': 'å',
                  '~': 'ü'
                }),
              (t.CHARSETS['='] = {
                '#': 'ù',
                '@': 'à',
                '[': 'é',
                '\\': 'ç',
                ']': 'ê',
                '^': 'î',
                _: 'è',
                '`': 'ô',
                '{': 'ä',
                '|': 'ö',
                '}': 'ü',
                '~': 'û'
              })
          },
          2584: (e, t) => {
            var n, o, i, r
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.C1_ESCAPED = t.C1 = t.C0 = void 0),
              ((r = n || (t.C0 = n = {})).NUL = '\0'),
              (r.SOH = ''),
              (r.STX = ''),
              (r.ETX = ''),
              (r.EOT = ''),
              (r.ENQ = ''),
              (r.ACK = ''),
              (r.BEL = ''),
              (r.BS = '\b'),
              (r.HT = '\t'),
              (r.LF = '\n'),
              (r.VT = '\v'),
              (r.FF = '\f'),
              (r.CR = '\r'),
              (r.SO = ''),
              (r.SI = ''),
              (r.DLE = ''),
              (r.DC1 = ''),
              (r.DC2 = ''),
              (r.DC3 = ''),
              (r.DC4 = ''),
              (r.NAK = ''),
              (r.SYN = ''),
              (r.ETB = ''),
              (r.CAN = ''),
              (r.EM = ''),
              (r.SUB = ''),
              (r.ESC = ''),
              (r.FS = ''),
              (r.GS = ''),
              (r.RS = ''),
              (r.US = ''),
              (r.SP = ' '),
              (r.DEL = ''),
              (function (e) {
                ;(e.PAD = ''),
                  (e.HOP = ''),
                  (e.BPH = ''),
                  (e.NBH = ''),
                  (e.IND = ''),
                  (e.NEL = ''),
                  (e.SSA = ''),
                  (e.ESA = ''),
                  (e.HTS = ''),
                  (e.HTJ = ''),
                  (e.VTS = ''),
                  (e.PLD = ''),
                  (e.PLU = ''),
                  (e.RI = ''),
                  (e.SS2 = ''),
                  (e.SS3 = ''),
                  (e.DCS = ''),
                  (e.PU1 = ''),
                  (e.PU2 = ''),
                  (e.STS = ''),
                  (e.CCH = ''),
                  (e.MW = ''),
                  (e.SPA = ''),
                  (e.EPA = ''),
                  (e.SOS = ''),
                  (e.SGCI = ''),
                  (e.SCI = ''),
                  (e.CSI = ''),
                  (e.ST = ''),
                  (e.OSC = ''),
                  (e.PM = ''),
                  (e.APC = '')
              })(o || (t.C1 = o = {})),
              (function (e) {
                e.ST = `${n.ESC}\\`
              })(i || (t.C1_ESCAPED = i = {}))
          },
          7399: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.evaluateKeyboardEvent = void 0)
            const o = n(2584),
              i = {
                48: ['0', ')'],
                49: ['1', '!'],
                50: ['2', '@'],
                51: ['3', '#'],
                52: ['4', '$'],
                53: ['5', '%'],
                54: ['6', '^'],
                55: ['7', '&'],
                56: ['8', '*'],
                57: ['9', '('],
                186: [';', ':'],
                187: ['=', '+'],
                188: [',', '<'],
                189: ['-', '_'],
                190: ['.', '>'],
                191: ['/', '?'],
                192: ['`', '~'],
                219: ['[', '{'],
                220: ['\\', '|'],
                221: [']', '}'],
                222: ["'", '"']
              }
            t.evaluateKeyboardEvent = function (e, t, n, r) {
              const a = { type: 0, cancel: !1, key: void 0 },
                s =
                  (e.shiftKey ? 1 : 0) |
                  (e.altKey ? 2 : 0) |
                  (e.ctrlKey ? 4 : 0) |
                  (e.metaKey ? 8 : 0)
              switch (e.keyCode) {
                case 0:
                  'UIKeyInputUpArrow' === e.key
                    ? (a.key = t ? o.C0.ESC + 'OA' : o.C0.ESC + '[A')
                    : 'UIKeyInputLeftArrow' === e.key
                      ? (a.key = t ? o.C0.ESC + 'OD' : o.C0.ESC + '[D')
                      : 'UIKeyInputRightArrow' === e.key
                        ? (a.key = t ? o.C0.ESC + 'OC' : o.C0.ESC + '[C')
                        : 'UIKeyInputDownArrow' === e.key &&
                          (a.key = t ? o.C0.ESC + 'OB' : o.C0.ESC + '[B')
                  break
                case 8:
                  ;(a.key = e.ctrlKey ? '\b' : o.C0.DEL),
                    e.altKey && (a.key = o.C0.ESC + a.key)
                  break
                case 9:
                  if (e.shiftKey) {
                    a.key = o.C0.ESC + '[Z'
                    break
                  }
                  ;(a.key = o.C0.HT), (a.cancel = !0)
                  break
                case 13:
                  ;(a.key = e.altKey ? o.C0.ESC + o.C0.CR : o.C0.CR),
                    (a.cancel = !0)
                  break
                case 27:
                  ;(a.key = o.C0.ESC),
                    e.altKey && (a.key = o.C0.ESC + o.C0.ESC),
                    (a.cancel = !0)
                  break
                case 37:
                  if (e.metaKey) break
                  s
                    ? ((a.key = o.C0.ESC + '[1;' + (s + 1) + 'D'),
                      a.key === o.C0.ESC + '[1;3D' &&
                        (a.key = o.C0.ESC + (n ? 'b' : '[1;5D')))
                    : (a.key = t ? o.C0.ESC + 'OD' : o.C0.ESC + '[D')
                  break
                case 39:
                  if (e.metaKey) break
                  s
                    ? ((a.key = o.C0.ESC + '[1;' + (s + 1) + 'C'),
                      a.key === o.C0.ESC + '[1;3C' &&
                        (a.key = o.C0.ESC + (n ? 'f' : '[1;5C')))
                    : (a.key = t ? o.C0.ESC + 'OC' : o.C0.ESC + '[C')
                  break
                case 38:
                  if (e.metaKey) break
                  s
                    ? ((a.key = o.C0.ESC + '[1;' + (s + 1) + 'A'),
                      n ||
                        a.key !== o.C0.ESC + '[1;3A' ||
                        (a.key = o.C0.ESC + '[1;5A'))
                    : (a.key = t ? o.C0.ESC + 'OA' : o.C0.ESC + '[A')
                  break
                case 40:
                  if (e.metaKey) break
                  s
                    ? ((a.key = o.C0.ESC + '[1;' + (s + 1) + 'B'),
                      n ||
                        a.key !== o.C0.ESC + '[1;3B' ||
                        (a.key = o.C0.ESC + '[1;5B'))
                    : (a.key = t ? o.C0.ESC + 'OB' : o.C0.ESC + '[B')
                  break
                case 45:
                  e.shiftKey || e.ctrlKey || (a.key = o.C0.ESC + '[2~')
                  break
                case 46:
                  a.key = s
                    ? o.C0.ESC + '[3;' + (s + 1) + '~'
                    : o.C0.ESC + '[3~'
                  break
                case 36:
                  a.key = s
                    ? o.C0.ESC + '[1;' + (s + 1) + 'H'
                    : t
                      ? o.C0.ESC + 'OH'
                      : o.C0.ESC + '[H'
                  break
                case 35:
                  a.key = s
                    ? o.C0.ESC + '[1;' + (s + 1) + 'F'
                    : t
                      ? o.C0.ESC + 'OF'
                      : o.C0.ESC + '[F'
                  break
                case 33:
                  e.shiftKey
                    ? (a.type = 2)
                    : e.ctrlKey
                      ? (a.key = o.C0.ESC + '[5;' + (s + 1) + '~')
                      : (a.key = o.C0.ESC + '[5~')
                  break
                case 34:
                  e.shiftKey
                    ? (a.type = 3)
                    : e.ctrlKey
                      ? (a.key = o.C0.ESC + '[6;' + (s + 1) + '~')
                      : (a.key = o.C0.ESC + '[6~')
                  break
                case 112:
                  a.key = s ? o.C0.ESC + '[1;' + (s + 1) + 'P' : o.C0.ESC + 'OP'
                  break
                case 113:
                  a.key = s ? o.C0.ESC + '[1;' + (s + 1) + 'Q' : o.C0.ESC + 'OQ'
                  break
                case 114:
                  a.key = s ? o.C0.ESC + '[1;' + (s + 1) + 'R' : o.C0.ESC + 'OR'
                  break
                case 115:
                  a.key = s ? o.C0.ESC + '[1;' + (s + 1) + 'S' : o.C0.ESC + 'OS'
                  break
                case 116:
                  a.key = s
                    ? o.C0.ESC + '[15;' + (s + 1) + '~'
                    : o.C0.ESC + '[15~'
                  break
                case 117:
                  a.key = s
                    ? o.C0.ESC + '[17;' + (s + 1) + '~'
                    : o.C0.ESC + '[17~'
                  break
                case 118:
                  a.key = s
                    ? o.C0.ESC + '[18;' + (s + 1) + '~'
                    : o.C0.ESC + '[18~'
                  break
                case 119:
                  a.key = s
                    ? o.C0.ESC + '[19;' + (s + 1) + '~'
                    : o.C0.ESC + '[19~'
                  break
                case 120:
                  a.key = s
                    ? o.C0.ESC + '[20;' + (s + 1) + '~'
                    : o.C0.ESC + '[20~'
                  break
                case 121:
                  a.key = s
                    ? o.C0.ESC + '[21;' + (s + 1) + '~'
                    : o.C0.ESC + '[21~'
                  break
                case 122:
                  a.key = s
                    ? o.C0.ESC + '[23;' + (s + 1) + '~'
                    : o.C0.ESC + '[23~'
                  break
                case 123:
                  a.key = s
                    ? o.C0.ESC + '[24;' + (s + 1) + '~'
                    : o.C0.ESC + '[24~'
                  break
                default:
                  if (!e.ctrlKey || e.shiftKey || e.altKey || e.metaKey)
                    if ((n && !r) || !e.altKey || e.metaKey)
                      !n || e.altKey || e.ctrlKey || e.shiftKey || !e.metaKey
                        ? e.key &&
                          !e.ctrlKey &&
                          !e.altKey &&
                          !e.metaKey &&
                          e.keyCode >= 48 &&
                          1 === e.key.length
                          ? (a.key = e.key)
                          : e.key &&
                            e.ctrlKey &&
                            ('_' === e.key && (a.key = o.C0.US),
                            '@' === e.key && (a.key = o.C0.NUL))
                        : 65 === e.keyCode && (a.type = 1)
                    else {
                      const t = i[e.keyCode],
                        n = t?.[e.shiftKey ? 1 : 0]
                      if (n) a.key = o.C0.ESC + n
                      else if (e.keyCode >= 65 && e.keyCode <= 90) {
                        const t = e.ctrlKey ? e.keyCode - 64 : e.keyCode + 32
                        let n = String.fromCharCode(t)
                        e.shiftKey && (n = n.toUpperCase()),
                          (a.key = o.C0.ESC + n)
                      } else if (32 === e.keyCode)
                        a.key = o.C0.ESC + (e.ctrlKey ? o.C0.NUL : ' ')
                      else if ('Dead' === e.key && e.code.startsWith('Key')) {
                        let t = e.code.slice(3, 4)
                        e.shiftKey || (t = t.toLowerCase()),
                          (a.key = o.C0.ESC + t),
                          (a.cancel = !0)
                      }
                    }
                  else
                    e.keyCode >= 65 && e.keyCode <= 90
                      ? (a.key = String.fromCharCode(e.keyCode - 64))
                      : 32 === e.keyCode
                        ? (a.key = o.C0.NUL)
                        : e.keyCode >= 51 && e.keyCode <= 55
                          ? (a.key = String.fromCharCode(e.keyCode - 51 + 27))
                          : 56 === e.keyCode
                            ? (a.key = o.C0.DEL)
                            : 219 === e.keyCode
                              ? (a.key = o.C0.ESC)
                              : 220 === e.keyCode
                                ? (a.key = o.C0.FS)
                                : 221 === e.keyCode && (a.key = o.C0.GS)
              }
              return a
            }
          },
          482: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.Utf8ToUtf32 =
                t.StringToUtf32 =
                t.utf32ToString =
                t.stringFromCodePoint =
                  void 0),
              (t.stringFromCodePoint = function (e) {
                return e > 65535
                  ? ((e -= 65536),
                    String.fromCharCode(55296 + (e >> 10)) +
                      String.fromCharCode((e % 1024) + 56320))
                  : String.fromCharCode(e)
              }),
              (t.utf32ToString = function (e, t = 0, n = e.length) {
                let o = ''
                for (let i = t; i < n; ++i) {
                  let t = e[i]
                  t > 65535
                    ? ((t -= 65536),
                      (o +=
                        String.fromCharCode(55296 + (t >> 10)) +
                        String.fromCharCode((t % 1024) + 56320)))
                    : (o += String.fromCharCode(t))
                }
                return o
              }),
              (t.StringToUtf32 = class {
                constructor() {
                  this._interim = 0
                }
                clear() {
                  this._interim = 0
                }
                decode(e, t) {
                  const n = e.length
                  if (!n) return 0
                  let o = 0,
                    i = 0
                  if (this._interim) {
                    const n = e.charCodeAt(i++)
                    56320 <= n && n <= 57343
                      ? (t[o++] =
                          1024 * (this._interim - 55296) + n - 56320 + 65536)
                      : ((t[o++] = this._interim), (t[o++] = n)),
                      (this._interim = 0)
                  }
                  for (let r = i; r < n; ++r) {
                    const i = e.charCodeAt(r)
                    if (55296 <= i && i <= 56319) {
                      if (++r >= n) return (this._interim = i), o
                      const a = e.charCodeAt(r)
                      56320 <= a && a <= 57343
                        ? (t[o++] = 1024 * (i - 55296) + a - 56320 + 65536)
                        : ((t[o++] = i), (t[o++] = a))
                    } else 65279 !== i && (t[o++] = i)
                  }
                  return o
                }
              }),
              (t.Utf8ToUtf32 = class {
                constructor() {
                  this.interim = new Uint8Array(3)
                }
                clear() {
                  this.interim.fill(0)
                }
                decode(e, t) {
                  const n = e.length
                  if (!n) return 0
                  let o,
                    i,
                    r,
                    a,
                    s = 0,
                    l = 0,
                    c = 0
                  if (this.interim[0]) {
                    let o = !1,
                      i = this.interim[0]
                    i &= 192 == (224 & i) ? 31 : 224 == (240 & i) ? 15 : 7
                    let r,
                      a = 0
                    for (; (r = 63 & this.interim[++a]) && a < 4; )
                      (i <<= 6), (i |= r)
                    const l =
                        192 == (224 & this.interim[0])
                          ? 2
                          : 224 == (240 & this.interim[0])
                            ? 3
                            : 4,
                      d = l - a
                    for (; c < d; ) {
                      if (c >= n) return 0
                      if (((r = e[c++]), 128 != (192 & r))) {
                        c--, (o = !0)
                        break
                      }
                      ;(this.interim[a++] = r), (i <<= 6), (i |= 63 & r)
                    }
                    o ||
                      (2 === l
                        ? i < 128
                          ? c--
                          : (t[s++] = i)
                        : 3 === l
                          ? i < 2048 ||
                            (i >= 55296 && i <= 57343) ||
                            65279 === i ||
                            (t[s++] = i)
                          : i < 65536 || i > 1114111 || (t[s++] = i)),
                      this.interim.fill(0)
                  }
                  const d = n - 4
                  let u = c
                  for (; u < n; ) {
                    for (
                      ;
                      !(
                        !(u < d) ||
                        128 & (o = e[u]) ||
                        128 & (i = e[u + 1]) ||
                        128 & (r = e[u + 2]) ||
                        128 & (a = e[u + 3])
                      );

                    )
                      (t[s++] = o),
                        (t[s++] = i),
                        (t[s++] = r),
                        (t[s++] = a),
                        (u += 4)
                    if (((o = e[u++]), o < 128)) t[s++] = o
                    else if (192 == (224 & o)) {
                      if (u >= n) return (this.interim[0] = o), s
                      if (((i = e[u++]), 128 != (192 & i))) {
                        u--
                        continue
                      }
                      if (((l = ((31 & o) << 6) | (63 & i)), l < 128)) {
                        u--
                        continue
                      }
                      t[s++] = l
                    } else if (224 == (240 & o)) {
                      if (u >= n) return (this.interim[0] = o), s
                      if (((i = e[u++]), 128 != (192 & i))) {
                        u--
                        continue
                      }
                      if (u >= n)
                        return (this.interim[0] = o), (this.interim[1] = i), s
                      if (((r = e[u++]), 128 != (192 & r))) {
                        u--
                        continue
                      }
                      if (
                        ((l = ((15 & o) << 12) | ((63 & i) << 6) | (63 & r)),
                        l < 2048 || (l >= 55296 && l <= 57343) || 65279 === l)
                      )
                        continue
                      t[s++] = l
                    } else if (240 == (248 & o)) {
                      if (u >= n) return (this.interim[0] = o), s
                      if (((i = e[u++]), 128 != (192 & i))) {
                        u--
                        continue
                      }
                      if (u >= n)
                        return (this.interim[0] = o), (this.interim[1] = i), s
                      if (((r = e[u++]), 128 != (192 & r))) {
                        u--
                        continue
                      }
                      if (u >= n)
                        return (
                          (this.interim[0] = o),
                          (this.interim[1] = i),
                          (this.interim[2] = r),
                          s
                        )
                      if (((a = e[u++]), 128 != (192 & a))) {
                        u--
                        continue
                      }
                      if (
                        ((l =
                          ((7 & o) << 18) |
                          ((63 & i) << 12) |
                          ((63 & r) << 6) |
                          (63 & a)),
                        l < 65536 || l > 1114111)
                      )
                        continue
                      t[s++] = l
                    }
                  }
                  return s
                }
              })
          },
          225: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.UnicodeV6 = void 0)
            const o = n(1480),
              i = [
                [768, 879],
                [1155, 1158],
                [1160, 1161],
                [1425, 1469],
                [1471, 1471],
                [1473, 1474],
                [1476, 1477],
                [1479, 1479],
                [1536, 1539],
                [1552, 1557],
                [1611, 1630],
                [1648, 1648],
                [1750, 1764],
                [1767, 1768],
                [1770, 1773],
                [1807, 1807],
                [1809, 1809],
                [1840, 1866],
                [1958, 1968],
                [2027, 2035],
                [2305, 2306],
                [2364, 2364],
                [2369, 2376],
                [2381, 2381],
                [2385, 2388],
                [2402, 2403],
                [2433, 2433],
                [2492, 2492],
                [2497, 2500],
                [2509, 2509],
                [2530, 2531],
                [2561, 2562],
                [2620, 2620],
                [2625, 2626],
                [2631, 2632],
                [2635, 2637],
                [2672, 2673],
                [2689, 2690],
                [2748, 2748],
                [2753, 2757],
                [2759, 2760],
                [2765, 2765],
                [2786, 2787],
                [2817, 2817],
                [2876, 2876],
                [2879, 2879],
                [2881, 2883],
                [2893, 2893],
                [2902, 2902],
                [2946, 2946],
                [3008, 3008],
                [3021, 3021],
                [3134, 3136],
                [3142, 3144],
                [3146, 3149],
                [3157, 3158],
                [3260, 3260],
                [3263, 3263],
                [3270, 3270],
                [3276, 3277],
                [3298, 3299],
                [3393, 3395],
                [3405, 3405],
                [3530, 3530],
                [3538, 3540],
                [3542, 3542],
                [3633, 3633],
                [3636, 3642],
                [3655, 3662],
                [3761, 3761],
                [3764, 3769],
                [3771, 3772],
                [3784, 3789],
                [3864, 3865],
                [3893, 3893],
                [3895, 3895],
                [3897, 3897],
                [3953, 3966],
                [3968, 3972],
                [3974, 3975],
                [3984, 3991],
                [3993, 4028],
                [4038, 4038],
                [4141, 4144],
                [4146, 4146],
                [4150, 4151],
                [4153, 4153],
                [4184, 4185],
                [4448, 4607],
                [4959, 4959],
                [5906, 5908],
                [5938, 5940],
                [5970, 5971],
                [6002, 6003],
                [6068, 6069],
                [6071, 6077],
                [6086, 6086],
                [6089, 6099],
                [6109, 6109],
                [6155, 6157],
                [6313, 6313],
                [6432, 6434],
                [6439, 6440],
                [6450, 6450],
                [6457, 6459],
                [6679, 6680],
                [6912, 6915],
                [6964, 6964],
                [6966, 6970],
                [6972, 6972],
                [6978, 6978],
                [7019, 7027],
                [7616, 7626],
                [7678, 7679],
                [8203, 8207],
                [8234, 8238],
                [8288, 8291],
                [8298, 8303],
                [8400, 8431],
                [12330, 12335],
                [12441, 12442],
                [43014, 43014],
                [43019, 43019],
                [43045, 43046],
                [64286, 64286],
                [65024, 65039],
                [65056, 65059],
                [65279, 65279],
                [65529, 65531]
              ],
              r = [
                [68097, 68099],
                [68101, 68102],
                [68108, 68111],
                [68152, 68154],
                [68159, 68159],
                [119143, 119145],
                [119155, 119170],
                [119173, 119179],
                [119210, 119213],
                [119362, 119364],
                [917505, 917505],
                [917536, 917631],
                [917760, 917999]
              ]
            let a
            t.UnicodeV6 = class {
              constructor() {
                if (((this.version = '6'), !a)) {
                  ;(a = new Uint8Array(65536)),
                    a.fill(1),
                    (a[0] = 0),
                    a.fill(0, 1, 32),
                    a.fill(0, 127, 160),
                    a.fill(2, 4352, 4448),
                    (a[9001] = 2),
                    (a[9002] = 2),
                    a.fill(2, 11904, 42192),
                    (a[12351] = 1),
                    a.fill(2, 44032, 55204),
                    a.fill(2, 63744, 64256),
                    a.fill(2, 65040, 65050),
                    a.fill(2, 65072, 65136),
                    a.fill(2, 65280, 65377),
                    a.fill(2, 65504, 65511)
                  for (let e = 0; e < i.length; ++e)
                    a.fill(0, i[e][0], i[e][1] + 1)
                }
              }
              wcwidth(e) {
                return e < 32
                  ? 0
                  : e < 127
                    ? 1
                    : e < 65536
                      ? a[e]
                      : (function (e, t) {
                            let n,
                              o = 0,
                              i = t.length - 1
                            if (e < t[0][0] || e > t[i][1]) return !1
                            for (; i >= o; )
                              if (((n = (o + i) >> 1), e > t[n][1])) o = n + 1
                              else {
                                if (!(e < t[n][0])) return !0
                                i = n - 1
                              }
                            return !1
                          })(e, r)
                        ? 0
                        : (e >= 131072 && e <= 196605) ||
                            (e >= 196608 && e <= 262141)
                          ? 2
                          : 1
              }
              charProperties(e, t) {
                let n = this.wcwidth(e),
                  i = 0 === n && 0 !== t
                if (i) {
                  const e = o.UnicodeService.extractWidth(t)
                  0 === e ? (i = !1) : e > n && (n = e)
                }
                return o.UnicodeService.createPropertyValue(0, n, i)
              }
            }
          },
          5981: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.WriteBuffer = void 0)
            const o = n(8460),
              i = n(844)
            class r extends i.Disposable {
              static {
                __name(this, 'n')
              }
              constructor(e) {
                super(),
                  (this._action = e),
                  (this._writeBuffer = []),
                  (this._callbacks = []),
                  (this._pendingData = 0),
                  (this._bufferOffset = 0),
                  (this._isSyncWriting = !1),
                  (this._syncCalls = 0),
                  (this._didUserInput = !1),
                  (this._onWriteParsed = this.register(new o.EventEmitter())),
                  (this.onWriteParsed = this._onWriteParsed.event)
              }
              handleUserInput() {
                this._didUserInput = !0
              }
              writeSync(e, t) {
                if (void 0 !== t && this._syncCalls > t)
                  return void (this._syncCalls = 0)
                if (
                  ((this._pendingData += e.length),
                  this._writeBuffer.push(e),
                  this._callbacks.push(void 0),
                  this._syncCalls++,
                  this._isSyncWriting)
                )
                  return
                let n
                for (
                  this._isSyncWriting = !0;
                  (n = this._writeBuffer.shift());

                ) {
                  this._action(n)
                  const e = this._callbacks.shift()
                  e && e()
                }
                ;(this._pendingData = 0),
                  (this._bufferOffset = 2147483647),
                  (this._isSyncWriting = !1),
                  (this._syncCalls = 0)
              }
              write(e, t) {
                if (this._pendingData > 5e7)
                  throw new Error(
                    'write data discarded, use flow control to avoid losing data'
                  )
                if (!this._writeBuffer.length) {
                  if (((this._bufferOffset = 0), this._didUserInput))
                    return (
                      (this._didUserInput = !1),
                      (this._pendingData += e.length),
                      this._writeBuffer.push(e),
                      this._callbacks.push(t),
                      void this._innerWrite()
                    )
                  setTimeout(() => this._innerWrite())
                }
                ;(this._pendingData += e.length),
                  this._writeBuffer.push(e),
                  this._callbacks.push(t)
              }
              _innerWrite(e = 0, t = !0) {
                const n = e || Date.now()
                for (; this._writeBuffer.length > this._bufferOffset; ) {
                  const e = this._writeBuffer[this._bufferOffset],
                    o = this._action(e, t)
                  if (o) {
                    const e = __name(
                      (e) =>
                        Date.now() - n >= 12
                          ? setTimeout(() => this._innerWrite(0, e))
                          : this._innerWrite(n, e),
                      'e'
                    )
                    return void o
                      .catch(
                        (e) => (
                          queueMicrotask(() => {
                            throw e
                          }),
                          Promise.resolve(!1)
                        )
                      )
                      .then(e)
                  }
                  const i = this._callbacks[this._bufferOffset]
                  if (
                    (i && i(),
                    this._bufferOffset++,
                    (this._pendingData -= e.length),
                    Date.now() - n >= 12)
                  )
                    break
                }
                this._writeBuffer.length > this._bufferOffset
                  ? (this._bufferOffset > 50 &&
                      ((this._writeBuffer = this._writeBuffer.slice(
                        this._bufferOffset
                      )),
                      (this._callbacks = this._callbacks.slice(
                        this._bufferOffset
                      )),
                      (this._bufferOffset = 0)),
                    setTimeout(() => this._innerWrite()))
                  : ((this._writeBuffer.length = 0),
                    (this._callbacks.length = 0),
                    (this._pendingData = 0),
                    (this._bufferOffset = 0)),
                  this._onWriteParsed.fire()
              }
            }
            t.WriteBuffer = r
          },
          5941: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.toRgbString = t.parseColor = void 0)
            const n =
                /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/,
              o = /^[\da-f]+$/
            function i(e, t) {
              const n = e.toString(16),
                o = n.length < 2 ? '0' + n : n
              switch (t) {
                case 4:
                  return n[0]
                case 8:
                  return o
                case 12:
                  return (o + o).slice(0, 3)
                default:
                  return o + o
              }
            }
            __name(i, 'r'),
              (t.parseColor = function (e) {
                if (!e) return
                let t = e.toLowerCase()
                if (0 === t.indexOf('rgb:')) {
                  t = t.slice(4)
                  const e = n.exec(t)
                  if (e) {
                    const t = e[1] ? 15 : e[4] ? 255 : e[7] ? 4095 : 65535
                    return [
                      Math.round(
                        (parseInt(e[1] || e[4] || e[7] || e[10], 16) / t) * 255
                      ),
                      Math.round(
                        (parseInt(e[2] || e[5] || e[8] || e[11], 16) / t) * 255
                      ),
                      Math.round(
                        (parseInt(e[3] || e[6] || e[9] || e[12], 16) / t) * 255
                      )
                    ]
                  }
                } else if (
                  0 === t.indexOf('#') &&
                  ((t = t.slice(1)),
                  o.exec(t) && [3, 6, 9, 12].includes(t.length))
                ) {
                  const e = t.length / 3,
                    n = [0, 0, 0]
                  for (let o = 0; o < 3; ++o) {
                    const i = parseInt(t.slice(e * o, e * o + e), 16)
                    n[o] =
                      1 === e ? i << 4 : 2 === e ? i : 3 === e ? i >> 4 : i >> 8
                  }
                  return n
                }
              }),
              (t.toRgbString = function (e, t = 16) {
                const [n, o, r] = e
                return `rgb:${i(n, t)}/${i(o, t)}/${i(r, t)}`
              })
          },
          5770: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.PAYLOAD_LIMIT = void 0),
              (t.PAYLOAD_LIMIT = 1e7)
          },
          6351: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.DcsHandler = t.DcsParser = void 0)
            const o = n(482),
              i = n(8742),
              r = n(5770),
              a = []
            t.DcsParser = class {
              constructor() {
                ;(this._handlers = Object.create(null)),
                  (this._active = a),
                  (this._ident = 0),
                  (this._handlerFb = () => {}),
                  (this._stack = {
                    paused: !1,
                    loopPosition: 0,
                    fallThrough: !1
                  })
              }
              dispose() {
                ;(this._handlers = Object.create(null)),
                  (this._handlerFb = () => {}),
                  (this._active = a)
              }
              registerHandler(e, t) {
                void 0 === this._handlers[e] && (this._handlers[e] = [])
                const n = this._handlers[e]
                return (
                  n.push(t),
                  {
                    dispose: __name(() => {
                      const e = n.indexOf(t)
                      ;-1 !== e && n.splice(e, 1)
                    }, 'dispose')
                  }
                )
              }
              clearHandler(e) {
                this._handlers[e] && delete this._handlers[e]
              }
              setHandlerFallback(e) {
                this._handlerFb = e
              }
              reset() {
                if (this._active.length)
                  for (
                    let e = this._stack.paused
                      ? this._stack.loopPosition - 1
                      : this._active.length - 1;
                    e >= 0;
                    --e
                  )
                    this._active[e].unhook(!1)
                ;(this._stack.paused = !1),
                  (this._active = a),
                  (this._ident = 0)
              }
              hook(e, t) {
                if (
                  (this.reset(),
                  (this._ident = e),
                  (this._active = this._handlers[e] || a),
                  this._active.length)
                )
                  for (let n = this._active.length - 1; n >= 0; n--)
                    this._active[n].hook(t)
                else this._handlerFb(this._ident, 'HOOK', t)
              }
              put(e, t, n) {
                if (this._active.length)
                  for (let o = this._active.length - 1; o >= 0; o--)
                    this._active[o].put(e, t, n)
                else
                  this._handlerFb(
                    this._ident,
                    'PUT',
                    (0, o.utf32ToString)(e, t, n)
                  )
              }
              unhook(e, t = !0) {
                if (this._active.length) {
                  let n = !1,
                    o = this._active.length - 1,
                    i = !1
                  if (
                    (this._stack.paused &&
                      ((o = this._stack.loopPosition - 1),
                      (n = t),
                      (i = this._stack.fallThrough),
                      (this._stack.paused = !1)),
                    !i && !1 === n)
                  ) {
                    for (
                      ;
                      o >= 0 && ((n = this._active[o].unhook(e)), !0 !== n);
                      o--
                    )
                      if (n instanceof Promise)
                        return (
                          (this._stack.paused = !0),
                          (this._stack.loopPosition = o),
                          (this._stack.fallThrough = !1),
                          n
                        )
                    o--
                  }
                  for (; o >= 0; o--)
                    if (
                      ((n = this._active[o].unhook(!1)), n instanceof Promise)
                    )
                      return (
                        (this._stack.paused = !0),
                        (this._stack.loopPosition = o),
                        (this._stack.fallThrough = !0),
                        n
                      )
                } else this._handlerFb(this._ident, 'UNHOOK', e)
                ;(this._active = a), (this._ident = 0)
              }
            }
            const s = new i.Params()
            s.addParam(0),
              (t.DcsHandler = class {
                constructor(e) {
                  ;(this._handler = e),
                    (this._data = ''),
                    (this._params = s),
                    (this._hitLimit = !1)
                }
                hook(e) {
                  ;(this._params = e.length > 1 || e.params[0] ? e.clone() : s),
                    (this._data = ''),
                    (this._hitLimit = !1)
                }
                put(e, t, n) {
                  this._hitLimit ||
                    ((this._data += (0, o.utf32ToString)(e, t, n)),
                    this._data.length > r.PAYLOAD_LIMIT &&
                      ((this._data = ''), (this._hitLimit = !0)))
                }
                unhook(e) {
                  let t = !1
                  if (this._hitLimit) t = !1
                  else if (
                    e &&
                    ((t = this._handler(this._data, this._params)),
                    t instanceof Promise)
                  )
                    return t.then(
                      (e) => (
                        (this._params = s),
                        (this._data = ''),
                        (this._hitLimit = !1),
                        e
                      )
                    )
                  return (
                    (this._params = s),
                    (this._data = ''),
                    (this._hitLimit = !1),
                    t
                  )
                }
              })
          },
          2015: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.EscapeSequenceParser =
                t.VT500_TRANSITION_TABLE =
                t.TransitionTable =
                  void 0)
            const o = n(844),
              i = n(8742),
              r = n(6242),
              a = n(6351)
            class s {
              static {
                __name(this, 'a')
              }
              constructor(e) {
                this.table = new Uint8Array(e)
              }
              setDefault(e, t) {
                this.table.fill((e << 4) | t)
              }
              add(e, t, n, o) {
                this.table[(t << 8) | e] = (n << 4) | o
              }
              addMany(e, t, n, o) {
                for (let i = 0; i < e.length; i++)
                  this.table[(t << 8) | e[i]] = (n << 4) | o
              }
            }
            t.TransitionTable = s
            const l = 160
            t.VT500_TRANSITION_TABLE = (function () {
              const e = new s(4095),
                t = Array.apply(null, Array(256)).map((e, t) => t),
                n = __name((e, n) => t.slice(e, n), 'i'),
                o = n(32, 127),
                i = n(0, 24)
              i.push(25), i.push.apply(i, n(28, 32))
              const r = n(0, 14)
              let a
              for (a in (e.setDefault(1, 0), e.addMany(o, 0, 2, 0), r))
                e.addMany([24, 26, 153, 154], a, 3, 0),
                  e.addMany(n(128, 144), a, 3, 0),
                  e.addMany(n(144, 152), a, 3, 0),
                  e.add(156, a, 0, 0),
                  e.add(27, a, 11, 1),
                  e.add(157, a, 4, 8),
                  e.addMany([152, 158, 159], a, 0, 7),
                  e.add(155, a, 11, 3),
                  e.add(144, a, 11, 9)
              return (
                e.addMany(i, 0, 3, 0),
                e.addMany(i, 1, 3, 1),
                e.add(127, 1, 0, 1),
                e.addMany(i, 8, 0, 8),
                e.addMany(i, 3, 3, 3),
                e.add(127, 3, 0, 3),
                e.addMany(i, 4, 3, 4),
                e.add(127, 4, 0, 4),
                e.addMany(i, 6, 3, 6),
                e.addMany(i, 5, 3, 5),
                e.add(127, 5, 0, 5),
                e.addMany(i, 2, 3, 2),
                e.add(127, 2, 0, 2),
                e.add(93, 1, 4, 8),
                e.addMany(o, 8, 5, 8),
                e.add(127, 8, 5, 8),
                e.addMany([156, 27, 24, 26, 7], 8, 6, 0),
                e.addMany(n(28, 32), 8, 0, 8),
                e.addMany([88, 94, 95], 1, 0, 7),
                e.addMany(o, 7, 0, 7),
                e.addMany(i, 7, 0, 7),
                e.add(156, 7, 0, 0),
                e.add(127, 7, 0, 7),
                e.add(91, 1, 11, 3),
                e.addMany(n(64, 127), 3, 7, 0),
                e.addMany(n(48, 60), 3, 8, 4),
                e.addMany([60, 61, 62, 63], 3, 9, 4),
                e.addMany(n(48, 60), 4, 8, 4),
                e.addMany(n(64, 127), 4, 7, 0),
                e.addMany([60, 61, 62, 63], 4, 0, 6),
                e.addMany(n(32, 64), 6, 0, 6),
                e.add(127, 6, 0, 6),
                e.addMany(n(64, 127), 6, 0, 0),
                e.addMany(n(32, 48), 3, 9, 5),
                e.addMany(n(32, 48), 5, 9, 5),
                e.addMany(n(48, 64), 5, 0, 6),
                e.addMany(n(64, 127), 5, 7, 0),
                e.addMany(n(32, 48), 4, 9, 5),
                e.addMany(n(32, 48), 1, 9, 2),
                e.addMany(n(32, 48), 2, 9, 2),
                e.addMany(n(48, 127), 2, 10, 0),
                e.addMany(n(48, 80), 1, 10, 0),
                e.addMany(n(81, 88), 1, 10, 0),
                e.addMany([89, 90, 92], 1, 10, 0),
                e.addMany(n(96, 127), 1, 10, 0),
                e.add(80, 1, 11, 9),
                e.addMany(i, 9, 0, 9),
                e.add(127, 9, 0, 9),
                e.addMany(n(28, 32), 9, 0, 9),
                e.addMany(n(32, 48), 9, 9, 12),
                e.addMany(n(48, 60), 9, 8, 10),
                e.addMany([60, 61, 62, 63], 9, 9, 10),
                e.addMany(i, 11, 0, 11),
                e.addMany(n(32, 128), 11, 0, 11),
                e.addMany(n(28, 32), 11, 0, 11),
                e.addMany(i, 10, 0, 10),
                e.add(127, 10, 0, 10),
                e.addMany(n(28, 32), 10, 0, 10),
                e.addMany(n(48, 60), 10, 8, 10),
                e.addMany([60, 61, 62, 63], 10, 0, 11),
                e.addMany(n(32, 48), 10, 9, 12),
                e.addMany(i, 12, 0, 12),
                e.add(127, 12, 0, 12),
                e.addMany(n(28, 32), 12, 0, 12),
                e.addMany(n(32, 48), 12, 9, 12),
                e.addMany(n(48, 64), 12, 0, 11),
                e.addMany(n(64, 127), 12, 12, 13),
                e.addMany(n(64, 127), 10, 12, 13),
                e.addMany(n(64, 127), 9, 12, 13),
                e.addMany(i, 13, 13, 13),
                e.addMany(o, 13, 13, 13),
                e.add(127, 13, 0, 13),
                e.addMany([27, 156, 24, 26], 13, 14, 0),
                e.add(l, 0, 2, 0),
                e.add(l, 8, 5, 8),
                e.add(l, 6, 0, 6),
                e.add(l, 11, 0, 11),
                e.add(l, 13, 13, 13),
                e
              )
            })()
            class c extends o.Disposable {
              static {
                __name(this, 'c')
              }
              constructor(e = t.VT500_TRANSITION_TABLE) {
                super(),
                  (this._transitions = e),
                  (this._parseStack = {
                    state: 0,
                    handlers: [],
                    handlerPos: 0,
                    transition: 0,
                    chunkPos: 0
                  }),
                  (this.initialState = 0),
                  (this.currentState = this.initialState),
                  (this._params = new i.Params()),
                  this._params.addParam(0),
                  (this._collect = 0),
                  (this.precedingJoinState = 0),
                  (this._printHandlerFb = (e, t, n) => {}),
                  (this._executeHandlerFb = (e) => {}),
                  (this._csiHandlerFb = (e, t) => {}),
                  (this._escHandlerFb = (e) => {}),
                  (this._errorHandlerFb = (e) => e),
                  (this._printHandler = this._printHandlerFb),
                  (this._executeHandlers = Object.create(null)),
                  (this._csiHandlers = Object.create(null)),
                  (this._escHandlers = Object.create(null)),
                  this.register(
                    (0, o.toDisposable)(() => {
                      ;(this._csiHandlers = Object.create(null)),
                        (this._executeHandlers = Object.create(null)),
                        (this._escHandlers = Object.create(null))
                    })
                  ),
                  (this._oscParser = this.register(new r.OscParser())),
                  (this._dcsParser = this.register(new a.DcsParser())),
                  (this._errorHandler = this._errorHandlerFb),
                  this.registerEscHandler({ final: '\\' }, () => !0)
              }
              _identifier(e, t = [64, 126]) {
                let n = 0
                if (e.prefix) {
                  if (e.prefix.length > 1)
                    throw new Error('only one byte as prefix supported')
                  if (((n = e.prefix.charCodeAt(0)), (n && 60 > n) || n > 63))
                    throw new Error('prefix must be in range 0x3c .. 0x3f')
                }
                if (e.intermediates) {
                  if (e.intermediates.length > 2)
                    throw new Error(
                      'only two bytes as intermediates are supported'
                    )
                  for (let t = 0; t < e.intermediates.length; ++t) {
                    const o = e.intermediates.charCodeAt(t)
                    if (32 > o || o > 47)
                      throw new Error(
                        'intermediate must be in range 0x20 .. 0x2f'
                      )
                    ;(n <<= 8), (n |= o)
                  }
                }
                if (1 !== e.final.length)
                  throw new Error('final must be a single byte')
                const o = e.final.charCodeAt(0)
                if (t[0] > o || o > t[1])
                  throw new Error(`final must be in range ${t[0]} .. ${t[1]}`)
                return (n <<= 8), (n |= o), n
              }
              identToString(e) {
                const t = []
                for (; e; ) t.push(String.fromCharCode(255 & e)), (e >>= 8)
                return t.reverse().join('')
              }
              setPrintHandler(e) {
                this._printHandler = e
              }
              clearPrintHandler() {
                this._printHandler = this._printHandlerFb
              }
              registerEscHandler(e, t) {
                const n = this._identifier(e, [48, 126])
                void 0 === this._escHandlers[n] && (this._escHandlers[n] = [])
                const o = this._escHandlers[n]
                return (
                  o.push(t),
                  {
                    dispose: __name(() => {
                      const e = o.indexOf(t)
                      ;-1 !== e && o.splice(e, 1)
                    }, 'dispose')
                  }
                )
              }
              clearEscHandler(e) {
                this._escHandlers[this._identifier(e, [48, 126])] &&
                  delete this._escHandlers[this._identifier(e, [48, 126])]
              }
              setEscHandlerFallback(e) {
                this._escHandlerFb = e
              }
              setExecuteHandler(e, t) {
                this._executeHandlers[e.charCodeAt(0)] = t
              }
              clearExecuteHandler(e) {
                this._executeHandlers[e.charCodeAt(0)] &&
                  delete this._executeHandlers[e.charCodeAt(0)]
              }
              setExecuteHandlerFallback(e) {
                this._executeHandlerFb = e
              }
              registerCsiHandler(e, t) {
                const n = this._identifier(e)
                void 0 === this._csiHandlers[n] && (this._csiHandlers[n] = [])
                const o = this._csiHandlers[n]
                return (
                  o.push(t),
                  {
                    dispose: __name(() => {
                      const e = o.indexOf(t)
                      ;-1 !== e && o.splice(e, 1)
                    }, 'dispose')
                  }
                )
              }
              clearCsiHandler(e) {
                this._csiHandlers[this._identifier(e)] &&
                  delete this._csiHandlers[this._identifier(e)]
              }
              setCsiHandlerFallback(e) {
                this._csiHandlerFb = e
              }
              registerDcsHandler(e, t) {
                return this._dcsParser.registerHandler(this._identifier(e), t)
              }
              clearDcsHandler(e) {
                this._dcsParser.clearHandler(this._identifier(e))
              }
              setDcsHandlerFallback(e) {
                this._dcsParser.setHandlerFallback(e)
              }
              registerOscHandler(e, t) {
                return this._oscParser.registerHandler(e, t)
              }
              clearOscHandler(e) {
                this._oscParser.clearHandler(e)
              }
              setOscHandlerFallback(e) {
                this._oscParser.setHandlerFallback(e)
              }
              setErrorHandler(e) {
                this._errorHandler = e
              }
              clearErrorHandler() {
                this._errorHandler = this._errorHandlerFb
              }
              reset() {
                ;(this.currentState = this.initialState),
                  this._oscParser.reset(),
                  this._dcsParser.reset(),
                  this._params.reset(),
                  this._params.addParam(0),
                  (this._collect = 0),
                  (this.precedingJoinState = 0),
                  0 !== this._parseStack.state &&
                    ((this._parseStack.state = 2),
                    (this._parseStack.handlers = []))
              }
              _preserveStack(e, t, n, o, i) {
                ;(this._parseStack.state = e),
                  (this._parseStack.handlers = t),
                  (this._parseStack.handlerPos = n),
                  (this._parseStack.transition = o),
                  (this._parseStack.chunkPos = i)
              }
              parse(e, t, n) {
                let o,
                  i = 0,
                  r = 0,
                  a = 0
                if (this._parseStack.state)
                  if (2 === this._parseStack.state)
                    (this._parseStack.state = 0),
                      (a = this._parseStack.chunkPos + 1)
                  else {
                    if (void 0 === n || 1 === this._parseStack.state)
                      throw (
                        ((this._parseStack.state = 1),
                        new Error(
                          'improper continuation due to previous async handler, giving up parsing'
                        ))
                      )
                    const t = this._parseStack.handlers
                    let r = this._parseStack.handlerPos - 1
                    switch (this._parseStack.state) {
                      case 3:
                        if (!1 === n && r > -1)
                          for (
                            ;
                            r >= 0 && ((o = t[r](this._params)), !0 !== o);
                            r--
                          )
                            if (o instanceof Promise)
                              return (this._parseStack.handlerPos = r), o
                        this._parseStack.handlers = []
                        break
                      case 4:
                        if (!1 === n && r > -1)
                          for (; r >= 0 && ((o = t[r]()), !0 !== o); r--)
                            if (o instanceof Promise)
                              return (this._parseStack.handlerPos = r), o
                        this._parseStack.handlers = []
                        break
                      case 6:
                        if (
                          ((i = e[this._parseStack.chunkPos]),
                          (o = this._dcsParser.unhook(24 !== i && 26 !== i, n)),
                          o)
                        )
                          return o
                        27 === i && (this._parseStack.transition |= 1),
                          this._params.reset(),
                          this._params.addParam(0),
                          (this._collect = 0)
                        break
                      case 5:
                        if (
                          ((i = e[this._parseStack.chunkPos]),
                          (o = this._oscParser.end(24 !== i && 26 !== i, n)),
                          o)
                        )
                          return o
                        27 === i && (this._parseStack.transition |= 1),
                          this._params.reset(),
                          this._params.addParam(0),
                          (this._collect = 0)
                    }
                    ;(this._parseStack.state = 0),
                      (a = this._parseStack.chunkPos + 1),
                      (this.precedingJoinState = 0),
                      (this.currentState = 15 & this._parseStack.transition)
                  }
                for (let s = a; s < t; ++s) {
                  switch (
                    ((i = e[s]),
                    (r =
                      this._transitions.table[
                        (this.currentState << 8) | (i < 160 ? i : l)
                      ]),
                    r >> 4)
                  ) {
                    case 2:
                      for (let o = s + 1; ; ++o) {
                        if (o >= t || (i = e[o]) < 32 || (i > 126 && i < l)) {
                          this._printHandler(e, s, o), (s = o - 1)
                          break
                        }
                        if (++o >= t || (i = e[o]) < 32 || (i > 126 && i < l)) {
                          this._printHandler(e, s, o), (s = o - 1)
                          break
                        }
                        if (++o >= t || (i = e[o]) < 32 || (i > 126 && i < l)) {
                          this._printHandler(e, s, o), (s = o - 1)
                          break
                        }
                        if (++o >= t || (i = e[o]) < 32 || (i > 126 && i < l)) {
                          this._printHandler(e, s, o), (s = o - 1)
                          break
                        }
                      }
                      break
                    case 3:
                      this._executeHandlers[i]
                        ? this._executeHandlers[i]()
                        : this._executeHandlerFb(i),
                        (this.precedingJoinState = 0)
                      break
                    case 0:
                      break
                    case 1:
                      if (
                        this._errorHandler({
                          position: s,
                          code: i,
                          currentState: this.currentState,
                          collect: this._collect,
                          params: this._params,
                          abort: !1
                        }).abort
                      )
                        return
                      break
                    case 7:
                      const n = this._csiHandlers[(this._collect << 8) | i]
                      let a = n ? n.length - 1 : -1
                      for (
                        ;
                        a >= 0 && ((o = n[a](this._params)), !0 !== o);
                        a--
                      )
                        if (o instanceof Promise)
                          return this._preserveStack(3, n, a, r, s), o
                      a < 0 &&
                        this._csiHandlerFb(
                          (this._collect << 8) | i,
                          this._params
                        ),
                        (this.precedingJoinState = 0)
                      break
                    case 8:
                      do {
                        switch (i) {
                          case 59:
                            this._params.addParam(0)
                            break
                          case 58:
                            this._params.addSubParam(-1)
                            break
                          default:
                            this._params.addDigit(i - 48)
                        }
                      } while (++s < t && (i = e[s]) > 47 && i < 60)
                      s--
                      break
                    case 9:
                      ;(this._collect <<= 8), (this._collect |= i)
                      break
                    case 10:
                      const c = this._escHandlers[(this._collect << 8) | i]
                      let d = c ? c.length - 1 : -1
                      for (; d >= 0 && ((o = c[d]()), !0 !== o); d--)
                        if (o instanceof Promise)
                          return this._preserveStack(4, c, d, r, s), o
                      d < 0 && this._escHandlerFb((this._collect << 8) | i),
                        (this.precedingJoinState = 0)
                      break
                    case 11:
                      this._params.reset(),
                        this._params.addParam(0),
                        (this._collect = 0)
                      break
                    case 12:
                      this._dcsParser.hook(
                        (this._collect << 8) | i,
                        this._params
                      )
                      break
                    case 13:
                      for (let o = s + 1; ; ++o)
                        if (
                          o >= t ||
                          24 === (i = e[o]) ||
                          26 === i ||
                          27 === i ||
                          (i > 127 && i < l)
                        ) {
                          this._dcsParser.put(e, s, o), (s = o - 1)
                          break
                        }
                      break
                    case 14:
                      if (
                        ((o = this._dcsParser.unhook(24 !== i && 26 !== i)), o)
                      )
                        return this._preserveStack(6, [], 0, r, s), o
                      27 === i && (r |= 1),
                        this._params.reset(),
                        this._params.addParam(0),
                        (this._collect = 0),
                        (this.precedingJoinState = 0)
                      break
                    case 4:
                      this._oscParser.start()
                      break
                    case 5:
                      for (let o = s + 1; ; o++)
                        if (o >= t || (i = e[o]) < 32 || (i > 127 && i < l)) {
                          this._oscParser.put(e, s, o), (s = o - 1)
                          break
                        }
                      break
                    case 6:
                      if (((o = this._oscParser.end(24 !== i && 26 !== i)), o))
                        return this._preserveStack(5, [], 0, r, s), o
                      27 === i && (r |= 1),
                        this._params.reset(),
                        this._params.addParam(0),
                        (this._collect = 0),
                        (this.precedingJoinState = 0)
                  }
                  this.currentState = 15 & r
                }
              }
            }
            t.EscapeSequenceParser = c
          },
          6242: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.OscHandler = t.OscParser = void 0)
            const o = n(5770),
              i = n(482),
              r = []
            ;(t.OscParser = class {
              constructor() {
                ;(this._state = 0),
                  (this._active = r),
                  (this._id = -1),
                  (this._handlers = Object.create(null)),
                  (this._handlerFb = () => {}),
                  (this._stack = {
                    paused: !1,
                    loopPosition: 0,
                    fallThrough: !1
                  })
              }
              registerHandler(e, t) {
                void 0 === this._handlers[e] && (this._handlers[e] = [])
                const n = this._handlers[e]
                return (
                  n.push(t),
                  {
                    dispose: __name(() => {
                      const e = n.indexOf(t)
                      ;-1 !== e && n.splice(e, 1)
                    }, 'dispose')
                  }
                )
              }
              clearHandler(e) {
                this._handlers[e] && delete this._handlers[e]
              }
              setHandlerFallback(e) {
                this._handlerFb = e
              }
              dispose() {
                ;(this._handlers = Object.create(null)),
                  (this._handlerFb = () => {}),
                  (this._active = r)
              }
              reset() {
                if (2 === this._state)
                  for (
                    let e = this._stack.paused
                      ? this._stack.loopPosition - 1
                      : this._active.length - 1;
                    e >= 0;
                    --e
                  )
                    this._active[e].end(!1)
                ;(this._stack.paused = !1),
                  (this._active = r),
                  (this._id = -1),
                  (this._state = 0)
              }
              _start() {
                if (
                  ((this._active = this._handlers[this._id] || r),
                  this._active.length)
                )
                  for (let e = this._active.length - 1; e >= 0; e--)
                    this._active[e].start()
                else this._handlerFb(this._id, 'START')
              }
              _put(e, t, n) {
                if (this._active.length)
                  for (let o = this._active.length - 1; o >= 0; o--)
                    this._active[o].put(e, t, n)
                else
                  this._handlerFb(
                    this._id,
                    'PUT',
                    (0, i.utf32ToString)(e, t, n)
                  )
              }
              start() {
                this.reset(), (this._state = 1)
              }
              put(e, t, n) {
                if (3 !== this._state) {
                  if (1 === this._state)
                    for (; t < n; ) {
                      const n = e[t++]
                      if (59 === n) {
                        ;(this._state = 2), this._start()
                        break
                      }
                      if (n < 48 || 57 < n) return void (this._state = 3)
                      ;-1 === this._id && (this._id = 0),
                        (this._id = 10 * this._id + n - 48)
                    }
                  2 === this._state && n - t > 0 && this._put(e, t, n)
                }
              }
              end(e, t = !0) {
                if (0 !== this._state) {
                  if (3 !== this._state)
                    if (
                      (1 === this._state && this._start(), this._active.length)
                    ) {
                      let n = !1,
                        o = this._active.length - 1,
                        i = !1
                      if (
                        (this._stack.paused &&
                          ((o = this._stack.loopPosition - 1),
                          (n = t),
                          (i = this._stack.fallThrough),
                          (this._stack.paused = !1)),
                        !i && !1 === n)
                      ) {
                        for (
                          ;
                          o >= 0 && ((n = this._active[o].end(e)), !0 !== n);
                          o--
                        )
                          if (n instanceof Promise)
                            return (
                              (this._stack.paused = !0),
                              (this._stack.loopPosition = o),
                              (this._stack.fallThrough = !1),
                              n
                            )
                        o--
                      }
                      for (; o >= 0; o--)
                        if (
                          ((n = this._active[o].end(!1)), n instanceof Promise)
                        )
                          return (
                            (this._stack.paused = !0),
                            (this._stack.loopPosition = o),
                            (this._stack.fallThrough = !0),
                            n
                          )
                    } else this._handlerFb(this._id, 'END', e)
                  ;(this._active = r), (this._id = -1), (this._state = 0)
                }
              }
            }),
              (t.OscHandler = class {
                constructor(e) {
                  ;(this._handler = e), (this._data = ''), (this._hitLimit = !1)
                }
                start() {
                  ;(this._data = ''), (this._hitLimit = !1)
                }
                put(e, t, n) {
                  this._hitLimit ||
                    ((this._data += (0, i.utf32ToString)(e, t, n)),
                    this._data.length > o.PAYLOAD_LIMIT &&
                      ((this._data = ''), (this._hitLimit = !0)))
                }
                end(e) {
                  let t = !1
                  if (this._hitLimit) t = !1
                  else if (
                    e &&
                    ((t = this._handler(this._data)), t instanceof Promise)
                  )
                    return t.then(
                      (e) => ((this._data = ''), (this._hitLimit = !1), e)
                    )
                  return (this._data = ''), (this._hitLimit = !1), t
                }
              })
          },
          8742: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.Params = void 0)
            const n = 2147483647
            class o {
              static {
                __name(this, 's')
              }
              static fromArray(e) {
                const t = new o()
                if (!e.length) return t
                for (let n = Array.isArray(e[0]) ? 1 : 0; n < e.length; ++n) {
                  const o = e[n]
                  if (Array.isArray(o))
                    for (let e = 0; e < o.length; ++e) t.addSubParam(o[e])
                  else t.addParam(o)
                }
                return t
              }
              constructor(e = 32, t = 32) {
                if (
                  ((this.maxLength = e), (this.maxSubParamsLength = t), t > 256)
                )
                  throw new Error(
                    'maxSubParamsLength must not be greater than 256'
                  )
                ;(this.params = new Int32Array(e)),
                  (this.length = 0),
                  (this._subParams = new Int32Array(t)),
                  (this._subParamsLength = 0),
                  (this._subParamsIdx = new Uint16Array(e)),
                  (this._rejectDigits = !1),
                  (this._rejectSubDigits = !1),
                  (this._digitIsSub = !1)
              }
              clone() {
                const e = new o(this.maxLength, this.maxSubParamsLength)
                return (
                  e.params.set(this.params),
                  (e.length = this.length),
                  e._subParams.set(this._subParams),
                  (e._subParamsLength = this._subParamsLength),
                  e._subParamsIdx.set(this._subParamsIdx),
                  (e._rejectDigits = this._rejectDigits),
                  (e._rejectSubDigits = this._rejectSubDigits),
                  (e._digitIsSub = this._digitIsSub),
                  e
                )
              }
              toArray() {
                const e = []
                for (let t = 0; t < this.length; ++t) {
                  e.push(this.params[t])
                  const n = this._subParamsIdx[t] >> 8,
                    o = 255 & this._subParamsIdx[t]
                  o - n > 0 &&
                    e.push(Array.prototype.slice.call(this._subParams, n, o))
                }
                return e
              }
              reset() {
                ;(this.length = 0),
                  (this._subParamsLength = 0),
                  (this._rejectDigits = !1),
                  (this._rejectSubDigits = !1),
                  (this._digitIsSub = !1)
              }
              addParam(e) {
                if (((this._digitIsSub = !1), this.length >= this.maxLength))
                  this._rejectDigits = !0
                else {
                  if (e < -1)
                    throw new Error('values lesser than -1 are not allowed')
                  ;(this._subParamsIdx[this.length] =
                    (this._subParamsLength << 8) | this._subParamsLength),
                    (this.params[this.length++] = e > n ? n : e)
                }
              }
              addSubParam(e) {
                if (((this._digitIsSub = !0), this.length))
                  if (
                    this._rejectDigits ||
                    this._subParamsLength >= this.maxSubParamsLength
                  )
                    this._rejectSubDigits = !0
                  else {
                    if (e < -1)
                      throw new Error('values lesser than -1 are not allowed')
                    ;(this._subParams[this._subParamsLength++] = e > n ? n : e),
                      this._subParamsIdx[this.length - 1]++
                  }
              }
              hasSubParams(e) {
                return (
                  (255 & this._subParamsIdx[e]) - (this._subParamsIdx[e] >> 8) >
                  0
                )
              }
              getSubParams(e) {
                const t = this._subParamsIdx[e] >> 8,
                  n = 255 & this._subParamsIdx[e]
                return n - t > 0 ? this._subParams.subarray(t, n) : null
              }
              getSubParamsAll() {
                const e = {}
                for (let t = 0; t < this.length; ++t) {
                  const n = this._subParamsIdx[t] >> 8,
                    o = 255 & this._subParamsIdx[t]
                  o - n > 0 && (e[t] = this._subParams.slice(n, o))
                }
                return e
              }
              addDigit(e) {
                let t
                if (
                  this._rejectDigits ||
                  !(t = this._digitIsSub
                    ? this._subParamsLength
                    : this.length) ||
                  (this._digitIsSub && this._rejectSubDigits)
                )
                  return
                const o = this._digitIsSub ? this._subParams : this.params,
                  i = o[t - 1]
                o[t - 1] = ~i ? Math.min(10 * i + e, n) : e
              }
            }
            t.Params = o
          },
          5741: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.AddonManager = void 0),
              (t.AddonManager = class {
                constructor() {
                  this._addons = []
                }
                dispose() {
                  for (let e = this._addons.length - 1; e >= 0; e--)
                    this._addons[e].instance.dispose()
                }
                loadAddon(e, t) {
                  const n = { instance: t, dispose: t.dispose, isDisposed: !1 }
                  this._addons.push(n),
                    (t.dispose = () => this._wrappedAddonDispose(n)),
                    t.activate(e)
                }
                _wrappedAddonDispose(e) {
                  if (e.isDisposed) return
                  let t = -1
                  for (let n = 0; n < this._addons.length; n++)
                    if (this._addons[n] === e) {
                      t = n
                      break
                    }
                  if (-1 === t)
                    throw new Error(
                      'Could not dispose an addon that has not been loaded'
                    )
                  ;(e.isDisposed = !0),
                    e.dispose.apply(e.instance),
                    this._addons.splice(t, 1)
                }
              })
          },
          8771: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.BufferApiView = void 0)
            const o = n(3785),
              i = n(511)
            t.BufferApiView = class {
              constructor(e, t) {
                ;(this._buffer = e), (this.type = t)
              }
              init(e) {
                return (this._buffer = e), this
              }
              get cursorY() {
                return this._buffer.y
              }
              get cursorX() {
                return this._buffer.x
              }
              get viewportY() {
                return this._buffer.ydisp
              }
              get baseY() {
                return this._buffer.ybase
              }
              get length() {
                return this._buffer.lines.length
              }
              getLine(e) {
                const t = this._buffer.lines.get(e)
                if (t) return new o.BufferLineApiView(t)
              }
              getNullCell() {
                return new i.CellData()
              }
            }
          },
          3785: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.BufferLineApiView = void 0)
            const o = n(511)
            t.BufferLineApiView = class {
              constructor(e) {
                this._line = e
              }
              get isWrapped() {
                return this._line.isWrapped
              }
              get length() {
                return this._line.length
              }
              getCell(e, t) {
                if (!(e < 0 || e >= this._line.length))
                  return t
                    ? (this._line.loadCell(e, t), t)
                    : this._line.loadCell(e, new o.CellData())
              }
              translateToString(e, t, n) {
                return this._line.translateToString(e, t, n)
              }
            }
          },
          8285: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.BufferNamespaceApi = void 0)
            const o = n(8771),
              i = n(8460),
              r = n(844)
            class a extends r.Disposable {
              static {
                __name(this, 'o')
              }
              constructor(e) {
                super(),
                  (this._core = e),
                  (this._onBufferChange = this.register(new i.EventEmitter())),
                  (this.onBufferChange = this._onBufferChange.event),
                  (this._normal = new o.BufferApiView(
                    this._core.buffers.normal,
                    'normal'
                  )),
                  (this._alternate = new o.BufferApiView(
                    this._core.buffers.alt,
                    'alternate'
                  )),
                  this._core.buffers.onBufferActivate(() =>
                    this._onBufferChange.fire(this.active)
                  )
              }
              get active() {
                if (this._core.buffers.active === this._core.buffers.normal)
                  return this.normal
                if (this._core.buffers.active === this._core.buffers.alt)
                  return this.alternate
                throw new Error('Active buffer is neither normal nor alternate')
              }
              get normal() {
                return this._normal.init(this._core.buffers.normal)
              }
              get alternate() {
                return this._alternate.init(this._core.buffers.alt)
              }
            }
            t.BufferNamespaceApi = a
          },
          7975: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ParserApi = void 0),
              (t.ParserApi = class {
                constructor(e) {
                  this._core = e
                }
                registerCsiHandler(e, t) {
                  return this._core.registerCsiHandler(e, (e) => t(e.toArray()))
                }
                addCsiHandler(e, t) {
                  return this.registerCsiHandler(e, t)
                }
                registerDcsHandler(e, t) {
                  return this._core.registerDcsHandler(e, (e, n) =>
                    t(e, n.toArray())
                  )
                }
                addDcsHandler(e, t) {
                  return this.registerDcsHandler(e, t)
                }
                registerEscHandler(e, t) {
                  return this._core.registerEscHandler(e, t)
                }
                addEscHandler(e, t) {
                  return this.registerEscHandler(e, t)
                }
                registerOscHandler(e, t) {
                  return this._core.registerOscHandler(e, t)
                }
                addOscHandler(e, t) {
                  return this.registerOscHandler(e, t)
                }
              })
          },
          7090: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.UnicodeApi = void 0),
              (t.UnicodeApi = class {
                constructor(e) {
                  this._core = e
                }
                register(e) {
                  this._core.unicodeService.register(e)
                }
                get versions() {
                  return this._core.unicodeService.versions
                }
                get activeVersion() {
                  return this._core.unicodeService.activeVersion
                }
                set activeVersion(e) {
                  this._core.unicodeService.activeVersion = e
                }
              })
          },
          744: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.BufferService = t.MINIMUM_ROWS = t.MINIMUM_COLS = void 0)
            const r = n(8460),
              a = n(844),
              s = n(5295),
              l = n(2585)
            ;(t.MINIMUM_COLS = 2), (t.MINIMUM_ROWS = 1)
            let c = (t.BufferService = class extends a.Disposable {
              get buffer() {
                return this.buffers.active
              }
              constructor(e) {
                super(),
                  (this.isUserScrolling = !1),
                  (this._onResize = this.register(new r.EventEmitter())),
                  (this.onResize = this._onResize.event),
                  (this._onScroll = this.register(new r.EventEmitter())),
                  (this.onScroll = this._onScroll.event),
                  (this.cols = Math.max(
                    e.rawOptions.cols || 0,
                    t.MINIMUM_COLS
                  )),
                  (this.rows = Math.max(
                    e.rawOptions.rows || 0,
                    t.MINIMUM_ROWS
                  )),
                  (this.buffers = this.register(new s.BufferSet(e, this)))
              }
              resize(e, t) {
                ;(this.cols = e),
                  (this.rows = t),
                  this.buffers.resize(e, t),
                  this._onResize.fire({ cols: e, rows: t })
              }
              reset() {
                this.buffers.reset(), (this.isUserScrolling = !1)
              }
              scroll(e, t = !1) {
                const n = this.buffer
                let o
                ;(o = this._cachedBlankLine),
                  (o &&
                    o.length === this.cols &&
                    o.getFg(0) === e.fg &&
                    o.getBg(0) === e.bg) ||
                    ((o = n.getBlankLine(e, t)), (this._cachedBlankLine = o)),
                  (o.isWrapped = t)
                const i = n.ybase + n.scrollTop,
                  r = n.ybase + n.scrollBottom
                if (0 === n.scrollTop) {
                  const e = n.lines.isFull
                  r === n.lines.length - 1
                    ? e
                      ? n.lines.recycle().copyFrom(o)
                      : n.lines.push(o.clone())
                    : n.lines.splice(r + 1, 0, o.clone()),
                    e
                      ? this.isUserScrolling &&
                        (n.ydisp = Math.max(n.ydisp - 1, 0))
                      : (n.ybase++, this.isUserScrolling || n.ydisp++)
                } else {
                  const e = r - i + 1
                  n.lines.shiftElements(i + 1, e - 1, -1),
                    n.lines.set(r, o.clone())
                }
                this.isUserScrolling || (n.ydisp = n.ybase),
                  this._onScroll.fire(n.ydisp)
              }
              scrollLines(e, t, n) {
                const o = this.buffer
                if (e < 0) {
                  if (0 === o.ydisp) return
                  this.isUserScrolling = !0
                } else e + o.ydisp >= o.ybase && (this.isUserScrolling = !1)
                const i = o.ydisp
                ;(o.ydisp = Math.max(Math.min(o.ydisp + e, o.ybase), 0)),
                  i !== o.ydisp && (t || this._onScroll.fire(o.ydisp))
              }
            })
            t.BufferService = c = o([i(0, l.IOptionsService)], c)
          },
          7994: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.CharsetService = void 0),
              (t.CharsetService = class {
                constructor() {
                  ;(this.glevel = 0), (this._charsets = [])
                }
                reset() {
                  ;(this.charset = void 0),
                    (this._charsets = []),
                    (this.glevel = 0)
                }
                setgLevel(e) {
                  ;(this.glevel = e), (this.charset = this._charsets[e])
                }
                setgCharset(e, t) {
                  ;(this._charsets[e] = t),
                    this.glevel === e && (this.charset = t)
                }
              })
          },
          1753: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.CoreMouseService = void 0)
            const r = n(2585),
              a = n(8460),
              s = n(844),
              l = {
                NONE: { events: 0, restrict: __name(() => !1, 'restrict') },
                X10: {
                  events: 1,
                  restrict: __name(
                    (e) =>
                      4 !== e.button &&
                      1 === e.action &&
                      ((e.ctrl = !1), (e.alt = !1), (e.shift = !1), !0),
                    'restrict'
                  )
                },
                VT200: {
                  events: 19,
                  restrict: __name((e) => 32 !== e.action, 'restrict')
                },
                DRAG: {
                  events: 23,
                  restrict: __name(
                    (e) => 32 !== e.action || 3 !== e.button,
                    'restrict'
                  )
                },
                ANY: { events: 31, restrict: __name((e) => !0, 'restrict') }
              }
            function c(e, t) {
              let n = (e.ctrl ? 16 : 0) | (e.shift ? 4 : 0) | (e.alt ? 8 : 0)
              return (
                4 === e.button
                  ? ((n |= 64), (n |= e.action))
                  : ((n |= 3 & e.button),
                    4 & e.button && (n |= 64),
                    8 & e.button && (n |= 128),
                    32 === e.action
                      ? (n |= 32)
                      : 0 !== e.action || t || (n |= 3)),
                n
              )
            }
            __name(c, 'c')
            const d = String.fromCharCode,
              u = {
                DEFAULT: __name((e) => {
                  const t = [c(e, !1) + 32, e.col + 32, e.row + 32]
                  return t[0] > 255 || t[1] > 255 || t[2] > 255
                    ? ''
                    : `[M${d(t[0])}${d(t[1])}${d(t[2])}`
                }, 'DEFAULT'),
                SGR: __name((e) => {
                  const t = 0 === e.action && 4 !== e.button ? 'm' : 'M'
                  return `[<${c(e, !0)};${e.col};${e.row}${t}`
                }, 'SGR'),
                SGR_PIXELS: __name((e) => {
                  const t = 0 === e.action && 4 !== e.button ? 'm' : 'M'
                  return `[<${c(e, !0)};${e.x};${e.y}${t}`
                }, 'SGR_PIXELS')
              }
            let p = (t.CoreMouseService = class extends s.Disposable {
              constructor(e, t) {
                super(),
                  (this._bufferService = e),
                  (this._coreService = t),
                  (this._protocols = {}),
                  (this._encodings = {}),
                  (this._activeProtocol = ''),
                  (this._activeEncoding = ''),
                  (this._lastEvent = null),
                  (this._onProtocolChange = this.register(
                    new a.EventEmitter()
                  )),
                  (this.onProtocolChange = this._onProtocolChange.event)
                for (const n of Object.keys(l)) this.addProtocol(n, l[n])
                for (const n of Object.keys(u)) this.addEncoding(n, u[n])
                this.reset()
              }
              addProtocol(e, t) {
                this._protocols[e] = t
              }
              addEncoding(e, t) {
                this._encodings[e] = t
              }
              get activeProtocol() {
                return this._activeProtocol
              }
              get areMouseEventsActive() {
                return 0 !== this._protocols[this._activeProtocol].events
              }
              set activeProtocol(e) {
                if (!this._protocols[e])
                  throw new Error(`unknown protocol "${e}"`)
                ;(this._activeProtocol = e),
                  this._onProtocolChange.fire(this._protocols[e].events)
              }
              get activeEncoding() {
                return this._activeEncoding
              }
              set activeEncoding(e) {
                if (!this._encodings[e])
                  throw new Error(`unknown encoding "${e}"`)
                this._activeEncoding = e
              }
              reset() {
                ;(this.activeProtocol = 'NONE'),
                  (this.activeEncoding = 'DEFAULT'),
                  (this._lastEvent = null)
              }
              triggerMouseEvent(e) {
                if (
                  e.col < 0 ||
                  e.col >= this._bufferService.cols ||
                  e.row < 0 ||
                  e.row >= this._bufferService.rows
                )
                  return !1
                if (4 === e.button && 32 === e.action) return !1
                if (3 === e.button && 32 !== e.action) return !1
                if (4 !== e.button && (2 === e.action || 3 === e.action))
                  return !1
                if (
                  (e.col++,
                  e.row++,
                  32 === e.action &&
                    this._lastEvent &&
                    this._equalEvents(
                      this._lastEvent,
                      e,
                      'SGR_PIXELS' === this._activeEncoding
                    ))
                )
                  return !1
                if (!this._protocols[this._activeProtocol].restrict(e))
                  return !1
                const t = this._encodings[this._activeEncoding](e)
                return (
                  t &&
                    ('DEFAULT' === this._activeEncoding
                      ? this._coreService.triggerBinaryEvent(t)
                      : this._coreService.triggerDataEvent(t, !0)),
                  (this._lastEvent = e),
                  !0
                )
              }
              explainEvents(e) {
                return {
                  down: !!(1 & e),
                  up: !!(2 & e),
                  drag: !!(4 & e),
                  move: !!(8 & e),
                  wheel: !!(16 & e)
                }
              }
              _equalEvents(e, t, n) {
                if (n) {
                  if (e.x !== t.x) return !1
                  if (e.y !== t.y) return !1
                } else {
                  if (e.col !== t.col) return !1
                  if (e.row !== t.row) return !1
                }
                return (
                  e.button === t.button &&
                  e.action === t.action &&
                  e.ctrl === t.ctrl &&
                  e.alt === t.alt &&
                  e.shift === t.shift
                )
              }
            })
            t.CoreMouseService = p = o(
              [i(0, r.IBufferService), i(1, r.ICoreService)],
              p
            )
          },
          6975: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.CoreService = void 0)
            const r = n(1439),
              a = n(8460),
              s = n(844),
              l = n(2585),
              c = Object.freeze({ insertMode: !1 }),
              d = Object.freeze({
                applicationCursorKeys: !1,
                applicationKeypad: !1,
                bracketedPasteMode: !1,
                origin: !1,
                reverseWraparound: !1,
                sendFocus: !1,
                wraparound: !0
              })
            let u = (t.CoreService = class extends s.Disposable {
              constructor(e, t, n) {
                super(),
                  (this._bufferService = e),
                  (this._logService = t),
                  (this._optionsService = n),
                  (this.isCursorInitialized = !1),
                  (this.isCursorHidden = !1),
                  (this._onData = this.register(new a.EventEmitter())),
                  (this.onData = this._onData.event),
                  (this._onUserInput = this.register(new a.EventEmitter())),
                  (this.onUserInput = this._onUserInput.event),
                  (this._onBinary = this.register(new a.EventEmitter())),
                  (this.onBinary = this._onBinary.event),
                  (this._onRequestScrollToBottom = this.register(
                    new a.EventEmitter()
                  )),
                  (this.onRequestScrollToBottom =
                    this._onRequestScrollToBottom.event),
                  (this.modes = (0, r.clone)(c)),
                  (this.decPrivateModes = (0, r.clone)(d))
              }
              reset() {
                ;(this.modes = (0, r.clone)(c)),
                  (this.decPrivateModes = (0, r.clone)(d))
              }
              triggerDataEvent(e, t = !1) {
                if (this._optionsService.rawOptions.disableStdin) return
                const n = this._bufferService.buffer
                t &&
                  this._optionsService.rawOptions.scrollOnUserInput &&
                  n.ybase !== n.ydisp &&
                  this._onRequestScrollToBottom.fire(),
                  t && this._onUserInput.fire(),
                  this._logService.debug(`sending data "${e}"`, () =>
                    e.split('').map((e) => e.charCodeAt(0))
                  ),
                  this._onData.fire(e)
              }
              triggerBinaryEvent(e) {
                this._optionsService.rawOptions.disableStdin ||
                  (this._logService.debug(`sending binary "${e}"`, () =>
                    e.split('').map((e) => e.charCodeAt(0))
                  ),
                  this._onBinary.fire(e))
              }
            })
            t.CoreService = u = o(
              [
                i(0, l.IBufferService),
                i(1, l.ILogService),
                i(2, l.IOptionsService)
              ],
              u
            )
          },
          9074: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.DecorationService = void 0)
            const o = n(8055),
              i = n(8460),
              r = n(844),
              a = n(6106)
            let s = 0,
              l = 0
            class c extends r.Disposable {
              static {
                __name(this, 'c')
              }
              get decorations() {
                return this._decorations.values()
              }
              constructor() {
                super(),
                  (this._decorations = new a.SortedList((e) => e?.marker.line)),
                  (this._onDecorationRegistered = this.register(
                    new i.EventEmitter()
                  )),
                  (this.onDecorationRegistered =
                    this._onDecorationRegistered.event),
                  (this._onDecorationRemoved = this.register(
                    new i.EventEmitter()
                  )),
                  (this.onDecorationRemoved = this._onDecorationRemoved.event),
                  this.register((0, r.toDisposable)(() => this.reset()))
              }
              registerDecoration(e) {
                if (e.marker.isDisposed) return
                const t = new d(e)
                if (t) {
                  const e = t.marker.onDispose(() => t.dispose())
                  t.onDispose(() => {
                    t &&
                      (this._decorations.delete(t) &&
                        this._onDecorationRemoved.fire(t),
                      e.dispose())
                  }),
                    this._decorations.insert(t),
                    this._onDecorationRegistered.fire(t)
                }
                return t
              }
              reset() {
                for (const e of this._decorations.values()) e.dispose()
                this._decorations.clear()
              }
              *getDecorationsAtCell(e, t, n) {
                let o = 0,
                  i = 0
                for (const r of this._decorations.getKeyIterator(t))
                  (o = r.options.x ?? 0),
                    (i = o + (r.options.width ?? 1)),
                    e >= o &&
                      e < i &&
                      (!n || (r.options.layer ?? 'bottom') === n) &&
                      (yield r)
              }
              forEachDecorationAtCell(e, t, n, o) {
                this._decorations.forEachByKey(t, (t) => {
                  ;(s = t.options.x ?? 0),
                    (l = s + (t.options.width ?? 1)),
                    e >= s &&
                      e < l &&
                      (!n || (t.options.layer ?? 'bottom') === n) &&
                      o(t)
                })
              }
            }
            t.DecorationService = c
            class d extends r.Disposable {
              static {
                __name(this, 'l')
              }
              get isDisposed() {
                return this._isDisposed
              }
              get backgroundColorRGB() {
                return (
                  null === this._cachedBg &&
                    (this.options.backgroundColor
                      ? (this._cachedBg = o.css.toColor(
                          this.options.backgroundColor
                        ))
                      : (this._cachedBg = void 0)),
                  this._cachedBg
                )
              }
              get foregroundColorRGB() {
                return (
                  null === this._cachedFg &&
                    (this.options.foregroundColor
                      ? (this._cachedFg = o.css.toColor(
                          this.options.foregroundColor
                        ))
                      : (this._cachedFg = void 0)),
                  this._cachedFg
                )
              }
              constructor(e) {
                super(),
                  (this.options = e),
                  (this.onRenderEmitter = this.register(new i.EventEmitter())),
                  (this.onRender = this.onRenderEmitter.event),
                  (this._onDispose = this.register(new i.EventEmitter())),
                  (this.onDispose = this._onDispose.event),
                  (this._cachedBg = null),
                  (this._cachedFg = null),
                  (this.marker = e.marker),
                  this.options.overviewRulerOptions &&
                    !this.options.overviewRulerOptions.position &&
                    (this.options.overviewRulerOptions.position = 'full')
              }
              dispose() {
                this._onDispose.fire(), super.dispose()
              }
            }
          },
          4348: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.InstantiationService = t.ServiceCollection = void 0)
            const o = n(2585),
              i = n(8343)
            class r {
              static {
                __name(this, 'n')
              }
              constructor(...e) {
                this._entries = new Map()
                for (const [t, n] of e) this.set(t, n)
              }
              set(e, t) {
                const n = this._entries.get(e)
                return this._entries.set(e, t), n
              }
              forEach(e) {
                for (const [t, n] of this._entries.entries()) e(t, n)
              }
              has(e) {
                return this._entries.has(e)
              }
              get(e) {
                return this._entries.get(e)
              }
            }
            ;(t.ServiceCollection = r),
              (t.InstantiationService = class {
                constructor() {
                  ;(this._services = new r()),
                    this._services.set(o.IInstantiationService, this)
                }
                setService(e, t) {
                  this._services.set(e, t)
                }
                getService(e) {
                  return this._services.get(e)
                }
                createInstance(e, ...t) {
                  const n = (0, i.getServiceDependencies)(e).sort(
                      (e, t) => e.index - t.index
                    ),
                    o = []
                  for (const i of n) {
                    const t = this._services.get(i.id)
                    if (!t)
                      throw new Error(
                        `[createInstance] ${e.name} depends on UNKNOWN service ${i.id}.`
                      )
                    o.push(t)
                  }
                  const r = n.length > 0 ? n[0].index : t.length
                  if (t.length !== r)
                    throw new Error(
                      `[createInstance] First service dependency of ${e.name} at position ${r + 1} conflicts with ${t.length} static arguments`
                    )
                  return new e(...[...t, ...o])
                }
              })
          },
          7866: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.traceCall = t.setTraceLogger = t.LogService = void 0)
            const r = n(844),
              a = n(2585),
              s = {
                trace: a.LogLevelEnum.TRACE,
                debug: a.LogLevelEnum.DEBUG,
                info: a.LogLevelEnum.INFO,
                warn: a.LogLevelEnum.WARN,
                error: a.LogLevelEnum.ERROR,
                off: a.LogLevelEnum.OFF
              }
            let l,
              c = (t.LogService = class extends r.Disposable {
                get logLevel() {
                  return this._logLevel
                }
                constructor(e) {
                  super(),
                    (this._optionsService = e),
                    (this._logLevel = a.LogLevelEnum.OFF),
                    this._updateLogLevel(),
                    this.register(
                      this._optionsService.onSpecificOptionChange(
                        'logLevel',
                        () => this._updateLogLevel()
                      )
                    ),
                    (l = this)
                }
                _updateLogLevel() {
                  this._logLevel = s[this._optionsService.rawOptions.logLevel]
                }
                _evalLazyOptionalParams(e) {
                  for (let t = 0; t < e.length; t++)
                    'function' == typeof e[t] && (e[t] = e[t]())
                }
                _log(e, t, n) {
                  this._evalLazyOptionalParams(n),
                    e.call(
                      console,
                      (this._optionsService.options.logger
                        ? ''
                        : 'xterm.js: ') + t,
                      ...n
                    )
                }
                trace(e, ...t) {
                  this._logLevel <= a.LogLevelEnum.TRACE &&
                    this._log(
                      this._optionsService.options.logger?.trace.bind(
                        this._optionsService.options.logger
                      ) ?? console.log,
                      e,
                      t
                    )
                }
                debug(e, ...t) {
                  this._logLevel <= a.LogLevelEnum.DEBUG &&
                    this._log(
                      this._optionsService.options.logger?.debug.bind(
                        this._optionsService.options.logger
                      ) ?? console.log,
                      e,
                      t
                    )
                }
                info(e, ...t) {
                  this._logLevel <= a.LogLevelEnum.INFO &&
                    this._log(
                      this._optionsService.options.logger?.info.bind(
                        this._optionsService.options.logger
                      ) ?? console.info,
                      e,
                      t
                    )
                }
                warn(e, ...t) {
                  this._logLevel <= a.LogLevelEnum.WARN &&
                    this._log(
                      this._optionsService.options.logger?.warn.bind(
                        this._optionsService.options.logger
                      ) ?? console.warn,
                      e,
                      t
                    )
                }
                error(e, ...t) {
                  this._logLevel <= a.LogLevelEnum.ERROR &&
                    this._log(
                      this._optionsService.options.logger?.error.bind(
                        this._optionsService.options.logger
                      ) ?? console.error,
                      e,
                      t
                    )
                }
              })
            ;(t.LogService = c = o([i(0, a.IOptionsService)], c)),
              (t.setTraceLogger = function (e) {
                l = e
              }),
              (t.traceCall = function (e, t, n) {
                if ('function' != typeof n.value)
                  throw new Error('not supported')
                const o = n.value
                n.value = function (...e) {
                  if (l.logLevel !== a.LogLevelEnum.TRACE)
                    return o.apply(this, e)
                  l.trace(
                    `GlyphRenderer#${o.name}(${e.map((e) => JSON.stringify(e)).join(', ')})`
                  )
                  const t = o.apply(this, e)
                  return l.trace(`GlyphRenderer#${o.name} return`, t), t
                }
              })
          },
          7302: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.OptionsService = t.DEFAULT_OPTIONS = void 0)
            const o = n(8460),
              i = n(844),
              r = n(6114)
            t.DEFAULT_OPTIONS = {
              cols: 80,
              rows: 24,
              cursorBlink: !1,
              cursorStyle: 'block',
              cursorWidth: 1,
              cursorInactiveStyle: 'outline',
              customGlyphs: !0,
              drawBoldTextInBrightColors: !0,
              documentOverride: null,
              fastScrollModifier: 'alt',
              fastScrollSensitivity: 5,
              fontFamily: 'courier-new, courier, monospace',
              fontSize: 15,
              fontWeight: 'normal',
              fontWeightBold: 'bold',
              ignoreBracketedPasteMode: !1,
              lineHeight: 1,
              letterSpacing: 0,
              linkHandler: null,
              logLevel: 'info',
              logger: null,
              scrollback: 1e3,
              scrollOnUserInput: !0,
              scrollSensitivity: 1,
              screenReaderMode: !1,
              smoothScrollDuration: 0,
              macOptionIsMeta: !1,
              macOptionClickForcesSelection: !1,
              minimumContrastRatio: 1,
              disableStdin: !1,
              allowProposedApi: !1,
              allowTransparency: !1,
              tabStopWidth: 8,
              theme: {},
              rescaleOverlappingGlyphs: !1,
              rightClickSelectsWord: r.isMac,
              windowOptions: {},
              windowsMode: !1,
              windowsPty: {},
              wordSeparator: ' ()[]{}\',"`',
              altClickMovesCursor: !0,
              convertEol: !1,
              termName: 'xterm',
              cancelEvents: !1,
              overviewRulerWidth: 0
            }
            const a = [
              'normal',
              'bold',
              '100',
              '200',
              '300',
              '400',
              '500',
              '600',
              '700',
              '800',
              '900'
            ]
            class s extends i.Disposable {
              static {
                __name(this, 'a')
              }
              constructor(e) {
                super(),
                  (this._onOptionChange = this.register(new o.EventEmitter())),
                  (this.onOptionChange = this._onOptionChange.event)
                const n = { ...t.DEFAULT_OPTIONS }
                for (const t in e)
                  if (t in n)
                    try {
                      const o = e[t]
                      n[t] = this._sanitizeAndValidateOption(t, o)
                    } catch (r) {
                      console.error(r)
                    }
                ;(this.rawOptions = n),
                  (this.options = { ...n }),
                  this._setupOptions(),
                  this.register(
                    (0, i.toDisposable)(() => {
                      ;(this.rawOptions.linkHandler = null),
                        (this.rawOptions.documentOverride = null)
                    })
                  )
              }
              onSpecificOptionChange(e, t) {
                return this.onOptionChange((n) => {
                  n === e && t(this.rawOptions[e])
                })
              }
              onMultipleOptionChange(e, t) {
                return this.onOptionChange((n) => {
                  ;-1 !== e.indexOf(n) && t()
                })
              }
              _setupOptions() {
                const e = __name((e) => {
                    if (!(e in t.DEFAULT_OPTIONS))
                      throw new Error(`No option with key "${e}"`)
                    return this.rawOptions[e]
                  }, 'e'),
                  n = __name((e, n) => {
                    if (!(e in t.DEFAULT_OPTIONS))
                      throw new Error(`No option with key "${e}"`)
                    ;(n = this._sanitizeAndValidateOption(e, n)),
                      this.rawOptions[e] !== n &&
                        ((this.rawOptions[e] = n), this._onOptionChange.fire(e))
                  }, 'i')
                for (const t in this.rawOptions) {
                  const o = { get: e.bind(this, t), set: n.bind(this, t) }
                  Object.defineProperty(this.options, t, o)
                }
              }
              _sanitizeAndValidateOption(e, n) {
                switch (e) {
                  case 'cursorStyle':
                    if (
                      (n || (n = t.DEFAULT_OPTIONS[e]),
                      !(function (e) {
                        return 'block' === e || 'underline' === e || 'bar' === e
                      })(n))
                    )
                      throw new Error(`"${n}" is not a valid value for ${e}`)
                    break
                  case 'wordSeparator':
                    n || (n = t.DEFAULT_OPTIONS[e])
                    break
                  case 'fontWeight':
                  case 'fontWeightBold':
                    if ('number' == typeof n && 1 <= n && n <= 1e3) break
                    n = a.includes(n) ? n : t.DEFAULT_OPTIONS[e]
                    break
                  case 'cursorWidth':
                    n = Math.floor(n)
                  case 'lineHeight':
                  case 'tabStopWidth':
                    if (n < 1)
                      throw new Error(`${e} cannot be less than 1, value: ${n}`)
                    break
                  case 'minimumContrastRatio':
                    n = Math.max(1, Math.min(21, Math.round(10 * n) / 10))
                    break
                  case 'scrollback':
                    if ((n = Math.min(n, 4294967295)) < 0)
                      throw new Error(`${e} cannot be less than 0, value: ${n}`)
                    break
                  case 'fastScrollSensitivity':
                  case 'scrollSensitivity':
                    if (n <= 0)
                      throw new Error(
                        `${e} cannot be less than or equal to 0, value: ${n}`
                      )
                    break
                  case 'rows':
                  case 'cols':
                    if (!n && 0 !== n)
                      throw new Error(`${e} must be numeric, value: ${n}`)
                    break
                  case 'windowsPty':
                    n = n ?? {}
                }
                return n
              }
            }
            t.OptionsService = s
          },
          2660: function (e, t, n) {
            var o =
                (this && this.__decorate) ||
                function (e, t, n, o) {
                  var i,
                    r = arguments.length,
                    a =
                      r < 3
                        ? t
                        : null === o
                          ? (o = Object.getOwnPropertyDescriptor(t, n))
                          : o
                  if (
                    'object' == typeof Reflect &&
                    'function' == typeof Reflect.decorate
                  )
                    a = Reflect.decorate(e, t, n, o)
                  else
                    for (var s = e.length - 1; s >= 0; s--)
                      (i = e[s]) &&
                        (a = (r < 3 ? i(a) : r > 3 ? i(t, n, a) : i(t, n)) || a)
                  return r > 3 && a && Object.defineProperty(t, n, a), a
                },
              i =
                (this && this.__param) ||
                function (e, t) {
                  return function (n, o) {
                    t(n, o, e)
                  }
                }
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.OscLinkService = void 0)
            const r = n(2585)
            let a = (t.OscLinkService = class {
              constructor(e) {
                ;(this._bufferService = e),
                  (this._nextId = 1),
                  (this._entriesWithId = new Map()),
                  (this._dataByLinkId = new Map())
              }
              registerLink(e) {
                const t = this._bufferService.buffer
                if (void 0 === e.id) {
                  const n = t.addMarker(t.ybase + t.y),
                    o = { data: e, id: this._nextId++, lines: [n] }
                  return (
                    n.onDispose(() => this._removeMarkerFromLink(o, n)),
                    this._dataByLinkId.set(o.id, o),
                    o.id
                  )
                }
                const n = e,
                  o = this._getEntryIdKey(n),
                  i = this._entriesWithId.get(o)
                if (i) return this.addLineToLink(i.id, t.ybase + t.y), i.id
                const r = t.addMarker(t.ybase + t.y),
                  a = {
                    id: this._nextId++,
                    key: this._getEntryIdKey(n),
                    data: n,
                    lines: [r]
                  }
                return (
                  r.onDispose(() => this._removeMarkerFromLink(a, r)),
                  this._entriesWithId.set(a.key, a),
                  this._dataByLinkId.set(a.id, a),
                  a.id
                )
              }
              addLineToLink(e, t) {
                const n = this._dataByLinkId.get(e)
                if (n && n.lines.every((e) => e.line !== t)) {
                  const e = this._bufferService.buffer.addMarker(t)
                  n.lines.push(e),
                    e.onDispose(() => this._removeMarkerFromLink(n, e))
                }
              }
              getLinkData(e) {
                return this._dataByLinkId.get(e)?.data
              }
              _getEntryIdKey(e) {
                return `${e.id};;${e.uri}`
              }
              _removeMarkerFromLink(e, t) {
                const n = e.lines.indexOf(t)
                ;-1 !== n &&
                  (e.lines.splice(n, 1),
                  0 === e.lines.length &&
                    (void 0 !== e.data.id && this._entriesWithId.delete(e.key),
                    this._dataByLinkId.delete(e.id)))
              }
            })
            t.OscLinkService = a = o([i(0, r.IBufferService)], a)
          },
          8343: (e, t) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.createDecorator =
                t.getServiceDependencies =
                t.serviceRegistry =
                  void 0)
            const n = 'di$target',
              o = 'di$dependencies'
            ;(t.serviceRegistry = new Map()),
              (t.getServiceDependencies = function (e) {
                return e[o] || []
              }),
              (t.createDecorator = function (e) {
                if (t.serviceRegistry.has(e)) return t.serviceRegistry.get(e)
                const i = __name(function (e, t, r) {
                  if (3 !== arguments.length)
                    throw new Error(
                      '@IServiceName-decorator can only be used to decorate a parameter'
                    )
                  var a, s, l
                  ;(a = i),
                    (l = r),
                    (s = e)[n] === s
                      ? s[o].push({ id: a, index: l })
                      : ((s[o] = [{ id: a, index: l }]), (s[n] = s))
                }, 'r')
                return (i.toString = () => e), t.serviceRegistry.set(e, i), i
              })
          },
          2585: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.IDecorationService =
                t.IUnicodeService =
                t.IOscLinkService =
                t.IOptionsService =
                t.ILogService =
                t.LogLevelEnum =
                t.IInstantiationService =
                t.ICharsetService =
                t.ICoreService =
                t.ICoreMouseService =
                t.IBufferService =
                  void 0)
            const o = n(8343)
            var i, r
            ;(t.IBufferService = (0, o.createDecorator)('BufferService')),
              (t.ICoreMouseService = (0, o.createDecorator)(
                'CoreMouseService'
              )),
              (t.ICoreService = (0, o.createDecorator)('CoreService')),
              (t.ICharsetService = (0, o.createDecorator)('CharsetService')),
              (t.IInstantiationService = (0, o.createDecorator)(
                'InstantiationService'
              )),
              ((r = i || (t.LogLevelEnum = i = {}))[(r.TRACE = 0)] = 'TRACE'),
              (r[(r.DEBUG = 1)] = 'DEBUG'),
              (r[(r.INFO = 2)] = 'INFO'),
              (r[(r.WARN = 3)] = 'WARN'),
              (r[(r.ERROR = 4)] = 'ERROR'),
              (r[(r.OFF = 5)] = 'OFF'),
              (t.ILogService = (0, o.createDecorator)('LogService')),
              (t.IOptionsService = (0, o.createDecorator)('OptionsService')),
              (t.IOscLinkService = (0, o.createDecorator)('OscLinkService')),
              (t.IUnicodeService = (0, o.createDecorator)('UnicodeService')),
              (t.IDecorationService = (0, o.createDecorator)(
                'DecorationService'
              ))
          },
          1480: (e, t, n) => {
            Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.UnicodeService = void 0)
            const o = n(8460),
              i = n(225)
            class r {
              static {
                __name(this, 'n')
              }
              static extractShouldJoin(e) {
                return !!(1 & e)
              }
              static extractWidth(e) {
                return (e >> 1) & 3
              }
              static extractCharKind(e) {
                return e >> 3
              }
              static createPropertyValue(e, t, n = !1) {
                return ((16777215 & e) << 3) | ((3 & t) << 1) | (n ? 1 : 0)
              }
              constructor() {
                ;(this._providers = Object.create(null)),
                  (this._active = ''),
                  (this._onChange = new o.EventEmitter()),
                  (this.onChange = this._onChange.event)
                const e = new i.UnicodeV6()
                this.register(e),
                  (this._active = e.version),
                  (this._activeProvider = e)
              }
              dispose() {
                this._onChange.dispose()
              }
              get versions() {
                return Object.keys(this._providers)
              }
              get activeVersion() {
                return this._active
              }
              set activeVersion(e) {
                if (!this._providers[e])
                  throw new Error(`unknown Unicode version "${e}"`)
                ;(this._active = e),
                  (this._activeProvider = this._providers[e]),
                  this._onChange.fire(e)
              }
              register(e) {
                this._providers[e.version] = e
              }
              wcwidth(e) {
                return this._activeProvider.wcwidth(e)
              }
              getStringCellWidth(e) {
                let t = 0,
                  n = 0
                const o = e.length
                for (let i = 0; i < o; ++i) {
                  let a = e.charCodeAt(i)
                  if (55296 <= a && a <= 56319) {
                    if (++i >= o) return t + this.wcwidth(a)
                    const n = e.charCodeAt(i)
                    56320 <= n && n <= 57343
                      ? (a = 1024 * (a - 55296) + n - 56320 + 65536)
                      : (t += this.wcwidth(n))
                  }
                  const s = this.charProperties(a, n)
                  let l = r.extractWidth(s)
                  r.extractShouldJoin(s) && (l -= r.extractWidth(n)),
                    (t += l),
                    (n = s)
                }
                return t
              }
              charProperties(e, t) {
                return this._activeProvider.charProperties(e, t)
              }
            }
            t.UnicodeService = r
          }
        },
        t = {}
      function n(o) {
        var i = t[o]
        if (void 0 !== i) return i.exports
        var r = (t[o] = { exports: {} })
        return e[o].call(r.exports, r, r.exports, n), r.exports
      }
      __name(n, 'i')
      var o = {}
      return (
        (() => {
          var e = o
          Object.defineProperty(e, '__esModule', { value: !0 }),
            (e.Terminal = void 0)
          const t = n(9042),
            i = n(3236),
            r = n(844),
            a = n(5741),
            s = n(8285),
            l = n(7975),
            c = n(7090),
            d = ['cols', 'rows']
          class u extends r.Disposable {
            static {
              __name(this, 'd')
            }
            constructor(e) {
              super(),
                (this._core = this.register(new i.Terminal(e))),
                (this._addonManager = this.register(new a.AddonManager())),
                (this._publicOptions = { ...this._core.options })
              const t = __name((e) => this._core.options[e], 't'),
                n = __name((e, t) => {
                  this._checkReadonlyOptions(e), (this._core.options[e] = t)
                }, 'i')
              for (const o in this._core.options) {
                const e = { get: t.bind(this, o), set: n.bind(this, o) }
                Object.defineProperty(this._publicOptions, o, e)
              }
            }
            _checkReadonlyOptions(e) {
              if (d.includes(e))
                throw new Error(
                  `Option "${e}" can only be set in the constructor`
                )
            }
            _checkProposedApi() {
              if (!this._core.optionsService.rawOptions.allowProposedApi)
                throw new Error(
                  'You must set the allowProposedApi option to true to use proposed API'
                )
            }
            get onBell() {
              return this._core.onBell
            }
            get onBinary() {
              return this._core.onBinary
            }
            get onCursorMove() {
              return this._core.onCursorMove
            }
            get onData() {
              return this._core.onData
            }
            get onKey() {
              return this._core.onKey
            }
            get onLineFeed() {
              return this._core.onLineFeed
            }
            get onRender() {
              return this._core.onRender
            }
            get onResize() {
              return this._core.onResize
            }
            get onScroll() {
              return this._core.onScroll
            }
            get onSelectionChange() {
              return this._core.onSelectionChange
            }
            get onTitleChange() {
              return this._core.onTitleChange
            }
            get onWriteParsed() {
              return this._core.onWriteParsed
            }
            get element() {
              return this._core.element
            }
            get parser() {
              return (
                this._parser || (this._parser = new l.ParserApi(this._core)),
                this._parser
              )
            }
            get unicode() {
              return this._checkProposedApi(), new c.UnicodeApi(this._core)
            }
            get textarea() {
              return this._core.textarea
            }
            get rows() {
              return this._core.rows
            }
            get cols() {
              return this._core.cols
            }
            get buffer() {
              return (
                this._buffer ||
                  (this._buffer = this.register(
                    new s.BufferNamespaceApi(this._core)
                  )),
                this._buffer
              )
            }
            get markers() {
              return this._checkProposedApi(), this._core.markers
            }
            get modes() {
              const e = this._core.coreService.decPrivateModes
              let t = 'none'
              switch (this._core.coreMouseService.activeProtocol) {
                case 'X10':
                  t = 'x10'
                  break
                case 'VT200':
                  t = 'vt200'
                  break
                case 'DRAG':
                  t = 'drag'
                  break
                case 'ANY':
                  t = 'any'
              }
              return {
                applicationCursorKeysMode: e.applicationCursorKeys,
                applicationKeypadMode: e.applicationKeypad,
                bracketedPasteMode: e.bracketedPasteMode,
                insertMode: this._core.coreService.modes.insertMode,
                mouseTrackingMode: t,
                originMode: e.origin,
                reverseWraparoundMode: e.reverseWraparound,
                sendFocusMode: e.sendFocus,
                wraparoundMode: e.wraparound
              }
            }
            get options() {
              return this._publicOptions
            }
            set options(e) {
              for (const t in e) this._publicOptions[t] = e[t]
            }
            blur() {
              this._core.blur()
            }
            focus() {
              this._core.focus()
            }
            input(e, t = !0) {
              this._core.input(e, t)
            }
            resize(e, t) {
              this._verifyIntegers(e, t), this._core.resize(e, t)
            }
            open(e) {
              this._core.open(e)
            }
            attachCustomKeyEventHandler(e) {
              this._core.attachCustomKeyEventHandler(e)
            }
            attachCustomWheelEventHandler(e) {
              this._core.attachCustomWheelEventHandler(e)
            }
            registerLinkProvider(e) {
              return this._core.registerLinkProvider(e)
            }
            registerCharacterJoiner(e) {
              return (
                this._checkProposedApi(), this._core.registerCharacterJoiner(e)
              )
            }
            deregisterCharacterJoiner(e) {
              this._checkProposedApi(), this._core.deregisterCharacterJoiner(e)
            }
            registerMarker(e = 0) {
              return this._verifyIntegers(e), this._core.registerMarker(e)
            }
            registerDecoration(e) {
              return (
                this._checkProposedApi(),
                this._verifyPositiveIntegers(
                  e.x ?? 0,
                  e.width ?? 0,
                  e.height ?? 0
                ),
                this._core.registerDecoration(e)
              )
            }
            hasSelection() {
              return this._core.hasSelection()
            }
            select(e, t, n) {
              this._verifyIntegers(e, t, n), this._core.select(e, t, n)
            }
            getSelection() {
              return this._core.getSelection()
            }
            getSelectionPosition() {
              return this._core.getSelectionPosition()
            }
            clearSelection() {
              this._core.clearSelection()
            }
            selectAll() {
              this._core.selectAll()
            }
            selectLines(e, t) {
              this._verifyIntegers(e, t), this._core.selectLines(e, t)
            }
            dispose() {
              super.dispose()
            }
            scrollLines(e) {
              this._verifyIntegers(e), this._core.scrollLines(e)
            }
            scrollPages(e) {
              this._verifyIntegers(e), this._core.scrollPages(e)
            }
            scrollToTop() {
              this._core.scrollToTop()
            }
            scrollToBottom() {
              this._core.scrollToBottom()
            }
            scrollToLine(e) {
              this._verifyIntegers(e), this._core.scrollToLine(e)
            }
            clear() {
              this._core.clear()
            }
            write(e, t) {
              this._core.write(e, t)
            }
            writeln(e, t) {
              this._core.write(e), this._core.write('\r\n', t)
            }
            paste(e) {
              this._core.paste(e)
            }
            refresh(e, t) {
              this._verifyIntegers(e, t), this._core.refresh(e, t)
            }
            reset() {
              this._core.reset()
            }
            clearTextureAtlas() {
              this._core.clearTextureAtlas()
            }
            loadAddon(e) {
              this._addonManager.loadAddon(this, e)
            }
            static get strings() {
              return t
            }
            _verifyIntegers(...e) {
              for (const t of e)
                if (t === 1 / 0 || isNaN(t) || t % 1 != 0)
                  throw new Error('This API only accepts integers')
            }
            _verifyPositiveIntegers(...e) {
              for (const t of e)
                if (t && (t === 1 / 0 || isNaN(t) || t % 1 != 0 || t < 0))
                  throw new Error('This API only accepts positive integers')
            }
          }
          e.Terminal = u
        })(),
        o
      )
    })()
  )
})(xterm$2, xterm$2.exports)
var xtermExports = xterm$2.exports
const xterm$1 = getDefaultExportFromCjs(xtermExports)
function useTerminal(e) {
  const t = new addonFitExports.FitAddon(),
    n = Vue.markRaw(new xtermExports.Terminal({ convertEol: !0 }))
  return (
    n.loadAddon(t),
    n.attachCustomKeyEventHandler(
      (e) =>
        'keydown' !== e.type ||
        (!e.ctrlKey && !e.metaKey) ||
        ('c' !== e.key && 'v' !== e.key)
    ),
    Vue.onMounted(async () => {
      n.open(e.value)
    }),
    Vue.onUnmounted(() => {
      n.dispose()
    }),
    {
      terminal: n,
      useAutoSize(e, o = !0, i = !0, r) {
        const a = __name(
            (t) => (null == t || isNaN(t) ? e.value?.clientHeight / 20 : t),
            'ensureValidRows'
          ),
          s = __name(
            (t) => (null == t || isNaN(t) ? e.value?.clientWidth / 8 : t),
            'ensureValidCols'
          ),
          l = __name(() => {
            const e = t.proposeDimensions()
            n.resize(i ? s(e?.cols) : n.cols, o ? a(e?.rows) : n.rows), r?.()
          }, 'resize'),
          c = new ResizeObserver(_.debounce(l, 25))
        return (
          Vue.onMounted(async () => {
            c.observe(e.value), l()
          }),
          Vue.onUnmounted(() => {
            c.disconnect()
          }),
          { resize: l }
        )
      }
    }
  )
}
__name(useTerminal, 'useTerminal')
const _hoisted_1$K = { class: 'p-terminal rounded-none h-full w-full p-2' },
  _sfc_main$H = Vue.defineComponent({
    __name: 'BaseTerminal',
    emits: ['created'],
    setup(e, { emit: t }) {
      const n = t,
        o = Vue.ref(),
        i = Vue.ref()
      return (
        n('created', useTerminal(o), i),
        (e, t) => (
          Vue.openBlock(),
          Vue.createElementBlock(
            'div',
            {
              class: 'relative overflow-hidden h-full w-full bg-black',
              ref_key: 'rootEl',
              ref: i
            },
            [
              Vue.createElementVNode('div', _hoisted_1$K, [
                Vue.createElementVNode(
                  'div',
                  {
                    class: 'h-full terminal-host',
                    ref_key: 'terminalEl',
                    ref: o
                  },
                  null,
                  512
                )
              ])
            ],
            512
          )
        )
      )
    }
  }),
  BaseTerminal = _export_sfc(_sfc_main$H, [['__scopeId', 'data-v-4f7907e3']])
var theme$i = __name(function (e) {
    var t = e.dt
    return '\n.p-progressspinner {\n    position: relative;\n    margin: 0 auto;\n    width: 100px;\n    height: 100px;\n    display: inline-block;\n}\n\n.p-progressspinner::before {\n    content: "";\n    display: block;\n    padding-top: 100%;\n}\n\n.p-progressspinner-spin {\n    height: 100%;\n    transform-origin: center center;\n    width: 100%;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    margin: auto;\n    animation: p-progressspinner-rotate 2s linear infinite;\n}\n\n.p-progressspinner-circle {\n    stroke-dasharray: 89, 200;\n    stroke-dashoffset: 0;\n    stroke: '
      .concat(
        t('progressspinner.color.1'),
        ';\n    animation: p-progressspinner-dash 1.5s ease-in-out infinite, p-progressspinner-color 6s ease-in-out infinite;\n    stroke-linecap: round;\n}\n\n@keyframes p-progressspinner-rotate {\n    100% {\n        transform: rotate(360deg);\n    }\n}\n@keyframes p-progressspinner-dash {\n    0% {\n        stroke-dasharray: 1, 200;\n        stroke-dashoffset: 0;\n    }\n    50% {\n        stroke-dasharray: 89, 200;\n        stroke-dashoffset: -35px;\n    }\n    100% {\n        stroke-dasharray: 89, 200;\n        stroke-dashoffset: -124px;\n    }\n}\n@keyframes p-progressspinner-color {\n    100%,\n    0% {\n        stroke: '
      )
      .concat(
        t('progressspinner.color.1'),
        ';\n    }\n    40% {\n        stroke: '
      )
      .concat(
        t('progressspinner.color.2'),
        ';\n    }\n    66% {\n        stroke: '
      )
      .concat(
        t('progressspinner.color.3'),
        ';\n    }\n    80%,\n    90% {\n        stroke: '
      )
      .concat(t('progressspinner.color.4'), ';\n    }\n}\n')
  }, 'theme'),
  classes$i = {
    root: 'p-progressspinner',
    spin: 'p-progressspinner-spin',
    circle: 'p-progressspinner-circle'
  },
  ProgressSpinnerStyle = BaseStyle.extend({
    name: 'progressspinner',
    theme: theme$i,
    classes: classes$i
  }),
  script$1$h = {
    name: 'BaseProgressSpinner',
    extends: script$Y,
    props: {
      strokeWidth: { type: String, default: '2' },
      fill: { type: String, default: 'none' },
      animationDuration: { type: String, default: '2s' }
    },
    style: ProgressSpinnerStyle,
    provide: __name(function () {
      return { $pcProgressSpinner: this, $parentInstance: this }
    }, 'provide')
  },
  script$r = {
    name: 'ProgressSpinner',
    extends: script$1$h,
    inheritAttrs: !1,
    computed: {
      svgStyle: __name(function () {
        return { 'animation-duration': this.animationDuration }
      }, 'svgStyle')
    }
  },
  _hoisted_1$J = ['fill', 'stroke-width']
function render$q(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps(
        { class: e.cx('root'), role: 'progressbar' },
        e.ptmi('root')
      ),
      [
        (Vue.openBlock(),
        Vue.createElementBlock(
          'svg',
          Vue.mergeProps(
            { class: e.cx('spin'), viewBox: '25 25 50 50', style: r.svgStyle },
            e.ptm('spin')
          ),
          [
            Vue.createElementVNode(
              'circle',
              Vue.mergeProps(
                {
                  class: e.cx('circle'),
                  cx: '50',
                  cy: '50',
                  r: '20',
                  fill: e.fill,
                  'stroke-width': e.strokeWidth,
                  strokeMiterlimit: '10'
                },
                e.ptm('circle')
              ),
              null,
              16,
              _hoisted_1$J
            )
          ],
          16
        ))
      ],
      16
    )
  )
}
__name(render$q, 'render$q'), (script$r.render = render$q)
const _hoisted_1$I = { class: 'bg-black h-full w-full' },
  _hoisted_2$s = { key: 0, class: 'p-4 text-center' },
  _sfc_main$G = Vue.defineComponent({
    __name: 'LogsTerminal',
    setup(e) {
      const t = Vue.ref(''),
        n = Vue.ref(!0),
        o = __name(({ terminal: e, useAutoSize: o }, i) => {
          o(i, !0, !1)
          const r = __name((t, n) => {
              n && e.resize(n.cols, e.rows), e.write(t.map((e) => e.m).join(''))
            }, 'update'),
            a = __name((e) => {
              r(e.detail.entries, e.detail.size)
            }, 'logReceived'),
            s = __name(async () => {
              const e = await api.getRawLogs()
              r(e.entries, e.size)
            }, 'loadLogEntries'),
            l = __name(async () => {
              const { clientId: e } = storeToRefs(useExecutionStore())
              e.value || (await until(e).not.toBeNull()),
                api.subscribeLogs(!0),
                api.addEventListener('logs', a)
            }, 'watchLogs')
          Vue.onMounted(async () => {
            try {
              await s()
            } catch (e) {
              return (
                console.error('Error loading logs', e),
                void (t.value =
                  'Unable to load logs, please ensure you have updated your ComfyUI backend.')
              )
            }
            await l(), (n.value = !1)
          }),
            Vue.onUnmounted(() => {
              api.clientId && api.subscribeLogs(!1),
                api.removeEventListener('logs', a)
            })
        }, 'terminalCreated')
      return (e, i) => (
        Vue.openBlock(),
        Vue.createElementBlock('div', _hoisted_1$I, [
          t.value
            ? (Vue.openBlock(),
              Vue.createElementBlock(
                'p',
                _hoisted_2$s,
                Vue.toDisplayString(t.value),
                1
              ))
            : n.value
              ? (Vue.openBlock(),
                Vue.createBlock(Vue.unref(script$r), {
                  key: 1,
                  class:
                    'relative inset-0 flex justify-center items-center h-full z-10'
                }))
              : Vue.createCommentVNode('', !0),
          Vue.withDirectives(
            Vue.createVNode(BaseTerminal, { onCreated: o }, null, 512),
            [[Vue.vShow, !n.value]]
          )
        ])
      )
    }
  }),
  LogsTerminal = _export_sfc(_sfc_main$G, [['__scopeId', 'data-v-b7201572']]),
  _sfc_main$F = Vue.defineComponent({
    __name: 'CommandTerminal',
    setup(e) {
      const t = __name(({ terminal: e, useAutoSize: t }, n) => {
        const o = electronAPI().Terminal
        let i, r
        t(n, !0, !0, () => {
          e.element?.offsetParent && o.resize(e.cols, e.rows)
        }),
          Vue.onMounted(async () => {
            ;(i = e.onData(async (e) => {
              o.write(e)
            })),
              (r = o.onOutput((t) => {
                e.write(t)
              }))
            const t = await o.restore()
            setTimeout(() => {
              t.buffer.length &&
                (e.resize(t.size.cols, t.size.rows), e.write(t.buffer.join('')))
            }, 500)
          }),
          Vue.onUnmounted(() => {
            i?.dispose(), r?.()
          })
      }, 'terminalCreated')
      return (e, n) => (
        Vue.openBlock(), Vue.createBlock(BaseTerminal, { onCreated: t })
      )
    }
  }),
  CommandTerminal = _export_sfc(_sfc_main$F, [
    ['__scopeId', 'data-v-36dec989']
  ]),
  useLogsTerminalTab = __name(() => {
    const { t: e } = VueI18n.useI18n()
    return {
      id: 'logs-terminal',
      title: e('logs'),
      component: Vue.markRaw(LogsTerminal),
      type: 'vue'
    }
  }, 'useLogsTerminalTab'),
  useCommandTerminalTab = __name(() => {
    const { t: e } = VueI18n.useI18n()
    return {
      id: 'command-terminal',
      title: e('terminal'),
      component: Vue.markRaw(CommandTerminal),
      type: 'vue'
    }
  }, 'useCommandTerminalTab'),
  useBottomPanelStore = defineStore('bottomPanel', () => {
    const e = Vue.ref(!1),
      t = __name(() => {
        0 !== n.value.length && (e.value = !e.value)
      }, 'toggleBottomPanel'),
      n = Vue.ref([]),
      o = Vue.ref(null),
      i = Vue.computed(() => n.value.find((e) => e.id === o.value) ?? null),
      r = __name((e) => {
        o.value = e
      }, 'setActiveTab'),
      a = __name((t) => {
        o.value === t && e.value
          ? (e.value = !1)
          : ((o.value = t), (e.value = !0))
      }, 'toggleBottomPanelTab'),
      s = __name((e) => {
        ;(n.value = [...n.value, e]),
          1 === n.value.length && (o.value = e.id),
          useCommandStore().registerCommand({
            id: `Workspace.ToggleBottomPanelTab.${e.id}`,
            icon: 'pi pi-list',
            label: e.title,
            function: __name(() => a(e.id), 'function')
          })
      }, 'registerBottomPanelTab'),
      l = __name(() => {
        s(useLogsTerminalTab()), isElectron() && s(useCommandTerminalTab())
      }, 'registerCoreBottomPanelTabs')
    return {
      bottomPanelVisible: e,
      toggleBottomPanel: t,
      bottomPanelTabs: n,
      activeBottomPanelTab: i,
      activeBottomPanelTabId: o,
      setActiveTab: r,
      toggleBottomPanelTab: a,
      registerBottomPanelTab: s,
      registerCoreBottomPanelTabs: l,
      registerExtensionBottomPanelTabs: __name((e) => {
        e.bottomPanelTabs && e.bottomPanelTabs.forEach(s)
      }, 'registerExtensionBottomPanelTabs')
    }
  }),
  useWidgetStore = defineStore('widget', () => {
    const e = ComfyWidgets,
      t = Vue.ref({}),
      n = Vue.computed(() => ({ ...t.value, ...e }))
    function o(e, t) {
      return 'COMBO' === e
        ? 'COMBO'
        : `${e}:${t}` in n.value
          ? `${e}:${t}`
          : e in n.value
            ? e
            : null
    }
    function i(e) {
      return null !== o(e.type, e.name)
    }
    function r(e) {
      t.value = { ...t.value, ...e }
    }
    return (
      __name(o, 'getWidgetType'),
      __name(i, 'inputIsWidget'),
      __name(r, 'registerCustomWidgets'),
      {
        widgets: n,
        getWidgetType: o,
        inputIsWidget: i,
        registerCustomWidgets: r
      }
    )
  }),
  useExtensionStore = defineStore('extension', () => {
    const e = Vue.ref({}),
      t = Vue.computed(() => Object.values(e.value)),
      n = Vue.ref(new Set()),
      o = Vue.computed(() =>
        Array.from(n.value).filter((t) => !(t in e.value))
      ),
      i = __name((e) => !n.value.has(e), 'isExtensionEnabled'),
      r = Vue.computed(() => t.value.filter((e) => i(e.name)))
    function a(t) {
      if (!t.name) throw new Error("Extensions must have a 'name' property.")
      if (e.value[t.name])
        throw new Error(`Extension named '${t.name}' already registered.`)
      n.value.has(t.name) && console.log(`Extension ${t.name} is disabled.`),
        (e.value[t.name] = Vue.markRaw(t)),
        useKeybindingStore().loadExtensionKeybindings(t),
        useCommandStore().loadExtensionCommands(t),
        useMenuItemStore().loadExtensionMenuCommands(t),
        useSettingStore().loadExtensionSettings(t),
        useBottomPanelStore().registerExtensionBottomPanelTabs(t),
        t.getCustomWidgets &&
          (async () => {
            if (t.getCustomWidgets) {
              const e = await t.getCustomWidgets(app$1)
              useWidgetStore().registerCustomWidgets(e)
            }
          })(),
        app$1.extensions.push(t)
    }
    function s() {
      ;(n.value = new Set(useSettingStore().get('Comfy.Extension.Disabled'))),
        n.value.add('pysssss.Locking'),
        n.value.add('pysssss.SnapToGrid')
    }
    __name(a, 'registerExtension'), __name(s, 'loadDisabledExtensionNames')
    for (const l of app$1.extensions) e.value[l.name] = Vue.markRaw(l)
    return {
      extensions: t,
      enabledExtensions: r,
      inactiveDisabledExtensionNames: o,
      isExtensionEnabled: i,
      registerExtension: a,
      loadDisabledExtensionNames: s
    }
  }),
  useAboutPanelStore = defineStore('aboutPanel', () => {
    const e = useExtensionStore(),
      t = useSystemStatsStore(),
      n = Vue.computed(() => t?.systemStats?.system?.comfyui_version ?? ''),
      o = Vue.computed(() => [
        {
          label: `ComfyUI ${isElectron() ? 'v' + electronAPI().getComfyUIVersion() : n.value}`,
          url: 'https://github.com/comfyanonymous/ComfyUI',
          icon: 'pi pi-github'
        },
        {
          label: 'ComfyUI_frontend v1.5.8',
          url: 'https://github.com/Comfy-Org/ComfyUI_frontend',
          icon: 'pi pi-github'
        },
        {
          label: 'Discord',
          url: 'https://www.comfy.org/discord',
          icon: 'pi pi-discord'
        },
        {
          label: 'ComfyOrg',
          url: 'https://www.comfy.org/',
          icon: 'pi pi-globe'
        }
      ])
    return {
      badges: Vue.computed(() => [
        ...o.value,
        ...e.extensions.flatMap((e) => e.aboutPageBadges ?? [])
      ])
    }
  })
var script$q = { name: 'ChevronLeftIcon', extends: script$X }
function render$p(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              d: 'M9.61296 13C9.50997 13.0005 9.40792 12.9804 9.3128 12.9409C9.21767 12.9014 9.13139 12.8433 9.05902 12.7701L3.83313 7.54416C3.68634 7.39718 3.60388 7.19795 3.60388 6.99022C3.60388 6.78249 3.68634 6.58325 3.83313 6.43628L9.05902 1.21039C9.20762 1.07192 9.40416 0.996539 9.60724 1.00012C9.81032 1.00371 10.0041 1.08597 10.1477 1.22959C10.2913 1.37322 10.3736 1.56698 10.3772 1.77005C10.3808 1.97313 10.3054 2.16968 10.1669 2.31827L5.49496 6.99022L10.1669 11.6622C10.3137 11.8091 10.3962 12.0084 10.3962 12.2161C10.3962 12.4238 10.3137 12.6231 10.1669 12.7701C10.0945 12.8433 10.0083 12.9014 9.91313 12.9409C9.81801 12.9804 9.71596 13.0005 9.61296 13Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$p, 'render$p'), (script$q.render = render$p)
var script$p = { name: 'ChevronRightIcon', extends: script$X }
function render$o(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              d: 'M4.38708 13C4.28408 13.0005 4.18203 12.9804 4.08691 12.9409C3.99178 12.9014 3.9055 12.8433 3.83313 12.7701C3.68634 12.6231 3.60388 12.4238 3.60388 12.2161C3.60388 12.0084 3.68634 11.8091 3.83313 11.6622L8.50507 6.99022L3.83313 2.31827C3.69467 2.16968 3.61928 1.97313 3.62287 1.77005C3.62645 1.56698 3.70872 1.37322 3.85234 1.22959C3.99596 1.08597 4.18972 1.00371 4.3928 1.00012C4.59588 0.996539 4.79242 1.07192 4.94102 1.21039L10.1669 6.43628C10.3137 6.58325 10.3962 6.78249 10.3962 6.99022C10.3962 7.19795 10.3137 7.39718 10.1669 7.54416L4.94102 12.7701C4.86865 12.8433 4.78237 12.9014 4.68724 12.9409C4.59212 12.9804 4.49007 13.0005 4.38708 13Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$o, 'render$o'), (script$p.render = render$o)
var theme$h = __name(function (e) {
    var t = e.dt
    return '\n.p-tabview-tablist-container {\n    position: relative;\n}\n\n.p-tabview-scrollable > .p-tabview-tablist-container {\n    overflow: hidden;\n}\n\n.p-tabview-tablist-scroll-container {\n    overflow-x: auto;\n    overflow-y: hidden;\n    scroll-behavior: smooth;\n    scrollbar-width: none;\n    overscroll-behavior: contain auto;\n}\n\n.p-tabview-tablist-scroll-container::-webkit-scrollbar {\n    display: none;\n}\n\n.p-tabview-tablist {\n    display: flex;\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    flex: 1 1 auto;\n    background: '
      .concat(t('tabview.tab.list.background'), ';\n    border: 1px solid ')
      .concat(
        t('tabview.tab.list.border.color'),
        ';\n    border-width: 0 0 1px 0;\n    position: relative;\n}\n\n.p-tabview-tab-header {\n    cursor: pointer;\n    user-select: none;\n    display: flex;\n    align-items: center;\n    text-decoration: none;\n    position: relative;\n    overflow: hidden;\n    border-style: solid;\n    border-width: 0 0 1px 0;\n    border-color: transparent transparent '
      )
      .concat(t('tabview.tab.border.color'), ' transparent;\n    color: ')
      .concat(
        t('tabview.tab.color'),
        ';\n    padding: 1rem 1.125rem;\n    font-weight: 600;\n    border-top-right-radius: '
      )
      .concat(t('border.radius.md'), ';\n    border-top-left-radius: ')
      .concat(t('border.radius.md'), ';\n    transition: color ')
      .concat(t('tabview.transition.duration'), ', outline-color ')
      .concat(
        t('tabview.transition.duration'),
        ';\n    margin: 0 0 -1px 0;\n    outline-color: transparent;\n}\n\n.p-tabview-tablist-item:not(.p-disabled) .p-tabview-tab-header:focus-visible {\n    outline: '
      )
      .concat(t('focus.ring.width'), ' ')
      .concat(t('focus.ring.style'), ' ')
      .concat(
        t('focus.ring.color'),
        ';\n    outline-offset: -1px;\n}\n\n.p-tabview-tablist-item:not(.p-highlight):not(.p-disabled):hover > .p-tabview-tab-header {\n    color: '
      )
      .concat(
        t('tabview.tab.hover.color'),
        ';\n}\n\n.p-tabview-tablist-item.p-highlight > .p-tabview-tab-header {\n    color: '
      )
      .concat(
        t('tabview.tab.active.color'),
        ';\n}\n\n.p-tabview-tab-title {\n    line-height: 1;\n    white-space: nowrap;\n}\n\n.p-tabview-next-button,\n.p-tabview-prev-button {\n    position: absolute;\n    top: 0;\n    margin: 0;\n    padding: 0;\n    z-index: 2;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: '
      )
      .concat(t('tabview.nav.button.background'), ';\n    color: ')
      .concat(
        t('tabview.nav.button.color'),
        ';\n    width: 2.5rem;\n    border-radius: 0;\n    outline-color: transparent;\n    transition: color '
      )
      .concat(t('tabview.transition.duration'), ', outline-color ')
      .concat(t('tabview.transition.duration'), ';\n    box-shadow: ')
      .concat(
        t('tabview.nav.button.shadow'),
        ';\n    border: none;\n    cursor: pointer;\n    user-select: none;\n}\n\n.p-tabview-next-button:focus-visible,\n.p-tabview-prev-button:focus-visible {\n    outline: '
      )
      .concat(t('focus.ring.width'), ' ')
      .concat(t('focus.ring.style'), ' ')
      .concat(t('focus.ring.color'), ';\n    outline-offset: ')
      .concat(
        t('focus.ring.offset'),
        ';\n}\n\n.p-tabview-next-button:hover,\n.p-tabview-prev-button:hover {\n    color: '
      )
      .concat(
        t('tabview.nav.button.hover.color'),
        ';\n}\n\n.p-tabview-prev-button {\n    left: 0;\n}\n\n.p-tabview-next-button {\n    right: 0;\n}\n\n.p-tabview-panels {\n    background: '
      )
      .concat(t('tabview.tab.panel.background'), ';\n    color: ')
      .concat(
        t('tabview.tab.panel.color'),
        ';\n    padding: 0.875rem 1.125rem 1.125rem 1.125rem;\n}\n\n.p-tabview-ink-bar {\n    z-index: 1;\n    display: block;\n    position: absolute;\n    bottom: -1px;\n    height: 1px;\n    background: '
      )
      .concat(
        t('tabview.tab.active.border.color'),
        ';\n    transition: 250ms cubic-bezier(0.35, 0, 0.25, 1);\n}\n'
      )
  }, 'theme'),
  classes$h = {
    root: __name(function (e) {
      return [
        'p-tabview p-component',
        { 'p-tabview-scrollable': e.props.scrollable }
      ]
    }, 'root'),
    navContainer: 'p-tabview-tablist-container',
    prevButton: 'p-tabview-prev-button',
    navContent: 'p-tabview-tablist-scroll-container',
    nav: 'p-tabview-tablist',
    tab: {
      header: __name(function (e) {
        var t = e.instance,
          n = e.tab,
          o = e.index
        return [
          'p-tabview-tablist-item',
          t.getTabProp(n, 'headerClass'),
          {
            'p-tabview-tablist-item-active': t.d_activeIndex === o,
            'p-disabled': t.getTabProp(n, 'disabled')
          }
        ]
      }, 'header'),
      headerAction: 'p-tabview-tab-header',
      headerTitle: 'p-tabview-tab-title',
      content: __name(function (e) {
        var t = e.instance,
          n = e.tab
        return ['p-tabview-panel', t.getTabProp(n, 'contentClass')]
      }, 'content')
    },
    inkbar: 'p-tabview-ink-bar',
    nextButton: 'p-tabview-next-button',
    panelContainer: 'p-tabview-panels'
  },
  TabViewStyle = BaseStyle.extend({
    name: 'tabview',
    theme: theme$h,
    classes: classes$h
  }),
  script$1$g = {
    name: 'BaseTabView',
    extends: script$Y,
    props: {
      activeIndex: { type: Number, default: 0 },
      lazy: { type: Boolean, default: !1 },
      scrollable: { type: Boolean, default: !1 },
      tabindex: { type: Number, default: 0 },
      selectOnFocus: { type: Boolean, default: !1 },
      prevButtonProps: { type: null, default: null },
      nextButtonProps: { type: null, default: null },
      prevIcon: { type: String, default: void 0 },
      nextIcon: { type: String, default: void 0 }
    },
    style: TabViewStyle,
    provide: __name(function () {
      return { $pcTabs: void 0, $pcTabView: this, $parentInstance: this }
    }, 'provide')
  },
  script$o = {
    name: 'TabView',
    extends: script$1$g,
    inheritAttrs: !1,
    emits: ['update:activeIndex', 'tab-change', 'tab-click'],
    data: __name(function () {
      return {
        id: this.$attrs.id,
        d_activeIndex: this.activeIndex,
        isPrevButtonDisabled: !0,
        isNextButtonDisabled: !1
      }
    }, 'data'),
    watch: {
      '$attrs.id': __name(function (e) {
        this.id = e || UniqueComponentId()
      }, '$attrsId'),
      activeIndex: __name(function (e) {
        ;(this.d_activeIndex = e), this.scrollInView({ index: e })
      }, 'activeIndex')
    },
    mounted: __name(function () {
      console.warn('Deprecated since v4. Use Tabs component instead.'),
        (this.id = this.id || UniqueComponentId()),
        this.updateInkBar(),
        this.scrollable && this.updateButtonState()
    }, 'mounted'),
    updated: __name(function () {
      this.updateInkBar(), this.scrollable && this.updateButtonState()
    }, 'updated'),
    methods: {
      isTabPanel: __name(function (e) {
        return 'TabPanel' === e.type.name
      }, 'isTabPanel'),
      isTabActive: __name(function (e) {
        return this.d_activeIndex === e
      }, 'isTabActive'),
      getTabProp: __name(function (e, t) {
        return e.props ? e.props[t] : void 0
      }, 'getTabProp'),
      getKey: __name(function (e, t) {
        return this.getTabProp(e, 'header') || t
      }, 'getKey'),
      getTabHeaderActionId: __name(function (e) {
        return ''.concat(this.id, '_').concat(e, '_header_action')
      }, 'getTabHeaderActionId'),
      getTabContentId: __name(function (e) {
        return ''.concat(this.id, '_').concat(e, '_content')
      }, 'getTabContentId'),
      getTabPT: __name(function (e, t, n) {
        var o = this.tabs.length,
          i = {
            props: e.props,
            parent: { instance: this, props: this.$props, state: this.$data },
            context: {
              index: n,
              count: o,
              first: 0 === n,
              last: n === o - 1,
              active: this.isTabActive(n)
            }
          }
        return Vue.mergeProps(
          this.ptm('tabpanel.'.concat(t), { tabpanel: i }),
          this.ptm('tabpanel.'.concat(t), i),
          this.ptmo(this.getTabProp(e, 'pt'), t, i)
        )
      }, 'getTabPT'),
      onScroll: __name(function (e) {
        this.scrollable && this.updateButtonState(), e.preventDefault()
      }, 'onScroll'),
      onPrevButtonClick: __name(function () {
        var e = this.$refs.content,
          t = getWidth(e),
          n = e.scrollLeft - t
        e.scrollLeft = n <= 0 ? 0 : n
      }, 'onPrevButtonClick'),
      onNextButtonClick: __name(function () {
        var e = this.$refs.content,
          t = getWidth(e) - this.getVisibleButtonWidths(),
          n = e.scrollLeft + t,
          o = e.scrollWidth - t
        e.scrollLeft = n >= o ? o : n
      }, 'onNextButtonClick'),
      onTabClick: __name(function (e, t, n) {
        this.changeActiveIndex(e, t, n),
          this.$emit('tab-click', { originalEvent: e, index: n })
      }, 'onTabClick'),
      onTabKeyDown: __name(function (e, t, n) {
        switch (e.code) {
          case 'ArrowLeft':
            this.onTabArrowLeftKey(e)
            break
          case 'ArrowRight':
            this.onTabArrowRightKey(e)
            break
          case 'Home':
            this.onTabHomeKey(e)
            break
          case 'End':
            this.onTabEndKey(e)
            break
          case 'PageDown':
            this.onPageDownKey(e)
            break
          case 'PageUp':
            this.onPageUpKey(e)
            break
          case 'Enter':
          case 'NumpadEnter':
          case 'Space':
            this.onTabEnterKey(e, t, n)
        }
      }, 'onTabKeyDown'),
      onTabArrowRightKey: __name(function (e) {
        var t = this.findNextHeaderAction(e.target.parentElement)
        t ? this.changeFocusedTab(e, t) : this.onTabHomeKey(e),
          e.preventDefault()
      }, 'onTabArrowRightKey'),
      onTabArrowLeftKey: __name(function (e) {
        var t = this.findPrevHeaderAction(e.target.parentElement)
        t ? this.changeFocusedTab(e, t) : this.onTabEndKey(e),
          e.preventDefault()
      }, 'onTabArrowLeftKey'),
      onTabHomeKey: __name(function (e) {
        var t = this.findFirstHeaderAction()
        this.changeFocusedTab(e, t), e.preventDefault()
      }, 'onTabHomeKey'),
      onTabEndKey: __name(function (e) {
        var t = this.findLastHeaderAction()
        this.changeFocusedTab(e, t), e.preventDefault()
      }, 'onTabEndKey'),
      onPageDownKey: __name(function (e) {
        this.scrollInView({ index: this.$refs.nav.children.length - 2 }),
          e.preventDefault()
      }, 'onPageDownKey'),
      onPageUpKey: __name(function (e) {
        this.scrollInView({ index: 0 }), e.preventDefault()
      }, 'onPageUpKey'),
      onTabEnterKey: __name(function (e, t, n) {
        this.changeActiveIndex(e, t, n), e.preventDefault()
      }, 'onTabEnterKey'),
      findNextHeaderAction: __name(function (e) {
        var t =
          arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
            ? e
            : e.nextElementSibling
        return t
          ? getAttribute(t, 'data-p-disabled') ||
            'inkbar' === getAttribute(t, 'data-pc-section')
            ? this.findNextHeaderAction(t)
            : findSingle(t, '[data-pc-section="headeraction"]')
          : null
      }, 'findNextHeaderAction'),
      findPrevHeaderAction: __name(function (e) {
        var t =
          arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
            ? e
            : e.previousElementSibling
        return t
          ? getAttribute(t, 'data-p-disabled') ||
            'inkbar' === getAttribute(t, 'data-pc-section')
            ? this.findPrevHeaderAction(t)
            : findSingle(t, '[data-pc-section="headeraction"]')
          : null
      }, 'findPrevHeaderAction'),
      findFirstHeaderAction: __name(function () {
        return this.findNextHeaderAction(this.$refs.nav.firstElementChild, !0)
      }, 'findFirstHeaderAction'),
      findLastHeaderAction: __name(function () {
        return this.findPrevHeaderAction(this.$refs.nav.lastElementChild, !0)
      }, 'findLastHeaderAction'),
      changeActiveIndex: __name(function (e, t, n) {
        this.getTabProp(t, 'disabled') ||
          this.d_activeIndex === n ||
          ((this.d_activeIndex = n),
          this.$emit('update:activeIndex', n),
          this.$emit('tab-change', { originalEvent: e, index: n }),
          this.scrollInView({ index: n }))
      }, 'changeActiveIndex'),
      changeFocusedTab: __name(function (e, t) {
        if (
          t &&
          (focus(t), this.scrollInView({ element: t }), this.selectOnFocus)
        ) {
          var n = parseInt(t.parentElement.dataset.pcIndex, 10),
            o = this.tabs[n]
          this.changeActiveIndex(e, o, n)
        }
      }, 'changeFocusedTab'),
      scrollInView: __name(function (e) {
        var t = e.element,
          n = e.index,
          o = void 0 === n ? -1 : n,
          i = t || this.$refs.nav.children[o]
        i && i.scrollIntoView && i.scrollIntoView({ block: 'nearest' })
      }, 'scrollInView'),
      updateInkBar: __name(function () {
        var e = this.$refs.nav.children[this.d_activeIndex]
        ;(this.$refs.inkbar.style.width = getWidth(e) + 'px'),
          (this.$refs.inkbar.style.left =
            getOffset(e).left - getOffset(this.$refs.nav).left + 'px')
      }, 'updateInkBar'),
      updateButtonState: __name(function () {
        var e = this.$refs.content,
          t = e.scrollLeft,
          n = e.scrollWidth,
          o = getWidth(e)
        ;(this.isPrevButtonDisabled = 0 === t),
          (this.isNextButtonDisabled = parseInt(t) === n - o)
      }, 'updateButtonState'),
      getVisibleButtonWidths: __name(function () {
        var e = this.$refs
        return [e.prevBtn, e.nextBtn].reduce(function (e, t) {
          return t ? e + getWidth(t) : e
        }, 0)
      }, 'getVisibleButtonWidths')
    },
    computed: {
      tabs: __name(function () {
        var e = this
        return this.$slots.default().reduce(function (t, n) {
          return (
            e.isTabPanel(n)
              ? t.push(n)
              : n.children &&
                n.children instanceof Array &&
                n.children.forEach(function (n) {
                  e.isTabPanel(n) && t.push(n)
                }),
            t
          )
        }, [])
      }, 'tabs'),
      prevButtonAriaLabel: __name(function () {
        return this.$primevue.config.locale.aria
          ? this.$primevue.config.locale.aria.previous
          : void 0
      }, 'prevButtonAriaLabel'),
      nextButtonAriaLabel: __name(function () {
        return this.$primevue.config.locale.aria
          ? this.$primevue.config.locale.aria.next
          : void 0
      }, 'nextButtonAriaLabel')
    },
    directives: { ripple: Ripple },
    components: { ChevronLeftIcon: script$q, ChevronRightIcon: script$p }
  }
function _typeof$a(e) {
  return (_typeof$a =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$c(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$c(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$c(Object(n), !0).forEach(function (t) {
          _defineProperty$a(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$c(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$a(e, t, n) {
  return (
    (t = _toPropertyKey$9(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$9(e) {
  var t = _toPrimitive$9(e, 'string')
  return 'symbol' == _typeof$a(t) ? t : t + ''
}
function _toPrimitive$9(e, t) {
  if ('object' != _typeof$a(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$a(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$a, '_typeof$a'),
  __name(ownKeys$c, 'ownKeys$c'),
  __name(_objectSpread$c, '_objectSpread$c'),
  __name(_defineProperty$a, '_defineProperty$a'),
  __name(_toPropertyKey$9, '_toPropertyKey$9'),
  __name(_toPrimitive$9, '_toPrimitive$9')
var _hoisted_1$H = ['tabindex', 'aria-label'],
  _hoisted_2$r = ['data-p-active', 'data-p-disabled', 'data-pc-index'],
  _hoisted_3$h = [
    'id',
    'tabindex',
    'aria-disabled',
    'aria-selected',
    'aria-controls',
    'onClick',
    'onKeydown'
  ],
  _hoisted_4$a = ['tabindex', 'aria-label'],
  _hoisted_5$8 = ['id', 'aria-labelledby', 'data-pc-index', 'data-p-active']
function render$n(e, t, n, o, i, r) {
  var a = Vue.resolveDirective('ripple')
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps({ class: e.cx('root'), role: 'tablist' }, e.ptmi('root')),
      [
        Vue.createElementVNode(
          'div',
          Vue.mergeProps(
            { class: e.cx('navContainer') },
            e.ptm('navContainer')
          ),
          [
            e.scrollable && !i.isPrevButtonDisabled
              ? Vue.withDirectives(
                  (Vue.openBlock(),
                  Vue.createElementBlock(
                    'button',
                    Vue.mergeProps(
                      {
                        key: 0,
                        ref: 'prevBtn',
                        type: 'button',
                        class: e.cx('prevButton'),
                        tabindex: e.tabindex,
                        'aria-label': r.prevButtonAriaLabel,
                        onClick:
                          t[0] ||
                          (t[0] = function () {
                            return (
                              r.onPrevButtonClick &&
                              r.onPrevButtonClick.apply(r, arguments)
                            )
                          })
                      },
                      _objectSpread$c(
                        _objectSpread$c({}, e.prevButtonProps),
                        e.ptm('prevButton')
                      ),
                      { 'data-pc-group-section': 'navbutton' }
                    ),
                    [
                      Vue.renderSlot(e.$slots, 'previcon', {}, function () {
                        return [
                          (Vue.openBlock(),
                          Vue.createBlock(
                            Vue.resolveDynamicComponent(
                              e.prevIcon ? 'span' : 'ChevronLeftIcon'
                            ),
                            Vue.mergeProps(
                              { 'aria-hidden': 'true', class: e.prevIcon },
                              e.ptm('prevIcon')
                            ),
                            null,
                            16,
                            ['class']
                          ))
                        ]
                      })
                    ],
                    16,
                    _hoisted_1$H
                  )),
                  [[a]]
                )
              : Vue.createCommentVNode('', !0),
            Vue.createElementVNode(
              'div',
              Vue.mergeProps(
                {
                  ref: 'content',
                  class: e.cx('navContent'),
                  onScroll:
                    t[1] ||
                    (t[1] = function () {
                      return r.onScroll && r.onScroll.apply(r, arguments)
                    })
                },
                e.ptm('navContent')
              ),
              [
                Vue.createElementVNode(
                  'ul',
                  Vue.mergeProps(
                    { ref: 'nav', class: e.cx('nav') },
                    e.ptm('nav')
                  ),
                  [
                    (Vue.openBlock(!0),
                    Vue.createElementBlock(
                      Vue.Fragment,
                      null,
                      Vue.renderList(r.tabs, function (t, n) {
                        return (
                          Vue.openBlock(),
                          Vue.createElementBlock(
                            'li',
                            Vue.mergeProps(
                              {
                                key: r.getKey(t, n),
                                style: r.getTabProp(t, 'headerStyle'),
                                class: e.cx('tab.header', { tab: t, index: n }),
                                role: 'presentation',
                                ref_for: !0
                              },
                              _objectSpread$c(
                                _objectSpread$c(
                                  _objectSpread$c(
                                    {},
                                    r.getTabProp(t, 'headerProps')
                                  ),
                                  r.getTabPT(t, 'root', n)
                                ),
                                r.getTabPT(t, 'header', n)
                              ),
                              {
                                'data-pc-name': 'tabpanel',
                                'data-p-active': i.d_activeIndex === n,
                                'data-p-disabled': r.getTabProp(t, 'disabled'),
                                'data-pc-index': n
                              }
                            ),
                            [
                              Vue.withDirectives(
                                (Vue.openBlock(),
                                Vue.createElementBlock(
                                  'a',
                                  Vue.mergeProps(
                                    {
                                      id: r.getTabHeaderActionId(n),
                                      class: e.cx('tab.headerAction'),
                                      tabindex:
                                        r.getTabProp(t, 'disabled') ||
                                        !r.isTabActive(n)
                                          ? -1
                                          : e.tabindex,
                                      role: 'tab',
                                      'aria-disabled': r.getTabProp(
                                        t,
                                        'disabled'
                                      ),
                                      'aria-selected': r.isTabActive(n),
                                      'aria-controls': r.getTabContentId(n),
                                      onClick: __name(function (e) {
                                        return r.onTabClick(e, t, n)
                                      }, 'onClick'),
                                      onKeydown: __name(function (e) {
                                        return r.onTabKeyDown(e, t, n)
                                      }, 'onKeydown'),
                                      ref_for: !0
                                    },
                                    _objectSpread$c(
                                      _objectSpread$c(
                                        {},
                                        r.getTabProp(t, 'headerActionProps')
                                      ),
                                      r.getTabPT(t, 'headerAction', n)
                                    )
                                  ),
                                  [
                                    t.props && t.props.header
                                      ? (Vue.openBlock(),
                                        Vue.createElementBlock(
                                          'span',
                                          Vue.mergeProps(
                                            {
                                              key: 0,
                                              class: e.cx('tab.headerTitle'),
                                              ref_for: !0
                                            },
                                            r.getTabPT(t, 'headerTitle', n)
                                          ),
                                          Vue.toDisplayString(t.props.header),
                                          17
                                        ))
                                      : Vue.createCommentVNode('', !0),
                                    t.children && t.children.header
                                      ? (Vue.openBlock(),
                                        Vue.createBlock(
                                          Vue.resolveDynamicComponent(
                                            t.children.header
                                          ),
                                          { key: 1 }
                                        ))
                                      : Vue.createCommentVNode('', !0)
                                  ],
                                  16,
                                  _hoisted_3$h
                                )),
                                [[a]]
                              )
                            ],
                            16,
                            _hoisted_2$r
                          )
                        )
                      }),
                      128
                    )),
                    Vue.createElementVNode(
                      'li',
                      Vue.mergeProps(
                        {
                          ref: 'inkbar',
                          class: e.cx('inkbar'),
                          role: 'presentation',
                          'aria-hidden': 'true'
                        },
                        e.ptm('inkbar')
                      ),
                      null,
                      16
                    )
                  ],
                  16
                )
              ],
              16
            ),
            e.scrollable && !i.isNextButtonDisabled
              ? Vue.withDirectives(
                  (Vue.openBlock(),
                  Vue.createElementBlock(
                    'button',
                    Vue.mergeProps(
                      {
                        key: 1,
                        ref: 'nextBtn',
                        type: 'button',
                        class: e.cx('nextButton'),
                        tabindex: e.tabindex,
                        'aria-label': r.nextButtonAriaLabel,
                        onClick:
                          t[2] ||
                          (t[2] = function () {
                            return (
                              r.onNextButtonClick &&
                              r.onNextButtonClick.apply(r, arguments)
                            )
                          })
                      },
                      _objectSpread$c(
                        _objectSpread$c({}, e.nextButtonProps),
                        e.ptm('nextButton')
                      ),
                      { 'data-pc-group-section': 'navbutton' }
                    ),
                    [
                      Vue.renderSlot(e.$slots, 'nexticon', {}, function () {
                        return [
                          (Vue.openBlock(),
                          Vue.createBlock(
                            Vue.resolveDynamicComponent(
                              e.nextIcon ? 'span' : 'ChevronRightIcon'
                            ),
                            Vue.mergeProps(
                              { 'aria-hidden': 'true', class: e.nextIcon },
                              e.ptm('nextIcon')
                            ),
                            null,
                            16,
                            ['class']
                          ))
                        ]
                      })
                    ],
                    16,
                    _hoisted_4$a
                  )),
                  [[a]]
                )
              : Vue.createCommentVNode('', !0)
          ],
          16
        ),
        Vue.createElementVNode(
          'div',
          Vue.mergeProps(
            { class: e.cx('panelContainer') },
            e.ptm('panelContainer')
          ),
          [
            (Vue.openBlock(!0),
            Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(r.tabs, function (t, n) {
                return (
                  Vue.openBlock(),
                  Vue.createElementBlock(
                    Vue.Fragment,
                    { key: r.getKey(t, n) },
                    [
                      !e.lazy || r.isTabActive(n)
                        ? Vue.withDirectives(
                            (Vue.openBlock(),
                            Vue.createElementBlock(
                              'div',
                              Vue.mergeProps(
                                {
                                  key: 0,
                                  id: r.getTabContentId(n),
                                  style: r.getTabProp(t, 'contentStyle'),
                                  class: e.cx('tab.content', { tab: t }),
                                  role: 'tabpanel',
                                  'aria-labelledby': r.getTabHeaderActionId(n),
                                  ref_for: !0
                                },
                                _objectSpread$c(
                                  _objectSpread$c(
                                    _objectSpread$c(
                                      {},
                                      r.getTabProp(t, 'contentProps')
                                    ),
                                    r.getTabPT(t, 'root', n)
                                  ),
                                  r.getTabPT(t, 'content', n)
                                ),
                                {
                                  'data-pc-name': 'tabpanel',
                                  'data-pc-index': n,
                                  'data-p-active': i.d_activeIndex === n
                                }
                              ),
                              [
                                (Vue.openBlock(),
                                Vue.createBlock(Vue.resolveDynamicComponent(t)))
                              ],
                              16,
                              _hoisted_5$8
                            )),
                            [[Vue.vShow, !!e.lazy || r.isTabActive(n)]]
                          )
                        : Vue.createCommentVNode('', !0)
                    ],
                    64
                  )
                )
              }),
              128
            ))
          ],
          16
        )
      ],
      16
    )
  )
}
__name(render$n, 'render$n'), (script$o.render = render$n)
const _hoisted_1$G = { class: 'grid grid-cols-2 gap-2' },
  _hoisted_2$q = { class: 'font-medium' },
  _sfc_main$E = Vue.defineComponent({
    __name: 'DeviceInfo',
    props: { device: {} },
    setup(e) {
      const t = e,
        n = [
          { field: 'name', header: 'Name' },
          { field: 'type', header: 'Type' },
          { field: 'vram_total', header: 'VRAM Total' },
          { field: 'vram_free', header: 'VRAM Free' },
          { field: 'torch_vram_total', header: 'Torch VRAM Total' },
          { field: 'torch_vram_free', header: 'Torch VRAM Free' }
        ],
        o = __name(
          (e, t) =>
            [
              'vram_total',
              'vram_free',
              'torch_vram_total',
              'torch_vram_free'
            ].includes(t)
              ? formatSize(e)
              : e,
          'formatValue'
        )
      return (e, i) => (
        Vue.openBlock(),
        Vue.createElementBlock('div', _hoisted_1$G, [
          (Vue.openBlock(),
          Vue.createElementBlock(
            Vue.Fragment,
            null,
            Vue.renderList(
              n,
              (e) => (
                Vue.openBlock(),
                Vue.createElementBlock(
                  Vue.Fragment,
                  { key: e.field },
                  [
                    Vue.createElementVNode(
                      'div',
                      _hoisted_2$q,
                      Vue.toDisplayString(e.header),
                      1
                    ),
                    Vue.createElementVNode(
                      'div',
                      null,
                      Vue.toDisplayString(o(t.device[e.field], e.field)),
                      1
                    )
                  ],
                  64
                )
              )
            ),
            64
          ))
        ])
      )
    }
  }),
  _hoisted_1$F = { class: 'system-stats' },
  _hoisted_2$p = { class: 'mb-6' },
  _hoisted_3$g = { class: 'text-2xl font-semibold mb-4' },
  _hoisted_4$9 = { class: 'grid grid-cols-2 gap-2' },
  _hoisted_5$7 = { class: 'font-medium' },
  _hoisted_6$5 = { class: 'text-2xl font-semibold mb-4' },
  _sfc_main$D = Vue.defineComponent({
    __name: 'SystemStatsPanel',
    props: { stats: {} },
    setup(e) {
      const t = e,
        n = Vue.computed(() => ({
          ...t.stats.system,
          argv: t.stats.system.argv.join(' ')
        })),
        o = [
          { field: 'os', header: 'OS' },
          { field: 'python_version', header: 'Python Version' },
          { field: 'embedded_python', header: 'Embedded Python' },
          { field: 'pytorch_version', header: 'Pytorch Version' },
          { field: 'argv', header: 'Arguments' },
          { field: 'ram_total', header: 'RAM Total' },
          { field: 'ram_free', header: 'RAM Free' }
        ],
        i = __name(
          (e, t) => (['ram_total', 'ram_free'].includes(t) ? formatSize(e) : e),
          'formatValue'
        )
      return (e, r) => (
        Vue.openBlock(),
        Vue.createElementBlock('div', _hoisted_1$F, [
          Vue.createElementVNode('div', _hoisted_2$p, [
            Vue.createElementVNode(
              'h2',
              _hoisted_3$g,
              Vue.toDisplayString(e.$t('systemInfo')),
              1
            ),
            Vue.createElementVNode('div', _hoisted_4$9, [
              (Vue.openBlock(),
              Vue.createElementBlock(
                Vue.Fragment,
                null,
                Vue.renderList(
                  o,
                  (e) => (
                    Vue.openBlock(),
                    Vue.createElementBlock(
                      Vue.Fragment,
                      { key: e.field },
                      [
                        Vue.createElementVNode(
                          'div',
                          _hoisted_5$7,
                          Vue.toDisplayString(e.header),
                          1
                        ),
                        Vue.createElementVNode(
                          'div',
                          null,
                          Vue.toDisplayString(i(n.value[e.field], e.field)),
                          1
                        )
                      ],
                      64
                    )
                  )
                ),
                64
              ))
            ])
          ]),
          Vue.createVNode(Vue.unref(script$G)),
          Vue.createElementVNode('div', null, [
            Vue.createElementVNode(
              'h2',
              _hoisted_6$5,
              Vue.toDisplayString(e.$t('devices')),
              1
            ),
            t.stats.devices.length > 1
              ? (Vue.openBlock(),
                Vue.createBlock(
                  Vue.unref(script$o),
                  { key: 0 },
                  {
                    default: Vue.withCtx(() => [
                      (Vue.openBlock(!0),
                      Vue.createElementBlock(
                        Vue.Fragment,
                        null,
                        Vue.renderList(
                          t.stats.devices,
                          (e) => (
                            Vue.openBlock(),
                            Vue.createBlock(
                              Vue.unref(script$s),
                              { key: e.index, header: e.name },
                              {
                                default: Vue.withCtx(() => [
                                  Vue.createVNode(
                                    _sfc_main$E,
                                    { device: e },
                                    null,
                                    8,
                                    ['device']
                                  )
                                ]),
                                _: 2
                              },
                              1032,
                              ['header']
                            )
                          )
                        ),
                        128
                      ))
                    ]),
                    _: 1
                  }
                ))
              : (Vue.openBlock(),
                Vue.createBlock(
                  _sfc_main$E,
                  { key: 1, device: t.stats.devices[0] },
                  null,
                  8,
                  ['device']
                ))
          ])
        ])
      )
    }
  }),
  _hoisted_1$E = { class: 'text-2xl font-bold mb-2' },
  _hoisted_2$o = { class: 'space-y-2' },
  _hoisted_3$f = ['href', 'title'],
  _sfc_main$C = Vue.defineComponent({
    __name: 'AboutPanel',
    setup(e) {
      const t = useSystemStatsStore(),
        n = useAboutPanelStore()
      return (
        Vue.onMounted(async () => {
          t.systemStats || (await t.fetchSystemStats())
        }),
        (e, o) => (
          Vue.openBlock(),
          Vue.createBlock(
            _sfc_main$I,
            { value: 'About', class: 'about-container' },
            {
              default: Vue.withCtx(() => [
                Vue.createElementVNode(
                  'h2',
                  _hoisted_1$E,
                  Vue.toDisplayString(e.$t('about')),
                  1
                ),
                Vue.createElementVNode('div', _hoisted_2$o, [
                  (Vue.openBlock(!0),
                  Vue.createElementBlock(
                    Vue.Fragment,
                    null,
                    Vue.renderList(
                      Vue.unref(n).badges,
                      (e) => (
                        Vue.openBlock(),
                        Vue.createElementBlock(
                          'a',
                          {
                            key: e.url,
                            href: e.url,
                            target: '_blank',
                            rel: 'noopener noreferrer',
                            class:
                              'about-badge inline-flex items-center no-underline',
                            title: e.url
                          },
                          [
                            Vue.createVNode(
                              Vue.unref(script$C),
                              { class: 'mr-2' },
                              {
                                icon: Vue.withCtx(() => [
                                  Vue.createElementVNode(
                                    'i',
                                    {
                                      class: Vue.normalizeClass([
                                        e.icon,
                                        'mr-2 text-xl'
                                      ])
                                    },
                                    null,
                                    2
                                  )
                                ]),
                                default: Vue.withCtx(() => [
                                  Vue.createTextVNode(
                                    ' ' + Vue.toDisplayString(e.label),
                                    1
                                  )
                                ]),
                                _: 2
                              },
                              1024
                            )
                          ],
                          8,
                          _hoisted_3$f
                        )
                      )
                    ),
                    128
                  ))
                ]),
                Vue.createVNode(Vue.unref(script$G)),
                Vue.unref(t).systemStats
                  ? (Vue.openBlock(),
                    Vue.createBlock(
                      _sfc_main$D,
                      { key: 0, stats: Vue.unref(t).systemStats },
                      null,
                      8,
                      ['stats']
                    ))
                  : Vue.createCommentVNode('', !0)
              ]),
              _: 1
            }
          )
        )
      )
    }
  })
var theme$g = __name(function (e) {
    var t = e.dt
    return '\n.p-message {\n    border-radius: '
      .concat(t('message.border.radius'), ';\n    outline-width: ')
      .concat(
        t('message.border.width'),
        ';\n    outline-style: solid;\n}\n\n.p-message-content {\n    display: flex;\n    align-items: center;\n    padding: '
      )
      .concat(t('message.content.padding'), ';\n    gap: ')
      .concat(
        t('message.content.gap'),
        ';\n    height: 100%;\n}\n\n.p-message-icon {\n    flex-shrink: 0;\n}\n\n.p-message-close-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-shrink: 0;\n    margin-inline-start: auto;\n    overflow: hidden;\n    position: relative;\n    width: '
      )
      .concat(t('message.close.button.width'), ';\n    height: ')
      .concat(t('message.close.button.height'), ';\n    border-radius: ')
      .concat(
        t('message.close.button.border.radius'),
        ';\n    background: transparent;\n    transition: background '
      )
      .concat(t('message.transition.duration'), ', color ')
      .concat(t('message.transition.duration'), ', outline-color ')
      .concat(t('message.transition.duration'), ', box-shadow ')
      .concat(
        t('message.transition.duration'),
        ', opacity 0.3s;\n    outline-color: transparent;\n    color: inherit;\n    padding: 0;\n    border: none;\n    cursor: pointer;\n    user-select: none;\n}\n\n.p-message-close-icon {\n    font-size: '
      )
      .concat(t('message.close.icon.size'), ';\n    width: ')
      .concat(t('message.close.icon.size'), ';\n    height: ')
      .concat(
        t('message.close.icon.size'),
        ';\n}\n\n.p-message-close-button:focus-visible {\n    outline-width: '
      )
      .concat(
        t('message.close.button.focus.ring.width'),
        ';\n    outline-style: '
      )
      .concat(
        t('message.close.button.focus.ring.style'),
        ';\n    outline-offset: '
      )
      .concat(
        t('message.close.button.focus.ring.offset'),
        ';\n}\n\n.p-message-info {\n    background: '
      )
      .concat(t('message.info.background'), ';\n    outline-color: ')
      .concat(t('message.info.border.color'), ';\n    color: ')
      .concat(t('message.info.color'), ';\n    box-shadow: ')
      .concat(
        t('message.info.shadow'),
        ';\n}\n\n.p-message-info .p-message-close-button:focus-visible {\n    outline-color: '
      )
      .concat(
        t('message.info.close.button.focus.ring.color'),
        ';\n    box-shadow: '
      )
      .concat(
        t('message.info.close.button.focus.ring.shadow'),
        ';\n}\n\n.p-message-info .p-message-close-button:hover {\n    background: '
      )
      .concat(
        t('message.info.close.button.hover.background'),
        ';\n}\n\n.p-message-info.p-message-outlined {\n    color: '
      )
      .concat(t('message.info.outlined.color'), ';\n    outline-color: ')
      .concat(
        t('message.info.outlined.border.color'),
        ';\n}\n\n.p-message-info.p-message-simple {\n    color: '
      )
      .concat(
        t('message.info.simple.color'),
        ';\n}\n\n.p-message-success {\n    background: '
      )
      .concat(t('message.success.background'), ';\n    outline-color: ')
      .concat(t('message.success.border.color'), ';\n    color: ')
      .concat(t('message.success.color'), ';\n    box-shadow: ')
      .concat(
        t('message.success.shadow'),
        ';\n}\n\n.p-message-success .p-message-close-button:focus-visible {\n    outline-color: '
      )
      .concat(
        t('message.success.close.button.focus.ring.color'),
        ';\n    box-shadow: '
      )
      .concat(
        t('message.success.close.button.focus.ring.shadow'),
        ';\n}\n\n.p-message-success .p-message-close-button:hover {\n    background: '
      )
      .concat(
        t('message.success.close.button.hover.background'),
        ';\n}\n\n.p-message-success.p-message-outlined {\n    color: '
      )
      .concat(t('message.success.outlined.color'), ';\n    outline-color: ')
      .concat(
        t('message.success.outlined.border.color'),
        ';\n}\n\n.p-message-success.p-message-simple {\n    color: '
      )
      .concat(
        t('message.success.simple.color'),
        ';\n}\n\n.p-message-warn {\n    background: '
      )
      .concat(t('message.warn.background'), ';\n    outline-color: ')
      .concat(t('message.warn.border.color'), ';\n    color: ')
      .concat(t('message.warn.color'), ';\n    box-shadow: ')
      .concat(
        t('message.warn.shadow'),
        ';\n}\n\n.p-message-warn .p-message-close-button:focus-visible {\n    outline-color: '
      )
      .concat(
        t('message.warn.close.button.focus.ring.color'),
        ';\n    box-shadow: '
      )
      .concat(
        t('message.warn.close.button.focus.ring.shadow'),
        ';\n}\n\n.p-message-warn .p-message-close-button:hover {\n    background: '
      )
      .concat(
        t('message.warn.close.button.hover.background'),
        ';\n}\n\n.p-message-warn.p-message-outlined {\n    color: '
      )
      .concat(t('message.warn.outlined.color'), ';\n    outline-color: ')
      .concat(
        t('message.warn.outlined.border.color'),
        ';\n}\n\n.p-message-warn.p-message-simple {\n    color: '
      )
      .concat(
        t('message.warn.simple.color'),
        ';\n}\n\n.p-message-error {\n    background: '
      )
      .concat(t('message.error.background'), ';\n    outline-color: ')
      .concat(t('message.error.border.color'), ';\n    color: ')
      .concat(t('message.error.color'), ';\n    box-shadow: ')
      .concat(
        t('message.error.shadow'),
        ';\n}\n\n.p-message-error .p-message-close-button:focus-visible {\n    outline-color: '
      )
      .concat(
        t('message.error.close.button.focus.ring.color'),
        ';\n    box-shadow: '
      )
      .concat(
        t('message.error.close.button.focus.ring.shadow'),
        ';\n}\n\n.p-message-error .p-message-close-button:hover {\n    background: '
      )
      .concat(
        t('message.error.close.button.hover.background'),
        ';\n}\n\n.p-message-error.p-message-outlined {\n    color: '
      )
      .concat(t('message.error.outlined.color'), ';\n    outline-color: ')
      .concat(
        t('message.error.outlined.border.color'),
        ';\n}\n\n.p-message-error.p-message-simple {\n    color: '
      )
      .concat(
        t('message.error.simple.color'),
        ';\n}\n\n.p-message-secondary {\n    background: '
      )
      .concat(t('message.secondary.background'), ';\n    outline-color: ')
      .concat(t('message.secondary.border.color'), ';\n    color: ')
      .concat(t('message.secondary.color'), ';\n    box-shadow: ')
      .concat(
        t('message.secondary.shadow'),
        ';\n}\n\n.p-message-secondary .p-message-close-button:focus-visible {\n    outline-color: '
      )
      .concat(
        t('message.secondary.close.button.focus.ring.color'),
        ';\n    box-shadow: '
      )
      .concat(
        t('message.secondary.close.button.focus.ring.shadow'),
        ';\n}\n\n.p-message-secondary .p-message-close-button:hover {\n    background: '
      )
      .concat(
        t('message.secondary.close.button.hover.background'),
        ';\n}\n\n.p-message-secondary.p-message-outlined {\n    color: '
      )
      .concat(t('message.secondary.outlined.color'), ';\n    outline-color: ')
      .concat(
        t('message.secondary.outlined.border.color'),
        ';\n}\n\n.p-message-secondary.p-message-simple {\n    color: '
      )
      .concat(
        t('message.secondary.simple.color'),
        ';\n}\n\n.p-message-contrast {\n    background: '
      )
      .concat(t('message.contrast.background'), ';\n    outline-color: ')
      .concat(t('message.contrast.border.color'), ';\n    color: ')
      .concat(t('message.contrast.color'), ';\n    box-shadow: ')
      .concat(
        t('message.contrast.shadow'),
        ';\n}\n\n.p-message-contrast .p-message-close-button:focus-visible {\n    outline-color: '
      )
      .concat(
        t('message.contrast.close.button.focus.ring.color'),
        ';\n    box-shadow: '
      )
      .concat(
        t('message.contrast.close.button.focus.ring.shadow'),
        ';\n}\n\n.p-message-contrast .p-message-close-button:hover {\n    background: '
      )
      .concat(
        t('message.contrast.close.button.hover.background'),
        ';\n}\n\n.p-message-contrast.p-message-outlined {\n    color: '
      )
      .concat(t('message.contrast.outlined.color'), ';\n    outline-color: ')
      .concat(
        t('message.contrast.outlined.border.color'),
        ';\n}\n\n.p-message-contrast.p-message-simple {\n    color: '
      )
      .concat(
        t('message.contrast.simple.color'),
        ';\n}\n\n.p-message-text {\n    font-size: '
      )
      .concat(t('message.text.font.size'), ';\n    font-weight: ')
      .concat(
        t('message.text.font.weight'),
        ';\n}\n\n.p-message-icon {\n    font-size: '
      )
      .concat(t('message.icon.size'), ';\n    width: ')
      .concat(t('message.icon.size'), ';\n    height: ')
      .concat(
        t('message.icon.size'),
        ';\n}\n\n.p-message-enter-from {\n    opacity: 0;\n}\n\n.p-message-enter-active {\n    transition: opacity 0.3s;\n}\n\n.p-message.p-message-leave-from {\n    max-height: 1000px;\n}\n\n.p-message.p-message-leave-to {\n    max-height: 0;\n    opacity: 0;\n    margin: 0;\n}\n\n.p-message-leave-active {\n    overflow: hidden;\n    transition: max-height 0.45s cubic-bezier(0, 1, 0, 1), opacity 0.3s, margin 0.3s;\n}\n\n.p-message-leave-active .p-message-close-button {\n    opacity: 0;\n}\n\n.p-message-sm .p-message-content {\n    padding: '
      )
      .concat(
        t('message.content.sm.padding'),
        ';\n}\n\n.p-message-sm .p-message-text {\n    font-size: '
      )
      .concat(
        t('message.text.sm.font.size'),
        ';\n}\n\n.p-message-sm .p-message-icon {\n    font-size: '
      )
      .concat(t('message.icon.sm.size'), ';\n    width: ')
      .concat(t('message.icon.sm.size'), ';\n    height: ')
      .concat(
        t('message.icon.sm.size'),
        ';\n}\n\n.p-message-sm .p-message-close-icon {\n    font-size: '
      )
      .concat(t('message.close.icon.sm.size'), ';\n    width: ')
      .concat(t('message.close.icon.sm.size'), ';\n    height: ')
      .concat(
        t('message.close.icon.sm.size'),
        ';\n}\n\n.p-message-lg .p-message-content {\n    padding: '
      )
      .concat(
        t('message.content.lg.padding'),
        ';\n}\n\n.p-message-lg .p-message-text {\n    font-size: '
      )
      .concat(
        t('message.text.lg.font.size'),
        ';\n}\n\n.p-message-lg .p-message-icon {\n    font-size: '
      )
      .concat(t('message.icon.lg.size'), ';\n    width: ')
      .concat(t('message.icon.lg.size'), ';\n    height: ')
      .concat(
        t('message.icon.lg.size'),
        ';\n}\n\n.p-message-lg .p-message-close-icon {\n    font-size: '
      )
      .concat(t('message.close.icon.lg.size'), ';\n    width: ')
      .concat(t('message.close.icon.lg.size'), ';\n    height: ')
      .concat(
        t('message.close.icon.lg.size'),
        ';\n}\n\n.p-message-outlined {\n    background: transparent;\n    outline-width: '
      )
      .concat(
        t('message.outlined.border.width'),
        ';\n}\n\n.p-message-simple {\n    background: transparent;\n    outline-color: transparent;\n    box-shadow: none;\n}\n\n.p-message-simple .p-message-content {\n    padding: '
      )
      .concat(
        t('message.simple.content.padding'),
        ';\n}\n\n.p-message-outlined .p-message-close-button:hover,\n.p-message-simple .p-message-close-button:hover {\n    background: transparent;\n}\n'
      )
  }, 'theme'),
  classes$g = {
    root: __name(function (e) {
      var t = e.props
      return [
        'p-message p-component p-message-' + t.severity,
        {
          'p-message-outlined': 'outlined' === t.variant,
          'p-message-simple': 'simple' === t.variant,
          'p-message-sm': 'small' === t.size,
          'p-message-lg': 'large' === t.size
        }
      ]
    }, 'root'),
    content: 'p-message-content',
    icon: 'p-message-icon',
    text: 'p-message-text',
    closeButton: 'p-message-close-button',
    closeIcon: 'p-message-close-icon'
  },
  MessageStyle = BaseStyle.extend({
    name: 'message',
    theme: theme$g,
    classes: classes$g
  }),
  script$1$f = {
    name: 'BaseMessage',
    extends: script$Y,
    props: {
      severity: { type: String, default: 'info' },
      closable: { type: Boolean, default: !1 },
      life: { type: Number, default: null },
      icon: { type: String, default: void 0 },
      closeIcon: { type: String, default: void 0 },
      closeButtonProps: { type: null, default: null },
      size: { type: String, default: null },
      variant: { type: String, default: null }
    },
    style: MessageStyle,
    provide: __name(function () {
      return { $pcMessage: this, $parentInstance: this }
    }, 'provide')
  },
  script$n = {
    name: 'Message',
    extends: script$1$f,
    inheritAttrs: !1,
    emits: ['close', 'life-end'],
    timeout: null,
    data: __name(function () {
      return { visible: !0 }
    }, 'data'),
    mounted: __name(function () {
      var e = this
      this.life &&
        setTimeout(function () {
          ;(e.visible = !1), e.$emit('life-end')
        }, this.life)
    }, 'mounted'),
    methods: {
      close: __name(function (e) {
        ;(this.visible = !1), this.$emit('close', e)
      }, 'close')
    },
    computed: {
      closeAriaLabel: __name(function () {
        return this.$primevue.config.locale.aria
          ? this.$primevue.config.locale.aria.close
          : void 0
      }, 'closeAriaLabel')
    },
    directives: { ripple: Ripple },
    components: { TimesIcon: script$x }
  }
function _typeof$9(e) {
  return (_typeof$9 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$b(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$b(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$b(Object(n), !0).forEach(function (t) {
          _defineProperty$9(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$b(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$9(e, t, n) {
  return (
    (t = _toPropertyKey$8(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$8(e) {
  var t = _toPrimitive$8(e, 'string')
  return 'symbol' == _typeof$9(t) ? t : t + ''
}
function _toPrimitive$8(e, t) {
  if ('object' != _typeof$9(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$9(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$9, '_typeof$9'),
  __name(ownKeys$b, 'ownKeys$b'),
  __name(_objectSpread$b, '_objectSpread$b'),
  __name(_defineProperty$9, '_defineProperty$9'),
  __name(_toPropertyKey$8, '_toPropertyKey$8'),
  __name(_toPrimitive$8, '_toPrimitive$8')
var _hoisted_1$D = ['aria-label']
function render$m(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('TimesIcon'),
    s = Vue.resolveDirective('ripple')
  return (
    Vue.openBlock(),
    Vue.createBlock(
      Vue.Transition,
      Vue.mergeProps({ name: 'p-message', appear: '' }, e.ptmi('transition')),
      {
        default: Vue.withCtx(function () {
          return [
            Vue.withDirectives(
              Vue.createElementVNode(
                'div',
                Vue.mergeProps(
                  {
                    class: e.cx('root'),
                    role: 'alert',
                    'aria-live': 'assertive',
                    'aria-atomic': 'true'
                  },
                  e.ptm('root')
                ),
                [
                  e.$slots.container
                    ? Vue.renderSlot(e.$slots, 'container', {
                        key: 0,
                        closeCallback: r.close
                      })
                    : (Vue.openBlock(),
                      Vue.createElementBlock(
                        'div',
                        Vue.mergeProps(
                          { key: 1, class: e.cx('content') },
                          e.ptm('content')
                        ),
                        [
                          Vue.renderSlot(
                            e.$slots,
                            'icon',
                            { class: Vue.normalizeClass(e.cx('icon')) },
                            function () {
                              return [
                                (Vue.openBlock(),
                                Vue.createBlock(
                                  Vue.resolveDynamicComponent(
                                    e.icon ? 'span' : null
                                  ),
                                  Vue.mergeProps(
                                    { class: [e.cx('icon'), e.icon] },
                                    e.ptm('icon')
                                  ),
                                  null,
                                  16,
                                  ['class']
                                ))
                              ]
                            }
                          ),
                          e.$slots.default
                            ? (Vue.openBlock(),
                              Vue.createElementBlock(
                                'div',
                                Vue.mergeProps(
                                  { key: 0, class: e.cx('text') },
                                  e.ptm('text')
                                ),
                                [Vue.renderSlot(e.$slots, 'default')],
                                16
                              ))
                            : Vue.createCommentVNode('', !0),
                          e.closable
                            ? Vue.withDirectives(
                                (Vue.openBlock(),
                                Vue.createElementBlock(
                                  'button',
                                  Vue.mergeProps(
                                    {
                                      key: 1,
                                      class: e.cx('closeButton'),
                                      'aria-label': r.closeAriaLabel,
                                      type: 'button',
                                      onClick:
                                        t[0] ||
                                        (t[0] = function (e) {
                                          return r.close(e)
                                        })
                                    },
                                    _objectSpread$b(
                                      _objectSpread$b({}, e.closeButtonProps),
                                      e.ptm('closeButton')
                                    )
                                  ),
                                  [
                                    Vue.renderSlot(
                                      e.$slots,
                                      'closeicon',
                                      {},
                                      function () {
                                        return [
                                          e.closeIcon
                                            ? (Vue.openBlock(),
                                              Vue.createElementBlock(
                                                'i',
                                                Vue.mergeProps(
                                                  {
                                                    key: 0,
                                                    class: [
                                                      e.cx('closeIcon'),
                                                      e.closeIcon
                                                    ]
                                                  },
                                                  e.ptm('closeIcon')
                                                ),
                                                null,
                                                16
                                              ))
                                            : (Vue.openBlock(),
                                              Vue.createBlock(
                                                a,
                                                Vue.mergeProps(
                                                  {
                                                    key: 1,
                                                    class: [
                                                      e.cx('closeIcon'),
                                                      e.closeIcon
                                                    ]
                                                  },
                                                  e.ptm('closeIcon')
                                                ),
                                                null,
                                                16,
                                                ['class']
                                              ))
                                        ]
                                      }
                                    )
                                  ],
                                  16,
                                  _hoisted_1$D
                                )),
                                [[s]]
                              )
                            : Vue.createCommentVNode('', !0)
                        ],
                        16
                      ))
                ],
                16
              ),
              [[Vue.vShow, i.visible]]
            )
          ]
        }),
        _: 3
      },
      16
    )
  )
}
__name(render$m, 'render$m'), (script$n.render = render$m)
const _sfc_main$B = Vue.defineComponent({
    __name: 'FirstTimeUIMessage',
    setup(e) {
      const t = useSettingStore(),
        n = Vue.computed(() => !t.exists('Comfy.UseNewMenu')),
        o = __name(() => {
          const e = t.get('Comfy.UseNewMenu')
          t.set('Comfy.UseNewMenu', e)
        }, 'handleClose')
      return (e, t) =>
        n.value
          ? (Vue.openBlock(),
            Vue.createBlock(
              Vue.unref(script$n),
              {
                key: 0,
                class: 'first-time-ui-message',
                severity: 'info',
                closable: !0,
                onClose: o
              },
              {
                default: Vue.withCtx(() => [
                  Vue.createTextVNode(
                    Vue.toDisplayString(e.$t('firstTimeUIMessage')),
                    1
                  )
                ]),
                _: 1
              }
            ))
          : Vue.createCommentVNode('', !0)
    }
  }),
  useUserStore = defineStore('user', () => {
    const e = Vue.ref(null),
      t = Vue.ref(null),
      n = Vue.computed(() => e.value && 'users' in e.value),
      o = Vue.computed(() => !t.value && n.value),
      i = Vue.computed(() =>
        Object.entries(e.value?.users ?? {}).map(([e, t]) => ({
          userId: e,
          username: t
        }))
      ),
      r = Vue.computed(() => i.value.find((e) => e.userId === t.value) ?? null),
      a = Vue.computed(() => null !== e.value)
    async function s() {
      ;(e.value = await api.getUserConfig()),
        (t.value = localStorage['Comfy.userId'])
    }
    async function l(e) {
      const t = await api.createUser(e),
        n = await t.json()
      if (t.status >= 300)
        throw new Error(
          n.error ?? 'Error creating user: ' + t.status + ' ' + t.statusText
        )
      return { userId: n, username: e }
    }
    async function c({ userId: e, username: n }) {
      ;(t.value = e),
        (localStorage['Comfy.userId'] = e),
        (localStorage['Comfy.userName'] = n)
    }
    async function d() {
      delete localStorage['Comfy.userId'], delete localStorage['Comfy.userName']
    }
    return (
      __name(s, 'initialize'),
      __name(l, 'createUser'),
      __name(c, 'login'),
      Vue.watchEffect(() => {
        n.value && t.value && (api.user = t.value)
      }),
      __name(d, 'logout'),
      {
        users: i,
        currentUser: r,
        isMultiUserServer: n,
        needsLogin: o,
        initialized: a,
        initialize: s,
        createUser: l,
        login: c,
        logout: d
      }
    )
  }),
  _hoisted_1$C = { class: 'flex items-center justify-between' },
  _sfc_main$A = Vue.defineComponent({
    __name: 'CurrentUserMessage',
    setup(e) {
      const t = useUserStore(),
        n = __name(() => {
          t.logout(), window.location.reload()
        }, 'logout')
      return (e, o) =>
        Vue.unref(t).isMultiUserServer
          ? (Vue.openBlock(),
            Vue.createBlock(
              Vue.unref(script$n),
              {
                key: 0,
                severity: 'info',
                icon: 'pi pi-user',
                'pt:text': 'w-full'
              },
              {
                default: Vue.withCtx(() => [
                  Vue.createElementVNode('div', _hoisted_1$C, [
                    Vue.createElementVNode(
                      'div',
                      null,
                      Vue.toDisplayString(e.$t('currentUser')) +
                        ': ' +
                        Vue.toDisplayString(Vue.unref(t).currentUser?.username),
                      1
                    ),
                    Vue.createVNode(Vue.unref(script$K), {
                      icon: 'pi pi-sign-out',
                      onClick: n,
                      text: ''
                    })
                  ])
                ]),
                _: 1
              }
            ))
          : Vue.createCommentVNode('', !0)
    }
  })
function buildTree(e, t) {
  const n = { key: 'root', label: 'root', children: [] },
    o = { root: n }
  for (const i of e) {
    const e = t(i)
    let r = n
    for (let t = 0; t < e.length; t++) {
      const n = e[t]
      if ('' === n && t === e.length - 1) break
      const i = r.key + '/' + n
      if (!o[i]) {
        const e = { key: i, label: n, leaf: !1, children: [] }
        ;(o[i] = e), r.children?.push(e)
      }
      r = o[i]
    }
    ;(r.leaf = '' !== e[e.length - 1]), (r.data = i)
  }
  return n
}
function flattenTree(e) {
  const t = [],
    n = [e]
  for (; n.length; ) {
    const e = n.pop()
    e.leaf && e.data && t.push(e.data), n.push(...(e.children || []))
  }
  return t
}
function sortedTree(e, { groupLeaf: t = !1 } = {}) {
  const n = { ...e }
  if (e.children)
    if (t) {
      const t = e.children.filter((e) => !e.leaf),
        o = e.children.filter((e) => e.leaf),
        i = t.sort((e, t) => (e.label ?? '').localeCompare(t.label ?? '')),
        r = o.sort((e, t) => (e.label ?? '').localeCompare(t.label ?? ''))
      n.children = [...i.map((e) => sortedTree(e, { groupLeaf: !0 })), ...r]
    } else {
      const t = [...e.children].sort((e, t) =>
        (e.label ?? '').localeCompare(t.label ?? '')
      )
      n.children = [...t.map((e) => sortedTree(e, { groupLeaf: !1 }))]
    }
  return n
}
__name(buildTree, 'buildTree'),
  __name(flattenTree, 'flattenTree'),
  __name(sortedTree, 'sortedTree')
const findNodeByKey = __name((e, t) => {
    if (e.key === t) return e
    if (!e.children) return null
    for (const n of e.children) {
      const e = findNodeByKey(n, t)
      if (e) return e
    }
    return null
  }, 'findNodeByKey'),
  _hoisted_1$B = { class: 'settings-container' },
  _sfc_main$z = Vue.defineComponent({
    __name: 'SettingDialogContent',
    setup(e) {
      const t = Vue.defineAsyncComponent(() =>
          __vitePreload(
            () => import('./KeybindingPanel-DUoRw5XE.js'),
            __vite__mapDeps([0, 1, 2, 3]),
            import.meta.url
          )
        ),
        n = Vue.defineAsyncComponent(() =>
          __vitePreload(
            () => import('./ExtensionPanel-DSAkKiE9.js'),
            __vite__mapDeps([4, 1, 2]),
            import.meta.url
          )
        ),
        o = Vue.defineAsyncComponent(() =>
          __vitePreload(
            () => import('./ServerConfigPanel-B_24-2Tt.js'),
            __vite__mapDeps([5, 6]),
            import.meta.url
          )
        ),
        i = { key: 'about', label: 'About', children: [] },
        r = { key: 'keybinding', label: 'Keybinding', children: [] },
        a = { key: 'extension', label: 'Extension', children: [] },
        s = { key: 'server-config', label: 'Server-Config', children: [] },
        l = Vue.computed(() =>
          useSettingStore().get('Comfy.Settings.ExtensionPanel') ? [a] : []
        ),
        c = Vue.computed(() => (isElectron() ? [s] : [])),
        d = useSettingStore(),
        u = Vue.computed(() => d.settingTree),
        p = Vue.computed(() => u.value.children ?? []),
        { t: h } = VueI18n.useI18n(),
        m = Vue.computed(() =>
          [...p.value, r, ...l.value, ...c.value, i].map((e) => ({
            ...e,
            translatedLabel: h(
              `settingsCategories.${normalizeI18nKey(e.label)}`,
              e.label
            )
          }))
        ),
        f = Vue.ref(null),
        _ = Vue.ref([])
      Vue.watch(f, (e, t) => {
        null === e && (f.value = t)
      }),
        Vue.onMounted(() => {
          f.value = m.value[0]
        })
      const g = __name(
          (e) =>
            [...(e.children ?? [])]
              .sort((e, t) => e.label.localeCompare(t.label))
              .map((e) => ({ label: e.label, settings: flattenTree(e) })),
          'sortedGroups'
        ),
        v = Vue.ref(''),
        y = Vue.ref(!1)
      Vue.watch(v, () => (y.value = !0))
      const b = __name((e) => {
          if (!e) return void (_.value = [])
          const t = flattenTree(u.value).filter(
              (t) =>
                t.id.toLowerCase().includes(e.toLowerCase()) ||
                t.name.toLowerCase().includes(e.toLowerCase())
            ),
            n = {}
          t.forEach((e) => {
            const t = e.id.split('.')[1]
            n[t] || (n[t] = []), n[t].push(e)
          }),
            (_.value = Object.entries(n).map(([e, t]) => ({
              label: e,
              settings: t
            }))),
            (y.value = !1)
        }, 'handleSearch'),
        S = Vue.computed(() => v.value.length > 0 && !y.value),
        C = Vue.computed(() => (S.value ? 'Search Results' : f.value?.label))
      return (e, i) => (
        Vue.openBlock(),
        Vue.createElementBlock('div', _hoisted_1$B, [
          Vue.createVNode(
            Vue.unref(script$F),
            { class: 'settings-sidebar flex-shrink-0 p-2 w-48 2xl:w-64' },
            {
              default: Vue.withCtx(() => [
                Vue.createVNode(
                  SearchBox,
                  {
                    class: 'settings-search-box w-full mb-2',
                    modelValue: v.value,
                    'onUpdate:modelValue':
                      i[0] || (i[0] = (e) => (v.value = e)),
                    onSearch: b,
                    placeholder: e.$t('searchSettings') + '...'
                  },
                  null,
                  8,
                  ['modelValue', 'placeholder']
                ),
                Vue.createVNode(
                  Vue.unref(script$M),
                  {
                    modelValue: f.value,
                    'onUpdate:modelValue':
                      i[1] || (i[1] = (e) => (f.value = e)),
                    options: m.value,
                    optionLabel: 'translatedLabel',
                    scrollHeight: '100%',
                    disabled: S.value,
                    class: 'border-none w-full'
                  },
                  null,
                  8,
                  ['modelValue', 'options', 'disabled']
                )
              ]),
              _: 1
            }
          ),
          Vue.createVNode(Vue.unref(script$G), {
            layout: 'vertical',
            class: 'mx-1 2xl:mx-4'
          }),
          Vue.createVNode(
            Vue.unref(script$I),
            {
              value: C.value,
              lazy: !0,
              class: 'settings-content h-full w-full'
            },
            {
              default: Vue.withCtx(() => [
                Vue.createVNode(
                  Vue.unref(script$H),
                  { class: 'settings-tab-panels h-full w-full pr-0' },
                  {
                    default: Vue.withCtx(() => [
                      Vue.createVNode(
                        _sfc_main$I,
                        { value: 'Search Results' },
                        {
                          default: Vue.withCtx(() => [
                            Vue.createVNode(
                              _sfc_main$J,
                              { settingGroups: _.value },
                              null,
                              8,
                              ['settingGroups']
                            )
                          ]),
                          _: 1
                        }
                      ),
                      (Vue.openBlock(!0),
                      Vue.createElementBlock(
                        Vue.Fragment,
                        null,
                        Vue.renderList(
                          p.value,
                          (e) => (
                            Vue.openBlock(),
                            Vue.createBlock(
                              _sfc_main$I,
                              { key: e.key, value: e.label },
                              {
                                header: Vue.withCtx(() => [
                                  'Comfy' === C.value
                                    ? (Vue.openBlock(),
                                      Vue.createBlock(_sfc_main$A, { key: 0 }))
                                    : Vue.createCommentVNode('', !0),
                                  'Comfy' === C.value
                                    ? (Vue.openBlock(),
                                      Vue.createBlock(_sfc_main$B, { key: 1 }))
                                    : Vue.createCommentVNode('', !0)
                                ]),
                                default: Vue.withCtx(() => [
                                  Vue.createVNode(
                                    _sfc_main$J,
                                    { settingGroups: g(e) },
                                    null,
                                    8,
                                    ['settingGroups']
                                  )
                                ]),
                                _: 2
                              },
                              1032,
                              ['value']
                            )
                          )
                        ),
                        128
                      )),
                      Vue.createVNode(_sfc_main$C),
                      (Vue.openBlock(),
                      Vue.createBlock(Vue.Suspense, null, {
                        fallback: Vue.withCtx(
                          () =>
                            i[2] ||
                            (i[2] = [
                              Vue.createElementVNode(
                                'div',
                                null,
                                'Loading keybinding panel...',
                                -1
                              )
                            ])
                        ),
                        default: Vue.withCtx(() => [
                          Vue.createVNode(Vue.unref(t))
                        ]),
                        _: 1
                      })),
                      (Vue.openBlock(),
                      Vue.createBlock(Vue.Suspense, null, {
                        fallback: Vue.withCtx(
                          () =>
                            i[3] ||
                            (i[3] = [
                              Vue.createElementVNode(
                                'div',
                                null,
                                'Loading extension panel...',
                                -1
                              )
                            ])
                        ),
                        default: Vue.withCtx(() => [
                          Vue.createVNode(Vue.unref(n))
                        ]),
                        _: 1
                      })),
                      (Vue.openBlock(),
                      Vue.createBlock(Vue.Suspense, null, {
                        fallback: Vue.withCtx(
                          () =>
                            i[4] ||
                            (i[4] = [
                              Vue.createElementVNode(
                                'div',
                                null,
                                'Loading server config panel...',
                                -1
                              )
                            ])
                        ),
                        default: Vue.withCtx(() => [
                          Vue.createVNode(Vue.unref(o))
                        ]),
                        _: 1
                      }))
                    ]),
                    _: 1
                  }
                )
              ]),
              _: 1
            },
            8,
            ['value']
          )
        ])
      )
    }
  }),
  SettingDialogContent = _export_sfc(_sfc_main$z, [
    ['__scopeId', 'data-v-d09e40de']
  ]),
  _sfc_main$y = {},
  _hoisted_1$A = { class: 'px-4' }
function _sfc_render$1(e, t) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock('div', null, [
      Vue.createElementVNode('h2', _hoisted_1$A, [
        t[0] ||
          (t[0] = Vue.createElementVNode(
            'i',
            { class: 'pi pi-cog' },
            null,
            -1
          )),
        Vue.createElementVNode(
          'span',
          null,
          Vue.toDisplayString(e.$t('settings')),
          1
        )
      ])
    ])
  )
}
__name(_sfc_render$1, '_sfc_render$1')
const SettingDialogHeader = _export_sfc(_sfc_main$y, [
  ['render', _sfc_render$1],
  ['__scopeId', 'data-v-f3b37ea3']
])
var PrimeVueToastSymbol = Symbol()
function useToast() {
  var e = Vue.inject(PrimeVueToastSymbol)
  if (!e) throw new Error('No PrimeVue Toast provided!')
  return e
}
__name(useToast, 'useToast')
const _sfc_main$x = Vue.defineComponent({
    __name: 'FindIssueButton',
    props: { errorMessage: {}, repoOwner: {}, repoName: {} },
    setup(e) {
      const t = e,
        n = Vue.computed(() => t.errorMessage + ' is:issue'),
        o = __name(() => {
          const e = encodeURIComponent(n.value),
            o = `https://github.com/${t.repoOwner}/${t.repoName}/issues?q=${e}`
          window.open(o, '_blank')
        }, 'openGitHubIssues')
      return (e, t) => (
        Vue.openBlock(),
        Vue.createBlock(
          Vue.unref(script$K),
          {
            onClick: o,
            label: e.$t('findIssues'),
            severity: 'secondary',
            icon: 'pi pi-github'
          },
          null,
          8,
          ['label']
        )
      )
    }
  }),
  _sfc_main$w = Vue.defineComponent({
    __name: 'ReportIssueButton',
    props: { error: {} },
    setup(e) {
      const { t: t } = VueI18n.useI18n(),
        n = useToast(),
        o = Vue.ref(!1),
        i = Vue.ref(!1),
        r = Vue.computed(
          () => 'pi ' + (o.value ? 'pi-spin pi-spinner' : 'pi-send')
        ),
        a = __name(async () => {
          if (!o.value) {
            o.value = !0
            try {
              await electronAPI().sendErrorToSentry(e.error.exception_message, {
                stackTrace: e.error.traceback?.join('\n'),
                nodeType: e.error.node_type
              }),
                (i.value = !0),
                n.add({
                  severity: 'success',
                  summary: t('reportSent'),
                  life: 3e3
                })
            } finally {
              o.value = !1
            }
          }
        }, 'reportIssue')
      return (e, t) => {
        const n = Vue.resolveDirective('tooltip')
        return Vue.withDirectives(
          (Vue.openBlock(),
          Vue.createBlock(
            Vue.unref(script$K),
            {
              onClick: a,
              label: e.$t('reportIssue'),
              severity: i.value ? 'success' : 'secondary',
              icon: r.value,
              disabled: i.value
            },
            null,
            8,
            ['label', 'severity', 'icon', 'disabled']
          )),
          [[n, e.$t('reportIssueTooltip')]]
        )
      }
    }
  })
function useCopyToClipboard() {
  const { copy: e, isSupported: t } = useClipboard(),
    n = useToast()
  return {
    copyToClipboard: __name(async (o) => {
      if (t)
        try {
          await e(o),
            n.add({
              severity: 'success',
              summary: 'Success',
              detail: 'Copied to clipboard',
              life: 3e3
            })
        } catch (i) {
          n.add({
            severity: 'error',
            summary: 'Error',
            detail: 'Failed to copy report'
          })
        }
      else
        n.add({
          severity: 'error',
          summary: 'Error',
          detail: 'Clipboard API not supported in your browser'
        })
    }, 'copyToClipboard')
  }
}
__name(useCopyToClipboard, 'useCopyToClipboard')
const _hoisted_1$z = { class: 'comfy-error-report' },
  _hoisted_2$n = { class: 'wrapper-pre' },
  _hoisted_3$e = { class: 'action-container' },
  repoOwner = 'comfyanonymous',
  repoName = 'ComfyUI',
  _sfc_main$v = Vue.defineComponent({
    __name: 'ExecutionErrorDialogContent',
    props: { error: {} },
    setup(e) {
      const t = e,
        n = Vue.ref(''),
        o = Vue.ref(!1),
        i = __name(() => {
          o.value = !0
        }, 'showReport'),
        r = isElectron(),
        a = useToast()
      Vue.onMounted(async () => {
        try {
          const [e, t] = await Promise.all([
            api.getSystemStats(),
            api.getLogs()
          ])
          s(e, t)
        } catch (e) {
          console.error('Error fetching system stats or logs:', e),
            a.add({
              severity: 'error',
              summary: 'Error',
              detail: 'Failed to fetch system information',
              life: 5e3
            })
        }
      })
      const s = __name((e, o) => {
          const i = JSON.stringify(app$1.graph.serialize()),
            r =
              i.length > 2e4
                ? 'Workflow too large. Please manually upload the workflow from local file system.'
                : i
          n.value = `\n# ComfyUI Error Report\n## Error Details\n- **Node ID:** ${t.error.node_id}\n- **Node Type:** ${t.error.node_type}\n- **Exception Type:** ${t.error.exception_type}\n- **Exception Message:** ${t.error.exception_message}\n## Stack Trace\n\`\`\`\n${t.error.traceback.join('\n')}\n\`\`\`\n## System Information\n- **ComfyUI Version:** ${e.system.comfyui_version}\n- **Arguments:** ${e.system.argv.join(' ')}\n- **OS:** ${e.system.os}\n- **Python Version:** ${e.system.python_version}\n- **Embedded Python:** ${e.system.embedded_python}\n- **PyTorch Version:** ${e.system.pytorch_version}\n## Devices\n${e.devices.map((e) => `\n- **Name:** ${e.name}\n  - **Type:** ${e.type}\n  - **VRAM Total:** ${e.vram_total}\n  - **VRAM Free:** ${e.vram_free}\n  - **Torch VRAM Total:** ${e.torch_vram_total}\n  - **Torch VRAM Free:** ${e.torch_vram_free}\n`).join('\n')}\n## Logs\n\`\`\`\n${o}\n\`\`\`\n## Attached Workflow\nPlease make sure that workflow does not contain any sensitive information such as API keys or passwords.\n\`\`\`\n${r}\n\`\`\`\n\n## Additional Context\n(Please add any additional context or steps to reproduce the error here)\n`
        }, 'generateReport'),
        { copyToClipboard: l } = useCopyToClipboard(),
        c = __name(async () => {
          await l(n.value)
        }, 'copyReportToClipboard')
      return (e, a) => (
        Vue.openBlock(),
        Vue.createElementBlock(
          Vue.Fragment,
          null,
          [
            Vue.createVNode(
              NoResultsPlaceholder,
              {
                icon: 'pi pi-exclamation-circle',
                title: t.error.node_type,
                message: t.error.exception_message
              },
              null,
              8,
              ['title', 'message']
            ),
            Vue.createElementVNode('div', _hoisted_1$z, [
              Vue.withDirectives(
                Vue.createVNode(
                  Vue.unref(script$K),
                  { label: e.$t('showReport'), onClick: i, text: '' },
                  null,
                  8,
                  ['label']
                ),
                [[Vue.vShow, !o.value]]
              ),
              o.value
                ? (Vue.openBlock(),
                  Vue.createElementBlock(
                    Vue.Fragment,
                    { key: 0 },
                    [
                      Vue.createVNode(Vue.unref(script$G)),
                      Vue.createVNode(
                        Vue.unref(script$F),
                        {
                          style: {
                            width: '100%',
                            height: '400px',
                            'max-width': '80vw'
                          }
                        },
                        {
                          default: Vue.withCtx(() => [
                            Vue.createElementVNode(
                              'pre',
                              _hoisted_2$n,
                              Vue.toDisplayString(n.value),
                              1
                            )
                          ]),
                          _: 1
                        }
                      ),
                      Vue.createVNode(Vue.unref(script$G))
                    ],
                    64
                  ))
                : Vue.createCommentVNode('', !0),
              Vue.createElementVNode('div', _hoisted_3$e, [
                Vue.unref(r)
                  ? (Vue.openBlock(),
                    Vue.createBlock(
                      _sfc_main$w,
                      { key: 0, error: t.error },
                      null,
                      8,
                      ['error']
                    ))
                  : Vue.createCommentVNode('', !0),
                Vue.createVNode(
                  _sfc_main$x,
                  {
                    errorMessage: t.error.exception_message,
                    repoOwner: repoOwner,
                    repoName: repoName
                  },
                  null,
                  8,
                  ['errorMessage']
                ),
                o.value
                  ? (Vue.openBlock(),
                    Vue.createBlock(
                      Vue.unref(script$K),
                      {
                        key: 1,
                        label: e.$t('copyToClipboard'),
                        icon: 'pi pi-copy',
                        onClick: c
                      },
                      null,
                      8,
                      ['label']
                    ))
                  : Vue.createCommentVNode('', !0)
              ])
            ])
          ],
          64
        )
      )
    }
  }),
  ExecutionErrorDialogContent = _export_sfc(_sfc_main$v, [
    ['__scopeId', 'data-v-db438f98']
  ]),
  _hoisted_1$y = {
    class: 'flex flex-wrap content-around justify-around gap-4 mt-4',
    'data-testid': 'template-workflows-content'
  },
  _hoisted_2$m = ['data-testid'],
  _hoisted_3$d = ['onClick'],
  _hoisted_4$8 = ['src'],
  _sfc_main$u = Vue.defineComponent({
    __name: 'TemplateWorkflowsContent',
    setup(e) {
      const { t: t } = VueI18n.useI18n(),
        n = ['default', 'image2image', 'upscale', 'flux_schnell'],
        o = Vue.ref(null),
        i = __name(async (e) => {
          o.value = e
          const n = await fetch(api.fileURL(`templates/${e}.json`)).then((e) =>
            e.json()
          )
          return (
            useDialogStore().closeDialog(),
            await app$1.loadGraphData(
              n,
              !0,
              !0,
              t(`templateWorkflows.template.${e}`)
            ),
            !1
          )
        }, 'loadWorkflow')
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock('div', _hoisted_1$y, [
          (Vue.openBlock(),
          Vue.createElementBlock(
            Vue.Fragment,
            null,
            Vue.renderList(n, (n) =>
              Vue.createElementVNode(
                'div',
                { key: n, 'data-testid': `template-workflow-${n}` },
                [
                  Vue.createVNode(
                    Vue.unref(script$J),
                    null,
                    {
                      header: Vue.withCtx(() => [
                        Vue.createElementVNode(
                          'div',
                          {
                            class:
                              'relative overflow-hidden rounded-lg cursor-pointer',
                            onClick: __name((e) => i(n), 'onClick')
                          },
                          [
                            Vue.createElementVNode(
                              'img',
                              {
                                src: `/templates/${n}.jpg`,
                                class: 'w-64 h-64 rounded-lg object-cover'
                              },
                              null,
                              8,
                              _hoisted_4$8
                            ),
                            t[0] ||
                              (t[0] = Vue.createElementVNode(
                                'a',
                                null,
                                [
                                  Vue.createElementVNode(
                                    'div',
                                    {
                                      class:
                                        'absolute top-0 left-0 w-64 h-64 overflow-hidden opacity-0 transition duration-300 ease-in-out hover:opacity-100 bg-opacity-50 bg-black flex items-center justify-center'
                                    },
                                    [
                                      Vue.createElementVNode('i', {
                                        class: 'pi pi-play-circle'
                                      })
                                    ]
                                  )
                                ],
                                -1
                              )),
                            o.value === n
                              ? (Vue.openBlock(),
                                Vue.createBlock(Vue.unref(script$r), {
                                  key: 0,
                                  class: 'absolute inset-0 z-1 w-3/12 h-full'
                                }))
                              : Vue.createCommentVNode('', !0)
                          ],
                          8,
                          _hoisted_3$d
                        )
                      ]),
                      subtitle: Vue.withCtx(() => [
                        Vue.createTextVNode(
                          Vue.toDisplayString(
                            e.$t(`templateWorkflows.template.${n}`)
                          ),
                          1
                        )
                      ]),
                      _: 2
                    },
                    1024
                  )
                ],
                8,
                _hoisted_2$m
              )
            ),
            64
          ))
        ])
      )
    }
  }),
  TemplateWorkflowsContent = _export_sfc(_sfc_main$u, [
    ['__scopeId', 'data-v-98830966']
  ])
var theme$f = __name(function (e) {
    var t = e.dt
    return '\n.p-floatlabel {\n    display: block;\n    position: relative;\n}\n\n.p-floatlabel label {\n    position: absolute;\n    pointer-events: none;\n    top: 50%;\n    transform: translateY(-50%);\n    transition-property: all;\n    transition-timing-function: ease;\n    line-height: 1;\n    font-weight: '
      .concat(t('floatlabel.font.weight'), ';\n    inset-inline-start: ')
      .concat(t('floatlabel.position.x'), ';\n    color: ')
      .concat(t('floatlabel.color'), ';\n    transition-duration: ')
      .concat(
        t('floatlabel.transition.duration'),
        ';\n}\n\n.p-floatlabel:has(.p-textarea) label {\n    top: '
      )
      .concat(
        t('floatlabel.position.y'),
        ';\n    transform: translateY(0);\n}\n\n.p-floatlabel:has(.p-inputicon:first-child) label {\n    inset-inline-start: calc(('
      )
      .concat(t('form.field.padding.x'), ' * 2) + ')
      .concat(
        t('icon.size'),
        ');\n}\n\n.p-floatlabel:has(.p-invalid) label {\n    color: '
      )
      .concat(
        t('floatlabel.invalid.color'),
        ';\n}\n\n.p-floatlabel:has(input:focus) label,\n.p-floatlabel:has(input.p-filled) label,\n.p-floatlabel:has(input:-webkit-autofill) label,\n.p-floatlabel:has(textarea:focus) label,\n.p-floatlabel:has(textarea.p-filled) label,\n.p-floatlabel:has(.p-inputwrapper-focus) label,\n.p-floatlabel:has(.p-inputwrapper-filled) label {\n    top: '
      )
      .concat(
        t('floatlabel.over.active.top'),
        ';\n    transform: translateY(0);\n    font-size: '
      )
      .concat(t('floatlabel.active.font.size'), ';\n    font-weight: ')
      .concat(
        t('floatlabel.label.active.font.weight'),
        ';\n}\n\n.p-floatlabel:has(input.p-filled) label,\n.p-floatlabel:has(textarea.p-filled) label,\n.p-floatlabel:has(.p-inputwrapper-filled) label {\n    color: '
      )
      .concat(
        t('floatlabel.active.color'),
        ';\n}\n\n.p-floatlabel:has(input:focus) label,\n.p-floatlabel:has(input:-webkit-autofill) label,\n.p-floatlabel:has(textarea:focus) label,\n.p-floatlabel:has(.p-inputwrapper-focus) label {\n    color: '
      )
      .concat(
        t('floatlabel.focus.color'),
        ';\n}\n\n.p-floatlabel-in .p-inputtext,\n.p-floatlabel-in .p-textarea,\n.p-floatlabel-in .p-select-label,\n.p-floatlabel-in .p-multiselect-label,\n.p-floatlabel-in .p-autocomplete-input-multiple,\n.p-floatlabel-in .p-cascadeselect-label,\n.p-floatlabel-in .p-treeselect-label {\n    padding-block-start: '
      )
      .concat(
        t('floatlabel.in.input.padding.top'),
        ';\n    padding-block-end: '
      )
      .concat(
        t('floatlabel.in.input.padding.bottom'),
        ';\n}\n\n.p-floatlabel-in:has(input:focus) label,\n.p-floatlabel-in:has(input.p-filled) label,\n.p-floatlabel-in:has(input:-webkit-autofill) label,\n.p-floatlabel-in:has(textarea:focus) label,\n.p-floatlabel-in:has(textarea.p-filled) label,\n.p-floatlabel-in:has(.p-inputwrapper-focus) label,\n.p-floatlabel-in:has(.p-inputwrapper-filled) label {\n    top: '
      )
      .concat(
        t('floatlabel.in.active.top'),
        ';\n}\n\n.p-floatlabel-on:has(input:focus) label,\n.p-floatlabel-on:has(input.p-filled) label,\n.p-floatlabel-on:has(input:-webkit-autofill) label,\n.p-floatlabel-on:has(textarea:focus) label,\n.p-floatlabel-on:has(textarea.p-filled) label,\n.p-floatlabel-on:has(.p-inputwrapper-focus) label,\n.p-floatlabel-on:has(.p-inputwrapper-filled) label {\n    top: 0;\n    transform: translateY(-50%);\n    border-radius: '
      )
      .concat(t('floatlabel.on.border.radius'), ';\n    background: ')
      .concat(t('floatlabel.on.active.background'), ';\n    padding: ')
      .concat(t('floatlabel.on.active.padding'), ';\n}\n')
  }, 'theme'),
  classes$f = {
    root: __name(function (e) {
      e.instance
      var t = e.props
      return [
        'p-floatlabel',
        {
          'p-floatlabel-over': 'over' === t.variant,
          'p-floatlabel-on': 'on' === t.variant,
          'p-floatlabel-in': 'in' === t.variant
        }
      ]
    }, 'root')
  },
  FloatLabelStyle = BaseStyle.extend({
    name: 'floatlabel',
    theme: theme$f,
    classes: classes$f
  }),
  script$1$e = {
    name: 'BaseFloatLabel',
    extends: script$Y,
    props: { variant: { type: String, default: 'over' } },
    style: FloatLabelStyle,
    provide: __name(function () {
      return { $pcFloatLabel: this, $parentInstance: this }
    }, 'provide')
  },
  script$m = { name: 'FloatLabel', extends: script$1$e, inheritAttrs: !1 }
function render$l(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'span',
      Vue.mergeProps({ class: e.cx('root') }, e.ptmi('root')),
      [Vue.renderSlot(e.$slots, 'default')],
      16
    )
  )
}
__name(render$l, 'render$l'), (script$m.render = render$l)
const _hoisted_1$x = {
    class: 'prompt-dialog-content flex flex-col gap-2 pt-8'
  },
  _sfc_main$t = Vue.defineComponent({
    __name: 'PromptDialogContent',
    props: { message: {}, defaultValue: {}, onConfirm: { type: Function } },
    setup(e) {
      const t = e,
        n = Vue.ref(t.defaultValue),
        o = __name(() => {
          t.onConfirm(n.value), useDialogStore().closeDialog()
        }, 'onConfirm'),
        i = Vue.ref(null),
        r = __name(() => {
          if (!i.value) return
          const e = i.value.$el
          e.setSelectionRange(0, e.value.length)
        }, 'selectAllText')
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock('div', _hoisted_1$x, [
          Vue.createVNode(Vue.unref(script$m), null, {
            default: Vue.withCtx(() => [
              Vue.createVNode(
                Vue.unref(script$P),
                {
                  ref_key: 'inputRef',
                  ref: i,
                  modelValue: n.value,
                  'onUpdate:modelValue': t[0] || (t[0] = (e) => (n.value = e)),
                  onKeyup: Vue.withKeys(o, ['enter']),
                  onFocus: r,
                  autofocus: ''
                },
                null,
                8,
                ['modelValue']
              ),
              Vue.createElementVNode(
                'label',
                null,
                Vue.toDisplayString(e.message),
                1
              )
            ]),
            _: 1
          }),
          Vue.createVNode(
            Vue.unref(script$K),
            { onClick: o },
            {
              default: Vue.withCtx(() => [
                Vue.createTextVNode(Vue.toDisplayString(e.$t('confirm')), 1)
              ]),
              _: 1
            }
          )
        ])
      )
    }
  }),
  _hoisted_1$w = {
    class: 'prompt-dialog-content flex flex-col gap-6 m-2 mt-4'
  },
  _hoisted_2$l = { key: 0, class: 'pl-4 m-0 flex flex-col gap-2' },
  _hoisted_3$c = { class: 'flex gap-4 justify-end' },
  _sfc_main$s = Vue.defineComponent({
    __name: 'ConfirmationDialogContent',
    props: {
      message: {},
      type: {},
      onConfirm: { type: Function },
      itemList: {}
    },
    setup(e) {
      const t = e,
        n = __name(() => useDialogStore().closeDialog(), 'onCancel'),
        o = __name(() => {
          t.onConfirm(!1), useDialogStore().closeDialog()
        }, 'onDeny'),
        i = __name(() => {
          t.onConfirm(!0), useDialogStore().closeDialog()
        }, 'onConfirm')
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock('section', _hoisted_1$w, [
          Vue.createElementVNode(
            'span',
            null,
            Vue.toDisplayString(e.message),
            1
          ),
          e.itemList?.length
            ? (Vue.openBlock(),
              Vue.createElementBlock('ul', _hoisted_2$l, [
                (Vue.openBlock(!0),
                Vue.createElementBlock(
                  Vue.Fragment,
                  null,
                  Vue.renderList(
                    e.itemList,
                    (e) => (
                      Vue.openBlock(),
                      Vue.createElementBlock(
                        'li',
                        { key: e },
                        Vue.toDisplayString(e),
                        1
                      )
                    )
                  ),
                  128
                ))
              ]))
            : Vue.createCommentVNode('', !0),
          Vue.createElementVNode('div', _hoisted_3$c, [
            Vue.createVNode(
              Vue.unref(script$K),
              {
                label: e.$t('cancel'),
                icon: 'pi pi-undo',
                severity: 'secondary',
                onClick: n,
                autofocus: ''
              },
              null,
              8,
              ['label']
            ),
            'delete' === e.type
              ? (Vue.openBlock(),
                Vue.createBlock(
                  Vue.unref(script$K),
                  {
                    key: 0,
                    label: e.$t('delete'),
                    severity: 'danger',
                    onClick: i,
                    icon: 'pi pi-trash'
                  },
                  null,
                  8,
                  ['label']
                ))
              : 'overwrite' === e.type
                ? (Vue.openBlock(),
                  Vue.createBlock(
                    Vue.unref(script$K),
                    {
                      key: 1,
                      label: e.$t('overwrite'),
                      severity: 'warn',
                      onClick: i,
                      icon: 'pi pi-save'
                    },
                    null,
                    8,
                    ['label']
                  ))
                : (Vue.openBlock(),
                  Vue.createElementBlock(
                    Vue.Fragment,
                    { key: 2 },
                    [
                      Vue.createVNode(
                        Vue.unref(script$K),
                        {
                          label: e.$t('no'),
                          severity: 'secondary',
                          onClick: o,
                          icon: 'pi pi-times'
                        },
                        null,
                        8,
                        ['label']
                      ),
                      Vue.createVNode(
                        Vue.unref(script$K),
                        { label: e.$t('save'), onClick: i, icon: 'pi pi-save' },
                        null,
                        8,
                        ['label']
                      )
                    ],
                    64
                  ))
          ])
        ])
      )
    }
  }),
  welcome$3 = { title: 'Welcome to ComfyUI', getStarted: 'Get Started' },
  userSelect$3 = {
    newUser: 'New user',
    enterUsername: 'Enter a username',
    existingUser: 'Existing user',
    selectUser: 'Select a user',
    next: 'Next'
  },
  notSupported$3 = {
    title: 'Your device is not supported',
    message: 'Only following devices are supported:',
    learnMore: 'Learn More',
    reportIssue: 'Report Issue',
    supportedDevices: {
      macos: 'MacOS (M1 or later)',
      windows: 'Windows (Nvidia GPU with CUDA support)'
    },
    continue: 'Continue',
    continueTooltip: 'I am sure my device is supported'
  },
  downloadGit$3 = {
    title: 'Download git',
    message:
      'Unable to locate git.  A working copy of git is required for normal operation.',
    instructions:
      'Please download and install the latest version for your operating system.  The Download git button below opens the git-scm.com downloads page.',
    warning:
      'If you are sure you do not need git installed, or there has been a mistake, you may click Skip to byapss this check.  Attempting to run ComfyUI without a working copy of git is not currently supported.',
    gitWebsite: 'Download git',
    skip: 'Skip'
  },
  install$3 = {
    installLocation: 'Install Location',
    migration: 'Migration',
    desktopSettings: 'Desktop Settings',
    chooseInstallationLocation: 'Choose Installation Location',
    systemLocations: 'System Locations',
    failedToSelectDirectory: 'Failed to select directory',
    pathValidationFailed: 'Failed to validate path',
    installLocationDescription:
      "Select the directory for ComfyUI's user data. A python environment will be installed to the selected location. Please make sure the selected disk has enough space (~15GB) left.",
    installLocationTooltip:
      "ComfyUI's user data directory. Stores:\n- Python Environment\n- Models\n- Custom nodes\n",
    appDataLocationTooltip:
      "ComfyUI's app data directory. Stores:\n- Logs\n- Server configs",
    appPathLocationTooltip:
      "ComfyUI's app asset directory. Stores the ComfyUI code and assets",
    migrateFromExistingInstallation: 'Migrate from Existing Installation',
    migrationSourcePathDescription:
      'If you have an existing ComfyUI installation, we can copy/link your existing user files and models to the new installation.',
    selectItemsToMigrate: 'Select Items to Migrate',
    migrationOptional:
      "Migration is optional. If you don't have an existing installation, you can skip this step.",
    desktopAppSettings: 'Desktop App Settings',
    desktopAppSettingsDescription:
      'Configure how ComfyUI behaves on your desktop. You can change these settings later.',
    settings: {
      autoUpdate: 'Automatic Updates',
      allowMetrics: 'Crash Reports',
      autoUpdateDescription:
        "Automatically download and install updates when they become available. You'll always be notified before updates are installed.",
      allowMetricsDescription:
        'Help improve ComfyUI by sending anonymous crash reports. No personal information or workflow content will be collected. This can be disabled at any time in the settings menu.',
      learnMoreAboutData: 'Learn more about data collection',
      dataCollectionDialog: {
        title: 'About Data Collection',
        whatWeCollect: 'What we collect:',
        whatWeDoNotCollect: "What we don't collect:",
        errorReports: 'Error message and stack trace',
        systemInfo: 'Hardware, OS type, and app version',
        personalInformation: 'Personal information',
        workflowContent: 'Workflow content',
        fileSystemInformation: 'File system information',
        workflowContents: 'Workflow contents',
        customNodeConfigurations: 'Custom node configurations'
      }
    },
    customNodes: 'Custom Nodes',
    customNodesDescription:
      'Reference custom node files from existing ComfyUI installations and install their dependencies.'
  },
  serverStart$3 = {
    reinstall: 'Reinstall',
    reportIssue: 'Report Issue',
    openLogs: 'Open Logs',
    process: {
      'initial-state': 'Loading...',
      'python-setup': 'Setting up Python Environment...',
      'starting-server': 'Starting ComfyUI server...',
      ready: 'Finishing...',
      error: 'Unable to start ComfyUI Desktop'
    }
  },
  serverConfig$3 = {
    modifiedConfigs:
      'You have modified the following server configurations. Restart to apply changes.',
    revertChanges: 'Revert Changes',
    restart: 'Restart'
  },
  currentUser$3 = 'Current user',
  empty$3 = 'Empty',
  noWorkflowsFound$3 = 'No workflows found.',
  comingSoon$3 = 'Coming Soon',
  firstTimeUIMessage$3 =
    'This is the first time you use the new UI. Choose "Menu > Use New Menu > Disabled" to restore the old UI.',
  download$3 = 'Download',
  loadAllFolders$3 = 'Load All Folders',
  refresh$3 = 'Refresh',
  terminal$3 = 'Terminal',
  logs$3 = 'Logs',
  videoFailedToLoad$3 = 'Video failed to load',
  extensionName$3 = 'Extension Name',
  reloadToApplyChanges$3 = 'Reload to apply changes',
  insert$3 = 'Insert',
  systemInfo$3 = 'System Info',
  devices$3 = 'Devices',
  about$3 = 'About',
  add$3 = 'Add',
  confirm$4 = 'Confirm',
  reset$3 = 'Reset',
  resetKeybindingsTooltip$3 = 'Reset keybindings to default',
  customizeFolder$3 = 'Customize Folder',
  icon$3 = 'Icon',
  color$3 = 'Color',
  bookmark$3 = 'Bookmark',
  folder$3 = 'Folder',
  star$3 = 'Star',
  heart$3 = 'Heart',
  file$3 = 'File',
  inbox$3 = 'Inbox',
  box$3 = 'Box',
  briefcase$3 = 'Briefcase',
  error$3 = 'Error',
  loading$3 = 'Loading',
  findIssues$3 = 'Find Issues',
  reportIssue$3 = 'Send Report',
  reportIssueTooltip$3 = 'Submit the error report to Comfy Org',
  reportSent$3 = 'Report Submitted',
  copyToClipboard$3 = 'Copy to Clipboard',
  openNewIssue$3 = 'Open New Issue',
  showReport$3 = 'Show Report',
  imageFailedToLoad$3 = 'Image failed to load',
  reconnecting$3 = 'Reconnecting',
  reconnected$3 = 'Reconnected',
  rename$3 = 'Rename',
  save$3 = 'Save',
  no$3 = 'No',
  cancel$3 = 'Cancel',
  overwrite$3 = 'Overwrite',
  customize$3 = 'Customize',
  experimental$3 = 'BETA',
  deprecated$3 = 'DEPR',
  loadWorkflow$3 = 'Load Workflow',
  goToNode$3 = 'Go to Node',
  settings$3 = 'Settings',
  settingsDialog$3 = {
    'Comfy-Desktop_AutoUpdate': { name: 'Automatically check for updates' },
    'Comfy-Desktop_SendStatistics': { name: 'Send anonymous crash reports' },
    Comfy_ColorPalette: { name: 'Color Palette' },
    Comfy_ConfirmClear: { name: 'Require confirmation when clearing workflow' },
    Comfy_DevMode: { name: 'Enable dev mode options (API save, etc.)' },
    Comfy_DisableFloatRounding: {
      name: 'Disable default float widget rounding.',
      tooltip:
        '(requires page reload) Cannot disable round when round is set by the node in the backend.'
    },
    Comfy_DisableSliders: { name: 'Disable node widget sliders' },
    Comfy_DOMClippingEnabled: {
      name: 'Enable DOM element clipping (enabling may reduce performance)'
    },
    Comfy_EditAttention_Delta: { name: 'Ctrl+up/down precision' },
    Comfy_EnableTooltips: { name: 'Enable Tooltips' },
    Comfy_EnableWorkflowViewRestore: {
      name: 'Save and restore canvas position and zoom level in workflows'
    },
    Comfy_Extension_Disabled: { name: 'Disabled extension names' },
    Comfy_FloatRoundingPrecision: {
      name: 'Float widget rounding decimal places [0 = auto].',
      tooltip: '(requires page reload)'
    },
    Comfy_Graph_CanvasInfo: {
      name: 'Show canvas info on bottom left corner (fps, etc.)'
    },
    Comfy_Graph_CanvasMenu: { name: 'Show graph canvas menu' },
    Comfy_Graph_CtrlShiftZoom: {
      name: 'Enable fast-zoom shortcut (Ctrl + Shift + Drag)'
    },
    Comfy_Graph_LinkMarkers: { name: 'Link midpoint markers' },
    Comfy_Graph_ZoomSpeed: { name: 'Canvas zoom speed' },
    Comfy_Group_DoubleClickTitleToEdit: {
      name: 'Double click group title to edit'
    },
    Comfy_GroupSelectedNodes_Padding: { name: 'Group selected nodes padding' },
    Comfy_InvertMenuScrolling: { name: 'Invert Context Menu Scrolling' },
    Comfy_Keybinding_NewBindings: { name: 'Keybindings set by the user' },
    Comfy_Keybinding_UnsetBindings: { name: 'Keybindings unset by the user' },
    Comfy_LinkRelease_Action: { name: 'Action on link release (No modifier)' },
    Comfy_LinkRelease_ActionShift: { name: 'Action on link release (Shift)' },
    Comfy_LinkRenderMode: { name: 'Link Render Mode' },
    Comfy_Locale: { name: 'Language' },
    Comfy_MaskEditor_BrushAdjustmentSpeed: {
      name: 'Brush adjustment speed multiplier',
      tooltip:
        'Controls how quickly the brush size and hardness change when adjusting. Higher values mean faster changes.'
    },
    Comfy_MaskEditor_UseDominantAxis: {
      name: 'Lock brush adjustment to dominant axis',
      tooltip:
        'When enabled, brush adjustments will only affect size OR hardness based on which direction you move more'
    },
    Comfy_MaskEditor_UseNewEditor: {
      name: 'Use new mask editor',
      tooltip: 'Switch to the new mask editor interface'
    },
    Comfy_MenuPosition: { name: "Save legacy menu's position" },
    Comfy_ModelLibrary_AutoLoadAll: {
      name: 'Automatically load all model folders',
      tooltip:
        'If true, all folders will load as soon as you open the model library (this may cause delays while it loads). If false, root level model folders will only load once you click on them.'
    },
    Comfy_ModelLibrary_NameFormat: {
      name: 'What name to display in the model library tree view',
      tooltip:
        'Select "filename" to render a simplified view of the raw filename (without directory or ".safetensors" extension) in the model list. Select "title" to display the configurable model metadata title.'
    },
    Comfy_Node_AutoSnapLinkToSlot: {
      name: 'Auto snap link to node slot',
      tooltip:
        'When dragging a link over a node, the link automatically snap to a viable input slot on the node'
    },
    Comfy_Node_BypassAllLinksOnDelete: {
      name: 'Keep all links when deleting nodes',
      tooltip:
        'When deleting a node, attempt to reconnect all of its input and output links (bypassing the deleted node)'
    },
    Comfy_Node_DoubleClickTitleToEdit: {
      name: 'Double click node title to edit'
    },
    Comfy_Node_MiddleClickRerouteNode: {
      name: 'Middle-click creates a new Reroute node'
    },
    Comfy_Node_Opacity: { name: 'Node opacity' },
    Comfy_Node_ShowDeprecated: {
      name: 'Show deprecated nodes in search',
      tooltip:
        'Deprecated nodes are hidden by default in the UI, but remain functional in existing workflows that use them.'
    },
    Comfy_Node_ShowExperimental: {
      name: 'Show experimental nodes in search',
      tooltip:
        'Experimental nodes are marked as such in the UI and may be subject to significant changes or removal in future versions. Use with caution in production workflows'
    },
    Comfy_Node_SnapHighlightsNode: {
      name: 'Snap highlights node',
      tooltip:
        'When dragging a link over a node with viable input slot, highlight the node'
    },
    Comfy_NodeBadge_NodeIdBadgeMode: { name: 'Node ID badge mode' },
    Comfy_NodeBadge_NodeLifeCycleBadgeMode: {
      name: 'Node life cycle badge mode'
    },
    Comfy_NodeBadge_NodeSourceBadgeMode: { name: 'Node source badge mode' },
    Comfy_NodeInputConversionSubmenus: {
      name: 'In the node context menu, place the entries that convert between input/widget in sub-menus.'
    },
    Comfy_NodeLibrary_Bookmarks: {
      name: 'Node library bookmarks with display name (deprecated)'
    },
    Comfy_NodeLibrary_Bookmarks_V2: {
      name: 'Node library bookmarks v2 with unique name'
    },
    Comfy_NodeLibrary_BookmarksCustomization: {
      name: 'Node library bookmarks customization'
    },
    Comfy_NodeSearchBoxImpl: { name: 'Node search box implementation' },
    Comfy_NodeSearchBoxImpl_NodePreview: {
      name: 'Node preview',
      tooltip: 'Only applies to the default implementation'
    },
    Comfy_NodeSearchBoxImpl_ShowCategory: {
      name: 'Show node category in search results',
      tooltip: 'Only applies to the default implementation'
    },
    Comfy_NodeSearchBoxImpl_ShowIdName: {
      name: 'Show node id name in search results',
      tooltip: 'Only applies to the default implementation'
    },
    Comfy_NodeSearchBoxImpl_ShowNodeFrequency: {
      name: 'Show node frequency in search results',
      tooltip: 'Only applies to the default implementation'
    },
    Comfy_NodeSuggestions_number: {
      name: 'Number of nodes suggestions',
      tooltip: 'Only for litegraph searchbox/context menu'
    },
    Comfy_Pointer_ClickBufferTime: {
      name: 'Pointer click drift delay',
      tooltip:
        'After pressing a pointer button down, this is the maximum time (in milliseconds) that pointer movement can be ignored for.\n\nHelps prevent objects from being unintentionally nudged if the pointer is moved whilst clicking.'
    },
    Comfy_Pointer_ClickDrift: {
      name: 'Pointer click drift (maximum distance)',
      tooltip:
        'If the pointer moves more than this distance while holding a button down, it is considered dragging (rather than clicking).\n\nHelps prevent objects from being unintentionally nudged if the pointer is moved whilst clicking.'
    },
    Comfy_Pointer_DoubleClickTime: {
      name: 'Double click interval (maximum)',
      tooltip:
        'The maximum time in milliseconds between the two clicks of a double-click.  Increasing this value may assist if double-clicks are sometimes not registered.'
    },
    Comfy_PreviewFormat: {
      name: 'Preview image format',
      tooltip:
        'When displaying a preview in the image widget, convert it to a lightweight image, e.g. webp, jpeg, webp;50, etc.'
    },
    Comfy_PromptFilename: { name: 'Prompt for filename when saving workflow' },
    Comfy_Queue_ImageFit: { name: 'Queue image fit' },
    Comfy_Queue_MaxHistoryItems: {
      name: 'Queue history size',
      tooltip: 'The maximum number of tasks that show in the queue history.'
    },
    Comfy_QueueButton_BatchCountLimit: {
      name: 'Batch count limit',
      tooltip:
        'The maximum number of tasks added to the queue at one button click'
    },
    Comfy_RerouteBeta: {
      name: 'Opt-in to the reroute beta test',
      tooltip:
        'Enables the new native reroutes.\n\nReroutes can be added by holding alt and dragging from a link line, or on the link menu.\n\nDisabling this option is non-destructive - reroutes are hidden.'
    },
    Comfy_Server_LaunchArgs: {
      name: 'Server launch arguments',
      tooltip:
        'These are the actual arguments that are passed to the server when it is launched.'
    },
    Comfy_Server_ServerConfigValues: {
      name: 'Server config values for frontend display',
      tooltip: 'Server config values used for frontend display only'
    },
    Comfy_Settings_ExtensionPanel: {
      name: 'Show extension panel in settings dialog'
    },
    Comfy_Sidebar_Location: { name: 'Sidebar location' },
    Comfy_Sidebar_Size: { name: 'Sidebar size' },
    Comfy_SnapToGrid_GridSize: {
      name: 'Snap to grid size',
      tooltip:
        'When dragging and resizing nodes while holding shift they will be aligned to the grid, this controls the size of that grid.'
    },
    Comfy_TextareaWidget_FontSize: { name: 'Textarea widget font size' },
    Comfy_TextareaWidget_Spellcheck: { name: 'Textarea widget spellcheck' },
    Comfy_TreeExplorer_ItemPadding: { name: 'Tree explorer item padding' },
    Comfy_UseNewMenu: { name: 'Use new menu' },
    Comfy_Validation_NodeDefs: {
      name: 'Validate node definitions (slow)',
      tooltip:
        'Recommended for node developers. This will validate all node definitions on startup.'
    },
    Comfy_Validation_Workflows: { name: 'Validate workflows' },
    Comfy_WidgetControlMode: {
      name: 'Widget control mode',
      tooltip:
        'Controls when widget values are updated (randomize/increment/decrement), either before the prompt is queued or after.'
    },
    Comfy_Window_UnloadConfirmation: {
      name: 'Show confirmation when closing window'
    },
    Comfy_Workflow_ConfirmDelete: {
      name: 'Show confirmation when deleting workflows'
    },
    Comfy_Workflow_ShowMissingModelsWarning: {
      name: 'Show missing models warning'
    },
    Comfy_Workflow_ShowMissingNodesWarning: {
      name: 'Show missing nodes warning'
    },
    Comfy_Workflow_SortNodeIdOnSave: {
      name: 'Sort node IDs when saving workflow'
    },
    Comfy_Workflow_WorkflowTabsPosition: { name: 'Opened workflows position' },
    LiteGraph_Canvas_MaximumFps: {
      name: 'Maxium FPS',
      tooltip:
        'The maximum frames per second that the canvas is allowed to render. Caps GPU usage at the cost of smoothness. If 0, the screen refresh rate is used. Default: 0'
    },
    pysssss_SnapToGrid: { name: 'Always snap to grid' }
  },
  searchWorkflows$3 = 'Search Workflows',
  searchSettings$3 = 'Search Settings',
  searchNodes$3 = 'Search Nodes',
  searchModels$3 = 'Search Models',
  searchKeybindings$3 = 'Search Keybindings',
  searchExtensions$3 = 'Search Extensions',
  noResultsFound$3 = 'No Results Found',
  searchFailedMessage$3 =
    "We couldn't find any settings matching your search. Try adjusting your search terms.",
  noTasksFound$3 = 'No Tasks Found',
  noTasksFoundMessage$3 = 'There are no tasks in the queue.',
  newFolder$3 = 'New Folder',
  sideToolbar$3 = {
    themeToggle: 'Toggle Theme',
    logout: 'Logout',
    queue: 'Queue',
    nodeLibrary: 'Node Library',
    workflows: 'Workflows',
    browseTemplates: 'Browse example templates',
    openWorkflow: 'Open workflow in local file system',
    newBlankWorkflow: 'Create a new blank workflow',
    nodeLibraryTab: { sortOrder: 'Sort Order' },
    modelLibrary: 'Model Library',
    downloads: 'Downloads',
    queueTab: {
      showFlatList: 'Show Flat List',
      backToAllTasks: 'Back to All Tasks',
      containImagePreview: 'Fill Image Preview',
      coverImagePreview: 'Fit Image Preview',
      clearPendingTasks: 'Clear Pending Tasks',
      filter: 'Filter Outputs',
      filters: { hideCached: 'Hide Cached', hideCanceled: 'Hide Canceled' }
    },
    workflowTab: {
      confirmDeleteTitle: 'Delete workflow?',
      confirmDelete: 'Are you sure you want to delete this workflow?',
      deleted: 'Workflow deleted',
      deleteFailedTitle: 'Delete failed',
      deleteFailed: 'Attempt to delete the workflow failed.',
      dirtyCloseTitle: 'Save Changes?',
      dirtyClose:
        'The files below have been changed.  Would you like to save them before closing?',
      confirmOverwriteTitle: 'Overwrite existing file?',
      confirmOverwrite:
        'The file below already exists. Would you like to overwrite it?'
    }
  },
  menu$3 = {
    hideMenu: 'Hide Menu',
    showMenu: 'Show Menu',
    batchCount: 'Batch Count',
    batchCountTooltip:
      'The number of times the workflow generation should be queued',
    autoQueue: 'Auto Queue',
    disabled: 'Disabled',
    disabledTooltip: 'The workflow will not be automatically queued',
    instant: 'Instant',
    instantTooltip:
      'The workflow will be queued instantly after a generation finishes',
    onChange: 'On Change',
    onChangeTooltip: 'The workflow will be queued once a change is made',
    queueWorkflow: 'Queue workflow (Shift to queue at front)',
    queueWorkflowFront: 'Queue workflow at front',
    queue: 'Queue',
    execute: 'Execute',
    interrupt: 'Cancel current run',
    refresh: 'Refresh node definitions',
    clipspace: 'Open Clipspace',
    resetView: 'Reset canvas view',
    clear: 'Clear workflow',
    toggleBottomPanel: 'Toggle Bottom Panel'
  },
  tabMenu$3 = {
    duplicateTab: 'Duplicate Tab',
    closeTab: 'Close Tab',
    closeTabsToLeft: 'Close Tabs to Left',
    closeTabsToRight: 'Close Tabs to Right',
    closeOtherTabs: 'Close Other Tabs'
  },
  templateWorkflows$3 = {
    title: 'Get Started with a Template',
    template: {
      default: 'Image Generation',
      image2image: 'Image to Image',
      upscale: '2 Pass Upscale',
      flux_schnell: 'Flux Schnell'
    }
  },
  graphCanvasMenu$3 = {
    zoomIn: 'Zoom In',
    zoomOut: 'Zoom Out',
    resetView: 'Reset View',
    fitView: 'Fit View',
    selectMode: 'Select Mode',
    panMode: 'Pan Mode',
    toggleLinkVisibility: 'Toggle Link Visibility'
  },
  electronFileDownload$3 = {
    inProgress: 'In Progress',
    pause: 'Pause Download',
    paused: 'Paused',
    resume: 'Resume Download',
    cancel: 'Cancel Download',
    cancelled: 'Cancelled'
  },
  menuLabels$3 = {
    Workflow: 'Workflow',
    Edit: 'Edit',
    Help: 'Help',
    New: 'New',
    Open: 'Open',
    'Load Default Workflow': 'Load Default Workflow',
    Save: 'Save',
    'Save As': 'Save As',
    Export: 'Export',
    'Export (API)': 'Export (API)',
    Undo: 'Undo',
    Redo: 'Redo',
    'Clear Workflow': 'Clear Workflow',
    'Reset View': 'Reset View',
    Clipspace: 'Clipspace',
    'Refresh Node Definitions': 'Refresh Node Definitions',
    Interrupt: 'Interrupt',
    'Clear Pending Tasks': 'Clear Pending Tasks',
    'Browse Templates': 'Browse Templates',
    'Zoom In': 'Zoom In',
    'Zoom Out': 'Zoom Out',
    'Fit view to selected nodes': 'Fit view to selected nodes',
    'Toggle Lock': 'Toggle Lock',
    'Toggle Link Visibility': 'Toggle Link Visibility',
    'Queue Prompt': 'Queue Prompt',
    'Queue Prompt (Front)': 'Queue Prompt (Front)',
    Settings: 'Settings',
    'Group Selected Nodes': 'Group Selected Nodes',
    'Next Opened Workflow': 'Next Opened Workflow',
    'Previous Opened Workflow': 'Previous Opened Workflow',
    'Mute/Unmute Selected Nodes': 'Mute/Unmute Selected Nodes',
    'Bypass/Unbypass Selected Nodes': 'Bypass/Unbypass Selected Nodes',
    'Pin/Unpin Selected Nodes': 'Pin/Unpin Selected Nodes',
    'Pin/Unpin Selected Items': 'Pin/Unpin Selected Items',
    'Collapse/Expand Selected Nodes': 'Collapse/Expand Selected Nodes',
    'Toggle Theme': 'Toggle Theme',
    'Toggle Bottom Panel': 'Toggle Bottom Panel',
    'Toggle Focus Mode': 'Toggle Focus Mode',
    'Fit Group To Contents': 'Fit Group To Contents',
    'ComfyUI Issues': 'ComfyUI Issues',
    'ComfyUI Docs': 'ComfyUI Docs',
    'Comfy-Org Discord': 'Comfy-Org Discord',
    'Toggle Search Box': 'Toggle Search Box',
    Queue: 'Queue',
    'Node Library': 'Node Library',
    'Model Library': 'Model Library',
    Workflows: 'Workflows',
    Logs: 'Logs',
    Terminal: 'Terminal',
    'Convert selected nodes to group node':
      'Convert selected nodes to group node',
    'Ungroup selected group nodes': 'Ungroup selected group nodes',
    'Manage group nodes': 'Manage group nodes',
    'Open Logs Folder': 'Open Logs Folder',
    'Open Models Folder': 'Open Models Folder',
    'Open Outputs Folder': 'Open Outputs Folder',
    'Open Inputs Folder': 'Open Inputs Folder',
    'Open Custom Nodes Folder': 'Open Custom Nodes Folder',
    'Open extra_model_paths_yaml': 'Open extra_model_paths.yaml',
    'Open DevTools': 'Open DevTools',
    Feedback: 'Feedback',
    Reinstall: 'Reinstall',
    Restart: 'Restart'
  },
  desktopMenu$3 = {
    reinstall: 'Reinstall',
    confirmReinstall:
      'This will clear your extra_models_config.yaml file, and begin installation again.  Are you sure?'
  },
  settingsCategories$3 = {
    'Comfy-Desktop': 'Comfy-Desktop',
    General: 'General',
    Appearance: 'Appearance',
    ColorPalette: 'Color Palette',
    Comfy: 'Comfy',
    Workflow: 'Workflow',
    DevMode: 'Dev Mode',
    LiteGraph: 'Lite Graph',
    'Node Widget': 'Node Widget',
    Node: 'Node',
    EditAttention: 'Edit Attention',
    Extension: 'Extension',
    Canvas: 'Canvas',
    Link: 'Link',
    Group: 'Group',
    Menu: 'Menu',
    Keybinding: 'Keybinding',
    LinkRelease: 'Link Release',
    Graph: 'Graph',
    Locale: 'Locale',
    'Mask Editor': 'Mask Editor',
    BrushAdjustment: 'Brush Adjustment',
    NewEditor: 'New Editor',
    ModelLibrary: 'Model Library',
    NodeInputConversionSubmenus: 'Node Input Conversion Submenus',
    NodeLibrary: 'Node Library',
    'Node Search Box': 'Node Search Box',
    Pointer: 'Pointer',
    Queue: 'Queue',
    QueueButton: 'Queue Button',
    RerouteBeta: 'Reroute Beta',
    Server: 'Server',
    Settings: 'Settings',
    Sidebar: 'Sidebar',
    'Tree Explorer': 'Tree Explorer',
    Validation: 'Validation',
    Window: 'Window',
    'Server-Config': 'Server-Config',
    About: 'About'
  },
  serverConfigItems$3 = {
    'tls-keyfile': { name: 'TLS Key File: Path to TLS key file for HTTPS' },
    'tls-certfile': {
      name: 'TLS Certificate File: Path to TLS certificate file for HTTPS'
    },
    'enable-cors-header': {
      name: 'Enable CORS header: Use "*" for all origins or specify domain'
    },
    'max-upload-size': { name: 'Maximum upload size (MB)' },
    'cuda-device': { name: 'CUDA device index to use' },
    'cuda-malloc': { name: 'Use CUDA malloc for memory allocation' },
    'global-precision': {
      name: 'Global floating point precision',
      tooltip: 'Global floating point precision'
    },
    'unet-precision': { name: 'UNET precision', tooltip: 'UNET precision' },
    'vae-precision': { name: 'VAE precision', tooltip: 'VAE precision' },
    'cpu-vae': { name: 'Run VAE on CPU' },
    'text-encoder-precision': {
      name: 'Text Encoder precision',
      tooltip: 'Text Encoder precision'
    },
    'force-channels-last': { name: 'Force channels-last memory format' },
    directml: { name: 'DirectML device index' },
    'disable-ipex-optimize': { name: 'Disable IPEX optimization' },
    'preview-method': { name: 'Method used for latent previews' },
    'preview-size': { name: 'Size of preview images' },
    'cache-classic': { name: 'Use classic cache system' },
    'cache-lru': {
      name: 'Use LRU caching with a maximum of N node results cached.',
      tooltip: 'May use more RAM/VRAM.'
    },
    'cross-attention-method': { name: 'Cross attention method' },
    'disable-xformers': { name: 'Disable xFormers optimization' },
    'force-upcast-attention': { name: 'Force attention upcast' },
    'dont-upcast-attention': { name: 'Prevent attention upcast' },
    'vram-management': { name: 'VRAM management mode' },
    'reserve-vram': {
      name: 'Reserved VRAM (GB)',
      tooltip:
        'Set the amount of vram in GB you want to reserve for use by your OS/other software. By default some amount is reverved depending on your OS.'
    },
    'default-hashing-function': {
      name: 'Default hashing function for model files'
    },
    'disable-smart-memory': {
      name: 'Disable smart memory management',
      tooltip:
        'Force ComfyUI to aggressively offload to regular ram instead of keeping models in vram when it can.'
    },
    deterministic: {
      name: 'Make pytorch use slower deterministic algorithms when it can.',
      tooltip:
        'Note that this might not make images deterministic in all cases.'
    },
    fast: {
      name: 'Enable some untested and potentially quality deteriorating optimizations.'
    },
    'dont-print-server': { name: "Don't print server output to console." },
    'disable-metadata': { name: 'Disable saving prompt metadata in files.' },
    'disable-all-custom-nodes': { name: 'Disable loading all custom nodes.' },
    'log-level': { name: 'Logging verbosity level' }
  },
  serverConfigCategories$3 = {
    Network: 'Network',
    CUDA: 'CUDA',
    Inference: 'Inference',
    Memory: 'Memory',
    Preview: 'Preview',
    Cache: 'Cache',
    Attention: 'Attention',
    General: 'General'
  },
  nodeDefs$3 = {
    AddNoise: { display_name: 'AddNoise' },
    AlignYourStepsScheduler: { display_name: 'AlignYourStepsScheduler' },
    BasicGuider: { display_name: 'BasicGuider' },
    BasicScheduler: { display_name: 'BasicScheduler' },
    BetaSamplingScheduler: { display_name: 'BetaSamplingScheduler' },
    Canny: { display_name: 'Canny' },
    CFGGuider: { display_name: 'CFGGuider' },
    CheckpointLoader: {
      display_name: 'Load Checkpoint With Config (DEPRECATED)'
    },
    CheckpointLoaderSimple: {
      display_name: 'Load Checkpoint',
      description:
        'Loads a diffusion model checkpoint, diffusion models are used to denoise latents.'
    },
    CheckpointSave: { display_name: 'Save Checkpoint' },
    CLIPAttentionMultiply: { display_name: 'CLIPAttentionMultiply' },
    CLIPLoader: {
      display_name: 'Load CLIP',
      description:
        '[Recipes]\n\nstable_diffusion: clip-l\nstable_cascade: clip-g\nsd3: t5 / clip-g / clip-l\nstable_audio: t5\nmochi: t5'
    },
    CLIPMergeAdd: { display_name: 'CLIPMergeAdd' },
    CLIPMergeSimple: { display_name: 'CLIPMergeSimple' },
    CLIPMergeSubtract: { display_name: 'CLIPMergeSubtract' },
    CLIPSave: { display_name: 'CLIPSave' },
    CLIPSetLastLayer: { display_name: 'CLIP Set Last Layer' },
    CLIPTextEncode: {
      display_name: 'CLIP Text Encode (Prompt)',
      description:
        'Encodes a text prompt using a CLIP model into an embedding that can be used to guide the diffusion model towards generating specific images.'
    },
    CLIPTextEncodeControlnet: { display_name: 'CLIPTextEncodeControlnet' },
    CLIPTextEncodeFlux: { display_name: 'CLIPTextEncodeFlux' },
    CLIPTextEncodeHunyuanDiT: { display_name: 'CLIPTextEncodeHunyuanDiT' },
    CLIPTextEncodeSD3: { display_name: 'CLIPTextEncodeSD3' },
    CLIPTextEncodeSDXL: { display_name: 'CLIPTextEncodeSDXL' },
    CLIPTextEncodeSDXLRefiner: { display_name: 'CLIPTextEncodeSDXLRefiner' },
    CLIPVisionEncode: { display_name: 'CLIP Vision Encode' },
    CLIPVisionLoader: { display_name: 'Load CLIP Vision' },
    CombineHooks2: { display_name: 'Combine Hooks [2]' },
    CombineHooks4: { display_name: 'Combine Hooks [4]' },
    CombineHooks8: { display_name: 'Combine Hooks [8]' },
    ConditioningAverage: { display_name: 'ConditioningAverage' },
    ConditioningCombine: { display_name: 'Conditioning (Combine)' },
    ConditioningConcat: { display_name: 'Conditioning (Concat)' },
    ConditioningSetArea: { display_name: 'Conditioning (Set Area)' },
    ConditioningSetAreaPercentage: {
      display_name: 'Conditioning (Set Area with Percentage)'
    },
    ConditioningSetAreaStrength: {
      display_name: 'ConditioningSetAreaStrength'
    },
    ConditioningSetDefaultCombine: { display_name: 'Cond Set Default Combine' },
    ConditioningSetMask: { display_name: 'Conditioning (Set Mask)' },
    ConditioningSetProperties: { display_name: 'Cond Set Props' },
    ConditioningSetPropertiesAndCombine: {
      display_name: 'Cond Set Props Combine'
    },
    ConditioningSetTimestepRange: {
      display_name: 'ConditioningSetTimestepRange'
    },
    ConditioningTimestepsRange: { display_name: 'Timesteps Range' },
    ConditioningZeroOut: { display_name: 'ConditioningZeroOut' },
    ControlNetApply: { display_name: 'Apply ControlNet (OLD)' },
    ControlNetApplyAdvanced: { display_name: 'Apply ControlNet' },
    ControlNetApplySD3: { display_name: 'Apply Controlnet with VAE' },
    ControlNetInpaintingAliMamaApply: {
      display_name: 'ControlNetInpaintingAliMamaApply'
    },
    ControlNetLoader: { display_name: 'Load ControlNet Model' },
    CreateHookKeyframe: { display_name: 'Create Hook Keyframe' },
    CreateHookKeyframesFromFloats: {
      display_name: 'Create Hook Keyframes From Floats'
    },
    CreateHookKeyframesInterpolated: {
      display_name: 'Create Hook Keyframes Interp.'
    },
    CreateHookLora: { display_name: 'Create Hook LoRA' },
    CreateHookLoraModelOnly: { display_name: 'Create Hook LoRA (MO)' },
    CreateHookModelAsLora: { display_name: 'Create Hook Model as LoRA' },
    CreateHookModelAsLoraModelOnly: {
      display_name: 'Create Hook Model as LoRA (MO)'
    },
    CropMask: { display_name: 'CropMask' },
    DevToolsDeprecatedNode: {
      display_name: 'Deprecated Node',
      description: 'A deprecated node'
    },
    DevToolsErrorRaiseNode: {
      display_name: 'Raise Error',
      description: 'Raise an error for development purposes'
    },
    DevToolsErrorRaiseNodeWithMessage: {
      display_name: 'Raise Error with Message',
      description: 'Raise an error with message for development purposes'
    },
    DevToolsExperimentalNode: {
      display_name: 'Experimental Node',
      description: 'A experimental node'
    },
    DevToolsLongComboDropdown: {
      display_name: 'Long Combo Dropdown',
      description: 'A long combo dropdown'
    },
    DevToolsNodeWithForceInput: {
      display_name: 'Node With Force Input',
      description: 'A node with a forced input'
    },
    DevToolsNodeWithOnlyOptionalInput: {
      display_name: 'Node With Only Optional Input',
      description: 'A node with only optional input'
    },
    DevToolsNodeWithOptionalInput: {
      display_name: 'Node With Optional Input',
      description: 'A node with an optional input'
    },
    DevToolsNodeWithOutputList: {
      display_name: 'Node With Output List',
      description: 'A node with an output list'
    },
    DevToolsNodeWithStringInput: {
      display_name: 'Node With String Input',
      description: 'A node with a string input'
    },
    DevToolsNodeWithUnionInput: {
      display_name: 'Node With Union Input',
      description: 'A node with a union input'
    },
    DiffControlNetLoader: { display_name: 'Load ControlNet Model (diff)' },
    DifferentialDiffusion: { display_name: 'Differential Diffusion' },
    DiffusersLoader: { display_name: 'DiffusersLoader' },
    DisableNoise: { display_name: 'DisableNoise' },
    DualCFGGuider: { display_name: 'DualCFGGuider' },
    DualCLIPLoader: {
      display_name: 'DualCLIPLoader',
      description:
        '[Recipes]\n\nsdxl: clip-l, clip-g\nsd3: clip-l, clip-g / clip-l, t5 / clip-g, t5\nflux: clip-l, t5'
    },
    EmptyImage: { display_name: 'EmptyImage' },
    EmptyLatentAudio: { display_name: 'EmptyLatentAudio' },
    EmptyLatentImage: {
      display_name: 'Empty Latent Image',
      description:
        'Create a new batch of empty latent images to be denoised via sampling.'
    },
    EmptyLTXVLatentVideo: { display_name: 'EmptyLTXVLatentVideo' },
    EmptyMochiLatentVideo: { display_name: 'EmptyMochiLatentVideo' },
    EmptySD3LatentImage: { display_name: 'EmptySD3LatentImage' },
    ExponentialScheduler: { display_name: 'ExponentialScheduler' },
    FeatherMask: { display_name: 'FeatherMask' },
    FlipSigmas: { display_name: 'FlipSigmas' },
    FluxGuidance: { display_name: 'FluxGuidance' },
    FreeU: { display_name: 'FreeU' },
    FreeU_V2: { display_name: 'FreeU_V2' },
    GITSScheduler: { display_name: 'GITSScheduler' },
    GLIGENLoader: { display_name: 'GLIGENLoader' },
    GLIGENTextBoxApply: { display_name: 'GLIGENTextBoxApply' },
    GrowMask: { display_name: 'GrowMask' },
    HypernetworkLoader: { display_name: 'HypernetworkLoader' },
    HyperTile: { display_name: 'HyperTile' },
    ImageBatch: { display_name: 'Batch Images' },
    ImageBlend: { display_name: 'Image Blend' },
    ImageBlur: { display_name: 'Image Blur' },
    ImageColorToMask: { display_name: 'ImageColorToMask' },
    ImageCompositeMasked: { display_name: 'ImageCompositeMasked' },
    ImageCrop: { display_name: 'Image Crop' },
    ImageFromBatch: { display_name: 'ImageFromBatch' },
    ImageInvert: { display_name: 'Invert Image' },
    ImageOnlyCheckpointLoader: {
      display_name: 'Image Only Checkpoint Loader (img2vid model)'
    },
    ImageOnlyCheckpointSave: { display_name: 'ImageOnlyCheckpointSave' },
    ImagePadForOutpaint: { display_name: 'Pad Image for Outpainting' },
    ImageQuantize: { display_name: 'Image Quantize' },
    ImageScale: { display_name: 'Upscale Image' },
    ImageScaleBy: { display_name: 'Upscale Image By' },
    ImageScaleToTotalPixels: { display_name: 'Scale Image to Total Pixels' },
    ImageSharpen: { display_name: 'Image Sharpen' },
    ImageToMask: { display_name: 'Convert Image to Mask' },
    ImageUpscaleWithModel: { display_name: 'Upscale Image (using Model)' },
    InpaintModelConditioning: { display_name: 'InpaintModelConditioning' },
    InstructPixToPixConditioning: {
      display_name: 'InstructPixToPixConditioning'
    },
    InvertMask: { display_name: 'InvertMask' },
    JoinImageWithAlpha: { display_name: 'Join Image with Alpha' },
    KarrasScheduler: { display_name: 'KarrasScheduler' },
    KSampler: {
      display_name: 'KSampler',
      description:
        'Uses the provided model, positive and negative conditioning to denoise the latent image.'
    },
    KSamplerAdvanced: { display_name: 'KSampler (Advanced)' },
    KSamplerSelect: { display_name: 'KSamplerSelect' },
    LaplaceScheduler: { display_name: 'LaplaceScheduler' },
    LatentAdd: { display_name: 'LatentAdd' },
    LatentApplyOperation: { display_name: 'LatentApplyOperation' },
    LatentApplyOperationCFG: { display_name: 'LatentApplyOperationCFG' },
    LatentBatch: { display_name: 'LatentBatch' },
    LatentBatchSeedBehavior: { display_name: 'LatentBatchSeedBehavior' },
    LatentBlend: { display_name: 'Latent Blend' },
    LatentComposite: { display_name: 'Latent Composite' },
    LatentCompositeMasked: { display_name: 'LatentCompositeMasked' },
    LatentCrop: { display_name: 'Crop Latent' },
    LatentFlip: { display_name: 'Flip Latent' },
    LatentFromBatch: { display_name: 'Latent From Batch' },
    LatentInterpolate: { display_name: 'LatentInterpolate' },
    LatentMultiply: { display_name: 'LatentMultiply' },
    LatentOperationSharpen: { display_name: 'LatentOperationSharpen' },
    LatentOperationTonemapReinhard: {
      display_name: 'LatentOperationTonemapReinhard'
    },
    LatentRotate: { display_name: 'Rotate Latent' },
    LatentSubtract: { display_name: 'LatentSubtract' },
    LatentUpscale: { display_name: 'Upscale Latent' },
    LatentUpscaleBy: { display_name: 'Upscale Latent By' },
    LoadAudio: { display_name: 'LoadAudio' },
    LoadImage: { display_name: 'Load Image' },
    LoadImageMask: { display_name: 'Load Image (as Mask)' },
    LoadLatent: { display_name: 'LoadLatent' },
    LoraLoader: {
      display_name: 'Load LoRA',
      description:
        'LoRAs are used to modify diffusion and CLIP models, altering the way in which latents are denoised such as applying styles. Multiple LoRA nodes can be linked together.'
    },
    LoraLoaderModelOnly: {
      display_name: 'LoraLoaderModelOnly',
      description:
        'LoRAs are used to modify diffusion and CLIP models, altering the way in which latents are denoised such as applying styles. Multiple LoRA nodes can be linked together.'
    },
    LoraSave: { display_name: 'Extract and Save Lora' },
    LTXVConditioning: { display_name: 'LTXVConditioning' },
    LTXVImgToVideo: { display_name: 'LTXVImgToVideo' },
    LTXVScheduler: { display_name: 'LTXVScheduler' },
    MaskComposite: { display_name: 'MaskComposite' },
    MaskToImage: { display_name: 'Convert Mask to Image' },
    ModelMergeAdd: { display_name: 'ModelMergeAdd' },
    ModelMergeAuraflow: { display_name: 'ModelMergeAuraflow' },
    ModelMergeBlocks: { display_name: 'ModelMergeBlocks' },
    ModelMergeFlux1: { display_name: 'ModelMergeFlux1' },
    ModelMergeLTXV: { display_name: 'ModelMergeLTXV' },
    ModelMergeMochiPreview: { display_name: 'ModelMergeMochiPreview' },
    ModelMergeSD1: { display_name: 'ModelMergeSD1' },
    ModelMergeSD2: { display_name: 'ModelMergeSD2' },
    ModelMergeSD3_2B: { display_name: 'ModelMergeSD3_2B' },
    ModelMergeSD35_Large: { display_name: 'ModelMergeSD35_Large' },
    ModelMergeSDXL: { display_name: 'ModelMergeSDXL' },
    ModelMergeSimple: { display_name: 'ModelMergeSimple' },
    ModelMergeSubtract: { display_name: 'ModelMergeSubtract' },
    ModelSamplingAuraFlow: { display_name: 'ModelSamplingAuraFlow' },
    ModelSamplingContinuousEDM: { display_name: 'ModelSamplingContinuousEDM' },
    ModelSamplingContinuousV: { display_name: 'ModelSamplingContinuousV' },
    ModelSamplingDiscrete: { display_name: 'ModelSamplingDiscrete' },
    ModelSamplingFlux: { display_name: 'ModelSamplingFlux' },
    ModelSamplingLTXV: { display_name: 'ModelSamplingLTXV' },
    ModelSamplingSD3: { display_name: 'ModelSamplingSD3' },
    ModelSamplingStableCascade: { display_name: 'ModelSamplingStableCascade' },
    ModelSave: { display_name: 'ModelSave' },
    Morphology: { display_name: 'ImageMorphology' },
    PairConditioningCombine: { display_name: 'Cond Pair Combine' },
    PairConditioningSetDefaultCombine: {
      display_name: 'Cond Pair Set Default Combine'
    },
    PairConditioningSetProperties: { display_name: 'Cond Pair Set Props' },
    PairConditioningSetPropertiesAndCombine: {
      display_name: 'Cond Pair Set Props Combine'
    },
    PatchModelAddDownscale: {
      display_name: 'PatchModelAddDownscale (Kohya Deep Shrink)'
    },
    PerpNeg: { display_name: 'Perp-Neg (DEPRECATED by PerpNegGuider)' },
    PerpNegGuider: { display_name: 'PerpNegGuider' },
    PerturbedAttentionGuidance: { display_name: 'PerturbedAttentionGuidance' },
    PhotoMakerEncode: { display_name: 'PhotoMakerEncode' },
    PhotoMakerLoader: { display_name: 'PhotoMakerLoader' },
    PolyexponentialScheduler: { display_name: 'PolyexponentialScheduler' },
    PorterDuffImageComposite: { display_name: 'Porter-Duff Image Composite' },
    PreviewAudio: { display_name: 'PreviewAudio' },
    PreviewImage: {
      display_name: 'Preview Image',
      description: 'Saves the input images to your ComfyUI output directory.'
    },
    RandomNoise: { display_name: 'RandomNoise' },
    RebatchImages: { display_name: 'Rebatch Images' },
    RebatchLatents: { display_name: 'Rebatch Latents' },
    RepeatImageBatch: { display_name: 'RepeatImageBatch' },
    RepeatLatentBatch: { display_name: 'Repeat Latent Batch' },
    RescaleCFG: { display_name: 'RescaleCFG' },
    SamplerCustom: { display_name: 'SamplerCustom' },
    SamplerCustomAdvanced: { display_name: 'SamplerCustomAdvanced' },
    SamplerDPMAdaptative: { display_name: 'SamplerDPMAdaptative' },
    SamplerDPMPP_2M_SDE: { display_name: 'SamplerDPMPP_2M_SDE' },
    SamplerDPMPP_2S_Ancestral: { display_name: 'SamplerDPMPP_2S_Ancestral' },
    SamplerDPMPP_3M_SDE: { display_name: 'SamplerDPMPP_3M_SDE' },
    SamplerDPMPP_SDE: { display_name: 'SamplerDPMPP_SDE' },
    SamplerEulerAncestral: { display_name: 'SamplerEulerAncestral' },
    SamplerEulerAncestralCFGPP: { display_name: 'SamplerEulerAncestralCFG++' },
    SamplerEulerCFGpp: { display_name: 'SamplerEulerCFG++' },
    SamplerLCMUpscale: { display_name: 'SamplerLCMUpscale' },
    SamplerLMS: { display_name: 'SamplerLMS' },
    SaveAnimatedPNG: { display_name: 'SaveAnimatedPNG' },
    SaveAnimatedWEBP: { display_name: 'SaveAnimatedWEBP' },
    SaveAudio: { display_name: 'SaveAudio' },
    SaveImage: {
      display_name: 'Save Image',
      description: 'Saves the input images to your ComfyUI output directory.'
    },
    SaveImageWebsocket: { display_name: 'SaveImageWebsocket' },
    SaveLatent: { display_name: 'SaveLatent' },
    SD_4XUpscale_Conditioning: { display_name: 'SD_4XUpscale_Conditioning' },
    SDTurboScheduler: { display_name: 'SDTurboScheduler' },
    SelfAttentionGuidance: { display_name: 'Self-Attention Guidance' },
    SetClipHooks: { display_name: 'Set CLIP Hooks' },
    SetHookKeyframes: { display_name: 'Set Hook Keyframes' },
    SetLatentNoiseMask: { display_name: 'Set Latent Noise Mask' },
    SetUnionControlNetType: { display_name: 'SetUnionControlNetType' },
    SkipLayerGuidanceDiT: {
      display_name: 'SkipLayerGuidanceDiT',
      description:
        'Generic version of SkipLayerGuidance node that can be used on every DiT model.'
    },
    SkipLayerGuidanceSD3: {
      display_name: 'SkipLayerGuidanceSD3',
      description:
        'Generic version of SkipLayerGuidance node that can be used on every DiT model.'
    },
    SolidMask: { display_name: 'SolidMask' },
    SplitImageWithAlpha: { display_name: 'Split Image with Alpha' },
    SplitSigmas: { display_name: 'SplitSigmas' },
    SplitSigmasDenoise: { display_name: 'SplitSigmasDenoise' },
    StableCascade_EmptyLatentImage: {
      display_name: 'StableCascade_EmptyLatentImage'
    },
    StableCascade_StageB_Conditioning: {
      display_name: 'StableCascade_StageB_Conditioning'
    },
    StableCascade_StageC_VAEEncode: {
      display_name: 'StableCascade_StageC_VAEEncode'
    },
    StableCascade_SuperResolutionControlnet: {
      display_name: 'StableCascade_SuperResolutionControlnet'
    },
    StableZero123_Conditioning: { display_name: 'StableZero123_Conditioning' },
    StableZero123_Conditioning_Batched: {
      display_name: 'StableZero123_Conditioning_Batched'
    },
    StyleModelApply: { display_name: 'Apply Style Model' },
    StyleModelLoader: { display_name: 'Load Style Model' },
    SV3D_Conditioning: { display_name: 'SV3D_Conditioning' },
    SVD_img2vid_Conditioning: { display_name: 'SVD_img2vid_Conditioning' },
    ThresholdMask: { display_name: 'ThresholdMask' },
    TomePatchModel: { display_name: 'TomePatchModel' },
    TorchCompileModel: { display_name: 'TorchCompileModel' },
    TripleCLIPLoader: {
      display_name: 'TripleCLIPLoader',
      description: '[Recipes]\n\nsd3: clip-l, clip-g, t5'
    },
    unCLIPCheckpointLoader: { display_name: 'unCLIPCheckpointLoader' },
    unCLIPConditioning: { display_name: 'unCLIPConditioning' },
    UNetCrossAttentionMultiply: { display_name: 'UNetCrossAttentionMultiply' },
    UNETLoader: { display_name: 'Load Diffusion Model' },
    UNetSelfAttentionMultiply: { display_name: 'UNetSelfAttentionMultiply' },
    UNetTemporalAttentionMultiply: {
      display_name: 'UNetTemporalAttentionMultiply'
    },
    UpscaleModelLoader: { display_name: 'Load Upscale Model' },
    VAEDecode: {
      display_name: 'VAE Decode',
      description: 'Decodes latent images back into pixel space images.'
    },
    VAEDecodeAudio: { display_name: 'VAEDecodeAudio' },
    VAEDecodeTiled: { display_name: 'VAE Decode (Tiled)' },
    VAEEncode: { display_name: 'VAE Encode' },
    VAEEncodeAudio: { display_name: 'VAEEncodeAudio' },
    VAEEncodeForInpaint: { display_name: 'VAE Encode (for Inpainting)' },
    VAEEncodeTiled: { display_name: 'VAE Encode (Tiled)' },
    VAELoader: { display_name: 'Load VAE' },
    VAESave: { display_name: 'VAESave' },
    VideoLinearCFGGuidance: { display_name: 'VideoLinearCFGGuidance' },
    VideoTriangleCFGGuidance: { display_name: 'VideoTriangleCFGGuidance' },
    VPScheduler: { display_name: 'VPScheduler' },
    WebcamCapture: { display_name: 'Webcam Capture' }
  },
  en = {
    welcome: welcome$3,
    userSelect: userSelect$3,
    notSupported: notSupported$3,
    downloadGit: downloadGit$3,
    install: install$3,
    serverStart: serverStart$3,
    serverConfig: serverConfig$3,
    currentUser: currentUser$3,
    empty: empty$3,
    noWorkflowsFound: noWorkflowsFound$3,
    comingSoon: comingSoon$3,
    firstTimeUIMessage: firstTimeUIMessage$3,
    download: download$3,
    loadAllFolders: loadAllFolders$3,
    refresh: refresh$3,
    terminal: terminal$3,
    logs: logs$3,
    videoFailedToLoad: videoFailedToLoad$3,
    extensionName: extensionName$3,
    reloadToApplyChanges: reloadToApplyChanges$3,
    insert: insert$3,
    systemInfo: systemInfo$3,
    devices: devices$3,
    about: about$3,
    add: add$3,
    confirm: confirm$4,
    reset: reset$3,
    resetKeybindingsTooltip: resetKeybindingsTooltip$3,
    customizeFolder: customizeFolder$3,
    icon: icon$3,
    color: color$3,
    bookmark: bookmark$3,
    folder: folder$3,
    star: star$3,
    heart: heart$3,
    file: file$3,
    inbox: inbox$3,
    box: box$3,
    briefcase: briefcase$3,
    error: error$3,
    loading: loading$3,
    findIssues: findIssues$3,
    reportIssue: reportIssue$3,
    reportIssueTooltip: reportIssueTooltip$3,
    reportSent: reportSent$3,
    copyToClipboard: copyToClipboard$3,
    openNewIssue: openNewIssue$3,
    showReport: showReport$3,
    imageFailedToLoad: imageFailedToLoad$3,
    reconnecting: reconnecting$3,
    reconnected: reconnected$3,
    delete: 'Delete',
    rename: rename$3,
    save: save$3,
    no: no$3,
    cancel: cancel$3,
    overwrite: overwrite$3,
    customize: customize$3,
    experimental: experimental$3,
    deprecated: deprecated$3,
    loadWorkflow: loadWorkflow$3,
    goToNode: goToNode$3,
    settings: settings$3,
    settingsDialog: settingsDialog$3,
    searchWorkflows: searchWorkflows$3,
    searchSettings: searchSettings$3,
    searchNodes: searchNodes$3,
    searchModels: searchModels$3,
    searchKeybindings: searchKeybindings$3,
    searchExtensions: searchExtensions$3,
    noResultsFound: noResultsFound$3,
    searchFailedMessage: searchFailedMessage$3,
    noTasksFound: noTasksFound$3,
    noTasksFoundMessage: noTasksFoundMessage$3,
    newFolder: newFolder$3,
    sideToolbar: sideToolbar$3,
    menu: menu$3,
    tabMenu: tabMenu$3,
    templateWorkflows: templateWorkflows$3,
    graphCanvasMenu: graphCanvasMenu$3,
    electronFileDownload: electronFileDownload$3,
    menuLabels: menuLabels$3,
    desktopMenu: desktopMenu$3,
    settingsCategories: settingsCategories$3,
    serverConfigItems: serverConfigItems$3,
    serverConfigCategories: serverConfigCategories$3,
    nodeDefs: nodeDefs$3
  },
  about$2 = '关于',
  add$2 = '添加',
  bookmark$2 = '书签',
  box$2 = '盒子',
  briefcase$2 = '公文包',
  cancel$2 = '取消',
  color$2 = '颜色',
  comingSoon$2 = '敬请期待',
  confirm$3 = '确认',
  copyToClipboard$2 = '复制到剪贴板',
  currentUser$2 = '当前用户',
  customize$2 = '定制',
  customizeFolder$2 = '定制文件夹',
  deprecated$2 = '弃用',
  desktopMenu$2 = {
    confirmReinstall:
      '这将清除您的 extra_models_config.yaml 文件，并重新开始安装。您确定吗？',
    reinstall: '重新安装'
  },
  devices$2 = '设备',
  download$2 = '下载',
  downloadGit$2 = {
    gitWebsite: '下载 git',
    instructions:
      '请下载并安装适合您操作系统的最新版本。下面的下载 git 按钮将打开 git-scm.com 下载页面。',
    message: '无法找到 git。正常操作需要一个可用的 git 副本。',
    skip: '跳过',
    title: '下载 git',
    warning:
      '如果您确定不需要安装 git，或者这是一个错误，您可以点击跳过以绕过此检查。当前不支持在没有可用 git 副本的情况下运行 ComfyUI。'
  },
  electronFileDownload$2 = {
    cancel: '取消下载',
    cancelled: '已取消',
    inProgress: '进行中',
    pause: '暂停下载',
    paused: '已暂停',
    resume: '恢复下载'
  },
  empty$2 = '空',
  error$2 = '错误',
  experimental$2 = 'BETA',
  extensionName$2 = '扩展名称',
  file$2 = '文件',
  findIssues$2 = '查找 Issue',
  firstTimeUIMessage$2 =
    '这是您第一次使用新界面。选择“菜单 > 使用新菜单 > Disabled”以恢复旧界面。',
  folder$2 = '文件夹',
  goToNode$2 = '前往节点',
  graphCanvasMenu$2 = {
    fitView: '适应视图',
    panMode: '平移模式',
    resetView: '重置视图',
    selectMode: '选择模式',
    toggleLinkVisibility: '切换链接可见性',
    zoomIn: '放大',
    zoomOut: '缩小'
  },
  heart$2 = '心',
  icon$2 = '图标',
  imageFailedToLoad$2 = '图像加载失败',
  inbox$2 = '收件箱',
  insert$2 = '插入',
  install$2 = {
    appDataLocationTooltip:
      'ComfyUI 的应用数据目录。存储：\n- 日志\n- 服务器配置',
    appPathLocationTooltip: 'ComfyUI 的应用资产目录。存储 ComfyUI 代码和资产',
    chooseInstallationLocation: '选择安装位置',
    customNodes: '自定义节点',
    customNodesDescription:
      '引用现有 ComfyUI 安装的自定义节点文件并安装其依赖项。',
    desktopAppSettings: '桌面应用设置',
    desktopAppSettingsDescription:
      '配置 ComfyUI 在桌面上的行为。您可以稍后更改这些设置。',
    desktopSettings: '桌面设置',
    failedToSelectDirectory: '选择目录失败',
    installLocation: '安装位置',
    installLocationDescription:
      '选择 ComfyUI 用户数据的目录。将安装一个 Python 环境到所选位置。请确保所选磁盘有足够的空间（约 15GB）。',
    installLocationTooltip:
      'ComfyUI 的用户数据目录。存储：\n- Python 环境\n- 模型\n- 自定义节点\n',
    migrateFromExistingInstallation: '从现有安装迁移',
    migration: '迁移',
    migrationOptional: '迁移是可选的。如果您没有现有安装，可以跳过此步骤。',
    migrationSourcePathDescription:
      '如果您有现有的 ComfyUI 安装，我们可以将您的现有用户文件和模型复制/链接到新安装。',
    pathValidationFailed: '路径验证失败',
    selectItemsToMigrate: '选择要迁移的项目',
    settings: {
      allowMetrics: '崩溃报告',
      allowMetricsDescription:
        '通过发送匿名崩溃报告来帮助改善 ComfyUI。不会收集任何个人信息或工作流内容。您可以随时在设置菜单中禁用此功能。',
      autoUpdate: '自动更新',
      autoUpdateDescription:
        '在更新可用时自动下载并安装更新。您将在安装更新之前始终收到通知。',
      dataCollectionDialog: {
        customNodeConfigurations: '自定义节点配置',
        errorReports: '错误信息和堆栈跟踪',
        fileSystemInformation: '文件系统信息',
        personalInformation: '个人信息',
        systemInfo: '硬件、操作系统类型和应用版本',
        title: '关于数据收集',
        whatWeCollect: '我们收集的内容：',
        whatWeDoNotCollect: '我们不收集的内容：',
        workflowContent: '工作流内容',
        workflowContents: '工作流内容'
      },
      learnMoreAboutData: '了解更多关于数据收集的信息'
    },
    systemLocations: '系统位置'
  },
  loadAllFolders$2 = '加载所有文件夹',
  loadWorkflow$2 = '加载工作流',
  loading$2 = '加载中',
  logs$2 = '日志',
  menu$2 = {
    autoQueue: '自动执行',
    batchCount: '批次数量',
    batchCountTooltip: '工作流生成次数',
    clear: '清空工作流',
    clipspace: '打开剪贴板',
    disabled: '禁用',
    disabledTooltip: '工作流将不会自动执行',
    execute: '执行',
    hideMenu: '隐藏菜单',
    instant: '实时',
    instantTooltip: '工作流将会在生成完成后立即执行',
    interrupt: '取消当前任务',
    onChange: '更改时',
    onChangeTooltip: '一旦进行更改，工作流将被排队',
    queue: '执行',
    queueWorkflow: '执行 (Shift 执行到队列首)',
    queueWorkflowFront: '执行到队列首',
    refresh: '刷新节点',
    resetView: '重置画布视图',
    showMenu: '显示菜单',
    toggleBottomPanel: '底部面板'
  },
  menuLabels$2 = {
    'Browse Templates': '浏览模板',
    'Bypass/Unbypass Selected Nodes': '旁路/取消旁路选定节点',
    'Clear Pending Tasks': '清除待处理任务',
    'Clear Workflow': '清除工作流',
    Clipspace: '剪辑空间',
    'Collapse/Expand Selected Nodes': '折叠/展开选定节点',
    'Comfy-Org Discord': 'Comfy-Org Discord',
    'ComfyUI Docs': 'ComfyUI 文档',
    'ComfyUI Issues': 'ComfyUI 问题',
    'Convert selected nodes to group node': '将选定节点转换为组节点',
    Edit: '编辑',
    Export: '导出',
    'Export (API)': '导出 (API)',
    Feedback: '反馈',
    'Fit Group To Contents': '适应组内容',
    'Fit view to selected nodes': '适应视图到选定节点',
    'Group Selected Nodes': '分组选定节点',
    Help: '帮助',
    Interrupt: '中断',
    'Load Default Workflow': '加载默认工作流',
    Logs: '日志',
    'Manage group nodes': '管理组节点',
    'Model Library': '模型库',
    'Mute/Unmute Selected Nodes': '静音/取消静音选定节点',
    New: '新建',
    'Next Opened Workflow': '下一个打开的工作流',
    'Node Library': '节点库',
    Open: '打开',
    'Open Custom Nodes Folder': '打开自定义节点文件夹',
    'Open DevTools': '打开开发者工具',
    'Open Inputs Folder': '打开输入文件夹',
    'Open Logs Folder': '打开日志文件夹',
    'Open Models Folder': '打开模型文件夹',
    'Open Outputs Folder': '打开输出文件夹',
    'Open extra_model_paths_yaml': '打开 extra_model_paths.yaml',
    'Pin/Unpin Selected Items': '固定/取消固定选定项目',
    'Pin/Unpin Selected Nodes': '固定/取消固定选定节点',
    'Previous Opened Workflow': '上一个打开的工作流',
    Queue: '队列',
    'Queue Prompt': '队列提示',
    'Queue Prompt (Front)': '队列提示 (前面)',
    Redo: '重做',
    'Refresh Node Definitions': '刷新节点定义',
    Reinstall: '重新安装',
    'Reset View': '重置视图',
    Restart: '重启',
    Save: '保存',
    'Save As': '另存为',
    Settings: '设置',
    Terminal: '终端',
    'Toggle Bottom Panel': '切换底部面板',
    'Toggle Focus Mode': '切换专注模式',
    'Toggle Link Visibility': '切换链接可见性',
    'Toggle Lock': '切换锁定',
    'Toggle Search Box': '切换搜索框',
    'Toggle Theme': '切换主题',
    Undo: '撤销',
    'Ungroup selected group nodes': '取消选定组节点的分组',
    Workflow: '工作流',
    Workflows: '工作流',
    'Zoom In': '放大',
    'Zoom Out': '缩小'
  },
  newFolder$2 = '新建文件夹',
  no$2 = '不',
  noResultsFound$2 = '未找到结果',
  noTasksFound$2 = '未找到任务',
  noTasksFoundMessage$2 = '队列中没有任务。',
  noWorkflowsFound$2 = '未找到工作流',
  nodeDefs$2 = {
    AddNoise: { display_name: '添加噪声' },
    AlignYourStepsScheduler: { display_name: '对齐步骤调度器' },
    BasicGuider: { display_name: '基本引导器' },
    BasicScheduler: { display_name: '基本调度器' },
    BetaSamplingScheduler: { display_name: '贝塔采样调度器' },
    CFGGuider: { display_name: 'CFG引导器' },
    CLIPAttentionMultiply: { display_name: 'CLIP注意力乘法' },
    CLIPLoader: {
      description:
        '[配方]\n\n稳定扩散：clip-l\n稳定级联：clip-g\nsd3：t5 / clip-g / clip-l\n稳定音频：t5\nmochi：t5',
      display_name: '加载CLIP'
    },
    CLIPMergeAdd: { display_name: 'CLIP合并添加' },
    CLIPMergeSimple: { display_name: 'CLIP合并简单' },
    CLIPMergeSubtract: { display_name: 'CLIP合并减法' },
    CLIPSave: { display_name: '保存CLIP' },
    CLIPSetLastLayer: { display_name: '设置CLIP最后一层' },
    CLIPTextEncode: {
      description:
        '使用CLIP模型对文本提示进行编码，生成可以引导扩散模型生成特定图像的嵌入。',
      display_name: 'CLIP文本编码（提示）'
    },
    CLIPTextEncodeControlnet: { display_name: 'CLIP文本编码控制网' },
    CLIPTextEncodeFlux: { display_name: 'CLIP文本编码Flux' },
    CLIPTextEncodeHunyuanDiT: { display_name: 'CLIP文本编码混元DiT' },
    CLIPTextEncodeSD3: { display_name: 'CLIP文本编码SD3' },
    CLIPTextEncodeSDXL: { display_name: 'CLIP文本编码SDXL' },
    CLIPTextEncodeSDXLRefiner: { display_name: 'CLIP文本编码SDXL精炼器' },
    CLIPVisionEncode: { display_name: 'CLIP视觉编码' },
    CLIPVisionLoader: { display_name: '加载CLIP视觉' },
    Canny: { display_name: 'Canny边缘检测' },
    CheckpointLoader: { display_name: '加载检查点配置（已弃用）' },
    CheckpointLoaderSimple: {
      description: '加载扩散模型检查点，扩散模型用于去噪潜在图像。',
      display_name: '加载检查点'
    },
    CheckpointSave: { display_name: '保存检查点' },
    CombineHooks2: { display_name: '组合钩子 [2]' },
    CombineHooks4: { display_name: '组合钩子 [4]' },
    CombineHooks8: { display_name: '组合钩子 [8]' },
    ConditioningAverage: { display_name: '条件平均' },
    ConditioningCombine: { display_name: '条件（组合）' },
    ConditioningConcat: { display_name: '条件（连接）' },
    ConditioningSetArea: { display_name: '条件（设置区域）' },
    ConditioningSetAreaPercentage: { display_name: '条件（按百分比设置区域）' },
    ConditioningSetAreaStrength: { display_name: '条件设置区域强度' },
    ConditioningSetDefaultCombine: { display_name: '条件设置默认组合' },
    ConditioningSetMask: { display_name: '条件（设置掩码）' },
    ConditioningSetProperties: { display_name: '条件设置属性' },
    ConditioningSetPropertiesAndCombine: { display_name: '条件设置属性组合' },
    ConditioningSetTimestepRange: { display_name: '条件设置时间步范围' },
    ConditioningTimestepsRange: { display_name: '时间步范围' },
    ConditioningZeroOut: { display_name: '条件零化' },
    ControlNetApply: { display_name: '应用控制网（旧）' },
    ControlNetApplyAdvanced: { display_name: '应用控制网' },
    ControlNetApplySD3: { display_name: '应用控制网与VAE' },
    ControlNetInpaintingAliMamaApply: { display_name: '控制网修复AliMama应用' },
    ControlNetLoader: { display_name: '加载控制网模型' },
    CreateHookKeyframe: { display_name: '创建钩子关键帧' },
    CreateHookKeyframesFromFloats: { display_name: '从浮点数创建钩子关键帧' },
    CreateHookKeyframesInterpolated: { display_name: '创建插值钩子关键帧' },
    CreateHookLora: { display_name: '创建钩子LoRA' },
    CreateHookLoraModelOnly: { display_name: '仅创建钩子LoRA（MO）' },
    CreateHookModelAsLora: { display_name: '创建钩子模型作为LoRA' },
    CreateHookModelAsLoraModelOnly: {
      display_name: '仅创建钩子模型作为LoRA（MO）'
    },
    CropMask: { display_name: '裁剪掩码' },
    DevToolsDeprecatedNode: {
      description: '一个已弃用的节点',
      display_name: '已弃用节点'
    },
    DevToolsErrorRaiseNode: {
      description: '出于开发目的引发错误',
      display_name: '引发错误'
    },
    DevToolsErrorRaiseNodeWithMessage: {
      description: '出于开发目的引发带消息的错误',
      display_name: '带消息的引发错误'
    },
    DevToolsExperimentalNode: {
      description: '一个实验性的节点',
      display_name: '实验性节点'
    },
    DevToolsLongComboDropdown: {
      description: '一个长组合下拉菜单',
      display_name: '长组合下拉菜单'
    },
    DevToolsNodeWithForceInput: {
      description: '一个具有强制输入的节点',
      display_name: '强制输入节点'
    },
    DevToolsNodeWithOnlyOptionalInput: {
      description: '一个仅有可选输入的节点',
      display_name: '仅有可选输入的节点'
    },
    DevToolsNodeWithOptionalInput: {
      description: '一个具有可选输入的节点',
      display_name: '具有可选输入的节点'
    },
    DevToolsNodeWithOutputList: {
      description: '一个具有输出列表的节点',
      display_name: '具有输出列表的节点'
    },
    DevToolsNodeWithStringInput: {
      description: '一个具有字符串输入的节点',
      display_name: '具有字符串输入的节点'
    },
    DevToolsNodeWithUnionInput: {
      description: '一个具有联合输入的节点',
      display_name: '具有联合输入的节点'
    },
    DiffControlNetLoader: { display_name: '加载控制网模型（diff）' },
    DifferentialDiffusion: { display_name: '差分扩散' },
    DiffusersLoader: { display_name: '扩散器加载器' },
    DisableNoise: { display_name: '禁用噪声' },
    DualCFGGuider: { display_name: '双CFG引导器' },
    DualCLIPLoader: {
      description:
        '[配方]\n\nsdxl：clip-l，clip-g\nsd3：clip-l，clip-g / clip-l，t5 / clip-g，t5\nflux：clip-l，t5',
      display_name: '双CLIP加载器'
    },
    EmptyImage: { display_name: '空图像' },
    EmptyLTXVLatentVideo: { display_name: '空LTXV潜在视频' },
    EmptyLatentAudio: { display_name: '空潜在音频' },
    EmptyLatentImage: {
      description: '创建一批新的空潜在图像，以通过采样进行去噪。',
      display_name: '空潜在图像'
    },
    EmptyMochiLatentVideo: { display_name: '空Mochi潜在视频' },
    EmptySD3LatentImage: { display_name: '空SD3潜在图像' },
    ExponentialScheduler: { display_name: '指数调度器' },
    FeatherMask: { display_name: '羽毛掩码' },
    FlipSigmas: { display_name: '翻转Sigma' },
    FluxGuidance: { display_name: 'Flux引导' },
    FreeU: { display_name: 'FreeU' },
    FreeU_V2: { display_name: 'FreeU_V2' },
    GITSScheduler: { display_name: 'GITS调度器' },
    GLIGENLoader: { display_name: 'GLIGEN加载器' },
    GLIGENTextBoxApply: { display_name: 'GLIGEN文本框应用' },
    GrowMask: { display_name: '扩展掩码' },
    HyperTile: { display_name: '超平铺' },
    HypernetworkLoader: { display_name: '超网络加载器' },
    ImageBatch: { display_name: '图像批处理' },
    ImageBlend: { display_name: '图像混合' },
    ImageBlur: { display_name: '图像模糊' },
    ImageColorToMask: { display_name: '图像颜色到掩码' },
    ImageCompositeMasked: { display_name: '图像合成掩码' },
    ImageCrop: { display_name: '图像裁剪' },
    ImageFromBatch: { display_name: '从批次获取图像' },
    ImageInvert: { display_name: '反转图像' },
    ImageOnlyCheckpointLoader: {
      display_name: '仅图像检查点加载器（img2vid模型）'
    },
    ImageOnlyCheckpointSave: { display_name: '仅图像检查点保存' },
    ImagePadForOutpaint: { display_name: '为外绘填充图像' },
    ImageQuantize: { display_name: '图像量化' },
    ImageScale: { display_name: '图像放大' },
    ImageScaleBy: { display_name: '按比例放大图像' },
    ImageScaleToTotalPixels: { display_name: '将图像缩放到总像素' },
    ImageSharpen: { display_name: '图像锐化' },
    ImageToMask: { display_name: '将图像转换为掩码' },
    ImageUpscaleWithModel: { display_name: '使用模型放大图像' },
    InpaintModelConditioning: { display_name: '修复模型条件' },
    InstructPixToPixConditioning: { display_name: '指令像素到像素条件' },
    InvertMask: { display_name: '反转掩码' },
    JoinImageWithAlpha: { display_name: '与Alpha合并图像' },
    KSampler: {
      description: '使用提供的模型、正向和负向条件去噪潜在图像。',
      display_name: 'K采样器'
    },
    KSamplerAdvanced: { display_name: 'K采样器（高级）' },
    KSamplerSelect: { display_name: 'K采样器选择' },
    KarrasScheduler: { display_name: 'Karras调度器' },
    LTXVConditioning: { display_name: 'LTXV条件' },
    LTXVImgToVideo: { display_name: 'LTXV图像到视频' },
    LTXVScheduler: { display_name: 'LTXV调度器' },
    LaplaceScheduler: { display_name: '拉普拉斯调度器' },
    LatentAdd: { display_name: '潜在添加' },
    LatentApplyOperation: { display_name: '潜在应用操作' },
    LatentApplyOperationCFG: { display_name: '潜在应用操作CFG' },
    LatentBatch: { display_name: '潜在批处理' },
    LatentBatchSeedBehavior: { display_name: '潜在批处理种子行为' },
    LatentBlend: { display_name: '潜在混合' },
    LatentComposite: { display_name: '潜在合成' },
    LatentCompositeMasked: { display_name: '潜在合成掩码' },
    LatentCrop: { display_name: '裁剪潜在' },
    LatentFlip: { display_name: '翻转潜在' },
    LatentFromBatch: { display_name: '从批次获取潜在' },
    LatentInterpolate: { display_name: '潜在插值' },
    LatentMultiply: { display_name: '潜在乘法' },
    LatentOperationSharpen: { display_name: '潜在操作锐化' },
    LatentOperationTonemapReinhard: {
      display_name: '潜在操作色调映射Reinhard'
    },
    LatentRotate: { display_name: '旋转潜在' },
    LatentSubtract: { display_name: '潜在减法' },
    LatentUpscale: { display_name: '放大潜在' },
    LatentUpscaleBy: { display_name: '按比例放大潜在' },
    LoadAudio: { display_name: '加载音频' },
    LoadImage: { display_name: '加载图像' },
    LoadImageMask: { display_name: '加载图像（作为掩码）' },
    LoadLatent: { display_name: '加载潜在' },
    LoraLoader: {
      description:
        'LoRA用于修改扩散和CLIP模型，改变潜在图像的去噪方式，例如应用风格。多个LoRA节点可以链接在一起。',
      display_name: '加载LoRA'
    },
    LoraLoaderModelOnly: {
      description:
        'LoRA用于修改扩散和CLIP模型，改变潜在图像的去噪方式，例如应用风格。多个LoRA节点可以链接在一起。',
      display_name: '仅加载LoRA模型'
    },
    LoraSave: { display_name: '提取并保存LoRA' },
    MaskComposite: { display_name: '掩码合成' },
    MaskToImage: { display_name: '将掩码转换为图像' },
    ModelMergeAdd: { display_name: '模型合并添加' },
    ModelMergeAuraflow: { display_name: '模型合并Auraflow' },
    ModelMergeBlocks: { display_name: '模型合并块' },
    ModelMergeFlux1: { display_name: '模型合并Flux1' },
    ModelMergeLTXV: { display_name: '模型合并LTXV' },
    ModelMergeMochiPreview: { display_name: '模型合并Mochi预览' },
    ModelMergeSD1: { display_name: '模型合并SD1' },
    ModelMergeSD2: { display_name: '模型合并SD2' },
    ModelMergeSD35_Large: { display_name: '模型合并SD35_大' },
    ModelMergeSD3_2B: { display_name: '模型合并SD3_2B' },
    ModelMergeSDXL: { display_name: '模型合并SDXL' },
    ModelMergeSimple: { display_name: '模型合并简单' },
    ModelMergeSubtract: { display_name: '模型合并减法' },
    ModelSamplingAuraFlow: { display_name: '模型采样AuraFlow' },
    ModelSamplingContinuousEDM: { display_name: '模型采样连续EDM' },
    ModelSamplingContinuousV: { display_name: '模型采样连续V' },
    ModelSamplingDiscrete: { display_name: '模型采样离散' },
    ModelSamplingFlux: { display_name: '模型采样Flux' },
    ModelSamplingLTXV: { display_name: '模型采样LTXV' },
    ModelSamplingSD3: { display_name: '模型采样SD3' },
    ModelSamplingStableCascade: { display_name: '模型采样稳定级联' },
    ModelSave: { display_name: '保存模型' },
    Morphology: { display_name: '图像形态学' },
    PairConditioningCombine: { display_name: '条件对组合' },
    PairConditioningSetDefaultCombine: { display_name: '条件对设置默认组合' },
    PairConditioningSetProperties: { display_name: '条件对设置属性' },
    PairConditioningSetPropertiesAndCombine: {
      display_name: '条件对设置属性组合'
    },
    PatchModelAddDownscale: {
      display_name: '补丁模型添加下采样（Kohya深度缩小）'
    },
    PerpNeg: { display_name: 'Perp-Neg（已弃用，使用PerpNegGuider）' },
    PerpNegGuider: { display_name: 'PerpNeg引导器' },
    PerturbedAttentionGuidance: { display_name: '扰动注意力引导' },
    PhotoMakerEncode: { display_name: 'PhotoMaker编码' },
    PhotoMakerLoader: { display_name: 'PhotoMaker加载器' },
    PolyexponentialScheduler: { display_name: '多指数调度器' },
    PorterDuffImageComposite: { display_name: 'Porter-Duff图像合成' },
    PreviewAudio: { display_name: '预览音频' },
    PreviewImage: {
      description: '将输入图像保存到您的ComfyUI输出目录。',
      display_name: '预览图像'
    },
    RandomNoise: { display_name: '随机噪声' },
    RebatchImages: { display_name: '重新批处理图像' },
    RebatchLatents: { display_name: '重新批处理潜在' },
    RepeatImageBatch: { display_name: '重复图像批处理' },
    RepeatLatentBatch: { display_name: '重复潜在批处理' },
    RescaleCFG: { display_name: '重新缩放CFG' },
    SDTurboScheduler: { display_name: 'SDTurbo调度器' },
    SD_4XUpscale_Conditioning: { display_name: 'SD_4X放大条件' },
    SV3D_Conditioning: { display_name: 'SV3D条件' },
    SVD_img2vid_Conditioning: { display_name: 'SVD_img2vid条件' },
    SamplerCustom: { display_name: '自定义采样器' },
    SamplerCustomAdvanced: { display_name: '自定义采样器（高级）' },
    SamplerDPMAdaptative: { display_name: '自适应DPM采样器' },
    SamplerDPMPP_2M_SDE: { display_name: 'DPMPP_2M_SDE采样器' },
    SamplerDPMPP_2S_Ancestral: { display_name: 'DPMPP_2S_祖先采样器' },
    SamplerDPMPP_3M_SDE: { display_name: 'DPMPP_3M_SDE采样器' },
    SamplerDPMPP_SDE: { display_name: 'DPMPP_SDE采样器' },
    SamplerEulerAncestral: { display_name: '欧拉祖先采样器' },
    SamplerEulerAncestralCFGPP: { display_name: '欧拉祖先CFG++采样器' },
    SamplerEulerCFGpp: { display_name: '欧拉CFG++采样器' },
    SamplerLCMUpscale: { display_name: 'LCM放大采样器' },
    SamplerLMS: { display_name: 'LMS采样器' },
    SaveAnimatedPNG: { display_name: '保存动画PNG' },
    SaveAnimatedWEBP: { display_name: '保存动画WEBP' },
    SaveAudio: { display_name: '保存音频' },
    SaveImage: {
      description: '将输入图像保存到您的ComfyUI输出目录。',
      display_name: '保存图像'
    },
    SaveImageWebsocket: { display_name: '保存图像Websocket' },
    SaveLatent: { display_name: '保存潜在' },
    SelfAttentionGuidance: { display_name: '自注意力引导' },
    SetClipHooks: { display_name: '设置CLIP钩子' },
    SetHookKeyframes: { display_name: '设置钩子关键帧' },
    SetLatentNoiseMask: { display_name: '设置潜在噪声掩码' },
    SetUnionControlNetType: { display_name: '设置联合控制网类型' },
    SkipLayerGuidanceDiT: {
      description: '通用版本的跳过层引导节点，可用于每个DiT模型。',
      display_name: '跳过层引导DiT'
    },
    SkipLayerGuidanceSD3: {
      description: '通用版本的跳过层引导节点，可用于每个DiT模型。',
      display_name: '跳过层引导SD3'
    },
    SolidMask: { display_name: '实心掩码' },
    SplitImageWithAlpha: { display_name: '按Alpha分割图像' },
    SplitSigmas: { display_name: '分割Sigma' },
    SplitSigmasDenoise: { display_name: '分割Sigma去噪' },
    StableCascade_EmptyLatentImage: { display_name: '稳定级联_空潜在图像' },
    StableCascade_StageB_Conditioning: { display_name: '稳定级联_B阶段条件' },
    StableCascade_StageC_VAEEncode: { display_name: '稳定级联_C阶段VAE编码' },
    StableCascade_SuperResolutionControlnet: {
      display_name: '稳定级联_超分辨率控制网'
    },
    StableZero123_Conditioning: { display_name: '稳定零123条件' },
    StableZero123_Conditioning_Batched: {
      display_name: '稳定零123条件_批处理'
    },
    StyleModelApply: { display_name: '应用风格模型' },
    StyleModelLoader: { display_name: '加载风格模型' },
    ThresholdMask: { display_name: '阈值掩码' },
    TomePatchModel: { display_name: 'Tome补丁模型' },
    TorchCompileModel: { display_name: 'Torch编译模型' },
    TripleCLIPLoader: {
      description: '[配方]\n\nsd3：clip-l，clip-g，t5',
      display_name: '三重CLIP加载器'
    },
    UNETLoader: { display_name: '加载扩散模型' },
    UNetCrossAttentionMultiply: { display_name: 'UNet交叉注意力乘法' },
    UNetSelfAttentionMultiply: { display_name: 'UNet自注意力乘法' },
    UNetTemporalAttentionMultiply: { display_name: 'UNet时间注意力乘法' },
    UpscaleModelLoader: { display_name: '加载放大模型' },
    VAEDecode: {
      description: '将潜在图像解码回像素空间图像。',
      display_name: 'VAE解码'
    },
    VAEDecodeAudio: { display_name: 'VAE解码音频' },
    VAEDecodeTiled: { display_name: 'VAE解码（平铺）' },
    VAEEncode: { display_name: 'VAE编码' },
    VAEEncodeAudio: { display_name: 'VAE编码音频' },
    VAEEncodeForInpaint: { display_name: 'VAE编码（用于修复）' },
    VAEEncodeTiled: { display_name: 'VAE编码（平铺）' },
    VAELoader: { display_name: '加载VAE' },
    VAESave: { display_name: '保存VAE' },
    VPScheduler: { display_name: 'VPS调度器' },
    VideoLinearCFGGuidance: { display_name: '视频线性CFG引导' },
    VideoTriangleCFGGuidance: { display_name: '视频三角形CFG引导' },
    WebcamCapture: { display_name: '网络摄像头捕获' },
    unCLIPCheckpointLoader: { display_name: 'unCLIP检查点加载器' },
    unCLIPConditioning: { display_name: 'unCLIP条件' }
  },
  notSupported$2 = {
    continue: '继续',
    continueTooltip: '我确定我的设备是受支持的',
    learnMore: '了解更多',
    message: '仅支持以下设备：',
    reportIssue: '报告问题',
    supportedDevices: {
      macos: 'MacOS (M1 或更高版本)',
      windows: 'Windows (支持 CUDA 的 Nvidia GPU)'
    },
    title: '您的设备不受支持'
  },
  openNewIssue$2 = '开启新 Issue',
  overwrite$2 = '覆盖',
  reconnected$2 = '已重新连接',
  reconnecting$2 = '重新连接中',
  refresh$2 = '刷新',
  reloadToApplyChanges$2 = '重新加载以应用更改',
  rename$2 = '重命名',
  reportIssue$2 = '发送报告',
  reportIssueTooltip$2 = '将错误报告提交给 Comfy 组织',
  reportSent$2 = '报告已提交',
  reset$2 = '重置',
  resetKeybindingsTooltip$2 = '重置键位',
  save$2 = '保存',
  searchExtensions$2 = '搜索插件',
  searchFailedMessage$2 =
    '我们找不到与您的搜索匹配的任何设置。请尝试调整搜索条件。',
  searchKeybindings$2 = '搜索键位',
  searchModels$2 = '搜索模型',
  searchNodes$2 = '搜索节点',
  searchSettings$2 = '搜索设置',
  searchWorkflows$2 = '搜索工作流',
  serverConfig$2 = {
    modifiedConfigs: '您已修改以下服务器配置。重启以应用更改。',
    restart: '重启',
    revertChanges: '撤销更改'
  },
  serverConfigCategories$2 = {
    Attention: '注意力',
    CUDA: 'CUDA',
    Cache: '缓存',
    General: '常规',
    Inference: '推理',
    Memory: '内存',
    Network: '网络',
    Preview: '预览'
  },
  serverConfigItems$2 = {
    'cache-classic': { name: '使用经典缓存系统' },
    'cache-lru': {
      name: '使用 LRU 缓存，最多缓存 N 个节点结果。',
      tooltip: '可能会使用更多的 RAM/VRAM。'
    },
    'cpu-vae': { name: '在 CPU 上运行 VAE' },
    'cross-attention-method': { name: '交叉注意力方法' },
    'cuda-device': { name: '要使用的 CUDA 设备索引' },
    'cuda-malloc': { name: '使用 CUDA malloc 进行内存分配' },
    'default-hashing-function': { name: '模型文件的默认哈希函数' },
    deterministic: {
      name: '使 pytorch 在可以时使用较慢的确定性算法。',
      tooltip: '请注意，这可能不会在所有情况下使图像具有确定性。'
    },
    directml: { name: 'DirectML 设备索引' },
    'disable-all-custom-nodes': { name: '禁用加载所有自定义节点。' },
    'disable-ipex-optimize': { name: '禁用 IPEX 优化' },
    'disable-metadata': { name: '禁用在文件中保存提示元数据。' },
    'disable-smart-memory': {
      name: '禁用智能内存管理',
      tooltip: '强制 ComfyUI 在可以时将模型从 VRAM 移出到常规 RAM。'
    },
    'disable-xformers': { name: '禁用 xFormers 优化' },
    'dont-print-server': { name: '不将服务器输出打印到控制台。' },
    'dont-upcast-attention': { name: '防止注意力上升' },
    'enable-cors-header': {
      name: '启用 CORS 头：使用 "*" 代表所有来源或指定域名'
    },
    fast: { name: '启用一些未经测试且可能降低质量的优化。' },
    'force-channels-last': { name: '强制使用 channels-last 内存格式' },
    'force-upcast-attention': { name: '强制注意力上升' },
    'global-precision': { name: '全局浮点精度', tooltip: '全局浮点精度' },
    'log-level': { name: '日志详细级别' },
    'max-upload-size': { name: '最大上传大小 (MB)' },
    'preview-method': { name: '用于潜在预览的方法' },
    'preview-size': { name: '预览图像的大小' },
    'reserve-vram': {
      name: '保留 VRAM (GB)',
      tooltip:
        '设置您希望为操作系统/其他软件保留的 VRAM 数量（以 GB 为单位）。默认情况下，根据您的操作系统保留一定数量。'
    },
    'text-encoder-precision': {
      name: '文本编码器精度',
      tooltip: '文本编码器精度'
    },
    'tls-certfile': { name: 'TLS 证书文件：HTTPS 的 TLS 证书文件路径' },
    'tls-keyfile': { name: 'TLS 密钥文件：HTTPS 的 TLS 密钥文件路径' },
    'unet-precision': { name: 'UNET 精度', tooltip: 'UNET 精度' },
    'vae-precision': { name: 'VAE 精度', tooltip: 'VAE 精度' },
    'vram-management': { name: 'VRAM 管理模式' }
  },
  serverStart$2 = {
    openLogs: '打开日志',
    process: {
      error: '无法启动 ComfyUI 桌面版',
      'initial-state': '加载中...',
      'python-setup': '正在设置 Python 环境...',
      ready: '完成中...',
      'starting-server': '正在启动 ComfyUI 服务器...'
    },
    reinstall: '重新安装',
    reportIssue: '报告问题'
  },
  settings$2 = '设置',
  settingsCategories$2 = {
    About: '关于',
    Appearance: '外观',
    BrushAdjustment: '画笔调整',
    Canvas: '画布',
    ColorPalette: '调色板',
    Comfy: 'Comfy',
    'Comfy-Desktop': 'Comfy桌面版',
    DevMode: '开发模式',
    EditAttention: '编辑Attention',
    Extension: '扩展',
    General: '常规',
    Graph: '图',
    Group: '组',
    Keybinding: '快捷键',
    Link: '链接',
    LinkRelease: '链接释放',
    LiteGraph: 'Lite Graph',
    Locale: '区域设置',
    'Mask Editor': '遮罩编辑器',
    Menu: '菜单',
    ModelLibrary: '模型库',
    NewEditor: '新编辑器',
    Node: '节点',
    'Node Search Box': '节点搜索框',
    'Node Widget': '节点小部件',
    NodeInputConversionSubmenus: '节点输入转换子菜单',
    NodeLibrary: '节点库',
    Pointer: '指针',
    Queue: '队列',
    QueueButton: '队列按钮',
    RerouteBeta: '重定向测试版',
    Server: '服务器',
    'Server-Config': '服务器配置',
    Settings: '设置',
    Sidebar: '侧边栏',
    'Tree Explorer': '树形浏览器',
    Validation: '验证',
    Window: '窗口',
    Workflow: '工作流'
  },
  settingsDialog$2 = {
    'Comfy-Desktop_AutoUpdate': { name: '自动检查更新' },
    'Comfy-Desktop_SendStatistics': { name: '发送匿名崩溃报告' },
    Comfy_ColorPalette: { name: '调色板' },
    Comfy_ConfirmClear: { name: '清除工作流时需要确认' },
    Comfy_DOMClippingEnabled: { name: '启用DOM元素裁剪（启用可能会降低性能）' },
    Comfy_DevMode: { name: '启用开发模式选项（API保存等）' },
    Comfy_DisableFloatRounding: {
      name: '禁用默认浮动小部件四舍五入。',
      tooltip:
        '(需要重新加载页面) 当后端节点设置了四舍五入时，无法禁用四舍五入。'
    },
    Comfy_DisableSliders: { name: '禁用节点小部件滑块' },
    Comfy_EditAttention_Delta: { name: 'Ctrl+上/下 精度' },
    Comfy_EnableTooltips: { name: '启用工具提示' },
    Comfy_EnableWorkflowViewRestore: {
      name: '在工作流中保存和恢复画布位置及缩放级别'
    },
    Comfy_Extension_Disabled: { name: '禁用的扩展名称' },
    Comfy_FloatRoundingPrecision: {
      name: '浮动小部件四舍五入的小数位数 [0 = 自动]。',
      tooltip: '(需要重新加载页面)'
    },
    Comfy_Graph_CanvasInfo: { name: '在左下角显示画布信息（fps等）' },
    Comfy_Graph_CanvasMenu: { name: '显示图形画布菜单' },
    Comfy_Graph_CtrlShiftZoom: {
      name: '启用快速缩放快捷键（Ctrl + Shift + 拖动）'
    },
    Comfy_Graph_LinkMarkers: { name: '链接中点标记' },
    Comfy_Graph_ZoomSpeed: { name: '画布缩放速度' },
    Comfy_GroupSelectedNodes_Padding: { name: '选定节点的组内边距' },
    Comfy_Group_DoubleClickTitleToEdit: { name: '双击组标题以编辑' },
    Comfy_InvertMenuScrolling: { name: '反转上下文菜单滚动' },
    Comfy_Keybinding_NewBindings: { name: '用户设置的键绑定' },
    Comfy_Keybinding_UnsetBindings: { name: '用户取消的键绑定' },
    Comfy_LinkRelease_Action: { name: '释放链接时的操作（无修饰符）' },
    Comfy_LinkRelease_ActionShift: { name: '释放链接时的操作（Shift）' },
    Comfy_LinkRenderMode: { name: '链接渲染模式' },
    Comfy_Locale: { name: '语言' },
    Comfy_MaskEditor_BrushAdjustmentSpeed: {
      name: '画笔调整速度倍增器',
      tooltip: '控制调整时画笔大小和硬度变化的速度。更高的值意味着更快的变化。'
    },
    Comfy_MaskEditor_UseDominantAxis: {
      name: '将画笔调整锁定到主轴',
      tooltip: '启用后，画笔调整将仅根据您移动的方向影响大小或硬度。'
    },
    Comfy_MaskEditor_UseNewEditor: {
      name: '使用新画笔编辑器',
      tooltip: '切换到新的画笔编辑器界面'
    },
    Comfy_MenuPosition: { name: '保存旧版菜单位置' },
    Comfy_ModelLibrary_AutoLoadAll: {
      name: '自动加载所有模型文件夹',
      tooltip:
        '如果为真，所有文件夹将在打开模型库时立即加载（这可能会导致加载时的延迟）。如果为假，根级模型文件夹仅在您单击它们时加载。'
    },
    Comfy_ModelLibrary_NameFormat: {
      name: '在模型库树视图中显示的名称',
      tooltip:
        '选择“文件名”以在模型列表中呈现原始文件名的简化视图（不带目录或“.safetensors”扩展名）。选择“标题”以显示可配置的模型元数据标题。'
    },
    Comfy_NodeBadge_NodeIdBadgeMode: { name: '节点ID徽章模式' },
    Comfy_NodeBadge_NodeLifeCycleBadgeMode: { name: '节点生命周期徽章模式' },
    Comfy_NodeBadge_NodeSourceBadgeMode: { name: '节点源徽章模式' },
    Comfy_NodeInputConversionSubmenus: {
      name: '在节点上下文菜单中，将输入/小部件之间转换的条目放置在子菜单中。'
    },
    Comfy_NodeLibrary_Bookmarks: { name: '节点库书签及显示名称（已弃用）' },
    Comfy_NodeLibrary_BookmarksCustomization: { name: '节点库书签自定义' },
    Comfy_NodeLibrary_Bookmarks_V2: { name: '节点库书签v2及唯一名称' },
    Comfy_NodeSearchBoxImpl: { name: '节点搜索框实现' },
    Comfy_NodeSearchBoxImpl_NodePreview: {
      name: '节点预览',
      tooltip: '仅适用于默认实现'
    },
    Comfy_NodeSearchBoxImpl_ShowCategory: {
      name: '在搜索结果中显示节点类别',
      tooltip: '仅适用于默认实现'
    },
    Comfy_NodeSearchBoxImpl_ShowIdName: {
      name: '在搜索结果中显示节点ID名称',
      tooltip: '仅适用于默认实现'
    },
    Comfy_NodeSearchBoxImpl_ShowNodeFrequency: {
      name: '在搜索结果中显示节点频率',
      tooltip: '仅适用于默认实现'
    },
    Comfy_NodeSuggestions_number: {
      name: '节点建议数量',
      tooltip: '仅适用于 litegraph 搜索框/上下文菜单'
    },
    Comfy_Node_AutoSnapLinkToSlot: {
      name: '自动将链接吸附到节点插槽',
      tooltip: '在节点上拖动链接时，链接会自动吸附到节点的可用输入插槽。'
    },
    Comfy_Node_BypassAllLinksOnDelete: {
      name: '删除节点时保留所有链接',
      tooltip:
        '删除节点时，尝试重新连接其所有输入和输出链接（绕过已删除的节点）。'
    },
    Comfy_Node_DoubleClickTitleToEdit: { name: '双击节点标题以编辑' },
    Comfy_Node_MiddleClickRerouteNode: { name: '中键单击创建新的重定向节点' },
    Comfy_Node_Opacity: { name: '节点不透明度' },
    Comfy_Node_ShowDeprecated: {
      name: '在搜索中显示已弃用的节点',
      tooltip:
        '已弃用的节点在UI中默认隐藏，但在使用它们的现有工作流中仍然有效。'
    },
    Comfy_Node_ShowExperimental: {
      name: '在搜索中显示实验性节点',
      tooltip:
        '实验性节点在UI中标记为实验性，可能在未来版本中发生重大变化或被移除。在生产工作流中谨慎使用。'
    },
    Comfy_Node_SnapHighlightsNode: {
      name: '吸附高亮节点',
      tooltip: '在拖动链接经过具有可用输入插槽的节点时，高亮显示该节点。'
    },
    Comfy_Pointer_ClickBufferTime: {
      name: '指针点击漂移延迟',
      tooltip:
        '按下指针按钮后，这是指针移动可以被忽略的最大时间（以毫秒为单位）。\n\n有助于防止在点击时意外推动对象。'
    },
    Comfy_Pointer_ClickDrift: {
      name: '指针点击漂移（最大距离）',
      tooltip:
        '如果指针在按住按钮时移动超过此距离，则视为拖动（而不是点击）。\n\n有助于防止在点击时意外推动对象。'
    },
    Comfy_Pointer_DoubleClickTime: {
      name: '双击间隔（最大）',
      tooltip:
        '双击的两次点击之间的最大时间（以毫秒为单位）。增加此值可能有助于解决双击有时未被注册的问题。'
    },
    Comfy_PreviewFormat: {
      name: '预览图像格式',
      tooltip:
        '在图像小部件中显示预览时，将其转换为轻量级图像，例如webp、jpeg、webp;50等。'
    },
    Comfy_PromptFilename: { name: '保存工作流时提示文件名' },
    Comfy_QueueButton_BatchCountLimit: {
      name: '批处理计数限制',
      tooltip: '一次点击按钮添加到队列的最大任务数量'
    },
    Comfy_Queue_ImageFit: { name: '队列图像适应' },
    Comfy_Queue_MaxHistoryItems: {
      name: '队列历史大小',
      tooltip: '队列历史中显示的最大任务数量。'
    },
    Comfy_RerouteBeta: {
      name: '选择加入重定向测试版',
      tooltip:
        '启用新的本地重定向。\n\n可以通过按住alt并从链接线拖动来添加重定向，或在链接菜单中添加。\n\n禁用此选项不会造成破坏 - 重定向将被隐藏。'
    },
    Comfy_Server_LaunchArgs: {
      name: '服务器启动参数',
      tooltip: '这些是启动服务器时传递给服务器的实际参数。'
    },
    Comfy_Server_ServerConfigValues: {
      name: '前端显示的服务器配置值',
      tooltip: '仅用于前端显示的服务器配置值'
    },
    Comfy_Settings_ExtensionPanel: { name: '在设置对话框中显示扩展面板' },
    Comfy_Sidebar_Location: { name: '侧边栏位置' },
    Comfy_Sidebar_Size: { name: '侧边栏大小' },
    Comfy_SnapToGrid_GridSize: {
      name: '吸附到网格大小',
      tooltip:
        '在按住shift拖动和调整节点大小时，它们将对齐到网格，这控制着网格的大小。'
    },
    Comfy_TextareaWidget_FontSize: { name: '文本区域小部件字体大小' },
    Comfy_TextareaWidget_Spellcheck: { name: '文本区域小部件拼写检查' },
    Comfy_TreeExplorer_ItemPadding: { name: '树形浏览器项目内边距' },
    Comfy_UseNewMenu: { name: '使用新菜单' },
    Comfy_Validation_NodeDefs: {
      name: '验证节点定义（慢）',
      tooltip: '推荐给节点开发者。这将在启动时验证所有节点定义。'
    },
    Comfy_Validation_Workflows: { name: '验证工作流' },
    Comfy_WidgetControlMode: {
      name: '小部件控制模式',
      tooltip:
        '控制小部件值的更新时机（随机/增量/减量），可以在提示排队之前或之后。'
    },
    Comfy_Window_UnloadConfirmation: { name: '关闭窗口时显示确认' },
    Comfy_Workflow_ConfirmDelete: { name: '删除工作流时显示确认' },
    Comfy_Workflow_ShowMissingModelsWarning: { name: '显示缺失模型警告' },
    Comfy_Workflow_ShowMissingNodesWarning: { name: '显示缺失节点警告' },
    Comfy_Workflow_SortNodeIdOnSave: { name: '保存工作流时排序节点ID' },
    Comfy_Workflow_WorkflowTabsPosition: { name: '已打开工作流的位置' },
    LiteGraph_Canvas_MaximumFps: {
      name: '最大FPS',
      tooltip:
        '画布允许渲染的最大帧数。限制GPU使用以换取流畅度。如果为0，则使用屏幕刷新率。默认值：0'
    },
    pysssss_SnapToGrid: { name: '始终吸附到网格' }
  },
  showReport$2 = '显示报告',
  sideToolbar$2 = {
    browseTemplates: '浏览示例模板',
    downloads: '下载',
    logout: '登出',
    modelLibrary: '模型库',
    newBlankWorkflow: '创建一个新空白工作流',
    nodeLibrary: '节点库',
    nodeLibraryTab: { sortOrder: '排序顺序' },
    openWorkflow: '在本地文件系统中打开工作流',
    queue: '队列',
    queueTab: {
      backToAllTasks: '返回',
      clearPendingTasks: '清除待处理任务',
      containImagePreview: '填充图像预览',
      coverImagePreview: '适应图像预览',
      filter: '过滤输出',
      filters: { hideCached: '隐藏缓存', hideCanceled: '隐藏已取消' },
      showFlatList: '平铺结果'
    },
    themeToggle: '主题切换',
    workflowTab: {
      confirmDelete: '您确定要删除此工作流吗？',
      confirmDeleteTitle: '删除工作流？',
      confirmOverwrite: '下面的文件已经存在。您想要覆盖它吗？',
      confirmOverwriteTitle: '覆盖现有文件？',
      deleteFailed: '尝试删除工作流失败。',
      deleteFailedTitle: '删除失败',
      deleted: '工作流已删除',
      dirtyClose: '以下文件已被更改。您想在关闭之前保存它们吗？',
      dirtyCloseTitle: '保存更改？'
    },
    workflows: '工作流'
  },
  star$2 = '星星',
  systemInfo$2 = '系统信息',
  tabMenu$2 = {
    closeOtherTabs: '关闭其他标签',
    closeTab: '关闭标签',
    closeTabsToLeft: '关闭左侧标签',
    closeTabsToRight: '关闭右侧标签',
    duplicateTab: '复制标签'
  },
  templateWorkflows$2 = {
    template: {
      default: 'Image Generation',
      flux_schnell: 'Flux Schnell',
      image2image: 'Image to Image',
      upscale: '2 Pass Upscale'
    },
    title: '从模板开始'
  },
  terminal$2 = '终端',
  userSelect$2 = {
    enterUsername: '输入用户名',
    existingUser: '已有用户',
    newUser: '新用户',
    next: '下一步',
    selectUser: '选择用户'
  },
  videoFailedToLoad$2 = '视频加载失败',
  welcome$2 = { getStarted: '开始使用', title: '欢迎使用 ComfyUI' },
  zh = {
    about: about$2,
    add: add$2,
    bookmark: bookmark$2,
    box: box$2,
    briefcase: briefcase$2,
    cancel: cancel$2,
    color: color$2,
    comingSoon: comingSoon$2,
    confirm: confirm$3,
    copyToClipboard: copyToClipboard$2,
    currentUser: currentUser$2,
    customize: customize$2,
    customizeFolder: customizeFolder$2,
    delete: '删除',
    deprecated: deprecated$2,
    desktopMenu: desktopMenu$2,
    devices: devices$2,
    download: download$2,
    downloadGit: downloadGit$2,
    electronFileDownload: electronFileDownload$2,
    empty: empty$2,
    error: error$2,
    experimental: experimental$2,
    extensionName: extensionName$2,
    file: file$2,
    findIssues: findIssues$2,
    firstTimeUIMessage: firstTimeUIMessage$2,
    folder: folder$2,
    goToNode: goToNode$2,
    graphCanvasMenu: graphCanvasMenu$2,
    heart: heart$2,
    icon: icon$2,
    imageFailedToLoad: imageFailedToLoad$2,
    inbox: inbox$2,
    insert: insert$2,
    install: install$2,
    loadAllFolders: loadAllFolders$2,
    loadWorkflow: loadWorkflow$2,
    loading: loading$2,
    logs: logs$2,
    menu: menu$2,
    menuLabels: menuLabels$2,
    newFolder: newFolder$2,
    no: no$2,
    noResultsFound: noResultsFound$2,
    noTasksFound: noTasksFound$2,
    noTasksFoundMessage: noTasksFoundMessage$2,
    noWorkflowsFound: noWorkflowsFound$2,
    nodeDefs: nodeDefs$2,
    notSupported: notSupported$2,
    openNewIssue: openNewIssue$2,
    overwrite: overwrite$2,
    reconnected: reconnected$2,
    reconnecting: reconnecting$2,
    refresh: refresh$2,
    reloadToApplyChanges: reloadToApplyChanges$2,
    rename: rename$2,
    reportIssue: reportIssue$2,
    reportIssueTooltip: reportIssueTooltip$2,
    reportSent: reportSent$2,
    reset: reset$2,
    resetKeybindingsTooltip: resetKeybindingsTooltip$2,
    save: save$2,
    searchExtensions: searchExtensions$2,
    searchFailedMessage: searchFailedMessage$2,
    searchKeybindings: searchKeybindings$2,
    searchModels: searchModels$2,
    searchNodes: searchNodes$2,
    searchSettings: searchSettings$2,
    searchWorkflows: searchWorkflows$2,
    serverConfig: serverConfig$2,
    serverConfigCategories: serverConfigCategories$2,
    serverConfigItems: serverConfigItems$2,
    serverStart: serverStart$2,
    settings: settings$2,
    settingsCategories: settingsCategories$2,
    settingsDialog: settingsDialog$2,
    showReport: showReport$2,
    sideToolbar: sideToolbar$2,
    star: star$2,
    systemInfo: systemInfo$2,
    tabMenu: tabMenu$2,
    templateWorkflows: templateWorkflows$2,
    terminal: terminal$2,
    userSelect: userSelect$2,
    videoFailedToLoad: videoFailedToLoad$2,
    welcome: welcome$2
  },
  about$1 = 'О',
  add$1 = 'Добавить',
  bookmark$1 = 'Закладка',
  box$1 = 'Ящик',
  briefcase$1 = 'Чемодан',
  cancel$1 = 'Отмена',
  color$1 = 'Цвет',
  comingSoon$1 = 'Скоро',
  confirm$2 = 'Подтвердить',
  copyToClipboard$1 = 'Копировать в буфер обмена',
  currentUser$1 = 'Текущий пользователь',
  customize$1 = 'Настроить',
  customizeFolder$1 = 'Настроить папку',
  deprecated$1 = 'УСТАР',
  desktopMenu$1 = {
    confirmReinstall:
      'Это очистит ваш файл extra_models_config.yaml и начнет установку заново. Вы уверены?',
    reinstall: 'Переустановить'
  },
  devices$1 = 'Устройства',
  download$1 = 'Скачать',
  downloadGit$1 = {
    gitWebsite: 'Скачать git',
    instructions:
      "Пожалуйста, скачайте и установите последнюю версию для вашей операционной системы. Кнопка 'Скачать git' ниже открывает страницу загрузок git-scm.com.",
    message:
      'Не удалось найти git. Рабочая копия git необходима для нормальной работы.',
    skip: 'Пропустить',
    title: 'Скачать git',
    warning:
      "Если вы уверены, что вам не нужно устанавливать git, или произошла ошибка, вы можете нажать 'Пропустить', чтобы обойти эту проверку. Попытка запустить ComfyUI без рабочей копии git в настоящее время не поддерживается."
  },
  electronFileDownload$1 = {
    cancel: 'Отменить загрузку',
    cancelled: 'Отменено',
    inProgress: 'В процессе',
    pause: 'Приостановить загрузку',
    paused: 'Приостановлено',
    resume: 'Возобновить загрузку'
  },
  empty$1 = 'Пусто',
  error$1 = 'Ошибка',
  experimental$1 = 'БЕТА',
  extensionName$1 = 'Название расширения',
  file$1 = 'Файл',
  findIssues$1 = 'Найти Issue',
  firstTimeUIMessage$1 =
    'Это первый раз, когда вы используете новый интерфейс. Выберите "Меню > Использовать новое меню > Disabled", чтобы восстановить старый интерфейс.',
  folder$1 = 'Папка',
  goToNode$1 = 'Перейти к узлу',
  graphCanvasMenu$1 = {
    fitView: 'Подгонять под выделенные',
    panMode: 'Режим панорамирования',
    resetView: 'Сбросить вид',
    selectMode: 'Выбрать режим',
    toggleLinkVisibility: 'Переключить видимость ссылок',
    zoomIn: 'Увеличить',
    zoomOut: 'Уменьшить'
  },
  heart$1 = 'Сердце',
  icon$1 = 'Иконка',
  imageFailedToLoad$1 = 'Изображение не удалось загрузить',
  inbox$1 = 'Входящие',
  insert$1 = 'Вставить',
  install$1 = {
    appDataLocationTooltip:
      'Директория данных приложения ComfyUI. Хранит:\n- Логи\n- Конфигурации сервера',
    appPathLocationTooltip:
      'Директория активов приложения ComfyUI. Хранит код и активы ComfyUI',
    chooseInstallationLocation: 'Выберите место установки',
    customNodes: 'Пользовательские узлы',
    customNodesDescription:
      'Ссылайтесь на файлы пользовательских узлов из существующих установок ComfyUI и устанавливайте их зависимости.',
    desktopAppSettings: 'Настройки настольного приложения',
    desktopAppSettingsDescription:
      'Настройте, как ComfyUI ведет себя на вашем рабочем столе. Вы можете изменить эти настройки позже.',
    desktopSettings: 'Настройки рабочего стола',
    failedToSelectDirectory: 'Не удалось выбрать директорию',
    installLocation: 'Место установки',
    installLocationDescription:
      'Выберите директорию для пользовательских данных ComfyUI. В выбранном месте будет установлена среда Python. Пожалуйста, убедитесь, что на выбранном диске достаточно места (~15 ГБ).',
    installLocationTooltip:
      'Директория пользовательских данных ComfyUI. Хранит:\n- Среда Python\n- Модели\n- Пользовательские узлы\n',
    migrateFromExistingInstallation: 'Миграция из существующей установки',
    migration: 'Миграция',
    migrationOptional:
      'Миграция является необязательной. Если у вас нет существующей установки, вы можете пропустить этот шаг.',
    migrationSourcePathDescription:
      'Если у вас есть существующая установка ComfyUI, мы можем скопировать/связать ваши существующие пользовательские файлы и модели в новую установку.',
    pathValidationFailed: 'Не удалось проверить путь',
    selectItemsToMigrate: 'Выберите элементы для миграции',
    settings: {
      allowMetrics: 'Отчеты о сбоях',
      allowMetricsDescription:
        'Помогите улучшить ComfyUI, отправляя анонимные отчеты о сбоях. Личная информация или содержимое рабочего процесса не будут собираться. Это можно отключить в любое время в меню настроек.',
      autoUpdate: 'Автоматические обновления',
      autoUpdateDescription:
        'Автоматически загружать и устанавливать обновления, когда они становятся доступными. Вы всегда будете уведомлены перед установкой обновлений.',
      dataCollectionDialog: {
        customNodeConfigurations: 'Конфигурации пользовательских узлов',
        errorReports: 'Сообщения об ошибках и трассировка стека',
        fileSystemInformation: 'Информация о файловой системе',
        personalInformation: 'Личная информация',
        systemInfo: 'Аппаратное обеспечение, тип ОС и версия приложения',
        title: 'О сборе данных',
        whatWeCollect: 'Что мы собираем:',
        whatWeDoNotCollect: 'Что мы не собираем:',
        workflowContent: 'Содержимое рабочего процесса',
        workflowContents: 'Содержимое рабочего процесса'
      },
      learnMoreAboutData: 'Узнать больше о сборе данных'
    },
    systemLocations: 'Системные места'
  },
  loadAllFolders$1 = 'Загрузить все папки',
  loadWorkflow$1 = 'Загрузить рабочий процесс',
  loading$1 = 'Загрузка',
  logs$1 = 'Логи',
  menu$1 = {
    autoQueue: 'Автоочередь',
    batchCount: 'Количество пакетов',
    batchCountTooltip:
      'Количество раз, когда генерация рабочего процесса должна быть помещена в очередь',
    clear: 'Очистить рабочий процесс',
    clipspace: 'Открыть Clipspace',
    disabled: 'Отключено',
    disabledTooltip: 'Рабочий процесс не будет автоматически помещён в очередь',
    execute: 'Выполнить',
    hideMenu: 'Скрыть меню',
    instant: 'Мгновенно',
    instantTooltip:
      'Рабочий процесс будет помещён в очередь сразу же после завершения генерации',
    interrupt: 'Отменить текущее выполнение',
    onChange: 'При изменении',
    onChangeTooltip:
      'Рабочий процесс будет поставлен в очередь после внесения изменений',
    queue: 'Выполнить',
    queueWorkflow: 'Очередь рабочего процесса (Shift для вставки спереди)',
    queueWorkflowFront: 'Очередь рабочего процесса (Вставка спереди)',
    refresh: 'Обновить определения узлов',
    resetView: 'Сбросить вид холста',
    showMenu: 'Показать меню',
    toggleBottomPanel: 'Переключить нижнюю панель'
  },
  menuLabels$1 = {
    'Browse Templates': 'Просмотреть шаблоны',
    'Bypass/Unbypass Selected Nodes': 'Обойти/восстановить выбранные узлы',
    'Clear Pending Tasks': 'Очистить ожидающие задачи',
    'Clear Workflow': 'Очистить рабочий процесс',
    Clipspace: 'Клиппространство',
    'Collapse/Expand Selected Nodes': 'Свернуть/развернуть выбранные узлы',
    'Comfy-Org Discord': 'Discord Comfy-Org',
    'ComfyUI Docs': 'Документация ComfyUI',
    'ComfyUI Issues': 'Проблемы ComfyUI',
    'Convert selected nodes to group node':
      'Преобразовать выбранные узлы в групповой узел',
    Edit: 'Редактировать',
    Export: 'Экспортировать',
    'Export (API)': 'Экспорт (API)',
    Feedback: 'Обратная связь',
    'Fit Group To Contents': 'Подогнать группу под содержимое',
    'Fit view to selected nodes': 'Подогнать вид под выбранные узлы',
    'Group Selected Nodes': 'Сгруппировать выбранные узлы',
    Help: 'Помощь',
    Interrupt: 'Прервать',
    'Load Default Workflow': 'Загрузить стандартный рабочий процесс',
    Logs: 'Журналы',
    'Manage group nodes': 'Управление групповыми узлами',
    'Model Library': 'Библиотека моделей',
    'Mute/Unmute Selected Nodes': 'Отключить/включить звук для выбранных узлов',
    New: 'Новый',
    'Next Opened Workflow': 'Следующий открытый рабочий процесс',
    'Node Library': 'Библиотека узлов',
    Open: 'Открыть',
    'Open Custom Nodes Folder': 'Открыть папку пользовательских узлов',
    'Open DevTools': 'Открыть инструменты разработчика',
    'Open Inputs Folder': 'Открыть папку входных данных',
    'Open Logs Folder': 'Открыть папку журналов',
    'Open Models Folder': 'Открыть папку моделей',
    'Open Outputs Folder': 'Открыть папку выходных данных',
    'Open extra_model_paths_yaml': 'Открыть extra_model_paths.yaml',
    'Pin/Unpin Selected Items': 'Закрепить/открепить выбранные элементы',
    'Pin/Unpin Selected Nodes': 'Закрепить/открепить выбранные узлы',
    'Previous Opened Workflow': 'Предыдущий открытый рабочий процесс',
    Queue: 'Очередь',
    'Queue Prompt': 'Запрос в очереди',
    'Queue Prompt (Front)': 'Запрос в очереди (спереди)',
    Redo: 'Повторить',
    'Refresh Node Definitions': 'Обновить определения узлов',
    Reinstall: 'Переустановить',
    'Reset View': 'Сбросить вид',
    Restart: 'Перезапустить',
    Save: 'Сохранить',
    'Save As': 'Сохранить как',
    Settings: 'Настройки',
    Terminal: 'Терминал',
    'Toggle Bottom Panel': 'Переключить нижнюю панель',
    'Toggle Focus Mode': 'Переключить режим фокуса',
    'Toggle Link Visibility': 'Переключить видимость ссылок',
    'Toggle Lock': 'Переключить блокировку',
    'Toggle Search Box': 'Переключить поисковую панель',
    'Toggle Theme': 'Переключить тему',
    Undo: 'Отменить',
    'Ungroup selected group nodes': 'Разгруппировать выбранные групповые узлы',
    Workflow: 'Рабочий процесс',
    Workflows: 'Рабочие процессы',
    'Zoom In': 'Увеличить',
    'Zoom Out': 'Уменьшить'
  },
  newFolder$1 = 'Новая папка',
  no$1 = 'Нет',
  noResultsFound$1 = 'Ничего не найдено',
  noTasksFound$1 = 'Задачи не найдены',
  noTasksFoundMessage$1 = 'В очереди нет задач.',
  noWorkflowsFound$1 = 'Рабочие процессы не найдены.',
  nodeDefs$1 = {
    AddNoise: { display_name: 'Добавить шум' },
    AlignYourStepsScheduler: { display_name: 'Планировщик выравнивания шагов' },
    BasicGuider: { display_name: 'Основной гид' },
    BasicScheduler: { display_name: 'Основной планировщик' },
    BetaSamplingScheduler: { display_name: 'Планировщик выборки Бета' },
    CFGGuider: { display_name: 'CFG Гид' },
    CLIPAttentionMultiply: { display_name: 'Умножение внимания CLIP' },
    CLIPLoader: {
      description:
        '[Рецепты]\n\nstable_diffusion: clip-l\nstable_cascade: clip-g\nsd3: t5 / clip-g / clip-l\nstable_audio: t5\nmochi: t5',
      display_name: 'Загрузить CLIP'
    },
    CLIPMergeAdd: { display_name: 'Сложение CLIP' },
    CLIPMergeSimple: { display_name: 'Простое слияние CLIP' },
    CLIPMergeSubtract: { display_name: 'Вычитание CLIP' },
    CLIPSave: { display_name: 'Сохранить CLIP' },
    CLIPSetLastLayer: { display_name: 'Установить последний слой CLIP' },
    CLIPTextEncode: {
      description:
        'Кодирует текстовый запрос с помощью модели CLIP в вектор, который можно использовать для управления моделью диффузии для генерации конкретных изображений.',
      display_name: 'Кодирование текста CLIP (Запрос)'
    },
    CLIPTextEncodeControlnet: {
      display_name: 'Кодирование текста CLIP для Controlnet'
    },
    CLIPTextEncodeFlux: { display_name: 'Кодирование текста CLIP Flux' },
    CLIPTextEncodeHunyuanDiT: {
      display_name: 'Кодирование текста CLIP HunyuanDiT'
    },
    CLIPTextEncodeSD3: { display_name: 'Кодирование текста CLIP SD3' },
    CLIPTextEncodeSDXL: { display_name: 'Кодирование текста CLIP SDXL' },
    CLIPTextEncodeSDXLRefiner: {
      display_name: 'Кодирование текста CLIP SDXL Refinement'
    },
    CLIPVisionEncode: { display_name: 'Кодирование видения CLIP' },
    CLIPVisionLoader: { display_name: 'Загрузить видение CLIP' },
    Canny: { display_name: 'Канни' },
    CheckpointLoader: {
      display_name: 'Загрузить контрольную точку с конфигурацией (УСТАРЕЛО)'
    },
    CheckpointLoaderSimple: {
      description:
        'Загружает контрольную точку модели диффузии, модели диффузии используются для удаления шума из латентов.',
      display_name: 'Загрузить контрольную точку'
    },
    CheckpointSave: { display_name: 'Сохранить контрольную точку' },
    CombineHooks2: { display_name: 'Объединить хуки [2]' },
    CombineHooks4: { display_name: 'Объединить хуки [4]' },
    CombineHooks8: { display_name: 'Объединить хуки [8]' },
    ConditioningAverage: { display_name: 'Среднее кондиционирование' },
    ConditioningCombine: { display_name: 'Кондиционирование (Объединение)' },
    ConditioningConcat: { display_name: 'Кондиционирование (Конкатенация)' },
    ConditioningSetArea: {
      display_name: 'Кондиционирование (Установить область)'
    },
    ConditioningSetAreaPercentage: {
      display_name: 'Кондиционирование (Установить область с процентом)'
    },
    ConditioningSetAreaStrength: {
      display_name: 'Сила установки области кондиционирования'
    },
    ConditioningSetDefaultCombine: {
      display_name:
        'Установить значение по умолчанию для объединения кондиционирования'
    },
    ConditioningSetMask: {
      display_name: 'Кондиционирование (Установить маску)'
    },
    ConditioningSetProperties: {
      display_name: 'Установить свойства кондиционирования'
    },
    ConditioningSetPropertiesAndCombine: {
      display_name: 'Установить свойства кондиционирования и объединить'
    },
    ConditioningSetTimestepRange: {
      display_name: 'Установить диапазон временных шагов кондиционирования'
    },
    ConditioningTimestepsRange: { display_name: 'Диапазон временных шагов' },
    ConditioningZeroOut: { display_name: 'Обнуление кондиционирования' },
    ControlNetApply: { display_name: 'Применить ControlNet (СТАРОЕ)' },
    ControlNetApplyAdvanced: { display_name: 'Применить ControlNet' },
    ControlNetApplySD3: { display_name: 'Применить ControlNet с VAE' },
    ControlNetInpaintingAliMamaApply: {
      display_name: 'Применить ControlNet для инпейнтинга AliMama'
    },
    ControlNetLoader: { display_name: 'Загрузить модель ControlNet' },
    CreateHookKeyframe: { display_name: 'Создать ключевой кадр хука' },
    CreateHookKeyframesFromFloats: {
      display_name: 'Создать ключевые кадры хука из чисел с плавающей запятой'
    },
    CreateHookKeyframesInterpolated: {
      display_name: 'Создать интерполированные ключевые кадры хука'
    },
    CreateHookLora: { display_name: 'Создать хук LoRA' },
    CreateHookLoraModelOnly: {
      display_name: 'Создать хук LoRA (Только модель)'
    },
    CreateHookModelAsLora: { display_name: 'Создать хук модели как LoRA' },
    CreateHookModelAsLoraModelOnly: {
      display_name: 'Создать хук модели как LoRA (Только модель)'
    },
    CropMask: { display_name: 'Обрезать маску' },
    DevToolsDeprecatedNode: {
      description: 'Устаревший узел',
      display_name: 'Устаревший узел'
    },
    DevToolsErrorRaiseNode: {
      description: 'Выбросить ошибку для целей разработки',
      display_name: 'Выбросить ошибку'
    },
    DevToolsErrorRaiseNodeWithMessage: {
      description: 'Выбросить ошибку с сообщением для целей разработки',
      display_name: 'Выбросить ошибку с сообщением'
    },
    DevToolsExperimentalNode: {
      description: 'Экспериментальный узел',
      display_name: 'Экспериментальный узел'
    },
    DevToolsLongComboDropdown: {
      description: 'Длинный комбинированный выпадающий список',
      display_name: 'Длинный комбинированный выпадающий список'
    },
    DevToolsNodeWithForceInput: {
      description: 'Узел с принудительным вводом',
      display_name: 'Узел с принудительным вводом'
    },
    DevToolsNodeWithOnlyOptionalInput: {
      description: 'Узел только с необязательным вводом',
      display_name: 'Узел только с необязательным вводом'
    },
    DevToolsNodeWithOptionalInput: {
      description: 'Узел с необязательным вводом',
      display_name: 'Узел с необязательным вводом'
    },
    DevToolsNodeWithOutputList: {
      description: 'Узел с выходным списком',
      display_name: 'Узел с выходным списком'
    },
    DevToolsNodeWithStringInput: {
      description: 'Узел со строковым вводом',
      display_name: 'Узел со строковым вводом'
    },
    DevToolsNodeWithUnionInput: {
      description: 'Узел с объединённым вводом',
      display_name: 'Узел с объединённым вводом'
    },
    DiffControlNetLoader: {
      display_name: 'Загрузить модель ControlNet (дифф)'
    },
    DifferentialDiffusion: { display_name: 'Дифференциальная диффузия' },
    DiffusersLoader: { display_name: 'Загрузчик диффузоров' },
    DisableNoise: { display_name: 'Отключить шум' },
    DualCFGGuider: { display_name: 'Двойной CFG Гид' },
    DualCLIPLoader: {
      description:
        '[Рецепты]\n\nsdxl: clip-l, clip-g\nsd3: clip-l, clip-g / clip-l, t5 / clip-g, t5\nflux: clip-l, t5',
      display_name: 'Двойной загрузчик CLIP'
    },
    EmptyImage: { display_name: 'Пустое изображение' },
    EmptyLTXVLatentVideo: { display_name: 'Пустое латентное видео LTXV' },
    EmptyLatentAudio: { display_name: 'Пустой латентный аудио' },
    EmptyLatentImage: {
      description:
        'Создает новую партию пустых латентных изображений для удаления шума через выборку.',
      display_name: 'Пустое латентное изображение'
    },
    EmptyMochiLatentVideo: { display_name: 'Пустое латентное видео Mochi' },
    EmptySD3LatentImage: { display_name: 'Пустое латентное изображение SD3' },
    ExponentialScheduler: { display_name: 'Экспоненциальный планировщик' },
    FeatherMask: { display_name: 'Пернатая маска' },
    FlipSigmas: { display_name: 'Перевернуть сигмы' },
    FluxGuidance: { display_name: 'Направление Flux' },
    FreeU: { display_name: 'FreeU' },
    FreeU_V2: { display_name: 'FreeU_V2' },
    GITSScheduler: { display_name: 'GITSScheduler' },
    GLIGENLoader: { display_name: 'Загрузчик GLIGEN' },
    GLIGENTextBoxApply: { display_name: 'Применить текстовое поле GLIGEN' },
    GrowMask: { display_name: 'Увеличить маску' },
    HyperTile: { display_name: 'Гиперплитка' },
    HypernetworkLoader: { display_name: 'Загрузчик гиперсети' },
    ImageBatch: { display_name: 'Партия изображений' },
    ImageBlend: { display_name: 'Смешивание изображений' },
    ImageBlur: { display_name: 'Размытие изображения' },
    ImageColorToMask: { display_name: 'Цвет изображения в маску' },
    ImageCompositeMasked: { display_name: 'Составное изображение с маской' },
    ImageCrop: { display_name: 'Обрезка изображения' },
    ImageFromBatch: { display_name: 'Изображение из партии' },
    ImageInvert: { display_name: 'Инвертировать изображение' },
    ImageOnlyCheckpointLoader: {
      display_name:
        'Загрузчик контрольной точки только для изображения (модель img2vid)'
    },
    ImageOnlyCheckpointSave: {
      display_name: 'Сохранить только контрольную точку изображения'
    },
    ImagePadForOutpaint: {
      display_name: 'Добавить поля к изображению для выкрашивания'
    },
    ImageQuantize: { display_name: 'Квантизация изображения' },
    ImageScale: { display_name: 'Масштабировать изображение' },
    ImageScaleBy: { display_name: 'Масштабировать изображение на' },
    ImageScaleToTotalPixels: {
      display_name: 'Масштабировать изображение до общего количества пикселей'
    },
    ImageSharpen: { display_name: 'Резкость изображения' },
    ImageToMask: { display_name: 'Преобразовать изображение в маску' },
    ImageUpscaleWithModel: {
      display_name: 'Увеличить изображение (с использованием модели)'
    },
    InpaintModelConditioning: {
      display_name: 'Кондиционирование модели инпейнтинга'
    },
    InstructPixToPixConditioning: {
      display_name: 'Кондиционирование PixToPix'
    },
    InvertMask: { display_name: 'Инвертировать маску' },
    JoinImageWithAlpha: {
      display_name: 'Объединить изображение с альфа-каналом'
    },
    KSampler: {
      description:
        'Использует предоставленную модель, положительное и отрицательное кондиционирование для удаления шума из латентного изображения.',
      display_name: 'KSampler'
    },
    KSamplerAdvanced: { display_name: 'KSampler (Расширенный)' },
    KSamplerSelect: { display_name: 'Выбор KSampler' },
    KarrasScheduler: { display_name: 'Планировщик Карраса' },
    LTXVConditioning: { display_name: 'Кондиционирование LTXV' },
    LTXVImgToVideo: { display_name: 'LTXVImgToVideo' },
    LTXVScheduler: { display_name: 'Планировщик LTXV' },
    LaplaceScheduler: { display_name: 'Планировщик Лапласа' },
    LatentAdd: { display_name: 'Добавить латент' },
    LatentApplyOperation: { display_name: 'Применить операцию к латенту' },
    LatentApplyOperationCFG: {
      display_name: 'Применить операцию к латенту CFG'
    },
    LatentBatch: { display_name: 'Партия латентов' },
    LatentBatchSeedBehavior: {
      display_name: 'Поведение семени партии латентов'
    },
    LatentBlend: { display_name: 'Смешивание латентов' },
    LatentComposite: { display_name: 'Составной латент' },
    LatentCompositeMasked: { display_name: 'Составной латент с маской' },
    LatentCrop: { display_name: 'Обрезка латента' },
    LatentFlip: { display_name: 'Перевернуть латент' },
    LatentFromBatch: { display_name: 'Латент из партии' },
    LatentInterpolate: { display_name: 'Интерполяция латента' },
    LatentMultiply: { display_name: 'Умножить латент' },
    LatentOperationSharpen: { display_name: 'Операция латента: резкость' },
    LatentOperationTonemapReinhard: {
      display_name: 'Операция латента: тональная карта Рейнхарда'
    },
    LatentRotate: { display_name: 'Повернуть латент' },
    LatentSubtract: { display_name: 'Вычесть латент' },
    LatentUpscale: { display_name: 'Увеличить латент' },
    LatentUpscaleBy: { display_name: 'Увеличить латент на' },
    LoadAudio: { display_name: 'Загрузить аудио' },
    LoadImage: { display_name: 'Загрузить изображение' },
    LoadImageMask: { display_name: 'Загрузить изображение (как маску)' },
    LoadLatent: { display_name: 'Загрузить латент' },
    LoraLoader: {
      description:
        'LoRA используются для изменения моделей диффузии и CLIP, изменяя способ, которым латенты удаляются от шума, например, применяя стили. Несколько узлов LoRA могут быть связаны вместе.',
      display_name: 'Загрузить LoRA'
    },
    LoraLoaderModelOnly: {
      description:
        'LoRA используются для изменения моделей диффузии и CLIP, изменяя способ, которым латенты удаляются от шума, например, применяя стили. Несколько узлов LoRA могут быть связаны вместе.',
      display_name: 'Загрузчик LoRA (Только модель)'
    },
    LoraSave: { display_name: 'Извлечь и сохранить LoRA' },
    MaskComposite: { display_name: 'Составная маска' },
    MaskToImage: { display_name: 'Преобразовать маску в изображение' },
    ModelMergeAdd: { display_name: 'Сложение моделей' },
    ModelMergeAuraflow: { display_name: 'Слияние моделей Auraflow' },
    ModelMergeBlocks: { display_name: 'Слияние блоков моделей' },
    ModelMergeFlux1: { display_name: 'Слияние моделей Flux1' },
    ModelMergeLTXV: { display_name: 'Слияние моделей LTXV' },
    ModelMergeMochiPreview: {
      display_name: 'Предварительный просмотр слияния моделей Mochi'
    },
    ModelMergeSD1: { display_name: 'Слияние моделей SD1' },
    ModelMergeSD2: { display_name: 'Слияние моделей SD2' },
    ModelMergeSD35_Large: { display_name: 'Слияние моделей SD35_Large' },
    ModelMergeSD3_2B: { display_name: 'Слияние моделей SD3_2B' },
    ModelMergeSDXL: { display_name: 'Слияние моделей SDXL' },
    ModelMergeSimple: { display_name: 'Простое слияние моделей' },
    ModelMergeSubtract: { display_name: 'Вычитание моделей' },
    ModelSamplingAuraFlow: { display_name: 'Выборка модели AuraFlow' },
    ModelSamplingContinuousEDM: {
      display_name: 'Выборка модели Continuous EDM'
    },
    ModelSamplingContinuousV: { display_name: 'Выборка модели Continuous V' },
    ModelSamplingDiscrete: { display_name: 'Дискретная выборка модели' },
    ModelSamplingFlux: { display_name: 'Выборка модели Flux' },
    ModelSamplingLTXV: { display_name: 'Выборка модели LTXV' },
    ModelSamplingSD3: { display_name: 'Выборка модели SD3' },
    ModelSamplingStableCascade: {
      display_name: 'Выборка модели Stable Cascade'
    },
    ModelSave: { display_name: 'Сохранить модель' },
    Morphology: { display_name: 'Морфология изображения' },
    PairConditioningCombine: {
      display_name: 'Объединение пар кондиционирования'
    },
    PairConditioningSetDefaultCombine: {
      display_name:
        'Установить значение по умолчанию для объединения пар кондиционирования'
    },
    PairConditioningSetProperties: {
      display_name: 'Установить свойства пар кондиционирования'
    },
    PairConditioningSetPropertiesAndCombine: {
      display_name: 'Установить свойства пар кондиционирования и объединить'
    },
    PatchModelAddDownscale: {
      display_name: 'Добавить уменьшение модели патча (Kohya Deep Shrink)'
    },
    PerpNeg: { display_name: 'Перп-Нег (УСТАРЕЛО из-за PerpNegGuider)' },
    PerpNegGuider: { display_name: 'PerpNegGuider' },
    PerturbedAttentionGuidance: {
      display_name: 'Направление с учетом возмущений'
    },
    PhotoMakerEncode: { display_name: 'Кодирование PhotoMaker' },
    PhotoMakerLoader: { display_name: 'Загрузчик PhotoMaker' },
    PolyexponentialScheduler: {
      display_name: 'Полиэкспоненциальный планировщик'
    },
    PorterDuffImageComposite: {
      display_name: 'Составное изображение Портера-Даффа'
    },
    PreviewAudio: { display_name: 'Предварительный просмотр аудио' },
    PreviewImage: {
      description:
        'Сохраняет входные изображения в вашу директорию вывода ComfyUI.',
      display_name: 'Предварительный просмотр изображения'
    },
    RandomNoise: { display_name: 'Случайный шум' },
    RebatchImages: { display_name: 'Перепаковать изображения' },
    RebatchLatents: { display_name: 'Перепаковать латенты' },
    RepeatImageBatch: { display_name: 'Повторить партию изображений' },
    RepeatLatentBatch: { display_name: 'Повторить партию латентов' },
    RescaleCFG: { display_name: 'Масштабировать CFG' },
    SDTurboScheduler: { display_name: 'Планировщик SDTurbo' },
    SD_4XUpscale_Conditioning: { display_name: 'SD_4XUpscale_Conditioning' },
    SV3D_Conditioning: { display_name: 'SV3D_Кондиционирование' },
    SVD_img2vid_Conditioning: { display_name: 'SVD_img2vid_Кондиционирование' },
    SamplerCustom: { display_name: 'Пользовательский выборщик' },
    SamplerCustomAdvanced: {
      display_name: 'Пользовательский выборщик (Расширенный)'
    },
    SamplerDPMAdaptative: { display_name: 'Адаптивный выборщик DPM' },
    SamplerDPMPP_2M_SDE: { display_name: 'Выборщик DPMPP_2M_SDE' },
    SamplerDPMPP_2S_Ancestral: { display_name: 'Выборщик DPMPP_2S_Ancestral' },
    SamplerDPMPP_3M_SDE: { display_name: 'Выборщик DPMPP_3M_SDE' },
    SamplerDPMPP_SDE: { display_name: 'Выборщик DPMPP_SDE' },
    SamplerEulerAncestral: { display_name: 'Выборщик Эйлера (Анастр.)' },
    SamplerEulerAncestralCFGPP: {
      display_name: 'Выборщик Эйлера (Анастр.) CFG++'
    },
    SamplerEulerCFGpp: { display_name: 'Выборщик Эйлера CFG++' },
    SamplerLCMUpscale: { display_name: 'Выборщик LCM Upscale' },
    SamplerLMS: { display_name: 'Выборщик LMS' },
    SaveAnimatedPNG: { display_name: 'Сохранить анимированный PNG' },
    SaveAnimatedWEBP: { display_name: 'Сохранить анимированный WEBP' },
    SaveAudio: { display_name: 'Сохранить аудио' },
    SaveImage: {
      description:
        'Сохраняет входные изображения в вашу директорию вывода ComfyUI.',
      display_name: 'Сохранить изображение'
    },
    SaveImageWebsocket: {
      display_name: 'Сохранить изображение через веб-сокет'
    },
    SaveLatent: { display_name: 'Сохранить латент' },
    SelfAttentionGuidance: { display_name: 'Направление самовнимания' },
    SetClipHooks: { display_name: 'Установить хуки CLIP' },
    SetHookKeyframes: { display_name: 'Установить ключевые кадры хука' },
    SetLatentNoiseMask: { display_name: 'Установить маску шума латента' },
    SetUnionControlNetType: {
      display_name: 'Установить тип объединенного ControlNet'
    },
    SkipLayerGuidanceDiT: {
      description:
        'Универсальная версия узла SkipLayerGuidance, которую можно использовать на любой модели DiT.',
      display_name: 'Пропустить руководство по слоям DiT'
    },
    SkipLayerGuidanceSD3: {
      description:
        'Универсальная версия узла SkipLayerGuidance, которую можно использовать на любой модели DiT.',
      display_name: 'Пропустить руководство по слоям SD3'
    },
    SolidMask: { display_name: 'Сплошная маска' },
    SplitImageWithAlpha: {
      display_name: 'Разделить изображение с альфа-каналом'
    },
    SplitSigmas: { display_name: 'Разделить сигмы' },
    SplitSigmasDenoise: { display_name: 'Разделить сигмы для удаления шума' },
    StableCascade_EmptyLatentImage: {
      display_name: 'StableCascade_Пустое латентное изображение'
    },
    StableCascade_StageB_Conditioning: {
      display_name: 'StableCascade_Этап B_Кондиционирование'
    },
    StableCascade_StageC_VAEEncode: {
      display_name: 'StableCascade_Этап C_VAE Кодирование'
    },
    StableCascade_SuperResolutionControlnet: {
      display_name: 'StableCascade_Суперразрешение Controlnet'
    },
    StableZero123_Conditioning: {
      display_name: 'StableZero123_Кондиционирование'
    },
    StableZero123_Conditioning_Batched: {
      display_name: 'StableZero123_Кондиционирование_Пакетное'
    },
    StyleModelApply: { display_name: 'Применить модель стиля' },
    StyleModelLoader: { display_name: 'Загрузить модель стиля' },
    ThresholdMask: { display_name: 'Пороговая маска' },
    TomePatchModel: { display_name: 'Модель патча Tome' },
    TorchCompileModel: { display_name: 'Скомпилировать модель Torch' },
    TripleCLIPLoader: {
      description: '[Рецепты]\n\nsd3: clip-l, clip-g, t5',
      display_name: 'Тройной загрузчик CLIP'
    },
    UNETLoader: { display_name: 'Загрузить модель диффузии' },
    UNetCrossAttentionMultiply: {
      display_name: 'Умножение перекрестного внимания UNet'
    },
    UNetSelfAttentionMultiply: { display_name: 'Умножение самовнимания UNet' },
    UNetTemporalAttentionMultiply: {
      display_name: 'Умножение временного внимания UNet'
    },
    UpscaleModelLoader: { display_name: 'Загрузить модель увеличения' },
    VAEDecode: {
      description:
        'Декодирует латентные изображения обратно в изображения в пиксельном пространстве.',
      display_name: 'Декодировать VAE'
    },
    VAEDecodeAudio: { display_name: 'Декодировать аудио VAE' },
    VAEDecodeTiled: { display_name: 'Декодировать VAE (плитками)' },
    VAEEncode: { display_name: 'Кодировать VAE' },
    VAEEncodeAudio: { display_name: 'Кодировать аудио VAE' },
    VAEEncodeForInpaint: { display_name: 'Кодировать VAE (для инпейнтинга)' },
    VAEEncodeTiled: { display_name: 'Кодировать VAE (плитками)' },
    VAELoader: { display_name: 'Загрузить VAE' },
    VAESave: { display_name: 'Сохранить VAE' },
    VPScheduler: { display_name: 'Планировщик VP' },
    VideoLinearCFGGuidance: { display_name: 'Направление Video Linear CFG' },
    VideoTriangleCFGGuidance: {
      display_name: 'Направление Video Triangle CFG'
    },
    WebcamCapture: { display_name: 'Захват с веб-камеры' },
    unCLIPCheckpointLoader: {
      display_name: 'Загрузчик контрольной точки unCLIP'
    },
    unCLIPConditioning: { display_name: 'unCLIP кондиционирование' }
  },
  notSupported$1 = {
    continue: 'Продолжить',
    continueTooltip: 'Я уверен, что мое устройство поддерживается',
    learnMore: 'Узнать больше',
    message: 'Поддерживаются только следующие устройства:',
    reportIssue: 'Сообщить о проблеме',
    supportedDevices: {
      macos: 'MacOS (M1 или новее)',
      windows: 'Windows (Nvidia GPU с поддержкой CUDA)'
    },
    title: 'Ваше устройство не поддерживается'
  },
  openNewIssue$1 = 'Открыть новый Issue',
  overwrite$1 = 'Перезаписать',
  reconnected$1 = 'Переподключено',
  reconnecting$1 = 'Переподключение',
  refresh$1 = 'Обновить',
  reloadToApplyChanges$1 = 'Перезагрузите, чтобы применить изменения',
  rename$1 = 'Переименовать',
  reportIssue$1 = 'Отправить отчет',
  reportIssueTooltip$1 = 'Отправить отчет об ошибке в Comfy Org',
  reportSent$1 = 'Отчет отправлен',
  reset$1 = 'Сбросить',
  resetKeybindingsTooltip$1 = 'Сбросить сочетания клавиш по умолчанию',
  save$1 = 'Сохранить',
  searchExtensions$1 = 'Поиск расширений',
  searchFailedMessage$1 =
    'Не удалось найти ни одной настройки, соответствующей вашему запросу. Попробуйте скорректировать поисковый запрос.',
  searchKeybindings$1 = 'Поиск сочетаний клавиш',
  searchModels$1 = 'Поиск моделей',
  searchNodes$1 = 'Поиск узлов',
  searchSettings$1 = 'Поиск настроек',
  searchWorkflows$1 = 'Поиск рабочих процессов',
  serverConfig$1 = {
    modifiedConfigs:
      'Вы изменили следующие конфигурации сервера. Перезапустите, чтобы применить изменения.',
    restart: 'Перезапустить',
    revertChanges: 'Отменить изменения'
  },
  serverConfigCategories$1 = {
    Attention: 'Внимание',
    CUDA: 'CUDA',
    Cache: 'Кэш',
    General: 'Общее',
    Inference: 'Вывод',
    Memory: 'Память',
    Network: 'Сеть',
    Preview: 'Предпросмотр'
  },
  serverConfigItems$1 = {
    'cache-classic': { name: 'Использовать классическую систему кэширования' },
    'cache-lru': {
      name: 'Использовать LRU кэширование с максимальным количеством N кэшированных результатов узлов.',
      tooltip: 'Может использовать больше ОЗУ/ВРП.'
    },
    'cpu-vae': { name: 'Запуск VAE на CPU' },
    'cross-attention-method': { name: 'Метод перекрестного внимания' },
    'cuda-device': { name: 'Индекс устройства CUDA для использования' },
    'cuda-malloc': { name: 'Использовать CUDA malloc для выделения памяти' },
    'default-hashing-function': {
      name: 'Функция хеширования по умолчанию для файлов моделей'
    },
    deterministic: {
      name: 'Заставить pytorch использовать более медленные детерминированные алгоритмы, когда это возможно.',
      tooltip:
        'Обратите внимание, что это может не сделать изображения детерминированными во всех случаях.'
    },
    directml: { name: 'Индекс устройства DirectML' },
    'disable-all-custom-nodes': {
      name: 'Отключить загрузку всех пользовательских узлов.'
    },
    'disable-ipex-optimize': { name: 'Отключить оптимизацию IPEX' },
    'disable-metadata': {
      name: 'Отключить сохранение метаданных подсказок в файлах.'
    },
    'disable-smart-memory': {
      name: 'Отключить управление умной памятью',
      tooltip:
        'Принудить ComfyUI агрессивно выгружать в обычную оперативную память вместо того, чтобы держать модели в VRAM, когда это возможно.'
    },
    'disable-xformers': { name: 'Отключить оптимизацию xFormers' },
    'dont-print-server': { name: 'Не выводить вывод сервера в консоль.' },
    'dont-upcast-attention': { name: 'Предотвратить повышение внимания' },
    'enable-cors-header': {
      name: 'Включить CORS заголовок: Используйте "*" для всех источников или укажите домен'
    },
    fast: {
      name: 'Включить некоторые непроверенные и потенциально ухудшающие качество оптимизации.'
    },
    'force-channels-last': {
      name: 'Принудительное использование формата памяти с последними каналами'
    },
    'force-upcast-attention': { name: 'Принудительное повышение внимания' },
    'global-precision': {
      name: 'Глобальная точность с плавающей запятой',
      tooltip: 'Глобальная точность с плавающей запятой'
    },
    'log-level': { name: 'Уровень подробности логирования' },
    'max-upload-size': { name: 'Максимальный размер загрузки (МБ)' },
    'preview-method': { name: 'Метод, используемый для латентных превью' },
    'preview-size': { name: 'Размер превью изображений' },
    'reserve-vram': {
      name: 'Резервируемая VRAM (ГБ)',
      tooltip:
        'Установите количество VRAM в ГБ, которое вы хотите зарезервировать для использования вашей ОС/другими программами. По умолчанию резервируется определенное количество в зависимости от вашей ОС.'
    },
    'text-encoder-precision': {
      name: 'Точность текстового кодировщика',
      tooltip: 'Точность текстового кодировщика'
    },
    'tls-certfile': {
      name: 'TLS сертификат: Путь к TLS сертификату для HTTPS'
    },
    'tls-keyfile': {
      name: 'TLS ключевой файл: Путь к TLS ключевому файлу для HTTPS'
    },
    'unet-precision': { name: 'Точность UNET', tooltip: 'Точность UNET' },
    'vae-precision': { name: 'Точность VAE', tooltip: 'Точность VAE' },
    'vram-management': { name: 'Режим управления VRAM' }
  },
  serverStart$1 = {
    openLogs: 'Открыть логи',
    process: {
      error: 'Не удалось запустить ComfyUI Desktop',
      'initial-state': 'Загрузка...',
      'python-setup': 'Настройка окружения Python...',
      ready: 'Завершение...',
      'starting-server': 'Запуск сервера ComfyUI...'
    },
    reinstall: 'Переустановить',
    reportIssue: 'Сообщить о проблеме'
  },
  settings$1 = 'Настройки',
  settingsCategories$1 = {
    About: 'О программе',
    Appearance: 'Внешний вид',
    BrushAdjustment: 'Настройка кисти',
    Canvas: 'Холст',
    ColorPalette: 'Цветовая палитра',
    Comfy: 'Comfy',
    'Comfy-Desktop': 'Comfy рабочий стол',
    DevMode: 'Режим разработчика',
    EditAttention: 'Редактировать внимание',
    Extension: 'Расширение',
    General: 'Общие',
    Graph: 'Граф',
    Group: 'Группа',
    Keybinding: 'Сочетание клавиш',
    Link: 'Ссылка',
    LinkRelease: 'Освобождение ссылки',
    LiteGraph: 'Lite Graph',
    Locale: 'Локализация',
    'Mask Editor': 'Редактор масок',
    Menu: 'Меню',
    ModelLibrary: 'Библиотека моделей',
    NewEditor: 'Новый редактор',
    Node: 'Узел',
    'Node Search Box': 'Поисковая строка узлов',
    'Node Widget': 'Виджет узла',
    NodeInputConversionSubmenus: 'Подменю преобразования ввода узла',
    NodeLibrary: 'Библиотека узлов',
    Pointer: 'Указатель',
    Queue: 'Очередь',
    QueueButton: 'Кнопка очереди',
    RerouteBeta: 'Бета-версия перенаправления',
    Server: 'Сервер',
    'Server-Config': 'Настройки сервера',
    Settings: 'Настройки',
    Sidebar: 'Боковая панель',
    'Tree Explorer': 'Дерево проводника',
    Validation: 'Валидация',
    Window: 'Окно',
    Workflow: 'Рабочий процесс'
  },
  settingsDialog$1 = {
    'Comfy-Desktop_AutoUpdate': { name: 'Автоматически проверять обновления' },
    'Comfy-Desktop_SendStatistics': {
      name: 'Отправлять анонимные отчеты о сбоях'
    },
    Comfy_ColorPalette: { name: 'Цветовая палитра' },
    Comfy_ConfirmClear: {
      name: 'Требовать подтверждение при очистке рабочего процесса'
    },
    Comfy_DOMClippingEnabled: {
      name: 'Включить обрезку элементов DOM (включение может снизить производительность)'
    },
    Comfy_DevMode: {
      name: 'Включить параметры режима разработчика (сохранение API и т.д.)'
    },
    Comfy_DisableFloatRounding: {
      name: 'Отключить округление по умолчанию для плавающих виджетов.',
      tooltip:
        '(требуется перезагрузка страницы) Невозможно отключить округление, если оно установлено узлом на сервере.'
    },
    Comfy_DisableSliders: { name: 'Отключить ползунки виджетов узлов' },
    Comfy_EditAttention_Delta: { name: 'Точность Ctrl+вверх/вниз' },
    Comfy_EnableTooltips: { name: 'Включить подсказки' },
    Comfy_EnableWorkflowViewRestore: {
      name: 'Сохранять и восстанавливать положение и уровень масштабирования холста в рабочих процессах'
    },
    Comfy_Extension_Disabled: { name: 'Отключенные имена расширений' },
    Comfy_FloatRoundingPrecision: {
      name: 'Количество знаков после запятой для округления плавающего виджета [0 = авто].',
      tooltip: '(требуется перезагрузка страницы)'
    },
    Comfy_Graph_CanvasInfo: {
      name: 'Показать информацию о холсте в нижнем левом углу (fps и т.д.)'
    },
    Comfy_Graph_CanvasMenu: { name: 'Показать меню холста графа' },
    Comfy_Graph_CtrlShiftZoom: {
      name: 'Включить быстрый зум с помощью сочетания клавиш (Ctrl + Shift + Перетаскивание)'
    },
    Comfy_Graph_LinkMarkers: { name: 'Маркер середины ссылки' },
    Comfy_Graph_ZoomSpeed: { name: 'Скорость зума холста' },
    Comfy_GroupSelectedNodes_Padding: {
      name: 'Отступ для выбранных узлов группы'
    },
    Comfy_Group_DoubleClickTitleToEdit: {
      name: 'Дважды щелкните по заголовку группы, чтобы редактировать'
    },
    Comfy_InvertMenuScrolling: {
      name: 'Инвертировать прокрутку контекстного меню'
    },
    Comfy_Keybinding_NewBindings: {
      name: 'Сочетания клавиш, установленные пользователем'
    },
    Comfy_Keybinding_UnsetBindings: {
      name: 'Сочетания клавиш, снятые пользователем'
    },
    Comfy_LinkRelease_Action: {
      name: 'Действие при отпускании ссылки (без модификатора)'
    },
    Comfy_LinkRelease_ActionShift: {
      name: 'Действие при отпускании ссылки (Shift)'
    },
    Comfy_LinkRenderMode: { name: 'Режим рендеринга ссылки' },
    Comfy_Locale: { name: 'Язык' },
    Comfy_MaskEditor_BrushAdjustmentSpeed: {
      name: 'Множитель скорости регулировки кисти',
      tooltip:
        'Управляет тем, как быстро изменяются размер и жесткость кисти при регулировке. Более высокие значения означают более быстрые изменения.'
    },
    Comfy_MaskEditor_UseDominantAxis: {
      name: 'Закрепить регулировку кисти по доминирующей оси',
      tooltip:
        'При включении регулировки кисти будет влиять только на размер ИЛИ жесткость в зависимости от того, в каком направлении вы двигаетесь больше'
    },
    Comfy_MaskEditor_UseNewEditor: {
      name: 'Использовать новый редактор масок',
      tooltip: 'Переключиться на новый интерфейс редактора масок'
    },
    Comfy_MenuPosition: { name: 'Сохранить положение старого меню' },
    Comfy_ModelLibrary_AutoLoadAll: {
      name: 'Автоматически загружать все папки моделей',
      tooltip:
        'Если true, все папки будут загружены, как только вы откроете библиотеку моделей (это может вызвать задержки при загрузке). Если false, корневые папки моделей будут загружены только после нажатия на них.'
    },
    Comfy_ModelLibrary_NameFormat: {
      name: 'Какое имя отображать в древовидном представлении библиотеки моделей',
      tooltip:
        'Выберите "имя файла", чтобы отобразить упрощенный вид сырого имени файла (без директории или расширения ".safetensors") в списке моделей. Выберите "название", чтобы отобразить настраиваемое название метаданных модели.'
    },
    Comfy_NodeBadge_NodeIdBadgeMode: { name: 'Режим значка ID узла' },
    Comfy_NodeBadge_NodeLifeCycleBadgeMode: {
      name: 'Режим значка жизненного цикла узла'
    },
    Comfy_NodeBadge_NodeSourceBadgeMode: {
      name: 'Режим значка источника узла'
    },
    Comfy_NodeInputConversionSubmenus: {
      name: 'В контекстном меню узла разместите элементы, которые конвертируют между вводом/виджетом в подменю.'
    },
    Comfy_NodeLibrary_Bookmarks: {
      name: 'Закладки библиотеки узлов с отображаемым именем (устарело)'
    },
    Comfy_NodeLibrary_BookmarksCustomization: {
      name: 'Настройка закладок библиотеки узлов'
    },
    Comfy_NodeLibrary_Bookmarks_V2: {
      name: 'Закладки библиотеки узлов v2 с уникальным именем'
    },
    Comfy_NodeSearchBoxImpl: { name: 'Реализация поискового поля узлов' },
    Comfy_NodeSearchBoxImpl_NodePreview: {
      name: 'Предварительный просмотр узла',
      tooltip: 'Применяется только к стандартной реализации'
    },
    Comfy_NodeSearchBoxImpl_ShowCategory: {
      name: 'Показать категорию узла в результатах поиска',
      tooltip: 'Применяется только к стандартной реализации'
    },
    Comfy_NodeSearchBoxImpl_ShowIdName: {
      name: 'Показать имя ID узла в результатах поиска',
      tooltip: 'Применяется только к стандартной реализации'
    },
    Comfy_NodeSearchBoxImpl_ShowNodeFrequency: {
      name: 'Показать частоту узла в результатах поиска',
      tooltip: 'Применяется только к стандартной реализации'
    },
    Comfy_NodeSuggestions_number: {
      name: 'Количество предложений узлов',
      tooltip: 'Только для поля поиска litegraph/контекстного меню'
    },
    Comfy_Node_AutoSnapLinkToSlot: {
      name: 'Автоматически привязывать ссылку к слоту узла',
      tooltip:
        'При перетаскивании ссылки над узлом ссылка автоматически привязывается к подходящему входному слоту узла'
    },
    Comfy_Node_BypassAllLinksOnDelete: {
      name: 'Сохранить все ссылки при удалении узлов',
      tooltip:
        'При удалении узла попытаться переподключить все его входные и выходные ссылки (обходя удаленный узел)'
    },
    Comfy_Node_DoubleClickTitleToEdit: {
      name: 'Дважды щелкните по заголовку узла, чтобы редактировать'
    },
    Comfy_Node_MiddleClickRerouteNode: {
      name: 'Средний щелчок создает новый узел перенаправления'
    },
    Comfy_Node_Opacity: { name: 'Непрозрачность узла' },
    Comfy_Node_ShowDeprecated: {
      name: 'Показать устаревшие узлы в поиске',
      tooltip:
        'Устаревшие узлы по умолчанию скрыты в интерфейсе, но остаются функциональными в существующих рабочих процессах, которые их используют.'
    },
    Comfy_Node_ShowExperimental: {
      name: 'Показать экспериментальные узлы в поиске',
      tooltip:
        'Экспериментальные узлы помечены как таковые в интерфейсе и могут подвергаться значительным изменениям или удалению в будущих версиях. Используйте с осторожностью в производственных рабочих процессах'
    },
    Comfy_Node_SnapHighlightsNode: {
      name: 'Подсветка узла при привязке',
      tooltip:
        'При перетаскивании ссылки над узлом с подходящим входным слотом, узел подсвечивается'
    },
    Comfy_Pointer_ClickBufferTime: {
      name: 'Задержка дрейфа щелчка указателя',
      tooltip:
        'После нажатия кнопки указателя, это максимальное время (в миллисекундах), в течение которого движение указателя может быть проигнорировано.\n\nПомогает предотвратить непреднамеренное смещение объектов, если указатель перемещается во время щелчка.'
    },
    Comfy_Pointer_ClickDrift: {
      name: 'Дрейф щелчка указателя (максимальное расстояние)',
      tooltip:
        'Если указатель перемещается более чем на это расстояние, удерживая кнопку, это считается перетаскиванием (а не щелчком).\n\nПомогает предотвратить непреднамеренное смещение объектов, если указатель перемещается во время щелчка.'
    },
    Comfy_Pointer_DoubleClickTime: {
      name: 'Интервал двойного щелчка (максимум)',
      tooltip:
        'Максимальное время в миллисекундах между двумя щелчками двойного щелчка. Увеличение этого значения может помочь, если двойные щелчки иногда не регистрируются.'
    },
    Comfy_PreviewFormat: {
      name: 'Формат изображения предварительного просмотра',
      tooltip:
        'При отображении предварительного просмотра в виджете изображения, преобразуйте его в легковесное изображение, например, webp, jpeg, webp;50 и т.д.'
    },
    Comfy_PromptFilename: {
      name: 'Запрос имени файла при сохранении рабочего процесса'
    },
    Comfy_QueueButton_BatchCountLimit: {
      name: 'Ограничение количества партий',
      tooltip:
        'Максимальное количество задач, добавляемых в очередь за одно нажатие кнопки'
    },
    Comfy_Queue_ImageFit: { name: 'Подгонка изображения в очереди' },
    Comfy_Queue_MaxHistoryItems: {
      name: 'Размер истории очереди',
      tooltip: 'Максимальное количество задач, отображаемых в истории очереди.'
    },
    Comfy_RerouteBeta: {
      name: 'Участвовать в бета-тестировании перенаправления',
      tooltip:
        'Включает новые нативные перенаправления.\n\nПеренаправления можно добавлять, удерживая alt и перетаскивая от линии ссылки или в меню ссылки.\n\nОтключение этой опции не разрушительно - перенаправления скрыты.'
    },
    Comfy_Server_LaunchArgs: {
      name: 'Аргументы запуска сервера',
      tooltip:
        'Это фактические аргументы, которые передаются серверу при его запуске.'
    },
    Comfy_Server_ServerConfigValues: {
      name: 'Значения конфигурации сервера для отображения на фронтенде',
      tooltip:
        'Значения конфигурации сервера, используемые только для отображения на фронтенде'
    },
    Comfy_Settings_ExtensionPanel: {
      name: 'Показать панель расширений в диалоговом окне настроек'
    },
    Comfy_Sidebar_Location: { name: 'Расположение боковой панели' },
    Comfy_Sidebar_Size: { name: 'Размер боковой панели' },
    Comfy_SnapToGrid_GridSize: {
      name: 'Размер сетки привязки',
      tooltip:
        'При перетаскивании и изменении размера узлов, удерживая shift, они будут выровнены по сетке, это контролирует размер этой сетки.'
    },
    Comfy_TextareaWidget_FontSize: {
      name: 'Размер шрифта виджета текстовой области'
    },
    Comfy_TextareaWidget_Spellcheck: {
      name: 'Проверка орфографии виджета текстовой области'
    },
    Comfy_TreeExplorer_ItemPadding: {
      name: 'Отступ элемента в проводнике дерева'
    },
    Comfy_UseNewMenu: { name: 'Использовать новое меню' },
    Comfy_Validation_NodeDefs: {
      name: 'Проверка определений узлов (медленно)',
      tooltip:
        'Рекомендуется для разработчиков узлов. Это проверит все определения узлов при запуске.'
    },
    Comfy_Validation_Workflows: { name: 'Проверка рабочих процессов' },
    Comfy_WidgetControlMode: {
      name: 'Режим управления виджетом',
      tooltip:
        'Управляет тем, когда обновляются значения виджета (случайные/увеличение/уменьшение), либо до того, как запрос будет поставлен в очередь, либо после.'
    },
    Comfy_Window_UnloadConfirmation: {
      name: 'Показать подтверждение при закрытии окна'
    },
    Comfy_Workflow_ConfirmDelete: {
      name: 'Показать подтверждение при удалении рабочих процессов'
    },
    Comfy_Workflow_ShowMissingModelsWarning: {
      name: 'Показать предупреждение об отсутствующих моделях'
    },
    Comfy_Workflow_ShowMissingNodesWarning: {
      name: 'Показать предупреждение об отсутствующих узлах'
    },
    Comfy_Workflow_SortNodeIdOnSave: {
      name: 'Сортировать ID узлов при сохранении рабочего процесса'
    },
    Comfy_Workflow_WorkflowTabsPosition: {
      name: 'Положение открытых рабочих процессов'
    },
    LiteGraph_Canvas_MaximumFps: {
      name: 'Максимум FPS',
      tooltip:
        'Максимальное количество кадров в секунду, которое холст может рендерить. Ограничивает использование GPU за счет плавности. Если 0, используется частота обновления экрана. По умолчанию: 0'
    },
    pysssss_SnapToGrid: { name: 'Всегда привязываться к сетке' }
  },
  showReport$1 = 'Показать отчёт',
  sideToolbar$1 = {
    browseTemplates: 'Просмотреть примеры шаблонов',
    downloads: 'Загрузки',
    logout: 'Выйти',
    modelLibrary: 'Библиотека моделей',
    newBlankWorkflow: 'Создайте новый пустой рабочий процесс',
    nodeLibrary: 'Библиотека узлов',
    nodeLibraryTab: { sortOrder: 'Порядок сортировки' },
    openWorkflow: 'Открыть рабочий процесс в локальной файловой системе',
    queue: 'Очередь',
    queueTab: {
      backToAllTasks: 'Вернуться ко всем задачам',
      clearPendingTasks: 'Очистить отложенные задачи',
      containImagePreview: 'Предпросмотр заливающего изображения',
      coverImagePreview: 'Предпросмотр подходящего изображения',
      filter: 'Фильтровать выводы',
      filters: {
        hideCached: 'Скрыть кэшированные',
        hideCanceled: 'Скрыть отмененные'
      },
      showFlatList: 'Показать плоский список'
    },
    themeToggle: 'Переключить тему',
    workflowTab: {
      confirmDelete: 'Вы уверены, что хотите удалить этот рабочий процесс?',
      confirmDeleteTitle: 'Удалить рабочий процесс?',
      confirmOverwrite: 'Файл ниже уже существует. Вы хотите его перезаписать?',
      confirmOverwriteTitle: 'Перезаписать существующий файл?',
      deleteFailed: 'Попытка удалить рабочий процесс не удалась.',
      deleteFailedTitle: 'Не удалось удалить',
      deleted: 'Рабочий процесс удален',
      dirtyClose:
        'Файлы ниже были изменены. Вы хотите сохранить их перед закрытием?',
      dirtyCloseTitle: 'Сохранить изменения?'
    },
    workflows: 'Рабочие процессы'
  },
  star$1 = 'Звёздочка',
  systemInfo$1 = 'Информация о системе',
  tabMenu$1 = {
    closeOtherTabs: 'Закрыть другие вкладки',
    closeTab: 'Закрыть вкладку',
    closeTabsToLeft: 'Закрыть вкладки слева',
    closeTabsToRight: 'Закрыть вкладки справа',
    duplicateTab: 'Дублировать вкладку'
  },
  templateWorkflows$1 = {
    template: {
      default: 'Image Generation',
      flux_schnell: 'Flux Schnell',
      image2image: 'Image to Image',
      upscale: '2 Pass Upscale'
    },
    title: 'Начните работу с шаблона'
  },
  terminal$1 = 'Терминал',
  userSelect$1 = {
    enterUsername: 'Введите имя пользователя',
    existingUser: 'Существующий пользователь',
    newUser: 'Новый пользователь',
    next: 'Далее',
    selectUser: 'Выберите пользователя'
  },
  videoFailedToLoad$1 = 'Видео не удалось загрузить',
  welcome$1 = { getStarted: 'Начать', title: 'Добро пожаловать в ComfyUI' },
  ru = {
    about: about$1,
    add: add$1,
    bookmark: bookmark$1,
    box: box$1,
    briefcase: briefcase$1,
    cancel: cancel$1,
    color: color$1,
    comingSoon: comingSoon$1,
    confirm: confirm$2,
    copyToClipboard: copyToClipboard$1,
    currentUser: currentUser$1,
    customize: customize$1,
    customizeFolder: customizeFolder$1,
    delete: 'Удалить',
    deprecated: deprecated$1,
    desktopMenu: desktopMenu$1,
    devices: devices$1,
    download: download$1,
    downloadGit: downloadGit$1,
    electronFileDownload: electronFileDownload$1,
    empty: empty$1,
    error: error$1,
    experimental: experimental$1,
    extensionName: extensionName$1,
    file: file$1,
    findIssues: findIssues$1,
    firstTimeUIMessage: firstTimeUIMessage$1,
    folder: folder$1,
    goToNode: goToNode$1,
    graphCanvasMenu: graphCanvasMenu$1,
    heart: heart$1,
    icon: icon$1,
    imageFailedToLoad: imageFailedToLoad$1,
    inbox: inbox$1,
    insert: insert$1,
    install: install$1,
    loadAllFolders: loadAllFolders$1,
    loadWorkflow: loadWorkflow$1,
    loading: loading$1,
    logs: logs$1,
    menu: menu$1,
    menuLabels: menuLabels$1,
    newFolder: newFolder$1,
    no: no$1,
    noResultsFound: noResultsFound$1,
    noTasksFound: noTasksFound$1,
    noTasksFoundMessage: noTasksFoundMessage$1,
    noWorkflowsFound: noWorkflowsFound$1,
    nodeDefs: nodeDefs$1,
    notSupported: notSupported$1,
    openNewIssue: openNewIssue$1,
    overwrite: overwrite$1,
    reconnected: reconnected$1,
    reconnecting: reconnecting$1,
    refresh: refresh$1,
    reloadToApplyChanges: reloadToApplyChanges$1,
    rename: rename$1,
    reportIssue: reportIssue$1,
    reportIssueTooltip: reportIssueTooltip$1,
    reportSent: reportSent$1,
    reset: reset$1,
    resetKeybindingsTooltip: resetKeybindingsTooltip$1,
    save: save$1,
    searchExtensions: searchExtensions$1,
    searchFailedMessage: searchFailedMessage$1,
    searchKeybindings: searchKeybindings$1,
    searchModels: searchModels$1,
    searchNodes: searchNodes$1,
    searchSettings: searchSettings$1,
    searchWorkflows: searchWorkflows$1,
    serverConfig: serverConfig$1,
    serverConfigCategories: serverConfigCategories$1,
    serverConfigItems: serverConfigItems$1,
    serverStart: serverStart$1,
    settings: settings$1,
    settingsCategories: settingsCategories$1,
    settingsDialog: settingsDialog$1,
    showReport: showReport$1,
    sideToolbar: sideToolbar$1,
    star: star$1,
    systemInfo: systemInfo$1,
    tabMenu: tabMenu$1,
    templateWorkflows: templateWorkflows$1,
    terminal: terminal$1,
    userSelect: userSelect$1,
    videoFailedToLoad: videoFailedToLoad$1,
    welcome: welcome$1
  },
  about = '情報',
  add = '追加',
  bookmark = 'ブックマーク',
  box = 'ボックス',
  briefcase = 'ブリーフケース',
  cancel = 'キャンセル',
  color = '色',
  comingSoon = '近日公開',
  confirm$1 = '確認',
  copyToClipboard = 'クリップボードにコピー',
  currentUser = '現在のユーザー',
  customize = 'カスタマイズ',
  customizeFolder = 'フォルダーをカスタマイズ',
  deprecated = '非推奨',
  desktopMenu = {
    confirmReinstall:
      'これにより、extra_models_config.yamlファイルがクリアされ、再インストールが開始されます。本当によろしいですか？',
    reinstall: '再インストール'
  },
  devices = 'デバイス',
  download = 'ダウンロード',
  downloadGit = {
    gitWebsite: 'Gitをダウンロード',
    instructions:
      'お使いのオペレーティングシステムに最新バージョンをダウンロードしてインストールしてください。以下の「Gitをダウンロード」ボタンをクリックすると、git-scm.comのダウンロードページが開きます。',
    message:
      'Gitを見つけることができません。正常に動作するためには、Gitの作業コピーが必要です。',
    skip: 'スキップ',
    title: 'Gitをダウンロード',
    warning:
      'Gitがインストールされていなくても問題ないと確信している場合、または間違いがあった場合は、「スキップ」をクリックしてこのチェックをスキップできます。作業コピーのない状態でComfyUIを実行することは現在サポートされていません。'
  },
  electronFileDownload = {
    cancel: 'ダウンロードをキャンセル',
    cancelled: 'キャンセルされました',
    inProgress: 'ダウンロード中',
    pause: 'ダウンロードを一時停止',
    paused: '一時停止',
    resume: 'ダウンロードを再開'
  },
  empty = '表示する項目がありません',
  error = 'エラー',
  experimental = 'ベータ',
  extensionName = '拡張機能名',
  file = 'ファイル',
  findIssues = '問題を探す',
  firstTimeUIMessage =
    'あなたはこの新しいUIを初めて使用します。もし以前のUIに戻したい場合は、"メニュー > 新しいメニューを使用 > Disabled"を選択してください。',
  folder = 'フォルダー',
  goToNode = 'ノードへ移動',
  graphCanvasMenu = {
    fitView: 'ビューに合わせる',
    panMode: 'パンモード',
    resetView: 'ビューをリセット',
    selectMode: '選択モード',
    toggleLinkVisibility: 'リンクの表示切り替え',
    zoomIn: '拡大',
    zoomOut: '縮小'
  },
  heart = 'ハート',
  icon = 'アイコン',
  imageFailedToLoad = '画像の読み込みに失敗しました',
  inbox = '受信箱',
  insert = '挿入',
  install = {
    appDataLocationTooltip:
      'ComfyUIのアプリデータディレクトリ。保存内容:\n- ログ\n- サーバー設定',
    appPathLocationTooltip:
      'ComfyUIのアプリ資産ディレクトリ。ComfyUIのコードとアセットを保存します',
    chooseInstallationLocation: 'インストール先を選択',
    customNodes: 'カスタムノード',
    customNodesDescription:
      '既存のComfyUIインストールからカスタムノードファイルを参照し、その依存関係をインストールします。',
    desktopAppSettings: 'デスクトップアプリの設定',
    desktopAppSettingsDescription:
      'ComfyUIのデスクトップでの動作を設定します。これらの設定は後で変更可能です。',
    desktopSettings: 'デスクトップ設定',
    failedToSelectDirectory: 'ディレクトリの選択に失敗しました',
    installLocation: 'インストール先',
    installLocationDescription:
      'ComfyUIのユーザーデータを保存するディレクトリを選択してください。Python環境が選択した場所にインストールされます。選択したディスクに約15GBの空き容量が必要です。',
    installLocationTooltip:
      'ComfyUIのユーザーデータディレクトリ。保存内容:\n- Python環境\n- モデル\n- カスタムノード\n',
    migrateFromExistingInstallation: '既存のインストールから移行',
    migration: '移行',
    migrationOptional:
      '移行は任意です。既存のインストールがない場合、このステップをスキップできます。',
    migrationSourcePathDescription:
      '既存のComfyUIインストールがある場合、既存のユーザーファイルやモデルを新しいインストールにコピー/リンクできます。',
    pathValidationFailed: 'パスの検証に失敗しました',
    selectItemsToMigrate: '移行する項目を選択',
    settings: {
      allowMetrics: 'クラッシュレポート',
      allowMetricsDescription:
        'ComfyUIの改善に協力してください。匿名のクラッシュレポートを送信します。個人情報やワークフロー内容は収集されません。この設定はいつでも無効にできます。',
      autoUpdate: '自動更新',
      autoUpdateDescription:
        '更新が利用可能になると、自動的にダウンロードおよびインストールを行います。インストール前に通知が表示されます。',
      dataCollectionDialog: {
        customNodeConfigurations: 'カスタムノード設定',
        errorReports: 'エラーメッセージとスタックトレース',
        fileSystemInformation: 'ファイルシステム情報',
        personalInformation: '個人情報',
        systemInfo: 'ハードウェア、OSの種類、アプリのバージョン',
        title: 'データ収集について',
        whatWeCollect: '収集内容:',
        whatWeDoNotCollect: '収集しない内容:',
        workflowContent: 'ワークフロー内容',
        workflowContents: 'ワークフロー内容'
      },
      learnMoreAboutData: 'データ収集の詳細を見る'
    },
    systemLocations: 'システムの場所'
  },
  loadAllFolders = 'すべてのフォルダーを読み込む',
  loadWorkflow = 'ワークフローを読み込む',
  loading = '読み込み中',
  logs = 'ログ',
  menu = {
    autoQueue: '自動キュー',
    batchCount: 'バッチ数',
    batchCountTooltip: 'ワークフロー生成回数',
    clear: 'ワークフローをクリア',
    clipspace: 'クリップスペースを開く',
    disabled: '無効',
    disabledTooltip: 'ワークフローは自動的にキューに追加されません',
    execute: '実行',
    hideMenu: 'メニューを隠す',
    instant: '即時',
    instantTooltip: '生成完了後すぐにキューに追加',
    interrupt: '現在の実行を中止',
    onChange: '変更時',
    onChangeTooltip: '変更が行われるとワークフローがキューに追加されます',
    queue: '実行',
    queueWorkflow: 'キューに追加 (Shiftで先頭に)',
    queueWorkflowFront: '先頭に追加',
    refresh: 'ノードを更新',
    resetView: 'ビューをリセット',
    showMenu: 'メニューを表示',
    toggleBottomPanel: '下部パネルを切り替え'
  },
  menuLabels = {
    'Browse Templates': 'テンプレートを参照',
    'Bypass/Unbypass Selected Nodes': '選択したノードのバイパス/バイパス解除',
    'Clear Pending Tasks': '保留中のタスクをクリア',
    'Clear Workflow': 'ワークフローをクリア',
    Clipspace: 'クリップスペース',
    'Collapse/Expand Selected Nodes': '選択したノードの折りたたみ/展開',
    'Comfy-Org Discord': 'Comfy-Org Discord',
    'ComfyUI Docs': 'ComfyUIのドキュメント',
    'ComfyUI Issues': 'ComfyUIの問題',
    'Convert selected nodes to group node':
      '選択したノードをグループノードに変換',
    Edit: '編集',
    Export: 'エクスポート',
    'Export (API)': 'エクスポート (API)',
    Feedback: 'フィードバック',
    'Fit Group To Contents': 'グループを内容に合わせる',
    'Fit view to selected nodes': '選択したノードにビューを合わせる',
    'Group Selected Nodes': '選択したノードをグループ化',
    Help: 'ヘルプ',
    Interrupt: '中断',
    'Load Default Workflow': 'デフォルトワークフローを読み込む',
    Logs: 'ログ',
    'Manage group nodes': 'グループノードを管理',
    'Model Library': 'モデルライブラリ',
    'Mute/Unmute Selected Nodes': '選択したノードのミュート/ミュート解除',
    New: '新規',
    'Next Opened Workflow': '次に開いたワークフロー',
    'Node Library': 'ノードライブラリ',
    Open: '開く',
    'Open Custom Nodes Folder': 'カスタムノードフォルダを開く',
    'Open DevTools': 'DevToolsを開く',
    'Open Inputs Folder': '入力フォルダを開く',
    'Open Logs Folder': 'ログフォルダを開く',
    'Open Models Folder': 'モデルフォルダを開く',
    'Open Outputs Folder': '出力フォルダを開く',
    'Open extra_model_paths_yaml': 'extra_model_paths.yamlを開く',
    'Pin/Unpin Selected Items': '選択したアイテムのピン留め/ピン留め解除',
    'Pin/Unpin Selected Nodes': '選択したノードのピン留め/ピン留め解除',
    'Previous Opened Workflow': '前に開いたワークフロー',
    Queue: 'キュー',
    'Queue Prompt': 'キューのプロンプト',
    'Queue Prompt (Front)': 'キューのプロンプト (前面)',
    Redo: 'やり直す',
    'Refresh Node Definitions': 'ノード定義を更新',
    Reinstall: '再インストール',
    'Reset View': 'ビューをリセット',
    Restart: '再起動',
    Save: '保存',
    'Save As': '名前を付けて保存',
    Settings: '設定',
    Terminal: 'ターミナル',
    'Toggle Bottom Panel': '下部パネルの切り替え',
    'Toggle Focus Mode': 'フォーカスモードの切り替え',
    'Toggle Link Visibility': 'リンクの表示/非表示を切り替え',
    'Toggle Lock': 'ロックの切り替え',
    'Toggle Search Box': '検索ボックスの切り替え',
    'Toggle Theme': 'テーマの切り替え',
    Undo: '元に戻す',
    'Ungroup selected group nodes': '選択したグループノードのグループ解除',
    Workflow: 'ワークフロー',
    Workflows: 'ワークフロー',
    'Zoom In': 'ズームイン',
    'Zoom Out': 'ズームアウト'
  },
  newFolder = '新しいフォルダー',
  no = 'いいえ',
  noResultsFound = '結果が見つかりませんでした',
  noTasksFound = 'タスクが見つかりませんでした',
  noTasksFoundMessage = 'キューにタスクがありません。',
  noWorkflowsFound = 'ワークフローが見つかりませんでした。',
  nodeDefs = {
    AddNoise: { display_name: 'ノイズを追加' },
    AlignYourStepsScheduler: { display_name: 'ステップを整列' },
    BasicGuider: { display_name: '基本ガイダー' },
    BasicScheduler: { display_name: '基本スケジューラー' },
    BetaSamplingScheduler: { display_name: 'ベータサンプリングスケジューラー' },
    CFGGuider: { display_name: 'CFGガイダー' },
    CLIPAttentionMultiply: { display_name: 'CLIP注意の乗算' },
    CLIPLoader: {
      description:
        '[レシピ]\n\nstable_diffusion: clip-l\nstable_cascade: clip-g\nsd3: t5 / clip-g / clip-l\nstable_audio: t5\nmochi: t5',
      display_name: 'CLIPを読み込む'
    },
    CLIPMergeAdd: { display_name: 'CLIPマージ追加' },
    CLIPMergeSimple: { display_name: 'CLIPマージシンプル' },
    CLIPMergeSubtract: { display_name: 'CLIPマージ減算' },
    CLIPSave: { display_name: 'CLIPを保存' },
    CLIPSetLastLayer: { display_name: 'CLIPの最終層を設定' },
    CLIPTextEncode: {
      description:
        'テキストプロンプトをCLIPモデルを使用してエンコードし、特定の画像を生成するために拡散モデルをガイドするために使用できる埋め込みに変換します。',
      display_name: 'CLIPテキストエンコード（プロンプト）'
    },
    CLIPTextEncodeControlnet: {
      display_name: 'CLIPテキストエンコードコントロールネット'
    },
    CLIPTextEncodeFlux: { display_name: 'CLIPテキストエンコードフラックス' },
    CLIPTextEncodeHunyuanDiT: {
      display_name: 'CLIPテキストエンコードフンユアンDiT'
    },
    CLIPTextEncodeSD3: { display_name: 'CLIPテキストエンコードSD3' },
    CLIPTextEncodeSDXL: { display_name: 'CLIPテキストエンコードSDXL' },
    CLIPTextEncodeSDXLRefiner: {
      display_name: 'CLIPテキストエンコードSDXLリファイナー'
    },
    CLIPVisionEncode: { display_name: 'CLIPビジョンエンコード' },
    CLIPVisionLoader: { display_name: 'CLIPビジョンを読み込む' },
    Canny: { display_name: 'キャニー' },
    CheckpointLoader: {
      display_name: '設定でチェックポイントを読み込む（非推奨）'
    },
    CheckpointLoaderSimple: {
      description:
        '拡散モデルのチェックポイントを読み込みます。拡散モデルは潜在変数のノイズを除去するために使用されます。',
      display_name: 'チェックポイントを読み込む'
    },
    CheckpointSave: { display_name: 'チェックポイントを保存' },
    CombineHooks2: { display_name: 'フックを組み合わせる [2]' },
    CombineHooks4: { display_name: 'フックを組み合わせる [4]' },
    CombineHooks8: { display_name: 'フックを組み合わせる [8]' },
    ConditioningAverage: { display_name: '条件付け平均' },
    ConditioningCombine: { display_name: '条件付け（組み合わせ）' },
    ConditioningConcat: { display_name: '条件付け（連結）' },
    ConditioningSetArea: { display_name: '条件付け（エリア設定）' },
    ConditioningSetAreaPercentage: {
      display_name: '条件付け（パーセンテージでエリア設定）'
    },
    ConditioningSetAreaStrength: { display_name: '条件付けエリア強度' },
    ConditioningSetDefaultCombine: {
      display_name: '条件付けデフォルト組み合わせを設定'
    },
    ConditioningSetMask: { display_name: '条件付け（マスク設定）' },
    ConditioningSetProperties: { display_name: '条件付けプロパティ設定' },
    ConditioningSetPropertiesAndCombine: {
      display_name: '条件付けプロパティ設定と組み合わせ'
    },
    ConditioningSetTimestepRange: {
      display_name: '条件付けタイムステップ範囲'
    },
    ConditioningTimestepsRange: { display_name: 'タイムステップ範囲' },
    ConditioningZeroOut: { display_name: '条件付けゼロアウト' },
    ControlNetApply: { display_name: 'ControlNetを適用（旧）' },
    ControlNetApplyAdvanced: { display_name: 'ControlNetを適用' },
    ControlNetApplySD3: { display_name: 'VAEでControlNetを適用' },
    ControlNetInpaintingAliMamaApply: {
      display_name: 'ControlNetインペインティングAliMamaを適用'
    },
    ControlNetLoader: { display_name: 'ControlNetモデルを読み込む' },
    CreateHookKeyframe: { display_name: 'フックキーフレームを作成' },
    CreateHookKeyframesFromFloats: {
      display_name: 'フックキーフレームを浮動小数点から作成'
    },
    CreateHookKeyframesInterpolated: {
      display_name: 'フックキーフレームを補間'
    },
    CreateHookLora: { display_name: 'フックLoRAを作成' },
    CreateHookLoraModelOnly: { display_name: 'フックLoRA（モデルのみ）' },
    CreateHookModelAsLora: { display_name: 'フックモデルをLoRAとして作成' },
    CreateHookModelAsLoraModelOnly: {
      display_name: 'フックモデルをLoRAとして作成（モデルのみ）'
    },
    CropMask: { display_name: 'マスクをトリミング' },
    DevToolsDeprecatedNode: {
      description: '非推奨のノード',
      display_name: '非推奨ノード'
    },
    DevToolsErrorRaiseNode: {
      description: '開発目的のためにエラーを発生させる',
      display_name: 'エラーを発生させる'
    },
    DevToolsErrorRaiseNodeWithMessage: {
      description: '開発目的のためにメッセージ付きのエラーを発生させる',
      display_name: 'メッセージ付きエラーを発生させる'
    },
    DevToolsExperimentalNode: {
      description: '実験的なノード',
      display_name: '実験的ノード'
    },
    DevToolsLongComboDropdown: {
      description: '長いコンボドロップダウン',
      display_name: 'ロングコンボドロップダウン'
    },
    DevToolsNodeWithForceInput: {
      description: '強制入力を持つノード',
      display_name: '強制入力ノード'
    },
    DevToolsNodeWithOnlyOptionalInput: {
      description: 'オプション入力のみを持つノード',
      display_name: 'オプション入力のみのノード'
    },
    DevToolsNodeWithOptionalInput: {
      description: 'オプション入力を持つノード',
      display_name: 'オプション入力ノード'
    },
    DevToolsNodeWithOutputList: {
      description: '出力リストを持つノード',
      display_name: '出力リストノード'
    },
    DevToolsNodeWithStringInput: {
      description: '文字列入力を持つノード',
      display_name: '文字列入力ノード'
    },
    DevToolsNodeWithUnionInput: {
      description: 'ユニオン入力を持つノード',
      display_name: 'ユニオン入力ノード'
    },
    DiffControlNetLoader: {
      display_name: 'ControlNetモデルを読み込む（diff）'
    },
    DifferentialDiffusion: { display_name: '差分拡散' },
    DiffusersLoader: { display_name: 'ディフューザーを読み込む' },
    DisableNoise: { display_name: 'ノイズを無効にする' },
    DualCFGGuider: { display_name: 'デュアルCFGガイダー' },
    DualCLIPLoader: {
      description:
        '[レシピ]\n\nsdxl: clip-l, clip-g\nsd3: clip-l, clip-g / clip-l, t5 / clip-g, t5\nflux: clip-l, t5',
      display_name: 'デュアルCLIPを読み込む'
    },
    EmptyImage: { display_name: '空の画像' },
    EmptyLTXVLatentVideo: { display_name: '空のLTXV潜在ビデオ' },
    EmptyLatentAudio: { display_name: '空の潜在音声' },
    EmptyLatentImage: {
      description:
        'サンプリングを通じてノイズを除去するための空の潜在画像の新しいバッチを作成します。',
      display_name: '空の潜在画像'
    },
    EmptyMochiLatentVideo: { display_name: '空のMochi潜在ビデオ' },
    EmptySD3LatentImage: { display_name: '空のSD3潜在画像' },
    ExponentialScheduler: { display_name: '指数スケジューラー' },
    FeatherMask: { display_name: 'フェザー マスク' },
    FlipSigmas: { display_name: 'シグマを反転' },
    FluxGuidance: { display_name: 'フラックスガイダンス' },
    FreeU: { display_name: 'FreeU' },
    FreeU_V2: { display_name: 'FreeU_V2' },
    GITSScheduler: { display_name: 'GITSスケジューラー' },
    GLIGENLoader: { display_name: 'GLIGENを読み込む' },
    GLIGENTextBoxApply: { display_name: 'GLIGENテキストボックスを適用' },
    GrowMask: { display_name: 'マスクを拡大' },
    HyperTile: { display_name: 'ハイパータイル' },
    HypernetworkLoader: { display_name: 'ハイパーネットワークを読み込む' },
    ImageBatch: { display_name: '画像バッチ' },
    ImageBlend: { display_name: '画像ブレンド' },
    ImageBlur: { display_name: '画像ぼかし' },
    ImageColorToMask: { display_name: '画像色をマスクに変換' },
    ImageCompositeMasked: { display_name: 'マスクされた画像合成' },
    ImageCrop: { display_name: '画像トリミング' },
    ImageFromBatch: { display_name: 'バッチから画像を取得' },
    ImageInvert: { display_name: '画像を反転' },
    ImageOnlyCheckpointLoader: {
      display_name: '画像のみのチェックポイントローダー（img2vidモデル）'
    },
    ImageOnlyCheckpointSave: { display_name: '画像のみのチェックポイント保存' },
    ImagePadForOutpaint: { display_name: 'アウトペイント用に画像をパッド' },
    ImageQuantize: { display_name: '画像を量子化' },
    ImageScale: { display_name: '画像を拡大' },
    ImageScaleBy: { display_name: '画像を拡大（指定サイズ）' },
    ImageScaleToTotalPixels: { display_name: '画像を総ピクセルにスケール' },
    ImageSharpen: { display_name: '画像をシャープ化' },
    ImageToMask: { display_name: '画像をマスクに変換' },
    ImageUpscaleWithModel: { display_name: 'モデルを使用して画像を拡大' },
    InpaintModelConditioning: { display_name: 'インペイントモデル条件付け' },
    InstructPixToPixConditioning: { display_name: 'PixToPix条件付け' },
    InvertMask: { display_name: 'マスクを反転' },
    JoinImageWithAlpha: { display_name: 'アルファで画像を結合' },
    KSampler: {
      description:
        '提供されたモデル、正の条件付けと負の条件付けを使用して潜在画像のノイズを除去します。',
      display_name: 'Kサンプラー'
    },
    KSamplerAdvanced: { display_name: 'Kサンプラー（高度）' },
    KSamplerSelect: { display_name: 'Kサンプラー選択' },
    KarrasScheduler: { display_name: 'カラススケジューラー' },
    LTXVConditioning: { display_name: 'LTXV条件付け' },
    LTXVImgToVideo: { display_name: 'LTXV画像からビデオへ' },
    LTXVScheduler: { display_name: 'LTXVスケジューラー' },
    LaplaceScheduler: { display_name: 'ラプラススケジューラー' },
    LatentAdd: { display_name: '潜在追加' },
    LatentApplyOperation: { display_name: '潜在操作を適用' },
    LatentApplyOperationCFG: { display_name: '潜在操作CFGを適用' },
    LatentBatch: { display_name: '潜在バッチ' },
    LatentBatchSeedBehavior: { display_name: '潜在バッチシード動作' },
    LatentBlend: { display_name: '潜在ブレンド' },
    LatentComposite: { display_name: '潜在合成' },
    LatentCompositeMasked: { display_name: 'マスクされた潜在合成' },
    LatentCrop: { display_name: '潜在トリミング' },
    LatentFlip: { display_name: '潜在反転' },
    LatentFromBatch: { display_name: 'バッチから潜在を取得' },
    LatentInterpolate: { display_name: '潜在補間' },
    LatentMultiply: { display_name: '潜在乗算' },
    LatentOperationSharpen: { display_name: '潜在操作シャープ化' },
    LatentOperationTonemapReinhard: {
      display_name: '潜在操作トーンマップライナード'
    },
    LatentRotate: { display_name: '潜在回転' },
    LatentSubtract: { display_name: '潜在減算' },
    LatentUpscale: { display_name: '潜在を拡大' },
    LatentUpscaleBy: { display_name: '潜在を拡大（指定サイズ）' },
    LoadAudio: { display_name: '音声を読み込む' },
    LoadImage: { display_name: '画像を読み込む' },
    LoadImageMask: { display_name: '画像を読み込む（マスクとして）' },
    LoadLatent: { display_name: '潜在を読み込む' },
    LoraLoader: {
      description:
        'LoRAは拡散およびCLIPモデルを修正するために使用され、潜在のノイズ除去方法を変更します。複数のLoRAノードを連結できます。',
      display_name: 'LoRAを読み込む'
    },
    LoraLoaderModelOnly: {
      description:
        'LoRAは拡散およびCLIPモデルを修正するために使用され、潜在のノイズ除去方法を変更します。複数のLoRAノードを連結できます。',
      display_name: 'LoRAローダーモデルのみ'
    },
    LoraSave: { display_name: 'LoRAを抽出して保存' },
    MaskComposite: { display_name: 'マスク合成' },
    MaskToImage: { display_name: 'マスクを画像に変換' },
    ModelMergeAdd: { display_name: 'モデルマージ追加' },
    ModelMergeAuraflow: { display_name: 'モデルマージオーラフロー' },
    ModelMergeBlocks: { display_name: 'モデルマージブロック' },
    ModelMergeFlux1: { display_name: 'モデルマージフラックス1' },
    ModelMergeLTXV: { display_name: 'モデルマージLTXV' },
    ModelMergeMochiPreview: { display_name: 'モデルマージMochiプレビュー' },
    ModelMergeSD1: { display_name: 'モデルマージSD1' },
    ModelMergeSD2: { display_name: 'モデルマージSD2' },
    ModelMergeSD35_Large: { display_name: 'モデルマージSD35_Large' },
    ModelMergeSD3_2B: { display_name: 'モデルマージSD3_2B' },
    ModelMergeSDXL: { display_name: 'モデルマージSDXL' },
    ModelMergeSimple: { display_name: 'モデルマージシンプル' },
    ModelMergeSubtract: { display_name: 'モデルマージ減算' },
    ModelSamplingAuraFlow: { display_name: 'モデルサンプリングオーラフロー' },
    ModelSamplingContinuousEDM: { display_name: 'モデルサンプリング連続EDM' },
    ModelSamplingContinuousV: { display_name: 'モデルサンプリング連続V' },
    ModelSamplingDiscrete: { display_name: 'モデルサンプリング離散' },
    ModelSamplingFlux: { display_name: 'モデルサンプリングフラックス' },
    ModelSamplingLTXV: { display_name: 'モデルサンプリングLTXV' },
    ModelSamplingSD3: { display_name: 'モデルサンプリングSD3' },
    ModelSamplingStableCascade: {
      display_name: 'モデルサンプリング安定カスケード'
    },
    ModelSave: { display_name: 'モデルを保存' },
    Morphology: { display_name: '画像形態学' },
    PairConditioningCombine: { display_name: 'ペア条件付け組み合わせ' },
    PairConditioningSetDefaultCombine: {
      display_name: 'ペア条件付けデフォルト組み合わせを設定'
    },
    PairConditioningSetProperties: {
      display_name: 'ペア条件付けプロパティ設定'
    },
    PairConditioningSetPropertiesAndCombine: {
      display_name: 'ペア条件付けプロパティ設定と組み合わせ'
    },
    PatchModelAddDownscale: {
      display_name: 'パッチモデル追加ダウンスケール（Kohya Deep Shrink）'
    },
    PerpNeg: { display_name: 'Perp-Neg（PerpNegGuiderによって非推奨）' },
    PerpNegGuider: { display_name: 'PerpNegガイダー' },
    PerturbedAttentionGuidance: { display_name: '摂動注意ガイダンス' },
    PhotoMakerEncode: { display_name: 'フォトメーカーエンコード' },
    PhotoMakerLoader: { display_name: 'フォトメーカーを読み込む' },
    PolyexponentialScheduler: { display_name: 'ポリ指数スケジューラー' },
    PorterDuffImageComposite: { display_name: 'ポーターダフ画像合成' },
    PreviewAudio: { display_name: 'オーディオプレビュー' },
    PreviewImage: {
      description: '入力画像をComfyUI出力ディレクトリに保存します。',
      display_name: '画像プレビュー'
    },
    RandomNoise: { display_name: 'ランダムノイズ' },
    RebatchImages: { display_name: '画像を再バッチ' },
    RebatchLatents: { display_name: '潜在を再バッチ' },
    RepeatImageBatch: { display_name: '画像バッチを繰り返す' },
    RepeatLatentBatch: { display_name: '潜在バッチを繰り返す' },
    RescaleCFG: { display_name: 'CFGを再スケール' },
    SDTurboScheduler: { display_name: 'SDターボスケジューラー' },
    SD_4XUpscale_Conditioning: { display_name: 'SD_4X拡大条件付け' },
    SV3D_Conditioning: { display_name: 'SV3D条件付け' },
    SVD_img2vid_Conditioning: { display_name: 'SVD_img2vid条件付け' },
    SamplerCustom: { display_name: 'カスタムサンプラー' },
    SamplerCustomAdvanced: { display_name: 'カスタムサンプラー（高度）' },
    SamplerDPMAdaptative: { display_name: 'サンプラーDPM適応' },
    SamplerDPMPP_2M_SDE: { display_name: 'サンプラーDPMPP_2M_SDE' },
    SamplerDPMPP_2S_Ancestral: { display_name: 'サンプラーDPMPP_2S_祖先' },
    SamplerDPMPP_3M_SDE: { display_name: 'サンプラーDPMPP_3M_SDE' },
    SamplerDPMPP_SDE: { display_name: 'サンプラーDPMPP_SDE' },
    SamplerEulerAncestral: { display_name: 'サンプラーオイラー祖先' },
    SamplerEulerAncestralCFGPP: { display_name: 'サンプラーオイラー祖先CFG++' },
    SamplerEulerCFGpp: { display_name: 'サンプラーオイラーCFG++' },
    SamplerLCMUpscale: { display_name: 'サンプラーLCM拡大' },
    SamplerLMS: { display_name: 'サンプラーLMS' },
    SaveAnimatedPNG: { display_name: 'アニメーションPNGを保存' },
    SaveAnimatedWEBP: { display_name: 'アニメーションWEBPを保存' },
    SaveAudio: { display_name: 'オーディオを保存' },
    SaveImage: {
      description: '入力画像をComfyUI出力ディレクトリに保存します。',
      display_name: '画像を保存'
    },
    SaveImageWebsocket: { display_name: '画像を保存するWebSocket' },
    SaveLatent: { display_name: '潜在を保存' },
    SelfAttentionGuidance: { display_name: '自己注意ガイダンス' },
    SetClipHooks: { display_name: 'CLIPフックを設定' },
    SetHookKeyframes: { display_name: 'フックキーフレームを設定' },
    SetLatentNoiseMask: { display_name: '潜在ノイズマスクを設定' },
    SetUnionControlNetType: { display_name: 'Union ControlNetタイプを設定' },
    SkipLayerGuidanceDiT: {
      description:
        'すべてのDiTモデルで使用できるSkipLayerGuidanceノードの一般的なバージョン。',
      display_name: 'SkipLayerGuidanceDiT'
    },
    SkipLayerGuidanceSD3: {
      description:
        'すべてのDiTモデルで使用できるSkipLayerGuidanceノードの一般的なバージョン。',
      display_name: 'SkipLayerGuidanceSD3'
    },
    SolidMask: { display_name: 'ソリッドマスク' },
    SplitImageWithAlpha: { display_name: 'アルファで画像を分割' },
    SplitSigmas: { display_name: 'シグマを分割' },
    SplitSigmasDenoise: { display_name: 'シグマを分割してノイズ除去' },
    StableCascade_EmptyLatentImage: {
      display_name: '安定カスケード_空の潜在画像'
    },
    StableCascade_StageB_Conditioning: {
      display_name: '安定カスケード_ステージB条件付け'
    },
    StableCascade_StageC_VAEEncode: {
      display_name: '安定カスケード_ステージC_VAEエンコード'
    },
    StableCascade_SuperResolutionControlnet: {
      display_name: '安定カスケード_超解像Controlnet'
    },
    StableZero123_Conditioning: { display_name: '安定ゼロ123条件付け' },
    StableZero123_Conditioning_Batched: {
      display_name: '安定ゼロ123条件付け（バッチ）'
    },
    StyleModelApply: { display_name: 'スタイルモデルを適用' },
    StyleModelLoader: { display_name: 'スタイルモデルを読み込む' },
    ThresholdMask: { display_name: 'しきい値マスク' },
    TomePatchModel: { display_name: 'トメパッチモデル' },
    TorchCompileModel: { display_name: 'Torchコンパイルモデル' },
    TripleCLIPLoader: {
      description: '[レシピ]\n\nsd3: clip-l, clip-g, t5',
      display_name: 'トリプルCLIPを読み込む'
    },
    UNETLoader: { display_name: '拡散モデルを読み込む' },
    UNetCrossAttentionMultiply: { display_name: 'UNetクロス注意の乗算' },
    UNetSelfAttentionMultiply: { display_name: 'UNet自己注意の乗算' },
    UNetTemporalAttentionMultiply: { display_name: 'UNet時間的注意の乗算' },
    UpscaleModelLoader: { display_name: '拡大モデルを読み込む' },
    VAEDecode: {
      description: '潜在画像をピクセル空間画像にデコードします。',
      display_name: 'VAEデコード'
    },
    VAEDecodeAudio: { display_name: 'VAEデコード音声' },
    VAEDecodeTiled: { display_name: 'VAEデコード（タイル）' },
    VAEEncode: { display_name: 'VAEエンコード' },
    VAEEncodeAudio: { display_name: 'VAEエンコード音声' },
    VAEEncodeForInpaint: { display_name: 'VAEエンコード（インペイント用）' },
    VAEEncodeTiled: { display_name: 'VAEエンコード（タイル）' },
    VAELoader: { display_name: 'VAEを読み込む' },
    VAESave: { display_name: 'VAEを保存' },
    VPScheduler: { display_name: 'VPスケジューラー' },
    VideoLinearCFGGuidance: { display_name: 'ビデオ線形CFGガイダンス' },
    VideoTriangleCFGGuidance: { display_name: 'ビデオ三角形CFGガイダンス' },
    WebcamCapture: { display_name: 'ウェブカメラキャプチャ' },
    unCLIPCheckpointLoader: { display_name: 'unCLIPチェックポイントローダー' },
    unCLIPConditioning: { display_name: 'unCLIP条件付け' }
  },
  notSupported = {
    continue: '続ける',
    continueTooltip: '私のデバイスはサポートされていると確信しています',
    learnMore: '詳細を見る',
    message: '以下のデバイスのみサポートされています:',
    reportIssue: '問題を報告',
    supportedDevices: {
      macos: 'MacOS (M1以降)',
      windows: 'Windows (CUDA対応のNvidia GPU)'
    },
    title: 'お使いのデバイスはサポートされていません'
  },
  openNewIssue = '新しいIssueを開く',
  overwrite = '上書き',
  reconnected = '再接続しました',
  reconnecting = '再接続中',
  refresh = '更新',
  reloadToApplyChanges = '変更を適用するには再読み込みしてください',
  rename = '名前を変更',
  reportIssue = 'レポートを送信',
  reportIssueTooltip = 'エラーレポートをComfy Orgに送信',
  reportSent = 'レポートを送信しました',
  reset = 'リセット',
  resetKeybindingsTooltip = 'キーバインドをデフォルトに戻す',
  save = '保存',
  searchExtensions = '拡張機能を検索',
  searchFailedMessage =
    '検索条件に一致する設定が見つかりませんでした。条件を変更して再試行してください。',
  searchKeybindings = 'キーバインドを検索',
  searchModels = 'モデルを検索',
  searchNodes = 'ノードを検索',
  searchSettings = '設定を検索',
  searchWorkflows = 'ワークフローを検索',
  serverConfig = {
    modifiedConfigs:
      '以下のサーバー設定を変更しました。変更を適用するには再起動してください。',
    restart: '再起動',
    revertChanges: '変更を元に戻す'
  },
  serverConfigCategories = {
    Attention: 'アテンション',
    CUDA: 'CUDA',
    Cache: 'キャッシュ',
    General: '一般',
    Inference: '推論',
    Memory: 'メモリ',
    Network: 'ネットワーク',
    Preview: 'プレビュー'
  },
  serverConfigItems = {
    'cache-classic': { name: 'クラシックキャッシュシステムを使用する' },
    'cache-lru': {
      name: '最大Nノード結果をキャッシュするLRUキャッシングを使用する。',
      tooltip: 'RAM/VRAMを多く使用する可能性があります。'
    },
    'cpu-vae': { name: 'CPUでVAEを実行する' },
    'cross-attention-method': { name: 'クロスアテンションメソッド' },
    'cuda-device': { name: '使用するCUDAデバイスインデックス' },
    'cuda-malloc': { name: 'メモリ割り当てにCUDA mallocを使用する' },
    'default-hashing-function': {
      name: 'モデルファイルのデフォルトハッシュ関数'
    },
    deterministic: {
      name: '可能な場合、PyTorchが遅い決定論的アルゴリズムを使用する。',
      tooltip:
        'これにより、すべてのケースで画像が決定論的になるわけではないことに注意してください。'
    },
    directml: { name: 'DirectMLデバイスインデックス' },
    'disable-all-custom-nodes': {
      name: 'すべてのカスタムノードの読み込みを無効にする。'
    },
    'disable-ipex-optimize': { name: 'IPEX最適化を無効にする' },
    'disable-metadata': {
      name: 'ファイルにプロンプトメタデータを保存しない。'
    },
    'disable-smart-memory': {
      name: 'スマートメモリ管理を無効にする',
      tooltip:
        'ComfyUIがモデルをVRAMに保持する代わりに、通常のRAMに積極的にオフロードするように強制します。'
    },
    'disable-xformers': { name: 'xFormers最適化を無効にする' },
    'dont-print-server': { name: 'サーバー出力をコンソールに表示しない。' },
    'dont-upcast-attention': { name: 'アテンションのアップキャストを防ぐ' },
    'enable-cors-header': {
      name: 'CORSヘッダーを有効にする: "*"を使用してすべてのオリジンを許可するか、ドメインを指定する'
    },
    fast: { name: '未テストの潜在的に品質を低下させる最適化を有効にする。' },
    'force-channels-last': { name: 'チャネルを最後に強制するメモリ形式' },
    'force-upcast-attention': {
      name: 'アテンションのアップキャストを強制する'
    },
    'global-precision': {
      name: 'グローバル浮動小数点精度',
      tooltip: 'グローバル浮動小数点精度'
    },
    'log-level': { name: 'ログの冗長性レベル' },
    'max-upload-size': { name: '最大アップロードサイズ (MB)' },
    'preview-method': { name: '潜在プレビューに使用されるメソッド' },
    'preview-size': { name: 'プレビュー画像のサイズ' },
    'reserve-vram': {
      name: '予約済みVRAM (GB)',
      tooltip:
        'OS/他のソフトウェアで使用するために予約したいVRAMの量をGB単位で設定します。デフォルトでは、OSに応じていくらかの量が予約されます。'
    },
    'text-encoder-precision': {
      name: 'テキストエンコーダー精度',
      tooltip: 'テキストエンコーダー精度'
    },
    'tls-certfile': {
      name: 'TLS証明書ファイル: HTTPS用のTLS証明書ファイルのパス'
    },
    'tls-keyfile': { name: 'TLSキーファイル: HTTPS用のTLSキーファイルのパス' },
    'unet-precision': { name: 'UNET精度', tooltip: 'UNET精度' },
    'vae-precision': { name: 'VAE精度', tooltip: 'VAE精度' },
    'vram-management': { name: 'VRAM管理モード' }
  },
  serverStart = {
    openLogs: 'ログを開く',
    process: {
      error: 'ComfyUIデスクトップを起動できません',
      'initial-state': '読み込み中...',
      'python-setup': 'Python環境を設定中...',
      ready: '完了中...',
      'starting-server': 'ComfyUIサーバーを起動中...'
    },
    reinstall: '再インストール',
    reportIssue: '問題を報告'
  },
  settings = '設定',
  settingsCategories = {
    About: '情報',
    Appearance: '外観',
    BrushAdjustment: 'ブラシ調整',
    Canvas: 'キャンバス',
    ColorPalette: 'カラーパレット',
    Comfy: 'Comfy',
    'Comfy-Desktop': 'Comfyデスクトップ',
    DevMode: '開発モード',
    EditAttention: '編集Attention',
    Extension: '拡張',
    General: '一般',
    Graph: 'グラフ',
    Group: 'グループ',
    Keybinding: 'キー割り当て',
    Link: 'リンク',
    LinkRelease: 'リンク解除',
    LiteGraph: 'Lite Graph',
    Locale: 'ロケール',
    'Mask Editor': 'マスクエディタ',
    Menu: 'メニュー',
    ModelLibrary: 'モデルライブラリ',
    NewEditor: '新しいエディタ',
    Node: 'ノード',
    'Node Search Box': 'ノード検索ボックス',
    'Node Widget': 'ノードウィジェット',
    NodeInputConversionSubmenus: 'ノード入力変換サブメニュー',
    NodeLibrary: 'ノードライブラリ',
    Pointer: 'ポインタ',
    Queue: 'キュー',
    QueueButton: 'キューボタン',
    RerouteBeta: 'ルート変更ベータ',
    Server: 'サーバー',
    'Server-Config': 'サーバー設定',
    Settings: '設定',
    Sidebar: 'サイドバー',
    'Tree Explorer': 'ツリーエクスプローラー',
    Validation: '検証',
    Window: 'ウィンドウ',
    Workflow: 'ワークフロー'
  },
  settingsDialog = {
    'Comfy-Desktop_AutoUpdate': { name: '自動的に更新を確認する' },
    'Comfy-Desktop_SendStatistics': {
      name: '匿名のクラッシュレポートを送信する'
    },
    Comfy_ColorPalette: { name: 'カラーパレット' },
    Comfy_ConfirmClear: { name: 'ワークフローをクリアする際に確認を要求する' },
    Comfy_DOMClippingEnabled: {
      name: 'DOM要素のクリッピングを有効にする（有効にするとパフォーマンスが低下する可能性があります）'
    },
    Comfy_DevMode: { name: '開発モードオプションを有効にする（API保存など）' },
    Comfy_DisableFloatRounding: {
      name: 'デフォルトの浮動小数点ウィジェットの丸めを無効にする。',
      tooltip:
        '(ページの再読み込みが必要) バックエンドのノードで丸めが設定されている場合、丸めを無効にすることはできません。'
    },
    Comfy_DisableSliders: { name: 'ノードウィジェットスライダーを無効にする' },
    Comfy_EditAttention_Delta: { name: 'Ctrl+上/下の精度' },
    Comfy_EnableTooltips: { name: 'ツールチップを有効にする' },
    Comfy_EnableWorkflowViewRestore: {
      name: 'ワークフロー内のキャンバスの位置とズームレベルを保存および復元する'
    },
    Comfy_Extension_Disabled: { name: '無効な拡張機能名' },
    Comfy_FloatRoundingPrecision: {
      name: '浮動小数点ウィジェットの丸め小数点数 [0 = 自動]。',
      tooltip: '(ページの再読み込みが必要)'
    },
    Comfy_Graph_CanvasInfo: {
      name: '左下隅にキャンバス情報を表示する（fpsなど）'
    },
    Comfy_Graph_CanvasMenu: { name: 'グラフキャンバスメニューを表示する' },
    Comfy_Graph_CtrlShiftZoom: {
      name: 'ファストズームショートカットを有効にする（Ctrl + Shift + ドラッグ）'
    },
    Comfy_Graph_LinkMarkers: { name: 'リンク中点マーカー' },
    Comfy_Graph_ZoomSpeed: { name: 'キャンバスズーム速度' },
    Comfy_GroupSelectedNodes_Padding: { name: '選択したノードのパディング' },
    Comfy_Group_DoubleClickTitleToEdit: {
      name: 'グループタイトルをダブルクリックして編集'
    },
    Comfy_InvertMenuScrolling: {
      name: 'コンテキストメニューのスクロールを反転する'
    },
    Comfy_Keybinding_NewBindings: {
      name: 'ユーザーによって設定されたキー割り当て'
    },
    Comfy_Keybinding_UnsetBindings: {
      name: 'ユーザーによって解除されたキー割り当て'
    },
    Comfy_LinkRelease_Action: {
      name: 'リンクリリース時のアクション（修飾子なし）'
    },
    Comfy_LinkRelease_ActionShift: {
      name: 'リンクリリース時のアクション（Shift）'
    },
    Comfy_LinkRenderMode: { name: 'リンクレンダーモード' },
    Comfy_Locale: { name: '言語' },
    Comfy_MaskEditor_BrushAdjustmentSpeed: {
      name: 'ブラシ調整速度の倍率',
      tooltip:
        '調整時にブラシのサイズと硬さがどれだけ速く変化するかを制御します。値が高いほど、変化が速くなります。'
    },
    Comfy_MaskEditor_UseDominantAxis: {
      name: 'ブラシ調整を優先軸に固定する',
      tooltip:
        '有効にすると、ブラシの調整は、どの方向に多く動かすかに基づいて、サイズまたは硬さのいずれかにのみ影響します。'
    },
    Comfy_MaskEditor_UseNewEditor: {
      name: '新しいマスクエディタを使用する',
      tooltip: '新しいマスクエディタインターフェースに切り替えます。'
    },
    Comfy_MenuPosition: { name: 'レガシーメニューの位置を保存' },
    Comfy_ModelLibrary_AutoLoadAll: {
      name: 'すべてのモデルフォルダーを自動的に読み込む',
      tooltip:
        'trueの場合、モデルライブラリを開くとすぐにすべてのフォルダーが読み込まれます（これにより読み込み中に遅延が発生する可能性があります）。falseの場合、ルートレベルのモデルフォルダーはクリックするまで読み込まれません。'
    },
    Comfy_ModelLibrary_NameFormat: {
      name: 'モデルライブラリツリービューに表示する名前',
      tooltip:
        '"ファイル名"を選択すると、モデルリストにディレクトリや".safetensors"拡張子なしの生のファイル名の簡略化されたビューが表示されます。"タイトル"を選択すると、設定可能なモデルメタデータタイトルが表示されます。'
    },
    Comfy_NodeBadge_NodeIdBadgeMode: { name: 'ノードIDバッジモード' },
    Comfy_NodeBadge_NodeLifeCycleBadgeMode: {
      name: 'ノードライフサイクルバッジモード'
    },
    Comfy_NodeBadge_NodeSourceBadgeMode: { name: 'ノードソースバッジモード' },
    Comfy_NodeInputConversionSubmenus: {
      name: 'ノードのコンテキストメニューに、入力/ウィジェット間の変換を行うエントリをサブメニューに配置します。'
    },
    Comfy_NodeLibrary_Bookmarks: {
      name: 'ノードライブラリのブックマーク（非推奨）'
    },
    Comfy_NodeLibrary_BookmarksCustomization: {
      name: 'ノードライブラリのブックマークカスタマイズ'
    },
    Comfy_NodeLibrary_Bookmarks_V2: {
      name: 'ユニークな名前のノードライブラリのブックマークv2'
    },
    Comfy_NodeSearchBoxImpl: { name: 'ノード検索ボックスの実装' },
    Comfy_NodeSearchBoxImpl_NodePreview: {
      name: 'ノードプレビュー',
      tooltip: 'デフォルトの実装にのみ適用されます'
    },
    Comfy_NodeSearchBoxImpl_ShowCategory: {
      name: '検索結果にノードカテゴリを表示',
      tooltip: 'デフォルトの実装にのみ適用されます'
    },
    Comfy_NodeSearchBoxImpl_ShowIdName: {
      name: '検索結果にノードID名を表示',
      tooltip: 'デフォルトの実装にのみ適用されます'
    },
    Comfy_NodeSearchBoxImpl_ShowNodeFrequency: {
      name: '検索結果にノード頻度を表示',
      tooltip: 'デフォルトの実装にのみ適用されます'
    },
    Comfy_NodeSuggestions_number: {
      name: 'ノード提案の数',
      tooltip: 'ライトグラフの検索ボックス/コンテキストメニュー専用'
    },
    Comfy_Node_AutoSnapLinkToSlot: {
      name: 'ノードスロットにリンクを自動スナップ',
      tooltip:
        'ノードの上にリンクをドラッグすると、リンクがノードの有効な入力スロットに自動的にスナップします'
    },
    Comfy_Node_BypassAllLinksOnDelete: {
      name: 'ノード削除時にすべてのリンクを保持',
      tooltip:
        'ノードを削除する際、削除されたノードをバイパスしてすべての入力および出力リンクを再接続しようとします'
    },
    Comfy_Node_DoubleClickTitleToEdit: {
      name: 'ノードタイトルをダブルクリックして編集'
    },
    Comfy_Node_MiddleClickRerouteNode: {
      name: 'ミドルクリックで新しいリルートノードを作成'
    },
    Comfy_Node_Opacity: { name: 'ノードの不透明度' },
    Comfy_Node_ShowDeprecated: {
      name: '検索で非推奨ノードを表示',
      tooltip:
        '非推奨ノードはデフォルトでUIに隠されていますが、それを使用する既存のワークフローでは機能し続けます。'
    },
    Comfy_Node_ShowExperimental: {
      name: '検索で実験的ノードを表示',
      tooltip:
        '実験的ノードはUIでそのようにマークされており、将来のバージョンで大幅な変更や削除の対象となる可能性があります。生産ワークフローでの使用には注意が必要です'
    },
    Comfy_Node_SnapHighlightsNode: {
      name: 'スナップハイライトノード',
      tooltip:
        '有効な入力スロットを持つノードの上にリンクをドラッグすると、ノードがハイライトされます'
    },
    Comfy_Pointer_ClickBufferTime: {
      name: 'ポインタークリックドリフト遅延',
      tooltip:
        'ポインターボタンを押した後、ポインタの動きが無視される最大時間（ミリ秒単位）です。\n\nクリック中にポインタが移動した場合、オブジェクトが意図せず動かされるのを防ぎます。'
    },
    Comfy_Pointer_ClickDrift: {
      name: 'ポインタークリックドリフト（最大距離）',
      tooltip:
        'ボタンを押し続けている間にポインタがこの距離以上移動した場合、クリックではなくドラッグと見なされます。\n\nクリック中にポインタが移動した場合、オブジェクトが意図せず動かされるのを防ぎます。'
    },
    Comfy_Pointer_DoubleClickTime: {
      name: 'ダブルクリック間隔（最大）',
      tooltip:
        'ダブルクリックの2回のクリック間の最大時間（ミリ秒単位）。この値を増やすことで、ダブルクリックが時々登録されない場合に助けになるかもしれません。'
    },
    Comfy_PreviewFormat: {
      name: 'プレビュー画像フォーマット',
      tooltip:
        '画像ウィジェットでプレビューを表示する際、軽量画像に変換します（例：webp、jpeg、webp;50など）。'
    },
    Comfy_PromptFilename: {
      name: 'ワークフローを保存する際にファイル名を入力するよう促す'
    },
    Comfy_QueueButton_BatchCountLimit: {
      name: 'バッチ数制限',
      tooltip: '1回のボタンクリックでキューに追加できるタスクの最大数'
    },
    Comfy_Queue_ImageFit: { name: 'キュー画像フィット' },
    Comfy_Queue_MaxHistoryItems: {
      name: 'キュー履歴サイズ',
      tooltip: 'キュー履歴に表示されるタスクの最大数。'
    },
    Comfy_RerouteBeta: {
      name: 'リルートベータテストに参加する',
      tooltip:
        '新しいネイティブリルートを有効にします。\n\nリルートは、リンクラインからドラッグしながらaltを押すか、リンクメニューで追加できます。\n\nこのオプションを無効にしても破壊的ではなく、リルートは隠されます。'
    },
    Comfy_Server_LaunchArgs: {
      name: 'サーバー起動引数',
      tooltip: 'これらは、サーバーが起動されるときに渡される実際の引数です。'
    },
    Comfy_Server_ServerConfigValues: {
      name: 'フロントエンド表示用のサーバー設定値',
      tooltip: 'フロントエンド表示のみに使用されるサーバー設定値'
    },
    Comfy_Settings_ExtensionPanel: { name: '設定ダイアログに拡張パネルを表示' },
    Comfy_Sidebar_Location: { name: 'サイドバーの位置' },
    Comfy_Sidebar_Size: { name: 'サイドバーのサイズ' },
    Comfy_SnapToGrid_GridSize: {
      name: 'グリッドサイズにスナップ',
      tooltip:
        'シフトを押しながらノードをドラッグおよびサイズ変更すると、グリッドに整列されます。これにより、そのグリッドのサイズが制御されます。'
    },
    Comfy_TextareaWidget_FontSize: {
      name: 'テキストエリアウィジェットのフォントサイズ'
    },
    Comfy_TextareaWidget_Spellcheck: {
      name: 'テキストエリアウィジェットのスペルチェック'
    },
    Comfy_TreeExplorer_ItemPadding: {
      name: 'ツリーエクスプローラーアイテムのパディング'
    },
    Comfy_UseNewMenu: { name: '新しいメニューを使用' },
    Comfy_Validation_NodeDefs: {
      name: 'ノード定義を検証（遅い）',
      tooltip:
        'ノード開発者に推奨されます。これにより、起動時にすべてのノード定義が検証されます。'
    },
    Comfy_Validation_Workflows: { name: 'ワークフローを検証' },
    Comfy_WidgetControlMode: {
      name: 'ウィジェット制御モード',
      tooltip:
        'ウィジェットの値が更新されるタイミングを制御します（ランダム化/インクリメント/デクリメント）、プロンプトがキューに入れられる前または後のいずれかです。'
    },
    Comfy_Window_UnloadConfirmation: {
      name: 'ウィンドウを閉じるときに確認を表示'
    },
    Comfy_Workflow_ConfirmDelete: {
      name: 'ワークフローを削除する際に確認を表示'
    },
    Comfy_Workflow_ShowMissingModelsWarning: {
      name: '欠落しているモデルの警告を表示'
    },
    Comfy_Workflow_ShowMissingNodesWarning: {
      name: '欠落しているノードの警告を表示'
    },
    Comfy_Workflow_SortNodeIdOnSave: {
      name: 'ワークフローを保存する際にノードIDをソート'
    },
    Comfy_Workflow_WorkflowTabsPosition: {
      name: '開いているワークフローの位置'
    },
    LiteGraph_Canvas_MaximumFps: {
      name: '最大FPS',
      tooltip:
        'キャンバスがレンダリングできる最大フレーム数です。スムーズさの代わりにGPU使用量を制限します。0の場合、画面のリフレッシュレートが使用されます。デフォルト：0'
    },
    pysssss_SnapToGrid: { name: '常にグリッドにスナップ' }
  },
  showReport = 'レポートを表示',
  sideToolbar = {
    browseTemplates: 'サンプルテンプレートを表示',
    downloads: 'ダウンロード',
    logout: 'ログアウト',
    modelLibrary: 'モデルライブラリ',
    newBlankWorkflow: '新しい空のワークフローを作成',
    nodeLibrary: 'ノードライブラリ',
    nodeLibraryTab: { sortOrder: '並び順' },
    openWorkflow: 'ローカルでワークフローを開く',
    queue: 'キュー',
    queueTab: {
      backToAllTasks: 'すべてのタスクに戻る',
      clearPendingTasks: '保留中のタスクをクリア',
      containImagePreview: '画像プレビューを含める',
      coverImagePreview: '画像プレビューに合わせる',
      filter: '出力をフィルタ',
      filters: {
        hideCached: 'キャッシュを非表示',
        hideCanceled: 'キャンセル済みを非表示'
      },
      showFlatList: 'フラットリストを表示'
    },
    themeToggle: 'テーマの切り替え',
    workflowTab: {
      confirmDelete: 'このワークフローを削除してもよろしいですか？',
      confirmDeleteTitle: 'ワークフローを削除しますか？',
      confirmOverwrite: '以下のファイルはすでに存在します。上書きしますか？',
      confirmOverwriteTitle: '既存のファイルを上書きしますか？',
      deleteFailed: 'ワークフローの削除を試みましたが、失敗しました。',
      deleteFailedTitle: '削除に失敗しました',
      deleted: 'ワークフローが削除されました',
      dirtyClose: '以下のファイルが変更されました。閉じる前に保存しますか？',
      dirtyCloseTitle: '変更を保存しますか？'
    },
    workflows: 'ワークフロー'
  },
  star = 'スター',
  systemInfo = 'システム情報',
  tabMenu = {
    closeOtherTabs: '他のタブを閉じる',
    closeTab: 'タブを閉じる',
    closeTabsToLeft: '左のタブを閉じる',
    closeTabsToRight: '右のタブを閉じる',
    duplicateTab: 'タブを複製'
  },
  templateWorkflows = {
    template: {
      default: '画像生成',
      flux_schnell: 'Flux Schnell',
      image2image: '画像から画像へ',
      upscale: '2パスアップスケール'
    },
    title: 'テンプレートを利用して開始'
  },
  terminal = 'ターミナル',
  userSelect = {
    enterUsername: 'ユーザー名を入力してください',
    existingUser: '既存のユーザー',
    newUser: '新しいユーザー',
    next: '次へ',
    selectUser: 'ユーザーを選択'
  },
  videoFailedToLoad = 'ビデオの読み込みに失敗しました',
  welcome = { getStarted: 'はじめる', title: 'ComfyUIへようこそ' },
  ja = {
    about: about,
    add: add,
    bookmark: bookmark,
    box: box,
    briefcase: briefcase,
    cancel: cancel,
    color: color,
    comingSoon: comingSoon,
    confirm: confirm$1,
    copyToClipboard: copyToClipboard,
    currentUser: currentUser,
    customize: customize,
    customizeFolder: customizeFolder,
    delete: '削除',
    deprecated: deprecated,
    desktopMenu: desktopMenu,
    devices: devices,
    download: download,
    downloadGit: downloadGit,
    electronFileDownload: electronFileDownload,
    empty: empty,
    error: error,
    experimental: experimental,
    extensionName: extensionName,
    file: file,
    findIssues: findIssues,
    firstTimeUIMessage: firstTimeUIMessage,
    folder: folder,
    goToNode: goToNode,
    graphCanvasMenu: graphCanvasMenu,
    heart: heart,
    icon: icon,
    imageFailedToLoad: imageFailedToLoad,
    inbox: inbox,
    insert: insert,
    install: install,
    loadAllFolders: loadAllFolders,
    loadWorkflow: loadWorkflow,
    loading: loading,
    logs: logs,
    menu: menu,
    menuLabels: menuLabels,
    newFolder: newFolder,
    no: no,
    noResultsFound: noResultsFound,
    noTasksFound: noTasksFound,
    noTasksFoundMessage: noTasksFoundMessage,
    noWorkflowsFound: noWorkflowsFound,
    nodeDefs: nodeDefs,
    notSupported: notSupported,
    openNewIssue: openNewIssue,
    overwrite: overwrite,
    reconnected: reconnected,
    reconnecting: reconnecting,
    refresh: refresh,
    reloadToApplyChanges: reloadToApplyChanges,
    rename: rename,
    reportIssue: reportIssue,
    reportIssueTooltip: reportIssueTooltip,
    reportSent: reportSent,
    reset: reset,
    resetKeybindingsTooltip: resetKeybindingsTooltip,
    save: save,
    searchExtensions: searchExtensions,
    searchFailedMessage: searchFailedMessage,
    searchKeybindings: searchKeybindings,
    searchModels: searchModels,
    searchNodes: searchNodes,
    searchSettings: searchSettings,
    searchWorkflows: searchWorkflows,
    serverConfig: serverConfig,
    serverConfigCategories: serverConfigCategories,
    serverConfigItems: serverConfigItems,
    serverStart: serverStart,
    settings: settings,
    settingsCategories: settingsCategories,
    settingsDialog: settingsDialog,
    showReport: showReport,
    sideToolbar: sideToolbar,
    star: star,
    systemInfo: systemInfo,
    tabMenu: tabMenu,
    templateWorkflows: templateWorkflows,
    terminal: terminal,
    userSelect: userSelect,
    videoFailedToLoad: videoFailedToLoad,
    welcome: welcome
  },
  i18n = VueI18n.createI18n({
    legacy: !1,
    locale: navigator.language.split('-')[0] || 'en',
    fallbackLocale: 'en',
    messages: { en: en, zh: zh, ru: ru, ja: ja }
  }),
  { t: t } = i18n.global
function showLoadWorkflowWarning(e) {
  useDialogStore().showDialog({
    key: 'global-load-workflow-warning',
    component: LoadWorkflowWarning,
    props: e
  })
}
function showMissingModelsWarning(e) {
  useDialogStore().showDialog({
    key: 'global-missing-models-warning',
    component: MissingModelsWarning,
    props: e
  })
}
function showSettingsDialog() {
  useDialogStore().showDialog({
    key: 'global-settings',
    headerComponent: SettingDialogHeader,
    component: SettingDialogContent
  })
}
function showExecutionErrorDialog(e) {
  useDialogStore().showDialog({
    key: 'global-execution-error',
    component: ExecutionErrorDialogContent,
    props: { error: e }
  })
}
function showTemplateWorkflowsDialog() {
  useDialogStore().showDialog({
    key: 'global-template-workflows',
    title: i18n.global.t('templateWorkflows.title'),
    component: TemplateWorkflowsContent
  })
}
async function showPromptDialog({
  title: e,
  message: t,
  defaultValue: n = ''
}) {
  const o = useDialogStore()
  return new Promise((i) => {
    o.showDialog({
      key: 'global-prompt',
      title: e,
      component: _sfc_main$t,
      props: {
        message: t,
        defaultValue: n,
        onConfirm: __name((e) => {
          i(e)
        }, 'onConfirm')
      },
      dialogComponentProps: {
        onClose: __name(() => {
          i(null)
        }, 'onClose')
      }
    })
  })
}
async function showConfirmationDialog({
  title: e,
  type: t,
  message: n,
  itemList: o = []
}) {
  return new Promise((i) => {
    const r = {
      key: 'global-prompt',
      title: e,
      component: _sfc_main$s,
      props: { message: n, type: t, itemList: o, onConfirm: i },
      dialogComponentProps: { onClose: __name(() => i(null), 'onClose') }
    }
    useDialogStore().showDialog(r)
  })
}
__name(showLoadWorkflowWarning, 'showLoadWorkflowWarning'),
  __name(showMissingModelsWarning, 'showMissingModelsWarning'),
  __name(showSettingsDialog, 'showSettingsDialog'),
  __name(showExecutionErrorDialog, 'showExecutionErrorDialog'),
  __name(showTemplateWorkflowsDialog, 'showTemplateWorkflowsDialog'),
  __name(showPromptDialog, 'showPromptDialog'),
  __name(showConfirmationDialog, 'showConfirmationDialog')
const ComfyDialog = ComfyDialog$1
function $el(e, t, n) {
  const o = e.split('.'),
    i = document.createElement(o.shift())
  if ((o.length > 0 && i.classList.add(...o), t))
    if (
      ('string' == typeof t
        ? (t = { textContent: t })
        : t instanceof Element && (t = [t]),
      Array.isArray(t))
    )
      i.append(...t)
    else {
      const { parent: e, $: o, dataset: r, style: a, ...s } = t
      s.for && i.setAttribute('for', s.for),
        a && Object.assign(i.style, a),
        r && Object.assign(i.dataset, r),
        Object.assign(i, s),
        n && i.append(...(Array.isArray(n) ? n : [n])),
        e && e.append(i),
        o && o(i)
    }
  return i
}
function dragElement(e, t) {
  var n = 0,
    o = 0,
    i = 0,
    r = 0,
    a = 0,
    s = 0
  e.getElementsByClassName('drag-handle')[0]
    ? (e.getElementsByClassName('drag-handle')[0].onmousedown = p)
    : (e.onmousedown = p)
  new ResizeObserver(() => {
    l()
  }).observe(e)
  function l() {
    try {
      ;(a = Math.min(
        document.body.clientWidth - e.clientWidth,
        Math.max(0, e.offsetLeft)
      )),
        (s = Math.min(
          document.body.clientHeight - e.clientHeight,
          Math.max(0, e.offsetTop)
        )),
        c()
    } catch (t) {}
  }
  function c() {
    if ('none' === e.style.display) return
    const t = document.body.clientWidth / 2
    a + e.clientWidth / 2 > t
      ? ((e.style.left = 'unset'),
        (e.style.right = document.body.clientWidth - a - e.clientWidth + 'px'))
      : ((e.style.left = a + 'px'), (e.style.right = 'unset')),
      (e.style.top = s + 'px'),
      (e.style.bottom = 'unset'),
      u &&
        localStorage.setItem(
          'Comfy.MenuPosition',
          JSON.stringify({ x: e.offsetLeft, y: e.offsetTop })
        )
  }
  function d() {
    let e = localStorage.getItem('Comfy.MenuPosition')
    if (e) {
      const t = JSON.parse(e)
      ;(a = t.x), (s = t.y), c(), l()
    }
  }
  let u
  function p(e) {
    ;(e = e || window.event).preventDefault(),
      (i = e.clientX),
      (r = e.clientY),
      (document.onmouseup = m),
      (document.onmousemove = h)
  }
  function h(t) {
    ;(t = t || window.event).preventDefault(),
      e.classList.add('comfy-menu-manual-pos'),
      (n = t.clientX - i),
      (o = t.clientY - r),
      (i = t.clientX),
      (r = t.clientY),
      (a = Math.min(
        document.body.clientWidth - e.clientWidth,
        Math.max(0, e.offsetLeft + n)
      )),
      (s = Math.min(
        document.body.clientHeight - e.clientHeight,
        Math.max(0, e.offsetTop + o)
      )),
      c()
  }
  function m() {
    ;(document.onmouseup = null), (document.onmousemove = null)
  }
  return (
    __name(l, 'ensureInBounds'),
    __name(c, 'positionElement'),
    __name(d, 'restorePos'),
    t.addSetting({
      id: 'Comfy.MenuPosition',
      category: ['Comfy', 'Menu', 'MenuPosition'],
      name: "Save legacy menu's position",
      type: 'boolean',
      defaultValue: u,
      onChange(e) {
        void 0 === u && e && d(), (u = e)
      }
    }),
    __name(p, 'dragMouseDown'),
    __name(h, 'elementDrag'),
    window.addEventListener('resize', () => {
      l()
    }),
    __name(m, 'closeDragElement'),
    d
  )
}
__name($el, '$el'), __name(dragElement, 'dragElement')
class ComfyList {
  static {
    __name(this, 'ComfyList')
  }
  #X
  #J
  #Q
  element
  button
  constructor(e, t, n) {
    ;(this.#J = e),
      (this.#X = t || e.toLowerCase()),
      (this.#Q = n || !1),
      (this.element = $el('div.comfy-list')),
      (this.element.style.display = 'none')
  }
  get visible() {
    return 'none' !== this.element.style.display
  }
  async load() {
    const e = await api.getItems(this.#X)
    this.element.replaceChildren(
      ...Object.keys(e).flatMap((t) => [
        $el('h4', { textContent: t }),
        $el('div.comfy-list-items', [
          ...(this.#Q ? e[t].reverse() : e[t]).map((e) => {
            const t =
              'remove' in e
                ? e.remove
                : {
                    name: 'Delete',
                    cb: __name(() => api.deleteItem(this.#X, e.prompt[1]), 'cb')
                  }
            return $el('div', { textContent: e.prompt[0] + ': ' }, [
              $el('button', {
                textContent: 'Load',
                onclick: __name(async () => {
                  if (
                    (await app$1.loadGraphData(
                      e.prompt[3].extra_pnginfo.workflow,
                      !0,
                      !1
                    ),
                    'outputs' in e)
                  ) {
                    app$1.nodeOutputs = {}
                    for (const [t, n] of Object.entries(e.outputs)) {
                      const o = e.meta?.[t]?.display_node ?? t
                      app$1.nodeOutputs[o] = n
                    }
                  }
                }, 'onclick')
              }),
              $el('button', {
                textContent: t.name,
                onclick: __name(async () => {
                  await t.cb(), await this.update()
                }, 'onclick')
              })
            ])
          })
        ])
      ]),
      $el('div.comfy-list-actions', [
        $el('button', {
          textContent: 'Clear ' + this.#J,
          onclick: __name(async () => {
            await api.clearItems(this.#X), await this.load()
          }, 'onclick')
        }),
        $el('button', {
          textContent: 'Refresh',
          onclick: __name(() => this.load(), 'onclick')
        })
      ])
    )
  }
  async update() {
    this.visible && (await this.load())
  }
  async show() {
    ;(this.element.style.display = 'block'),
      (this.button.textContent = 'Close'),
      await this.load()
  }
  hide() {
    ;(this.element.style.display = 'none'),
      (this.button.textContent = 'View ' + this.#J)
  }
  toggle() {
    return this.visible ? (this.hide(), !1) : (this.show(), !0)
  }
}
class ComfyUI {
  static {
    __name(this, 'ComfyUI')
  }
  app
  dialog
  settings
  batchCount
  lastQueueSize
  queue
  history
  autoQueueMode
  graphHasChanged
  autoQueueEnabled
  menuContainer
  queueSize
  restoreMenuPosition
  loadFile
  constructor(e) {
    ;(this.app = e),
      (this.dialog = new ComfyDialog()),
      (this.settings = new ComfySettingsDialog(e)),
      (this.batchCount = 1),
      (this.lastQueueSize = 0),
      (this.queue = new ComfyList('Queue')),
      (this.history = new ComfyList('History', 'history', !0)),
      api.addEventListener('status', () => {
        this.queue.update(), this.history.update()
      }),
      this.setup(document.body)
  }
  setup(e) {
    const t = $el('input', {
      id: 'comfy-file-input',
      type: 'file',
      accept: '.json,image/png,.latent,.safetensors,image/webp,audio/flac',
      style: { display: 'none' },
      parent: document.body,
      onchange: __name(async () => {
        await app$1.handleFile(t.files[0]), (t.value = '')
      }, 'onchange')
    })
    this.loadFile = () => t.click()
    const n = toggleSwitch(
      'autoQueueMode',
      [
        {
          text: 'instant',
          tooltip: 'A new prompt will be queued as soon as the queue reaches 0'
        },
        {
          text: 'change',
          tooltip:
            'A new prompt will be queued when the queue is at 0 and the graph is/has changed'
        }
      ],
      {
        onChange: __name((e) => {
          this.autoQueueMode = e.item.value
        }, 'onChange')
      }
    )
    ;(n.style.display = 'none'),
      api.addEventListener('graphChanged', () => {
        'change' === this.autoQueueMode &&
          !0 === this.autoQueueEnabled &&
          (0 === this.lastQueueSize
            ? ((this.graphHasChanged = !1),
              app$1.queuePrompt(0, this.batchCount))
            : (this.graphHasChanged = !0))
      }),
      (this.menuContainer = $el('div.comfy-menu', { parent: e }, [
        $el(
          'div.drag-handle.comfy-menu-header',
          {
            style: {
              overflow: 'hidden',
              position: 'relative',
              width: '100%',
              cursor: 'default'
            }
          },
          [
            $el('span.drag-handle'),
            $el('span.comfy-menu-queue-size', {
              $: __name((e) => (this.queueSize = e), '$')
            }),
            $el('div.comfy-menu-actions', [
              $el('button.comfy-settings-btn', {
                textContent: '⚙️',
                onclick: showSettingsDialog
              }),
              $el('button.comfy-close-menu-btn', {
                textContent: '×',
                onclick: __name(() => {
                  useWorkspaceStore().focusMode = !0
                }, 'onclick')
              })
            ])
          ]
        ),
        $el('button.comfy-queue-btn', {
          id: 'queue-button',
          textContent: 'Queue Prompt',
          onclick: __name(
            () => app$1.queuePrompt(0, this.batchCount),
            'onclick'
          )
        }),
        $el('div', {}, [
          $el('label', { innerHTML: 'Extra options' }, [
            $el('input', {
              type: 'checkbox',
              onchange: __name((e) => {
                ;(document.getElementById('extraOptions').style.display = e
                  .srcElement.checked
                  ? 'block'
                  : 'none'),
                  (this.batchCount = e.srcElement.checked
                    ? Number.parseInt(
                        document.getElementById('batchCountInputRange').value
                      )
                    : 1),
                  (document.getElementById('autoQueueCheckbox').checked = !1),
                  (this.autoQueueEnabled = !1)
              }, 'onchange')
            })
          ])
        ]),
        $el(
          'div',
          { id: 'extraOptions', style: { width: '100%', display: 'none' } },
          [
            $el('div', [
              $el('label', { innerHTML: 'Batch count' }),
              $el('input', {
                id: 'batchCountInputNumber',
                type: 'number',
                value: this.batchCount,
                min: '1',
                style: { width: '35%', marginLeft: '0.4em' },
                oninput: __name((e) => {
                  ;(this.batchCount = e.target.value),
                    (document.getElementById('batchCountInputRange').value =
                      this.batchCount.toString())
                }, 'oninput')
              }),
              $el('input', {
                id: 'batchCountInputRange',
                type: 'range',
                min: '1',
                max: '100',
                value: this.batchCount,
                oninput: __name((e) => {
                  ;(this.batchCount = e.srcElement.value),
                    (document.getElementById('batchCountInputNumber').value =
                      e.srcElement.value)
                }, 'oninput')
              })
            ]),
            $el('div', [
              $el('label', {
                for: 'autoQueueCheckbox',
                innerHTML: 'Auto Queue'
              }),
              $el('input', {
                id: 'autoQueueCheckbox',
                type: 'checkbox',
                checked: !1,
                title: 'Automatically queue prompt when the queue size hits 0',
                onchange: __name((e) => {
                  ;(this.autoQueueEnabled = e.target.checked),
                    (n.style.display = this.autoQueueEnabled ? '' : 'none')
                }, 'onchange')
              }),
              n
            ])
          ]
        ),
        $el('div.comfy-menu-btns', [
          $el('button', {
            id: 'queue-front-button',
            textContent: 'Queue Front',
            onclick: __name(
              () => app$1.queuePrompt(-1, this.batchCount),
              'onclick'
            )
          }),
          $el('button', {
            $: __name((e) => (this.queue.button = e), '$'),
            id: 'comfy-view-queue-button',
            textContent: 'View Queue',
            onclick: __name(() => {
              this.history.hide(), this.queue.toggle()
            }, 'onclick')
          }),
          $el('button', {
            $: __name((e) => (this.history.button = e), '$'),
            id: 'comfy-view-history-button',
            textContent: 'View History',
            onclick: __name(() => {
              this.queue.hide(), this.history.toggle()
            }, 'onclick')
          })
        ]),
        this.queue.element,
        this.history.element,
        $el('button', {
          id: 'comfy-save-button',
          textContent: 'Save',
          onclick: __name(() => {
            useCommandStore().execute('Comfy.ExportWorkflow')
          }, 'onclick')
        }),
        $el('button', {
          id: 'comfy-dev-save-api-button',
          textContent: 'Save (API Format)',
          style: { width: '100%', display: 'none' },
          onclick: __name(() => {
            useCommandStore().execute('Comfy.ExportWorkflowAPI')
          }, 'onclick')
        }),
        $el('button', {
          id: 'comfy-load-button',
          textContent: 'Load',
          onclick: __name(() => t.click(), 'onclick')
        }),
        $el('button', {
          id: 'comfy-refresh-button',
          textContent: 'Refresh',
          onclick: __name(() => app$1.refreshComboInNodes(), 'onclick')
        }),
        $el('button', {
          id: 'comfy-clipspace-button',
          textContent: 'Clipspace',
          onclick: __name(() => app$1.openClipspace(), 'onclick')
        }),
        $el('button', {
          id: 'comfy-clear-button',
          textContent: 'Clear',
          onclick: __name(() => {
            ;(useSettingStore().get('Comfy.ConfirmClear') &&
              !confirm('Clear workflow?')) ||
              (app$1.clean(),
              app$1.graph.clear(),
              app$1.resetView(),
              api.dispatchCustomEvent('graphCleared'))
          }, 'onclick')
        }),
        $el('button', {
          id: 'comfy-load-default-button',
          textContent: 'Load Default',
          onclick: __name(async () => {
            ;(useSettingStore().get('Comfy.ConfirmClear') &&
              !confirm('Load default workflow?')) ||
              (app$1.resetView(), await app$1.loadGraphData())
          }, 'onclick')
        }),
        $el('button', {
          id: 'comfy-reset-view-button',
          textContent: 'Reset View',
          onclick: __name(async () => {
            app$1.resetView()
          }, 'onclick')
        })
      ])),
      (this.menuContainer.style.display = 'none'),
      (this.restoreMenuPosition = dragElement(
        this.menuContainer,
        this.settings
      )),
      this.setStatus({ exec_info: { queue_remaining: 'X' } })
  }
  setStatus(e) {
    ;(this.queueSize.textContent =
      'Queue size: ' + (e ? e.exec_info.queue_remaining : 'ERR')),
      e &&
        (0 == this.lastQueueSize ||
          0 != e.exec_info.queue_remaining ||
          !this.autoQueueEnabled ||
          ('instant' !== this.autoQueueMode && !this.graphHasChanged) ||
          app$1.lastExecutionError ||
          (app$1.queuePrompt(0, this.batchCount),
          (e.exec_info.queue_remaining += this.batchCount),
          (this.graphHasChanged = !1)),
        (this.lastQueueSize = e.exec_info.queue_remaining))
  }
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.ui = window.comfyAPI.ui || {}),
  (window.comfyAPI.ui.ComfyDialog = ComfyDialog),
  (window.comfyAPI.ui.$el = $el),
  (window.comfyAPI.ui.ComfyUI = ComfyUI)
const defaultGraph = {
    last_node_id: 9,
    last_link_id: 9,
    nodes: [
      {
        id: 7,
        type: 'CLIPTextEncode',
        pos: [413, 389],
        size: [425.27801513671875, 180.6060791015625],
        flags: {},
        order: 3,
        mode: 0,
        inputs: [{ name: 'clip', type: 'CLIP', link: 5 }],
        outputs: [
          {
            name: 'CONDITIONING',
            type: 'CONDITIONING',
            links: [6],
            slot_index: 0
          }
        ],
        properties: {},
        widgets_values: ['text, watermark']
      },
      {
        id: 6,
        type: 'CLIPTextEncode',
        pos: [415, 186],
        size: [422.84503173828125, 164.31304931640625],
        flags: {},
        order: 2,
        mode: 0,
        inputs: [{ name: 'clip', type: 'CLIP', link: 3 }],
        outputs: [
          {
            name: 'CONDITIONING',
            type: 'CONDITIONING',
            links: [4],
            slot_index: 0
          }
        ],
        properties: {},
        widgets_values: [
          'beautiful scenery nature glass bottle landscape, , purple galaxy bottle,'
        ]
      },
      {
        id: 5,
        type: 'EmptyLatentImage',
        pos: [473, 609],
        size: [315, 106],
        flags: {},
        order: 1,
        mode: 0,
        outputs: [
          { name: 'LATENT', type: 'LATENT', links: [2], slot_index: 0 }
        ],
        properties: {},
        widgets_values: [512, 512, 1]
      },
      {
        id: 3,
        type: 'KSampler',
        pos: [863, 186],
        size: [315, 262],
        flags: {},
        order: 4,
        mode: 0,
        inputs: [
          { name: 'model', type: 'MODEL', link: 1 },
          { name: 'positive', type: 'CONDITIONING', link: 4 },
          { name: 'negative', type: 'CONDITIONING', link: 6 },
          { name: 'latent_image', type: 'LATENT', link: 2 }
        ],
        outputs: [
          { name: 'LATENT', type: 'LATENT', links: [7], slot_index: 0 }
        ],
        properties: {},
        widgets_values: [0x8e7ff42ed37e, !0, 20, 8, 'euler', 'normal', 1]
      },
      {
        id: 8,
        type: 'VAEDecode',
        pos: [1209, 188],
        size: [210, 46],
        flags: {},
        order: 5,
        mode: 0,
        inputs: [
          { name: 'samples', type: 'LATENT', link: 7 },
          { name: 'vae', type: 'VAE', link: 8 }
        ],
        outputs: [{ name: 'IMAGE', type: 'IMAGE', links: [9], slot_index: 0 }],
        properties: {}
      },
      {
        id: 9,
        type: 'SaveImage',
        pos: [1451, 189],
        size: [210, 26],
        flags: {},
        order: 6,
        mode: 0,
        inputs: [{ name: 'images', type: 'IMAGE', link: 9 }],
        properties: {}
      },
      {
        id: 4,
        type: 'CheckpointLoaderSimple',
        pos: [26, 474],
        size: [315, 98],
        flags: {},
        order: 0,
        mode: 0,
        outputs: [
          { name: 'MODEL', type: 'MODEL', links: [1], slot_index: 0 },
          { name: 'CLIP', type: 'CLIP', links: [3, 5], slot_index: 1 },
          { name: 'VAE', type: 'VAE', links: [8], slot_index: 2 }
        ],
        properties: {},
        widgets_values: ['v1-5-pruned-emaonly.ckpt']
      }
    ],
    links: [
      [1, 4, 0, 3, 0, 'MODEL'],
      [2, 5, 0, 3, 3, 'LATENT'],
      [3, 4, 1, 6, 0, 'CLIP'],
      [4, 6, 0, 3, 1, 'CONDITIONING'],
      [5, 4, 1, 7, 0, 'CLIP'],
      [6, 7, 0, 3, 2, 'CONDITIONING'],
      [7, 3, 0, 8, 0, 'LATENT'],
      [8, 4, 2, 8, 1, 'VAE'],
      [9, 8, 0, 9, 0, 'IMAGE']
    ],
    groups: [],
    config: {},
    extra: {},
    version: 0.4
  },
  defaultGraphJSON = JSON.stringify(defaultGraph),
  blankGraph = {
    last_node_id: 0,
    last_link_id: 0,
    nodes: [],
    links: [],
    groups: [],
    config: {},
    extra: {},
    version: 0.4
  }
function getFromPngBuffer(e) {
  const t = new Uint8Array(e),
    n = new DataView(t.buffer)
  if (2303741511 !== n.getUint32(0))
    return void console.error('Not a valid PNG file')
  let o = 8,
    i = {}
  for (; o < t.length; ) {
    const e = n.getUint32(o),
      r = String.fromCharCode(...t.slice(o + 4, o + 8))
    if ('tEXt' === r || 'comf' == r || 'iTXt' === r) {
      let n = o + 8
      for (; 0 !== t[n]; ) n++
      const r = String.fromCharCode(...t.slice(o + 8, n)),
        a = t.slice(n + 1, o + 8 + e),
        s = new TextDecoder('utf-8').decode(a)
      i[r] = s
    }
    o += 12 + e
  }
  return i
}
function getFromPngFile(e) {
  return new Promise((t) => {
    const n = new FileReader()
    ;(n.onload = (e) => {
      t(getFromPngBuffer(e.target.result))
    }),
      n.readAsArrayBuffer(e)
  })
}
function getFromFlacBuffer(e) {
  const t = new DataView(e)
  if ('fLaC' !== String.fromCharCode(...new Uint8Array(e, 0, 4)))
    return void console.error('Not a valid FLAC file')
  let n = 4,
    o = null
  for (; n < t.byteLength; ) {
    const i = 128 & t.getUint8(n),
      r = 127 & t.getUint8(n),
      a = 16777215 & t.getUint32(n, !1)
    if (
      ((n += 4),
      4 === r && (o = parseVorbisComment(new DataView(e, n, a))),
      (n += a),
      i)
    )
      break
  }
  return o
}
function getFromFlacFile(e) {
  return new Promise((t) => {
    const n = new FileReader()
    ;(n.onload = function (e) {
      const n = e.target.result
      t(getFromFlacBuffer(n))
    }),
      n.readAsArrayBuffer(e)
  })
}
function parseVorbisComment(e) {
  let t = 0
  const n = e.getUint32(t, !0)
  t += 4
  getString(e, t, n)
  t += n
  const o = e.getUint32(t, !0)
  t += 4
  const i = {}
  for (let r = 0; r < o; r++) {
    const n = e.getUint32(t, !0)
    t += 4
    const o = getString(e, t, n)
    t += n
    const r = o.indexOf('=')
    i[o.substring(0, r)] = o.substring(r + 1)
  }
  return i
}
function getString(e, t, n) {
  let o = ''
  for (let i = 0; i < n; i++) o += String.fromCharCode(e.getUint8(t + i))
  return o
}
function getPngMetadata(e) {
  return getFromPngFile(e)
}
function getFlacMetadata(e) {
  return getFromFlacFile(e)
}
function parseExifData(e) {
  const t = 'II' === String.fromCharCode(...e.slice(0, 2))
  function n(t, n, o) {
    let i = e.slice(t, t + o)
    return 2 === o
      ? new DataView(i.buffer, i.byteOffset, i.byteLength).getUint16(0, n)
      : 4 === o
        ? new DataView(i.buffer, i.byteOffset, i.byteLength).getUint32(0, n)
        : void 0
  }
  __name(n, 'readInt')
  const o = n(4, t, 4)
  function i(o) {
    const i = n(o, t, 2),
      r = {}
    for (let a = 0; a < i; a++) {
      const i = o + 2 + 12 * a,
        s = n(i, t, 2),
        l = n(i + 2, t, 2),
        c = n(i + 4, t, 4),
        d = n(i + 8, t, 4)
      let u
      2 === l &&
        (u = new TextDecoder('utf-8').decode(e.subarray(d, d + c - 1))),
        (r[s] = u)
    }
    return r
  }
  __name(i, 'parseIFD')
  return i(o)
}
function splitValues(e) {
  var t = {}
  for (var n in e) {
    var o = e[n].split(':', 2)
    t[o[0]] = o[1]
  }
  return t
}
function getWebpMetadata(e) {
  return new Promise((t) => {
    const n = new FileReader()
    ;(n.onload = (e) => {
      const n = new Uint8Array(e.target.result),
        o = new DataView(n.buffer)
      if (1380533830 !== o.getUint32(0) || 1464156752 !== o.getUint32(8))
        return console.error('Not a valid WEBP file'), void t({})
      let i = 12,
        r = {}
      for (; i < n.length; ) {
        const e = o.getUint32(i + 4, !0)
        if ('EXIF' === String.fromCharCode(...n.slice(i, i + 4))) {
          'Exif\0\0' == String.fromCharCode(...n.slice(i + 8, i + 8 + 6)) &&
            (i += 6)
          let t = parseExifData(n.slice(i + 8, i + 8 + e))
          for (var a in t) {
            const e = t[a]
            if ('string' == typeof e) {
              const t = e.indexOf(':')
              r[e.slice(0, t)] = e.slice(t + 1)
            }
          }
          break
        }
        i += 8 + e
      }
      t(r)
    }),
      n.readAsArrayBuffer(e)
  })
}
function getLatentMetadata(e) {
  return new Promise((t) => {
    const n = new FileReader()
    n.onload = (e) => {
      const n = new Uint8Array(e.target.result)
      let o = new DataView(n.buffer).getUint32(0, !0),
        i = JSON.parse(new TextDecoder().decode(n.slice(8, 8 + o)))
      t(i.__metadata__)
    }
    var o = e.slice(0, 4194304)
    n.readAsArrayBuffer(o)
  })
}
async function importA1111(e, t) {
  const n = t.lastIndexOf('\nSteps:')
  if (n > -1) {
    const o = await api.getEmbeddings(),
      i = t
        .substr(n)
        .split('\n')[1]
        .match(
          new RegExp(
            '\\s*([^:]+:\\s*([^"\\{].*?|".*?"|\\{.*?\\}))\\s*(,|$)',
            'g'
          )
        )
        .reduce((e, t) => {
          const n = t.split(':')
          return (
            n[1].endsWith(',') && (n[1] = n[1].substr(0, n[1].length - 1)),
            (e[n[0].trim().toLowerCase()] = n[1].trim()),
            e
          )
        }, {}),
      r = t.lastIndexOf('\nNegative prompt:', n)
    if (r > -1) {
      let a = t.substr(0, r).trim(),
        s = t.substring(r + 18, n).trim()
      const l = LiteGraph.createNode('CheckpointLoaderSimple'),
        c = LiteGraph.createNode('CLIPSetLastLayer'),
        d = LiteGraph.createNode('CLIPTextEncode'),
        u = LiteGraph.createNode('CLIPTextEncode'),
        p = LiteGraph.createNode('KSampler'),
        h = LiteGraph.createNode('EmptyLatentImage'),
        m = LiteGraph.createNode('VAEDecode'),
        f = LiteGraph.createNode('VAELoader'),
        _ = LiteGraph.createNode('SaveImage')
      let g = null,
        v = null
      const y = __name((e) => 64 * Math.ceil(e / 64), 'ceil64'),
        b = __name((e, t) => e.widgets.find((e) => e.name === t), 'getWidget'),
        S = __name((e, t, n, o) => {
          const i = b(e, t)
          if (o) {
            const o = i.options.values.find((e) => e.startsWith(n))
            o
              ? (i.value = o)
              : (console.warn(`Unknown value '${n}' for widget '${t}'`, e),
                (i.value = n))
          } else i.value = n
        }, 'setWidgetValue'),
        C = __name((t, n, o, i) => {
          const r = []
          n = n.replace(/<lora:([^:]+:[^>]+)>/g, function (e, t) {
            const n = t.split(':'),
              o = parseFloat(n[1])
            return (
              isNaN(o)
                ? console.warn('Invalid LORA', e)
                : r.push({ name: n[0], weight: o }),
              ''
            )
          })
          for (const a of r) {
            const t = LiteGraph.createNode('LoraLoader')
            e.add(t),
              S(t, 'lora_name', a.name, !0),
              S(t, 'strength_model', a.weight),
              S(t, 'strength_clip', a.weight),
              i.node.connect(i.index, t, 0),
              o.node.connect(o.index, t, 1),
              (i = { node: t, index: 0 }),
              (o = { node: t, index: 1 })
          }
          return (
            o.node.connect(1, t, 0),
            i.node.connect(0, p, 0),
            g && i.node.connect(0, g, 0),
            { text: n, prevModel: i, prevClip: o }
          )
        }, 'createLoraNodes'),
        w = __name(
          (e) =>
            o.length
              ? e.replaceAll(
                  new RegExp(
                    '\\b(' +
                      o
                        .map((e) => e.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
                        .join('\\b|\\b') +
                      ')\\b',
                    'ig'
                  ),
                  'embedding:$1'
                )
              : e,
          'replaceEmbeddings'
        ),
        k = __name((e) => {
          const t = i[e]
          return delete i[e], t
        }, 'popOpt')
      e.clear(),
        e.add(l),
        e.add(c),
        e.add(d),
        e.add(u),
        e.add(p),
        e.add(h),
        e.add(m),
        e.add(f),
        e.add(_),
        l.connect(1, c, 0),
        c.connect(0, d, 0),
        c.connect(0, u, 0),
        l.connect(0, p, 0),
        d.connect(0, p, 1),
        u.connect(0, p, 2),
        h.connect(0, p, 3),
        m.connect(0, _, 0),
        p.connect(0, m, 0),
        f.connect(0, m, 1)
      const x = {
        model(e) {
          S(l, 'ckpt_name', e, !0)
        },
        vae(e) {
          S(f, 'vae_name', e, !0)
        },
        'cfg scale'(e) {
          S(p, 'cfg', +e)
        },
        'clip skip'(e) {
          S(c, 'stop_at_clip_layer', -e)
        },
        sampler(e) {
          let t = e.toLowerCase().replace('++', 'pp').replaceAll(' ', '_')
          t.includes('karras')
            ? ((t = t.replace('karras', '').replace(/_+$/, '')),
              S(p, 'scheduler', 'karras'))
            : S(p, 'scheduler', 'normal')
          const n = b(p, 'sampler_name').options.values.find(
            (e) => e === t || e === 'sample_' + t
          )
          n && S(p, 'sampler_name', n)
        },
        size(t) {
          const n = t.split('x'),
            o = y(+n[0]),
            i = y(+n[1]),
            r = k('hires upscale'),
            a = k('hires resize')
          v = k('hires steps')
          let s = k('hires upscaler')
          if ((S(h, 'width', o), S(h, 'height', i), r || a)) {
            let t, n, c, h
            if (r) (t = o * r), (n = i * r)
            else {
              const e = a.split('x')
              ;(t = +e[0]), (n = +e[1])
            }
            if (s.startsWith('Latent')) {
              if (
                ((h = c = LiteGraph.createNode('LatentUpscale')),
                e.add(c),
                p.connect(0, c, 0),
                'Latent (nearest-exact)' === s)
              )
                s = 'nearest-exact'
              S(c, 'upscale_method', s, !0)
            } else {
              const t = LiteGraph.createNode('VAEDecodeTiled')
              e.add(t), p.connect(0, t, 0), f.connect(0, t, 1)
              const n = LiteGraph.createNode('UpscaleModelLoader')
              e.add(n), S(n, 'model_name', s, !0)
              const o = LiteGraph.createNode('ImageUpscaleWithModel')
              e.add(o),
                t.connect(0, o, 1),
                n.connect(0, o, 0),
                (c = LiteGraph.createNode('ImageScale')),
                e.add(c),
                o.connect(0, c, 0)
              const i = (h = LiteGraph.createNode('VAEEncodeTiled'))
              e.add(i), c.connect(0, i, 0), f.connect(0, i, 1)
            }
            S(c, 'width', y(t)),
              S(c, 'height', y(n)),
              (g = LiteGraph.createNode('KSampler')),
              e.add(g),
              l.connect(0, g, 0),
              d.connect(0, g, 1),
              u.connect(0, g, 2),
              h.connect(0, g, 3),
              g.connect(0, m, 0)
          }
        },
        steps(e) {
          S(p, 'steps', +e)
        },
        seed(e) {
          S(p, 'seed', +e)
        }
      }
      for (const e in i) e in x && x[e](k(e))
      g &&
        (S(g, 'steps', v ? +v : b(p, 'steps').value),
        S(g, 'cfg', b(p, 'cfg').value),
        S(g, 'scheduler', b(p, 'scheduler').value),
        S(g, 'sampler_name', b(p, 'sampler_name').value),
        S(g, 'denoise', +(k('denoising strength') || '1')))
      let E = C(d, a, { node: c, index: 0 }, { node: l, index: 0 })
      ;(a = E.text),
        (E = C(u, s, E.prevClip, E.prevModel)),
        (s = E.text),
        S(d, 'text', w(a)),
        S(u, 'text', w(s)),
        e.arrange()
      for (const e of [
        'model hash',
        'ensd',
        'version',
        'vae hash',
        'ti hashes',
        'lora hashes',
        'hashes'
      ])
        delete i[e]
      console.warn('Unhandled parameters:', i)
    }
  }
}
function calculateImageGrid(e, t, n) {
  let o = 0,
    i = e[0].naturalWidth,
    r = e[0].naturalHeight
  const a = e.length
  let s, l, c, d, u
  for (let p = 1; p <= a; p++) {
    const e = Math.ceil(a / p),
      h = t / p,
      m = h / i,
      f = n / e / r,
      _ = Math.min(m, f, 1),
      g = i * _,
      v = r * _,
      y = g * v * a
    y > o &&
      ((o = y), (s = g), (l = v), (c = p), (d = e), (u = p * ((h - g) / 2)))
  }
  return { cellWidth: s, cellHeight: l, cols: c, rows: d, shiftX: u }
}
function createImageHost(e) {
  const t = $el('div.comfy-img-preview')
  let n,
    o = !0
  function i() {
    let i = null,
      r = null
    if (n) {
      let a = t.clientHeight
      o
        ? ((o = !1),
          a < 190 && (a = 190),
          t.style.setProperty('--comfy-widget-min-height', a.toString()))
        : t.style.setProperty('--comfy-widget-min-height', null)
      const s = e.size[0]
      ;({ cellWidth: i, cellHeight: r } = calculateImageGrid(n, s - 20, a)),
        (i += 'px'),
        (r += 'px'),
        t.style.setProperty('--comfy-img-preview-width', i),
        t.style.setProperty('--comfy-img-preview-height', r)
    }
  }
  return (
    __name(i, 'updateSize'),
    {
      el: t,
      updateImages(o) {
        o !== n &&
          (null == n &&
            requestAnimationFrame(() => {
              i()
            }),
          t.replaceChildren(...o),
          (n = o),
          e.onResize(e.size),
          e.graph.setDirtyCanvas(!0, !0))
      },
      getHeight() {
        i()
      },
      onDraw() {
        t.style.pointerEvents = 'all'
        const o = document.elementFromPoint(
          app$1.canvas.mouse[0],
          app$1.canvas.mouse[1]
        )
        if (((t.style.pointerEvents = 'none'), !o)) return
        const i = n.indexOf(o)
        e.overIndex = i
      }
    }
  )
}
function rgbToHsl({ r: e, g: t, b: n }) {
  ;(e /= 255), (t /= 255), (n /= 255)
  const o = Math.max(e, t, n),
    i = Math.min(e, t, n)
  let r = 0,
    a = 0
  const s = (o + i) / 2
  if (o !== i) {
    const l = o - i
    switch (((a = s > 0.5 ? l / (2 - o - i) : l / (o + i)), o)) {
      case e:
        r = (t - n) / l + (t < n ? 6 : 0)
        break
      case t:
        r = (n - e) / l + 2
        break
      case n:
        r = (e - t) / l + 4
    }
    r /= 6
  }
  return { h: r, s: a, l: s }
}
function hexToRgb(e) {
  let t = 0,
    n = 0,
    o = 0
  return (
    4 == e.length
      ? ((t = parseInt(e[1] + e[1], 16)),
        (n = parseInt(e[2] + e[2], 16)),
        (o = parseInt(e[3] + e[3], 16)))
      : 7 == e.length &&
        ((t = parseInt(e.slice(1, 3), 16)),
        (n = parseInt(e.slice(3, 5), 16)),
        (o = parseInt(e.slice(5, 7), 16))),
    { r: t, g: n, b: o }
  )
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.defaultGraph = window.comfyAPI.defaultGraph || {}),
  (window.comfyAPI.defaultGraph.defaultGraph = defaultGraph),
  (window.comfyAPI.defaultGraph.defaultGraphJSON = defaultGraphJSON),
  (window.comfyAPI.defaultGraph.blankGraph = blankGraph),
  __name(getFromPngBuffer, 'getFromPngBuffer'),
  __name(getFromPngFile, 'getFromPngFile'),
  (window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.png = window.comfyAPI.png || {}),
  (window.comfyAPI.png.getFromPngBuffer = getFromPngBuffer),
  (window.comfyAPI.png.getFromPngFile = getFromPngFile),
  __name(getFromFlacBuffer, 'getFromFlacBuffer'),
  __name(getFromFlacFile, 'getFromFlacFile'),
  __name(parseVorbisComment, 'parseVorbisComment'),
  __name(getString, 'getString'),
  (window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.flac = window.comfyAPI.flac || {}),
  (window.comfyAPI.flac.getFromFlacBuffer = getFromFlacBuffer),
  (window.comfyAPI.flac.getFromFlacFile = getFromFlacFile),
  __name(getPngMetadata, 'getPngMetadata'),
  __name(getFlacMetadata, 'getFlacMetadata'),
  __name(parseExifData, 'parseExifData'),
  __name(splitValues, 'splitValues'),
  __name(getWebpMetadata, 'getWebpMetadata'),
  __name(getLatentMetadata, 'getLatentMetadata'),
  __name(importA1111, 'importA1111'),
  (window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.pnginfo = window.comfyAPI.pnginfo || {}),
  (window.comfyAPI.pnginfo.getPngMetadata = getPngMetadata),
  (window.comfyAPI.pnginfo.getFlacMetadata = getFlacMetadata),
  (window.comfyAPI.pnginfo.getWebpMetadata = getWebpMetadata),
  (window.comfyAPI.pnginfo.getLatentMetadata = getLatentMetadata),
  (window.comfyAPI.pnginfo.importA1111 = importA1111),
  __name(calculateImageGrid, 'calculateImageGrid'),
  __name(createImageHost, 'createImageHost'),
  (window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.imagePreview = window.comfyAPI.imagePreview || {}),
  (window.comfyAPI.imagePreview.calculateImageGrid = calculateImageGrid),
  (window.comfyAPI.imagePreview.createImageHost = createImageHost),
  __name(rgbToHsl, 'rgbToHsl'),
  __name(hexToRgb, 'hexToRgb')
const identifyColorFormat = __name(
    (e) =>
      e
        ? !e.startsWith('#') || (4 !== e.length && 7 !== e.length)
          ? /rgba?\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*/.test(e)
            ? e.includes('rgba')
              ? 'rgba'
              : 'rgb'
            : /hsla?\(\s*\d+(\.\d+)?\s*,\s*\d+(\.\d+)?%\s*,\s*\d+(\.\d+)?%/.test(
                  e
                )
              ? e.includes('hsla')
                ? 'hsla'
                : 'hsl'
              : null
          : 'hex'
        : null,
    'identifyColorFormat'
  ),
  isHSLA = __name(
    (e) =>
      'object' == typeof e &&
      null !== e &&
      ['h', 's', 'l', 'a'].every(
        (t) => 'number' == typeof e[t] && !isNaN(e[t])
      ),
    'isHSLA'
  )
function parseToHSLA(e, t) {
  let n
  switch (t) {
    case 'hex': {
      const t = rgbToHsl(hexToRgb(e))
      return {
        h: Math.round(360 * t.h),
        s: +(100 * t.s).toFixed(1),
        l: +(100 * t.l).toFixed(1),
        a: 1
      }
    }
    case 'rgb':
    case 'rgba': {
      if (((n = e.match(/\d+(\.\d+)?/g)), !n || n.length < 3)) return null
      const [o, i, r] = n.map(Number),
        a = rgbToHsl({ r: o, g: i, b: r }),
        s = 'rgba' === t && n[3] ? parseFloat(n[3]) : 1
      return {
        h: Math.round(360 * a.h),
        s: +(100 * a.s).toFixed(1),
        l: +(100 * a.l).toFixed(1),
        a: s
      }
    }
    case 'hsl':
    case 'hsla': {
      if (((n = e.match(/\d+(\.\d+)?/g)), !n || n.length < 3)) return null
      const [o, i, r] = n.map(Number)
      return {
        h: o,
        s: i,
        l: r,
        a: 'hsla' === t && n[3] ? parseFloat(n[3]) : 1
      }
    }
    default:
      return null
  }
}
__name(parseToHSLA, 'parseToHSLA')
const applyColorAdjustments = __name((e, t) => {
    if (!Object.keys(t).length) return e
    const n = identifyColorFormat(e)
    if (!n)
      return console.warn(`Unsupported color format in color palette: ${e}`), e
    const o = parseToHSLA(e, n)
    return isHSLA(o)
      ? (t.lightness &&
          (o.l = Math.max(0, Math.min(100, o.l + 100 * t.lightness))),
        t.opacity && (o.a = Math.max(0, Math.min(1, t.opacity))),
        `hsla(${o.h}, ${o.s}%, ${o.l}%, ${o.a})`)
      : (console.warn(`Invalid color values in color palette: ${e}`), e)
  }, 'applyColorAdjustments'),
  adjustColor = _.memoize(
    applyColorAdjustments,
    (e, t) => `${e}-${JSON.stringify(t)}`
  ),
  parts = {
    d: __name((e) => e.getDate(), 'd'),
    M: __name((e) => e.getMonth() + 1, 'M'),
    h: __name((e) => e.getHours(), 'h'),
    m: __name((e) => e.getMinutes(), 'm'),
    s: __name((e) => e.getSeconds(), 's')
  },
  format$1 =
    Object.keys(parts)
      .map((e) => e + e + '?')
      .join('|') + '|yyy?y?'
function formatDate(e, t) {
  return e.replace(new RegExp(format$1, 'g'), (e) => {
    if ('yy' === e) return (t.getFullYear() + '').substring(2)
    if ('yyyy' === e) return t.getFullYear().toString()
    if (e[0] in parts) {
      return (parts[e[0]](t) + '').padStart(e.length, '0')
    }
    return e
  })
}
function clone$3(e) {
  try {
    if ('undefined' != typeof structuredClone) return structuredClone(e)
  } catch (t) {}
  return JSON.parse(JSON.stringify(e))
}
function applyTextReplacements(e, t) {
  return t.replace(/%([^%]+)%/g, function (t, n) {
    const o = n.split('.')
    if (2 !== o.length)
      return o[0].startsWith('date:')
        ? formatDate(o[0].substring(5), new Date())
        : ('width' !== n &&
            'height' !== n &&
            console.warn('Invalid replacement pattern', n),
          t)
    let i = e.graph.nodes.filter(
      (e) => e.properties?.['Node name for S&R'] === o[0]
    )
    if (
      (i.length || (i = e.graph.nodes.filter((e) => e.title === o[0])),
      !i.length)
    )
      return console.warn('Unable to find node', o[0]), t
    i.length > 1 &&
      console.warn('Multiple nodes matched', o[0], 'using first match')
    const r = i[0],
      a = r.widgets?.find((e) => e.name === o[1])
    return a
      ? ((a.value ?? '') + '').replaceAll(/\/|\\/g, '_')
      : (console.warn('Unable to find widget', o[1], 'on node', o[0], r), t)
  })
}
async function addStylesheet(e, t) {
  return new Promise((n, o) => {
    let i
    ;(i = e.endsWith('.js')
      ? e.substr(0, e.length - 2) + 'css'
      : new URL(
          e,
          t ?? `${window.location.protocol}//${window.location.host}`
        ).toString()),
      $el('link', {
        parent: document.head,
        rel: 'stylesheet',
        type: 'text/css',
        href: i,
        onload: n,
        onerror: o
      })
  })
}
function downloadBlob(e, t) {
  const n = URL.createObjectURL(t),
    o = $el('a', {
      href: n,
      download: e,
      style: { display: 'none' },
      parent: document.body
    })
  o.click(),
    setTimeout(function () {
      o.remove(), window.URL.revokeObjectURL(n)
    }, 0)
}
function prop(e, t, n, o) {
  let i
  return (
    Object.defineProperty(e, t, {
      get: () => i,
      set(n) {
        const r = i
        ;(i = n), o?.(i, r, e, t)
      }
    }),
    n
  )
}
function getStorageValue(e) {
  const t = api.clientId ?? api.initialClientId
  return (t && sessionStorage.getItem(`${e}:${t}`)) ?? localStorage.getItem(e)
}
function setStorageValue(e, t) {
  const n = api.clientId ?? api.initialClientId
  n && sessionStorage.setItem(`${e}:${n}`, t), localStorage.setItem(e, t)
}
__name(formatDate, 'formatDate'),
  __name(clone$3, 'clone$3'),
  __name(applyTextReplacements, 'applyTextReplacements'),
  __name(addStylesheet, 'addStylesheet'),
  __name(downloadBlob, 'downloadBlob'),
  __name(prop, 'prop'),
  __name(getStorageValue, 'getStorageValue'),
  __name(setStorageValue, 'setStorageValue'),
  (window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.utils = window.comfyAPI.utils || {}),
  (window.comfyAPI.utils.clone = clone$3),
  (window.comfyAPI.utils.applyTextReplacements = applyTextReplacements),
  (window.comfyAPI.utils.addStylesheet = addStylesheet),
  (window.comfyAPI.utils.downloadBlob = downloadBlob),
  (window.comfyAPI.utils.prop = prop),
  (window.comfyAPI.utils.getStorageValue = getStorageValue),
  (window.comfyAPI.utils.setStorageValue = setStorageValue)
class ComfyButtonGroup {
  static {
    __name(this, 'ComfyButtonGroup')
  }
  element = $el('div.comfyui-button-group')
  buttons
  constructor(...e) {
    this.buttons = prop(this, 'buttons', e, () => this.update())
  }
  insert(e, t) {
    this.buttons.splice(t, 0, e), this.update()
  }
  append(e) {
    this.buttons.push(e), this.update()
  }
  remove(e) {
    if (('number' != typeof e && (e = this.buttons.indexOf(e)), e > -1)) {
      const t = this.buttons.splice(e, 1)
      return this.update(), t
    }
  }
  update() {
    this.element.replaceChildren(...this.buttons.map((e) => e.element ?? e))
  }
}
function applyClasses(e, t, ...n) {
  let o
  ;(t ??= ''),
    (o =
      'string' == typeof t
        ? t
        : t instanceof Array
          ? t.join(' ')
          : Object.entries(t).reduce(
              (e, t) => (t[1] && (e += (e.length ? ' ' : '') + t[0]), e),
              ''
            )),
    (e.className = o),
    n && e.classList.add(...n)
}
function toggleElement(e, { onHide: t, onShow: n } = {}) {
  let o, i
  return (r) => {
    r
      ? (i && ((i = !1), o.replaceWith(e)), n?.(e, r))
      : (o || (o = document.createComment('')),
        (i = !0),
        e.replaceWith(o),
        t?.(e))
  }
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.buttonGroup = window.comfyAPI.buttonGroup || {}),
  (window.comfyAPI.buttonGroup.ComfyButtonGroup = ComfyButtonGroup),
  __name(applyClasses, 'applyClasses'),
  __name(toggleElement, 'toggleElement'),
  (window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.utils = window.comfyAPI.utils || {}),
  (window.comfyAPI.utils.applyClasses = applyClasses),
  (window.comfyAPI.utils.toggleElement = toggleElement)
class ComfyButton {
  static {
    __name(this, 'ComfyButton')
  }
  #ee = 0
  #te = !1
  isOver = !1
  iconElement = $el('i.mdi')
  contentElement = $el('span')
  popup
  element
  overIcon
  iconSize
  content
  icon
  tooltip
  classList
  hidden
  enabled
  action
  constructor({
    icon: e,
    overIcon: t,
    iconSize: n,
    content: o,
    tooltip: i,
    action: r,
    classList: a = 'comfyui-button',
    visibilitySetting: s,
    app: l,
    enabled: c = !0
  }) {
    if (
      ((this.element = $el(
        'button',
        {
          onmouseenter: __name(() => {
            ;(this.isOver = !0), this.overIcon && this.updateIcon()
          }, 'onmouseenter'),
          onmouseleave: __name(() => {
            ;(this.isOver = !1), this.overIcon && this.updateIcon()
          }, 'onmouseleave')
        },
        [this.iconElement, this.contentElement]
      )),
      (this.icon = prop(
        this,
        'icon',
        e,
        toggleElement(this.iconElement, { onShow: this.updateIcon })
      )),
      (this.overIcon = prop(this, 'overIcon', t, () => {
        this.isOver && this.updateIcon()
      })),
      (this.iconSize = prop(this, 'iconSize', n, this.updateIcon)),
      (this.content = prop(
        this,
        'content',
        o,
        toggleElement(this.contentElement, {
          onShow: __name((e, t) => {
            'string' == typeof t ? (e.textContent = t) : e.replaceChildren(t)
          }, 'onShow')
        })
      )),
      (this.tooltip = prop(this, 'tooltip', i, (e) => {
        e ? (this.element.title = e) : this.element.removeAttribute('title')
      })),
      void 0 !== i && this.element.setAttribute('aria-label', i),
      (this.classList = prop(this, 'classList', a, this.updateClasses)),
      (this.hidden = prop(this, 'hidden', !1, this.updateClasses)),
      (this.enabled = prop(this, 'enabled', c, () => {
        this.updateClasses(), (this.element.disabled = !this.enabled)
      })),
      (this.action = prop(this, 'action', r)),
      this.element.addEventListener('click', (e) => {
        this.popup && (this.#ee || this.popup.toggle()), this.action?.(e, this)
      }),
      s?.id)
    ) {
      const e = __name(() => {
        this.hidden = l.ui.settings.getSettingValue(s.id) !== s.showValue
      }, 'settingUpdated')
      l.ui.settings.addEventListener(s.id + '.change', e), e()
    }
  }
  updateIcon = __name(
    () =>
      (this.iconElement.className = `mdi mdi-${(this.isOver && this.overIcon) || this.icon}${this.iconSize ? ' mdi-' + this.iconSize + 'px' : ''}`),
    'updateIcon'
  )
  updateClasses = __name(() => {
    const e = []
    this.hidden && e.push('hidden'),
      this.enabled || e.push('disabled'),
      this.popup && (this.#te ? e.push('popup-open') : e.push('popup-closed')),
      applyClasses(this.element, this.classList, ...e)
  }, 'updateClasses')
  withPopup(e, t = 'click') {
    if (((this.popup = e), 'hover' === t))
      for (const n of [this.element, this.popup.element])
        n.addEventListener('mouseenter', () => {
          this.popup.open = !!++this.#ee
        }),
          n.addEventListener('mouseleave', () => {
            this.popup.open = !!--this.#ee
          })
    return (
      e.addEventListener('change', () => {
        ;(this.#te = e.open), this.updateClasses()
      }),
      this
    )
  }
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.button = window.comfyAPI.button || {}),
  (window.comfyAPI.button.ComfyButton = ComfyButton)
class ComfyPopup extends EventTarget {
  static {
    __name(this, 'ComfyPopup')
  }
  element = $el('div.comfyui-popup')
  open
  children
  target
  ignoreTarget
  container
  position
  closeOnEscape
  horizontal
  classList
  constructor(
    {
      target: e,
      container: t = document.body,
      classList: n = '',
      ignoreTarget: o = !0,
      closeOnEscape: i = !0,
      position: r = 'absolute',
      horizontal: a = 'left'
    },
    ...s
  ) {
    super(),
      (this.target = e),
      (this.ignoreTarget = o),
      (this.container = t),
      (this.position = r),
      (this.closeOnEscape = i),
      (this.horizontal = a),
      t.append(this.element),
      (this.children = prop(this, 'children', s, () => {
        this.element.replaceChildren(...this.children), this.update()
      })),
      (this.classList = prop(this, 'classList', n, () =>
        applyClasses(this.element, this.classList, 'comfyui-popup', a)
      )),
      (this.open = prop(this, 'open', !1, (e, t) => {
        e !== t && (e ? this.#ne() : this.#oe())
      }))
  }
  toggle() {
    this.open = !this.open
  }
  #oe() {
    this.element.classList.remove('open'),
      window.removeEventListener('resize', this.update),
      window.removeEventListener('click', this.#ie, { capture: !0 }),
      window.removeEventListener('keydown', this.#re, { capture: !0 }),
      this.dispatchEvent(new CustomEvent('close')),
      this.dispatchEvent(new CustomEvent('change'))
  }
  #ne() {
    this.element.classList.add('open'),
      this.update(),
      window.addEventListener('resize', this.update),
      window.addEventListener('click', this.#ie, { capture: !0 }),
      this.closeOnEscape &&
        window.addEventListener('keydown', this.#re, { capture: !0 }),
      this.dispatchEvent(new CustomEvent('open')),
      this.dispatchEvent(new CustomEvent('change'))
  }
  #re = __name((e) => {
    'Escape' === e.key &&
      ((this.open = !1), e.preventDefault(), e.stopImmediatePropagation())
  }, '#escHandler')
  #ie = __name((e) => {
    const t = e.target
    this.element.contains(t) ||
      !this.ignoreTarget ||
      this.target.contains(t) ||
      (this.open = !1)
  }, '#clickHandler')
  update = __name(() => {
    const e = this.target.getBoundingClientRect()
    this.element.style.setProperty('--bottom', 'unset'),
      'absolute' === this.position
        ? ('left' === this.horizontal
            ? this.element.style.setProperty('--left', e.left + 'px')
            : this.element.style.setProperty(
                '--left',
                e.right - this.element.clientWidth + 'px'
              ),
          this.element.style.setProperty('--top', e.bottom + 'px'),
          this.element.style.setProperty('--limit', e.bottom + 'px'))
        : (this.element.style.setProperty('--left', '0px'),
          this.element.style.setProperty('--top', e.height + 'px'),
          this.element.style.setProperty('--limit', e.height + 'px'))
    this.element.getBoundingClientRect().height < 30 &&
      (this.element.style.setProperty('--top', 'unset'),
      this.element.style.setProperty('--bottom', e.height + 5 + 'px'),
      this.element.style.setProperty('--limit', e.height + 5 + 'px'))
  }, 'update')
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.popup = window.comfyAPI.popup || {}),
  (window.comfyAPI.popup.ComfyPopup = ComfyPopup)
class ComfySplitButton {
  static {
    __name(this, 'ComfySplitButton')
  }
  arrow
  element
  popup
  items
  constructor(
    { primary: e, mode: t, horizontal: n = 'left', position: o = 'relative' },
    ...i
  ) {
    ;(this.arrow = new ComfyButton({ icon: 'chevron-down' })),
      (this.element = $el(
        'div.comfyui-split-button' + ('hover' === t ? '.hover' : ''),
        [
          $el(
            'div.comfyui-split-primary',
            { ariaLabel: 'Queue current workflow' },
            e.element
          ),
          $el(
            'div.comfyui-split-arrow',
            { ariaLabel: 'Open extra opens', ariaHasPopup: 'true' },
            this.arrow.element
          )
        ]
      )),
      (this.popup = new ComfyPopup({
        target: this.element,
        container: 'relative' === o ? this.element : document.body,
        classList:
          'comfyui-split-button-popup' + ('hover' === t ? ' hover' : ''),
        closeOnEscape: 'click' === t,
        position: o,
        horizontal: n
      })),
      this.arrow.withPopup(this.popup, t),
      (this.items = prop(this, 'items', i, () => this.update()))
  }
  update() {
    this.popup.element.replaceChildren(
      ...this.items.map((e) => ('element' in e ? e.element : e))
    )
  }
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.splitButton = window.comfyAPI.splitButton || {}),
  (window.comfyAPI.splitButton.ComfySplitButton = ComfySplitButton)
class ComfyAsyncDialog extends ComfyDialog$1 {
  static {
    __name(this, 'ComfyAsyncDialog')
  }
  #ae
  constructor(e) {
    super(
      'dialog.comfy-dialog.comfyui-dialog',
      e?.map(
        (e) => (
          'string' == typeof e && (e = { text: e }),
          $el('button.comfyui-button', {
            type: 'button',
            textContent: e.text,
            onclick: __name(() => this.close(e.value ?? e.text), 'onclick')
          })
        )
      )
    )
  }
  show(e) {
    return (
      this.element.addEventListener('close', () => {
        this.close()
      }),
      super.show(e),
      new Promise((e) => {
        this.#ae = e
      })
    )
  }
  showModal(e) {
    return (
      this.element.addEventListener('close', () => {
        this.close()
      }),
      super.show(e),
      this.element.showModal(),
      new Promise((e) => {
        this.#ae = e
      })
    )
  }
  close(e = null) {
    this.#ae(e), this.element.close(), super.close()
  }
  static async prompt({ title: e = null, message: t, actions: n }) {
    const o = new ComfyAsyncDialog(n),
      i = [$el('span', t)]
    e && i.unshift($el('h3', e))
    const r = await o.showModal(i)
    return o.element.remove(), r
  }
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.asyncDialog = window.comfyAPI.asyncDialog || {}),
  (window.comfyAPI.asyncDialog.ComfyAsyncDialog = ComfyAsyncDialog),
  $el('style', {
    parent: document.head,
    textContent:
      '\n        .draggable-item {\n            position: relative;\n            will-change: transform;\n            user-select: none;\n        }\n        .draggable-item.is-idle {\n            transition: 0.25s ease transform;\n        }\n        .draggable-item.is-draggable {\n            z-index: 10;\n        }\n    '
  })
class DraggableList extends EventTarget {
  static {
    __name(this, 'DraggableList')
  }
  listContainer
  draggableItem
  pointerStartX
  pointerStartY
  scrollYMax
  itemsGap = 0
  items = []
  itemSelector
  handleClass = 'drag-handle'
  off = []
  offDrag = []
  constructor(e, t) {
    super(),
      (this.listContainer = e),
      (this.itemSelector = t),
      this.listContainer &&
        (this.off.push(
          this.on(this.listContainer, 'mousedown', this.dragStart)
        ),
        this.off.push(
          this.on(this.listContainer, 'touchstart', this.dragStart)
        ),
        this.off.push(this.on(document, 'mouseup', this.dragEnd)),
        this.off.push(this.on(document, 'touchend', this.dragEnd)))
  }
  getAllItems() {
    return (
      this.items?.length ||
        ((this.items = Array.from(
          this.listContainer.querySelectorAll(this.itemSelector)
        )),
        this.items.forEach((e) => {
          e.classList.add('is-idle')
        })),
      this.items
    )
  }
  getIdleItems() {
    return this.getAllItems().filter((e) => e.classList.contains('is-idle'))
  }
  isItemAbove(e) {
    return e.hasAttribute('data-is-above')
  }
  isItemToggled(e) {
    return e.hasAttribute('data-is-toggled')
  }
  on(e, t, n, o) {
    return (
      (n = n.bind(this)),
      e.addEventListener(t, n, o),
      () => e.removeEventListener(t, n)
    )
  }
  dragStart(e) {
    e.target.classList.contains(this.handleClass) &&
      (this.draggableItem = e.target.closest(this.itemSelector)),
      this.draggableItem &&
        ((this.pointerStartX = e.clientX || e.touches[0].clientX),
        (this.pointerStartY = e.clientY || e.touches[0].clientY),
        (this.scrollYMax =
          this.listContainer.scrollHeight - this.listContainer.clientHeight),
        this.setItemsGap(),
        this.initDraggableItem(),
        this.initItemsState(),
        this.offDrag.push(this.on(document, 'mousemove', this.drag)),
        this.offDrag.push(
          this.on(document, 'touchmove', this.drag, { passive: !1 })
        ),
        this.dispatchEvent(
          new CustomEvent('dragstart', {
            detail: {
              element: this.draggableItem,
              position: this.getAllItems().indexOf(this.draggableItem)
            }
          })
        ))
  }
  setItemsGap() {
    if (this.getIdleItems().length <= 1) return void (this.itemsGap = 0)
    const e = this.getIdleItems()[0],
      t = this.getIdleItems()[1],
      n = e.getBoundingClientRect(),
      o = t.getBoundingClientRect()
    this.itemsGap = Math.abs(n.bottom - o.top)
  }
  initItemsState() {
    this.getIdleItems().forEach((e, t) => {
      this.getAllItems().indexOf(this.draggableItem) > t &&
        (e.dataset.isAbove = '')
    })
  }
  initDraggableItem() {
    this.draggableItem.classList.remove('is-idle'),
      this.draggableItem.classList.add('is-draggable')
  }
  drag(e) {
    if (!this.draggableItem) return
    e.preventDefault()
    const t = e.clientX || e.touches[0].clientX,
      n = e.clientY || e.touches[0].clientY,
      o = this.listContainer.getBoundingClientRect()
    n > o.bottom
      ? this.listContainer.scrollTop < this.scrollYMax &&
        (this.listContainer.scrollBy(0, 10), (this.pointerStartY -= 10))
      : n < o.top &&
        this.listContainer.scrollTop > 0 &&
        ((this.pointerStartY += 10), this.listContainer.scrollBy(0, -10))
    const i = t - this.pointerStartX,
      r = n - this.pointerStartY
    this.updateIdleItemsStateAndPosition(),
      (this.draggableItem.style.transform = `translate(${i}px, ${r}px)`)
  }
  updateIdleItemsStateAndPosition() {
    const e = this.draggableItem.getBoundingClientRect(),
      t = e.top + e.height / 2
    this.getIdleItems().forEach((e) => {
      const n = e.getBoundingClientRect(),
        o = n.top + n.height / 2
      this.isItemAbove(e)
        ? t <= o
          ? (e.dataset.isToggled = '')
          : delete e.dataset.isToggled
        : t >= o
          ? (e.dataset.isToggled = '')
          : delete e.dataset.isToggled
    }),
      this.getIdleItems().forEach((t) => {
        if (this.isItemToggled(t)) {
          const n = this.isItemAbove(t) ? 1 : -1
          t.style.transform = `translateY(${n * (e.height + this.itemsGap)}px)`
        } else t.style.transform = ''
      })
  }
  dragEnd() {
    this.draggableItem && (this.applyNewItemsOrder(), this.cleanup())
  }
  applyNewItemsOrder() {
    const e = []
    let t = -1
    this.getAllItems().forEach((n, o) => {
      if (n === this.draggableItem) return void (t = o)
      if (!this.isItemToggled(n)) return void (e[o] = n)
      const i = this.isItemAbove(n) ? o + 1 : o - 1
      e[i] = n
    })
    for (let n = 0; n < this.getAllItems().length; n++) {
      void 0 === e[n] && (e[n] = this.draggableItem)
    }
    e.forEach((e) => {
      this.listContainer.appendChild(e)
    }),
      (this.items = e),
      this.dispatchEvent(
        new CustomEvent('dragend', {
          detail: {
            element: this.draggableItem,
            oldPosition: t,
            newPosition: e.indexOf(this.draggableItem)
          }
        })
      )
  }
  cleanup() {
    ;(this.itemsGap = 0),
      (this.items = []),
      this.unsetDraggableItem(),
      this.unsetItemState(),
      this.offDrag.forEach((e) => e()),
      (this.offDrag = [])
  }
  unsetDraggableItem() {
    ;(this.draggableItem.style = null),
      this.draggableItem.classList.remove('is-draggable'),
      this.draggableItem.classList.add('is-idle'),
      (this.draggableItem = null)
  }
  unsetItemState() {
    this.getIdleItems().forEach((e, t) => {
      delete e.dataset.isAbove,
        delete e.dataset.isToggled,
        (e.style.transform = '')
    })
  }
  dispose() {
    this.off.forEach((e) => e())
  }
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.draggableList = window.comfyAPI.draggableList || {}),
  (window.comfyAPI.draggableList.DraggableList = DraggableList)
class ComfyAppMenu {
  static {
    __name(this, 'ComfyAppMenu')
  }
  app
  actionsGroup
  settingsGroup
  viewGroup
  element
  constructor(e) {
    ;(this.app = e),
      (this.actionsGroup = new ComfyButtonGroup()),
      (this.settingsGroup = new ComfyButtonGroup()),
      (this.viewGroup = new ComfyButtonGroup()),
      (this.element = $el('div.flex.gap-2.mx-2', [
        this.actionsGroup.element,
        this.settingsGroup.element,
        this.viewGroup.element
      ]))
  }
}
function isArray(e) {
  return Array.isArray ? Array.isArray(e) : '[object Array]' === getTag(e)
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.index = window.comfyAPI.index || {}),
  (window.comfyAPI.index.ComfyAppMenu = ComfyAppMenu),
  __name(isArray, 'isArray')
const INFINITY = 1 / 0
function baseToString(e) {
  if ('string' == typeof e) return e
  let t = e + ''
  return '0' == t && 1 / e == -INFINITY ? '-0' : t
}
function toString(e) {
  return null == e ? '' : baseToString(e)
}
function isString(e) {
  return 'string' == typeof e
}
function isNumber(e) {
  return 'number' == typeof e
}
function isBoolean(e) {
  return (
    !0 === e || !1 === e || (isObjectLike(e) && '[object Boolean]' == getTag(e))
  )
}
function isObject(e) {
  return 'object' == typeof e
}
function isObjectLike(e) {
  return isObject(e) && null !== e
}
function isDefined(e) {
  return null != e
}
function isBlank(e) {
  return !e.trim().length
}
function getTag(e) {
  return null == e
    ? void 0 === e
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(e)
}
__name(baseToString, 'baseToString'),
  __name(toString, 'toString'),
  __name(isString, 'isString'),
  __name(isNumber, 'isNumber'),
  __name(isBoolean, 'isBoolean'),
  __name(isObject, 'isObject'),
  __name(isObjectLike, 'isObjectLike'),
  __name(isDefined, 'isDefined'),
  __name(isBlank, 'isBlank'),
  __name(getTag, 'getTag')
const EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available',
  INCORRECT_INDEX_TYPE = "Incorrect 'index' type",
  LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = __name(
    (e) => `Invalid value for key ${e}`,
    'LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY'
  ),
  PATTERN_LENGTH_TOO_LARGE = __name(
    (e) => `Pattern length exceeds max of ${e}.`,
    'PATTERN_LENGTH_TOO_LARGE'
  ),
  MISSING_KEY_PROPERTY = __name(
    (e) => `Missing ${e} property in key`,
    'MISSING_KEY_PROPERTY'
  ),
  INVALID_KEY_WEIGHT_VALUE = __name(
    (e) => `Property 'weight' in key '${e}' must be a positive integer`,
    'INVALID_KEY_WEIGHT_VALUE'
  ),
  hasOwn = Object.prototype.hasOwnProperty
class KeyStore {
  static {
    __name(this, 'KeyStore')
  }
  constructor(e) {
    ;(this._keys = []), (this._keyMap = {})
    let t = 0
    e.forEach((e) => {
      let n = createKey(e)
      this._keys.push(n), (this._keyMap[n.id] = n), (t += n.weight)
    }),
      this._keys.forEach((e) => {
        e.weight /= t
      })
  }
  get(e) {
    return this._keyMap[e]
  }
  keys() {
    return this._keys
  }
  toJSON() {
    return JSON.stringify(this._keys)
  }
}
function createKey(e) {
  let t = null,
    n = null,
    o = null,
    i = 1,
    r = null
  if (isString(e) || isArray(e))
    (o = e), (t = createKeyPath(e)), (n = createKeyId(e))
  else {
    if (!hasOwn.call(e, 'name')) throw new Error(MISSING_KEY_PROPERTY('name'))
    const a = e.name
    if (((o = a), hasOwn.call(e, 'weight') && ((i = e.weight), i <= 0)))
      throw new Error(INVALID_KEY_WEIGHT_VALUE(a))
    ;(t = createKeyPath(a)), (n = createKeyId(a)), (r = e.getFn)
  }
  return { path: t, id: n, weight: i, src: o, getFn: r }
}
function createKeyPath(e) {
  return isArray(e) ? e : e.split('.')
}
function createKeyId(e) {
  return isArray(e) ? e.join('.') : e
}
function get$1(e, t) {
  let n = [],
    o = !1
  const i = __name((e, t, r) => {
    if (isDefined(e))
      if (t[r]) {
        const a = e[t[r]]
        if (!isDefined(a)) return
        if (r === t.length - 1 && (isString(a) || isNumber(a) || isBoolean(a)))
          n.push(toString(a))
        else if (isArray(a)) {
          o = !0
          for (let e = 0, n = a.length; e < n; e += 1) i(a[e], t, r + 1)
        } else t.length && i(a, t, r + 1)
      } else n.push(e)
  }, 'deepGet')
  return i(e, isString(t) ? t.split('.') : t, 0), o ? n : n[0]
}
__name(createKey, 'createKey'),
  __name(createKeyPath, 'createKeyPath'),
  __name(createKeyId, 'createKeyId'),
  __name(get$1, 'get$1')
const MatchOptions = {
    includeMatches: !1,
    findAllMatches: !1,
    minMatchCharLength: 1
  },
  BasicOptions = {
    isCaseSensitive: !1,
    includeScore: !1,
    keys: [],
    shouldSort: !0,
    sortFn: __name(
      (e, t) =>
        e.score === t.score
          ? e.idx < t.idx
            ? -1
            : 1
          : e.score < t.score
            ? -1
            : 1,
      'sortFn'
    )
  },
  FuzzyOptions = { location: 0, threshold: 0.6, distance: 100 },
  AdvancedOptions = {
    useExtendedSearch: !1,
    getFn: get$1,
    ignoreLocation: !1,
    ignoreFieldNorm: !1,
    fieldNormWeight: 1
  }
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
}
const SPACE = /[^ ]+/g
function norm(e = 1, t = 3) {
  const n = new Map(),
    o = Math.pow(10, t)
  return {
    get(t) {
      const i = t.match(SPACE).length
      if (n.has(i)) return n.get(i)
      const r = 1 / Math.pow(i, 0.5 * e),
        a = parseFloat(Math.round(r * o) / o)
      return n.set(i, a), a
    },
    clear() {
      n.clear()
    }
  }
}
__name(norm, 'norm')
class FuseIndex {
  static {
    __name(this, 'FuseIndex')
  }
  constructor({
    getFn: e = Config.getFn,
    fieldNormWeight: t = Config.fieldNormWeight
  } = {}) {
    ;(this.norm = norm(t, 3)),
      (this.getFn = e),
      (this.isCreated = !1),
      this.setIndexRecords()
  }
  setSources(e = []) {
    this.docs = e
  }
  setIndexRecords(e = []) {
    this.records = e
  }
  setKeys(e = []) {
    ;(this.keys = e),
      (this._keysMap = {}),
      e.forEach((e, t) => {
        this._keysMap[e.id] = t
      })
  }
  create() {
    !this.isCreated &&
      this.docs.length &&
      ((this.isCreated = !0),
      isString(this.docs[0])
        ? this.docs.forEach((e, t) => {
            this._addString(e, t)
          })
        : this.docs.forEach((e, t) => {
            this._addObject(e, t)
          }),
      this.norm.clear())
  }
  add(e) {
    const t = this.size()
    isString(e) ? this._addString(e, t) : this._addObject(e, t)
  }
  removeAt(e) {
    this.records.splice(e, 1)
    for (let t = e, n = this.size(); t < n; t += 1) this.records[t].i -= 1
  }
  getValueForItemAtKeyId(e, t) {
    return e[this._keysMap[t]]
  }
  size() {
    return this.records.length
  }
  _addString(e, t) {
    if (!isDefined(e) || isBlank(e)) return
    let n = { v: e, i: t, n: this.norm.get(e) }
    this.records.push(n)
  }
  _addObject(e, t) {
    let n = { i: t, $: {} }
    this.keys.forEach((t, o) => {
      let i = t.getFn ? t.getFn(e) : this.getFn(e, t.path)
      if (isDefined(i))
        if (isArray(i)) {
          let e = []
          const t = [{ nestedArrIndex: -1, value: i }]
          for (; t.length; ) {
            const { nestedArrIndex: n, value: o } = t.pop()
            if (isDefined(o))
              if (isString(o) && !isBlank(o)) {
                let t = { v: o, i: n, n: this.norm.get(o) }
                e.push(t)
              } else
                isArray(o) &&
                  o.forEach((e, n) => {
                    t.push({ nestedArrIndex: n, value: e })
                  })
          }
          n.$[o] = e
        } else if (isString(i) && !isBlank(i)) {
          let e = { v: i, n: this.norm.get(i) }
          n.$[o] = e
        }
    }),
      this.records.push(n)
  }
  toJSON() {
    return { keys: this.keys, records: this.records }
  }
}
function createIndex(
  e,
  t,
  { getFn: n = Config.getFn, fieldNormWeight: o = Config.fieldNormWeight } = {}
) {
  const i = new FuseIndex({ getFn: n, fieldNormWeight: o })
  return i.setKeys(e.map(createKey)), i.setSources(t), i.create(), i
}
function parseIndex(
  e,
  { getFn: t = Config.getFn, fieldNormWeight: n = Config.fieldNormWeight } = {}
) {
  const { keys: o, records: i } = e,
    r = new FuseIndex({ getFn: t, fieldNormWeight: n })
  return r.setKeys(o), r.setIndexRecords(i), r
}
function computeScore$1(
  e,
  {
    errors: t = 0,
    currentLocation: n = 0,
    expectedLocation: o = 0,
    distance: i = Config.distance,
    ignoreLocation: r = Config.ignoreLocation
  } = {}
) {
  const a = t / e.length
  if (r) return a
  const s = Math.abs(o - n)
  return i ? a + s / i : s ? 1 : a
}
function convertMaskToIndices(e = [], t = Config.minMatchCharLength) {
  let n = [],
    o = -1,
    i = -1,
    r = 0
  for (let a = e.length; r < a; r += 1) {
    let a = e[r]
    a && -1 === o
      ? (o = r)
      : a ||
        -1 === o ||
        ((i = r - 1), i - o + 1 >= t && n.push([o, i]), (o = -1))
  }
  return e[r - 1] && r - o >= t && n.push([o, r - 1]), n
}
__name(createIndex, 'createIndex'),
  __name(parseIndex, 'parseIndex'),
  __name(computeScore$1, 'computeScore$1'),
  __name(convertMaskToIndices, 'convertMaskToIndices')
const MAX_BITS = 32
function search(
  e,
  t,
  n,
  {
    location: o = Config.location,
    distance: i = Config.distance,
    threshold: r = Config.threshold,
    findAllMatches: a = Config.findAllMatches,
    minMatchCharLength: s = Config.minMatchCharLength,
    includeMatches: l = Config.includeMatches,
    ignoreLocation: c = Config.ignoreLocation
  } = {}
) {
  if (t.length > MAX_BITS) throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))
  const d = t.length,
    u = e.length,
    p = Math.max(0, Math.min(o, u))
  let h = r,
    m = p
  const f = s > 1 || l,
    _ = f ? Array(u) : []
  let g
  for (; (g = e.indexOf(t, m)) > -1; ) {
    let e = computeScore$1(t, {
      currentLocation: g,
      expectedLocation: p,
      distance: i,
      ignoreLocation: c
    })
    if (((h = Math.min(e, h)), (m = g + d), f)) {
      let e = 0
      for (; e < d; ) (_[g + e] = 1), (e += 1)
    }
  }
  m = -1
  let v = [],
    y = 1,
    b = d + u
  const S = 1 << (d - 1)
  for (let w = 0; w < d; w += 1) {
    let o = 0,
      r = b
    for (; o < r; ) {
      computeScore$1(t, {
        errors: w,
        currentLocation: p + r,
        expectedLocation: p,
        distance: i,
        ignoreLocation: c
      }) <= h
        ? (o = r)
        : (b = r),
        (r = Math.floor((b - o) / 2 + o))
    }
    b = r
    let s = Math.max(1, p - r + 1),
      l = a ? u : Math.min(p + r, u) + d,
      g = Array(l + 2)
    g[l + 1] = (1 << w) - 1
    for (let a = l; a >= s; a -= 1) {
      let o = a - 1,
        r = n[e.charAt(o)]
      if (
        (f && (_[o] = +!!r),
        (g[a] = ((g[a + 1] << 1) | 1) & r),
        w && (g[a] |= ((v[a + 1] | v[a]) << 1) | 1 | v[a + 1]),
        g[a] & S &&
          ((y = computeScore$1(t, {
            errors: w,
            currentLocation: o,
            expectedLocation: p,
            distance: i,
            ignoreLocation: c
          })),
          y <= h))
      ) {
        if (((h = y), (m = o), m <= p)) break
        s = Math.max(1, 2 * p - m)
      }
    }
    if (
      computeScore$1(t, {
        errors: w + 1,
        currentLocation: p,
        expectedLocation: p,
        distance: i,
        ignoreLocation: c
      }) > h
    )
      break
    v = g
  }
  const C = { isMatch: m >= 0, score: Math.max(0.001, y) }
  if (f) {
    const e = convertMaskToIndices(_, s)
    e.length ? l && (C.indices = e) : (C.isMatch = !1)
  }
  return C
}
function createPatternAlphabet(e) {
  let t = {}
  for (let n = 0, o = e.length; n < o; n += 1) {
    const i = e.charAt(n)
    t[i] = (t[i] || 0) | (1 << (o - n - 1))
  }
  return t
}
__name(search, 'search'), __name(createPatternAlphabet, 'createPatternAlphabet')
class BitapSearch {
  static {
    __name(this, 'BitapSearch')
  }
  constructor(
    e,
    {
      location: t = Config.location,
      threshold: n = Config.threshold,
      distance: o = Config.distance,
      includeMatches: i = Config.includeMatches,
      findAllMatches: r = Config.findAllMatches,
      minMatchCharLength: a = Config.minMatchCharLength,
      isCaseSensitive: s = Config.isCaseSensitive,
      ignoreLocation: l = Config.ignoreLocation
    } = {}
  ) {
    if (
      ((this.options = {
        location: t,
        threshold: n,
        distance: o,
        includeMatches: i,
        findAllMatches: r,
        minMatchCharLength: a,
        isCaseSensitive: s,
        ignoreLocation: l
      }),
      (this.pattern = s ? e : e.toLowerCase()),
      (this.chunks = []),
      !this.pattern.length)
    )
      return
    const c = __name((e, t) => {
        this.chunks.push({
          pattern: e,
          alphabet: createPatternAlphabet(e),
          startIndex: t
        })
      }, 'addChunk'),
      d = this.pattern.length
    if (d > MAX_BITS) {
      let e = 0
      const t = d % MAX_BITS,
        n = d - t
      for (; e < n; ) c(this.pattern.substr(e, MAX_BITS), e), (e += MAX_BITS)
      if (t) {
        const e = d - MAX_BITS
        c(this.pattern.substr(e), e)
      }
    } else c(this.pattern, 0)
  }
  searchIn(e) {
    const { isCaseSensitive: t, includeMatches: n } = this.options
    if ((t || (e = e.toLowerCase()), this.pattern === e)) {
      let t = { isMatch: !0, score: 0 }
      return n && (t.indices = [[0, e.length - 1]]), t
    }
    const {
      location: o,
      distance: i,
      threshold: r,
      findAllMatches: a,
      minMatchCharLength: s,
      ignoreLocation: l
    } = this.options
    let c = [],
      d = 0,
      u = !1
    this.chunks.forEach(({ pattern: t, alphabet: p, startIndex: h }) => {
      const {
        isMatch: m,
        score: f,
        indices: _
      } = search(e, t, p, {
        location: o + h,
        distance: i,
        threshold: r,
        findAllMatches: a,
        minMatchCharLength: s,
        includeMatches: n,
        ignoreLocation: l
      })
      m && (u = !0), (d += f), m && _ && (c = [...c, ..._])
    })
    let p = { isMatch: u, score: u ? d / this.chunks.length : 1 }
    return u && n && (p.indices = c), p
  }
}
class BaseMatch {
  static {
    __name(this, 'BaseMatch')
  }
  constructor(e) {
    this.pattern = e
  }
  static isMultiMatch(e) {
    return getMatch(e, this.multiRegex)
  }
  static isSingleMatch(e) {
    return getMatch(e, this.singleRegex)
  }
  search() {}
}
function getMatch(e, t) {
  const n = e.match(t)
  return n ? n[1] : null
}
__name(getMatch, 'getMatch')
class ExactMatch extends BaseMatch {
  static {
    __name(this, 'ExactMatch')
  }
  constructor(e) {
    super(e)
  }
  static get type() {
    return 'exact'
  }
  static get multiRegex() {
    return /^="(.*)"$/
  }
  static get singleRegex() {
    return /^=(.*)$/
  }
  search(e) {
    const t = e === this.pattern
    return {
      isMatch: t,
      score: t ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    }
  }
}
class InverseExactMatch extends BaseMatch {
  static {
    __name(this, 'InverseExactMatch')
  }
  constructor(e) {
    super(e)
  }
  static get type() {
    return 'inverse-exact'
  }
  static get multiRegex() {
    return /^!"(.*)"$/
  }
  static get singleRegex() {
    return /^!(.*)$/
  }
  search(e) {
    const t = -1 === e.indexOf(this.pattern)
    return { isMatch: t, score: t ? 0 : 1, indices: [0, e.length - 1] }
  }
}
class PrefixExactMatch extends BaseMatch {
  static {
    __name(this, 'PrefixExactMatch')
  }
  constructor(e) {
    super(e)
  }
  static get type() {
    return 'prefix-exact'
  }
  static get multiRegex() {
    return /^\^"(.*)"$/
  }
  static get singleRegex() {
    return /^\^(.*)$/
  }
  search(e) {
    const t = e.startsWith(this.pattern)
    return {
      isMatch: t,
      score: t ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    }
  }
}
class InversePrefixExactMatch extends BaseMatch {
  static {
    __name(this, 'InversePrefixExactMatch')
  }
  constructor(e) {
    super(e)
  }
  static get type() {
    return 'inverse-prefix-exact'
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/
  }
  static get singleRegex() {
    return /^!\^(.*)$/
  }
  search(e) {
    const t = !e.startsWith(this.pattern)
    return { isMatch: t, score: t ? 0 : 1, indices: [0, e.length - 1] }
  }
}
class SuffixExactMatch extends BaseMatch {
  static {
    __name(this, 'SuffixExactMatch')
  }
  constructor(e) {
    super(e)
  }
  static get type() {
    return 'suffix-exact'
  }
  static get multiRegex() {
    return /^"(.*)"\$$/
  }
  static get singleRegex() {
    return /^(.*)\$$/
  }
  search(e) {
    const t = e.endsWith(this.pattern)
    return {
      isMatch: t,
      score: t ? 0 : 1,
      indices: [e.length - this.pattern.length, e.length - 1]
    }
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  static {
    __name(this, 'InverseSuffixExactMatch')
  }
  constructor(e) {
    super(e)
  }
  static get type() {
    return 'inverse-suffix-exact'
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/
  }
  static get singleRegex() {
    return /^!(.*)\$$/
  }
  search(e) {
    const t = !e.endsWith(this.pattern)
    return { isMatch: t, score: t ? 0 : 1, indices: [0, e.length - 1] }
  }
}
class FuzzyMatch extends BaseMatch {
  static {
    __name(this, 'FuzzyMatch')
  }
  constructor(
    e,
    {
      location: t = Config.location,
      threshold: n = Config.threshold,
      distance: o = Config.distance,
      includeMatches: i = Config.includeMatches,
      findAllMatches: r = Config.findAllMatches,
      minMatchCharLength: a = Config.minMatchCharLength,
      isCaseSensitive: s = Config.isCaseSensitive,
      ignoreLocation: l = Config.ignoreLocation
    } = {}
  ) {
    super(e),
      (this._bitapSearch = new BitapSearch(e, {
        location: t,
        threshold: n,
        distance: o,
        includeMatches: i,
        findAllMatches: r,
        minMatchCharLength: a,
        isCaseSensitive: s,
        ignoreLocation: l
      }))
  }
  static get type() {
    return 'fuzzy'
  }
  static get multiRegex() {
    return /^"(.*)"$/
  }
  static get singleRegex() {
    return /^(.*)$/
  }
  search(e) {
    return this._bitapSearch.searchIn(e)
  }
}
class IncludeMatch extends BaseMatch {
  static {
    __name(this, 'IncludeMatch')
  }
  constructor(e) {
    super(e)
  }
  static get type() {
    return 'include'
  }
  static get multiRegex() {
    return /^'"(.*)"$/
  }
  static get singleRegex() {
    return /^'(.*)$/
  }
  search(e) {
    let t,
      n = 0
    const o = [],
      i = this.pattern.length
    for (; (t = e.indexOf(this.pattern, n)) > -1; )
      (n = t + i), o.push([t, n - 1])
    const r = !!o.length
    return { isMatch: r, score: r ? 0 : 1, indices: o }
  }
}
const searchers = [
    ExactMatch,
    IncludeMatch,
    PrefixExactMatch,
    InversePrefixExactMatch,
    InverseSuffixExactMatch,
    SuffixExactMatch,
    InverseExactMatch,
    FuzzyMatch
  ],
  searchersLen = searchers.length,
  SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,
  OR_TOKEN = '|'
function parseQuery(e, t = {}) {
  return e.split(OR_TOKEN).map((e) => {
    let n = e
        .trim()
        .split(SPACE_RE)
        .filter((e) => e && !!e.trim()),
      o = []
    for (let i = 0, r = n.length; i < r; i += 1) {
      const e = n[i]
      let r = !1,
        a = -1
      for (; !r && ++a < searchersLen; ) {
        const n = searchers[a]
        let i = n.isMultiMatch(e)
        i && (o.push(new n(i, t)), (r = !0))
      }
      if (!r)
        for (a = -1; ++a < searchersLen; ) {
          const n = searchers[a]
          let i = n.isSingleMatch(e)
          if (i) {
            o.push(new n(i, t))
            break
          }
        }
    }
    return o
  })
}
__name(parseQuery, 'parseQuery')
const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type])
class ExtendedSearch {
  static {
    __name(this, 'ExtendedSearch')
  }
  constructor(
    e,
    {
      isCaseSensitive: t = Config.isCaseSensitive,
      includeMatches: n = Config.includeMatches,
      minMatchCharLength: o = Config.minMatchCharLength,
      ignoreLocation: i = Config.ignoreLocation,
      findAllMatches: r = Config.findAllMatches,
      location: a = Config.location,
      threshold: s = Config.threshold,
      distance: l = Config.distance
    } = {}
  ) {
    ;(this.query = null),
      (this.options = {
        isCaseSensitive: t,
        includeMatches: n,
        minMatchCharLength: o,
        findAllMatches: r,
        ignoreLocation: i,
        location: a,
        threshold: s,
        distance: l
      }),
      (this.pattern = t ? e : e.toLowerCase()),
      (this.query = parseQuery(this.pattern, this.options))
  }
  static condition(e, t) {
    return t.useExtendedSearch
  }
  searchIn(e) {
    const t = this.query
    if (!t) return { isMatch: !1, score: 1 }
    const { includeMatches: n, isCaseSensitive: o } = this.options
    e = o ? e : e.toLowerCase()
    let i = 0,
      r = [],
      a = 0
    for (let s = 0, l = t.length; s < l; s += 1) {
      const o = t[s]
      ;(r.length = 0), (i = 0)
      for (let t = 0, s = o.length; t < s; t += 1) {
        const s = o[t],
          { isMatch: l, indices: c, score: d } = s.search(e)
        if (!l) {
          ;(a = 0), (i = 0), (r.length = 0)
          break
        }
        if (((i += 1), (a += d), n)) {
          const e = s.constructor.type
          MultiMatchSet.has(e) ? (r = [...r, ...c]) : r.push(c)
        }
      }
      if (i) {
        let e = { isMatch: !0, score: a / i }
        return n && (e.indices = r), e
      }
    }
    return { isMatch: !1, score: 1 }
  }
}
const registeredSearchers = []
function register$1(...e) {
  registeredSearchers.push(...e)
}
function createSearcher(e, t) {
  for (let n = 0, o = registeredSearchers.length; n < o; n += 1) {
    let o = registeredSearchers[n]
    if (o.condition(e, t)) return new o(e, t)
  }
  return new BitapSearch(e, t)
}
__name(register$1, 'register$1'), __name(createSearcher, 'createSearcher')
const LogicalOperator = { AND: '$and', OR: '$or' },
  KeyType = { PATH: '$path', PATTERN: '$val' },
  isExpression = __name(
    (e) => !(!e[LogicalOperator.AND] && !e[LogicalOperator.OR]),
    'isExpression'
  ),
  isPath = __name((e) => !!e[KeyType.PATH], 'isPath'),
  isLeaf = __name(
    (e) => !isArray(e) && isObject(e) && !isExpression(e),
    'isLeaf'
  ),
  convertToExplicit = __name(
    (e) => ({
      [LogicalOperator.AND]: Object.keys(e).map((t) => ({ [t]: e[t] }))
    }),
    'convertToExplicit'
  )
function parse(e, t, { auto: n = !0 } = {}) {
  const o = __name((e) => {
    let i = Object.keys(e)
    const r = isPath(e)
    if (!r && i.length > 1 && !isExpression(e)) return o(convertToExplicit(e))
    if (isLeaf(e)) {
      const o = r ? e[KeyType.PATH] : i[0],
        a = r ? e[KeyType.PATTERN] : e[o]
      if (!isString(a)) throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(o))
      const s = { keyId: createKeyId(o), pattern: a }
      return n && (s.searcher = createSearcher(a, t)), s
    }
    let a = { children: [], operator: i[0] }
    return (
      i.forEach((t) => {
        const n = e[t]
        isArray(n) &&
          n.forEach((e) => {
            a.children.push(o(e))
          })
      }),
      a
    )
  }, 'next')
  return isExpression(e) || (e = convertToExplicit(e)), o(e)
}
function computeScore(e, { ignoreFieldNorm: t = Config.ignoreFieldNorm }) {
  e.forEach((e) => {
    let n = 1
    e.matches.forEach(({ key: e, norm: o, score: i }) => {
      const r = e ? e.weight : null
      n *= Math.pow(0 === i && r ? Number.EPSILON : i, (r || 1) * (t ? 1 : o))
    }),
      (e.score = n)
  })
}
function transformMatches(e, t) {
  const n = e.matches
  ;(t.matches = []),
    isDefined(n) &&
      n.forEach((e) => {
        if (!isDefined(e.indices) || !e.indices.length) return
        const { indices: n, value: o } = e
        let i = { indices: n, value: o }
        e.key && (i.key = e.key.src),
          e.idx > -1 && (i.refIndex = e.idx),
          t.matches.push(i)
      })
}
function transformScore(e, t) {
  t.score = e.score
}
function format(
  e,
  t,
  {
    includeMatches: n = Config.includeMatches,
    includeScore: o = Config.includeScore
  } = {}
) {
  const i = []
  return (
    n && i.push(transformMatches),
    o && i.push(transformScore),
    e.map((e) => {
      const { idx: n } = e,
        o = { item: t[n], refIndex: n }
      return (
        i.length &&
          i.forEach((t) => {
            t(e, o)
          }),
        o
      )
    })
  )
}
__name(parse, 'parse'),
  __name(computeScore, 'computeScore'),
  __name(transformMatches, 'transformMatches'),
  __name(transformScore, 'transformScore'),
  __name(format, 'format')
class Fuse {
  static {
    __name(this, 'Fuse')
  }
  constructor(e, t = {}, n) {
    ;(this.options = { ...Config, ...t }),
      this.options.useExtendedSearch,
      (this._keyStore = new KeyStore(this.options.keys)),
      this.setCollection(e, n)
  }
  setCollection(e, t) {
    if (((this._docs = e), t && !(t instanceof FuseIndex)))
      throw new Error(INCORRECT_INDEX_TYPE)
    this._myIndex =
      t ||
      createIndex(this.options.keys, this._docs, {
        getFn: this.options.getFn,
        fieldNormWeight: this.options.fieldNormWeight
      })
  }
  add(e) {
    isDefined(e) && (this._docs.push(e), this._myIndex.add(e))
  }
  remove(e = () => !1) {
    const t = []
    for (let n = 0, o = this._docs.length; n < o; n += 1) {
      const i = this._docs[n]
      e(i, n) && (this.removeAt(n), (n -= 1), (o -= 1), t.push(i))
    }
    return t
  }
  removeAt(e) {
    this._docs.splice(e, 1), this._myIndex.removeAt(e)
  }
  getIndex() {
    return this._myIndex
  }
  search(e, { limit: t = -1 } = {}) {
    const {
      includeMatches: n,
      includeScore: o,
      shouldSort: i,
      sortFn: r,
      ignoreFieldNorm: a
    } = this.options
    let s = isString(e)
      ? isString(this._docs[0])
        ? this._searchStringList(e)
        : this._searchObjectList(e)
      : this._searchLogical(e)
    return (
      computeScore(s, { ignoreFieldNorm: a }),
      i && s.sort(r),
      isNumber(t) && t > -1 && (s = s.slice(0, t)),
      format(s, this._docs, { includeMatches: n, includeScore: o })
    )
  }
  _searchStringList(e) {
    const t = createSearcher(e, this.options),
      { records: n } = this._myIndex,
      o = []
    return (
      n.forEach(({ v: e, i: n, n: i }) => {
        if (!isDefined(e)) return
        const { isMatch: r, score: a, indices: s } = t.searchIn(e)
        r &&
          o.push({
            item: e,
            idx: n,
            matches: [{ score: a, value: e, norm: i, indices: s }]
          })
      }),
      o
    )
  }
  _searchLogical(e) {
    const t = parse(e, this.options),
      n = __name((e, t, o) => {
        if (!e.children) {
          const { keyId: n, searcher: i } = e,
            r = this._findMatches({
              key: this._keyStore.get(n),
              value: this._myIndex.getValueForItemAtKeyId(t, n),
              searcher: i
            })
          return r && r.length ? [{ idx: o, item: t, matches: r }] : []
        }
        const i = []
        for (let r = 0, a = e.children.length; r < a; r += 1) {
          const a = e.children[r],
            s = n(a, t, o)
          if (s.length) i.push(...s)
          else if (e.operator === LogicalOperator.AND) return []
        }
        return i
      }, 'evaluate'),
      o = this._myIndex.records,
      i = {},
      r = []
    return (
      o.forEach(({ $: e, i: o }) => {
        if (isDefined(e)) {
          let a = n(t, e, o)
          a.length &&
            (i[o] || ((i[o] = { idx: o, item: e, matches: [] }), r.push(i[o])),
            a.forEach(({ matches: e }) => {
              i[o].matches.push(...e)
            }))
        }
      }),
      r
    )
  }
  _searchObjectList(e) {
    const t = createSearcher(e, this.options),
      { keys: n, records: o } = this._myIndex,
      i = []
    return (
      o.forEach(({ $: e, i: o }) => {
        if (!isDefined(e)) return
        let r = []
        n.forEach((n, o) => {
          r.push(...this._findMatches({ key: n, value: e[o], searcher: t }))
        }),
          r.length && i.push({ idx: o, item: e, matches: r })
      }),
      i
    )
  }
  _findMatches({ key: e, value: t, searcher: n }) {
    if (!isDefined(t)) return []
    let o = []
    if (isArray(t))
      t.forEach(({ v: t, i: i, n: r }) => {
        if (!isDefined(t)) return
        const { isMatch: a, score: s, indices: l } = n.searchIn(t)
        a && o.push({ score: s, key: e, value: t, idx: i, norm: r, indices: l })
      })
    else {
      const { v: i, n: r } = t,
        { isMatch: a, score: s, indices: l } = n.searchIn(i)
      a && o.push({ score: s, key: e, value: i, norm: r, indices: l })
    }
    return o
  }
}
;(Fuse.version = '7.0.0'),
  (Fuse.createIndex = createIndex),
  (Fuse.parseIndex = parseIndex),
  (Fuse.config = Config),
  (Fuse.parseQuery = parse),
  register$1(ExtendedSearch)
class FuseSearch {
  static {
    __name(this, 'FuseSearch')
  }
  fuse
  keys
  data
  advancedScoring
  constructor(e, t, n = !0, o = !1) {
    ;(this.data = e), (this.keys = t.keys ?? []), (this.advancedScoring = o)
    const i = n && t?.keys ? Fuse.createIndex(t.keys, e) : void 0
    this.fuse = new Fuse(e, t, i)
  }
  search(e, t) {
    const n = e
      ? this.fuse.search(e, t)
      : this.data.map((e) => ({ item: e, score: 0 }))
    if (!this.advancedScoring) return n.map((e) => e.item)
    return n
      .map((t) => ({
        item: t.item,
        scores: this.calcAuxScores(e.toLocaleLowerCase(), t.item, t.score)
      }))
      .sort((e, t) => this.compareAux(e.scores, t.scores))
      .map((e) => e.item)
  }
  calcAuxScores(e, t, n) {
    let o = []
    o = this.keys.length ? this.keys.map((e) => t[e]) : [t]
    let i = o.map((t) => this.calcAuxSingle(e, t, n)).sort(this.compareAux)[0]
    const r = o.some((e) => e.toLocaleLowerCase().includes('deprecated'))
    return (
      (i[0] += r && 0 != i[0] ? 5 : 0),
      t.postProcessSearchScores && (i = t.postProcessSearchScores(i)),
      i
    )
  }
  calcAuxSingle(e, t, n) {
    const o = t
        .split(/ |\b|(?<=[a-z])(?=[A-Z])|(?=[A-Z][a-z])/)
        .map((e) => e.toLocaleLowerCase()),
      i = e.split(' ')
    let r = 9,
      a = 0,
      s = 0
    if ((t = t.toLocaleLowerCase()) == e) r = 0
    else if (t.startsWith(e)) (r = 1), (s = t.length)
    else if (o.includes(e))
      (r = 2), (a = t.indexOf(e) + 0.5 * t.length), (s = t.length)
    else if (t.includes(e))
      (r = 3), (a = t.indexOf(e) + 0.5 * t.length), (s = t.length)
    else if (i.every((e) => o.includes(e))) {
      const e = i.map((e) => o.indexOf(e)),
        n = Math.min(...e),
        l = Math.max(...e)
      ;(r = 4), (a = l - n + 0.5 * l + 0.5 * t.length), (s = t.length)
    } else if (i.every((e) => t.includes(e))) {
      const e = Math.min(...i.map((e) => t.indexOf(e))),
        n = Math.max(...i.map((e) => t.indexOf(e) + e.length))
      ;(r = 5), (a = n - e + 0.5 * n + 0.5 * t.length), (s = t.length)
    }
    return [
      r,
      a,
      s,
      n +
        0.2 * (1 - Math.min(t.length, e.length) / Math.max(t.length, e.length))
    ]
  }
  compareAux(e, t) {
    for (let n = 0; n < Math.min(e.length, t.length); n++)
      if (e[n] !== t[n]) return e[n] - t[n]
    return e.length - t.length
  }
}
class NodeFilter {
  static {
    __name(this, 'NodeFilter')
  }
  constructor(e, t, n, o, i, r, a) {
    ;(this.id = e),
      (this.name = t),
      (this.invokeSequence = n),
      (this.longInvokeSequence = o),
      (this.nodeOptions = i),
      (this.fuseSearch = new FuseSearch(this.getAllNodeOptions(r), a))
  }
  fuseSearch
  getNodeOptions(e) {
    return this.nodeOptions instanceof Function
      ? this.nodeOptions(e)
      : this.nodeOptions
  }
  getAllNodeOptions(e) {
    return [
      ...new Set(e.reduce((e, t) => [...e, ...this.getNodeOptions(t)], []))
    ]
  }
  matches(e, t, n) {
    const o = !1 !== n?.matchWildcards
    if (o && '*' === t) return !0
    const i = this.getNodeOptions(e)
    return i.includes(t) || (o && _.some(i, (e) => '*' === e))
  }
}
class NodeSearchService {
  static {
    __name(this, 'NodeSearchService')
  }
  nodeFuseSearch
  nodeFilters
  constructor(e) {
    this.nodeFuseSearch = new FuseSearch(
      e,
      {
        keys: ['name', 'display_name'],
        includeScore: !0,
        threshold: 0.3,
        shouldSort: !1,
        useExtendedSearch: !0
      },
      !0,
      !0
    )
    const t = { includeScore: !0, threshold: 0.3, shouldSort: !0 },
      n = new NodeFilter(
        'input',
        'Input Type',
        'i',
        'input',
        (e) => e.inputs.all.map((e) => e.type),
        e,
        t
      ),
      o = new NodeFilter(
        'output',
        'Output Type',
        'o',
        'output',
        (e) => e.outputs.all.map((e) => e.type),
        e,
        t
      ),
      i = new NodeFilter(
        'category',
        'Category',
        'c',
        'category',
        (e) => [e.category],
        e,
        t
      ),
      r = new NodeFilter(
        'source',
        'Source',
        's',
        'source',
        (e) => [e.nodeSource.displayText],
        e,
        t
      )
    this.nodeFilters = [n, o, i, r]
  }
  endsWithFilterStartSequence(e) {
    return e.endsWith(':')
  }
  searchNode(e, t = [], n, o) {
    const i = this.nodeFuseSearch.search(e).filter((e) =>
      _.every(t, (t) => {
        const [n, i] = t
        return n.matches(e, i, o)
      })
    )
    return n?.limit ? i.slice(0, n.limit) : i
  }
  getFilterById(e) {
    return this.nodeFilters.find((t) => t.id === e)
  }
}
class ComfyInputsSpec {
  static {
    __name(this, 'ComfyInputsSpec')
  }
  required
  optional
  hidden
  constructor(e) {
    ;(this.required = ComfyInputsSpec.transformInputSpecRecord(
      e.required ?? {}
    )),
      (this.optional = ComfyInputsSpec.transformInputSpecRecord(
        e.optional ?? {}
      )),
      (this.hidden = e.hidden)
  }
  static transformInputSpecRecord(e) {
    const t = {}
    for (const [n, o] of Object.entries(e))
      t[n] = ComfyInputsSpec.transformSingleInputSpec(n, o)
    return t
  }
  static isInputSpec(e) {
    return (
      Array.isArray(e) &&
      e.length >= 1 &&
      ('string' == typeof e[0] || Array.isArray(e[0]))
    )
  }
  static transformSingleInputSpec(e, t) {
    if (!ComfyInputsSpec.isInputSpec(t)) return t
    const [n, o] = t,
      i = o ?? {},
      r = Array.isArray(n) ? 'COMBO' : t[0]
    return 'COMBO' === r
      ? { name: e, type: r, ...i, comboOptions: n, default: i.default ?? n[0] }
      : { name: e, type: r, ...i }
  }
  get all() {
    return [...Object.values(this.required), ...Object.values(this.optional)]
  }
  getInput(e) {
    return this.required[e] ?? this.optional[e]
  }
}
class ComfyOutputSpec {
  static {
    __name(this, 'ComfyOutputSpec')
  }
  constructor(e, t, n, o, i, r) {
    ;(this.index = e),
      (this.name = t),
      (this.type = n),
      (this.is_list = o),
      (this.comboOptions = i),
      (this.tooltip = r)
  }
}
class ComfyOutputsSpec {
  static {
    __name(this, 'ComfyOutputsSpec')
  }
  constructor(e) {
    this.outputs = e
  }
  get all() {
    return this.outputs
  }
}
class ComfyNodeDefImpl {
  static {
    __name(this, 'ComfyNodeDefImpl')
  }
  name
  display_name
  category
  python_module
  description
  deprecated
  experimental
  output_node
  input
  output
  output_is_list
  output_name
  output_tooltips
  inputs
  outputs
  nodeSource
  constructor(e) {
    ;(this.name = e.name),
      (this.display_name = e.display_name),
      (this.category = e.category),
      (this.python_module = e.python_module),
      (this.description = e.description),
      (this.deprecated = e.deprecated ?? '' === e.category),
      (this.experimental =
        e.experimental ?? e.category.startsWith('_for_testing')),
      (this.output_node = e.output_node),
      (this.input = e.input ?? {}),
      (this.output = e.output ?? []),
      (this.output_is_list = e.output_is_list),
      (this.output_name = e.output_name),
      (this.output_tooltips = e.output_tooltips),
      (this.inputs = new ComfyInputsSpec(e.input ?? {})),
      (this.outputs = ComfyNodeDefImpl.transformOutputSpec(e)),
      (this.nodeSource = getNodeSource(e.python_module))
  }
  static transformOutputSpec(e) {
    const {
        output: t,
        output_is_list: n,
        output_name: o,
        output_tooltips: i
      } = e,
      r = (t ?? []).map((e, t) => {
        const r = Array.isArray(e) ? 'COMBO' : e
        return new ComfyOutputSpec(
          t,
          o?.[t],
          r,
          n?.[t],
          Array.isArray(e) ? e : void 0,
          i?.[t]
        )
      })
    return new ComfyOutputsSpec(r)
  }
  get nodePath() {
    return (this.category ? this.category + '/' : '') + this.name
  }
  get isDummyFolder() {
    return '' === this.name
  }
  postProcessSearchScores(e) {
    const t = useNodeFrequencyStore().getNodeFrequencyByName(this.name)
    return [e[0], -t, ...e.slice(1)]
  }
  get isCoreNode() {
    return this.nodeSource.type === NodeSourceType.Core
  }
  get nodeLifeCycleBadgeText() {
    return this.deprecated ? '[DEPR]' : this.experimental ? '[BETA]' : ''
  }
}
const SYSTEM_NODE_DEFS = {
  PrimitiveNode: {
    name: 'PrimitiveNode',
    display_name: 'Primitive',
    category: 'utils',
    input: { required: {}, optional: {} },
    output: ['*'],
    output_name: ['connect to widget input'],
    output_is_list: [!1],
    output_node: !1,
    python_module: 'nodes',
    description: 'Primitive values like numbers, strings, and booleans.'
  },
  Reroute: {
    name: 'Reroute',
    display_name: 'Reroute',
    category: 'utils',
    input: { required: { '': ['*'] }, optional: {} },
    output: ['*'],
    output_name: [''],
    output_is_list: [!1],
    output_node: !1,
    python_module: 'nodes',
    description: 'Reroute the connection to another node.'
  },
  Note: {
    name: 'Note',
    display_name: 'Note',
    category: 'utils',
    input: { required: {}, optional: {} },
    output: [],
    output_name: [],
    output_is_list: [],
    output_node: !1,
    python_module: 'nodes',
    description: 'Node that add notes to your project'
  }
}
function buildNodeDefTree(e) {
  return buildTree(e, (e) => e.nodePath.split('/'))
}
function createDummyFolderNodeDef(e) {
  return new ComfyNodeDefImpl({
    name: '',
    display_name: '',
    category: e.endsWith('/') ? e.slice(0, -1) : e,
    python_module: 'nodes',
    description: 'Dummy Folder Node (User should never see this string)',
    input: {},
    output: [],
    output_name: [],
    output_is_list: [],
    output_node: !1
  })
}
__name(buildNodeDefTree, 'buildNodeDefTree'),
  __name(createDummyFolderNodeDef, 'createDummyFolderNodeDef')
const useNodeDefStore = defineStore('nodeDef', () => {
    const e = Vue.ref({}),
      t = Vue.ref({}),
      n = Vue.ref(!1),
      o = Vue.ref(!1),
      i = Vue.computed(() => Object.values(e.value)),
      r = Vue.computed(() =>
        i.value.filter(
          (e) => (n.value || !e.deprecated) && (o.value || !e.experimental)
        )
      ),
      a = Vue.computed(() => new NodeSearchService(r.value)),
      s = Vue.computed(() => buildNodeDefTree(r.value))
    function l(n) {
      const o = {},
        i = {}
      for (const e of n)
        try {
          const t = new ComfyNodeDefImpl(e)
          ;(o[e.name] = t), (i[e.display_name] = t)
        } catch (e2) {
          console.error('Error adding nodeDef:', e2)
        }
      ;(e.value = o), (t.value = i)
    }
    function c(n) {
      const o = new ComfyNodeDefImpl(n)
      ;(e.value[n.name] = o), (t.value[n.display_name] = o)
    }
    function d(t) {
      return e.value[t.constructor?.nodeData?.name] ?? null
    }
    return (
      __name(l, 'updateNodeDefs'),
      __name(c, 'addNodeDef'),
      __name(d, 'fromLGraphNode'),
      {
        nodeDefsByName: e,
        nodeDefsByDisplayName: t,
        showDeprecated: n,
        showExperimental: o,
        nodeDefs: i,
        visibleNodeDefs: r,
        nodeSearchService: a,
        nodeTree: s,
        updateNodeDefs: l,
        addNodeDef: c,
        fromLGraphNode: d
      }
    )
  }),
  useNodeFrequencyStore = defineStore('nodeFrequency', () => {
    const e = Vue.ref(64),
      t = Vue.ref({}),
      n = Vue.computed(() => Object.keys(t.value)),
      o = Vue.ref(!1),
      i = __name(async () => {
        if (!o.value)
          try {
            const e = await axios.get('assets/sorted-custom-node-map.json')
            ;(t.value = e.data), (o.value = !0)
          } catch (e) {
            console.error('Error loading node frequencies:', e)
          }
      }, 'loadNodeFrequencies'),
      r = __name((e) => a(e.name), 'getNodeFrequency'),
      a = __name((e) => t.value[e] ?? 0, 'getNodeFrequencyByName'),
      s = useNodeDefStore(),
      l = Vue.computed(() =>
        n.value
          .map((e) => s.nodeDefsByName[e])
          .filter((e) => void 0 !== e)
          .slice(0, e.value)
      )
    return {
      nodeNamesByFrequency: n,
      topNodeDefs: l,
      isLoaded: o,
      loadNodeFrequencies: i,
      getNodeFrequency: r,
      getNodeFrequencyByName: a
    }
  })
function _findInMetadata(e, ...t) {
  for (const n of t) {
    if (n in e) return e[n]
    for (const t in e) if (t.endsWith(n)) return e[t]
  }
  return null
}
__name(_findInMetadata, '_findInMetadata')
class ComfyModelDef {
  static {
    __name(this, 'ComfyModelDef')
  }
  file_name
  normalized_file_name
  directory
  simplified_file_name
  key
  title
  architecture_id = ''
  author = ''
  resolution = ''
  description = ''
  usage_hint = ''
  trigger_phrase = ''
  tags = []
  image = ''
  has_loaded_metadata = !1
  is_load_requested = !1
  searchable = ''
  constructor(e, t) {
    ;(this.file_name = e),
      (this.normalized_file_name = e.replaceAll('\\', '/')),
      (this.simplified_file_name =
        this.normalized_file_name.split('/').pop() ?? ''),
      this.simplified_file_name.endsWith('.safetensors') &&
        (this.simplified_file_name = this.simplified_file_name.slice(0, -12)),
      (this.title = this.simplified_file_name),
      (this.directory = t),
      (this.key = `${t}/${this.normalized_file_name}`),
      this.updateSearchable()
  }
  updateSearchable() {
    this.searchable = [
      this.file_name,
      this.title,
      this.author,
      this.description,
      this.trigger_phrase,
      this.tags.join(', ')
    ]
      .join('\n')
      .toLowerCase()
  }
  async load() {
    if (!this.has_loaded_metadata && !this.is_load_requested) {
      this.is_load_requested = !0
      try {
        const e = await api.viewMetadata(this.directory, this.file_name)
        if (!e) return
        ;(this.title =
          _findInMetadata(
            e,
            'modelspec.title',
            'title',
            'display_name',
            'name'
          ) || this.title),
          (this.architecture_id =
            _findInMetadata(e, 'modelspec.architecture', 'architecture') || ''),
          (this.author =
            _findInMetadata(e, 'modelspec.author', 'author') || ''),
          (this.description =
            _findInMetadata(e, 'modelspec.description', 'description') || ''),
          (this.resolution =
            _findInMetadata(e, 'modelspec.resolution', 'resolution') || ''),
          (this.usage_hint =
            _findInMetadata(e, 'modelspec.usage_hint', 'usage_hint') || ''),
          (this.trigger_phrase =
            _findInMetadata(e, 'modelspec.trigger_phrase', 'trigger_phrase') ||
            ''),
          (this.image =
            _findInMetadata(
              e,
              'modelspec.thumbnail',
              'thumbnail',
              'image',
              'icon'
            ) || '')
        const t = _findInMetadata(e, 'modelspec.tags', 'tags') || ''
        ;(this.tags = t.split(',').map((e) => e.trim())),
          (this.has_loaded_metadata = !0),
          this.updateSearchable()
      } catch (e) {
        console.error('Error loading model metadata', this.file_name, this, e)
      }
    }
  }
}
var ResourceState = ((e) => (
  (e[(e.Uninitialized = 0)] = 'Uninitialized'),
  (e[(e.Loading = 1)] = 'Loading'),
  (e[(e.Loaded = 2)] = 'Loaded'),
  e
))(ResourceState || {})
class ModelFolder {
  static {
    __name(this, 'ModelFolder')
  }
  constructor(e) {
    this.directory = e
  }
  models = {}
  state = 0
  get key() {
    return this.directory + '/'
  }
  async load() {
    if (0 !== this.state) return this
    this.state = 1
    const e = await api.getModels(this.directory)
    for (const t of e) this.models[t] = new ComfyModelDef(t, this.directory)
    return (this.state = 2), this
  }
}
const useModelStore = defineStore('models', () => {
  const e = Vue.ref([]),
    t = Vue.ref({}),
    n = Vue.computed(() => e.value.map((e) => t.value[e])),
    o = Vue.computed(() => n.value.flatMap((e) => Object.values(e.models)))
  async function i() {
    ;(e.value = await api.getModelFolders()), (t.value = {})
    for (const n of e.value) t.value[n] = new ModelFolder(n)
  }
  async function r(e) {
    const n = t.value[e]
    return n ? await n.load() : null
  }
  async function a() {
    return Promise.all(n.value.map((e) => e.load()))
  }
  return (
    __name(i, 'loadModelFolders'),
    __name(r, 'getLoadedModelFolder'),
    __name(a, 'loadModels'),
    {
      models: o,
      modelFolders: n,
      loadModelFolders: i,
      loadModels: a,
      getLoadedModelFolder: r
    }
  )
})
async function syncEntities(e, t, n, o, i = () => !1) {
  const r = (await api.listUserDataFullInfo(e)).map((t) => ({
    ...t,
    path: e ? `${e}/${t.path}` : t.path
  }))
  for (const a of r) {
    const e = t[a.path]
    if (e) {
      if (i(e)) continue
      o(e, a)
    } else t[a.path] = n(a)
  }
  for (const [a, s] of Object.entries(t))
    i(s) || r.some((e) => e.path === a) || delete t[a]
}
__name(syncEntities, 'syncEntities')
class UserFile {
  static {
    __name(this, 'UserFile')
  }
  constructor(e, t, n) {
    ;(this.path = e), (this.lastModified = t), (this.size = n)
    const o = getPathDetails(e)
    ;(this.path = e),
      (this.directory = o.directory),
      (this.fullFilename = o.fullFilename),
      (this.filename = o.filename),
      (this.suffix = o.suffix)
  }
  directory
  fullFilename
  filename
  suffix
  isLoading = !1
  content = null
  originalContent = null
  updatePath(e) {
    const t = getPathDetails(e)
    ;(this.path = e),
      (this.directory = t.directory),
      (this.fullFilename = t.fullFilename),
      (this.filename = t.filename),
      (this.suffix = t.suffix)
  }
  static createTemporary(e) {
    return new UserFile(e, Date.now(), -1)
  }
  get isTemporary() {
    return -1 === this.size
  }
  get isPersisted() {
    return !this.isTemporary
  }
  get key() {
    return this.path
  }
  get isLoaded() {
    return null !== this.content
  }
  get isModified() {
    return this.content !== this.originalContent
  }
  async load({ force: e = !1 } = {}) {
    if (this.isTemporary || (!e && this.isLoaded)) return this
    this.isLoading = !0
    const t = await api.getUserData(this.path)
    if (200 !== t.status)
      throw new Error(
        `Failed to load file '${this.path}': ${t.status} ${t.statusText}`
      )
    return (
      (this.content = await t.text()),
      (this.originalContent = this.content),
      (this.isLoading = !1),
      this
    )
  }
  unload() {
    ;(this.content = null), (this.originalContent = null), (this.isLoading = !1)
  }
  async saveAs(e) {
    const t = this.isTemporary ? this : UserFile.createTemporary(e)
    return (t.content = this.content), await t.save(), t
  }
  async save({ force: e = !1 } = {}) {
    if (this.isPersisted && !this.isModified && !e) return this
    const t = await api.storeUserData(this.path, this.content, {
        overwrite: this.isPersisted,
        throwOnError: !0,
        full_info: !0
      }),
      n = await t.json()
    return (
      'object' == typeof n &&
        ((this.lastModified = n.modified), (this.size = n.size)),
      (this.originalContent = this.content),
      this
    )
  }
  async delete() {
    if (this.isTemporary) return
    const e = await api.deleteUserData(this.path)
    if (204 !== e.status)
      throw new Error(
        `Failed to delete file '${this.path}': ${e.status} ${e.statusText}`
      )
  }
  async rename(e) {
    if (this.isTemporary) return this.updatePath(e), this
    const t = await api.moveUserData(this.path, e)
    if (200 !== t.status)
      throw new Error(
        `Failed to rename file '${this.path}': ${t.status} ${t.statusText}`
      )
    this.updatePath(e)
    const n = await t.json()
    return (
      'object' == typeof n &&
        ((this.lastModified = n.modified), (this.size = n.size)),
      this
    )
  }
}
const useUserFileStore = defineStore('userFile', () => {
  const e = Vue.ref({}),
    t = Vue.computed(() => Object.values(e.value)),
    n = Vue.computed(() => t.value.filter((e) => e.isModified)),
    o = Vue.computed(() => t.value.filter((e) => e.isLoaded)),
    i = Vue.computed(() => buildTree(t.value, (e) => e.path.split('/')))
  return {
    userFiles: t,
    modifiedFiles: n,
    loadedFiles: o,
    fileTree: i,
    syncFiles: __name(async (t = '') => {
      await syncEntities(
        t,
        e.value,
        (e) => new UserFile(e.path, e.modified, e.size),
        (e, t) => {
          ;(e.lastModified = t.modified), (e.size = t.size), e.unload()
        }
      )
    }, 'syncFiles')
  }
})
class Processor {
  static {
    __name(this, 'Processor')
  }
  constructor(e) {
    ;(this.selfOptions = e || {}), (this.pipes = {})
  }
  options(e) {
    return e && (this.selfOptions = e), this.selfOptions
  }
  pipe(e, t) {
    let n = t
    if ('string' == typeof e) {
      if (void 0 === n) return this.pipes[e]
      this.pipes[e] = n
    }
    if (e && e.name) {
      if (((n = e), n.processor === this)) return n
      this.pipes[n.name] = n
    }
    return (n.processor = this), n
  }
  process(e, t) {
    let n = e
    n.options = this.options()
    let o,
      i = t || e.pipe || 'default'
    for (; i; )
      void 0 !== n.nextAfterChildren &&
        ((n.next = n.nextAfterChildren), (n.nextAfterChildren = null)),
        'string' == typeof i && (i = this.pipe(i)),
        i.process(n),
        (o = i),
        (i = null),
        n && n.next && ((n = n.next), (i = n.pipe || o))
    return n.hasResult ? n.result : void 0
  }
}
class Pipe {
  static {
    __name(this, 'Pipe')
  }
  constructor(e) {
    ;(this.name = e), (this.filters = [])
  }
  process(e) {
    if (!this.processor)
      throw new Error('add this pipe to a processor before using it')
    const t = this.debug,
      n = this.filters.length,
      o = e
    for (let i = 0; i < n; i++) {
      const e = this.filters[i]
      if (
        (t && this.log(`filter: ${e.filterName}`),
        e(o),
        'object' == typeof o && o.exiting)
      ) {
        o.exiting = !1
        break
      }
    }
    !o.next && this.resultCheck && this.resultCheck(o)
  }
  log(e) {
    console.log(`[jsondiffpatch] ${this.name} pipe, ${e}`)
  }
  append(...e) {
    return this.filters.push(...e), this
  }
  prepend(...e) {
    return this.filters.unshift(...e), this
  }
  indexOf(e) {
    if (!e) throw new Error('a filter name is required')
    for (let t = 0; t < this.filters.length; t++) {
      if (this.filters[t].filterName === e) return t
    }
    throw new Error(`filter not found: ${e}`)
  }
  list() {
    return this.filters.map((e) => e.filterName)
  }
  after(e, ...t) {
    const n = this.indexOf(e)
    return this.filters.splice(n + 1, 0, ...t), this
  }
  before(e, ...t) {
    const n = this.indexOf(e)
    return this.filters.splice(n, 0, ...t), this
  }
  replace(e, ...t) {
    const n = this.indexOf(e)
    return this.filters.splice(n, 1, ...t), this
  }
  remove(e) {
    const t = this.indexOf(e)
    return this.filters.splice(t, 1), this
  }
  clear() {
    return (this.filters.length = 0), this
  }
  shouldHaveResult(e) {
    if (!1 !== e) {
      if (!this.resultCheck)
        return (
          (this.resultCheck = (e) => {
            if (!e.hasResult) {
              console.log(e)
              const t = new Error(`${this.name} failed`)
              throw ((t.noResult = !0), t)
            }
          }),
          this
        )
    } else this.resultCheck = null
  }
}
class Context {
  static {
    __name(this, 'Context')
  }
  setResult(e) {
    return (this.result = e), (this.hasResult = !0), this
  }
  exit() {
    return (this.exiting = !0), this
  }
  push(e, t) {
    return (
      (e.parent = this),
      void 0 !== t && (e.childName = t),
      (e.root = this.root || this),
      (e.options = e.options || this.options),
      this.children
        ? ((this.children[this.children.length - 1].next = e),
          this.children.push(e))
        : ((this.children = [e]),
          (this.nextAfterChildren = this.next || null),
          (this.next = e)),
      (e.next = this),
      this
    )
  }
}
function cloneRegExp(e) {
  const t = /^\/(.*)\/([gimyu]*)$/.exec(e.toString())
  return new RegExp(t[1], t[2])
}
function clone$2(e) {
  if ('object' != typeof e) return e
  if (null === e) return null
  if (Array.isArray(e)) return e.map(clone$2)
  if (e instanceof Date) return new Date(e.getTime())
  if (e instanceof RegExp) return cloneRegExp(e)
  const t = {}
  for (const n in e)
    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = clone$2(e[n]))
  return t
}
__name(cloneRegExp, 'cloneRegExp'), __name(clone$2, 'clone$2')
class DiffContext extends Context {
  static {
    __name(this, 'DiffContext')
  }
  constructor(e, t) {
    super(), (this.left = e), (this.right = t), (this.pipe = 'diff')
  }
  setResult(e) {
    if (this.options.cloneDiffValues && 'object' == typeof e) {
      const t =
        'function' == typeof this.options.cloneDiffValues
          ? this.options.cloneDiffValues
          : clone$2
      'object' == typeof e[0] && (e[0] = t(e[0])),
        'object' == typeof e[1] && (e[1] = t(e[1]))
    }
    return super.setResult(e)
  }
}
class PatchContext extends Context {
  static {
    __name(this, 'PatchContext')
  }
  constructor(e, t) {
    super(), (this.left = e), (this.delta = t), (this.pipe = 'patch')
  }
}
class ReverseContext extends Context {
  static {
    __name(this, 'ReverseContext')
  }
  constructor(e) {
    super(), (this.delta = e), (this.pipe = 'reverse')
  }
}
const diffFilter$3 = __name(function (e) {
  if (e.left !== e.right)
    if (void 0 !== e.left)
      if (void 0 !== e.right) {
        if ('function' == typeof e.left || 'function' == typeof e.right)
          throw new Error('functions are not supported')
        ;(e.leftType = null === e.left ? 'null' : typeof e.left),
          (e.rightType = null === e.right ? 'null' : typeof e.right),
          e.leftType === e.rightType &&
          'boolean' !== e.leftType &&
          'number' !== e.leftType
            ? ('object' === e.leftType &&
                (e.leftIsArray = Array.isArray(e.left)),
              'object' === e.rightType &&
                (e.rightIsArray = Array.isArray(e.right)),
              e.leftIsArray === e.rightIsArray
                ? e.left instanceof RegExp &&
                  (e.right instanceof RegExp
                    ? e
                        .setResult([e.left.toString(), e.right.toString()])
                        .exit()
                    : e.setResult([e.left, e.right]).exit())
                : e.setResult([e.left, e.right]).exit())
            : e.setResult([e.left, e.right]).exit()
      } else e.setResult([e.left, 0, 0]).exit()
    else {
      if ('function' == typeof e.right)
        throw new Error('functions are not supported')
      e.setResult([e.right]).exit()
    }
  else e.setResult(void 0).exit()
}, 'trivialMatchesDiffFilter')
diffFilter$3.filterName = 'trivial'
const patchFilter$3 = __name(function (e) {
  if (void 0 === e.delta) return void e.setResult(e.left).exit()
  if (((e.nested = !Array.isArray(e.delta)), e.nested)) return
  const t = e.delta
  if (1 !== t.length)
    if (2 !== t.length)
      3 === t.length && 0 === t[2] && e.setResult(void 0).exit()
    else {
      if (e.left instanceof RegExp) {
        const n = /^\/(.*)\/([gimyu]+)$/.exec(t[1])
        if (n) return void e.setResult(new RegExp(n[1], n[2])).exit()
      }
      e.setResult(t[1]).exit()
    }
  else e.setResult(t[0]).exit()
}, 'trivialMatchesPatchFilter')
patchFilter$3.filterName = 'trivial'
const reverseFilter$3 = __name(function (e) {
  if (void 0 === e.delta) return void e.setResult(e.delta).exit()
  if (((e.nested = !Array.isArray(e.delta)), e.nested)) return
  const t = e.delta
  1 !== t.length
    ? 2 !== t.length
      ? 3 === t.length && 0 === t[2] && e.setResult([t[0]]).exit()
      : e.setResult([t[1], t[0]]).exit()
    : e.setResult([t[0], 0, 0]).exit()
}, 'trivialReferseFilter')
reverseFilter$3.filterName = 'trivial'
const collectChildrenDiffFilter = __name((e) => {
  if (!e || !e.children) return
  const t = e.children.length
  let n,
    o = e.result
  for (let i = 0; i < t; i++)
    (n = e.children[i]),
      void 0 !== n.result && ((o = o || {}), (o[n.childName] = n.result))
  o && e.leftIsArray && (o._t = 'a'), e.setResult(o).exit()
}, 'collectChildrenDiffFilter')
collectChildrenDiffFilter.filterName = 'collectChildren'
const objectsDiffFilter = __name((e) => {
  if (e.leftIsArray || 'object' !== e.leftType) return
  const t = e.left,
    n = e.right
  let o, i
  const r = e.options.propertyFilter
  for (o in t)
    Object.prototype.hasOwnProperty.call(t, o) &&
      ((r && !r(o, e)) || ((i = new DiffContext(t[o], n[o])), e.push(i, o)))
  for (o in n)
    Object.prototype.hasOwnProperty.call(n, o) &&
      ((r && !r(o, e)) ||
        (void 0 === t[o] &&
          ((i = new DiffContext(void 0, n[o])), e.push(i, o))))
  e.children && 0 !== e.children.length ? e.exit() : e.setResult(void 0).exit()
}, 'objectsDiffFilter')
objectsDiffFilter.filterName = 'objects'
const patchFilter$2 = __name(function (e) {
  if (!e.nested) return
  const t = e.delta
  if (t._t) return
  const n = t
  let o, i
  for (o in n) (i = new PatchContext(e.left[o], n[o])), e.push(i, o)
  e.exit()
}, 'nestedPatchFilter')
patchFilter$2.filterName = 'objects'
const collectChildrenPatchFilter$1 = __name(function (e) {
  if (!e || !e.children) return
  if (e.delta._t) return
  const t = e.left,
    n = e.children.length
  let o
  for (let i = 0; i < n; i++) {
    o = e.children[i]
    const n = o.childName
    Object.prototype.hasOwnProperty.call(e.left, n) && void 0 === o.result
      ? delete t[n]
      : t[n] !== o.result && (t[n] = o.result)
  }
  e.setResult(t).exit()
}, 'collectChildrenPatchFilter')
collectChildrenPatchFilter$1.filterName = 'collectChildren'
const reverseFilter$2 = __name(function (e) {
  if (!e.nested) return
  if (e.delta._t) return
  const t = e.delta
  let n, o
  for (n in t) (o = new ReverseContext(t[n])), e.push(o, n)
  e.exit()
}, 'nestedReverseFilter')
reverseFilter$2.filterName = 'objects'
const collectChildrenReverseFilter$1 = __name((e) => {
  if (!e || !e.children) return
  if (e.delta._t) return
  const t = e.children.length
  let n
  const o = {}
  for (let i = 0; i < t; i++) {
    n = e.children[i]
    const t = n.childName
    o[t] !== n.result && (o[t] = n.result)
  }
  e.setResult(o).exit()
}, 'collectChildrenReverseFilter$1')
collectChildrenReverseFilter$1.filterName = 'collectChildren'
const defaultMatch = __name(function (e, t, n, o) {
    return e[n] === t[o]
  }, 'defaultMatch'),
  lengthMatrix = __name(function (e, t, n, o) {
    const i = e.length,
      r = t.length
    let a, s
    const l = new Array(i + 1)
    for (a = 0; a < i + 1; a++)
      for (l[a] = new Array(r + 1), s = 0; s < r + 1; s++) l[a][s] = 0
    for (l.match = n, a = 1; a < i + 1; a++)
      for (s = 1; s < r + 1; s++)
        n(e, t, a - 1, s - 1, o)
          ? (l[a][s] = l[a - 1][s - 1] + 1)
          : (l[a][s] = Math.max(l[a - 1][s], l[a][s - 1]))
    return l
  }, 'lengthMatrix'),
  backtrack = __name(function (e, t, n, o) {
    let i = t.length,
      r = n.length
    const a = { sequence: [], indices1: [], indices2: [] }
    for (; 0 !== i && 0 !== r; ) {
      if (e.match(t, n, i - 1, r - 1, o))
        a.sequence.unshift(t[i - 1]),
          a.indices1.unshift(i - 1),
          a.indices2.unshift(r - 1),
          --i,
          --r
      else {
        e[i][r - 1] > e[i - 1][r] ? --r : --i
      }
    }
    return a
  }, 'backtrack'),
  get = __name(function (e, t, n, o) {
    const i = o || {},
      r = lengthMatrix(e, t, n || defaultMatch, i)
    return backtrack(r, e, t, i)
  }, 'get'),
  lcs = { get: get },
  ARRAY_MOVE = 3
function arraysHaveMatchByRef(e, t, n, o) {
  for (let i = 0; i < n; i++) {
    const n = e[i]
    for (let e = 0; e < o; e++) {
      const o = t[e]
      if (i !== e && n === o) return !0
    }
  }
}
function matchItems(e, t, n, o, i) {
  const r = e[n],
    a = t[o]
  if (r === a) return !0
  if ('object' != typeof r || 'object' != typeof a) return !1
  const s = i.objectHash
  if (!s) return i.matchByPosition && n === o
  i.hashCache1 = i.hashCache1 || []
  let l = i.hashCache1[n]
  if ((void 0 === l && (i.hashCache1[n] = l = s(r, n)), void 0 === l)) return !1
  i.hashCache2 = i.hashCache2 || []
  let c = i.hashCache2[o]
  return (
    void 0 === c && (i.hashCache2[o] = c = s(a, o)), void 0 !== c && l === c
  )
}
__name(arraysHaveMatchByRef, 'arraysHaveMatchByRef'),
  __name(matchItems, 'matchItems')
const diffFilter$2 = __name(function (e) {
  if (!e.leftIsArray) return
  const t = {
    objectHash: e.options && e.options.objectHash,
    matchByPosition: e.options && e.options.matchByPosition
  }
  let n,
    o,
    i,
    r = 0,
    a = 0
  const s = e.left,
    l = e.right,
    c = s.length,
    d = l.length
  let u, p
  for (
    c > 0 &&
    d > 0 &&
    !t.objectHash &&
    'boolean' != typeof t.matchByPosition &&
    (t.matchByPosition = !arraysHaveMatchByRef(s, l, c, d));
    r < c && r < d && matchItems(s, l, r, r, t);

  )
    (n = r), (u = new DiffContext(s[n], l[n])), e.push(u, n), r++
  for (; a + r < c && a + r < d && matchItems(s, l, c - 1 - a, d - 1 - a, t); )
    (o = c - 1 - a),
      (i = d - 1 - a),
      (u = new DiffContext(s[o], l[i])),
      e.push(u, i),
      a++
  if (r + a === c) {
    if (c === d) return void e.setResult(void 0).exit()
    for (p = p || { _t: 'a' }, n = r; n < d - a; n++) p[n] = [l[n]]
    return void e.setResult(p).exit()
  }
  if (r + a === d) {
    for (p = p || { _t: 'a' }, n = r; n < c - a; n++) p[`_${n}`] = [s[n], 0, 0]
    return void e.setResult(p).exit()
  }
  delete t.hashCache1, delete t.hashCache2
  const h = s.slice(r, c - a),
    m = l.slice(r, d - a),
    f = lcs.get(h, m, matchItems, t),
    _ = []
  for (p = p || { _t: 'a' }, n = r; n < c - a; n++)
    f.indices1.indexOf(n - r) < 0 && ((p[`_${n}`] = [s[n], 0, 0]), _.push(n))
  let g = !0
  e.options &&
    e.options.arrays &&
    !1 === e.options.arrays.detectMove &&
    (g = !1)
  let v = !1
  e.options &&
    e.options.arrays &&
    e.options.arrays.includeValueOnMove &&
    (v = !0)
  const y = _.length
  for (n = r; n < d - a; n++) {
    const a = f.indices2.indexOf(n - r)
    if (a < 0) {
      let a = !1
      if (g && y > 0)
        for (let c = 0; c < y; c++)
          if (((o = _[c]), matchItems(h, m, o - r, n - r, t))) {
            p[`_${o}`].splice(1, 2, n, ARRAY_MOVE),
              v || (p[`_${o}`][0] = ''),
              (i = n),
              (u = new DiffContext(s[o], l[i])),
              e.push(u, i),
              _.splice(c, 1),
              (a = !0)
            break
          }
      a || (p[n] = [l[n]])
    } else
      (o = f.indices1[a] + r),
        (i = f.indices2[a] + r),
        (u = new DiffContext(s[o], l[i])),
        e.push(u, i)
  }
  e.setResult(p).exit()
}, 'arraysDiffFilter')
diffFilter$2.filterName = 'arrays'
const compare = {
    numerically: (e, t) => e - t,
    numericallyBy: (e) => (t, n) => t[e] - n[e]
  },
  patchFilter$1 = __name(function (e) {
    if (!e.nested) return
    const t = e.delta
    if ('a' !== t._t) return
    let n, o
    const i = t,
      r = e.left
    let a = [],
      s = []
    const l = []
    for (n in i)
      if ('_t' !== n)
        if ('_' === n[0]) {
          const e = n
          if (0 !== i[e][2] && i[e][2] !== ARRAY_MOVE)
            throw new Error(
              `only removal or move can be applied at original array indices, invalid diff type: ${i[e][2]}`
            )
          a.push(parseInt(n.slice(1), 10))
        } else {
          const e = n
          1 === i[e].length
            ? s.push({ index: parseInt(e, 10), value: i[e][0] })
            : l.push({ index: parseInt(e, 10), delta: i[e] })
        }
    for (a = a.sort(compare.numerically), n = a.length - 1; n >= 0; n--) {
      o = a[n]
      const e = i[`_${o}`],
        t = r.splice(o, 1)[0]
      e[2] === ARRAY_MOVE && s.push({ index: e[1], value: t })
    }
    s = s.sort(compare.numericallyBy('index'))
    const c = s.length
    for (n = 0; n < c; n++) {
      const e = s[n]
      r.splice(e.index, 0, e.value)
    }
    const d = l.length
    let u
    if (d > 0)
      for (n = 0; n < d; n++) {
        const t = l[n]
        ;(u = new PatchContext(r[t.index], t.delta)), e.push(u, t.index)
      }
    e.children ? e.exit() : e.setResult(r).exit()
  }, 'nestedPatchFilter')
patchFilter$1.filterName = 'arrays'
const collectChildrenPatchFilter = __name(function (e) {
  if (!e || !e.children) return
  if ('a' !== e.delta._t) return
  const t = e.left,
    n = e.children.length
  let o
  for (let i = 0; i < n; i++) {
    o = e.children[i]
    t[o.childName] = o.result
  }
  e.setResult(t).exit()
}, 'collectChildrenPatchFilter')
collectChildrenPatchFilter.filterName = 'arraysCollectChildren'
const reverseFilter$1 = __name(function (e) {
  if (!e.nested) {
    const t = e.delta
    if (t[2] === ARRAY_MOVE) {
      const n = t
      ;(e.newName = `_${n[1]}`),
        e
          .setResult([n[0], parseInt(e.childName.substring(1), 10), ARRAY_MOVE])
          .exit()
    }
    return
  }
  const t = e.delta
  if ('a' !== t._t) return
  const n = t
  let o, i
  for (o in n) '_t' !== o && ((i = new ReverseContext(n[o])), e.push(i, o))
  e.exit()
}, 'arraysReverseFilter')
reverseFilter$1.filterName = 'arrays'
const reverseArrayDeltaIndex = __name((e, t, n) => {
    if ('string' == typeof t && '_' === t[0])
      return parseInt(t.substring(1), 10)
    if (Array.isArray(n) && 0 === n[2]) return `_${t}`
    let o = +t
    for (const i in e) {
      const n = e[i]
      if (Array.isArray(n))
        if (n[2] === ARRAY_MOVE) {
          const e = parseInt(i.substring(1), 10),
            r = n[1]
          if (r === +t) return e
          e <= o && r > o ? o++ : e >= o && r < o && o--
        } else if (0 === n[2]) {
          parseInt(i.substring(1), 10) <= o && o++
        } else 1 === n.length && parseInt(i, 10) <= o && o--
    }
    return o
  }, 'reverseArrayDeltaIndex'),
  collectChildrenReverseFilter = __name((e) => {
    if (!e || !e.children) return
    const t = e.delta
    if ('a' !== t._t) return
    const n = t,
      o = e.children.length
    let i
    const r = { _t: 'a' }
    for (let a = 0; a < o; a++) {
      i = e.children[a]
      let t = i.newName
      void 0 === t && (t = reverseArrayDeltaIndex(n, i.childName, i.result)),
        r[t] !== i.result && (r[t] = i.result)
    }
    e.setResult(r).exit()
  }, 'collectChildrenReverseFilter')
collectChildrenReverseFilter.filterName = 'arraysCollectChildren'
const diffFilter$1 = __name(function (e) {
  e.left instanceof Date
    ? (e.right instanceof Date
        ? e.left.getTime() !== e.right.getTime()
          ? e.setResult([e.left, e.right])
          : e.setResult(void 0)
        : e.setResult([e.left, e.right]),
      e.exit())
    : e.right instanceof Date && e.setResult([e.left, e.right]).exit()
}, 'datesDiffFilter')
diffFilter$1.filterName = 'dates'
const TEXT_DIFF = 2,
  DEFAULT_MIN_LENGTH = 60
let cachedDiffPatch = null
function getDiffMatchPatch(e, t) {
  var n
  if (!cachedDiffPatch) {
    let o
    if (
      !(null === (n = null == e ? void 0 : e.textDiff) || void 0 === n
        ? void 0
        : n.diffMatchPatch)
    ) {
      if (!t) return null
      const e = new Error(
        'The diff-match-patch library was not provided. Pass the library in through the options or use the `jsondiffpatch/with-text-diffs` entry-point.'
      )
      throw ((e.diff_match_patch_not_found = !0), e)
    }
    ;(o = new e.textDiff.diffMatchPatch()),
      (cachedDiffPatch = {
        diff: __name(function (e, t) {
          return o.patch_toText(o.patch_make(e, t))
        }, 'diff'),
        patch: __name(function (e, t) {
          const n = o.patch_apply(o.patch_fromText(t), e)
          for (let o = 0; o < n[1].length; o++)
            if (!n[1][o]) {
              new Error('text patch failed').textPatchFailed = !0
            }
          return n[0]
        }, 'patch')
      })
  }
  return cachedDiffPatch
}
__name(getDiffMatchPatch, 'getDiffMatchPatch')
const diffFilter = __name(function (e) {
  if ('string' !== e.leftType) return
  const t = e.left,
    n = e.right,
    o =
      (e.options && e.options.textDiff && e.options.textDiff.minLength) ||
      DEFAULT_MIN_LENGTH
  if (t.length < o || n.length < o) return void e.setResult([t, n]).exit()
  const i = getDiffMatchPatch(e.options)
  if (!i) return void e.setResult([t, n]).exit()
  const r = i.diff
  e.setResult([r(t, n), 0, TEXT_DIFF]).exit()
}, 'textsDiffFilter')
diffFilter.filterName = 'texts'
const patchFilter = __name(function (e) {
  if (e.nested) return
  const t = e.delta
  if (t[2] !== TEXT_DIFF) return
  const n = t,
    o = getDiffMatchPatch(e.options, !0).patch
  e.setResult(o(e.left, n[0])).exit()
}, 'textsPatchFilter')
patchFilter.filterName = 'texts'
const textDeltaReverse = __name(function (e) {
    let t,
      n,
      o,
      i,
      r = null
    const a = /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/
    let s
    const l = e.split('\n')
    for (t = 0, n = l.length; t < n; t++) {
      o = l[t]
      const e = o.slice(0, 1)
      '@' === e
        ? ((r = a.exec(o)),
          (s = t),
          (l[s] =
            '@@ -' + r[3] + ',' + r[4] + ' +' + r[1] + ',' + r[2] + ' @@'))
        : '+' === e
          ? ((l[t] = '-' + l[t].slice(1)),
            '+' === l[t - 1].slice(0, 1) &&
              ((i = l[t]), (l[t] = l[t - 1]), (l[t - 1] = i)))
          : '-' === e && (l[t] = '+' + l[t].slice(1))
    }
    return l.join('\n')
  }, 'textDeltaReverse'),
  reverseFilter = __name(function (e) {
    if (e.nested) return
    const t = e.delta
    if (t[2] !== TEXT_DIFF) return
    const n = t
    e.setResult([textDeltaReverse(n[0]), 0, TEXT_DIFF]).exit()
  }, 'textsReverseFilter')
reverseFilter.filterName = 'texts'
class DiffPatcher {
  static {
    __name(this, 'DiffPatcher')
  }
  constructor(e) {
    ;(this.processor = new Processor(e)),
      this.processor.pipe(
        new Pipe('diff')
          .append(
            collectChildrenDiffFilter,
            diffFilter$3,
            diffFilter$1,
            diffFilter,
            objectsDiffFilter,
            diffFilter$2
          )
          .shouldHaveResult()
      ),
      this.processor.pipe(
        new Pipe('patch')
          .append(
            collectChildrenPatchFilter$1,
            collectChildrenPatchFilter,
            patchFilter$3,
            patchFilter,
            patchFilter$2,
            patchFilter$1
          )
          .shouldHaveResult()
      ),
      this.processor.pipe(
        new Pipe('reverse')
          .append(
            collectChildrenReverseFilter$1,
            collectChildrenReverseFilter,
            reverseFilter$3,
            reverseFilter,
            reverseFilter$2,
            reverseFilter$1
          )
          .shouldHaveResult()
      )
  }
  options(e) {
    return this.processor.options(e)
  }
  diff(e, t) {
    return this.processor.process(new DiffContext(e, t))
  }
  patch(e, t) {
    return this.processor.process(new PatchContext(e, t))
  }
  reverse(e) {
    return this.processor.process(new ReverseContext(e))
  }
  unpatch(e, t) {
    return this.patch(e, this.reverse(t))
  }
  clone(e) {
    return clone$2(e)
  }
}
function dateReviver(e, t) {
  let n
  return 'string' == typeof t &&
    ((n =
      /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+-])(\d{2}):(\d{2}))$/.exec(
        t
      )),
    n)
    ? new Date(
        Date.UTC(+n[1], +n[2] - 1, +n[3], +n[4], +n[5], +n[6], +(n[7] || 0))
      )
    : t
}
function create(e) {
  return new DiffPatcher(e)
}
let defaultInstance
function diff(e, t) {
  return (
    defaultInstance || (defaultInstance = new DiffPatcher()),
    defaultInstance.diff(e, t)
  )
}
function patch(e, t) {
  return (
    defaultInstance || (defaultInstance = new DiffPatcher()),
    defaultInstance.patch(e, t)
  )
}
function unpatch(e, t) {
  return (
    defaultInstance || (defaultInstance = new DiffPatcher()),
    defaultInstance.unpatch(e, t)
  )
}
function reverse(e) {
  return (
    defaultInstance || (defaultInstance = new DiffPatcher()),
    defaultInstance.reverse(e)
  )
}
function clone$1(e) {
  return (
    defaultInstance || (defaultInstance = new DiffPatcher()),
    defaultInstance.clone(e)
  )
}
__name(dateReviver, 'dateReviver'),
  __name(create, 'create'),
  __name(diff, 'diff'),
  __name(patch, 'patch'),
  __name(unpatch, 'unpatch'),
  __name(reverse, 'reverse'),
  __name(clone$1, 'clone$1')
var loglevel$1 = { exports: {} },
  loglevel = loglevel$1.exports
!(function (e) {
  var t, n
  ;(t = commonjsGlobal),
    (n = function () {
      var e = __name(function () {}, 'noop'),
        t = 'undefined',
        n =
          typeof window !== t &&
          typeof window.navigator !== t &&
          /Trident\/|MSIE /.test(window.navigator.userAgent),
        o = ['trace', 'debug', 'info', 'warn', 'error'],
        i = {},
        r = null
      function a(e, t) {
        var n = e[t]
        if ('function' == typeof n.bind) return n.bind(e)
        try {
          return Function.prototype.bind.call(n, e)
        } catch (e2) {
          return function () {
            return Function.prototype.apply.apply(n, [e, arguments])
          }
        }
      }
      function s() {
        console.log &&
          (console.log.apply
            ? console.log.apply(console, arguments)
            : Function.prototype.apply.apply(console.log, [
                console,
                arguments
              ])),
          console.trace && console.trace()
      }
      function l(o) {
        return (
          'debug' === o && (o = 'log'),
          typeof console !== t &&
            ('trace' === o && n
              ? s
              : void 0 !== console[o]
                ? a(console, o)
                : void 0 !== console.log
                  ? a(console, 'log')
                  : e)
        )
      }
      function c() {
        for (var n = this.getLevel(), i = 0; i < o.length; i++) {
          var r = o[i]
          this[r] = i < n ? e : this.methodFactory(r, n, this.name)
        }
        if (
          ((this.log = this.debug),
          typeof console === t && n < this.levels.SILENT)
        )
          return 'No console available for logging'
      }
      function d(e) {
        return function () {
          typeof console !== t && (c.call(this), this[e].apply(this, arguments))
        }
      }
      function u(e, t, n) {
        return l(e) || d.apply(this, arguments)
      }
      function p(e, n) {
        var a,
          s,
          l,
          d = this,
          p = 'loglevel'
        function h(e) {
          var n = (o[e] || 'silent').toUpperCase()
          if (typeof window !== t && p) {
            try {
              return void (window.localStorage[p] = n)
            } catch (i) {}
            try {
              window.document.cookie = encodeURIComponent(p) + '=' + n + ';'
            } catch (i) {}
          }
        }
        function m() {
          var e
          if (typeof window !== t && p) {
            try {
              e = window.localStorage[p]
            } catch (r) {}
            if (typeof e === t)
              try {
                var n = window.document.cookie,
                  o = encodeURIComponent(p),
                  i = n.indexOf(o + '=')
                ;-1 !== i && (e = /^([^;]+)/.exec(n.slice(i + o.length + 1))[1])
              } catch (r) {}
            return void 0 === d.levels[e] && (e = void 0), e
          }
        }
        function f() {
          if (typeof window !== t && p) {
            try {
              window.localStorage.removeItem(p)
            } catch (e) {}
            try {
              window.document.cookie =
                encodeURIComponent(p) +
                '=; expires=Thu, 01 Jan 1970 00:00:00 UTC'
            } catch (e) {}
          }
        }
        function _(e) {
          var t = e
          if (
            ('string' == typeof t &&
              void 0 !== d.levels[t.toUpperCase()] &&
              (t = d.levels[t.toUpperCase()]),
            'number' == typeof t && t >= 0 && t <= d.levels.SILENT)
          )
            return t
          throw new TypeError('log.setLevel() called with invalid level: ' + e)
        }
        'string' == typeof e
          ? (p += ':' + e)
          : 'symbol' == typeof e && (p = void 0),
          __name(h, 'persistLevelIfPossible'),
          __name(m, 'getPersistedLevel'),
          __name(f, 'clearPersistedLevel'),
          __name(_, 'normalizeLevel'),
          (d.name = e),
          (d.levels = {
            TRACE: 0,
            DEBUG: 1,
            INFO: 2,
            WARN: 3,
            ERROR: 4,
            SILENT: 5
          }),
          (d.methodFactory = n || u),
          (d.getLevel = function () {
            return null != l ? l : null != s ? s : a
          }),
          (d.setLevel = function (e, t) {
            return (l = _(e)), !1 !== t && h(l), c.call(d)
          }),
          (d.setDefaultLevel = function (e) {
            ;(s = _(e)), m() || d.setLevel(e, !1)
          }),
          (d.resetLevel = function () {
            ;(l = null), f(), c.call(d)
          }),
          (d.enableAll = function (e) {
            d.setLevel(d.levels.TRACE, e)
          }),
          (d.disableAll = function (e) {
            d.setLevel(d.levels.SILENT, e)
          }),
          (d.rebuild = function () {
            if ((r !== d && (a = _(r.getLevel())), c.call(d), r === d))
              for (var e in i) i[e].rebuild()
          }),
          (a = _(r ? r.getLevel() : 'WARN'))
        var g = m()
        null != g && (l = _(g)), c.call(d)
      }
      __name(a, 'bindMethod'),
        __name(s, 'traceForIE'),
        __name(l, 'realMethod'),
        __name(c, 'replaceLoggingMethods'),
        __name(d, 'enableLoggingWhenConsoleArrives'),
        __name(u, 'defaultMethodFactory'),
        __name(p, 'Logger'),
        ((r = new p()).getLogger = __name(function (e) {
          if (('symbol' != typeof e && 'string' != typeof e) || '' === e)
            throw new TypeError(
              'You must supply a name when creating a logger.'
            )
          var t = i[e]
          return t || (t = i[e] = new p(e, r.methodFactory)), t
        }, 'getLogger'))
      var h = typeof window !== t ? window.log : void 0
      return (
        (r.noConflict = function () {
          return typeof window !== t && window.log === r && (window.log = h), r
        }),
        (r.getLoggers = __name(function () {
          return i
        }, 'getLoggers')),
        (r.default = r),
        r
      )
    }),
    e.exports ? (e.exports = n()) : (t.log = n())
})(loglevel$1)
var loglevelExports = loglevel$1.exports
const log = getDefaultExportFromCjs(loglevelExports)
function clone(e) {
  return JSON.parse(JSON.stringify(e))
}
__name(clone, 'clone')
const logger = log.getLogger('ChangeTracker')
logger.setLevel('info')
class ChangeTracker {
  static {
    __name(this, 'ChangeTracker')
  }
  constructor(e, t) {
    ;(this.workflow = e), (this.initialState = t), (this.activeState = t)
  }
  static MAX_HISTORY = 50
  activeState
  undoQueue = []
  redoQueue = []
  changeCount = 0
  restoringState = !1
  ds
  nodeOutputs
  static app
  get app() {
    return ChangeTracker.app
  }
  reset(e) {
    this.restoringState ||
      (logger.debug('Reset State'),
      e && (this.activeState = clone(e)),
      (this.initialState = clone(this.activeState)))
  }
  store() {
    this.ds = {
      scale: this.app.canvas.ds.scale,
      offset: [this.app.canvas.ds.offset[0], this.app.canvas.ds.offset[1]]
    }
  }
  restore() {
    this.ds &&
      ((this.app.canvas.ds.scale = this.ds.scale),
      (this.app.canvas.ds.offset = this.ds.offset)),
      this.nodeOutputs && (this.app.nodeOutputs = this.nodeOutputs)
  }
  updateModified() {
    api.dispatchCustomEvent('graphChanged', this.activeState)
    const e = useWorkflowStore().getWorkflowByPath(this.workflow.path)
    if (
      e &&
      ((e.isModified = !ChangeTracker.graphEqual(
        this.initialState,
        this.activeState
      )),
      logger.getLevel() <= logger.levels.DEBUG && e.isModified)
    ) {
      const e = ChangeTracker.graphDiff(this.initialState, this.activeState)
      logger.debug('Graph diff:', e)
    }
  }
  checkState() {
    if (!this.app.graph || this.changeCount) return
    const e = clone(this.app.graph.serialize())
    this.activeState
      ? ChangeTracker.graphEqual(this.activeState, e) ||
        (this.undoQueue.push(this.activeState),
        this.undoQueue.length > ChangeTracker.MAX_HISTORY &&
          this.undoQueue.shift(),
        logger.debug(
          'Diff detected. Undo queue length:',
          this.undoQueue.length
        ),
        (this.activeState = e),
        (this.redoQueue.length = 0),
        this.updateModified())
      : (this.activeState = e)
  }
  async updateState(e, t) {
    const n = e.pop()
    if (n) {
      t.push(this.activeState), (this.restoringState = !0)
      try {
        await this.app.loadGraphData(n, !1, !1, this.workflow, {
          showMissingModelsDialog: !1,
          showMissingNodesDialog: !1
        }),
          (this.activeState = n),
          this.updateModified()
      } finally {
        this.restoringState = !1
      }
    }
  }
  async undo() {
    await this.updateState(this.undoQueue, this.redoQueue),
      logger.debug(
        'Undo. Undo queue length:',
        this.undoQueue.length,
        'Redo queue length:',
        this.redoQueue.length
      )
  }
  async redo() {
    await this.updateState(this.redoQueue, this.undoQueue),
      logger.debug(
        'Redo. Undo queue length:',
        this.undoQueue.length,
        'Redo queue length:',
        this.redoQueue.length
      )
  }
  async undoRedo(e) {
    if ((e.ctrlKey || e.metaKey) && !e.altKey) {
      const t = e.key.toUpperCase()
      if (('Y' === t && !e.shiftKey) || ('Z' == t && e.shiftKey))
        return await this.redo(), !0
      if ('Z' === t && !e.shiftKey) return await this.undo(), !0
    }
  }
  beforeChange() {
    this.changeCount++
  }
  afterChange() {
    --this.changeCount || this.checkState()
  }
  static init(e) {
    const t = __name(
        () => useWorkflowStore().activeWorkflow?.changeTracker,
        'getCurrentChangeTracker'
      ),
      n = __name(() => t()?.checkState(), 'checkState')
    ChangeTracker.app = e
    let o = !1
    window.addEventListener(
      'keydown',
      (n) => {
        if (n.repeat) return
        const i = document.activeElement
        requestAnimationFrame(async () => {
          let r = null
          if (!e.ui.autoQueueEnabled || 'instant' === e.ui.autoQueueMode) {
            if (
              'INPUT' === i?.tagName ||
              (i && 'type' in i && 'textarea' === i.type)
            )
              return
            r = i
          }
          if (
            ((o =
              'Control' === n.key ||
              'Shift' === n.key ||
              'Alt' === n.key ||
              'Meta' === n.key),
            o)
          )
            return
          const a = t()
          a &&
            ((await a.undoRedo(n)) ||
              ChangeTracker.bindInput(e, r) ||
              (logger.debug('checkState on keydown'), a.checkState()))
        })
      },
      !0
    ),
      window.addEventListener('keyup', (e) => {
        o && ((o = !1), logger.debug('checkState on keyup'), n())
      }),
      window.addEventListener('mouseup', () => {
        logger.debug('checkState on mouseup'), n()
      }),
      api.addEventListener('promptQueued', () => {
        logger.debug('checkState on promptQueued'), n()
      }),
      api.addEventListener('graphCleared', () => {
        logger.debug('checkState on graphCleared'), n()
      })
    const i = LGraphCanvas.prototype.processMouseUp
    LGraphCanvas.prototype.processMouseUp = function (e) {
      const t = i.apply(this, [e])
      return logger.debug('checkState on processMouseUp'), n(), t
    }
    const r = LGraphCanvas.prototype.processMouseDown
    LGraphCanvas.prototype.processMouseDown = function (e) {
      const t = r.apply(this, [e])
      return logger.debug('checkState on processMouseDown'), n(), t
    }
    const a = LGraphCanvas.prototype.prompt
    LGraphCanvas.prototype.prompt = function (e, t, o, i) {
      const r = __name((e) => {
        o(e), n()
      }, 'extendedCallback')
      return logger.debug('checkState on prompt'), a.apply(this, [e, t, r, i])
    }
    const s = LiteGraph.ContextMenu.prototype.close
    LiteGraph.ContextMenu.prototype.close = function (e) {
      const t = s.apply(this, [e])
      return logger.debug('checkState on contextMenuClose'), n(), t
    }
    const l = LiteGraph.LGraph.prototype.onNodeAdded
    ;(LiteGraph.LGraph.prototype.onNodeAdded = function (t) {
      const o = l?.apply(this, [t])
      return (
        e?.configuringGraph || (logger.debug('checkState on onNodeAdded'), n()),
        o
      )
    }),
      document.addEventListener('litegraph:canvas', (e) => {
        const n = e.detail
        'before-change' === n.subType
          ? t()?.beforeChange()
          : 'after-change' === n.subType && t()?.afterChange()
      }),
      api.addEventListener('executed', (e) => {
        const t = e.detail,
          n = useExecutionStore().queuedPrompts[t.prompt_id]?.workflow,
          o = n?.changeTracker
        if (!o) return
        o.nodeOutputs ??= {}
        const i = o.nodeOutputs,
          r = i[t.node]
        if (t.merge && r)
          for (const a in t.output ?? {}) {
            const e = r[a]
            r[a] = e instanceof Array ? e.concat(t.output[a]) : t.output[a]
          }
        else i[t.node] = t.output
      })
  }
  static bindInput(e, t) {
    if (!t || 'CANVAS' === t.tagName || 'BODY' === t.tagName) return !1
    for (const n of ['change', 'input', 'blur']) {
      const e = t
      if (`on${n}` in e) {
        const t = __name(() => {
          useWorkflowStore().activeWorkflow?.changeTracker?.checkState?.(),
            e.removeEventListener(n, t)
        }, 'listener')
        return e.addEventListener(n, t), !0
      }
    }
    return !1
  }
  static graphEqual(e, t) {
    if (e === t) return !0
    if ('object' == typeof e && e && 'object' == typeof t && t) {
      if (
        !_.isEqualWith(e.nodes, t.nodes, (e, t) => {
          if (Array.isArray(e) && Array.isArray(t))
            return _.isEqual(new Set(e), new Set(t))
        })
      )
        return !1
      if (
        !_.isEqual(_.omit(e.extra ?? {}, ['ds']), _.omit(t.extra ?? {}, ['ds']))
      )
        return !1
      for (const n of ['links', 'reroutes', 'groups'])
        if (!_.isEqual(e[n], t[n])) return !1
      return !0
    }
    return !1
  }
  static graphDiff(e, t) {
    function n(e) {
      return {
        links: e.links,
        groups: e.groups,
        nodes: e.nodes.sort((e, t) =>
          'number' == typeof e.id && 'number' == typeof t.id ? e.id - t.id : 0
        )
      }
    }
    return __name(n, 'sortGraphNodes'), diff(n(e), n(t))
  }
}
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.changeTracker = window.comfyAPI.changeTracker || {}),
  (window.comfyAPI.changeTracker.ChangeTracker = ChangeTracker)
class ComfyWorkflow extends UserFile {
  static {
    __name(this, 'ComfyWorkflow')
  }
  static basePath = 'workflows/'
  changeTracker = null
  _isModified = !1
  constructor(e) {
    super(e.path, e.modified, e.size)
  }
  get key() {
    return this.path.substring(ComfyWorkflow.basePath.length)
  }
  get activeState() {
    return this.changeTracker?.activeState ?? null
  }
  get initialState() {
    return this.changeTracker?.initialState ?? null
  }
  get isLoaded() {
    return null !== this.changeTracker
  }
  get isModified() {
    return this._isModified
  }
  set isModified(e) {
    this._isModified = e
  }
  async load({ force: e = !1 } = {}) {
    if ((await super.load({ force: e }), !e && this.isLoaded)) return this
    if (!this.originalContent)
      throw new Error('[ASSERT] Workflow content should be loaded')
    return (
      console.debug('load and start tracking of workflow', this.path),
      (this.changeTracker = Vue.markRaw(
        new ChangeTracker(this, JSON.parse(this.originalContent))
      )),
      this
    )
  }
  unload() {
    console.debug('unload workflow', this.path),
      (this.changeTracker = null),
      super.unload()
  }
  async save() {
    this.content = JSON.stringify(this.activeState)
    const e = await super.save({ force: !0 })
    return this.changeTracker?.reset(), (this.isModified = !1), e
  }
  async saveAs(e) {
    return (
      (this.content = JSON.stringify(this.activeState)), await super.saveAs(e)
    )
  }
}
const useWorkflowStore = defineStore('workflow', () => {
    const e = __name((e) => {
        delete i.value[e.path]
        const t = s.value.indexOf(e.path)
        return -1 !== t && (s.value = s.value.filter((t) => t !== e.path)), t
      }, 'detachWorkflow'),
      t = __name((e, t = -1) => {
        ;(i.value[e.path] = e), -1 !== t && s.value.splice(t, 0, e.path)
      }, 'attachWorkflow'),
      n = Vue.ref(null),
      o = __name((e) => n.value?.path === e.path, 'isActive'),
      i = Vue.ref({}),
      r = Vue.computed(() => Object.values(i.value)),
      a = __name((e) => i.value[e] ?? null, 'getWorkflowByPath'),
      s = Vue.ref([]),
      l = Vue.computed(() => new Set(s.value)),
      c = Vue.computed(() => s.value.map((e) => i.value[e])),
      d = __name((e) => l.value.has(e.path), 'isOpen'),
      u = __name(async (e) => {
        if (o(e)) return e
        s.value.includes(e.path) || s.value.push(e.path)
        const t = await e.load()
        return (
          (n.value = t),
          console.debug('[workflowStore] open workflow', e.path),
          t
        )
      }, 'openWorkflow'),
      p = __name((e) => {
        const { directory: t, filename: n, suffix: o } = getPathDetails(e)
        let r = 2,
          a = e
        for (; i.value[a]; ) (a = `${t}/${n} (${r}).${o}`), r++
        return a
      }, 'getUnconflictedPath'),
      h = __name((e, t) => {
        const n = p(ComfyWorkflow.basePath + (e ?? 'Unsaved Workflow.json')),
          o = new ComfyWorkflow({ path: n, modified: Date.now(), size: -1 })
        return (
          (o.originalContent = o.content =
            t ? JSON.stringify(t) : defaultGraphJSON),
          (i.value[o.path] = o),
          o
        )
      }, 'createTemporary'),
      m = __name(async (e) => {
        ;(s.value = s.value.filter((t) => t !== e.path)),
          e.isTemporary ? delete i.value[e.path] : e.unload(),
          console.debug('[workflowStore] close workflow', e.path)
      }, 'closeWorkflow'),
      f = __name((e) => {
        const t = s.value.indexOf(n.value?.path ?? '')
        if (-1 !== t) {
          const n = c.value.length,
            o = (t + e + n) % n
          return c.value[o] ?? null
        }
        return null
      }, 'openedWorkflowIndexShift'),
      _ = Vue.computed(() => Array.from(r.value).filter((e) => e.isPersisted)),
      g = __name(async (e = '') => {
        await syncEntities(
          e ? 'workflows/' + e : 'workflows',
          i.value,
          (e) =>
            new ComfyWorkflow({
              path: e.path,
              modified: e.modified,
              size: e.size
            }),
          (e, t) => {
            ;(e.lastModified = t.modified), (e.size = t.size), e.unload()
          },
          (e) => e.isTemporary
        )
      }, 'syncWorkflows'),
      v = useWorkflowBookmarkStore(),
      y = Vue.computed(() => r.value.filter((e) => v.isBookmarked(e.path))),
      b = Vue.computed(() => r.value.filter((e) => e.isModified)),
      S = Vue.ref(!1),
      C = __name(async (n, o) => {
        S.value = !0
        try {
          const i = n.path,
            r = v.isBookmarked(i),
            a = e(n)
          try {
            await n.rename(o)
          } finally {
            t(n, a)
          }
          r && (v.setBookmarked(i, !1), v.setBookmarked(o, !0))
        } finally {
          S.value = !1
        }
      }, 'renameWorkflow'),
      w = __name(async (e) => {
        S.value = !0
        try {
          await e.delete(),
            v.isBookmarked(e.path) && v.setBookmarked(e.path, !1),
            delete i.value[e.path]
        } finally {
          S.value = !1
        }
      }, 'deleteWorkflow'),
      k = __name(async (n) => {
        S.value = !0
        try {
          const o = e(n)
          try {
            await n.save()
          } finally {
            t(n, o)
          }
        } finally {
          S.value = !1
        }
      }, 'saveWorkflow')
    return {
      activeWorkflow: n,
      isActive: o,
      openWorkflows: c,
      openedWorkflowIndexShift: f,
      openWorkflow: u,
      isOpen: d,
      isBusy: S,
      closeWorkflow: m,
      createTemporary: h,
      renameWorkflow: C,
      deleteWorkflow: w,
      saveWorkflow: k,
      workflows: r,
      bookmarkedWorkflows: y,
      persistedWorkflows: _,
      modifiedWorkflows: b,
      getWorkflowByPath: a,
      syncWorkflows: g
    }
  }),
  useWorkflowBookmarkStore = defineStore('workflowBookmark', () => {
    const e = Vue.ref(new Set()),
      t = __name((t) => e.value.has(t), 'isBookmarked'),
      n = __name(async () => {
        const t = await api.getUserData('workflows/.index.json')
        if (200 === t.status) {
          const n = await t.json()
          e.value = new Set(n?.favorites ?? [])
        }
      }, 'loadBookmarks'),
      o = __name(async () => {
        await api.storeUserData('workflows/.index.json', {
          favorites: Array.from(e.value)
        })
      }, 'saveBookmarks'),
      i = __name((t, n) => {
        e.value.has(t) !== n && (n ? e.value.add(t) : e.value.delete(t), o())
      }, 'setBookmarked'),
      r = __name((t) => {
        i(t, !e.value.has(t))
      }, 'toggleBookmarked')
    return {
      isBookmarked: t,
      loadBookmarks: n,
      saveBookmarks: o,
      setBookmarked: i,
      toggleBookmarked: r
    }
  })
async function getFilename(e) {
  if (useSettingStore().get('Comfy.PromptFilename')) {
    let t = await showPromptDialog({
      title: 'Export Workflow',
      message: 'Enter the filename:',
      defaultValue: e
    })
    return t ? (t.toLowerCase().endsWith('.json') || (t += '.json'), t) : null
  }
  return e
}
__name(getFilename, 'getFilename')
const workflowService = {
  async exportWorkflow(e, t) {
    const n = useWorkflowStore().activeWorkflow
    n?.path && (e = n.filename)
    const o = await app$1.graphToPrompt(),
      i = JSON.stringify(o[t], null, 2),
      r = new Blob([i], { type: 'application/json' }),
      a = await getFilename(e)
    a && downloadBlob(a, r)
  },
  async saveWorkflowAs(e) {
    const n = await showPromptDialog({
      title: 'Save workflow',
      message: 'Enter the filename:',
      defaultValue: e.filename
    })
    if (!n) return
    const o = e.directory + '/' + appendJsonExt(n),
      i = o.substring(ComfyWorkflow.basePath.length),
      r = useWorkflowStore(),
      a = r.getWorkflowByPath(o)
    if (a && !a.isTemporary) {
      if (
        !0 !==
        (await showConfirmationDialog({
          title: t('sideToolbar.workflowTab.confirmOverwriteTitle'),
          type: 'overwrite',
          message: t('sideToolbar.workflowTab.confirmOverwrite'),
          itemList: [o]
        }))
      )
        return
      if (a.path === e.path) return void (await this.saveWorkflow(e))
      if (!(await this.deleteWorkflow(a, !0))) return
    }
    if (e.isTemporary) await this.renameWorkflow(e, o), await r.saveWorkflow(e)
    else {
      const t = r.createTemporary(i, e.activeState)
      await this.openWorkflow(t), await r.saveWorkflow(t)
    }
  },
  async saveWorkflow(e) {
    e.isTemporary
      ? await this.saveWorkflowAs(e)
      : await useWorkflowStore().saveWorkflow(e)
  },
  async loadDefaultWorkflow() {
    await app$1.loadGraphData(defaultGraph)
  },
  async loadBlankWorkflow() {
    await app$1.loadGraphData(blankGraph)
  },
  async reloadCurrentWorkflow() {
    const e = useWorkflowStore().activeWorkflow
    e && (await this.openWorkflow(e, { force: !0 }))
  },
  async openWorkflow(e, t = { force: !1 }) {
    if (useWorkflowStore().isActive(e) && !t.force) return
    const n = !e.isLoaded
    n && (await e.load()),
      await app$1.loadGraphData(Vue.toRaw(e.activeState), !0, !0, e, {
        showMissingModelsDialog: n,
        showMissingNodesDialog: n
      })
  },
  async closeWorkflow(e, n = { warnIfUnsaved: !0 }) {
    if (!e.isLoaded) return !0
    if (e.isModified && n.warnIfUnsaved) {
      const n = await showConfirmationDialog({
        title: t('sideToolbar.workflowTab.dirtyCloseTitle'),
        type: 'dirtyClose',
        message: t('sideToolbar.workflowTab.dirtyClose'),
        itemList: [e.path]
      })
      if (null === n) return !1
      !0 === n && (await this.saveWorkflow(e))
    }
    const o = useWorkflowStore()
    return (
      1 === o.openWorkflows.length && (await this.loadDefaultWorkflow()),
      o.isActive(e) && (await this.loadNextOpenedWorkflow()),
      await o.closeWorkflow(e),
      !0
    )
  },
  async renameWorkflow(e, t) {
    await useWorkflowStore().renameWorkflow(e, t)
  },
  async deleteWorkflow(e, n = !1) {
    let o = !useSettingStore().get('Comfy.Workflow.ConfirmDelete') || n
    if (
      !o &&
      ((o = await showConfirmationDialog({
        title: t('sideToolbar.workflowTab.confirmDeleteTitle'),
        type: 'delete',
        message: t('sideToolbar.workflowTab.confirmDelete'),
        itemList: [e.path]
      })),
      !o)
    )
      return !1
    const i = useWorkflowStore()
    if (i.isOpen(e)) {
      if (!(await this.closeWorkflow(e, { warnIfUnsaved: !o }))) return !1
    }
    return (
      await i.deleteWorkflow(e),
      n ||
        useToastStore().add({
          severity: 'info',
          summary: t('sideToolbar.workflowTab.deleted'),
          life: 1e3
        }),
      !0
    )
  },
  beforeLoadNewGraph() {
    const e = useWorkspaceStore().workflow.activeWorkflow
    e && e.changeTracker.store()
  },
  async afterLoadNewGraph(e, t) {
    const n = useWorkspaceStore().workflow
    if ('string' == typeof e) {
      const o = n.getWorkflowByPath(ComfyWorkflow.basePath + appendJsonExt(e))
      if (o?.isPersisted) {
        const e = await n.openWorkflow(o)
        return e.changeTracker.restore(), void e.changeTracker.reset(t)
      }
    }
    if (null === e || 'string' == typeof e) {
      const o = e,
        i = n.createTemporary(o ? appendJsonExt(o) : void 0, t)
      return void (await n.openWorkflow(i))
    }
    const o = await n.openWorkflow(e)
    o.changeTracker.reset(t), o.changeTracker.restore()
  },
  async insertWorkflow(e) {
    const t = (await e.load()).initialState,
      n = localStorage.getItem('litegrapheditor_clipboard'),
      o = new LGraph(t),
      i = document.createElement('canvas'),
      r = new LGraphCanvas(i, o, { skip_events: !0, skip_render: !0 })
    r.selectNodes(),
      r.copyToClipboard(),
      app$1.canvas.pasteFromClipboard(),
      null !== n && localStorage.setItem('litegrapheditor_clipboard', n)
  },
  async loadNextOpenedWorkflow() {
    const e = useWorkflowStore().openedWorkflowIndexShift(1)
    e && (await this.openWorkflow(e))
  },
  async loadPreviousOpenedWorkflow() {
    const e = useWorkflowStore().openedWorkflowIndexShift(-1)
    e && (await this.openWorkflow(e))
  },
  async duplicateWorkflow(e) {
    const t = JSON.parse(JSON.stringify(e.activeState))
    await app$1.loadGraphData(t, !0, !0, e.filename)
  }
}
function serialise(e, t) {
  const n = { nodes: [], links: [] }
  let o = 0
  const i = []
  for (const r of e) !1 !== r.clonable && ((r._relative_id = o++), i.push(r))
  for (const r of i) {
    const e = r.clone()
    if (e) {
      if ((n.nodes.push(e.serialize()), r.inputs?.length))
        for (const o of r.inputs) {
          if (!o || null == o.link) continue
          const e = t.links.get(o.link)
          if (!e) continue
          const i = t.getNodeById(e.origin_id)
          i &&
            n.links.push([
              i._relative_id,
              e.origin_slot,
              r._relative_id,
              e.target_slot,
              i.id
            ])
        }
    } else console.warn('node type not found: ' + r.type)
  }
  return JSON.stringify(n)
}
function deserialiseAndCreate(e, t) {
  if (!e) return
  const { graph: n, graph_mouse: o } = t
  t.emitBeforeChange()
  try {
    n.beforeChange()
    const i = JSON.parse(e),
      r = [1 / 0, 1 / 0]
    for (const { pos: e } of i.nodes)
      r[0] > e[0] && (r[0] = e[0]), r[1] > e[1] && (r[1] = e[1])
    ;(Number.isFinite(r[0]) && Number.isFinite(r[1])) ||
      ((r[0] = o[0]), (r[1] = o[1]))
    const a = []
    for (const e of i.nodes) {
      const t = LiteGraph.createNode(e.type)
      t &&
        (t.configure(e),
        (t.pos[0] += o[0] - r[0]),
        (t.pos[1] += o[1] - r[1]),
        n.add(t, !0),
        a.push(t))
    }
    for (const e of i.links) {
      const t = e[0],
        n = null != t ? a[t] : void 0,
        o = a[e[2]]
      n && o
        ? n.connect(e[1], o, e[3])
        : console.warn('Warning, nodes missing on pasting')
    }
    t.selectNodes(a), n.afterChange()
  } finally {
    t.emitAfterChange()
  }
}
__name(serialise, 'serialise'),
  __name(deserialiseAndCreate, 'deserialiseAndCreate'),
  (window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.vintageClipboard = window.comfyAPI.vintageClipboard || {}),
  (window.comfyAPI.vintageClipboard.serialise = serialise),
  (window.comfyAPI.vintageClipboard.deserialiseAndCreate = deserialiseAndCreate)
const ANIM_PREVIEW_WIDGET = '$$comfy_animation_preview'
function sanitizeNodeName(e) {
  let t = { '&': '', '<': '', '>': '', '"': '', "'": '', '`': '', '=': '' }
  return String(e).replace(
    /[&<>"'`=]/g,
    __name(function (e) {
      return t[e]
    }, 'fromEntityMap')
  )
}
__name(sanitizeNodeName, 'sanitizeNodeName')
class ComfyApp {
  static {
    __name(this, 'ComfyApp')
  }
  #se = []
  #le = !1
  static clipspace = null
  static clipspace_invalidate_handler = null
  static open_maskeditor = null
  static clipspace_return_node = null
  vueAppReady
  api
  ui
  extensions
  extensionManager
  _nodeOutputs
  nodePreviewImages
  graph
  canvas
  dragOverNode
  canvasEl
  zoom_drag_start
  lastNodeErrors
  lastExecutionError
  progress
  configuringGraph
  ctx
  bodyTop
  bodyLeft
  bodyRight
  bodyBottom
  canvasContainer
  menu
  bypassBgColor
  openClipspace = __name(() => {}, 'openClipspace')
  get runningNodeId() {
    return useExecutionStore().executingNodeId
  }
  get shiftDown() {
    return useWorkspaceStore().shiftDown
  }
  get widgets() {
    return this.vueAppReady ? useWidgetStore().widgets : ComfyWidgets
  }
  get storageLocation() {
    return 'server'
  }
  get isNewUserSession() {
    return !1
  }
  constructor() {
    ;(this.vueAppReady = !1),
      (this.ui = new ComfyUI(this)),
      (this.api = api),
      (this.bodyTop = $el('div.comfyui-body-top', { parent: document.body })),
      (this.bodyLeft = $el('div.comfyui-body-left', { parent: document.body })),
      (this.bodyRight = $el('div.comfyui-body-right', {
        parent: document.body
      })),
      (this.bodyBottom = $el('div.comfyui-body-bottom', {
        parent: document.body
      })),
      (this.canvasContainer = $el('div.graph-canvas-container', {
        parent: document.body
      })),
      (this.menu = new ComfyAppMenu(this)),
      (this.bypassBgColor = '#FF00FF'),
      (this.extensions = []),
      (this.nodeOutputs = {}),
      (this.nodePreviewImages = {})
  }
  get nodeOutputs() {
    return this._nodeOutputs
  }
  set nodeOutputs(e) {
    ;(this._nodeOutputs = e), this.#ce('onNodeOutputsUpdated', e)
  }
  getPreviewFormatParam() {
    let e = this.ui.settings.getSettingValue('Comfy.PreviewFormat')
    return e ? `&preview=${e}` : ''
  }
  getRandParam() {
    return '&rand=' + Math.random()
  }
  static isImageNode(e) {
    return (
      e.imgs ||
      (e && e.widgets && e.widgets.findIndex((e) => 'image' === e.name) >= 0)
    )
  }
  static onClipspaceEditorSave() {
    ComfyApp.clipspace_return_node &&
      ComfyApp.pasteFromClipspace(ComfyApp.clipspace_return_node)
  }
  static onClipspaceEditorClosed() {
    ComfyApp.clipspace_return_node = null
  }
  static copyToClipspace(e) {
    var t = null
    e.widgets &&
      (t = e.widgets.map(({ type: e, name: t, value: n }) => ({
        type: e,
        name: t,
        value: n
      })))
    var n = void 0,
      o = void 0
    if (null != e.imgs) {
      ;(n = []), (o = [])
      for (let t = 0; t < e.imgs.length; t++)
        (n[t] = new Image()), (n[t].src = e.imgs[t].src), (o[t] = n[t])
    }
    var i = 0
    e.imageIndex && (i = e.imageIndex),
      (ComfyApp.clipspace = {
        widgets: t,
        imgs: n,
        original_imgs: o,
        images: e.images,
        selectedIndex: i,
        img_paste_mode: 'selected'
      }),
      (ComfyApp.clipspace_return_node = null),
      ComfyApp.clipspace_invalidate_handler &&
        ComfyApp.clipspace_invalidate_handler()
  }
  static pasteFromClipspace(e) {
    if (ComfyApp.clipspace) {
      if (
        ComfyApp.clipspace.imgs &&
        e.imgs &&
        (e.images &&
          ComfyApp.clipspace.images &&
          ('selected' == ComfyApp.clipspace.img_paste_mode
            ? (e.images = [
                ComfyApp.clipspace.images[ComfyApp.clipspace.selectedIndex]
              ])
            : (e.images = ComfyApp.clipspace.images),
          app$1.nodeOutputs[e.id + ''] &&
            (app$1.nodeOutputs[e.id + ''].images = e.images)),
        ComfyApp.clipspace.imgs)
      )
        if ('selected' == ComfyApp.clipspace.img_paste_mode) {
          const t = new Image()
          ;(t.src =
            ComfyApp.clipspace.imgs[ComfyApp.clipspace.selectedIndex].src),
            (e.imgs = [t]),
            (e.imageIndex = 0)
        } else {
          const t = []
          for (let n = 0; n < ComfyApp.clipspace.imgs.length; n++)
            (t[n] = new Image()),
              (t[n].src = ComfyApp.clipspace.imgs[n].src),
              (e.imgs = t)
        }
      if (e.widgets) {
        if (ComfyApp.clipspace.images) {
          const t = ComfyApp.clipspace.images[ComfyApp.clipspace.selectedIndex],
            n = e.widgets.findIndex((e) => 'image' === e.name)
          n >= 0 &&
            ('image' != e.widgets[n].type &&
            'string' == typeof e.widgets[n].value &&
            t.filename
              ? (e.widgets[n].value =
                  (t.subfolder ? t.subfolder + '/' : '') +
                  t.filename +
                  (t.type ? ` [${t.type}]` : ''))
              : (e.widgets[n].value = t))
        }
        ComfyApp.clipspace.widgets &&
          ComfyApp.clipspace.widgets.forEach(
            ({ type: t, name: n, value: o }) => {
              const i = Object.values(e.widgets).find(
                (e) => e.type === t && e.name === n
              )
              i &&
                'button' != i.type &&
                ('image' != i.type && 'string' == typeof i.value && o.filename
                  ? (i.value =
                      (o.subfolder ? o.subfolder + '/' : '') +
                      o.filename +
                      (o.type ? ` [${o.type}]` : ''))
                  : ((i.value = o), i.callback(o)))
            }
          )
      }
      app$1.graph.setDirtyCanvas(!0)
    }
  }
  get enabledExtensions() {
    return this.vueAppReady
      ? useExtensionStore().enabledExtensions
      : this.extensions
  }
  #ce(e, ...t) {
    let n = []
    for (const i of this.enabledExtensions)
      if (e in i)
        try {
          n.push(i[e](...t, this))
        } catch (o) {
          console.error(
            `Error calling extension '${i.name}' method '${e}'`,
            { error: o },
            { extension: i },
            { args: t }
          )
        }
    return n
  }
  async #de(e, ...t) {
    return await Promise.all(
      this.enabledExtensions.map(async (n) => {
        if (e in n)
          try {
            return await n[e](...t, this)
          } catch (o) {
            console.error(
              `Error calling extension '${n.name}' method '${e}'`,
              { error: o },
              { extension: n },
              { args: t }
            )
          }
      })
    )
  }
  #ue() {
    const e = LGraph$1.prototype.serialize,
      t = this
    LGraph$1.prototype.serialize = function () {
      const n = e.apply(this, arguments)
      return (
        useSettingStore().get('Comfy.EnableWorkflowViewRestore')
          ? (n.extra || (n.extra = {}),
            (n.extra.ds = {
              scale: t.canvas.ds.scale,
              offset: t.canvas.ds.offset
            }))
          : n.extra?.ds && delete n.extra.ds,
        n
      )
    }
  }
  #pe(e) {
    function t(e) {
      return void 0 === window.ClipboardItem
        ? []
        : [
            {
              content: 'Copy Image',
              callback: __name(async () => {
                const t = new URL(e.src)
                t.searchParams.delete('preview')
                const n = __name(async (e) => {
                  await navigator.clipboard.write([
                    new ClipboardItem({ [e.type]: e })
                  ])
                }, 'writeImage')
                try {
                  const i = await fetch(t),
                    r = await i.blob()
                  try {
                    await n(r)
                  } catch (o) {
                    if ('image/png' !== r.type) {
                      const t = $el('canvas', {
                          width: e.naturalWidth,
                          height: e.naturalHeight
                        }),
                        o = t.getContext('2d')
                      let i
                      if (void 0 === window.createImageBitmap) {
                        i = new Image()
                        const e = new Promise((e, t) => {
                          ;(i.onload = e), (i.onerror = t)
                        }).finally(() => {
                          URL.revokeObjectURL(i.src)
                        })
                        ;(i.src = URL.createObjectURL(r)), await e
                      } else i = await createImageBitmap(r)
                      try {
                        o.drawImage(i, 0, 0), t.toBlob(n, 'image/png')
                      } finally {
                        'function' == typeof i.close && i.close()
                      }
                      return
                    }
                    throw o
                  }
                } catch (o) {
                  useToastStore().addAlert(
                    'Error copying image: ' + (o.message ?? o)
                  )
                }
              }, 'callback')
            }
          ]
    }
    __name(t, 'getCopyImageOption'),
      (e.prototype.getExtraMenuOptions = function (e, n) {
        if (this.imgs) {
          let e
          null != this.imageIndex
            ? (e = this.imgs[this.imageIndex])
            : null != this.overIndex && (e = this.imgs[this.overIndex]),
            e &&
              n.unshift(
                {
                  content: 'Open Image',
                  callback: __name(() => {
                    let t = new URL(e.src)
                    t.searchParams.delete('preview'), window.open(t, '_blank')
                  }, 'callback')
                },
                ...t(e),
                {
                  content: 'Save Image',
                  callback: __name(() => {
                    const t = document.createElement('a')
                    let n = new URL(e.src)
                    n.searchParams.delete('preview'),
                      (t.href = n.toString()),
                      t.setAttribute(
                        'download',
                        new URLSearchParams(n.search).get('filename')
                      ),
                      document.body.append(t),
                      t.click(),
                      requestAnimationFrame(() => t.remove())
                  }, 'callback')
                }
              )
        }
        n.push({
          content: 'Bypass',
          callback: __name((e) => {
            this.mode === LGraphEventMode.BYPASS
              ? (this.mode = LGraphEventMode.ALWAYS)
              : (this.mode = LGraphEventMode.BYPASS),
              this.graph.change()
          }, 'callback')
        }),
          ComfyApp.clipspace_return_node ||
            (n.push({
              content: 'Copy (Clipspace)',
              callback: __name((e) => {
                ComfyApp.copyToClipspace(this)
              }, 'callback')
            }),
            null != ComfyApp.clipspace &&
              n.push({
                content: 'Paste (Clipspace)',
                callback: __name(() => {
                  ComfyApp.pasteFromClipspace(this)
                }, 'callback')
              }),
            ComfyApp.isImageNode(this) &&
              n.push({
                content: 'Open in MaskEditor',
                callback: __name((e) => {
                  ComfyApp.copyToClipspace(this),
                    (ComfyApp.clipspace_return_node = this),
                    ComfyApp.open_maskeditor()
                }, 'callback')
              }))
      })
  }
  #he(e) {
    const t = e.prototype.onKeyDown
    e.prototype.onKeyDown = function (e) {
      if (t && !1 === t.apply(this, e)) return !1
      if (this.flags.collapsed || !this.imgs || null === this.imageIndex) return
      let n = !1
      return (
        'ArrowLeft' === e.key || 'ArrowRight' === e.key
          ? ('ArrowLeft' === e.key
              ? (this.imageIndex -= 1)
              : 'ArrowRight' === e.key && (this.imageIndex += 1),
            (this.imageIndex %= this.imgs.length),
            this.imageIndex < 0 &&
              (this.imageIndex = this.imgs.length + this.imageIndex),
            (n = !0))
          : 'Escape' === e.key && ((this.imageIndex = null), (n = !0)),
        !0 === n
          ? (e.preventDefault(), e.stopImmediatePropagation(), !1)
          : void 0
      )
    }
  }
  #me(e) {
    const t = this
    function n(e) {
      let t
      if (null != e.imageOffset) t = e.imageOffset
      else if (e.widgets?.length) {
        const n = e.widgets[e.widgets.length - 1]
        ;(t = n.last_y),
          n.computeSize
            ? (t += n.computeSize()[1] + 4)
            : n.computedHeight
              ? (t += n.computedHeight)
              : (t += LiteGraph.NODE_WIDGET_HEIGHT + 4)
      } else t = e.computeSize()[1]
      return t
    }
    function o(e) {
      if (!this.flags.collapsed) {
        let d = [],
          u = !1
        const p = t.nodeOutputs[this.id + '']
        p?.images &&
          ((this.animatedImages = p?.animated?.find(Boolean)),
          this.images !== p.images &&
            ((this.images = p.images),
            (u = !0),
            (d = d.concat(
              p.images.map((e) =>
                api.apiURL(
                  '/view?' +
                    new URLSearchParams(e).toString() +
                    (this.animatedImages ? '' : t.getPreviewFormatParam()) +
                    t.getRandParam()
                )
              )
            ))))
        const h = t.nodePreviewImages[this.id + '']
        this.preview !== h &&
          ((this.preview = h), (u = !0), null != h && d.push(h)),
          u &&
            ((this.imageIndex = null),
            d.length > 0
              ? Promise.all(
                  d.map(
                    (e) =>
                      new Promise((t) => {
                        const n = new Image()
                        ;(n.onload = () => t(n)),
                          (n.onerror = () => t(null)),
                          (n.src = e)
                      })
                  )
                ).then((e) => {
                  ;(p && this.images !== p.images) ||
                    (h && this.preview !== h) ||
                    ((this.imgs = e.filter(Boolean)),
                    this.setSizeForImage?.(),
                    t.graph.setDirtyCanvas(!0))
                })
              : (this.imgs = null))
        const m = __name((e) => {
          let t = e[0].naturalWidth / e[0].naturalHeight
          for (let n = 1; n < e.length; n++) {
            if (t != e[n].naturalWidth / e[n].naturalHeight) return !1
          }
          return !0
        }, 'is_all_same_aspect_ratio')
        if (this.imgs?.length) {
          const d = this.widgets?.findIndex(
            (e) => e.name === ANIM_PREVIEW_WIDGET
          )
          if (this.animatedImages) {
            if (d > -1) {
              this.widgets[d].options.host.updateImages(this.imgs)
            } else {
              const e = createImageHost(this)
              this.setSizeForImage(!0)
              const t = this.addDOMWidget(ANIM_PREVIEW_WIDGET, 'img', e.el, {
                host: e,
                getHeight: e.getHeight,
                onDraw: e.onDraw,
                hideOnZoom: !1
              })
              ;(t.serializeValue = () => {}),
                t.options.host.updateImages(this.imgs)
            }
            return
          }
          d > -1 && (this.widgets[d].onRemove?.(), this.widgets.splice(d, 1))
          const u = t.graph.list_of_graphcanvas[0],
            p = u.graph_mouse
          !u.pointer_is_down &&
            this.pointerDown &&
            (p[0] === this.pointerDown.pos[0] &&
              p[1] === this.pointerDown.pos[1] &&
              (this.imageIndex = this.pointerDown.index),
            (this.pointerDown = null))
          let h = this.imageIndex
          const f = this.imgs.length
          1 !== f || h || (this.imageIndex = h = 0)
          const _ = n(this)
          var o = _
          let g = this.size[0],
            v = this.size[1]
          if (((v -= o), null == h)) {
            var i, r, a, s, l
            const t = m(this.imgs)
            if (t)
              (s = 0),
                ({
                  cellWidth: i,
                  cellHeight: r,
                  cols: l,
                  shiftX: a
                } = calculateImageGrid(this.imgs, g, v))
            else {
              s = 2
              const e = this.imgs.reduce(
                  (e, t) => Math.max(e, t.naturalWidth, t.naturalHeight),
                  0
                ),
                t = []
              ;(t.length = this.imgs.length),
                (t[0] = { naturalWidth: e, naturalHeight: e }),
                ({
                  cellWidth: i,
                  cellHeight: r,
                  cols: l,
                  shiftX: a
                } = calculateImageGrid(t, g, v))
            }
            let n = !1
            this.imageRects = []
            for (let d = 0; d < f; d++) {
              const h = this.imgs[d],
                m = Math.floor(d / l),
                f = d % l,
                _ = f * i + a,
                g = m * r + o
              if (
                !n &&
                ((n = LiteGraph.isInsideRectangle(
                  p[0],
                  p[1],
                  _ + this.pos[0],
                  g + this.pos[1],
                  i,
                  r
                )),
                n)
              ) {
                this.overIndex = d
                let t = 110
                u.pointer_is_down &&
                  ((this.pointerDown && this.pointerDown.index === d) ||
                    (this.pointerDown = { index: d, pos: [...p] }),
                  (t = 125)),
                  (e.filter = `contrast(${t}%) brightness(${t}%)`),
                  (u.canvas.style.cursor = 'pointer')
              }
              this.imageRects.push([_, g, i, r])
              let v = i / h.width,
                y = r / h.height
              var c = Math.min(v, y)
              let b = c * h.height,
                S = m * r + o + (r - b) / 2,
                C = c * h.width,
                w = f * i + a + (i - C) / 2
              e.drawImage(h, w + s, S + s, C - 2 * s, b - 2 * s),
                t ||
                  ((e.strokeStyle = '#8F8F8F'),
                  (e.lineWidth = 1),
                  e.strokeRect(_ + s, g + s, i - 2 * s, r - 2 * s)),
                (e.filter = 'none')
            }
            n || ((this.pointerDown = null), (this.overIndex = null))
          } else {
            let t = this.imgs[h].naturalWidth,
              n = this.imgs[h].naturalHeight
            const i = g / t,
              r = v / n,
              a = Math.min(i, r, 1)
            ;(t *= a), (n *= a)
            let s = (g - t) / 2,
              l = (v - n) / 2 + o
            e.drawImage(this.imgs[h], s, l, t, n)
            const c = __name((t, n, o, i) => {
              let r = '#333',
                a = '#fff',
                s = !1
              return (
                LiteGraph.isInsideRectangle(
                  p[0],
                  p[1],
                  t + this.pos[0],
                  n + this.pos[1],
                  o,
                  o
                )
                  ? ((u.canvas.style.cursor = 'pointer'),
                    u.pointer_is_down
                      ? ((r = '#1e90ff'), (s = !0))
                      : ((r = '#eee'), (a = '#000')))
                  : (this.pointerWasDown = null),
                (e.fillStyle = r),
                e.beginPath(),
                e.roundRect(t, n, o, o, [4]),
                e.fill(),
                (e.fillStyle = a),
                (e.font = '12px Arial'),
                (e.textAlign = 'center'),
                e.fillText(i, t + 15, n + 20),
                s
              )
            }, 'drawButton')
            if (f > 1) {
              if (c(g - 40, v + _ - 40, 30, `${this.imageIndex + 1}/${f}`)) {
                let e = this.imageIndex + 1 >= f ? 0 : this.imageIndex + 1
                ;(this.pointerDown && !this.pointerDown.index !== e) ||
                  (this.pointerDown = { index: e, pos: [...p] })
              }
              c(g - 40, _ + 10, 30, 'x') &&
                ((this.pointerDown && null !== !this.pointerDown.index) ||
                  (this.pointerDown = { index: null, pos: [...p] }))
            }
          }
        }
      }
    }
    __name(n, 'getImageTop'),
      (e.prototype.setSizeForImage = function (e) {
        if (!e && this.animatedImages) return
        if (this.inputHeight || this.freeWidgetSpace > 210)
          return void this.setSize(this.size)
        const t = n(this) + 220
        this.size[1] < t && this.setSize([this.size[0], t])
      }),
      __name(o, 'unsafeDrawBackground'),
      (e.prototype.onDrawBackground = function (e) {
        try {
          o.call(this, e)
        } catch (t) {
          console.error('Error drawing node background', t)
        }
      })
  }
  #fe() {
    document.addEventListener('drop', async (e) => {
      e.preventDefault(), e.stopPropagation()
      const t = this.dragOverNode
      if (
        ((this.dragOverNode = null),
        !(t && t.onDragDrop && (await t.onDragDrop(e))))
      )
        if (
          e.dataTransfer.files.length &&
          'image/bmp' !== e.dataTransfer.files[0].type
        )
          await this.handleFile(e.dataTransfer.files[0])
        else {
          const t = ['text/uri-list', 'text/x-moz-url'],
            n = [...e.dataTransfer.types].find((e) => t.find((t) => e === t))
          if (n) {
            const t = e.dataTransfer.getData(n)?.split('\n')?.[0]
            t && (await this.handleFile(await (await fetch(t)).blob()))
          }
        }
    }),
      this.canvasEl.addEventListener('dragleave', async () => {
        this.dragOverNode &&
          ((this.dragOverNode = null), this.graph.setDirtyCanvas(!1, !0))
      }),
      this.canvasEl.addEventListener(
        'dragover',
        (e) => {
          this.canvas.adjustMouseEvent(e)
          const t = this.graph.getNodeOnPos(e.canvasX, e.canvasY)
          if (t && t.onDragOver && t.onDragOver(e))
            return (
              (this.dragOverNode = t),
              void requestAnimationFrame(() => {
                this.graph.setDirtyCanvas(!1, !0)
              })
            )
          this.dragOverNode = null
        },
        !1
      )
  }
  #_e() {
    document.addEventListener('paste', async (e) => {
      if (this.shiftDown) return
      let t = e.clipboardData || window.clipboardData
      const n = t.items
      for (const s of n)
        if (s.type.startsWith('image/')) {
          var o = null
          if (
            (this.canvas.current_node &&
              this.canvas.current_node.is_selected &&
              ComfyApp.isImageNode(this.canvas.current_node) &&
              (o = this.canvas.current_node),
            !o)
          ) {
            const e = LiteGraph.createNode('LoadImage')
            ;(e.pos = [...this.canvas.graph_mouse]),
              (o = this.graph.add(e)),
              this.graph.change()
          }
          const e = s.getAsFile()
          return void o.pasteFile(e)
        }
      t = t.getData('text/plain')
      let i = null
      try {
        ;(t = t.slice(t.indexOf('{'))), (i = JSON.parse(t))
      } catch (r) {
        try {
          ;(t = t.slice(t.indexOf('workflow\n'))),
            (t = t.slice(t.indexOf('{'))),
            (i = JSON.parse(t))
        } catch (a) {
          i = null
        }
      }
      if (i && i.version && i.nodes && i.extra) await this.loadGraphData(i)
      else {
        if (
          (e.target instanceof HTMLTextAreaElement &&
            'textarea' === e.target.type) ||
          (e.target instanceof HTMLInputElement && 'text' === e.target.type)
        )
          return
        this.canvas.pasteFromClipboard()
      }
    })
  }
  #ge() {
    document.addEventListener('copy', (e) => {
      if (!(e.target instanceof Element)) return
      if (
        (e.target instanceof HTMLTextAreaElement &&
          'textarea' === e.target.type) ||
        (e.target instanceof HTMLInputElement && 'text' === e.target.type)
      )
        return
      return (e.target.classList.contains('litegraph') ||
        e.target.classList.contains('graph-canvas-container')) &&
        this.canvas.selected_nodes
        ? (this.canvas.copyToClipboard(),
          e.clipboardData.setData('text', ' '),
          e.preventDefault(),
          e.stopImmediatePropagation(),
          !1)
        : void 0
    })
  }
  #ve() {
    const e = this,
      t = LGraphCanvas.prototype.processMouseDown
    LGraphCanvas.prototype.processMouseDown = function (n) {
      if (
        useSettingStore().get('Comfy.Graph.CtrlShiftZoom') &&
        n.ctrlKey &&
        n.shiftKey &&
        !n.altKey &&
        n.buttons
      )
        return void (e.zoom_drag_start = [n.x, n.y, this.ds.scale])
      return t.apply(this, arguments)
    }
    const n = LGraphCanvas.prototype.processMouseMove
    LGraphCanvas.prototype.processMouseMove = function (t) {
      if (t.ctrlKey && t.shiftKey && e.zoom_drag_start) {
        if (!t.buttons) return void (e.zoom_drag_start = null)
        let n = t.y - e.zoom_drag_start[1],
          o = e.zoom_drag_start[2] - n / 100
        return (
          this.ds.changeScale(o, [e.zoom_drag_start[0], e.zoom_drag_start[1]]),
          void this.graph.change()
        )
      }
      return n.apply(this, arguments)
    }
  }
  #ye() {
    const e = LGraphCanvas.prototype.processKey
    LGraphCanvas.prototype.processKey = function (t) {
      if (this.graph) {
        var n = !1
        if (!(t.target instanceof Element && 'input' == t.target.localName)) {
          if ('keydown' == t.type && !t.repeat) {
            const e = KeyComboImpl.fromEvent(t),
              o = useKeybindingStore().getKeybinding(e)
            if (
              (o &&
                '#graph-canvas' === o.targetSelector &&
                (useCommandStore().execute(o.commandId), (n = !0)),
              'c' === t.key && (t.metaKey || t.ctrlKey))
            )
              return !0
            if (
              ('v' === t.key || 'V' == t.key) &&
              (t.metaKey || t.ctrlKey) &&
              !t.shiftKey
            )
              return !0
          }
          return (
            this.graph.change(),
            n
              ? (t.preventDefault(), t.stopImmediatePropagation(), !1)
              : e.apply(this, arguments)
          )
        }
      }
    }
  }
  #be() {
    const e = LGraphCanvas.prototype.drawGroups
    LGraphCanvas.prototype.drawGroups = function (t, n) {
      if (!this.graph) return
      var o = this.graph.groups
      n.save(), (n.globalAlpha = 0.7 * this.editor_alpha)
      for (var i = 0; i < o.length; ++i) {
        var r = o[i]
        if (LiteGraph.overlapBounding(this.visible_area, r._bounding)) {
          ;(n.fillStyle = r.color || '#335'),
            (n.strokeStyle = r.color || '#335')
          var a = r._pos,
            s = r._size
          ;(n.globalAlpha = 0.25 * this.editor_alpha), n.beginPath()
          var l = r.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE
          n.rect(a[0] + 0.5, a[1] + 0.5, s[0], 1.4 * l),
            n.fill(),
            (n.globalAlpha = this.editor_alpha)
        }
      }
      n.restore()
      return e.apply(this, arguments)
    }
  }
  #Se() {
    const e = LGraphCanvas.prototype.drawNodeShape,
      t = this
    LGraphCanvas.prototype.drawNodeShape = function (n, o, i, r, a, s) {
      const l = e.apply(this, arguments),
        c = t.lastNodeErrors?.[n.id]
      let d = null,
        u = 1
      if (
        (n.id === +t.runningNodeId
          ? (d = '#0f0')
          : t.dragOverNode && n.id === t.dragOverNode.id
            ? (d = 'dodgerblue')
            : c?.errors
              ? ((d = 'red'), (u = 2))
              : t.lastExecutionError &&
                +t.lastExecutionError.node_id === n.id &&
                ((d = '#f0f'), (u = 2)),
        d)
      ) {
        const e = n._shape || n.constructor.shape || LiteGraph.ROUND_SHAPE
        ;(o.lineWidth = u),
          (o.globalAlpha = 0.8),
          o.beginPath(),
          e == LiteGraph.BOX_SHAPE
            ? o.rect(
                -6,
                -6 - LiteGraph.NODE_TITLE_HEIGHT,
                12 + i[0] + 1,
                12 + i[1] + LiteGraph.NODE_TITLE_HEIGHT
              )
            : e == LiteGraph.ROUND_SHAPE ||
                (e == LiteGraph.CARD_SHAPE && n.flags.collapsed)
              ? o.roundRect(
                  -6,
                  -6 - LiteGraph.NODE_TITLE_HEIGHT,
                  12 + i[0] + 1,
                  12 + i[1] + LiteGraph.NODE_TITLE_HEIGHT,
                  2 * this.round_radius
                )
              : e == LiteGraph.CARD_SHAPE
                ? o.roundRect(
                    -6,
                    -6 - LiteGraph.NODE_TITLE_HEIGHT,
                    12 + i[0] + 1,
                    12 + i[1] + LiteGraph.NODE_TITLE_HEIGHT,
                    [2 * this.round_radius, 2 * this.round_radius, 2, 2]
                  )
                : e == LiteGraph.CIRCLE_SHAPE &&
                  o.arc(0.5 * i[0], 0.5 * i[1], 0.5 * i[0] + 6, 0, 2 * Math.PI),
          (o.strokeStyle = d),
          o.stroke(),
          (o.strokeStyle = r),
          (o.globalAlpha = 1)
      }
      if (
        (t.progress &&
          n.id === +t.runningNodeId &&
          ((o.fillStyle = 'green'),
          o.fillRect(0, 0, i[0] * (t.progress.value / t.progress.max), 6),
          (o.fillStyle = a)),
        c)
      ) {
        ;(o.lineWidth = 2), (o.strokeStyle = 'red')
        for (const e of c.errors)
          if (e.extra_info && e.extra_info.input_name) {
            const t = n.findInputSlot(e.extra_info.input_name)
            if (-1 !== t) {
              let e = n.getConnectionPos(!0, t)
              o.beginPath(),
                o.arc(e[0] - n.pos[0], e[1] - n.pos[1], 12, 0, 2 * Math.PI, !1),
                o.stroke()
            }
          }
      }
      return l
    }
    const n = LGraphCanvas.prototype.drawNode
    LGraphCanvas.prototype.drawNode = function (e, t) {
      const o = this.editor_alpha,
        i = e.color,
        r = e.bgcolor
      let a
      e.mode === LGraphEventMode.NEVER && (this.editor_alpha = 0.4),
        e.mode === LGraphEventMode.BYPASS
          ? ((a = app$1.bypassBgColor), (this.editor_alpha = 0.2))
          : (a = r || LiteGraph.NODE_DEFAULT_BGCOLOR)
      const s = {},
        l = useSettingStore().get('Comfy.Node.Opacity')
      l && (s.opacity = l),
        'light' === useSettingStore().get('Comfy.ColorPalette') &&
          ((s.lightness = 0.5),
          i && (e.color = adjustColor(i, { lightness: 0.5 }))),
        (e.bgcolor = adjustColor(a, s))
      const c = n.apply(this, arguments)
      return (this.editor_alpha = o), (e.color = i), (e.bgcolor = r), c
    }
  }
  #Ce() {
    api.addEventListener('status', ({ detail: e }) => {
      this.ui.setStatus(e)
    }),
      api.addEventListener('progress', ({ detail: e }) => {
        ;(this.progress = e), this.graph.setDirtyCanvas(!0, !1)
      }),
      api.addEventListener('executing', ({ detail: e }) => {
        ;(this.progress = null),
          this.graph.setDirtyCanvas(!0, !1),
          delete this.nodePreviewImages[this.runningNodeId]
      }),
      api.addEventListener('executed', ({ detail: e }) => {
        const t = this.nodeOutputs[e.display_node || e.node]
        if (e.merge && t)
          for (const o in e.output ?? {}) {
            const n = t[o]
            t[o] = n instanceof Array ? n.concat(e.output[o]) : e.output[o]
          }
        else this.nodeOutputs[e.display_node || e.node] = e.output
        const n = this.graph.getNodeById(e.display_node || e.node)
        n && n.onExecuted && n.onExecuted(e.output)
      }),
      api.addEventListener('execution_start', ({ detail: e }) => {
        ;(this.lastExecutionError = null),
          this.graph.nodes.forEach((e) => {
            e.onExecutionStart && e.onExecutionStart()
          })
      }),
      api.addEventListener('execution_error', ({ detail: e }) => {
        ;(this.lastExecutionError = e),
          showExecutionErrorDialog(e),
          this.canvas.draw(!0, !0)
      }),
      api.addEventListener('b_preview', ({ detail: e }) => {
        const t = this.runningNodeId
        if (null == t) return
        const n = e,
          o = URL.createObjectURL(n)
        this.nodePreviewImages[t] = [o]
      }),
      api.init()
  }
  #we() {
    const e = this,
      t = LGraph$1.prototype.configure
    LGraph$1.prototype.configure = function () {
      e.configuringGraph = !0
      try {
        return t.apply(this, arguments)
      } finally {
        e.configuringGraph = !1
      }
    }
  }
  #ke() {
    ;(app$1.canvas.getWidgetLinkType = function (e, t) {
      const n = useNodeDefStore().nodeDefsByName[t.type].inputs.getInput(e.name)
      return n?.type
    }),
      document.addEventListener('litegraph:canvas', async (e) => {
        if ('connectingWidgetLink' === e.detail.subType) {
          const { convertToInput: t } = await __vitePreload(
              async () => {
                const { convertToInput: e } = await import(
                  './widgetInputs-rxCYoFG8.js'
                )
                return { convertToInput: e }
              },
              [],
              import.meta.url
            ),
            { node: n, link: o, widget: i } = e.detail
          if (!n || !o || !i) return
          const r = n.constructor.nodeData
          if (!r) return
          const a = { ...r?.input?.required, ...r?.input?.optional }[i.name]
          if (!a) return
          const s = t(n, i, a)
          if (!s) return
          o.node.connect(o.slot, n, n.inputs.lastIndexOf(s))
        }
      })
  }
  #xe() {
    const e = this,
      t = e.graph.onConfigure
    e.graph.onConfigure = function () {
      for (const t of e.graph.nodes) t.onGraphConfigured?.()
      const n = t?.apply(this, arguments)
      for (const t of e.graph.nodes) t.onAfterGraphConfigured?.()
      return n
    }
  }
  async #Ee() {
    useExtensionStore().loadDisabledExtensionNames()
    const e = await api.getExtensions()
    await __vitePreload(
      () => import('./index-Ceqa5QT-.js'),
      __vite__mapDeps([7, 8, 9]),
      import.meta.url
    ),
      await Promise.all(
        e
          .filter((e) => !e.includes('extensions/core'))
          .map(async (e) => {
            try {
              await import(api.fileURL(e))
            } catch (t) {
              console.error('Error loading extension', e, t)
            }
          })
      )
  }
  async setup(e) {
    ;(this.canvasEl = e),
      (this.ui.menuContainer.style.display = 'block'),
      this.resizeCanvas(),
      await Promise.all([
        useWorkspaceStore().workflow.syncWorkflows(),
        this.ui.settings.load()
      ]),
      await this.#Ee(),
      this.#ve(),
      this.#ye(),
      this.#we(),
      this.#Ce(),
      this.#ue(),
      (this.graph = new LGraph$1()),
      this.#xe(),
      (this.canvas = new LGraphCanvas(e, this.graph)),
      (this.canvas.state = Vue.shallowReactive(this.canvas.state)),
      (this.ctx = e.getContext('2d')),
      (LiteGraph.alt_drag_do_clone_nodes = !0),
      this.graph.start(),
      this.resizeCanvas(),
      window.addEventListener('resize', () => this.resizeCanvas())
    const t = new ResizeObserver(() => this.resizeCanvas())
    t.observe(this.bodyTop),
      t.observe(this.bodyLeft),
      t.observe(this.bodyRight),
      t.observe(this.bodyBottom),
      await this.#de('init'),
      await this.registerNodes(),
      initWidgets(this)
    let n = !1
    try {
      const e = __name(async (e) => {
          if (e) {
            const t = JSON.parse(e),
              n = getStorageValue('Comfy.PreviousWorkflow')
            return await this.loadGraphData(t, !0, !0, n), !0
          }
        }, 'loadWorkflow'),
        t = api.initialClientId ?? api.clientId
      n =
        (t && (await e(sessionStorage.getItem(`workflow:${t}`)))) ||
        (await e(localStorage.getItem('workflow')))
    } catch (o) {
      console.error('Error loading previous workflow', o)
    }
    n || (await this.loadGraphData()),
      this.#Se(),
      this.#be(),
      this.#fe(),
      this.#ge(),
      this.#_e(),
      this.#ke(),
      await this.#de('setup')
  }
  resizeCanvas() {
    const e = Math.max(window.devicePixelRatio, 1)
    this.canvasEl.height = this.canvasEl.width = NaN
    const { width: t, height: n } = this.canvasEl.getBoundingClientRect()
    ;(this.canvasEl.width = Math.round(t * e)),
      (this.canvasEl.height = Math.round(n * e)),
      this.canvasEl.getContext('2d').scale(e, e),
      this.canvas?.draw(!0, !0)
  }
  updateVueAppNodeDefs(e) {
    const t = {
        ...Object.fromEntries(
          Object.entries(LiteGraph.registered_node_types).map(([e, t]) => [
            e,
            {
              name: e,
              display_name: e,
              category: t.category || '__frontend_only__',
              input: { required: {}, optional: {} },
              output: [],
              output_name: [],
              output_is_list: [],
              python_module: 'custom_nodes.frontend_only',
              description: `Frontend only node for ${e}`
            }
          ])
        ),
        ...e,
        ...SYSTEM_NODE_DEFS
      },
      n = useNodeDefStore(),
      o = Object.values(t)
    this.#ce('beforeRegisterVueAppNodeDefs', o, this), n.updateNodeDefs(o)
  }
  #Ie(e) {
    return Object.fromEntries(
      Object.entries(e).map(([e, n]) => [
        e,
        {
          ...n,
          display_name: t(
            `nodeDefs.${e}.display_name`,
            n.display_name ?? n.name
          ),
          description: n.description
            ? t(`nodeDefs.${e}.description`, n.description)
            : void 0
        }
      ])
    )
  }
  async #Te() {
    return this.#Ie(
      await api.getNodeDefs({
        validate: useSettingStore().get('Comfy.Validation.NodeDefs')
      })
    )
  }
  async registerNodes() {
    const e = await this.#Te()
    await this.registerNodesFromDefs(e),
      await this.#de('registerCustomNodes'),
      this.vueAppReady && this.updateVueAppNodeDefs(e)
  }
  getWidgetType(e, t) {
    const n = e[0]
    return Array.isArray(n)
      ? 'COMBO'
      : `${n}:${t}` in this.widgets
        ? `${n}:${t}`
        : n in this.widgets
          ? n
          : null
  }
  async registerNodeDef(e, t) {
    const n = this,
      o = class extends LGraphNode {
        static {
          __name(this, 'ComfyNode')
        }
        static comfyClass = t.name
        static title = t.display_name || t.name
        static nodeData = t
        static category
        constructor(e) {
          super(e)
          const o = t.input.required
          var i = t.input.required
          null != t.input.optional &&
            (i = Object.assign({}, t.input.required, t.input.optional))
          const r = { minWidth: 1, minHeight: 1 }
          for (const t in i) {
            const e = i[t],
              a = e[0],
              s = [a, e[1] ?? {}],
              l = o && t in o
            let c = !0
            const d = n.getWidgetType(s, t)
            if (d)
              'COMBO' === d
                ? Object.assign(r, n.widgets.COMBO(this, t, s, app$1) || {})
                : Object.assign(r, n.widgets[d](this, t, s, app$1) || {})
            else {
              const e = l ? {} : { shape: LiteGraph.SlotShape.HollowCircle }
              this.addInput(t, a, e), (c = !1)
            }
            c &&
              r?.widget &&
              ((r.widget.options ??= {}),
              l || (r.widget.options.inputIsOptional = !0),
              s[1]?.forceInput && (r.widget.options.forceInput = !0),
              s[1]?.defaultInput && (r.widget.options.defaultInput = !0),
              s[1]?.advanced && (r.widget.advanced = !0),
              s[1]?.hidden && (r.widget.hidden = !0))
          }
          for (const n in t.output) {
            let e = t.output[n]
            e instanceof Array && (e = 'COMBO')
            const o = t.output_name[n] || e,
              i = t.output_is_list[n] ? { shape: LiteGraph.GRID_SHAPE } : {}
            this.addOutput(o, e, i)
          }
          const a = this.computeSize()
          ;(a[0] = Math.max(r.minWidth, 1.5 * a[0])),
            (a[1] = Math.max(r.minHeight, a[1])),
            (this.size = a),
            (this.serialize_widgets = !0),
            app$1.#de('nodeCreated', this)
        }
        configure(e) {
          const t = __name((e, t) => {
            const n = { ...t }
            if (void 0 === e.widget && void 0 !== t.widget)
              return this.inputs.push(e), t
            for (const o of ['name', 'type', 'shape'])
              void 0 !== e[o] && (n[o] = e[o])
            return n
          }, 'merge')
          for (const n of ['inputs', 'outputs']) {
            const o = e[n] ?? []
            e[n] = o.map((e, o) => t(this[n][o] ?? {}, e))
          }
          super.configure(e)
        }
      }
    ;(o.prototype.comfyClass = t.name),
      this.#pe(o),
      this.#me(o),
      this.#he(o),
      await this.#de('beforeRegisterNodeDef', o, t),
      LiteGraph.registerNodeType(e, o),
      (o.category = t.category)
  }
  async registerNodesFromDefs(e) {
    await this.#de('addCustomNodeDefs', e)
    for (const t in e) this.registerNodeDef(t, e[t])
  }
  loadTemplateData(e) {
    if (!e?.templates) return
    const t = localStorage.getItem('litegrapheditor_clipboard')
    var n, o, i
    for (const r of e.templates) {
      if (!r?.data) continue
      JSON.parse(r.data).reroutes
        ? (localStorage.setItem('litegrapheditor_clipboard', r.data),
          app$1.canvas.pasteFromClipboard())
        : deserialiseAndCreate(r.data, app$1.canvas),
        (n = !1)
      for (const e in app$1.canvas.selected_nodes)
        (o = (i = app$1.canvas.selected_nodes[e]).pos[1] + i.size[1]),
          (!1 === n || o > n) && (n = o)
      app$1.canvas.graph_mouse[1] = n + 50
    }
    localStorage.setItem('litegrapheditor_clipboard', t)
  }
  #$e(e) {
    useSettingStore().get('Comfy.Workflow.ShowMissingNodesWarning') &&
      showLoadWorkflowWarning({ missingNodeTypes: e })
  }
  #Le(e, t) {
    useSettingStore().get('Comfy.Workflow.ShowMissingModelsWarning') &&
      showMissingModelsWarning({ missingModels: e, paths: t })
  }
  async loadGraphData(
    e,
    t = !0,
    n = !0,
    o = null,
    { showMissingNodesDialog: i = !0, showMissingModelsDialog: r = !0 } = {}
  ) {
    !1 !== t && this.clean()
    let a = !1
    if (
      (e || ((e = defaultGraph), (a = !0)),
      (e =
        'undefined' == typeof structuredClone
          ? JSON.parse(JSON.stringify(e))
          : structuredClone(e)),
      useSettingStore().get('Comfy.Validation.Workflows'))
    ) {
      e =
        (await validateComfyWorkflow(e, (e) => {
          useToastStore().addAlert(e)
        })) ?? e
    }
    workflowService.beforeLoadNewGraph()
    const s = [],
      l = []
    await this.#de('beforeConfigureGraph', e, s)
    for (let d of e.nodes)
      'T2IAdapterLoader' == d.type && (d.type = 'ControlNetLoader'),
        'ConditioningAverage ' == d.type && (d.type = 'ConditioningAverage'),
        'SDV_img2vid_Conditioning' == d.type &&
          (d.type = 'SVD_img2vid_Conditioning'),
        d.type in LiteGraph.registered_node_types ||
          (s.push(d.type), (d.type = sanitizeNodeName(d.type)))
    if (
      e.models &&
      useSettingStore().get('Comfy.Workflow.ShowMissingModelsWarning')
    )
      for (const d of e.models) {
        const e = await useModelStore().getLoadedModelFolder(d.directory)
        null === e
          ? ((d.directory_invalid = !0), l.push(d))
          : d.name in e.models || l.push(d)
      }
    try {
      this.graph.configure(e),
        n &&
          useSettingStore().get('Comfy.EnableWorkflowViewRestore') &&
          e.extra?.ds &&
          ((this.canvas.ds.offset = e.extra.ds.offset),
          (this.canvas.ds.scale = e.extra.ds.scale))
    } catch (c) {
      let e = []
      const t =
          c.fileName || (c.stack || '').match(/(\/extensions\/.*\.js)/)?.[1],
        n = (t || '').indexOf('/extensions/')
      return (
        n > -1 &&
          e.push(
            $el('span', {
              textContent: 'This may be due to the following script:'
            }),
            $el('br'),
            $el('span', {
              style: { fontWeight: 'bold' },
              textContent: t.substring(n)
            })
          ),
        void this.ui.dialog.show(
          $el('div', [
            $el('p', {
              textContent:
                'Loading aborted due to error reloading workflow data'
            }),
            $el('pre', {
              style: { padding: '5px', backgroundColor: 'rgba(255,0,0,0.2)' },
              textContent: c.toString()
            }),
            $el('pre', {
              style: {
                padding: '5px',
                color: '#ccc',
                fontSize: '10px',
                maxHeight: '50vh',
                overflow: 'auto',
                backgroundColor: 'rgba(0,0,0,0.2)'
              },
              textContent: c.stack || 'No stacktrace available'
            }),
            ...e
          ]).outerHTML
        )
      )
    }
    for (const d of this.graph.nodes) {
      const e = d.computeSize()
      if (
        ((e[0] = Math.max(d.size[0], e[0])),
        (e[1] = Math.max(d.size[1], e[1])),
        (d.size = e),
        d.widgets)
      )
        for (let t of d.widgets)
          ('KSampler' != d.type && 'KSamplerAdvanced' != d.type) ||
            ('sampler_name' == t.name &&
              'string' == typeof t.value &&
              t.value.startsWith('sample_') &&
              (t.value = t.value.slice(7))),
            ('KSampler' != d.type &&
              'KSamplerAdvanced' != d.type &&
              'PrimitiveNode' != d.type) ||
              ('control_after_generate' == t.name &&
                (!0 === t.value
                  ? (t.value = 'randomize')
                  : !1 === t.value && (t.value = 'fixed'))),
            a &&
              'combo' == t.type &&
              !t.options.values.includes(t.value) &&
              t.options.values.length > 0 &&
              (t.value = t.options.values[0])
      this.#ce('loadedGraphNode', d)
    }
    if ((s.length && i && this.#$e(s), l.length && r)) {
      const e = await api.getFolderPaths()
      this.#Le(l, e)
    }
    await this.#de('afterConfigureGraph', s),
      await workflowService.afterLoadNewGraph(o, this.graph.serialize()),
      requestAnimationFrame(() => {
        this.graph.setDirtyCanvas(!0, !0)
      })
  }
  serializeGraph(e = this.graph) {
    const t = useSettingStore().get('Comfy.Workflow.SortNodeIdOnSave')
    return e.serialize({ sortNodes: t })
  }
  async graphToPrompt(e = this.graph, t = !0) {
    for (const i of this.graph.computeExecutionOrder(!1)) {
      if (i.widgets) for (const t of i.widgets) t.beforeQueued?.()
      const e = i.getInnerNodes ? i.getInnerNodes() : [i]
      for (const t of e) t.isVirtualNode && t.applyToGraph && t.applyToGraph()
    }
    const n = this.serializeGraph(e),
      o = {}
    for (const i of e.computeExecutionOrder(!1)) {
      const e =
        !(
          i.mode === LGraphEventMode.NEVER || i.mode === LGraphEventMode.BYPASS
        ) && i.getInnerNodes
          ? i.getInnerNodes()
          : [i]
      for (const t of e) {
        if (t.isVirtualNode) continue
        if (
          t.mode === LGraphEventMode.NEVER ||
          t.mode === LGraphEventMode.BYPASS
        )
          continue
        const e = {},
          n = t.widgets
        if (n)
          for (const o in n) {
            const i = n[o]
            ;(i.options && !1 === i.options.serialize) ||
              (e[i.name] = i.serializeValue
                ? await i.serializeValue(t, o)
                : i.value)
          }
        for (let o in t.inputs) {
          let n = t.getInputNode(o)
          if (n) {
            let i = t.getInputLink(o)
            for (; n.mode === LGraphEventMode.BYPASS || n.isVirtualNode; ) {
              let e = !1
              if (n.isVirtualNode)
                (i = n.getInputLink(i.origin_slot)),
                  i && ((n = n.getInputNode(i.target_slot)), n && (e = !0))
              else if (i && n.mode === LGraphEventMode.BYPASS) {
                let r = [i.origin_slot]
                if (n.inputs) {
                  r = r.concat(Object.keys(n.inputs))
                  for (let a in r)
                    if (((a = r[a]), n.inputs[a]?.type === t.inputs[o].type)) {
                      ;(i = n.getInputLink(a)),
                        i && (n = n.getInputNode(a)),
                        (e = !0)
                      break
                    }
                }
              }
              if (!e) break
            }
            i &&
              (n?.updateLink && (i = n.updateLink(i)),
              i &&
                (e[t.inputs[o].name] = [
                  String(i.origin_id),
                  parseInt(i.origin_slot)
                ]))
          }
        }
        const i = { inputs: e, class_type: t.comfyClass }
        ;(i._meta = { title: t.title }), (o[String(t.id)] = i)
      }
    }
    if (t)
      for (const i in o)
        for (const e in o[i].inputs)
          Array.isArray(o[i].inputs[e]) &&
            2 === o[i].inputs[e].length &&
            !o[o[i].inputs[e][0]] &&
            delete o[i].inputs[e]
    return { workflow: n, output: o }
  }
  #Ae(e) {
    if (null == e) return '(unknown error)'
    if ('string' == typeof e) return e
    if (e.stack && e.message) return e.toString()
    if (e.response) {
      let t = e.response.error.message
      e.response.error.details && (t += ': ' + e.response.error.details)
      for (const [n, o] of Object.entries(e.response.node_errors)) {
        t += '\n' + o.class_type + ':'
        for (const e of o.errors) t += '\n    - ' + e.message + ': ' + e.details
      }
      return t
    }
    return '(unknown error)'
  }
  async queuePrompt(e, t = 1) {
    if ((this.#se.push({ number: e, batchCount: t }), !this.#le)) {
      ;(this.#le = !0), (this.lastNodeErrors = null)
      try {
        for (; this.#se.length; ) {
          ;({ number: e, batchCount: t } = this.#se.pop())
          for (let o = 0; o < t; o++) {
            const t = await this.graphToPrompt()
            try {
              const o = await api.queuePrompt(e, t)
              if (
                ((this.lastNodeErrors = o.node_errors),
                this.lastNodeErrors.length > 0)
              )
                this.canvas.draw(!0, !0)
              else
                try {
                  useExecutionStore().storePrompt({
                    id: o.prompt_id,
                    nodes: Object.keys(t.output),
                    workflow: useWorkspaceStore().workflow.activeWorkflow
                  })
                } catch (n) {}
            } catch (n) {
              const e = this.#Ae(n)
              this.ui.dialog.show(e),
                n.response &&
                  ((this.lastNodeErrors = n.response.node_errors),
                  this.canvas.draw(!0, !0))
              break
            }
            for (const e of t.workflow.nodes) {
              const t = this.graph.getNodeById(e.id)
              if (t.widgets)
                for (const e of t.widgets) e.afterQueued && e.afterQueued()
            }
            this.canvas.draw(!0, !0), await this.ui.queue.update()
          }
        }
      } finally {
        this.#le = !1
      }
      return (
        api.dispatchCustomEvent('promptQueued', { number: e, batchCount: t }),
        !this.lastNodeErrors
      )
    }
  }
  showErrorOnFileLoad(e) {
    this.ui.dialog.show(
      $el('div', [
        $el('p', { textContent: `Unable to find workflow in ${e.name}` })
      ]).outerHTML
    )
  }
  async handleFile(e) {
    const t = __name((e) => {
      if (!e) return e
      const t = e.lastIndexOf('.')
      return -1 === t ? e : e.substring(0, t)
    }, 'removeExt')(e.name)
    if ('image/png' === e.type) {
      const n = await getPngMetadata(e)
      n?.workflow
        ? await this.loadGraphData(JSON.parse(n.workflow), !0, !0, t)
        : n?.prompt
          ? this.loadApiJson(JSON.parse(n.prompt), t)
          : n?.parameters
            ? (workflowService.beforeLoadNewGraph(),
              importA1111(this.graph, n.parameters),
              workflowService.afterLoadNewGraph(t, this.serializeGraph()))
            : this.showErrorOnFileLoad(e)
    } else if ('image/webp' === e.type) {
      const n = await getWebpMetadata(e),
        o = n?.workflow || n?.Workflow,
        i = n?.prompt || n?.Prompt
      o
        ? this.loadGraphData(JSON.parse(o), !0, !0, t)
        : i
          ? this.loadApiJson(JSON.parse(i), t)
          : this.showErrorOnFileLoad(e)
    } else if ('audio/flac' === e.type || 'audio/x-flac' === e.type) {
      const n = await getFlacMetadata(e),
        o = n?.workflow || n?.Workflow,
        i = n?.prompt || n?.Prompt
      o
        ? this.loadGraphData(JSON.parse(o), !0, !0, t)
        : i
          ? this.loadApiJson(JSON.parse(i), t)
          : this.showErrorOnFileLoad(e)
    } else if ('application/json' === e.type || e.name?.endsWith('.json')) {
      const n = new FileReader()
      ;(n.onload = async () => {
        const e = n.result,
          o = JSON.parse(e)
        o?.templates
          ? this.loadTemplateData(o)
          : this.isApiJson(o)
            ? this.loadApiJson(o, t)
            : await this.loadGraphData(JSON.parse(e), !0, !1, t)
      }),
        n.readAsText(e)
    } else if (
      e.name?.endsWith('.latent') ||
      e.name?.endsWith('.safetensors')
    ) {
      const n = await getLatentMetadata(e)
      n.workflow
        ? await this.loadGraphData(JSON.parse(n.workflow), !0, !0, t)
        : n.prompt
          ? this.loadApiJson(JSON.parse(n.prompt))
          : this.showErrorOnFileLoad(e)
    } else this.showErrorOnFileLoad(e)
  }
  isApiJson(e) {
    return Object.values(e).every((e) => e.class_type)
  }
  loadApiJson(e, t) {
    workflowService.beforeLoadNewGraph()
    const n = Object.values(e).filter(
      (e) => !LiteGraph.registered_node_types[e.class_type]
    )
    if (n.length) return void this.#$e(n.map((e) => e.class_type))
    const o = Object.keys(e)
    app$1.graph.clear()
    for (const r of o) {
      const t = e[r],
        n = LiteGraph.createNode(t.class_type)
      ;(n.id = isNaN(+r) ? r : +r),
        (n.title = t._meta?.title ?? n.title),
        app$1.graph.add(n)
    }
    for (const r of o) {
      const t = e[r],
        n = app$1.graph.getNodeById(r)
      for (const e in t.inputs ?? {}) {
        const o = t.inputs[e]
        if (o instanceof Array) {
          const [t, r] = o,
            a = app$1.graph.getNodeById(t)
          let s = n.inputs?.findIndex((t) => t.name === e)
          if (null == s || -1 === s)
            try {
              const t = n.widgets?.find((t) => t.name === e)
              t && n.convertWidgetToInput?.(t) && (s = n.inputs?.length - 1)
            } catch (i) {}
          ;(null == s && -1 === s) || a.connect(r, n, s)
        } else {
          const t = n.widgets?.find((t) => t.name === e)
          t && ((t.value = o), t.callback?.(o))
        }
      }
    }
    app$1.graph.arrange()
    for (const r of o) {
      const t = e[r],
        n = app$1.graph.getNodeById(r)
      for (const e in t.inputs ?? {}) {
        const o = t.inputs[e]
        if (o instanceof Array) {
          const [t, r] = o,
            a = app$1.graph.getNodeById(t)
          let s = n.inputs?.findIndex((t) => t.name === e)
          if (null == s || -1 === s)
            try {
              const t = n.widgets?.find((t) => t.name === e)
              t && n.convertWidgetToInput?.(t) && (s = n.inputs?.length - 1)
            } catch (i) {}
          ;(null == s && -1 === s) || a.connect(r, n, s)
        } else {
          const t = n.widgets?.find((t) => t.name === e)
          t && ((t.value = o), t.callback?.(o))
        }
      }
    }
    app$1.graph.arrange(),
      workflowService.afterLoadNewGraph(t, this.serializeGraph())
  }
  registerExtension(e) {
    this.vueAppReady
      ? useExtensionStore().registerExtension(e)
      : this.extensions.push(e)
  }
  async refreshComboInNodes() {
    const e = {
      severity: 'info',
      summary: 'Update',
      detail: 'Update requested'
    }
    this.vueAppReady && useToastStore().add(e)
    const t = await this.#Te()
    for (const n in t) this.registerNodeDef(n, t[n])
    for (let n in this.graph.nodes) {
      const e = this.graph.nodes[n],
        o = t[e.type]
      if ((e.refreshComboInNode?.(t), o))
        for (const t in e.widgets) {
          const n = e.widgets[t]
          'combo' == n.type &&
            void 0 !== o.input.required[n.name] &&
            (n.options.values = o.input.required[n.name][0])
        }
    }
    await this.#de('refreshComboInNodes', t),
      this.vueAppReady &&
        (this.updateVueAppNodeDefs(t),
        useToastStore().remove(e),
        useToastStore().add({
          severity: 'success',
          summary: 'Updated',
          detail: 'Node definitions updated',
          life: 1e3
        }))
  }
  resetView() {
    ;(app$1.canvas.ds.scale = 1),
      (app$1.canvas.ds.offset = [0, 0]),
      app$1.graph.setDirtyCanvas(!0, !0)
  }
  clean() {
    ;(this.nodeOutputs = {}),
      (this.nodePreviewImages = {}),
      (this.lastNodeErrors = null),
      (this.lastExecutionError = null)
  }
  addNodeOnGraph(e, t = {}) {
    const n = LiteGraph.createNode(e.name, e.display_name, t)
    return this.graph.add(n), n
  }
  clientPosToCanvasPos(e) {
    const t = this.canvasContainer.getBoundingClientRect(),
      n = [t.left, t.top]
    return _.zip(e, this.canvas.ds.offset, n).map(
      ([e, t, n]) => (e - n) / this.canvas.ds.scale - t
    )
  }
  canvasPosToClientPos(e) {
    const t = this.canvasContainer.getBoundingClientRect(),
      n = [t.left, t.top]
    return _.zip(e, this.canvas.ds.offset, n).map(
      ([e, t, n]) => (e + t) * this.canvas.ds.scale + n
    )
  }
  getCanvasCenter() {
    const e = Math.max(window.devicePixelRatio ?? 1, 1),
      [t, n, o, i] = app$1.canvas.ds.visible_area
    return [t + o / e / 2, n + i / e / 2]
  }
  goToNode(e) {
    const t = this.graph.getNodeById(e)
    t && this.canvas.animateToBounds(t.boundingRect)
  }
}
const app$1 = new ComfyApp()
;(window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.app = window.comfyAPI.app || {}),
  (window.comfyAPI.app.ANIM_PREVIEW_WIDGET = ANIM_PREVIEW_WIDGET),
  (window.comfyAPI.app.ComfyApp = ComfyApp),
  (window.comfyAPI.app.app = app$1)
const CORE_SETTINGS = [
    {
      id: 'Comfy.Validation.Workflows',
      name: 'Validate workflows',
      type: 'boolean',
      defaultValue: !0
    },
    {
      id: 'Comfy.NodeSearchBoxImpl',
      category: ['Comfy', 'Node Search Box', 'Implementation'],
      experimental: !0,
      name: 'Node search box implementation',
      type: 'combo',
      options: ['default', 'litegraph (legacy)'],
      defaultValue: 'default'
    },
    {
      id: 'Comfy.LinkRelease.Action',
      category: ['LiteGraph', 'LinkRelease', 'Action'],
      name: 'Action on link release (No modifier)',
      type: 'combo',
      options: Object.values(LinkReleaseTriggerAction),
      defaultValue: LinkReleaseTriggerAction.CONTEXT_MENU
    },
    {
      id: 'Comfy.LinkRelease.ActionShift',
      category: ['LiteGraph', 'LinkRelease', 'ActionShift'],
      name: 'Action on link release (Shift)',
      type: 'combo',
      options: Object.values(LinkReleaseTriggerAction),
      defaultValue: LinkReleaseTriggerAction.SEARCH_BOX
    },
    {
      id: 'Comfy.NodeSearchBoxImpl.NodePreview',
      category: ['Comfy', 'Node Search Box', 'NodePreview'],
      name: 'Node preview',
      tooltip: 'Only applies to the default implementation',
      type: 'boolean',
      defaultValue: !0
    },
    {
      id: 'Comfy.NodeSearchBoxImpl.ShowCategory',
      category: ['Comfy', 'Node Search Box', 'ShowCategory'],
      name: 'Show node category in search results',
      tooltip: 'Only applies to the default implementation',
      type: 'boolean',
      defaultValue: !0
    },
    {
      id: 'Comfy.NodeSearchBoxImpl.ShowIdName',
      category: ['Comfy', 'Node Search Box', 'ShowIdName'],
      name: 'Show node id name in search results',
      tooltip: 'Only applies to the default implementation',
      type: 'boolean',
      defaultValue: !1
    },
    {
      id: 'Comfy.NodeSearchBoxImpl.ShowNodeFrequency',
      category: ['Comfy', 'Node Search Box', 'ShowNodeFrequency'],
      name: 'Show node frequency in search results',
      tooltip: 'Only applies to the default implementation',
      type: 'boolean',
      defaultValue: !1
    },
    {
      id: 'Comfy.Sidebar.Location',
      category: ['Appearance', 'Sidebar', 'Location'],
      name: 'Sidebar location',
      type: 'combo',
      options: ['left', 'right'],
      defaultValue: 'left'
    },
    {
      id: 'Comfy.Sidebar.Size',
      category: ['Appearance', 'Sidebar', 'Size'],
      name: 'Sidebar size',
      type: 'combo',
      options: ['normal', 'small'],
      defaultValue: __name(
        () => (window.innerWidth < 1600 ? 'small' : 'normal'),
        'defaultValue'
      )
    },
    {
      id: 'Comfy.TextareaWidget.FontSize',
      category: ['Appearance', 'Node Widget', 'TextareaWidget', 'FontSize'],
      name: 'Textarea widget font size',
      type: 'slider',
      defaultValue: 10,
      attrs: { min: 8, max: 24 }
    },
    {
      id: 'Comfy.TextareaWidget.Spellcheck',
      category: ['Comfy', 'Node Widget', 'TextareaWidget', 'Spellcheck'],
      name: 'Textarea widget spellcheck',
      type: 'boolean',
      defaultValue: !1
    },
    {
      id: 'Comfy.Workflow.SortNodeIdOnSave',
      name: 'Sort node IDs when saving workflow',
      type: 'boolean',
      defaultValue: !1
    },
    {
      id: 'Comfy.Graph.CanvasInfo',
      category: ['LiteGraph', 'Canvas', 'CanvasInfo'],
      name: 'Show canvas info on bottom left corner (fps, etc.)',
      type: 'boolean',
      defaultValue: !0
    },
    {
      id: 'Comfy.Node.ShowDeprecated',
      name: 'Show deprecated nodes in search',
      tooltip:
        'Deprecated nodes are hidden by default in the UI, but remain functional in existing workflows that use them.',
      type: 'boolean',
      defaultValue: !1
    },
    {
      id: 'Comfy.Node.ShowExperimental',
      name: 'Show experimental nodes in search',
      tooltip:
        'Experimental nodes are marked as such in the UI and may be subject to significant changes or removal in future versions. Use with caution in production workflows',
      type: 'boolean',
      defaultValue: !0
    },
    {
      id: 'Comfy.Node.Opacity',
      category: ['Appearance', 'Node', 'Opacity'],
      name: 'Node opacity',
      type: 'slider',
      defaultValue: 1,
      attrs: { min: 0.01, max: 1, step: 0.01 }
    },
    {
      id: 'Comfy.Workflow.ShowMissingNodesWarning',
      name: 'Show missing nodes warning',
      type: 'boolean',
      defaultValue: !0
    },
    {
      id: 'Comfy.Workflow.ShowMissingModelsWarning',
      name: 'Show missing models warning',
      type: 'boolean',
      defaultValue: !1,
      experimental: !0
    },
    {
      id: 'Comfy.Graph.ZoomSpeed',
      category: ['LiteGraph', 'Canvas', 'ZoomSpeed'],
      name: 'Canvas zoom speed',
      type: 'slider',
      defaultValue: 1.1,
      attrs: { min: 1.01, max: 2.5, step: 0.01 }
    },
    {
      id: 'Comfy.NodeLibrary.Bookmarks',
      name: 'Node library bookmarks with display name (deprecated)',
      type: 'hidden',
      defaultValue: [],
      deprecated: !0
    },
    {
      id: 'Comfy.NodeLibrary.Bookmarks.V2',
      name: 'Node library bookmarks v2 with unique name',
      type: 'hidden',
      defaultValue: []
    },
    {
      id: 'Comfy.NodeLibrary.BookmarksCustomization',
      name: 'Node library bookmarks customization',
      type: 'hidden',
      defaultValue: {}
    },
    {
      id: 'Comfy.Queue.ImageFit',
      name: 'Queue image fit',
      type: 'hidden',
      defaultValue: 'cover'
    },
    {
      id: 'Comfy.GroupSelectedNodes.Padding',
      category: ['LiteGraph', 'Group', 'Padding'],
      name: 'Group selected nodes padding',
      type: 'slider',
      defaultValue: 10,
      attrs: { min: 0, max: 100 }
    },
    {
      id: 'Comfy.Node.DoubleClickTitleToEdit',
      category: ['LiteGraph', 'Node', 'DoubleClickTitleToEdit'],
      name: 'Double click node title to edit',
      type: 'boolean',
      defaultValue: !0
    },
    {
      id: 'Comfy.Group.DoubleClickTitleToEdit',
      category: ['LiteGraph', 'Group', 'DoubleClickTitleToEdit'],
      name: 'Double click group title to edit',
      type: 'boolean',
      defaultValue: !0
    },
    {
      id: 'Comfy.Window.UnloadConfirmation',
      name: 'Show confirmation when closing window',
      type: 'boolean',
      defaultValue: !1
    },
    {
      id: 'Comfy.TreeExplorer.ItemPadding',
      category: ['Appearance', 'Tree Explorer', 'ItemPadding'],
      name: 'Tree explorer item padding',
      type: 'slider',
      defaultValue: 2,
      attrs: { min: 0, max: 8, step: 1 }
    },
    {
      id: 'Comfy.ModelLibrary.AutoLoadAll',
      name: 'Automatically load all model folders',
      tooltip:
        'If true, all folders will load as soon as you open the model library (this may cause delays while it loads). If false, root level model folders will only load once you click on them.',
      type: 'boolean',
      defaultValue: !1
    },
    {
      id: 'Comfy.ModelLibrary.NameFormat',
      name: 'What name to display in the model library tree view',
      tooltip:
        'Select "filename" to render a simplified view of the raw filename (without directory or ".safetensors" extension) in the model list. Select "title" to display the configurable model metadata title.',
      type: 'combo',
      options: ['filename', 'title'],
      defaultValue: 'title'
    },
    {
      id: 'Comfy.Locale',
      name: 'Language',
      type: 'combo',
      options: [
        { value: 'en', text: 'English' },
        { value: 'zh', text: '中文' },
        { value: 'ru', text: 'Русский' },
        { value: 'ja', text: '日本語' }
      ],
      defaultValue: __name(
        () => navigator.language.split('-')[0] || 'en',
        'defaultValue'
      )
    },
    {
      id: 'Comfy.NodeBadge.NodeSourceBadgeMode',
      category: ['LiteGraph', 'Node', 'NodeSourceBadgeMode'],
      name: 'Node source badge mode',
      type: 'combo',
      options: Object.values(NodeBadgeMode),
      defaultValue: NodeBadgeMode.HideBuiltIn
    },
    {
      id: 'Comfy.NodeBadge.NodeIdBadgeMode',
      category: ['LiteGraph', 'Node', 'NodeIdBadgeMode'],
      name: 'Node ID badge mode',
      type: 'combo',
      options: [NodeBadgeMode.None, NodeBadgeMode.ShowAll],
      defaultValue: NodeBadgeMode.ShowAll
    },
    {
      id: 'Comfy.NodeBadge.NodeLifeCycleBadgeMode',
      category: ['LiteGraph', 'Node', 'NodeLifeCycleBadgeMode'],
      name: 'Node life cycle badge mode',
      type: 'combo',
      options: [NodeBadgeMode.None, NodeBadgeMode.ShowAll],
      defaultValue: NodeBadgeMode.ShowAll
    },
    {
      id: 'Comfy.ConfirmClear',
      category: ['Comfy', 'Workflow', 'ConfirmClear'],
      name: 'Require confirmation when clearing workflow',
      type: 'boolean',
      defaultValue: !0
    },
    {
      id: 'Comfy.PromptFilename',
      category: ['Comfy', 'Workflow', 'PromptFilename'],
      name: 'Prompt for filename when saving workflow',
      type: 'boolean',
      defaultValue: !0
    },
    {
      id: 'Comfy.PreviewFormat',
      category: ['LiteGraph', 'Node Widget', 'PreviewFormat'],
      name: 'Preview image format',
      tooltip:
        'When displaying a preview in the image widget, convert it to a lightweight image, e.g. webp, jpeg, webp;50, etc.',
      type: 'text',
      defaultValue: ''
    },
    {
      id: 'Comfy.DisableSliders',
      category: ['LiteGraph', 'Node Widget', 'DisableSliders'],
      name: 'Disable node widget sliders',
      type: 'boolean',
      defaultValue: !1
    },
    {
      id: 'Comfy.DisableFloatRounding',
      category: ['LiteGraph', 'Node Widget', 'DisableFloatRounding'],
      name: 'Disable default float widget rounding.',
      tooltip:
        '(requires page reload) Cannot disable round when round is set by the node in the backend.',
      type: 'boolean',
      defaultValue: !1
    },
    {
      id: 'Comfy.FloatRoundingPrecision',
      category: ['LiteGraph', 'Node Widget', 'FloatRoundingPrecision'],
      name: 'Float widget rounding decimal places [0 = auto].',
      tooltip: '(requires page reload)',
      type: 'slider',
      attrs: { min: 0, max: 6, step: 1 },
      defaultValue: 0
    },
    {
      id: 'Comfy.EnableTooltips',
      category: ['LiteGraph', 'Node', 'EnableTooltips'],
      name: 'Enable Tooltips',
      type: 'boolean',
      defaultValue: !0
    },
    {
      id: 'Comfy.DevMode',
      name: 'Enable dev mode options (API save, etc.)',
      type: 'boolean',
      defaultValue: !1,
      onChange: __name((e) => {
        const t = document.getElementById('comfy-dev-save-api-button')
        t && (t.style.display = e ? 'flex' : 'none')
      }, 'onChange')
    },
    {
      id: 'Comfy.UseNewMenu',
      category: ['Comfy', 'Menu', 'UseNewMenu'],
      defaultValue: 'Top',
      name: 'Use new menu',
      type: 'combo',
      options: ['Disabled', 'Top', 'Bottom'],
      migrateDeprecatedValue: __name(
        (e) => ('Floating' === e ? 'Top' : e),
        'migrateDeprecatedValue'
      )
    },
    {
      id: 'Comfy.Workflow.WorkflowTabsPosition',
      name: 'Opened workflows position',
      type: 'combo',
      options: ['Sidebar', 'Topbar'],
      defaultValue: 'Sidebar'
    },
    {
      id: 'Comfy.Graph.CanvasMenu',
      category: ['LiteGraph', 'Canvas', 'CanvasMenu'],
      name: 'Show graph canvas menu',
      type: 'boolean',
      defaultValue: !0
    },
    {
      id: 'Comfy.QueueButton.BatchCountLimit',
      name: 'Batch count limit',
      tooltip:
        'The maximum number of tasks added to the queue at one button click',
      type: 'number',
      defaultValue: 100,
      versionAdded: '1.3.5'
    },
    {
      id: 'Comfy.Keybinding.UnsetBindings',
      name: 'Keybindings unset by the user',
      type: 'hidden',
      defaultValue: [],
      versionAdded: '1.3.7'
    },
    {
      id: 'Comfy.Keybinding.NewBindings',
      name: 'Keybindings set by the user',
      type: 'hidden',
      defaultValue: [],
      versionAdded: '1.3.7'
    },
    {
      id: 'Comfy.Extension.Disabled',
      name: 'Disabled extension names',
      type: 'hidden',
      defaultValue: [],
      versionAdded: '1.3.11'
    },
    {
      id: 'Comfy.Settings.ExtensionPanel',
      name: 'Show extension panel in settings dialog',
      type: 'boolean',
      defaultValue: !1,
      experimental: !0,
      versionAdded: '1.3.11'
    },
    {
      id: 'Comfy.Validation.NodeDefs',
      name: 'Validate node definitions (slow)',
      type: 'boolean',
      tooltip:
        'Recommended for node developers. This will validate all node definitions on startup.',
      defaultValue: !1,
      versionAdded: '1.3.14'
    },
    {
      id: 'Comfy.LinkRenderMode',
      category: ['LiteGraph', 'Graph', 'LinkRenderMode'],
      name: 'Link Render Mode',
      defaultValue: 2,
      type: 'combo',
      options: [
        { value: LiteGraph.STRAIGHT_LINK, text: 'Straight' },
        { value: LiteGraph.LINEAR_LINK, text: 'Linear' },
        { value: LiteGraph.SPLINE_LINK, text: 'Spline' },
        { value: LiteGraph.HIDDEN_LINK, text: 'Hidden' }
      ]
    },
    {
      id: 'Comfy.Node.AutoSnapLinkToSlot',
      category: ['LiteGraph', 'Node', 'AutoSnapLinkToSlot'],
      name: 'Auto snap link to node slot',
      tooltip:
        'When dragging a link over a node, the link automatically snap to a viable input slot on the node',
      type: 'boolean',
      defaultValue: !0,
      versionAdded: '1.3.29'
    },
    {
      id: 'Comfy.Node.SnapHighlightsNode',
      category: ['LiteGraph', 'Node', 'SnapHighlightsNode'],
      name: 'Snap highlights node',
      tooltip:
        'When dragging a link over a node with viable input slot, highlight the node',
      type: 'boolean',
      defaultValue: !0,
      versionAdded: '1.3.29'
    },
    {
      id: 'Comfy.Node.BypassAllLinksOnDelete',
      category: ['LiteGraph', 'Node', 'BypassAllLinksOnDelete'],
      name: 'Keep all links when deleting nodes',
      tooltip:
        'When deleting a node, attempt to reconnect all of its input and output links (bypassing the deleted node)',
      type: 'boolean',
      defaultValue: !0,
      versionAdded: '1.3.40'
    },
    {
      id: 'Comfy.Node.MiddleClickRerouteNode',
      category: ['LiteGraph', 'Node', 'MiddleClickRerouteNode'],
      name: 'Middle-click creates a new Reroute node',
      type: 'boolean',
      defaultValue: !0,
      versionAdded: '1.3.42'
    },
    {
      id: 'Comfy.RerouteBeta',
      category: ['LiteGraph', 'RerouteBeta'],
      name: 'Opt-in to the reroute beta test',
      tooltip:
        'Enables the new native reroutes.\n\nReroutes can be added by holding alt and dragging from a link line, or on the link menu.\n\nDisabling this option is non-destructive - reroutes are hidden.',
      experimental: !0,
      type: 'boolean',
      defaultValue: !1,
      versionAdded: '1.3.42'
    },
    {
      id: 'Comfy.Graph.LinkMarkers',
      category: ['LiteGraph', 'Link', 'LinkMarkers'],
      name: 'Link midpoint markers',
      defaultValue: LinkMarkerShape.Circle,
      type: 'combo',
      options: [
        { value: LinkMarkerShape.None, text: 'None' },
        { value: LinkMarkerShape.Circle, text: 'Circle' },
        { value: LinkMarkerShape.Arrow, text: 'Arrow' }
      ],
      versionAdded: '1.3.42'
    },
    {
      id: 'Comfy.DOMClippingEnabled',
      category: ['LiteGraph', 'Node', 'DOMClippingEnabled'],
      name: 'Enable DOM element clipping (enabling may reduce performance)',
      type: 'boolean',
      defaultValue: !0
    },
    {
      id: 'Comfy.Graph.CtrlShiftZoom',
      category: ['LiteGraph', 'Canvas', 'CtrlShiftZoom'],
      name: 'Enable fast-zoom shortcut (Ctrl + Shift + Drag)',
      type: 'boolean',
      defaultValue: !0,
      versionAdded: '1.4.0'
    },
    {
      id: 'Comfy.Pointer.ClickDrift',
      category: ['LiteGraph', 'Pointer', 'ClickDrift'],
      name: 'Pointer click drift (maximum distance)',
      tooltip:
        'If the pointer moves more than this distance while holding a button down, it is considered dragging (rather than clicking).\n\nHelps prevent objects from being unintentionally nudged if the pointer is moved whilst clicking.',
      experimental: !0,
      type: 'slider',
      attrs: { min: 0, max: 20, step: 1 },
      defaultValue: 6,
      versionAdded: '1.4.3'
    },
    {
      id: 'Comfy.Pointer.ClickBufferTime',
      category: ['LiteGraph', 'Pointer', 'ClickBufferTime'],
      name: 'Pointer click drift delay',
      tooltip:
        'After pressing a pointer button down, this is the maximum time (in milliseconds) that pointer movement can be ignored for.\n\nHelps prevent objects from being unintentionally nudged if the pointer is moved whilst clicking.',
      experimental: !0,
      type: 'slider',
      attrs: { min: 0, max: 1e3, step: 25 },
      defaultValue: 150,
      versionAdded: '1.4.3'
    },
    {
      id: 'Comfy.Pointer.DoubleClickTime',
      category: ['LiteGraph', 'Pointer', 'DoubleClickTime'],
      name: 'Double click interval (maximum)',
      tooltip:
        'The maximum time in milliseconds between the two clicks of a double-click.  Increasing this value may assist if double-clicks are sometimes not registered.',
      type: 'slider',
      attrs: { min: 100, max: 1e3, step: 50 },
      defaultValue: 300,
      versionAdded: '1.4.3'
    },
    {
      id: 'Comfy.SnapToGrid.GridSize',
      category: ['LiteGraph', 'Canvas', 'GridSize'],
      name: 'Snap to grid size',
      type: 'slider',
      attrs: { min: 1, max: 500 },
      tooltip:
        'When dragging and resizing nodes while holding shift they will be aligned to the grid, this controls the size of that grid.',
      defaultValue: LiteGraph.CANVAS_GRID_SIZE
    },
    {
      id: 'pysssss.SnapToGrid',
      category: ['LiteGraph', 'Canvas', 'AlwaysSnapToGrid'],
      name: 'Always snap to grid',
      type: 'boolean',
      defaultValue: !1,
      versionAdded: '1.3.13'
    },
    {
      id: 'Comfy.Server.ServerConfigValues',
      name: 'Server config values for frontend display',
      tooltip: 'Server config values used for frontend display only',
      type: 'hidden',
      defaultValue: {},
      versionAdded: '1.4.8'
    },
    {
      id: 'Comfy.Server.LaunchArgs',
      name: 'Server launch arguments',
      tooltip:
        'These are the actual arguments that are passed to the server when it is launched.',
      type: 'hidden',
      defaultValue: {},
      versionAdded: '1.4.8'
    },
    {
      id: 'Comfy.Queue.MaxHistoryItems',
      name: 'Queue history size',
      tooltip: 'The maximum number of tasks that show in the queue history.',
      type: 'slider',
      attrs: { min: 16, max: 256, step: 16 },
      defaultValue: 64,
      versionAdded: '1.4.12'
    },
    {
      id: 'LiteGraph.Canvas.MaximumFps',
      name: 'Maxium FPS',
      tooltip:
        'The maximum frames per second that the canvas is allowed to render. Caps GPU usage at the cost of smoothness. If 0, the screen refresh rate is used. Default: 0',
      type: 'slider',
      attrs: { min: 0, max: 120 },
      defaultValue: 0,
      versionAdded: '1.5.1'
    },
    {
      id: 'Comfy.EnableWorkflowViewRestore',
      category: ['Comfy', 'Workflow', 'EnableWorkflowViewRestore'],
      name: 'Save and restore canvas position and zoom level in workflows',
      type: 'boolean',
      defaultValue: !0,
      versionModified: '1.5.4'
    },
    {
      id: 'Comfy.Workflow.ConfirmDelete',
      name: 'Show confirmation when deleting workflows',
      type: 'boolean',
      defaultValue: !0,
      versionAdded: '1.5.6'
    }
  ],
  useSettingStore = defineStore('setting', () => {
    const e = Vue.ref({}),
      t = Vue.ref({}),
      n = Vue.computed(() => {
        const e = buildTree(
            Object.values(t.value).filter((e) => 'hidden' !== e.type),
            (e) => e.category || e.id.split('.')
          ),
          n = (e.children ?? []).filter((e) => e.leaf)
        return (
          n.length &&
            ((e.children = (e.children ?? []).filter((e) => !e.leaf)),
            e.children.push({
              key: 'Other',
              label: 'Other',
              leaf: !1,
              children: n
            })),
          e
        )
      })
    function o(n) {
      for (const t in n.settingsLookup) {
        const o = n.getSettingValue(t)
        e.value[t] = o
      }
      ;(t.value = n.settingsParamLookup),
        CORE_SETTINGS.forEach((e) => {
          n.addSetting(e)
        })
    }
    function i(e) {
      e.settings?.forEach((e) => {
        app$1.ui.settings.addSetting(e)
      })
    }
    function r(t) {
      return void 0 !== e.value[t]
    }
    async function a(t, n) {
      ;(e.value[t] = n), await app$1.ui.settings.setSettingValueAsync(t, n)
    }
    function s(t) {
      return e.value[t] ?? app$1.ui.settings.getSettingDefaultValue(t)
    }
    return (
      __name(o, 'addSettings'),
      __name(i, 'loadExtensionSettings'),
      __name(r, 'exists'),
      __name(a, 'set'),
      __name(s, 'get'),
      {
        settingValues: e,
        settings: t,
        settingTree: n,
        addSettings: o,
        loadExtensionSettings: i,
        set: a,
        get: s,
        exists: r
      }
    )
  }),
  CORE_KEYBINDINGS = [
    { combo: { ctrl: !0, key: 'Enter' }, commandId: 'Comfy.QueuePrompt' },
    {
      combo: { ctrl: !0, shift: !0, key: 'Enter' },
      commandId: 'Comfy.QueuePromptFront'
    },
    {
      combo: { ctrl: !0, alt: !0, key: 'Enter' },
      commandId: 'Comfy.Interrupt'
    },
    { combo: { key: 'r' }, commandId: 'Comfy.RefreshNodeDefinitions' },
    { combo: { key: 'q' }, commandId: 'Workspace.ToggleSidebarTab.queue' },
    { combo: { key: 'w' }, commandId: 'Workspace.ToggleSidebarTab.workflows' },
    {
      combo: { key: 'n' },
      commandId: 'Workspace.ToggleSidebarTab.node-library'
    },
    {
      combo: { key: 'm' },
      commandId: 'Workspace.ToggleSidebarTab.model-library'
    },
    { combo: { key: 's', ctrl: !0 }, commandId: 'Comfy.SaveWorkflow' },
    { combo: { key: 'o', ctrl: !0 }, commandId: 'Comfy.OpenWorkflow' },
    { combo: { key: 'Backspace' }, commandId: 'Comfy.ClearWorkflow' },
    {
      combo: { key: 'g', ctrl: !0 },
      commandId: 'Comfy.Graph.GroupSelectedNodes'
    },
    { combo: { key: ',', ctrl: !0 }, commandId: 'Comfy.ShowSettingsDialog' },
    {
      combo: { key: '=', alt: !0 },
      commandId: 'Comfy.Canvas.ZoomIn',
      targetSelector: '#graph-canvas'
    },
    {
      combo: { key: '+', alt: !0, shift: !0 },
      commandId: 'Comfy.Canvas.ZoomIn',
      targetSelector: '#graph-canvas'
    },
    {
      combo: { key: '+', alt: !0 },
      commandId: 'Comfy.Canvas.ZoomIn',
      targetSelector: '#graph-canvas'
    },
    {
      combo: { key: '-', alt: !0 },
      commandId: 'Comfy.Canvas.ZoomOut',
      targetSelector: '#graph-canvas'
    },
    {
      combo: { key: '.' },
      commandId: 'Comfy.Canvas.FitView',
      targetSelector: '#graph-canvas'
    },
    {
      combo: { key: 'p' },
      commandId: 'Comfy.Canvas.ToggleSelected.Pin',
      targetSelector: '#graph-canvas'
    },
    {
      combo: { key: 'c', alt: !0 },
      commandId: 'Comfy.Canvas.ToggleSelectedNodes.Collapse',
      targetSelector: '#graph-canvas'
    },
    {
      combo: { key: 'b', ctrl: !0 },
      commandId: 'Comfy.Canvas.ToggleSelectedNodes.Bypass',
      targetSelector: '#graph-canvas'
    },
    {
      combo: { key: 'm', ctrl: !0 },
      commandId: 'Comfy.Canvas.ToggleSelectedNodes.Mute',
      targetSelector: '#graph-canvas'
    },
    {
      combo: { key: '`', ctrl: !0 },
      commandId: 'Workspace.ToggleBottomPanelTab.logs-terminal'
    },
    { combo: { key: 'f' }, commandId: 'Workspace.ToggleFocusMode' }
  ]
class KeybindingImpl {
  static {
    __name(this, 'KeybindingImpl')
  }
  commandId
  combo
  targetSelector
  constructor(e) {
    ;(this.commandId = e.commandId),
      (this.combo = new KeyComboImpl(e.combo)),
      (this.targetSelector = e.targetSelector)
  }
  equals(e) {
    const t = Vue.toRaw(e)
    return (
      t instanceof KeybindingImpl &&
      this.commandId === t.commandId &&
      this.combo.equals(t.combo) &&
      this.targetSelector === t.targetSelector
    )
  }
}
class KeyComboImpl {
  static {
    __name(this, 'KeyComboImpl')
  }
  key
  ctrl
  alt
  shift
  constructor(e) {
    ;(this.key = e.key),
      (this.ctrl = e.ctrl ?? !1),
      (this.alt = e.alt ?? !1),
      (this.shift = e.shift ?? !1)
  }
  static fromEvent(e) {
    return new KeyComboImpl({
      key: e.key,
      ctrl: e.ctrlKey || e.metaKey,
      alt: e.altKey,
      shift: e.shiftKey
    })
  }
  equals(e) {
    const t = Vue.toRaw(e)
    return (
      t instanceof KeyComboImpl &&
      this.key.toUpperCase() === t.key.toUpperCase() &&
      this.ctrl === t.ctrl &&
      this.alt === t.alt &&
      this.shift === t.shift
    )
  }
  serialize() {
    return `${this.key.toUpperCase()}:${this.ctrl}:${this.alt}:${this.shift}`
  }
  toString() {
    return this.getKeySequences().join(' + ')
  }
  get hasModifier() {
    return this.ctrl || this.alt || this.shift
  }
  get isModifier() {
    return ['Control', 'Meta', 'Alt', 'Shift'].includes(this.key)
  }
  getKeySequences() {
    const e = []
    return (
      this.ctrl && e.push('Ctrl'),
      this.alt && e.push('Alt'),
      this.shift && e.push('Shift'),
      e.push(this.key),
      e
    )
  }
}
const useKeybindingStore = defineStore('keybinding', () => {
  const e = Vue.ref({}),
    t = Vue.ref({}),
    n = Vue.ref({}),
    o = Vue.computed(() => {
      const o = { ...e.value }
      for (const e of Object.values(n.value)) {
        const t = e.combo.serialize()
        o[t]?.equals(e) && delete o[t]
      }
      return { ...o, ...t.value }
    }),
    i = Vue.computed(() => Object.values(o.value))
  function r(e) {
    return o.value[e.serialize()]
  }
  function a(e) {
    const t = {}
    for (const n of e)
      n.commandId in t || (t[n.commandId] = []), t[n.commandId].push(n)
    return t
  }
  __name(r, 'getKeybinding'), __name(a, 'createKeybindingsByCommandId')
  const s = Vue.computed(() => a(i.value))
  function l(e) {
    return s.value[e] ?? []
  }
  __name(l, 'getKeybindingsByCommandId')
  const c = Vue.computed(() => a(Object.values(e.value)))
  function d(e) {
    return l(e)[0]
  }
  function u(e, t, { existOk: n = !1 }) {
    if (!n && t.combo.serialize() in e.value)
      throw new Error(
        `Keybinding on ${t.combo} already exists on ${e.value[t.combo.serialize()].commandId}`
      )
    e.value[t.combo.serialize()] = t
  }
  function p(t) {
    u(e, t, { existOk: !1 })
  }
  function h(o) {
    const i = e.value[o.combo.serialize()],
      r = n.value[o.combo.serialize()]
    o.equals(i) && o.equals(r)
      ? delete n.value[o.combo.serialize()]
      : (i && !i.equals(r) && m(i), u(t, o, { existOk: !0 }))
  }
  function m(i) {
    const r = i.combo.serialize()
    if (r in o.value)
      if (t.value[r]?.equals(i)) delete t.value[r]
      else {
        if (!e.value[r]?.equals(i))
          throw new Error(`Unknown keybinding: ${JSON.stringify(i)}`)
        u(n, i, { existOk: !1 })
      }
    else
      console.warn(`Trying to unset non-exist keybinding: ${JSON.stringify(i)}`)
  }
  function f(e) {
    const t = d(e.commandId)
    return !t?.equals(e) && (t && m(t), h(e), !0)
  }
  function _() {
    const e = useSettingStore(),
      t = e.get('Comfy.Keybinding.UnsetBindings')
    for (const o of t) m(new KeybindingImpl(o))
    const n = e.get('Comfy.Keybinding.NewBindings')
    for (const o of n) h(new KeybindingImpl(o))
  }
  function g() {
    for (const e of CORE_KEYBINDINGS) p(new KeybindingImpl(e))
  }
  function v(e) {
    if (e.keybindings)
      for (const n of e.keybindings)
        try {
          p(new KeybindingImpl(n))
        } catch (t) {
          console.warn(`Failed to load keybinding for extension ${e.name}`, t)
        }
  }
  async function y() {
    const e = useSettingStore()
    await e.set('Comfy.Keybinding.NewBindings', Object.values(t.value)),
      await e.set('Comfy.Keybinding.UnsetBindings', Object.values(n.value))
  }
  function b() {
    ;(t.value = {}), (n.value = {})
  }
  function S(e) {
    const t = d(e),
      n = c.value[e]?.[0]
    return !((void 0 === t && void 0 === n) || t?.equals(n))
  }
  return (
    __name(d, 'getKeybindingByCommandId'),
    __name(u, 'addKeybinding'),
    __name(p, 'addDefaultKeybinding'),
    __name(h, 'addUserKeybinding'),
    __name(m, 'unsetKeybinding'),
    __name(f, 'updateKeybindingOnCommand'),
    __name(_, 'loadUserKeybindings'),
    __name(g, 'loadCoreKeybindings'),
    __name(v, 'loadExtensionKeybindings'),
    __name(y, 'persistUserKeybindings'),
    __name(b, 'resetKeybindings'),
    __name(S, 'isCommandKeybindingModified'),
    {
      keybindings: i,
      getKeybinding: r,
      getKeybindingsByCommandId: l,
      getKeybindingByCommandId: d,
      addDefaultKeybinding: p,
      addUserKeybinding: h,
      unsetKeybinding: m,
      updateKeybindingOnCommand: f,
      loadUserKeybindings: _,
      loadCoreKeybindings: g,
      loadExtensionKeybindings: v,
      persistUserKeybindings: y,
      resetKeybindings: b,
      isCommandKeybindingModified: S
    }
  )
})
class ComfyCommandImpl {
  static {
    __name(this, 'ComfyCommandImpl')
  }
  id
  function
  _label
  _icon
  _tooltip
  _menubarLabel
  versionAdded
  confirmation
  constructor(e) {
    ;(this.id = e.id),
      (this.function = e.function),
      (this._label = e.label),
      (this._icon = e.icon),
      (this._tooltip = e.tooltip),
      (this._menubarLabel = e.menubarLabel ?? e.label),
      (this.versionAdded = e.versionAdded),
      (this.confirmation = e.confirmation)
  }
  get label() {
    return 'function' == typeof this._label ? this._label() : this._label
  }
  get icon() {
    return 'function' == typeof this._icon ? this._icon() : this._icon
  }
  get tooltip() {
    return 'function' == typeof this._tooltip ? this._tooltip() : this._tooltip
  }
  get menubarLabel() {
    return 'function' == typeof this._menubarLabel
      ? this._menubarLabel()
      : this._menubarLabel
  }
  get keybinding() {
    return useKeybindingStore().getKeybindingByCommandId(this.id)
  }
}
const useCommandStore = defineStore('command', () => {
  const e = Vue.ref({}),
    t = Vue.computed(() => Object.values(e.value)),
    n = __name((t) => {
      e.value[t.id] && console.warn(`Command ${t.id} already registered`),
        (e.value[t.id] = new ComfyCommandImpl(t))
    }, 'registerCommand'),
    o = __name((e) => {
      for (const t of e) n(t)
    }, 'registerCommands'),
    i = __name((t) => e.value[t], 'getCommand'),
    { wrapWithErrorHandlingAsync: r } = useErrorHandling(),
    a = __name(async (e, t) => {
      const n = i(e)
      if (!n) throw new Error(`Command ${e} not found`)
      await r(n.function, t)()
    }, 'execute'),
    s = __name((t) => !!e.value[t], 'isRegistered'),
    l = __name((e) => {
      if (e.commands) for (const t of e.commands) n(t)
    }, 'loadExtensionCommands')
  return {
    commands: t,
    execute: a,
    getCommand: i,
    registerCommand: n,
    registerCommands: o,
    isRegistered: s,
    loadExtensionCommands: l
  }
})
var theme$e = __name(function (e) {
    var t = e.dt
    return '\n.p-tree {\n    background: '
      .concat(t('tree.background'), ';\n    color: ')
      .concat(t('tree.color'), ';\n    padding: ')
      .concat(
        t('tree.padding'),
        ';\n}\n\n.p-tree-root-children,\n.p-tree-node-children {\n    display: flex;\n    list-style-type: none;\n    flex-direction: column;\n    margin: 0;\n    gap: '
      )
      .concat(
        t('tree.gap'),
        ';\n}\n\n.p-tree-root-children {\n    padding: 0;\n    padding-block-start: '
      )
      .concat(
        t('tree.gap'),
        ';\n}\n\n.p-tree-node-children {\n    padding: 0;\n    padding-block-start: '
      )
      .concat(t('tree.gap'), ';\n    padding-inline-start: ')
      .concat(
        t('tree.indent'),
        ';\n}\n\n.p-tree-node {\n    padding: 0;\n    outline: 0 none;\n}\n\n.p-tree-node-content {\n    border-radius: '
      )
      .concat(t('tree.node.border.radius'), ';\n    padding: ')
      .concat(
        t('tree.node.padding'),
        ';\n    display: flex;\n    align-items: center;\n    outline-color: transparent;\n    color: '
      )
      .concat(t('tree.node.color'), ';\n    gap: ')
      .concat(t('tree.node.gap'), ';\n    transition: background ')
      .concat(t('tree.transition.duration'), ', color ')
      .concat(t('tree.transition.duration'), ', outline-color ')
      .concat(t('tree.transition.duration'), ', box-shadow ')
      .concat(
        t('tree.transition.duration'),
        ';\n}\n\n.p-tree-node:focus-visible > .p-tree-node-content {\n    box-shadow: '
      )
      .concat(t('tree.node.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('tree.node.focus.ring.width'), ' ')
      .concat(t('tree.node.focus.ring.style'), ' ')
      .concat(t('tree.node.focus.ring.color'), ';\n    outline-offset: ')
      .concat(
        t('tree.node.focus.ring.offset'),
        ';\n}\n\n.p-tree-node-content.p-tree-node-selectable:not(.p-tree-node-selected):hover {\n    background: '
      )
      .concat(t('tree.node.hover.background'), ';\n    color: ')
      .concat(
        t('tree.node.hover.color'),
        ';\n}\n\n.p-tree-node-content.p-tree-node-selectable:not(.p-tree-node-selected):hover .p-tree-node-icon {\n    color: '
      )
      .concat(
        t('tree.node.icon.hover.color'),
        ';\n}\n\n.p-tree-node-content.p-tree-node-selected {\n    background: '
      )
      .concat(t('tree.node.selected.background'), ';\n    color: ')
      .concat(
        t('tree.node.selected.color'),
        ';\n}\n\n.p-tree-node-content.p-tree-node-selected .p-tree-node-toggle-button {\n    color: inherit;\n}\n\n.p-tree-node-toggle-button {\n    cursor: pointer;\n    user-select: none;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    flex-shrink: 0;\n    width: '
      )
      .concat(t('tree.node.toggle.button.size'), ';\n    height: ')
      .concat(t('tree.node.toggle.button.size'), ';\n    color: ')
      .concat(
        t('tree.node.toggle.button.color'),
        ';\n    border: 0 none;\n    background: transparent;\n    border-radius: '
      )
      .concat(
        t('tree.node.toggle.button.border.radius'),
        ';\n    transition: background '
      )
      .concat(t('tree.transition.duration'), ', color ')
      .concat(t('tree.transition.duration'), ', border-color ')
      .concat(t('tree.transition.duration'), ', outline-color ')
      .concat(t('tree.transition.duration'), ', box-shadow ')
      .concat(
        t('tree.transition.duration'),
        ';\n    outline-color: transparent;\n    padding: 0;\n}\n\n.p-tree-node-toggle-button:enabled:hover {\n    background: '
      )
      .concat(t('tree.node.toggle.button.hover.background'), ';\n    color: ')
      .concat(
        t('tree.node.toggle.button.hover.color'),
        ';\n}\n\n.p-tree-node-content.p-tree-node-selected .p-tree-node-toggle-button:hover {\n    background: '
      )
      .concat(
        t('tree.node.toggle.button.selected.hover.background'),
        ';\n    color: '
      )
      .concat(
        t('tree.node.toggle.button.selected.hover.color'),
        ';\n}\n\n.p-tree-root {\n    overflow: auto;\n}\n\n.p-tree-node-selectable {\n    cursor: pointer;\n    user-select: none;\n}\n\n.p-tree-node-leaf > .p-tree-node-content .p-tree-node-toggle-button {\n    visibility: hidden;\n}\n\n.p-tree-node-icon {\n    color: '
      )
      .concat(t('tree.node.icon.color'), ';\n    transition: color ')
      .concat(
        t('tree.transition.duration'),
        ';\n}\n\n.p-tree-node-content.p-tree-node-selected .p-tree-node-icon {\n    color: '
      )
      .concat(
        t('tree.node.icon.selected.color'),
        ';\n}\n\n.p-tree-filter {\n    margin: '
      )
      .concat(
        t('tree.filter.margin'),
        ';\n}\n\n.p-tree-filter-input {\n    width: 100%;\n}\n\n.p-tree-loading {\n    position: relative;\n    height: 100%;\n}\n\n.p-tree-loading-icon {\n    font-size: '
      )
      .concat(t('tree.loading.icon.size'), ';\n    width: ')
      .concat(t('tree.loading.icon.size'), ';\n    height: ')
      .concat(
        t('tree.loading.icon.size'),
        ';\n}\n\n.p-tree .p-tree-mask {\n    position: absolute;\n    z-index: 1;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-tree-flex-scrollable {\n    display: flex;\n    flex: 1;\n    height: 100%;\n    flex-direction: column;\n}\n\n.p-tree-flex-scrollable .p-tree-root {\n    flex: 1;\n}\n'
      )
  }, 'theme'),
  classes$e = {
    root: __name(function (e) {
      var t = e.props
      return [
        'p-tree p-component',
        {
          'p-tree-selectable': null != t.selectionMode,
          'p-tree-loading': t.loading,
          'p-tree-flex-scrollable': 'flex' === t.scrollHeight
        }
      ]
    }, 'root'),
    mask: 'p-tree-mask p-overlay-mask',
    loadingIcon: 'p-tree-loading-icon',
    pcFilterContainer: 'p-tree-filter',
    pcFilterInput: 'p-tree-filter-input',
    wrapper: 'p-tree-root',
    rootChildren: 'p-tree-root-children',
    node: __name(function (e) {
      return ['p-tree-node', { 'p-tree-node-leaf': e.instance.leaf }]
    }, 'node'),
    nodeContent: __name(function (e) {
      var t = e.instance
      return [
        'p-tree-node-content',
        t.node.styleClass,
        {
          'p-tree-node-selectable': t.selectable,
          'p-tree-node-selected':
            t.checkboxMode && t.$parentInstance.highlightOnSelect
              ? t.checked
              : t.selected
        }
      ]
    }, 'nodeContent'),
    nodeToggleButton: 'p-tree-node-toggle-button',
    nodeToggleIcon: 'p-tree-node-toggle-icon',
    nodeCheckbox: 'p-tree-node-checkbox',
    nodeIcon: 'p-tree-node-icon',
    nodeLabel: 'p-tree-node-label',
    nodeChildren: 'p-tree-node-children'
  },
  TreeStyle = BaseStyle.extend({
    name: 'tree',
    theme: theme$e,
    classes: classes$e
  }),
  script$l = { name: 'MinusIcon', extends: script$X }
function render$k(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              d: 'M13.2222 7.77778H0.777778C0.571498 7.77778 0.373667 7.69584 0.227806 7.54998C0.0819442 7.40412 0 7.20629 0 7.00001C0 6.79373 0.0819442 6.5959 0.227806 6.45003C0.373667 6.30417 0.571498 6.22223 0.777778 6.22223H13.2222C13.4285 6.22223 13.6263 6.30417 13.7722 6.45003C13.9181 6.5959 14 6.79373 14 7.00001C14 7.20629 13.9181 7.40412 13.7722 7.54998C13.6263 7.69584 13.4285 7.77778 13.2222 7.77778Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$k, 'render$k'), (script$l.render = render$k)
var theme$d = __name(function (e) {
    var t = e.dt
    return '\n.p-checkbox {\n    position: relative;\n    display: inline-flex;\n    user-select: none;\n    vertical-align: bottom;\n    width: '
      .concat(t('checkbox.width'), ';\n    height: ')
      .concat(
        t('checkbox.height'),
        ';\n}\n\n.p-checkbox-input {\n    cursor: pointer;\n    appearance: none;\n    position: absolute;\n    inset-block-start: 0;\n    inset-inline-start: 0;\n    width: 100%;\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    opacity: 0;\n    z-index: 1;\n    outline: 0 none;\n    border: 1px solid transparent;\n    border-radius: '
      )
      .concat(
        t('checkbox.border.radius'),
        ';\n}\n\n.p-checkbox-box {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-radius: '
      )
      .concat(t('checkbox.border.radius'), ';\n    border: 1px solid ')
      .concat(t('checkbox.border.color'), ';\n    background: ')
      .concat(t('checkbox.background'), ';\n    width: ')
      .concat(t('checkbox.width'), ';\n    height: ')
      .concat(t('checkbox.height'), ';\n    transition: background ')
      .concat(t('checkbox.transition.duration'), ', color ')
      .concat(t('checkbox.transition.duration'), ', border-color ')
      .concat(t('checkbox.transition.duration'), ', box-shadow ')
      .concat(t('checkbox.transition.duration'), ', outline-color ')
      .concat(
        t('checkbox.transition.duration'),
        ';\n    outline-color: transparent;\n    box-shadow: '
      )
      .concat(
        t('checkbox.shadow'),
        ';\n}\n\n.p-checkbox-icon {\n    transition-duration: '
      )
      .concat(t('checkbox.transition.duration'), ';\n    color: ')
      .concat(t('checkbox.icon.color'), ';\n    font-size: ')
      .concat(t('checkbox.icon.size'), ';\n    width: ')
      .concat(t('checkbox.icon.size'), ';\n    height: ')
      .concat(
        t('checkbox.icon.size'),
        ';\n}\n\n.p-checkbox:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n    border-color: '
      )
      .concat(
        t('checkbox.hover.border.color'),
        ';\n}\n\n.p-checkbox-checked .p-checkbox-box {\n    border-color: '
      )
      .concat(t('checkbox.checked.border.color'), ';\n    background: ')
      .concat(
        t('checkbox.checked.background'),
        ';\n}\n\n.p-checkbox-checked .p-checkbox-icon {\n    color: '
      )
      .concat(
        t('checkbox.icon.checked.color'),
        ';\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n    background: '
      )
      .concat(t('checkbox.checked.hover.background'), ';\n    border-color: ')
      .concat(
        t('checkbox.checked.hover.border.color'),
        ';\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-icon {\n    color: '
      )
      .concat(
        t('checkbox.icon.checked.hover.color'),
        ';\n}\n\n.p-checkbox:not(.p-disabled):has(.p-checkbox-input:focus-visible) .p-checkbox-box {\n    border-color: '
      )
      .concat(t('checkbox.focus.border.color'), ';\n    box-shadow: ')
      .concat(t('checkbox.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('checkbox.focus.ring.width'), ' ')
      .concat(t('checkbox.focus.ring.style'), ' ')
      .concat(t('checkbox.focus.ring.color'), ';\n    outline-offset: ')
      .concat(
        t('checkbox.focus.ring.offset'),
        ';\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:focus-visible) .p-checkbox-box {\n    border-color: '
      )
      .concat(
        t('checkbox.checked.focus.border.color'),
        ';\n}\n\n.p-checkbox.p-invalid > .p-checkbox-box {\n    border-color: '
      )
      .concat(
        t('checkbox.invalid.border.color'),
        ';\n}\n\n.p-checkbox.p-variant-filled .p-checkbox-box {\n    background: '
      )
      .concat(
        t('checkbox.filled.background'),
        ';\n}\n\n.p-checkbox-checked.p-variant-filled .p-checkbox-box {\n    background: '
      )
      .concat(
        t('checkbox.checked.background'),
        ';\n}\n\n.p-checkbox-checked.p-variant-filled:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n    background: '
      )
      .concat(
        t('checkbox.checked.hover.background'),
        ';\n}\n\n.p-checkbox.p-disabled {\n    opacity: 1;\n}\n\n.p-checkbox.p-disabled .p-checkbox-box {\n    background: '
      )
      .concat(t('checkbox.disabled.background'), ';\n    border-color: ')
      .concat(
        t('checkbox.checked.disabled.border.color'),
        ';\n}\n\n.p-checkbox.p-disabled .p-checkbox-box .p-checkbox-icon {\n    color: '
      )
      .concat(
        t('checkbox.icon.disabled.color'),
        ';\n}\n\n.p-checkbox-sm,\n.p-checkbox-sm .p-checkbox-box {\n    width: '
      )
      .concat(t('checkbox.sm.width'), ';\n    height: ')
      .concat(
        t('checkbox.sm.height'),
        ';\n}\n\n.p-checkbox-sm .p-checkbox-icon {\n    font-size: '
      )
      .concat(t('checkbox.icon.sm.size'), ';\n    width: ')
      .concat(t('checkbox.icon.sm.size'), ';\n    height: ')
      .concat(
        t('checkbox.icon.sm.size'),
        ';\n}\n\n.p-checkbox-lg,\n.p-checkbox-lg .p-checkbox-box {\n    width: '
      )
      .concat(t('checkbox.lg.width'), ';\n    height: ')
      .concat(
        t('checkbox.lg.height'),
        ';\n}\n\n.p-checkbox-lg .p-checkbox-icon {\n    font-size: '
      )
      .concat(t('checkbox.icon.lg.size'), ';\n    width: ')
      .concat(t('checkbox.icon.lg.size'), ';\n    height: ')
      .concat(t('checkbox.icon.lg.size'), ';\n}\n')
  }, 'theme'),
  classes$d = {
    root: __name(function (e) {
      var t = e.instance,
        n = e.props
      return [
        'p-checkbox p-component',
        {
          'p-checkbox-checked': t.checked,
          'p-disabled': n.disabled,
          'p-invalid': t.$pcCheckboxGroup
            ? t.$pcCheckboxGroup.$invalid
            : t.$invalid,
          'p-variant-filled': 'filled' === t.$variant,
          'p-checkbox-sm p-inputfield-sm': 'small' === n.size,
          'p-checkbox-lg p-inputfield-lg': 'large' === n.size
        }
      ]
    }, 'root'),
    box: 'p-checkbox-box',
    input: 'p-checkbox-input',
    icon: 'p-checkbox-icon'
  },
  CheckboxStyle = BaseStyle.extend({
    name: 'checkbox',
    theme: theme$d,
    classes: classes$d
  }),
  script$1$d = {
    name: 'BaseCheckbox',
    extends: script$Q,
    props: {
      value: null,
      binary: Boolean,
      indeterminate: { type: Boolean, default: !1 },
      trueValue: { type: null, default: !0 },
      falseValue: { type: null, default: !1 },
      readonly: { type: Boolean, default: !1 },
      required: { type: Boolean, default: !1 },
      tabindex: { type: Number, default: null },
      inputId: { type: String, default: null },
      inputClass: { type: [String, Object], default: null },
      inputStyle: { type: Object, default: null },
      ariaLabelledby: { type: String, default: null },
      ariaLabel: { type: String, default: null }
    },
    style: CheckboxStyle,
    provide: __name(function () {
      return { $pcCheckbox: this, $parentInstance: this }
    }, 'provide')
  }
function _toConsumableArray$5(e) {
  return (
    _arrayWithoutHoles$5(e) ||
    _iterableToArray$5(e) ||
    _unsupportedIterableToArray$8(e) ||
    _nonIterableSpread$5()
  )
}
function _nonIterableSpread$5() {
  throw new TypeError(
    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$8(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$8(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$8(e, t)
          : void 0
    )
  }
}
function _iterableToArray$5(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _arrayWithoutHoles$5(e) {
  if (Array.isArray(e)) return _arrayLikeToArray$8(e)
}
function _arrayLikeToArray$8(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
__name(_toConsumableArray$5, '_toConsumableArray$5'),
  __name(_nonIterableSpread$5, '_nonIterableSpread$5'),
  __name(_unsupportedIterableToArray$8, '_unsupportedIterableToArray$8'),
  __name(_iterableToArray$5, '_iterableToArray$5'),
  __name(_arrayWithoutHoles$5, '_arrayWithoutHoles$5'),
  __name(_arrayLikeToArray$8, '_arrayLikeToArray$8')
var script$k = {
    name: 'Checkbox',
    extends: script$1$d,
    inheritAttrs: !1,
    emits: ['change', 'focus', 'blur', 'update:indeterminate'],
    inject: { $pcCheckboxGroup: { default: void 0 } },
    data: __name(function () {
      return { d_indeterminate: this.indeterminate }
    }, 'data'),
    watch: {
      indeterminate: __name(function (e) {
        this.d_indeterminate = e
      }, 'indeterminate')
    },
    methods: {
      getPTOptions: __name(function (e) {
        return ('root' === e ? this.ptmi : this.ptm)(e, {
          context: {
            checked: this.checked,
            indeterminate: this.d_indeterminate,
            disabled: this.disabled
          }
        })
      }, 'getPTOptions'),
      onChange: __name(function (e) {
        var t = this
        if (!this.disabled && !this.readonly) {
          var n,
            o = this.$pcCheckboxGroup
              ? this.$pcCheckboxGroup.d_value
              : this.d_value
          ;(n = this.binary
            ? this.d_indeterminate
              ? this.trueValue
              : this.checked
                ? this.falseValue
                : this.trueValue
            : this.checked || this.d_indeterminate
              ? o.filter(function (e) {
                  return !equals(e, t.value)
                })
              : o
                ? [].concat(_toConsumableArray$5(o), [this.value])
                : [this.value]),
            this.d_indeterminate &&
              ((this.d_indeterminate = !1),
              this.$emit('update:indeterminate', this.d_indeterminate)),
            this.$pcCheckboxGroup
              ? this.$pcCheckboxGroup.writeValue(n, e)
              : this.writeValue(n, e),
            this.$emit('change', e)
        }
      }, 'onChange'),
      onFocus: __name(function (e) {
        this.$emit('focus', e)
      }, 'onFocus'),
      onBlur: __name(function (e) {
        var t, n
        this.$emit('blur', e),
          null === (t = (n = this.formField).onBlur) ||
            void 0 === t ||
            t.call(n, e)
      }, 'onBlur')
    },
    computed: {
      groupName: __name(function () {
        return this.$pcCheckboxGroup
          ? this.$pcCheckboxGroup.groupName
          : this.$formName
      }, 'groupName'),
      checked: __name(function () {
        var e = this.$pcCheckboxGroup
          ? this.$pcCheckboxGroup.d_value
          : this.d_value
        return (
          !this.d_indeterminate &&
          (this.binary ? e === this.trueValue : contains(this.value, e))
        )
      }, 'checked')
    },
    components: { CheckIcon: script$V, MinusIcon: script$l }
  },
  _hoisted_1$v = ['data-p-checked', 'data-p-indeterminate', 'data-p-disabled'],
  _hoisted_2$k = [
    'id',
    'value',
    'name',
    'checked',
    'tabindex',
    'disabled',
    'readonly',
    'required',
    'aria-labelledby',
    'aria-label',
    'aria-invalid',
    'aria-checked'
  ]
function render$j(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('CheckIcon'),
    s = Vue.resolveComponent('MinusIcon')
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps({ class: e.cx('root') }, r.getPTOptions('root'), {
        'data-p-checked': r.checked,
        'data-p-indeterminate': i.d_indeterminate || void 0,
        'data-p-disabled': e.disabled
      }),
      [
        Vue.createElementVNode(
          'input',
          Vue.mergeProps(
            {
              id: e.inputId,
              type: 'checkbox',
              class: [e.cx('input'), e.inputClass],
              style: e.inputStyle,
              value: e.value,
              name: r.groupName,
              checked: r.checked,
              tabindex: e.tabindex,
              disabled: e.disabled,
              readonly: e.readonly,
              required: e.required,
              'aria-labelledby': e.ariaLabelledby,
              'aria-label': e.ariaLabel,
              'aria-invalid': e.invalid || void 0,
              'aria-checked': i.d_indeterminate ? 'mixed' : void 0,
              onFocus:
                t[0] ||
                (t[0] = function () {
                  return r.onFocus && r.onFocus.apply(r, arguments)
                }),
              onBlur:
                t[1] ||
                (t[1] = function () {
                  return r.onBlur && r.onBlur.apply(r, arguments)
                }),
              onChange:
                t[2] ||
                (t[2] = function () {
                  return r.onChange && r.onChange.apply(r, arguments)
                })
            },
            r.getPTOptions('input')
          ),
          null,
          16,
          _hoisted_2$k
        ),
        Vue.createElementVNode(
          'div',
          Vue.mergeProps({ class: e.cx('box') }, r.getPTOptions('box')),
          [
            Vue.renderSlot(
              e.$slots,
              'icon',
              {
                checked: r.checked,
                indeterminate: i.d_indeterminate,
                class: Vue.normalizeClass(e.cx('icon'))
              },
              function () {
                return [
                  r.checked
                    ? (Vue.openBlock(),
                      Vue.createBlock(
                        a,
                        Vue.mergeProps(
                          { key: 0, class: e.cx('icon') },
                          r.getPTOptions('icon')
                        ),
                        null,
                        16,
                        ['class']
                      ))
                    : i.d_indeterminate
                      ? (Vue.openBlock(),
                        Vue.createBlock(
                          s,
                          Vue.mergeProps(
                            { key: 1, class: e.cx('icon') },
                            r.getPTOptions('icon')
                          ),
                          null,
                          16,
                          ['class']
                        ))
                      : Vue.createCommentVNode('', !0)
                ]
              }
            )
          ],
          16
        )
      ],
      16,
      _hoisted_1$v
    )
  )
}
__name(render$j, 'render$j'), (script$k.render = render$j)
var script$2$3 = {
  name: 'BaseTree',
  extends: script$Y,
  props: {
    value: { type: null, default: null },
    expandedKeys: { type: null, default: null },
    selectionKeys: { type: null, default: null },
    selectionMode: { type: String, default: null },
    metaKeySelection: { type: Boolean, default: !1 },
    loading: { type: Boolean, default: !1 },
    loadingIcon: { type: String, default: void 0 },
    loadingMode: { type: String, default: 'mask' },
    filter: { type: Boolean, default: !1 },
    filterBy: { type: [String, Function], default: 'label' },
    filterMode: { type: String, default: 'lenient' },
    filterPlaceholder: { type: String, default: null },
    filterLocale: { type: String, default: void 0 },
    highlightOnSelect: { type: Boolean, default: !1 },
    scrollHeight: { type: String, default: null },
    level: { type: Number, default: 0 },
    ariaLabelledby: { type: String, default: null },
    ariaLabel: { type: String, default: null }
  },
  style: TreeStyle,
  provide: __name(function () {
    return { $pcTree: this, $parentInstance: this }
  }, 'provide')
}
function _typeof$2$2(e) {
  return (_typeof$2$2 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function _createForOfIteratorHelper$1$1(e, t) {
  var n =
    ('undefined' != typeof Symbol && e[Symbol.iterator]) || e['@@iterator']
  if (!n) {
    if (Array.isArray(e) || (n = _unsupportedIterableToArray$1$1(e)) || t) {
      n && (e = n)
      var o = 0,
        i = __name(function () {}, 'F')
      return {
        s: i,
        n: __name(function () {
          return o >= e.length ? { done: !0 } : { done: !1, value: e[o++] }
        }, 'n'),
        e: __name(function (e) {
          throw e
        }, 'e'),
        f: i
      }
    }
    throw new TypeError(
      'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
    )
  }
  var r,
    a = !0,
    s = !1
  return {
    s: __name(function () {
      n = n.call(e)
    }, 's'),
    n: __name(function () {
      var e = n.next()
      return (a = e.done), e
    }, 'n'),
    e: __name(function (e) {
      ;(s = !0), (r = e)
    }, 'e'),
    f: __name(function () {
      try {
        a || null == n.return || n.return()
      } finally {
        if (s) throw r
      }
    }, 'f')
  }
}
function ownKeys$2$1(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$2$1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$2$1(Object(n), !0).forEach(function (t) {
          _defineProperty$2$2(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$2$1(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$2$2(e, t, n) {
  return (
    (t = _toPropertyKey$2$2(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$2$2(e) {
  var t = _toPrimitive$2$2(e, 'string')
  return 'symbol' == _typeof$2$2(t) ? t : t + ''
}
function _toPrimitive$2$2(e, t) {
  if ('object' != _typeof$2$2(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$2$2(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
function _toConsumableArray$1$1(e) {
  return (
    _arrayWithoutHoles$1$1(e) ||
    _iterableToArray$1$1(e) ||
    _unsupportedIterableToArray$1$1(e) ||
    _nonIterableSpread$1$1()
  )
}
function _nonIterableSpread$1$1() {
  throw new TypeError(
    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$1$1(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$1$1(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$1$1(e, t)
          : void 0
    )
  }
}
function _iterableToArray$1$1(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _arrayWithoutHoles$1$1(e) {
  if (Array.isArray(e)) return _arrayLikeToArray$1$1(e)
}
function _arrayLikeToArray$1$1(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
__name(_typeof$2$2, '_typeof$2$2'),
  __name(_createForOfIteratorHelper$1$1, '_createForOfIteratorHelper$1$1'),
  __name(ownKeys$2$1, 'ownKeys$2$1'),
  __name(_objectSpread$2$1, '_objectSpread$2$1'),
  __name(_defineProperty$2$2, '_defineProperty$2$2'),
  __name(_toPropertyKey$2$2, '_toPropertyKey$2$2'),
  __name(_toPrimitive$2$2, '_toPrimitive$2$2'),
  __name(_toConsumableArray$1$1, '_toConsumableArray$1$1'),
  __name(_nonIterableSpread$1$1, '_nonIterableSpread$1$1'),
  __name(_unsupportedIterableToArray$1$1, '_unsupportedIterableToArray$1$1'),
  __name(_iterableToArray$1$1, '_iterableToArray$1$1'),
  __name(_arrayWithoutHoles$1$1, '_arrayWithoutHoles$1$1'),
  __name(_arrayLikeToArray$1$1, '_arrayLikeToArray$1$1')
var script$1$c = {
    name: 'TreeNode',
    hostName: 'Tree',
    extends: script$Y,
    emits: ['node-toggle', 'node-click', 'checkbox-change'],
    props: {
      node: { type: null, default: null },
      expandedKeys: { type: null, default: null },
      loadingMode: { type: String, default: 'mask' },
      selectionKeys: { type: null, default: null },
      selectionMode: { type: String, default: null },
      templates: { type: null, default: null },
      level: { type: Number, default: null },
      index: null
    },
    nodeTouched: !1,
    toggleClicked: !1,
    mounted: __name(function () {
      this.setAllNodesTabIndexes()
    }, 'mounted'),
    methods: {
      toggle: __name(function () {
        this.$emit('node-toggle', this.node), (this.toggleClicked = !0)
      }, 'toggle'),
      label: __name(function (e) {
        return 'function' == typeof e.label ? e.label() : e.label
      }, 'label'),
      onChildNodeToggle: __name(function (e) {
        this.$emit('node-toggle', e)
      }, 'onChildNodeToggle'),
      getPTOptions: __name(function (e) {
        return this.ptm(e, {
          context: {
            node: this.node,
            index: this.index,
            expanded: this.expanded,
            selected: this.selected,
            checked: this.checked,
            partialChecked: this.partialChecked,
            leaf: this.leaf
          }
        })
      }, 'getPTOptions'),
      onClick: __name(function (e) {
        this.toggleClicked ||
        getAttribute(e.target, '[data-pc-section="nodetogglebutton"]') ||
        getAttribute(
          e.target.parentElement,
          '[data-pc-section="nodetogglebutton"]'
        )
          ? (this.toggleClicked = !1)
          : (this.isCheckboxSelectionMode()
              ? 0 != this.node.selectable && this.toggleCheckbox()
              : this.$emit('node-click', {
                  originalEvent: e,
                  nodeTouched: this.nodeTouched,
                  node: this.node
                }),
            (this.nodeTouched = !1))
      }, 'onClick'),
      onChildNodeClick: __name(function (e) {
        this.$emit('node-click', e)
      }, 'onChildNodeClick'),
      onTouchEnd: __name(function () {
        this.nodeTouched = !0
      }, 'onTouchEnd'),
      onKeyDown: __name(function (e) {
        if (this.isSameNode(e))
          switch (e.code) {
            case 'Tab':
              this.onTabKey(e)
              break
            case 'ArrowDown':
              this.onArrowDown(e)
              break
            case 'ArrowUp':
              this.onArrowUp(e)
              break
            case 'ArrowRight':
              this.onArrowRight(e)
              break
            case 'ArrowLeft':
              this.onArrowLeft(e)
              break
            case 'Enter':
            case 'NumpadEnter':
            case 'Space':
              this.onEnterKey(e)
          }
      }, 'onKeyDown'),
      onArrowDown: __name(function (e) {
        var t =
            'nodetogglebutton' === e.target.getAttribute('data-pc-section')
              ? e.target.closest('[role="treeitem"]')
              : e.target,
          n = t.children[1]
        if (n) this.focusRowChange(t, n.children[0])
        else if (t.nextElementSibling)
          this.focusRowChange(t, t.nextElementSibling)
        else {
          var o = this.findNextSiblingOfAncestor(t)
          o && this.focusRowChange(t, o)
        }
        e.preventDefault()
      }, 'onArrowDown'),
      onArrowUp: __name(function (e) {
        var t = e.target
        if (t.previousElementSibling)
          this.focusRowChange(
            t,
            t.previousElementSibling,
            this.findLastVisibleDescendant(t.previousElementSibling)
          )
        else {
          var n = this.getParentNodeElement(t)
          n && this.focusRowChange(t, n)
        }
        e.preventDefault()
      }, 'onArrowUp'),
      onArrowRight: __name(function (e) {
        var t = this
        this.leaf ||
          this.expanded ||
          ((e.currentTarget.tabIndex = -1),
          this.$emit('node-toggle', this.node),
          this.$nextTick(function () {
            t.onArrowDown(e)
          }))
      }, 'onArrowRight'),
      onArrowLeft: __name(function (e) {
        var t = findSingle(
          e.currentTarget,
          '[data-pc-section="nodetogglebutton"]'
        )
        if (0 === this.level && !this.expanded) return !1
        if (this.expanded && !this.leaf) return t.click(), !1
        var n = this.findBeforeClickableNode(e.currentTarget)
        n && this.focusRowChange(e.currentTarget, n)
      }, 'onArrowLeft'),
      onEnterKey: __name(function (e) {
        this.setTabIndexForSelectionMode(e, this.nodeTouched),
          this.onClick(e),
          e.preventDefault()
      }, 'onEnterKey'),
      onTabKey: __name(function () {
        this.setAllNodesTabIndexes()
      }, 'onTabKey'),
      setAllNodesTabIndexes: __name(function () {
        var e = find(
            this.$refs.currentNode.closest('[data-pc-section="rootchildren"]'),
            '[role="treeitem"]'
          ),
          t = _toConsumableArray$1$1(e).some(function (e) {
            return (
              'true' === e.getAttribute('aria-selected') ||
              'true' === e.getAttribute('aria-checked')
            )
          })
        ;(_toConsumableArray$1$1(e).forEach(function (e) {
          e.tabIndex = -1
        }),
        t)
          ? (_toConsumableArray$1$1(e).filter(function (e) {
              return (
                'true' === e.getAttribute('aria-selected') ||
                'true' === e.getAttribute('aria-checked')
              )
            })[0].tabIndex = 0)
          : (_toConsumableArray$1$1(e)[0].tabIndex = 0)
      }, 'setAllNodesTabIndexes'),
      setTabIndexForSelectionMode: __name(function (e, t) {
        if (null !== this.selectionMode) {
          var n = _toConsumableArray$1$1(
            find(this.$refs.currentNode.parentElement, '[role="treeitem"]')
          )
          ;(e.currentTarget.tabIndex = !1 === t ? -1 : 0),
            n.every(function (e) {
              return -1 === e.tabIndex
            }) && (n[0].tabIndex = 0)
        }
      }, 'setTabIndexForSelectionMode'),
      focusRowChange: __name(function (e, t, n) {
        ;(e.tabIndex = '-1'), (t.tabIndex = '0'), this.focusNode(n || t)
      }, 'focusRowChange'),
      findBeforeClickableNode: __name(function (e) {
        var t = e.closest('ul').closest('li')
        if (t) {
          var n = findSingle(t, 'button')
          return n && 'hidden' !== n.style.visibility
            ? t
            : this.findBeforeClickableNode(e.previousElementSibling)
        }
        return null
      }, 'findBeforeClickableNode'),
      toggleCheckbox: __name(function () {
        var e = this.selectionKeys
            ? _objectSpread$2$1({}, this.selectionKeys)
            : {},
          t = !this.checked
        this.propagateDown(this.node, t, e),
          this.$emit('checkbox-change', {
            node: this.node,
            check: t,
            selectionKeys: e
          })
      }, 'toggleCheckbox'),
      propagateDown: __name(function (e, t, n) {
        if (
          (t && 0 != e.selectable
            ? (n[e.key] = { checked: !0, partialChecked: !1 })
            : delete n[e.key],
          e.children && e.children.length)
        ) {
          var o,
            i = _createForOfIteratorHelper$1$1(e.children)
          try {
            for (i.s(); !(o = i.n()).done; ) {
              var r = o.value
              this.propagateDown(r, t, n)
            }
          } catch (a) {
            i.e(a)
          } finally {
            i.f()
          }
        }
      }, 'propagateDown'),
      propagateUp: __name(function (e) {
        var t,
          n = e.check,
          o = _objectSpread$2$1({}, e.selectionKeys),
          i = 0,
          r = !1,
          a = _createForOfIteratorHelper$1$1(this.node.children)
        try {
          for (a.s(); !(t = a.n()).done; ) {
            var s = t.value
            o[s.key] && o[s.key].checked
              ? i++
              : o[s.key] && o[s.key].partialChecked && (r = !0)
          }
        } catch (l) {
          a.e(l)
        } finally {
          a.f()
        }
        n && i === this.node.children.length
          ? (o[this.node.key] = { checked: !0, partialChecked: !1 })
          : (n || delete o[this.node.key],
            r || (i > 0 && i !== this.node.children.length)
              ? (o[this.node.key] = { checked: !1, partialChecked: !0 })
              : delete o[this.node.key]),
          this.$emit('checkbox-change', {
            node: e.node,
            check: e.check,
            selectionKeys: o
          })
      }, 'propagateUp'),
      onChildCheckboxChange: __name(function (e) {
        this.$emit('checkbox-change', e)
      }, 'onChildCheckboxChange'),
      findNextSiblingOfAncestor: __name(function (e) {
        var t = this.getParentNodeElement(e)
        return t
          ? t.nextElementSibling
            ? t.nextElementSibling
            : this.findNextSiblingOfAncestor(t)
          : null
      }, 'findNextSiblingOfAncestor'),
      findLastVisibleDescendant: __name(function (e) {
        var t = e.children[1]
        if (t) {
          var n = t.children[t.children.length - 1]
          return this.findLastVisibleDescendant(n)
        }
        return e
      }, 'findLastVisibleDescendant'),
      getParentNodeElement: __name(function (e) {
        var t = e.parentElement.parentElement
        return 'treeitem' === getAttribute(t, 'role') ? t : null
      }, 'getParentNodeElement'),
      focusNode: __name(function (e) {
        e.focus()
      }, 'focusNode'),
      isCheckboxSelectionMode: __name(function () {
        return 'checkbox' === this.selectionMode
      }, 'isCheckboxSelectionMode'),
      isSameNode: __name(function (e) {
        return (
          e.currentTarget &&
          (e.currentTarget.isSameNode(e.target) ||
            e.currentTarget.isSameNode(e.target.closest('[role="treeitem"]')))
        )
      }, 'isSameNode')
    },
    computed: {
      hasChildren: __name(function () {
        return this.node.children && this.node.children.length > 0
      }, 'hasChildren'),
      expanded: __name(function () {
        return this.expandedKeys && !0 === this.expandedKeys[this.node.key]
      }, 'expanded'),
      leaf: __name(function () {
        return (
          !1 !== this.node.leaf &&
          !(this.node.children && this.node.children.length)
        )
      }, 'leaf'),
      selectable: __name(function () {
        return !1 !== this.node.selectable && null != this.selectionMode
      }, 'selectable'),
      selected: __name(function () {
        return (
          !(!this.selectionMode || !this.selectionKeys) &&
          !0 === this.selectionKeys[this.node.key]
        )
      }, 'selected'),
      checkboxMode: __name(function () {
        return 'checkbox' === this.selectionMode && !1 !== this.node.selectable
      }, 'checkboxMode'),
      checked: __name(function () {
        return (
          !!this.selectionKeys &&
          this.selectionKeys[this.node.key] &&
          this.selectionKeys[this.node.key].checked
        )
      }, 'checked'),
      partialChecked: __name(function () {
        return (
          !!this.selectionKeys &&
          this.selectionKeys[this.node.key] &&
          this.selectionKeys[this.node.key].partialChecked
        )
      }, 'partialChecked'),
      ariaChecked: __name(function () {
        return 'single' === this.selectionMode ||
          'multiple' === this.selectionMode
          ? this.selected
          : void 0
      }, 'ariaChecked'),
      ariaSelected: __name(function () {
        return this.checkboxMode ? this.checked : void 0
      }, 'ariaSelected')
    },
    components: {
      Checkbox: script$k,
      ChevronDownIcon: script$y,
      ChevronRightIcon: script$p,
      CheckIcon: script$V,
      MinusIcon: script$l,
      SpinnerIcon: script$O
    },
    directives: { ripple: Ripple }
  },
  _hoisted_1$1$2 = [
    'aria-label',
    'aria-selected',
    'aria-expanded',
    'aria-setsize',
    'aria-posinset',
    'aria-level',
    'aria-checked',
    'tabindex'
  ],
  _hoisted_2$j = ['data-p-selected', 'data-p-selectable']
function render$1$3(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('SpinnerIcon'),
    s = Vue.resolveComponent('Checkbox'),
    l = Vue.resolveComponent('TreeNode', !0),
    c = Vue.resolveDirective('ripple')
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'li',
      Vue.mergeProps(
        {
          ref: 'currentNode',
          class: e.cx('node'),
          role: 'treeitem',
          'aria-label': r.label(n.node),
          'aria-selected': r.ariaSelected,
          'aria-expanded': r.expanded,
          'aria-setsize': n.node.children ? n.node.children.length : 0,
          'aria-posinset': n.index + 1,
          'aria-level': n.level,
          'aria-checked': r.ariaChecked,
          tabindex: 0 === n.index ? 0 : -1,
          onKeydown:
            t[4] ||
            (t[4] = function () {
              return r.onKeyDown && r.onKeyDown.apply(r, arguments)
            })
        },
        1 === n.level ? r.getPTOptions('node') : e.ptm('nodeChildren')
      ),
      [
        Vue.createElementVNode(
          'div',
          Vue.mergeProps(
            {
              class: e.cx('nodeContent'),
              onClick:
                t[2] ||
                (t[2] = function () {
                  return r.onClick && r.onClick.apply(r, arguments)
                }),
              onTouchend:
                t[3] ||
                (t[3] = function () {
                  return r.onTouchEnd && r.onTouchEnd.apply(r, arguments)
                }),
              style: n.node.style
            },
            r.getPTOptions('nodeContent'),
            {
              'data-p-selected': r.checkboxMode ? r.checked : r.selected,
              'data-p-selectable': r.selectable
            }
          ),
          [
            Vue.withDirectives(
              (Vue.openBlock(),
              Vue.createElementBlock(
                'button',
                Vue.mergeProps(
                  {
                    type: 'button',
                    class: e.cx('nodeToggleButton'),
                    onClick:
                      t[0] ||
                      (t[0] = function () {
                        return r.toggle && r.toggle.apply(r, arguments)
                      }),
                    tabindex: '-1'
                  },
                  r.getPTOptions('nodeToggleButton')
                ),
                [
                  n.node.loading && 'icon' === n.loadingMode
                    ? (Vue.openBlock(),
                      Vue.createElementBlock(
                        Vue.Fragment,
                        { key: 0 },
                        [
                          n.templates.nodetoggleicon ||
                          n.templates.nodetogglericon
                            ? (Vue.openBlock(),
                              Vue.createBlock(
                                Vue.resolveDynamicComponent(
                                  n.templates.nodetoggleicon ||
                                    n.templates.nodetogglericon
                                ),
                                {
                                  key: 0,
                                  node: n.node,
                                  expanded: r.expanded,
                                  class: Vue.normalizeClass(
                                    e.cx('nodeToggleIcon')
                                  )
                                },
                                null,
                                8,
                                ['node', 'expanded', 'class']
                              ))
                            : (Vue.openBlock(),
                              Vue.createBlock(
                                a,
                                Vue.mergeProps(
                                  {
                                    key: 1,
                                    spin: '',
                                    class: e.cx('nodeToggleIcon')
                                  },
                                  r.getPTOptions('nodeToggleIcon')
                                ),
                                null,
                                16,
                                ['class']
                              ))
                        ],
                        64
                      ))
                    : (Vue.openBlock(),
                      Vue.createElementBlock(
                        Vue.Fragment,
                        { key: 1 },
                        [
                          n.templates.nodetoggleicon || n.templates.togglericon
                            ? (Vue.openBlock(),
                              Vue.createBlock(
                                Vue.resolveDynamicComponent(
                                  n.templates.nodetoggleicon ||
                                    n.templates.togglericon
                                ),
                                {
                                  key: 0,
                                  node: n.node,
                                  expanded: r.expanded,
                                  class: Vue.normalizeClass(
                                    e.cx('nodeToggleIcon')
                                  )
                                },
                                null,
                                8,
                                ['node', 'expanded', 'class']
                              ))
                            : r.expanded
                              ? (Vue.openBlock(),
                                Vue.createBlock(
                                  Vue.resolveDynamicComponent(
                                    n.node.expandedIcon
                                      ? 'span'
                                      : 'ChevronDownIcon'
                                  ),
                                  Vue.mergeProps(
                                    { key: 1, class: e.cx('nodeToggleIcon') },
                                    r.getPTOptions('nodeToggleIcon')
                                  ),
                                  null,
                                  16,
                                  ['class']
                                ))
                              : (Vue.openBlock(),
                                Vue.createBlock(
                                  Vue.resolveDynamicComponent(
                                    n.node.collapsedIcon
                                      ? 'span'
                                      : 'ChevronRightIcon'
                                  ),
                                  Vue.mergeProps(
                                    { key: 2, class: e.cx('nodeToggleIcon') },
                                    r.getPTOptions('nodeToggleIcon')
                                  ),
                                  null,
                                  16,
                                  ['class']
                                ))
                        ],
                        64
                      ))
                ],
                16
              )),
              [[c]]
            ),
            r.checkboxMode
              ? (Vue.openBlock(),
                Vue.createBlock(
                  s,
                  {
                    key: 0,
                    defaultValue: r.checked,
                    binary: !0,
                    indeterminate: r.partialChecked,
                    class: Vue.normalizeClass(e.cx('nodeCheckbox')),
                    tabindex: -1,
                    unstyled: e.unstyled,
                    pt: r.getPTOptions('pcNodeCheckbox'),
                    'data-p-partialchecked': r.partialChecked
                  },
                  {
                    icon: Vue.withCtx(function (e) {
                      return [
                        n.templates.checkboxicon
                          ? (Vue.openBlock(),
                            Vue.createBlock(
                              Vue.resolveDynamicComponent(
                                n.templates.checkboxicon
                              ),
                              {
                                key: 0,
                                checked: e.checked,
                                partialChecked: r.partialChecked,
                                class: Vue.normalizeClass(e.class)
                              },
                              null,
                              8,
                              ['checked', 'partialChecked', 'class']
                            ))
                          : Vue.createCommentVNode('', !0)
                      ]
                    }),
                    _: 1
                  },
                  8,
                  [
                    'defaultValue',
                    'indeterminate',
                    'class',
                    'unstyled',
                    'pt',
                    'data-p-partialchecked'
                  ]
                ))
              : Vue.createCommentVNode('', !0),
            n.templates.nodeicon
              ? (Vue.openBlock(),
                Vue.createBlock(
                  Vue.resolveDynamicComponent(n.templates.nodeicon),
                  Vue.mergeProps(
                    { key: 1, node: n.node, class: [e.cx('nodeIcon')] },
                    r.getPTOptions('nodeIcon')
                  ),
                  null,
                  16,
                  ['node', 'class']
                ))
              : (Vue.openBlock(),
                Vue.createElementBlock(
                  'span',
                  Vue.mergeProps(
                    { key: 2, class: [e.cx('nodeIcon'), n.node.icon] },
                    r.getPTOptions('nodeIcon')
                  ),
                  null,
                  16
                )),
            Vue.createElementVNode(
              'span',
              Vue.mergeProps(
                { class: e.cx('nodeLabel') },
                r.getPTOptions('nodeLabel'),
                {
                  onKeydown:
                    t[1] || (t[1] = Vue.withModifiers(function () {}, ['stop']))
                }
              ),
              [
                n.templates[n.node.type] || n.templates.default
                  ? (Vue.openBlock(),
                    Vue.createBlock(
                      Vue.resolveDynamicComponent(
                        n.templates[n.node.type] || n.templates.default
                      ),
                      {
                        key: 0,
                        node: n.node,
                        expanded: r.expanded,
                        selected: r.checkboxMode ? r.checked : r.selected
                      },
                      null,
                      8,
                      ['node', 'expanded', 'selected']
                    ))
                  : (Vue.openBlock(),
                    Vue.createElementBlock(
                      Vue.Fragment,
                      { key: 1 },
                      [
                        Vue.createTextVNode(
                          Vue.toDisplayString(r.label(n.node)),
                          1
                        )
                      ],
                      64
                    ))
              ],
              16
            )
          ],
          16,
          _hoisted_2$j
        ),
        r.hasChildren && r.expanded
          ? (Vue.openBlock(),
            Vue.createElementBlock(
              'ul',
              Vue.mergeProps(
                { key: 0, class: e.cx('nodeChildren'), role: 'group' },
                e.ptm('nodeChildren')
              ),
              [
                (Vue.openBlock(!0),
                Vue.createElementBlock(
                  Vue.Fragment,
                  null,
                  Vue.renderList(n.node.children, function (t) {
                    return (
                      Vue.openBlock(),
                      Vue.createBlock(
                        l,
                        {
                          key: t.key,
                          node: t,
                          templates: n.templates,
                          level: n.level + 1,
                          loadingMode: n.loadingMode,
                          expandedKeys: n.expandedKeys,
                          onNodeToggle: r.onChildNodeToggle,
                          onNodeClick: r.onChildNodeClick,
                          selectionMode: n.selectionMode,
                          selectionKeys: n.selectionKeys,
                          onCheckboxChange: r.propagateUp,
                          unstyled: e.unstyled,
                          pt: e.pt
                        },
                        null,
                        8,
                        [
                          'node',
                          'templates',
                          'level',
                          'loadingMode',
                          'expandedKeys',
                          'onNodeToggle',
                          'onNodeClick',
                          'selectionMode',
                          'selectionKeys',
                          'onCheckboxChange',
                          'unstyled',
                          'pt'
                        ]
                      )
                    )
                  }),
                  128
                ))
              ],
              16
            ))
          : Vue.createCommentVNode('', !0)
      ],
      16,
      _hoisted_1$1$2
    )
  )
}
function _typeof$1$2(e) {
  return (_typeof$1$2 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function _createForOfIteratorHelper$3(e, t) {
  var n =
    ('undefined' != typeof Symbol && e[Symbol.iterator]) || e['@@iterator']
  if (!n) {
    if (Array.isArray(e) || (n = _unsupportedIterableToArray$7(e)) || t) {
      n && (e = n)
      var o = 0,
        i = __name(function () {}, 'F')
      return {
        s: i,
        n: __name(function () {
          return o >= e.length ? { done: !0 } : { done: !1, value: e[o++] }
        }, 'n'),
        e: __name(function (e) {
          throw e
        }, 'e'),
        f: i
      }
    }
    throw new TypeError(
      'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
    )
  }
  var r,
    a = !0,
    s = !1
  return {
    s: __name(function () {
      n = n.call(e)
    }, 's'),
    n: __name(function () {
      var e = n.next()
      return (a = e.done), e
    }, 'n'),
    e: __name(function (e) {
      ;(s = !0), (r = e)
    }, 'e'),
    f: __name(function () {
      try {
        a || null == n.return || n.return()
      } finally {
        if (s) throw r
      }
    }, 'f')
  }
}
function _toConsumableArray$4(e) {
  return (
    _arrayWithoutHoles$4(e) ||
    _iterableToArray$4(e) ||
    _unsupportedIterableToArray$7(e) ||
    _nonIterableSpread$4()
  )
}
function _nonIterableSpread$4() {
  throw new TypeError(
    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$7(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$7(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$7(e, t)
          : void 0
    )
  }
}
function _iterableToArray$4(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _arrayWithoutHoles$4(e) {
  if (Array.isArray(e)) return _arrayLikeToArray$7(e)
}
function _arrayLikeToArray$7(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
function ownKeys$1$2(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$1$2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$1$2(Object(n), !0).forEach(function (t) {
          _defineProperty$1$2(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$1$2(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$1$2(e, t, n) {
  return (
    (t = _toPropertyKey$1$2(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$1$2(e) {
  var t = _toPrimitive$1$2(e, 'string')
  return 'symbol' == _typeof$1$2(t) ? t : t + ''
}
function _toPrimitive$1$2(e, t) {
  if ('object' != _typeof$1$2(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$1$2(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(render$1$3, 'render$1$3'),
  (script$1$c.render = render$1$3),
  __name(_typeof$1$2, '_typeof$1$2'),
  __name(_createForOfIteratorHelper$3, '_createForOfIteratorHelper$3'),
  __name(_toConsumableArray$4, '_toConsumableArray$4'),
  __name(_nonIterableSpread$4, '_nonIterableSpread$4'),
  __name(_unsupportedIterableToArray$7, '_unsupportedIterableToArray$7'),
  __name(_iterableToArray$4, '_iterableToArray$4'),
  __name(_arrayWithoutHoles$4, '_arrayWithoutHoles$4'),
  __name(_arrayLikeToArray$7, '_arrayLikeToArray$7'),
  __name(ownKeys$1$2, 'ownKeys$1$2'),
  __name(_objectSpread$1$2, '_objectSpread$1$2'),
  __name(_defineProperty$1$2, '_defineProperty$1$2'),
  __name(_toPropertyKey$1$2, '_toPropertyKey$1$2'),
  __name(_toPrimitive$1$2, '_toPrimitive$1$2')
var script$j = {
  name: 'Tree',
  extends: script$2$3,
  inheritAttrs: !1,
  emits: [
    'node-expand',
    'node-collapse',
    'update:expandedKeys',
    'update:selectionKeys',
    'node-select',
    'node-unselect',
    'filter'
  ],
  data: __name(function () {
    return { d_expandedKeys: this.expandedKeys || {}, filterValue: null }
  }, 'data'),
  watch: {
    expandedKeys: __name(function (e) {
      this.d_expandedKeys = e
    }, 'expandedKeys')
  },
  methods: {
    onNodeToggle: __name(function (e) {
      var t = e.key
      this.d_expandedKeys[t]
        ? (delete this.d_expandedKeys[t], this.$emit('node-collapse', e))
        : ((this.d_expandedKeys[t] = !0), this.$emit('node-expand', e)),
        (this.d_expandedKeys = _objectSpread$1$2({}, this.d_expandedKeys)),
        this.$emit('update:expandedKeys', this.d_expandedKeys)
    }, 'onNodeToggle'),
    onNodeClick: __name(function (e) {
      if (null != this.selectionMode && !1 !== e.node.selectable) {
        var t =
          !e.nodeTouched && this.metaKeySelection
            ? this.handleSelectionWithMetaKey(e)
            : this.handleSelectionWithoutMetaKey(e)
        this.$emit('update:selectionKeys', t)
      }
    }, 'onNodeClick'),
    onCheckboxChange: __name(function (e) {
      this.$emit('update:selectionKeys', e.selectionKeys),
        e.check
          ? this.$emit('node-select', e.node)
          : this.$emit('node-unselect', e.node)
    }, 'onCheckboxChange'),
    handleSelectionWithMetaKey: __name(function (e) {
      var t,
        n = e.originalEvent,
        o = e.node,
        i = n.metaKey || n.ctrlKey
      return (
        this.isNodeSelected(o) && i
          ? (this.isSingleSelectionMode()
              ? (t = {})
              : delete (t = _objectSpread$1$2({}, this.selectionKeys))[o.key],
            this.$emit('node-unselect', o))
          : (this.isSingleSelectionMode()
              ? (t = {})
              : this.isMultipleSelectionMode() &&
                (t =
                  i && this.selectionKeys
                    ? _objectSpread$1$2({}, this.selectionKeys)
                    : {}),
            (t[o.key] = !0),
            this.$emit('node-select', o)),
        t
      )
    }, 'handleSelectionWithMetaKey'),
    handleSelectionWithoutMetaKey: __name(function (e) {
      var t,
        n = e.node,
        o = this.isNodeSelected(n)
      return (
        this.isSingleSelectionMode()
          ? o
            ? ((t = {}), this.$emit('node-unselect', n))
            : (((t = {})[n.key] = !0), this.$emit('node-select', n))
          : o
            ? (delete (t = _objectSpread$1$2({}, this.selectionKeys))[n.key],
              this.$emit('node-unselect', n))
            : (((t = this.selectionKeys
                ? _objectSpread$1$2({}, this.selectionKeys)
                : {})[n.key] = !0),
              this.$emit('node-select', n)),
        t
      )
    }, 'handleSelectionWithoutMetaKey'),
    isSingleSelectionMode: __name(function () {
      return 'single' === this.selectionMode
    }, 'isSingleSelectionMode'),
    isMultipleSelectionMode: __name(function () {
      return 'multiple' === this.selectionMode
    }, 'isMultipleSelectionMode'),
    isNodeSelected: __name(function (e) {
      return (
        !(!this.selectionMode || !this.selectionKeys) &&
        !0 === this.selectionKeys[e.key]
      )
    }, 'isNodeSelected'),
    isChecked: __name(function (e) {
      return (
        !!this.selectionKeys &&
        this.selectionKeys[e.key] &&
        this.selectionKeys[e.key].checked
      )
    }, 'isChecked'),
    isNodeLeaf: __name(function (e) {
      return !1 !== e.leaf && !(e.children && e.children.length)
    }, 'isNodeLeaf'),
    onFilterKeydown: __name(function (e) {
      ;('Enter' !== e.code && 'NumpadEnter' !== e.code) || e.preventDefault(),
        this.$emit('filter', { originalEvent: e, value: e.target.value })
    }, 'onFilterKeydown'),
    findFilteredNodes: __name(function (e, t) {
      if (e) {
        var n = !1
        if (e.children) {
          var o = _toConsumableArray$4(e.children)
          e.children = []
          var i,
            r = _createForOfIteratorHelper$3(o)
          try {
            for (r.s(); !(i = r.n()).done; ) {
              var a = _objectSpread$1$2({}, i.value)
              this.isFilterMatched(a, t) && ((n = !0), e.children.push(a))
            }
          } catch (s) {
            r.e(s)
          } finally {
            r.f()
          }
        }
        if (n) return !0
      }
    }, 'findFilteredNodes'),
    isFilterMatched: __name(function (e, t) {
      var n,
        o = t.searchFields,
        i = t.filterText,
        r = t.strict,
        a = !1,
        s = _createForOfIteratorHelper$3(o)
      try {
        for (s.s(); !(n = s.n()).done; ) {
          var l = n.value
          String(resolveFieldData(e, l))
            .toLocaleLowerCase(this.filterLocale)
            .indexOf(i) > -1 && (a = !0)
        }
      } catch (c) {
        s.e(c)
      } finally {
        s.f()
      }
      return (
        (!a || (r && !this.isNodeLeaf(e))) &&
          (a =
            this.findFilteredNodes(e, {
              searchFields: o,
              filterText: i,
              strict: r
            }) || a),
        a
      )
    }, 'isFilterMatched')
  },
  computed: {
    filteredValue: __name(function () {
      var e,
        t = [],
        n = isFunction$1(this.filterBy)
          ? [this.filterBy]
          : this.filterBy.split(','),
        o = this.filterValue.trim().toLocaleLowerCase(this.filterLocale),
        i = 'strict' === this.filterMode,
        r = _createForOfIteratorHelper$3(this.value)
      try {
        for (r.s(); !(e = r.n()).done; ) {
          var a = _objectSpread$1$2({}, e.value),
            s = { searchFields: n, filterText: o, strict: i }
          ;((i &&
            (this.findFilteredNodes(a, s) || this.isFilterMatched(a, s))) ||
            (!i &&
              (this.isFilterMatched(a, s) || this.findFilteredNodes(a, s)))) &&
            t.push(a)
        }
      } catch (l) {
        r.e(l)
      } finally {
        r.f()
      }
      return t
    }, 'filteredValue'),
    valueToRender: __name(function () {
      return this.filterValue && this.filterValue.trim().length > 0
        ? this.filteredValue
        : this.value
    }, 'valueToRender')
  },
  components: {
    TreeNode: script$1$c,
    InputText: script$P,
    InputIcon: script$S,
    IconField: script$T,
    SearchIcon: script$U,
    SpinnerIcon: script$O
  }
}
function _typeof$8(e) {
  return (_typeof$8 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$a(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$a(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$a(Object(n), !0).forEach(function (t) {
          _defineProperty$8(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$a(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$8(e, t, n) {
  return (
    (t = _toPropertyKey$7(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$7(e) {
  var t = _toPrimitive$7(e, 'string')
  return 'symbol' == _typeof$8(t) ? t : t + ''
}
function _toPrimitive$7(e, t) {
  if ('object' != _typeof$8(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$8(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$8, '_typeof$8'),
  __name(ownKeys$a, 'ownKeys$a'),
  __name(_objectSpread$a, '_objectSpread$a'),
  __name(_defineProperty$8, '_defineProperty$8'),
  __name(_toPropertyKey$7, '_toPropertyKey$7'),
  __name(_toPrimitive$7, '_toPrimitive$7')
var _hoisted_1$u = ['aria-labelledby', 'aria-label']
function render$i(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('SpinnerIcon'),
    s = Vue.resolveComponent('InputText'),
    l = Vue.resolveComponent('SearchIcon'),
    c = Vue.resolveComponent('InputIcon'),
    d = Vue.resolveComponent('IconField'),
    u = Vue.resolveComponent('TreeNode')
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps({ class: e.cx('root') }, e.ptmi('root')),
      [
        e.loading && 'mask' === e.loadingMode
          ? (Vue.openBlock(),
            Vue.createElementBlock(
              'div',
              Vue.mergeProps({ key: 0, class: e.cx('mask') }, e.ptm('mask')),
              [
                Vue.renderSlot(
                  e.$slots,
                  'loadingicon',
                  { class: Vue.normalizeClass(e.cx('loadingIcon')) },
                  function () {
                    return [
                      e.loadingIcon
                        ? (Vue.openBlock(),
                          Vue.createElementBlock(
                            'i',
                            Vue.mergeProps(
                              {
                                key: 0,
                                class: [
                                  e.cx('loadingIcon'),
                                  'pi-spin',
                                  e.loadingIcon
                                ]
                              },
                              e.ptm('loadingIcon')
                            ),
                            null,
                            16
                          ))
                        : (Vue.openBlock(),
                          Vue.createBlock(
                            a,
                            Vue.mergeProps(
                              { key: 1, spin: '', class: e.cx('loadingIcon') },
                              e.ptm('loadingIcon')
                            ),
                            null,
                            16,
                            ['class']
                          ))
                    ]
                  }
                )
              ],
              16
            ))
          : Vue.createCommentVNode('', !0),
        e.filter
          ? (Vue.openBlock(),
            Vue.createBlock(
              d,
              {
                key: 1,
                unstyled: e.unstyled,
                pt: _objectSpread$a(
                  _objectSpread$a({}, e.ptm('pcFilter')),
                  e.ptm('pcFilterContainer')
                ),
                class: Vue.normalizeClass(e.cx('pcFilterContainer'))
              },
              {
                default: Vue.withCtx(function () {
                  return [
                    Vue.createVNode(
                      s,
                      {
                        modelValue: i.filterValue,
                        'onUpdate:modelValue':
                          t[0] ||
                          (t[0] = function (e) {
                            return (i.filterValue = e)
                          }),
                        autocomplete: 'off',
                        class: Vue.normalizeClass(e.cx('pcFilterInput')),
                        placeholder: e.filterPlaceholder,
                        unstyled: e.unstyled,
                        onKeydown: r.onFilterKeydown,
                        pt: e.ptm('pcFilterInput')
                      },
                      null,
                      8,
                      [
                        'modelValue',
                        'class',
                        'placeholder',
                        'unstyled',
                        'onKeydown',
                        'pt'
                      ]
                    ),
                    Vue.createVNode(
                      c,
                      {
                        unstyled: e.unstyled,
                        pt: e.ptm('pcFilterIconContainer')
                      },
                      {
                        default: Vue.withCtx(function () {
                          return [
                            Vue.renderSlot(
                              e.$slots,
                              e.$slots.filtericon ? 'filtericon' : 'searchicon',
                              { class: Vue.normalizeClass(e.cx('filterIcon')) },
                              function () {
                                return [
                                  Vue.createVNode(
                                    l,
                                    Vue.mergeProps(
                                      { class: e.cx('filterIcon') },
                                      e.ptm('filterIcon')
                                    ),
                                    null,
                                    16,
                                    ['class']
                                  )
                                ]
                              }
                            )
                          ]
                        }),
                        _: 3
                      },
                      8,
                      ['unstyled', 'pt']
                    )
                  ]
                }),
                _: 3
              },
              8,
              ['unstyled', 'pt', 'class']
            ))
          : Vue.createCommentVNode('', !0),
        Vue.createElementVNode(
          'div',
          Vue.mergeProps(
            { class: e.cx('wrapper'), style: { maxHeight: e.scrollHeight } },
            e.ptm('wrapper')
          ),
          [
            Vue.renderSlot(e.$slots, 'header', {
              value: e.value,
              expandedKeys: e.expandedKeys,
              selectionKeys: e.selectionKeys
            }),
            Vue.createElementVNode(
              'ul',
              Vue.mergeProps(
                {
                  class: e.cx('rootChildren'),
                  role: 'tree',
                  'aria-labelledby': e.ariaLabelledby,
                  'aria-label': e.ariaLabel
                },
                e.ptm('rootChildren')
              ),
              [
                (Vue.openBlock(!0),
                Vue.createElementBlock(
                  Vue.Fragment,
                  null,
                  Vue.renderList(r.valueToRender, function (t, n) {
                    return (
                      Vue.openBlock(),
                      Vue.createBlock(
                        u,
                        {
                          key: t.key,
                          node: t,
                          templates: e.$slots,
                          level: e.level + 1,
                          index: n,
                          expandedKeys: i.d_expandedKeys,
                          onNodeToggle: r.onNodeToggle,
                          onNodeClick: r.onNodeClick,
                          selectionMode: e.selectionMode,
                          selectionKeys: e.selectionKeys,
                          onCheckboxChange: r.onCheckboxChange,
                          loadingMode: e.loadingMode,
                          unstyled: e.unstyled,
                          pt: e.pt
                        },
                        null,
                        8,
                        [
                          'node',
                          'templates',
                          'level',
                          'index',
                          'expandedKeys',
                          'onNodeToggle',
                          'onNodeClick',
                          'selectionMode',
                          'selectionKeys',
                          'onCheckboxChange',
                          'loadingMode',
                          'unstyled',
                          'pt'
                        ]
                      )
                    )
                  }),
                  128
                ))
              ],
              16,
              _hoisted_1$u
            ),
            Vue.renderSlot(e.$slots, 'footer', {
              value: e.value,
              expandedKeys: e.expandedKeys,
              selectionKeys: e.selectionKeys
            })
          ],
          16
        )
      ],
      16
    )
  )
}
__name(render$i, 'render$i'), (script$j.render = render$i)
var theme$c = __name(function (e) {
    var t = e.dt
    return '\n.p-contextmenu {\n    background: '
      .concat(t('contextmenu.background'), ';\n    color: ')
      .concat(t('contextmenu.color'), ';\n    border: 1px solid ')
      .concat(t('contextmenu.border.color'), ';\n    border-radius: ')
      .concat(t('contextmenu.border.radius'), ';\n    box-shadow: ')
      .concat(
        t('contextmenu.shadow'),
        ';\n    min-width: 12.5rem;\n}\n\n.p-contextmenu-root-list,\n.p-contextmenu-submenu {\n    margin: 0;\n    padding: '
      )
      .concat(
        t('contextmenu.list.padding'),
        ';\n    list-style: none;\n    outline: 0 none;\n    display: flex;\n    flex-direction: column;\n    gap: '
      )
      .concat(
        t('contextmenu.list.gap'),
        ';\n}\n\n.p-contextmenu-submenu {\n    position: absolute;\n    display: flex;\n    flex-direction: column;\n    min-width: 100%;\n    z-index: 1;\n    background: '
      )
      .concat(t('contextmenu.background'), ';\n    color: ')
      .concat(t('contextmenu.color'), ';\n    border: 1px solid ')
      .concat(t('contextmenu.border.color'), ';\n    border-radius: ')
      .concat(t('contextmenu.border.radius'), ';\n    box-shadow: ')
      .concat(
        t('contextmenu.shadow'),
        ';\n}\n\n.p-contextmenu-item {\n    position: relative;\n}\n\n.p-contextmenu-item-content {\n    transition: background '
      )
      .concat(t('contextmenu.transition.duration'), ', color ')
      .concat(t('contextmenu.transition.duration'), ';\n    border-radius: ')
      .concat(t('contextmenu.item.border.radius'), ';\n    color: ')
      .concat(
        t('contextmenu.item.color'),
        ';\n}\n\n.p-contextmenu-item-link {\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    text-decoration: none;\n    overflow: hidden;\n    position: relative;\n    color: inherit;\n    padding: '
      )
      .concat(t('contextmenu.item.padding'), ';\n    gap: ')
      .concat(
        t('contextmenu.item.gap'),
        ';\n    user-select: none;\n}\n\n.p-contextmenu-item-label {\n    line-height: 1;\n}\n\n.p-contextmenu-item-icon {\n    color: '
      )
      .concat(
        t('contextmenu.item.icon.color'),
        ';\n}\n\n.p-contextmenu-submenu-icon {\n    color: '
      )
      .concat(
        t('contextmenu.submenu.icon.color'),
        ';\n    margin-left: auto;\n    font-size: '
      )
      .concat(t('contextmenu.submenu.icon.size'), ';\n    width: ')
      .concat(t('contextmenu.submenu.icon.size'), ';\n    height: ')
      .concat(
        t('contextmenu.submenu.icon.size'),
        ';\n}\n\n.p-contextmenu-submenu-icon:dir(rtl) {\n    margin-left: 0;\n    margin-right: auto;\n}\n\n.p-contextmenu-item.p-focus > .p-contextmenu-item-content {\n    color: '
      )
      .concat(t('contextmenu.item.focus.color'), ';\n    background: ')
      .concat(
        t('contextmenu.item.focus.background'),
        ';\n}\n\n.p-contextmenu-item.p-focus > .p-contextmenu-item-content .p-contextmenu-item-icon {\n    color: '
      )
      .concat(
        t('contextmenu.item.icon.focus.color'),
        ';\n}\n\n.p-contextmenu-item.p-focus > .p-contextmenu-item-content .p-contextmenu-submenu-icon {\n    color: '
      )
      .concat(
        t('contextmenu.submenu.icon.focus.color'),
        ';\n}\n\n.p-contextmenu-item:not(.p-disabled) > .p-contextmenu-item-content:hover {\n    color: '
      )
      .concat(t('contextmenu.item.focus.color'), ';\n    background: ')
      .concat(
        t('contextmenu.item.focus.background'),
        ';\n}\n\n.p-contextmenu-item:not(.p-disabled) > .p-contextmenu-item-content:hover .p-contextmenu-item-icon {\n    color: '
      )
      .concat(
        t('contextmenu.item.icon.focus.color'),
        ';\n}\n\n.p-contextmenu-item:not(.p-disabled) > .p-contextmenu-item-content:hover .p-contextmenu-submenu-icon {\n    color: '
      )
      .concat(
        t('contextmenu.submenu.icon.focus.color'),
        ';\n}\n\n.p-contextmenu-item-active > .p-contextmenu-item-content {\n    color: '
      )
      .concat(t('contextmenu.item.active.color'), ';\n    background: ')
      .concat(
        t('contextmenu.item.active.background'),
        ';\n}\n\n.p-contextmenu-item-active > .p-contextmenu-item-content .p-contextmenu-item-icon {\n    color: '
      )
      .concat(
        t('contextmenu.item.icon.active.color'),
        ';\n}\n\n.p-contextmenu-item-active > .p-contextmenu-item-content .p-contextmenu-submenu-icon {\n    color: '
      )
      .concat(
        t('contextmenu.submenu.icon.active.color'),
        ';\n}\n\n.p-contextmenu-separator {\n    border-block-start: 1px solid '
      )
      .concat(
        t('contextmenu.separator.border.color'),
        ';\n}\n\n.p-contextmenu-enter-from,\n.p-contextmenu-leave-active {\n    opacity: 0;\n}\n\n.p-contextmenu-enter-active {\n    transition: opacity 250ms;\n}\n\n.p-contextmenu-mobile .p-contextmenu-submenu {\n    position: static;\n    box-shadow: none;\n    border: 0 none;\n    padding-inline-start: '
      )
      .concat(
        t('tieredmenu.submenu.mobile.indent'),
        ';\n    padding-inline-end: 0;\n}\n\n.p-contextmenu-mobile .p-contextmenu-submenu-icon {\n    transition: transform 0.2s;\n    transform: rotate(90deg);\n}\n\n.p-contextmenu-mobile .p-contextmenu-item-active > .p-contextmenu-item-content .p-contextmenu-submenu-icon {\n    transform: rotate(-90deg);\n}\n'
      )
  }, 'theme'),
  classes$c = {
    root: __name(function (e) {
      return [
        'p-contextmenu p-component',
        { 'p-contextmenu-mobile': e.instance.queryMatches }
      ]
    }, 'root'),
    rootList: 'p-contextmenu-root-list',
    item: __name(function (e) {
      var t = e.instance,
        n = e.processedItem
      return [
        'p-contextmenu-item',
        {
          'p-contextmenu-item-active': t.isItemActive(n),
          'p-focus': t.isItemFocused(n),
          'p-disabled': t.isItemDisabled(n)
        }
      ]
    }, 'item'),
    itemContent: 'p-contextmenu-item-content',
    itemLink: 'p-contextmenu-item-link',
    itemIcon: 'p-contextmenu-item-icon',
    itemLabel: 'p-contextmenu-item-label',
    submenuIcon: 'p-contextmenu-submenu-icon',
    submenu: 'p-contextmenu-submenu',
    separator: 'p-contextmenu-separator'
  },
  ContextMenuStyle = BaseStyle.extend({
    name: 'contextmenu',
    theme: theme$c,
    classes: classes$c
  }),
  script$i = { name: 'AngleRightIcon', extends: script$X }
function render$h(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              d: 'M5.25 11.1728C5.14929 11.1694 5.05033 11.1455 4.9592 11.1025C4.86806 11.0595 4.78666 10.9984 4.72 10.9228C4.57955 10.7822 4.50066 10.5916 4.50066 10.3928C4.50066 10.1941 4.57955 10.0035 4.72 9.86283L7.72 6.86283L4.72 3.86283C4.66067 3.71882 4.64765 3.55991 4.68275 3.40816C4.71785 3.25642 4.79932 3.11936 4.91585 3.01602C5.03238 2.91268 5.17819 2.84819 5.33305 2.83149C5.4879 2.81479 5.64411 2.84671 5.78 2.92283L9.28 6.42283C9.42045 6.56346 9.49934 6.75408 9.49934 6.95283C9.49934 7.15158 9.42045 7.34221 9.28 7.48283L5.78 10.9228C5.71333 10.9984 5.63193 11.0595 5.5408 11.1025C5.44966 11.1455 5.35071 11.1694 5.25 11.1728Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$h, 'render$h'), (script$i.render = render$h)
var script$2$2 = {
    name: 'BaseContextMenu',
    extends: script$Y,
    props: {
      model: { type: Array, default: null },
      appendTo: { type: [String, Object], default: 'body' },
      autoZIndex: { type: Boolean, default: !0 },
      baseZIndex: { type: Number, default: 0 },
      global: { type: Boolean, default: !1 },
      breakpoint: { type: String, default: '960px' },
      tabindex: { type: Number, default: 0 },
      ariaLabelledby: { type: String, default: null },
      ariaLabel: { type: String, default: null }
    },
    style: ContextMenuStyle,
    provide: __name(function () {
      return { $pcContextMenu: this, $parentInstance: this }
    }, 'provide')
  },
  script$1$b = {
    name: 'ContextMenuSub',
    hostName: 'ContextMenu',
    extends: script$Y,
    emits: ['item-click', 'item-mouseenter', 'item-mousemove'],
    props: {
      items: { type: Array, default: null },
      menuId: { type: String, default: null },
      focusedItemId: { type: String, default: null },
      root: { type: Boolean, default: !1 },
      visible: { type: Boolean, default: !1 },
      level: { type: Number, default: 0 },
      templates: { type: Object, default: null },
      activeItemPath: { type: Object, default: null },
      tabindex: { type: Number, default: 0 }
    },
    methods: {
      getItemId: __name(function (e) {
        return ''.concat(this.menuId, '_').concat(e.key)
      }, 'getItemId'),
      getItemKey: __name(function (e) {
        return this.getItemId(e)
      }, 'getItemKey'),
      getItemProp: __name(function (e, t, n) {
        return e && e.item ? resolve(e.item[t], n) : void 0
      }, 'getItemProp'),
      getItemLabel: __name(function (e) {
        return this.getItemProp(e, 'label')
      }, 'getItemLabel'),
      getItemLabelId: __name(function (e) {
        return ''.concat(this.menuId, '_').concat(e.key, '_label')
      }, 'getItemLabelId'),
      getPTOptions: __name(function (e, t, n) {
        return this.ptm(e, {
          context: {
            item: t.item,
            active: this.isItemActive(t),
            focused: this.isItemFocused(t),
            disabled: this.isItemDisabled(t),
            index: n
          }
        })
      }, 'getPTOptions'),
      isItemActive: __name(function (e) {
        return this.activeItemPath.some(function (t) {
          return t.key === e.key
        })
      }, 'isItemActive'),
      isItemVisible: __name(function (e) {
        return !1 !== this.getItemProp(e, 'visible')
      }, 'isItemVisible'),
      isItemDisabled: __name(function (e) {
        return this.getItemProp(e, 'disabled')
      }, 'isItemDisabled'),
      isItemFocused: __name(function (e) {
        return this.focusedItemId === this.getItemId(e)
      }, 'isItemFocused'),
      isItemGroup: __name(function (e) {
        return isNotEmpty(e.items)
      }, 'isItemGroup'),
      onItemClick: __name(function (e, t) {
        this.getItemProp(t, 'command', { originalEvent: e, item: t.item }),
          this.$emit('item-click', {
            originalEvent: e,
            processedItem: t,
            isFocus: !0
          })
      }, 'onItemClick'),
      onItemMouseEnter: __name(function (e, t) {
        this.$emit('item-mouseenter', { originalEvent: e, processedItem: t })
      }, 'onItemMouseEnter'),
      onItemMouseMove: __name(function (e, t) {
        this.$emit('item-mousemove', {
          originalEvent: e,
          processedItem: t,
          isFocus: !0
        })
      }, 'onItemMouseMove'),
      getAriaSetSize: __name(function () {
        var e = this
        return this.items.filter(function (t) {
          return e.isItemVisible(t) && !e.getItemProp(t, 'separator')
        }).length
      }, 'getAriaSetSize'),
      getAriaPosInset: __name(function (e) {
        var t = this
        return (
          e -
          this.items.slice(0, e).filter(function (e) {
            return t.isItemVisible(e) && t.getItemProp(e, 'separator')
          }).length +
          1
        )
      }, 'getAriaPosInset'),
      onEnter: __name(function () {
        nestedPosition(this.$refs.container, this.level)
      }, 'onEnter'),
      getMenuItemProps: __name(function (e, t) {
        return {
          action: Vue.mergeProps(
            { class: this.cx('itemLink'), tabindex: -1 },
            this.getPTOptions('itemLink', e, t)
          ),
          icon: Vue.mergeProps(
            { class: [this.cx('itemIcon'), this.getItemProp(e, 'icon')] },
            this.getPTOptions('itemIcon', e, t)
          ),
          label: Vue.mergeProps(
            { class: this.cx('itemLabel') },
            this.getPTOptions('itemLabel', e, t)
          ),
          submenuicon: Vue.mergeProps(
            { class: this.cx('submenuIcon') },
            this.getPTOptions('submenuicon', e, t)
          )
        }
      }, 'getMenuItemProps')
    },
    components: { AngleRightIcon: script$i },
    directives: { ripple: Ripple }
  },
  _hoisted_1$t = ['tabindex'],
  _hoisted_2$i = [
    'id',
    'aria-label',
    'aria-disabled',
    'aria-expanded',
    'aria-haspopup',
    'aria-level',
    'aria-setsize',
    'aria-posinset',
    'data-p-active',
    'data-p-focused',
    'data-p-disabled'
  ],
  _hoisted_3$b = ['onClick', 'onMouseenter', 'onMousemove'],
  _hoisted_4$7 = ['href', 'target'],
  _hoisted_5$6 = ['id'],
  _hoisted_6$4 = ['id']
function render$1$2(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('AngleRightIcon'),
    s = Vue.resolveComponent('ContextMenuSub', !0),
    l = Vue.resolveDirective('ripple')
  return (
    Vue.openBlock(),
    Vue.createBlock(
      Vue.Transition,
      Vue.mergeProps(
        { name: 'p-contextmenusub', onEnter: r.onEnter },
        e.ptm('menu.transition')
      ),
      {
        default: Vue.withCtx(function () {
          return [
            n.root || n.visible
              ? (Vue.openBlock(),
                Vue.createElementBlock(
                  'ul',
                  Vue.mergeProps(
                    { key: 0, ref: 'container', tabindex: n.tabindex },
                    e.ptm('rootList')
                  ),
                  [
                    (Vue.openBlock(!0),
                    Vue.createElementBlock(
                      Vue.Fragment,
                      null,
                      Vue.renderList(n.items, function (o, i) {
                        return (
                          Vue.openBlock(),
                          Vue.createElementBlock(
                            Vue.Fragment,
                            { key: r.getItemKey(o) },
                            [
                              r.isItemVisible(o) &&
                              !r.getItemProp(o, 'separator')
                                ? (Vue.openBlock(),
                                  Vue.createElementBlock(
                                    'li',
                                    Vue.mergeProps(
                                      {
                                        key: 0,
                                        id: r.getItemId(o),
                                        style: r.getItemProp(o, 'style'),
                                        class: [
                                          e.cx('item', { processedItem: o }),
                                          r.getItemProp(o, 'class')
                                        ],
                                        role: 'menuitem',
                                        'aria-label': r.getItemLabel(o),
                                        'aria-disabled':
                                          r.isItemDisabled(o) || void 0,
                                        'aria-expanded': r.isItemGroup(o)
                                          ? r.isItemActive(o)
                                          : void 0,
                                        'aria-haspopup':
                                          r.isItemGroup(o) &&
                                          !r.getItemProp(o, 'to')
                                            ? 'menu'
                                            : void 0,
                                        'aria-level': n.level + 1,
                                        'aria-setsize': r.getAriaSetSize(),
                                        'aria-posinset': r.getAriaPosInset(i),
                                        ref_for: !0
                                      },
                                      r.getPTOptions('item', o, i),
                                      {
                                        'data-p-active': r.isItemActive(o),
                                        'data-p-focused': r.isItemFocused(o),
                                        'data-p-disabled': r.isItemDisabled(o)
                                      }
                                    ),
                                    [
                                      Vue.createElementVNode(
                                        'div',
                                        Vue.mergeProps(
                                          {
                                            class: e.cx('itemContent'),
                                            onClick: __name(function (e) {
                                              return r.onItemClick(e, o)
                                            }, 'onClick'),
                                            onMouseenter: __name(function (e) {
                                              return r.onItemMouseEnter(e, o)
                                            }, 'onMouseenter'),
                                            onMousemove: __name(function (e) {
                                              return r.onItemMouseMove(e, o)
                                            }, 'onMousemove'),
                                            ref_for: !0
                                          },
                                          r.getPTOptions('itemContent', o, i)
                                        ),
                                        [
                                          n.templates.item
                                            ? (Vue.openBlock(),
                                              Vue.createBlock(
                                                Vue.resolveDynamicComponent(
                                                  n.templates.item
                                                ),
                                                {
                                                  key: 1,
                                                  item: o.item,
                                                  hasSubmenu: r.getItemProp(
                                                    o,
                                                    'items'
                                                  ),
                                                  label: r.getItemLabel(o),
                                                  props: r.getMenuItemProps(
                                                    o,
                                                    i
                                                  )
                                                },
                                                null,
                                                8,
                                                [
                                                  'item',
                                                  'hasSubmenu',
                                                  'label',
                                                  'props'
                                                ]
                                              ))
                                            : Vue.withDirectives(
                                                (Vue.openBlock(),
                                                Vue.createElementBlock(
                                                  'a',
                                                  Vue.mergeProps(
                                                    {
                                                      key: 0,
                                                      href: r.getItemProp(
                                                        o,
                                                        'url'
                                                      ),
                                                      class: e.cx('itemLink'),
                                                      target: r.getItemProp(
                                                        o,
                                                        'target'
                                                      ),
                                                      tabindex: '-1',
                                                      ref_for: !0
                                                    },
                                                    r.getPTOptions(
                                                      'itemLink',
                                                      o,
                                                      i
                                                    )
                                                  ),
                                                  [
                                                    n.templates.itemicon
                                                      ? (Vue.openBlock(),
                                                        Vue.createBlock(
                                                          Vue.resolveDynamicComponent(
                                                            n.templates.itemicon
                                                          ),
                                                          {
                                                            key: 0,
                                                            item: o.item,
                                                            class:
                                                              Vue.normalizeClass(
                                                                e.cx('itemIcon')
                                                              )
                                                          },
                                                          null,
                                                          8,
                                                          ['item', 'class']
                                                        ))
                                                      : r.getItemProp(o, 'icon')
                                                        ? (Vue.openBlock(),
                                                          Vue.createElementBlock(
                                                            'span',
                                                            Vue.mergeProps(
                                                              {
                                                                key: 1,
                                                                class: [
                                                                  e.cx(
                                                                    'itemIcon'
                                                                  ),
                                                                  r.getItemProp(
                                                                    o,
                                                                    'icon'
                                                                  )
                                                                ],
                                                                ref_for: !0
                                                              },
                                                              r.getPTOptions(
                                                                'itemIcon',
                                                                o,
                                                                i
                                                              )
                                                            ),
                                                            null,
                                                            16
                                                          ))
                                                        : Vue.createCommentVNode(
                                                            '',
                                                            !0
                                                          ),
                                                    Vue.createElementVNode(
                                                      'span',
                                                      Vue.mergeProps(
                                                        {
                                                          id: r.getItemLabelId(
                                                            o
                                                          ),
                                                          class:
                                                            e.cx('itemLabel'),
                                                          ref_for: !0
                                                        },
                                                        r.getPTOptions(
                                                          'itemLabel',
                                                          o,
                                                          i
                                                        )
                                                      ),
                                                      Vue.toDisplayString(
                                                        r.getItemLabel(o)
                                                      ),
                                                      17,
                                                      _hoisted_5$6
                                                    ),
                                                    r.getItemProp(o, 'items')
                                                      ? (Vue.openBlock(),
                                                        Vue.createElementBlock(
                                                          Vue.Fragment,
                                                          { key: 2 },
                                                          [
                                                            n.templates
                                                              .submenuicon
                                                              ? (Vue.openBlock(),
                                                                Vue.createBlock(
                                                                  Vue.resolveDynamicComponent(
                                                                    n.templates
                                                                      .submenuicon
                                                                  ),
                                                                  {
                                                                    key: 0,
                                                                    active:
                                                                      r.isItemActive(
                                                                        o
                                                                      ),
                                                                    class:
                                                                      Vue.normalizeClass(
                                                                        e.cx(
                                                                          'submenuIcon'
                                                                        )
                                                                      )
                                                                  },
                                                                  null,
                                                                  8,
                                                                  [
                                                                    'active',
                                                                    'class'
                                                                  ]
                                                                ))
                                                              : (Vue.openBlock(),
                                                                Vue.createBlock(
                                                                  a,
                                                                  Vue.mergeProps(
                                                                    {
                                                                      key: 1,
                                                                      class:
                                                                        e.cx(
                                                                          'submenuIcon'
                                                                        ),
                                                                      ref_for:
                                                                        !0
                                                                    },
                                                                    r.getPTOptions(
                                                                      'submenuicon',
                                                                      o,
                                                                      i
                                                                    )
                                                                  ),
                                                                  null,
                                                                  16,
                                                                  ['class']
                                                                ))
                                                          ],
                                                          64
                                                        ))
                                                      : Vue.createCommentVNode(
                                                          '',
                                                          !0
                                                        )
                                                  ],
                                                  16,
                                                  _hoisted_4$7
                                                )),
                                                [[l]]
                                              )
                                        ],
                                        16,
                                        _hoisted_3$b
                                      ),
                                      r.isItemVisible(o) && r.isItemGroup(o)
                                        ? (Vue.openBlock(),
                                          Vue.createBlock(
                                            s,
                                            Vue.mergeProps(
                                              {
                                                key: 0,
                                                id: r.getItemId(o) + '_list',
                                                role: 'menu',
                                                class: e.cx('submenu'),
                                                menuId: n.menuId,
                                                focusedItemId: n.focusedItemId,
                                                items: o.items,
                                                templates: n.templates,
                                                activeItemPath:
                                                  n.activeItemPath,
                                                level: n.level + 1,
                                                visible:
                                                  r.isItemActive(o) &&
                                                  r.isItemGroup(o),
                                                pt: e.pt,
                                                unstyled: e.unstyled,
                                                onItemClick:
                                                  t[0] ||
                                                  (t[0] = function (t) {
                                                    return e.$emit(
                                                      'item-click',
                                                      t
                                                    )
                                                  }),
                                                onItemMouseenter:
                                                  t[1] ||
                                                  (t[1] = function (t) {
                                                    return e.$emit(
                                                      'item-mouseenter',
                                                      t
                                                    )
                                                  }),
                                                onItemMousemove:
                                                  t[2] ||
                                                  (t[2] = function (t) {
                                                    return e.$emit(
                                                      'item-mousemove',
                                                      t
                                                    )
                                                  }),
                                                'aria-labelledby':
                                                  r.getItemLabelId(o),
                                                ref_for: !0
                                              },
                                              e.ptm('submenu')
                                            ),
                                            null,
                                            16,
                                            [
                                              'id',
                                              'class',
                                              'menuId',
                                              'focusedItemId',
                                              'items',
                                              'templates',
                                              'activeItemPath',
                                              'level',
                                              'visible',
                                              'pt',
                                              'unstyled',
                                              'aria-labelledby'
                                            ]
                                          ))
                                        : Vue.createCommentVNode('', !0)
                                    ],
                                    16,
                                    _hoisted_2$i
                                  ))
                                : Vue.createCommentVNode('', !0),
                              r.isItemVisible(o) &&
                              r.getItemProp(o, 'separator')
                                ? (Vue.openBlock(),
                                  Vue.createElementBlock(
                                    'li',
                                    Vue.mergeProps(
                                      {
                                        key: 1,
                                        id: r.getItemId(o),
                                        style: r.getItemProp(o, 'style'),
                                        class: [
                                          e.cx('separator'),
                                          r.getItemProp(o, 'class')
                                        ],
                                        role: 'separator',
                                        ref_for: !0
                                      },
                                      e.ptm('separator')
                                    ),
                                    null,
                                    16,
                                    _hoisted_6$4
                                  ))
                                : Vue.createCommentVNode('', !0)
                            ],
                            64
                          )
                        )
                      }),
                      128
                    ))
                  ],
                  16,
                  _hoisted_1$t
                ))
              : Vue.createCommentVNode('', !0)
          ]
        }),
        _: 1
      },
      16,
      ['onEnter']
    )
  )
}
__name(render$1$2, 'render$1$2'), (script$1$b.render = render$1$2)
var script$h = {
  name: 'ContextMenu',
  extends: script$2$2,
  inheritAttrs: !1,
  emits: ['focus', 'blur', 'show', 'hide', 'before-show', 'before-hide'],
  target: null,
  outsideClickListener: null,
  resizeListener: null,
  documentContextMenuListener: null,
  matchMediaListener: null,
  pageX: null,
  pageY: null,
  container: null,
  list: null,
  data: __name(function () {
    return {
      id: this.$attrs.id,
      focused: !1,
      focusedItemInfo: { index: -1, level: 0, parentKey: '' },
      activeItemPath: [],
      visible: !1,
      submenuVisible: !1,
      query: null,
      queryMatches: !1
    }
  }, 'data'),
  watch: {
    '$attrs.id': __name(function (e) {
      this.id = e || UniqueComponentId()
    }, '$attrsId'),
    activeItemPath: __name(function (e) {
      isNotEmpty(e)
        ? (this.bindOutsideClickListener(), this.bindResizeListener())
        : this.visible ||
          (this.unbindOutsideClickListener(), this.unbindResizeListener())
    }, 'activeItemPath')
  },
  mounted: __name(function () {
    ;(this.id = this.id || UniqueComponentId()),
      this.bindMatchMediaListener(),
      this.global && this.bindDocumentContextMenuListener()
  }, 'mounted'),
  beforeUnmount: __name(function () {
    this.unbindResizeListener(),
      this.unbindOutsideClickListener(),
      this.unbindDocumentContextMenuListener(),
      this.unbindMatchMediaListener(),
      this.container && this.autoZIndex && ZIndex.clear(this.container),
      (this.target = null),
      (this.container = null)
  }, 'beforeUnmount'),
  methods: {
    getItemProp: __name(function (e, t) {
      return e ? resolve(e[t]) : void 0
    }, 'getItemProp'),
    getItemLabel: __name(function (e) {
      return this.getItemProp(e, 'label')
    }, 'getItemLabel'),
    isItemDisabled: __name(function (e) {
      return this.getItemProp(e, 'disabled')
    }, 'isItemDisabled'),
    isItemVisible: __name(function (e) {
      return !1 !== this.getItemProp(e, 'visible')
    }, 'isItemVisible'),
    isItemGroup: __name(function (e) {
      return isNotEmpty(this.getItemProp(e, 'items'))
    }, 'isItemGroup'),
    isItemSeparator: __name(function (e) {
      return this.getItemProp(e, 'separator')
    }, 'isItemSeparator'),
    getProccessedItemLabel: __name(function (e) {
      return e ? this.getItemLabel(e.item) : void 0
    }, 'getProccessedItemLabel'),
    isProccessedItemGroup: __name(function (e) {
      return e && isNotEmpty(e.items)
    }, 'isProccessedItemGroup'),
    toggle: __name(function (e) {
      this.visible ? this.hide() : this.show(e)
    }, 'toggle'),
    show: __name(function (e) {
      this.$emit('before-show'),
        (this.activeItemPath = []),
        (this.focusedItemInfo = { index: -1, level: 0, parentKey: '' }),
        focus(this.list),
        (this.pageX = e.pageX),
        (this.pageY = e.pageY),
        this.visible ? this.position() : (this.visible = !0),
        e.stopPropagation(),
        e.preventDefault()
    }, 'show'),
    hide: __name(function () {
      this.$emit('before-hide'),
        (this.visible = !1),
        (this.activeItemPath = []),
        (this.focusedItemInfo = { index: -1, level: 0, parentKey: '' })
    }, 'hide'),
    onFocus: __name(function (e) {
      ;(this.focused = !0),
        (this.focusedItemInfo =
          -1 !== this.focusedItemInfo.index
            ? this.focusedItemInfo
            : { index: -1, level: 0, parentKey: '' }),
        this.$emit('focus', e)
    }, 'onFocus'),
    onBlur: __name(function (e) {
      ;(this.focused = !1),
        (this.focusedItemInfo = { index: -1, level: 0, parentKey: '' }),
        (this.searchValue = ''),
        this.$emit('blur', e)
    }, 'onBlur'),
    onKeyDown: __name(function (e) {
      var t = e.metaKey || e.ctrlKey
      switch (e.code) {
        case 'ArrowDown':
          this.onArrowDownKey(e)
          break
        case 'ArrowUp':
          this.onArrowUpKey(e)
          break
        case 'ArrowLeft':
          this.onArrowLeftKey(e)
          break
        case 'ArrowRight':
          this.onArrowRightKey(e)
          break
        case 'Home':
          this.onHomeKey(e)
          break
        case 'End':
          this.onEndKey(e)
          break
        case 'Space':
          this.onSpaceKey(e)
          break
        case 'Enter':
        case 'NumpadEnter':
          this.onEnterKey(e)
          break
        case 'Escape':
          this.onEscapeKey(e)
          break
        case 'Tab':
          this.onTabKey(e)
          break
        case 'PageDown':
        case 'PageUp':
        case 'Backspace':
        case 'ShiftLeft':
        case 'ShiftRight':
          break
        default:
          !t && isPrintableCharacter(e.key) && this.searchItems(e, e.key)
      }
    }, 'onKeyDown'),
    onItemChange: __name(function (e, t) {
      var n = e.processedItem,
        o = e.isFocus
      if (!isEmpty(n)) {
        var i = n.index,
          r = n.key,
          a = n.level,
          s = n.parentKey,
          l = isNotEmpty(n.items),
          c = this.activeItemPath.filter(function (e) {
            return e.parentKey !== s && e.parentKey !== r
          })
        l && (c.push(n), (this.submenuVisible = !0)),
          (this.focusedItemInfo = { index: i, level: a, parentKey: s }),
          o && focus(this.list),
          ('hover' === t && this.queryMatches) || (this.activeItemPath = c)
      }
    }, 'onItemChange'),
    onItemClick: __name(function (e) {
      var t = e.processedItem,
        n = this.isProccessedItemGroup(t)
      if (this.isSelected(t)) {
        var o = t.index,
          i = t.key,
          r = t.level,
          a = t.parentKey
        ;(this.activeItemPath = this.activeItemPath.filter(function (e) {
          return i !== e.key && i.startsWith(e.key)
        })),
          (this.focusedItemInfo = { index: o, level: r, parentKey: a }),
          focus(this.list)
      } else n ? this.onItemChange(e) : this.hide()
    }, 'onItemClick'),
    onItemMouseEnter: __name(function (e) {
      this.onItemChange(e, 'hover')
    }, 'onItemMouseEnter'),
    onItemMouseMove: __name(function (e) {
      this.focused && this.changeFocusedItemIndex(e, e.processedItem.index)
    }, 'onItemMouseMove'),
    onArrowDownKey: __name(function (e) {
      var t =
        -1 !== this.focusedItemInfo.index
          ? this.findNextItemIndex(this.focusedItemInfo.index)
          : this.findFirstFocusedItemIndex()
      this.changeFocusedItemIndex(e, t), e.preventDefault()
    }, 'onArrowDownKey'),
    onArrowUpKey: __name(function (e) {
      if (e.altKey) {
        if (-1 !== this.focusedItemInfo.index) {
          var t = this.visibleItems[this.focusedItemInfo.index]
          !this.isProccessedItemGroup(t) &&
            this.onItemChange({ originalEvent: e, processedItem: t })
        }
        this.popup && this.hide(), e.preventDefault()
      } else {
        var n =
          -1 !== this.focusedItemInfo.index
            ? this.findPrevItemIndex(this.focusedItemInfo.index)
            : this.findLastFocusedItemIndex()
        this.changeFocusedItemIndex(e, n), e.preventDefault()
      }
    }, 'onArrowUpKey'),
    onArrowLeftKey: __name(function (e) {
      var t = this,
        n = this.visibleItems[this.focusedItemInfo.index],
        o = this.activeItemPath.find(function (e) {
          return e.key === n.parentKey
        })
      isEmpty(n.parent) ||
        ((this.focusedItemInfo = {
          index: -1,
          parentKey: o ? o.parentKey : ''
        }),
        (this.searchValue = ''),
        this.onArrowDownKey(e)),
        (this.activeItemPath = this.activeItemPath.filter(function (e) {
          return e.parentKey !== t.focusedItemInfo.parentKey
        })),
        e.preventDefault()
    }, 'onArrowLeftKey'),
    onArrowRightKey: __name(function (e) {
      var t = this.visibleItems[this.focusedItemInfo.index]
      this.isProccessedItemGroup(t) &&
        (this.onItemChange({ originalEvent: e, processedItem: t }),
        (this.focusedItemInfo = { index: -1, parentKey: t.key }),
        (this.searchValue = ''),
        this.onArrowDownKey(e)),
        e.preventDefault()
    }, 'onArrowRightKey'),
    onHomeKey: __name(function (e) {
      this.changeFocusedItemIndex(e, this.findFirstItemIndex()),
        e.preventDefault()
    }, 'onHomeKey'),
    onEndKey: __name(function (e) {
      this.changeFocusedItemIndex(e, this.findLastItemIndex()),
        e.preventDefault()
    }, 'onEndKey'),
    onEnterKey: __name(function (e) {
      if (-1 !== this.focusedItemInfo.index) {
        var t = findSingle(
            this.list,
            'li[id="'.concat(''.concat(this.focusedItemIdx), '"]')
          ),
          n = t && findSingle(t, '[data-pc-section="itemlink"]')
        n ? n.click() : t && t.click()
        var o = this.visibleItems[this.focusedItemInfo.index]
        !this.isProccessedItemGroup(o) &&
          (this.focusedItemInfo.index = this.findFirstFocusedItemIndex())
      }
      e.preventDefault()
    }, 'onEnterKey'),
    onSpaceKey: __name(function (e) {
      this.onEnterKey(e)
    }, 'onSpaceKey'),
    onEscapeKey: __name(function (e) {
      this.hide(),
        !this.popup &&
          (this.focusedItemInfo.index = this.findFirstFocusedItemIndex()),
        e.preventDefault()
    }, 'onEscapeKey'),
    onTabKey: __name(function (e) {
      if (-1 !== this.focusedItemInfo.index) {
        var t = this.visibleItems[this.focusedItemInfo.index]
        !this.isProccessedItemGroup(t) &&
          this.onItemChange({ originalEvent: e, processedItem: t })
      }
      this.hide()
    }, 'onTabKey'),
    onEnter: __name(function (e) {
      addStyle(e, { position: 'absolute' }),
        this.position(),
        this.autoZIndex &&
          ZIndex.set(
            'menu',
            e,
            this.baseZIndex + this.$primevue.config.zIndex.menu
          )
    }, 'onEnter'),
    onAfterEnter: __name(function () {
      this.bindOutsideClickListener(),
        this.bindResizeListener(),
        this.$emit('show'),
        focus(this.list)
    }, 'onAfterEnter'),
    onLeave: __name(function () {
      this.$emit('hide'), (this.container = null)
    }, 'onLeave'),
    onAfterLeave: __name(function (e) {
      this.autoZIndex && ZIndex.clear(e),
        this.unbindOutsideClickListener(),
        this.unbindResizeListener()
    }, 'onAfterLeave'),
    position: __name(function () {
      var e = this.pageX + 1,
        t = this.pageY + 1,
        n = this.container.offsetParent
          ? this.container.offsetWidth
          : getHiddenElementOuterWidth(this.container),
        o = this.container.offsetParent
          ? this.container.offsetHeight
          : getHiddenElementOuterHeight(this.container),
        i = getViewport(),
        r =
          window.scrollY ||
          document.documentElement.scrollTop ||
          document.body.scrollTop ||
          0,
        a =
          window.scrollX ||
          document.documentElement.scrollLeft ||
          document.body.scrollLeft ||
          0
      e + n - a > i.width && (e -= n),
        t + o - r > i.height && (t -= o),
        e < a && (e = a),
        t < r && (t = r),
        (this.container.style.left = e + 'px'),
        (this.container.style.top = t + 'px')
    }, 'position'),
    bindOutsideClickListener: __name(function () {
      var e = this
      this.outsideClickListener ||
        ((this.outsideClickListener = function (t) {
          var n = e.container && !e.container.contains(t.target),
            o =
              !e.visible ||
              !(
                e.target &&
                (e.target === t.target || e.target.contains(t.target))
              )
          n && o && e.hide()
        }),
        document.addEventListener('click', this.outsideClickListener))
    }, 'bindOutsideClickListener'),
    unbindOutsideClickListener: __name(function () {
      this.outsideClickListener &&
        (document.removeEventListener('click', this.outsideClickListener),
        (this.outsideClickListener = null))
    }, 'unbindOutsideClickListener'),
    bindResizeListener: __name(function () {
      var e = this
      this.resizeListener ||
        ((this.resizeListener = function () {
          e.visible && !isTouchDevice() && e.hide()
        }),
        window.addEventListener('resize', this.resizeListener))
    }, 'bindResizeListener'),
    unbindResizeListener: __name(function () {
      this.resizeListener &&
        (window.removeEventListener('resize', this.resizeListener),
        (this.resizeListener = null))
    }, 'unbindResizeListener'),
    bindDocumentContextMenuListener: __name(function () {
      var e = this
      this.documentContextMenuListener ||
        ((this.documentContextMenuListener = function (t) {
          2 === t.button && e.show(t)
        }),
        document.addEventListener(
          'contextmenu',
          this.documentContextMenuListener
        ))
    }, 'bindDocumentContextMenuListener'),
    unbindDocumentContextMenuListener: __name(function () {
      this.documentContextMenuListener &&
        (document.removeEventListener(
          'contextmenu',
          this.documentContextMenuListener
        ),
        (this.documentContextMenuListener = null))
    }, 'unbindDocumentContextMenuListener'),
    bindMatchMediaListener: __name(function () {
      var e = this
      if (!this.matchMediaListener) {
        var t = matchMedia('(max-width: '.concat(this.breakpoint, ')'))
        ;(this.query = t),
          (this.queryMatches = t.matches),
          (this.matchMediaListener = function () {
            e.queryMatches = t.matches
          }),
          this.query.addEventListener('change', this.matchMediaListener)
      }
    }, 'bindMatchMediaListener'),
    unbindMatchMediaListener: __name(function () {
      this.matchMediaListener &&
        (this.query.removeEventListener('change', this.matchMediaListener),
        (this.matchMediaListener = null))
    }, 'unbindMatchMediaListener'),
    isItemMatched: __name(function (e) {
      var t
      return (
        this.isValidItem(e) &&
        (null === (t = this.getProccessedItemLabel(e)) || void 0 === t
          ? void 0
          : t
              .toLocaleLowerCase()
              .startsWith(this.searchValue.toLocaleLowerCase()))
      )
    }, 'isItemMatched'),
    isValidItem: __name(function (e) {
      return (
        !!e &&
        !this.isItemDisabled(e.item) &&
        !this.isItemSeparator(e.item) &&
        this.isItemVisible(e.item)
      )
    }, 'isValidItem'),
    isValidSelectedItem: __name(function (e) {
      return this.isValidItem(e) && this.isSelected(e)
    }, 'isValidSelectedItem'),
    isSelected: __name(function (e) {
      return this.activeItemPath.some(function (t) {
        return t.key === e.key
      })
    }, 'isSelected'),
    findFirstItemIndex: __name(function () {
      var e = this
      return this.visibleItems.findIndex(function (t) {
        return e.isValidItem(t)
      })
    }, 'findFirstItemIndex'),
    findLastItemIndex: __name(function () {
      var e = this
      return findLastIndex(this.visibleItems, function (t) {
        return e.isValidItem(t)
      })
    }, 'findLastItemIndex'),
    findNextItemIndex: __name(function (e) {
      var t = this,
        n =
          e < this.visibleItems.length - 1
            ? this.visibleItems.slice(e + 1).findIndex(function (e) {
                return t.isValidItem(e)
              })
            : -1
      return n > -1 ? n + e + 1 : e
    }, 'findNextItemIndex'),
    findPrevItemIndex: __name(function (e) {
      var t = this,
        n =
          e > 0
            ? findLastIndex(this.visibleItems.slice(0, e), function (e) {
                return t.isValidItem(e)
              })
            : -1
      return n > -1 ? n : e
    }, 'findPrevItemIndex'),
    findSelectedItemIndex: __name(function () {
      var e = this
      return this.visibleItems.findIndex(function (t) {
        return e.isValidSelectedItem(t)
      })
    }, 'findSelectedItemIndex'),
    findFirstFocusedItemIndex: __name(function () {
      var e = this.findSelectedItemIndex()
      return e < 0 ? this.findFirstItemIndex() : e
    }, 'findFirstFocusedItemIndex'),
    findLastFocusedItemIndex: __name(function () {
      var e = this.findSelectedItemIndex()
      return e < 0 ? this.findLastItemIndex() : e
    }, 'findLastFocusedItemIndex'),
    searchItems: __name(function (e, t) {
      var n = this
      this.searchValue = (this.searchValue || '') + t
      var o = -1,
        i = !1
      return (
        -1 !==
          (o =
            -1 !== this.focusedItemInfo.index
              ? -1 ===
                (o = this.visibleItems
                  .slice(this.focusedItemInfo.index)
                  .findIndex(function (e) {
                    return n.isItemMatched(e)
                  }))
                ? this.visibleItems
                    .slice(0, this.focusedItemInfo.index)
                    .findIndex(function (e) {
                      return n.isItemMatched(e)
                    })
                : o + this.focusedItemInfo.index
              : this.visibleItems.findIndex(function (e) {
                  return n.isItemMatched(e)
                })) && (i = !0),
        -1 === o &&
          -1 === this.focusedItemInfo.index &&
          (o = this.findFirstFocusedItemIndex()),
        -1 !== o && this.changeFocusedItemIndex(e, o),
        this.searchTimeout && clearTimeout(this.searchTimeout),
        (this.searchTimeout = setTimeout(function () {
          ;(n.searchValue = ''), (n.searchTimeout = null)
        }, 500)),
        i
      )
    }, 'searchItems'),
    changeFocusedItemIndex: __name(function (e, t) {
      this.focusedItemInfo.index !== t &&
        ((this.focusedItemInfo.index = t), this.scrollInView())
    }, 'changeFocusedItemIndex'),
    scrollInView: __name(function () {
      var e =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1,
        t = -1 !== e ? ''.concat(this.id, '_').concat(e) : this.focusedItemIdx,
        n = findSingle(this.list, 'li[id="'.concat(t, '"]'))
      n &&
        n.scrollIntoView &&
        n.scrollIntoView({ block: 'nearest', inline: 'start' })
    }, 'scrollInView'),
    createProcessedItems: __name(function (e) {
      var t = this,
        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
        o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
        i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : '',
        r = []
      return (
        e &&
          e.forEach(function (e, a) {
            var s = ('' !== i ? i + '_' : '') + a,
              l = {
                item: e,
                index: a,
                level: n,
                key: s,
                parent: o,
                parentKey: i
              }
            ;(l.items = t.createProcessedItems(e.items, n + 1, l, s)), r.push(l)
          }),
        r
      )
    }, 'createProcessedItems'),
    containerRef: __name(function (e) {
      this.container = e
    }, 'containerRef'),
    listRef: __name(function (e) {
      this.list = e ? e.$el : void 0
    }, 'listRef')
  },
  computed: {
    processedItems: __name(function () {
      return this.createProcessedItems(this.model || [])
    }, 'processedItems'),
    visibleItems: __name(function () {
      var e = this,
        t = this.activeItemPath.find(function (t) {
          return t.key === e.focusedItemInfo.parentKey
        })
      return t ? t.items : this.processedItems
    }, 'visibleItems'),
    focusedItemIdx: __name(function () {
      return -1 !== this.focusedItemInfo.index
        ? ''
            .concat(this.id)
            .concat(
              isNotEmpty(this.focusedItemInfo.parentKey)
                ? '_' + this.focusedItemInfo.parentKey
                : '',
              '_'
            )
            .concat(this.focusedItemInfo.index)
        : null
    }, 'focusedItemIdx')
  },
  components: { ContextMenuSub: script$1$b, Portal: script$w }
}
function render$g(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('ContextMenuSub'),
    s = Vue.resolveComponent('Portal')
  return (
    Vue.openBlock(),
    Vue.createBlock(
      s,
      { appendTo: e.appendTo },
      {
        default: Vue.withCtx(function () {
          return [
            Vue.createVNode(
              Vue.Transition,
              Vue.mergeProps(
                {
                  name: 'p-contextmenu',
                  onEnter: r.onEnter,
                  onAfterEnter: r.onAfterEnter,
                  onLeave: r.onLeave,
                  onAfterLeave: r.onAfterLeave
                },
                e.ptm('transition')
              ),
              {
                default: Vue.withCtx(function () {
                  return [
                    i.visible
                      ? (Vue.openBlock(),
                        Vue.createElementBlock(
                          'div',
                          Vue.mergeProps(
                            {
                              key: 0,
                              ref: r.containerRef,
                              class: e.cx('root')
                            },
                            e.ptmi('root')
                          ),
                          [
                            Vue.createVNode(
                              a,
                              {
                                ref: r.listRef,
                                id: i.id + '_list',
                                class: Vue.normalizeClass(e.cx('rootList')),
                                role: 'menubar',
                                root: !0,
                                tabindex: e.tabindex,
                                'aria-orientation': 'vertical',
                                'aria-activedescendant': i.focused
                                  ? r.focusedItemIdx
                                  : void 0,
                                menuId: i.id,
                                focusedItemId: i.focused
                                  ? r.focusedItemIdx
                                  : void 0,
                                items: r.processedItems,
                                templates: e.$slots,
                                activeItemPath: i.activeItemPath,
                                'aria-labelledby': e.ariaLabelledby,
                                'aria-label': e.ariaLabel,
                                level: 0,
                                visible: i.submenuVisible,
                                pt: e.pt,
                                unstyled: e.unstyled,
                                onFocus: r.onFocus,
                                onBlur: r.onBlur,
                                onKeydown: r.onKeyDown,
                                onItemClick: r.onItemClick,
                                onItemMouseenter: r.onItemMouseEnter,
                                onItemMousemove: r.onItemMouseMove
                              },
                              null,
                              8,
                              [
                                'id',
                                'class',
                                'tabindex',
                                'aria-activedescendant',
                                'menuId',
                                'focusedItemId',
                                'items',
                                'templates',
                                'activeItemPath',
                                'aria-labelledby',
                                'aria-label',
                                'visible',
                                'pt',
                                'unstyled',
                                'onFocus',
                                'onBlur',
                                'onKeydown',
                                'onItemClick',
                                'onItemMouseenter',
                                'onItemMousemove'
                              ]
                            )
                          ],
                          16
                        ))
                      : Vue.createCommentVNode('', !0)
                  ]
                }),
                _: 1
              },
              16,
              ['onEnter', 'onAfterEnter', 'onLeave', 'onAfterLeave']
            )
          ]
        }),
        _: 1
      },
      8,
      ['appendTo']
    )
  )
}
__name(render$g, 'render$g'), (script$h.render = render$g)
const _hoisted_1$s = { class: 'editable-text' },
  _hoisted_2$h = { key: 0 },
  _sfc_main$r = Vue.defineComponent({
    __name: 'EditableText',
    props: { modelValue: {}, isEditing: { type: Boolean, default: !1 } },
    emits: ['update:modelValue', 'edit'],
    setup(e, { emit: t }) {
      const n = e,
        o = t,
        i = Vue.ref(n.modelValue),
        r = Vue.ref(null),
        a = __name(() => {
          r.value?.$el.blur()
        }, 'blurInputElement'),
        s = __name(() => {
          o('edit', i.value)
        }, 'finishEditing')
      Vue.watch(
        () => n.isEditing,
        (e) => {
          e &&
            ((i.value = n.modelValue),
            Vue.nextTick(() => {
              if (!r.value) return
              const e = (
                  i.value.includes('.')
                    ? i.value.split('.').slice(0, -1).join('.')
                    : i.value
                ).length,
                t = r.value.$el
              t.setSelectionRange?.(0, e)
            }))
        },
        { immediate: !0 }
      )
      const l = { mounted: __name((e) => e.focus(), 'mounted') }
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock('div', _hoisted_1$s, [
          n.isEditing
            ? Vue.withDirectives(
                (Vue.openBlock(),
                Vue.createBlock(
                  Vue.unref(script$P),
                  {
                    key: 1,
                    type: 'text',
                    size: 'small',
                    fluid: '',
                    modelValue: i.value,
                    'onUpdate:modelValue':
                      t[0] || (t[0] = (e) => (i.value = e)),
                    ref_key: 'inputRef',
                    ref: r,
                    onKeyup: Vue.withKeys(a, ['enter']),
                    onClick:
                      t[1] || (t[1] = Vue.withModifiers(() => {}, ['stop'])),
                    pt: { root: { onBlur: s } }
                  },
                  null,
                  8,
                  ['modelValue', 'pt']
                )),
                [[l]]
              )
            : (Vue.openBlock(),
              Vue.createElementBlock(
                'span',
                _hoisted_2$h,
                Vue.toDisplayString(e.modelValue),
                1
              ))
        ])
      )
    }
  }),
  EditableText = _export_sfc(_sfc_main$r, [['__scopeId', 'data-v-d670c40f']])
function _arrayWithHoles$1(e) {
  if (Array.isArray(e)) return e
}
function _iterableToArrayLimit$1(e, t) {
  var n =
    null == e
      ? null
      : ('undefined' != typeof Symbol && e[Symbol.iterator]) || e['@@iterator']
  if (null != n) {
    var o,
      i,
      r,
      a,
      s = [],
      l = !0,
      c = !1
    try {
      if (((r = (n = n.call(e)).next), 0 === t)) {
        if (Object(n) !== n) return
        l = !1
      } else
        for (
          ;
          !(l = (o = r.call(n)).done) && (s.push(o.value), s.length !== t);
          l = !0
        );
    } catch (d) {
      ;(c = !0), (i = d)
    } finally {
      try {
        if (!l && null != n.return && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (c) throw i
      }
    }
    return s
  }
}
function _arrayLikeToArray$6(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
function _unsupportedIterableToArray$6(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$6(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$6(e, t)
          : void 0
    )
  }
}
function _nonIterableRest$1() {
  throw new TypeError(
    'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _slicedToArray$1(e, t) {
  return (
    _arrayWithHoles$1(e) ||
    _iterableToArrayLimit$1(e, t) ||
    _unsupportedIterableToArray$6(e, t) ||
    _nonIterableRest$1()
  )
}
__name(_arrayWithHoles$1, '_arrayWithHoles$1'),
  __name(_iterableToArrayLimit$1, '_iterableToArrayLimit$1'),
  __name(_arrayLikeToArray$6, '_arrayLikeToArray$6'),
  __name(_unsupportedIterableToArray$6, '_unsupportedIterableToArray$6'),
  __name(_nonIterableRest$1, '_nonIterableRest$1'),
  __name(_slicedToArray$1, '_slicedToArray$1')
var dist = {},
  bind$1 = {}
Object.defineProperty(bind$1, '__esModule', { value: !0 })
var bind_2 = (bind$1.bind = void 0)
function bind(e, t) {
  var n = t.type,
    o = t.listener,
    i = t.options
  return (
    e.addEventListener(n, o, i),
    __name(function () {
      e.removeEventListener(n, o, i)
    }, 'unbind')
  )
}
__name(bind, 'bind'), (bind_2 = bind$1.bind = bind)
var bindAll$1 = {},
  __assign =
    (commonjsGlobal && commonjsGlobal.__assign) ||
    function () {
      return (
        (__assign =
          Object.assign ||
          function (e) {
            for (var t, n = 1, o = arguments.length; n < o; n++)
              for (var i in (t = arguments[n]))
                Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])
            return e
          }),
        __assign.apply(this, arguments)
      )
    }
Object.defineProperty(bindAll$1, '__esModule', { value: !0 })
var bindAll_2 = (bindAll$1.bindAll = void 0),
  bind_1 = bind$1
function toOptions(e) {
  if (void 0 !== e) return 'boolean' == typeof e ? { capture: e } : e
}
function getBinding(e, t) {
  return null == t
    ? e
    : __assign(__assign({}, e), {
        options: __assign(__assign({}, toOptions(t)), toOptions(e.options))
      })
}
function bindAll(e, t, n) {
  var o = t.map(function (t) {
    var o = getBinding(t, n)
    return (0, bind_1.bind)(e, o)
  })
  return __name(function () {
    o.forEach(function (e) {
      return e()
    })
  }, 'unbindAll')
}
__name(toOptions, 'toOptions'),
  __name(getBinding, 'getBinding'),
  __name(bindAll, 'bindAll'),
  (bindAll_2 = bindAll$1.bindAll = bindAll),
  (function (e) {
    Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.bindAll = e.bind = void 0)
    var t = bind$1
    Object.defineProperty(e, 'bind', {
      enumerable: !0,
      get: __name(function () {
        return t.bind
      }, 'get')
    })
    var n = bindAll$1
    Object.defineProperty(e, 'bindAll', {
      enumerable: !0,
      get: __name(function () {
        return n.bindAll
      }, 'get')
    })
  })(dist)
const index$1q = getDefaultExportFromCjs(dist)
var honeyPotDataAttribute = 'data-pdnd-honey-pot'
function isHoneyPotElement(e) {
  return e instanceof Element && e.hasAttribute(honeyPotDataAttribute)
}
function getElementFromPointWithoutHoneypot(e) {
  var t = _slicedToArray$1(document.elementsFromPoint(e.x, e.y), 2),
    n = t[0],
    o = t[1]
  return n ? (isHoneyPotElement(n) ? (null != o ? o : null) : n) : null
}
function _typeof$7(e) {
  return (_typeof$7 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function toPrimitive(e, t) {
  if ('object' != _typeof$7(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$7(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
function toPropertyKey(e) {
  var t = toPrimitive(e, 'string')
  return 'symbol' == _typeof$7(t) ? t : t + ''
}
function _defineProperty$7(e, t, n) {
  return (
    (t = toPropertyKey(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
__name(isHoneyPotElement, 'isHoneyPotElement'),
  __name(
    getElementFromPointWithoutHoneypot,
    'getElementFromPointWithoutHoneypot'
  ),
  __name(_typeof$7, '_typeof$7'),
  __name(toPrimitive, 'toPrimitive'),
  __name(toPropertyKey, 'toPropertyKey'),
  __name(_defineProperty$7, '_defineProperty$7')
var maxZIndex = 2147483647
function ownKeys$9(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$9(Object(n), !0).forEach(function (t) {
          _defineProperty$7(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$9(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
__name(ownKeys$9, 'ownKeys$9'), __name(_objectSpread$9, '_objectSpread$9')
var honeyPotSize = 2,
  halfHoneyPotSize = honeyPotSize / 2
function floorToClosestPixel(e) {
  return { x: Math.floor(e.x), y: Math.floor(e.y) }
}
function pullBackByHalfHoneyPotSize(e) {
  return { x: e.x - halfHoneyPotSize, y: e.y - halfHoneyPotSize }
}
function preventGoingBackwardsOffScreen(e) {
  return { x: Math.max(e.x, 0), y: Math.max(e.y, 0) }
}
function preventGoingForwardsOffScreen(e) {
  return {
    x: Math.min(e.x, window.innerWidth - honeyPotSize),
    y: Math.min(e.y, window.innerHeight - honeyPotSize)
  }
}
function getHoneyPotRectFor(e) {
  var t = preventGoingForwardsOffScreen(
    preventGoingBackwardsOffScreen(
      pullBackByHalfHoneyPotSize(floorToClosestPixel(e.client))
    )
  )
  return DOMRect.fromRect({
    x: t.x,
    y: t.y,
    width: honeyPotSize,
    height: honeyPotSize
  })
}
function getRectStyles(e) {
  var t = e.clientRect
  return {
    left: ''.concat(t.left, 'px'),
    top: ''.concat(t.top, 'px'),
    width: ''.concat(t.width, 'px'),
    height: ''.concat(t.height, 'px')
  }
}
function isWithin(e) {
  var t = e.client,
    n = e.clientRect
  return (
    t.x >= n.x && t.x <= n.x + n.width && t.y >= n.y && t.y <= n.y + n.height
  )
}
function mountHoneyPot(e) {
  var t = e.initial,
    n = document.createElement('div')
  n.setAttribute(honeyPotDataAttribute, 'true')
  var o = getHoneyPotRectFor({ client: t })
  Object.assign(
    n.style,
    _objectSpread$9(
      _objectSpread$9(
        {
          backgroundColor: 'transparent',
          position: 'fixed',
          padding: 0,
          margin: 0,
          boxSizing: 'border-box'
        },
        getRectStyles({ clientRect: o })
      ),
      {},
      { pointerEvents: 'auto', zIndex: maxZIndex }
    )
  ),
    document.body.appendChild(n)
  var i = dist.bind(window, {
    type: 'pointermove',
    listener: __name(function (e) {
      var t = { x: e.clientX, y: e.clientY }
      ;(o = getHoneyPotRectFor({ client: t })),
        Object.assign(n.style, getRectStyles({ clientRect: o }))
    }, 'listener'),
    options: { capture: !0 }
  })
  return __name(function (e) {
    var t = e.current
    if ((i(), isWithin({ client: t, clientRect: o }))) n.remove()
    else {
      __name(a, 'cleanup')
      var r = dist.bindAll(
        window,
        [
          { type: 'pointerdown', listener: a },
          { type: 'pointermove', listener: a },
          { type: 'focusin', listener: a },
          { type: 'focusout', listener: a },
          { type: 'dragstart', listener: a },
          { type: 'dragenter', listener: a },
          { type: 'dragover', listener: a }
        ],
        { capture: !0 }
      )
    }
    function a() {
      r(), n.remove()
    }
  }, 'finish')
}
function makeHoneyPotFix() {
  var e = null
  function t() {
    return (
      (e = null),
      dist.bind(window, {
        type: 'pointermove',
        listener: __name(function (t) {
          e = { x: t.clientX, y: t.clientY }
        }, 'listener'),
        options: { capture: !0 }
      })
    )
  }
  function n() {
    var t = null
    return __name(function (n) {
      var o = n.eventName,
        i = n.payload
      if ('onDragStart' === o) {
        var r,
          a = i.location.initial.input,
          s =
            null !== (r = e) && void 0 !== r
              ? r
              : { x: a.clientX, y: a.clientY }
        t = mountHoneyPot({ initial: s })
      }
      if ('onDrop' === o) {
        var l,
          c = i.location.current.input
        null === (l = t) ||
          void 0 === l ||
          l({ current: { x: c.clientX, y: c.clientY } }),
          (t = null),
          (e = null)
      }
    }, 'onPostEvent')
  }
  return (
    __name(t, 'bindEvents'),
    __name(n, 'getOnPostDispatch'),
    { bindEvents: t, getOnPostDispatch: n }
  )
}
function _arrayWithoutHoles$3(e) {
  if (Array.isArray(e)) return _arrayLikeToArray$6(e)
}
function _iterableToArray$3(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _nonIterableSpread$3() {
  throw new TypeError(
    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _toConsumableArray$3(e) {
  return (
    _arrayWithoutHoles$3(e) ||
    _iterableToArray$3(e) ||
    _unsupportedIterableToArray$6(e) ||
    _nonIterableSpread$3()
  )
}
function once(e) {
  var t = null
  return __name(function () {
    if (!t) {
      for (var n = arguments.length, o = new Array(n), i = 0; i < n; i++)
        o[i] = arguments[i]
      var r = e.apply(this, o)
      t = { result: r }
    }
    return t.result
  }, 'wrapped')
}
__name(floorToClosestPixel, 'floorToClosestPixel'),
  __name(pullBackByHalfHoneyPotSize, 'pullBackByHalfHoneyPotSize'),
  __name(preventGoingBackwardsOffScreen, 'preventGoingBackwardsOffScreen'),
  __name(preventGoingForwardsOffScreen, 'preventGoingForwardsOffScreen'),
  __name(getHoneyPotRectFor, 'getHoneyPotRectFor'),
  __name(getRectStyles, 'getRectStyles'),
  __name(isWithin, 'isWithin'),
  __name(mountHoneyPot, 'mountHoneyPot'),
  __name(makeHoneyPotFix, 'makeHoneyPotFix'),
  __name(_arrayWithoutHoles$3, '_arrayWithoutHoles$3'),
  __name(_iterableToArray$3, '_iterableToArray$3'),
  __name(_nonIterableSpread$3, '_nonIterableSpread$3'),
  __name(_toConsumableArray$3, '_toConsumableArray$3'),
  __name(once, 'once')
var isFirefox = once(
    __name(function () {
      return navigator.userAgent.includes('Firefox')
    }, 'isFirefox2')
  ),
  isSafari = once(
    __name(function () {
      var e = navigator.userAgent
      return e.includes('AppleWebKit') && !e.includes('Chrome')
    }, 'isSafari2')
  ),
  symbols = {
    isLeavingWindow: Symbol('leaving'),
    isEnteringWindow: Symbol('entering')
  }
function isEnteringWindowInSafari(e) {
  var t = e.dragEnter
  return !!isSafari() && t.hasOwnProperty(symbols.isEnteringWindow)
}
function isLeavingWindowInSafari(e) {
  var t = e.dragLeave
  return !!isSafari() && t.hasOwnProperty(symbols.isLeavingWindow)
}
function isNodeLike(e) {
  return 'nodeName' in e
}
function isFromAnotherWindow(e) {
  return isNodeLike(e) && e.ownerDocument !== document
}
function isLeavingWindow(e) {
  var t = e.dragLeave,
    n = t.type,
    o = t.relatedTarget
  return (
    'dragleave' === n &&
    (isSafari()
      ? isLeavingWindowInSafari({ dragLeave: t })
      : null == o ||
        (isFirefox() ? isFromAnotherWindow(o) : o instanceof HTMLIFrameElement))
  )
}
function getBindingsForBrokenDrags(e) {
  var t = e.onDragEnd
  return [
    {
      type: 'pointermove',
      listener: (function () {
        var e = 0
        return __name(function () {
          e < 20 ? e++ : t()
        }, 'listener')
      })()
    },
    { type: 'pointerdown', listener: t }
  ]
}
function getInput(e) {
  return {
    altKey: e.altKey,
    button: e.button,
    buttons: e.buttons,
    ctrlKey: e.ctrlKey,
    metaKey: e.metaKey,
    shiftKey: e.shiftKey,
    clientX: e.clientX,
    clientY: e.clientY,
    pageX: e.pageX,
    pageY: e.pageY
  }
}
__name(isEnteringWindowInSafari, 'isEnteringWindowInSafari'),
  __name(isLeavingWindowInSafari, 'isLeavingWindowInSafari'),
  __name(function () {
    if ('undefined' != typeof window && isSafari()) {
      __name(t, 'getInitialState')
      var e = { enterCount: 0, isOverWindow: !1 }
      __name(n, 'resetState'),
        dist.bindAll(
          window,
          [
            {
              type: 'dragstart',
              listener: __name(function () {
                ;(e.enterCount = 0), (e.isOverWindow = !0)
              }, 'listener')
            },
            { type: 'drop', listener: n },
            { type: 'dragend', listener: n },
            {
              type: 'dragenter',
              listener: __name(function (t) {
                e.isOverWindow ||
                  0 !== e.enterCount ||
                  (t[symbols.isEnteringWindow] = !0),
                  (e.isOverWindow = !0),
                  e.enterCount++
              }, 'listener')
            },
            {
              type: 'dragleave',
              listener: __name(function (t) {
                e.enterCount--,
                  e.isOverWindow &&
                    0 === e.enterCount &&
                    ((t[symbols.isLeavingWindow] = !0), (e.isOverWindow = !1))
              }, 'listener')
            }
          ],
          { capture: !0 }
        )
    }
    function t() {
      return { enterCount: 0, isOverWindow: !1 }
    }
    function n() {
      e = { enterCount: 0, isOverWindow: !1 }
    }
  }, 'fixSafari')(),
  __name(isNodeLike, 'isNodeLike'),
  __name(isFromAnotherWindow, 'isFromAnotherWindow'),
  __name(isLeavingWindow, 'isLeavingWindow'),
  __name(getBindingsForBrokenDrags, 'getBindingsForBrokenDrags'),
  __name(getInput, 'getInput')
var rafSchd = __name(function (e) {
    var t = [],
      n = null,
      o = __name(function () {
        for (var o = arguments.length, i = new Array(o), r = 0; r < o; r++)
          i[r] = arguments[r]
        ;(t = i),
          n ||
            (n = requestAnimationFrame(function () {
              ;(n = null), e.apply(void 0, t)
            }))
      }, 'wrapperFn')
    return (
      (o.cancel = function () {
        n && (cancelAnimationFrame(n), (n = null))
      }),
      o
    )
  }, 'rafSchd'),
  scheduleOnDrag = rafSchd(function (e) {
    return e()
  }),
  dragStart = (function () {
    var e = null
    function t(t) {
      var n = requestAnimationFrame(function () {
        ;(e = null), t()
      })
      e = { frameId: n, fn: t }
    }
    function n() {
      e && (cancelAnimationFrame(e.frameId), e.fn(), (e = null))
    }
    return __name(t, 'schedule'), __name(n, 'flush'), { schedule: t, flush: n }
  })()
function makeDispatch(e) {
  var t = e.source,
    n = e.initial,
    o = e.dispatchEvent,
    i = { dropTargets: [] }
  function r(e) {
    o(e), (i = { dropTargets: e.payload.location.current.dropTargets })
  }
  return (
    __name(r, 'safeDispatch'),
    {
      start: __name(function (e) {
        var o = e.nativeSetDragImage,
          a = { current: n, previous: i, initial: n }
        r({
          eventName: 'onGenerateDragPreview',
          payload: { source: t, location: a, nativeSetDragImage: o }
        }),
          dragStart.schedule(function () {
            r({ eventName: 'onDragStart', payload: { source: t, location: a } })
          })
      }, 'start'),
      dragUpdate: __name(function (e) {
        var o = e.current
        dragStart.flush(),
          scheduleOnDrag.cancel(),
          r({
            eventName: 'onDropTargetChange',
            payload: {
              source: t,
              location: { initial: n, previous: i, current: o }
            }
          })
      }, 'dragUpdate'),
      drag: __name(function (e) {
        var o = e.current
        scheduleOnDrag(function () {
          dragStart.flush(),
            r({
              eventName: 'onDrag',
              payload: {
                source: t,
                location: { initial: n, previous: i, current: o }
              }
            })
        })
      }, 'drag'),
      drop: __name(function (e) {
        var o = e.current,
          a = e.updatedSourcePayload
        dragStart.flush(),
          scheduleOnDrag.cancel(),
          r({
            eventName: 'onDrop',
            payload: {
              source: null != a ? a : t,
              location: { current: o, previous: i, initial: n }
            }
          })
      }, 'drop')
    }
  )
}
__name(makeDispatch, 'makeDispatch')
var globalState = { isActive: !1 }
function canStart() {
  return !globalState.isActive
}
function getNativeSetDragImage(e) {
  return e.dataTransfer
    ? e.dataTransfer.setDragImage.bind(e.dataTransfer)
    : null
}
function hasHierarchyChanged(e) {
  var t = e.current,
    n = e.next
  if (t.length !== n.length) return !0
  for (var o = 0; o < t.length; o++)
    if (t[o].element !== n[o].element) return !0
  return !1
}
function start(e) {
  var t = e.event,
    n = e.dragType,
    o = e.getDropTargetsOver,
    i = e.dispatchEvent
  if (canStart()) {
    var r = getStartLocation({ event: t, dragType: n, getDropTargetsOver: o })
    globalState.isActive = !0
    var a = { current: r }
    setDropEffectOnEvent({ event: t, current: r.dropTargets })
    var s = makeDispatch({ source: n.payload, dispatchEvent: i, initial: r })
    __name(c, 'updateState'),
      __name(d, 'onUpdateEvent'),
      __name(u, 'cancel'),
      __name(p, 'finish')
    var l = dist.bindAll(
      window,
      [
        {
          type: 'dragover',
          listener: __name(function (e) {
            d(e), s.drag({ current: a.current })
          }, 'listener')
        },
        { type: 'dragenter', listener: d },
        {
          type: 'dragleave',
          listener: __name(function (e) {
            isLeavingWindow({ dragLeave: e }) &&
              (c({ input: a.current.input, dropTargets: [] }),
              'external' === n.startedFrom && u())
          }, 'listener')
        },
        {
          type: 'drop',
          listener: __name(function (e) {
            ;(a.current = {
              dropTargets: a.current.dropTargets,
              input: getInput(e)
            }),
              a.current.dropTargets.length
                ? (e.preventDefault(),
                  setDropEffectOnEvent({
                    event: e,
                    current: a.current.dropTargets
                  }),
                  s.drop({
                    current: a.current,
                    updatedSourcePayload:
                      'external' === n.type ? n.getDropPayload(e) : null
                  }),
                  p())
                : u()
          }, 'listener')
        },
        {
          type: 'dragend',
          listener: __name(function (e) {
            ;(a.current = {
              dropTargets: a.current.dropTargets,
              input: getInput(e)
            }),
              u()
          }, 'listener')
        }
      ].concat(
        _toConsumableArray$3(getBindingsForBrokenDrags({ onDragEnd: u }))
      ),
      { capture: !0 }
    )
    s.start({ nativeSetDragImage: getNativeSetDragImage(t) })
  }
  function c(e) {
    var t = hasHierarchyChanged({
      current: a.current.dropTargets,
      next: e.dropTargets
    })
    ;(a.current = e), t && s.dragUpdate({ current: a.current })
  }
  function d(e) {
    var t = getInput(e),
      i = isHoneyPotElement(e.target)
        ? getElementFromPointWithoutHoneypot({ x: t.clientX, y: t.clientY })
        : e.target,
      r = o({
        target: i,
        input: t,
        source: n.payload,
        current: a.current.dropTargets
      })
    r.length &&
      (e.preventDefault(), setDropEffectOnEvent({ event: e, current: r })),
      c({ dropTargets: r, input: t })
  }
  function u() {
    a.current.dropTargets.length &&
      c({ dropTargets: [], input: a.current.input }),
      s.drop({ current: a.current, updatedSourcePayload: null }),
      p()
  }
  function p() {
    ;(globalState.isActive = !1), l()
  }
}
function setDropEffectOnEvent(e) {
  var t,
    n = e.event,
    o = null === (t = e.current[0]) || void 0 === t ? void 0 : t.dropEffect
  null != o && n.dataTransfer && (n.dataTransfer.dropEffect = o)
}
function getStartLocation(e) {
  var t = e.event,
    n = e.dragType,
    o = e.getDropTargetsOver,
    i = getInput(t)
  return 'external' === n.startedFrom
    ? { input: i, dropTargets: [] }
    : {
        input: i,
        dropTargets: o({
          input: i,
          source: n.payload,
          target: t.target,
          current: []
        })
      }
}
__name(canStart, 'canStart'),
  __name(getNativeSetDragImage, 'getNativeSetDragImage'),
  __name(hasHierarchyChanged, 'hasHierarchyChanged'),
  __name(start, 'start'),
  __name(setDropEffectOnEvent, 'setDropEffectOnEvent'),
  __name(getStartLocation, 'getStartLocation')
var lifecycle = { canStart: canStart, start: start },
  ledger = new Map()
function registerUsage(e) {
  var t = e.typeKey,
    n = e.mount,
    o = ledger.get(t)
  if (o) return o.usageCount++, o
  var i = { typeKey: t, unmount: n(), usageCount: 1 }
  return ledger.set(t, i), i
}
function register(e) {
  var t = registerUsage(e)
  return __name(function () {
    t.usageCount--, t.usageCount > 0 || (t.unmount(), ledger.delete(e.typeKey))
  }, 'unregister')
}
function combine() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n]
  return __name(function () {
    t.forEach(function (e) {
      return e()
    })
  }, 'cleanup')
}
function addAttribute(e, t) {
  var n = t.attribute,
    o = t.value
  return (
    e.setAttribute(n, o),
    function () {
      return e.removeAttribute(n)
    }
  )
}
function ownKeys$8(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$8(Object(n), !0).forEach(function (t) {
          _defineProperty$7(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$8(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _createForOfIteratorHelper$2(e, t) {
  var n =
    ('undefined' != typeof Symbol && e[Symbol.iterator]) || e['@@iterator']
  if (!n) {
    if (
      Array.isArray(e) ||
      (n = _unsupportedIterableToArray$5(e)) ||
      (t && e && 'number' == typeof e.length)
    ) {
      n && (e = n)
      var o = 0,
        i = __name(function () {}, 'F2')
      return {
        s: i,
        n: __name(function () {
          return o >= e.length ? { done: !0 } : { done: !1, value: e[o++] }
        }, 'n'),
        e: __name(function (e) {
          throw e
        }, 'e2'),
        f: i
      }
    }
    throw new TypeError(
      'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
    )
  }
  var r,
    a = !0,
    s = !1
  return {
    s: __name(function () {
      n = n.call(e)
    }, 's'),
    n: __name(function () {
      var e = n.next()
      return (a = e.done), e
    }, 'n'),
    e: __name(function (e) {
      ;(s = !0), (r = e)
    }, 'e2'),
    f: __name(function () {
      try {
        a || null == n.return || n.return()
      } finally {
        if (s) throw r
      }
    }, 'f')
  }
}
function _unsupportedIterableToArray$5(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$5(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$5(e, t)
          : void 0
    )
  }
}
function _arrayLikeToArray$5(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
function copyReverse(e) {
  return e.slice(0).reverse()
}
function makeDropTarget(e) {
  var t = e.typeKey,
    n = e.defaultDropEffect,
    o = new WeakMap(),
    i = 'data-drop-target-for-'.concat(t),
    r = '['.concat(i, ']')
  function a(e) {
    return (
      o.set(e.element, e),
      function () {
        return o.delete(e.element)
      }
    )
  }
  function s(e) {
    return combine(
      addAttribute(e.element, { attribute: i, value: 'true' }),
      a(e)
    )
  }
  function l(e) {
    var t,
      i,
      a,
      s,
      c = e.source,
      d = e.target,
      u = e.input,
      p = e.result,
      h = void 0 === p ? [] : p
    if (null == d) return h
    if (!(d instanceof Element))
      return d instanceof Node
        ? l({ source: c, target: d.parentElement, input: u, result: h })
        : h
    var m = d.closest(r)
    if (null == m) return h
    var f = o.get(m)
    if (null == f) return h
    var _ = { input: u, source: c, element: f.element }
    if (f.canDrop && !f.canDrop(_))
      return l({
        source: c,
        target: f.element.parentElement,
        input: u,
        result: h
      })
    var g =
        null !==
          (t =
            null === (i = f.getData) || void 0 === i ? void 0 : i.call(f, _)) &&
        void 0 !== t
          ? t
          : {},
      v =
        null !==
          (a =
            null === (s = f.getDropEffect) || void 0 === s
              ? void 0
              : s.call(f, _)) && void 0 !== a
          ? a
          : n,
      y = {
        data: g,
        element: f.element,
        dropEffect: v,
        isActiveDueToStickiness: !1
      }
    return l({
      source: c,
      target: f.element.parentElement,
      input: u,
      result: [].concat(_toConsumableArray$3(h), [y])
    })
  }
  function c(e) {
    var t,
      n = e.eventName,
      i = e.payload,
      r = _createForOfIteratorHelper$2(i.location.current.dropTargets)
    try {
      for (r.s(); !(t = r.n()).done; ) {
        var a,
          s = t.value,
          l = o.get(s.element),
          c = _objectSpread$8(_objectSpread$8({}, i), {}, { self: s })
        null == l || null === (a = l[n]) || void 0 === a || a.call(l, c)
      }
    } catch (d) {
      r.e(d)
    } finally {
      r.f()
    }
  }
  __name(a, 'addToRegistry'),
    __name(s, 'dropTargetForConsumers'),
    __name(l, 'getActualDropTargets'),
    __name(c, 'notifyCurrent')
  var d = {
    onGenerateDragPreview: c,
    onDrag: c,
    onDragStart: c,
    onDrop: c,
    onDropTargetChange: __name(function (e) {
      var t,
        n = e.payload,
        i = new Set(
          n.location.current.dropTargets.map(function (e) {
            return e.element
          })
        ),
        r = new Set(),
        a = _createForOfIteratorHelper$2(n.location.previous.dropTargets)
      try {
        for (a.s(); !(t = a.n()).done; ) {
          var s,
            l = t.value
          r.add(l.element)
          var c,
            d = o.get(l.element),
            u = i.has(l.element),
            p = _objectSpread$8(_objectSpread$8({}, n), {}, { self: l })
          if (
            (null == d ||
              null === (s = d.onDropTargetChange) ||
              void 0 === s ||
              s.call(d, p),
            !u)
          )
            null == d ||
              null === (c = d.onDragLeave) ||
              void 0 === c ||
              c.call(d, p)
        }
      } catch (b) {
        a.e(b)
      } finally {
        a.f()
      }
      var h,
        m = _createForOfIteratorHelper$2(n.location.current.dropTargets)
      try {
        for (m.s(); !(h = m.n()).done; ) {
          var f,
            _,
            g = h.value
          if (!r.has(g.element)) {
            var v = _objectSpread$8(_objectSpread$8({}, n), {}, { self: g }),
              y = o.get(g.element)
            null == y ||
              null === (f = y.onDropTargetChange) ||
              void 0 === f ||
              f.call(y, v),
              null == y ||
                null === (_ = y.onDragEnter) ||
                void 0 === _ ||
                _.call(y, v)
          }
        }
      } catch (b) {
        m.e(b)
      } finally {
        m.f()
      }
    }, 'onDropTargetChange')
  }
  function u(e) {
    d[e.eventName](e)
  }
  function p(e) {
    var t = e.source,
      n = e.target,
      i = e.input,
      r = e.current,
      a = l({ source: t, target: n, input: i })
    if (a.length >= r.length) return a
    for (
      var s = copyReverse(r), c = copyReverse(a), d = [], u = 0;
      u < s.length;
      u++
    ) {
      var p,
        h = s[u],
        m = c[u]
      if (null == m) {
        var f = d[u - 1],
          _ = s[u - 1]
        if (
          (null == f ? void 0 : f.element) !== (null == _ ? void 0 : _.element)
        )
          break
        var g = o.get(h.element)
        if (!g) break
        var v = { input: i, source: t, element: g.element }
        if (g.canDrop && !g.canDrop(v)) break
        if (null === (p = g.getIsSticky) || void 0 === p || !p.call(g, v)) break
        d.push(
          _objectSpread$8(
            _objectSpread$8({}, h),
            {},
            { isActiveDueToStickiness: !0 }
          )
        )
      } else d.push(m)
    }
    return copyReverse(d)
  }
  return (
    __name(u, 'dispatchEvent'),
    __name(p, 'getIsOver'),
    { dropTargetForConsumers: s, getIsOver: p, dispatchEvent: u }
  )
}
function _createForOfIteratorHelper$1(e, t) {
  var n =
    ('undefined' != typeof Symbol && e[Symbol.iterator]) || e['@@iterator']
  if (!n) {
    if (
      Array.isArray(e) ||
      (n = _unsupportedIterableToArray$4(e)) ||
      (t && e && 'number' == typeof e.length)
    ) {
      n && (e = n)
      var o = 0,
        i = __name(function () {}, 'F')
      return {
        s: i,
        n: __name(function () {
          return o >= e.length ? { done: !0 } : { done: !1, value: e[o++] }
        }, 'n'),
        e: __name(function (e) {
          throw e
        }, 'e'),
        f: i
      }
    }
    throw new TypeError(
      'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
    )
  }
  var r,
    a = !0,
    s = !1
  return {
    s: __name(function () {
      n = n.call(e)
    }, 's'),
    n: __name(function () {
      var e = n.next()
      return (a = e.done), e
    }, 'n'),
    e: __name(function (e) {
      ;(s = !0), (r = e)
    }, 'e'),
    f: __name(function () {
      try {
        a || null == n.return || n.return()
      } finally {
        if (s) throw r
      }
    }, 'f')
  }
}
function _unsupportedIterableToArray$4(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$4(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$4(e, t)
          : void 0
    )
  }
}
function _arrayLikeToArray$4(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
function ownKeys$7(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$7(Object(n), !0).forEach(function (t) {
          _defineProperty$7(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$7(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function makeMonitor() {
  var e = new Set(),
    t = null
  function n(e) {
    t && ((e.canMonitor && !e.canMonitor(t.canMonitorArgs)) || t.active.add(e))
  }
  function o(o) {
    var i = _objectSpread$7({}, o)
    return (
      e.add(i),
      n(i),
      __name(function () {
        e.delete(i), t && t.active.delete(i)
      }, 'cleanup')
    )
  }
  function i(o) {
    var i = o.eventName,
      r = o.payload
    if ('onGenerateDragPreview' === i) {
      t = {
        canMonitorArgs: { initial: r.location.initial, source: r.source },
        active: new Set()
      }
      var a,
        s = _createForOfIteratorHelper$1(e)
      try {
        for (s.s(); !(a = s.n()).done; ) {
          n(a.value)
        }
      } catch (p) {
        s.e(p)
      } finally {
        s.f()
      }
    }
    if (t) {
      for (var l = 0, c = Array.from(t.active); l < c.length; l++) {
        var d,
          u = c[l]
        if (t.active.has(u)) null === (d = u[i]) || void 0 === d || d.call(u, r)
      }
      'onDrop' === i && (t.active.clear(), (t = null))
    }
  }
  return (
    __name(n, 'tryAddToActive'),
    __name(o, 'monitorForConsumers'),
    __name(i, 'dispatchEvent'),
    { dispatchEvent: i, monitorForConsumers: o }
  )
}
function makeAdapter(e) {
  var t = e.typeKey,
    n = e.mount,
    o = e.dispatchEventToSource,
    i = e.onPostDispatch,
    r = e.defaultDropEffect,
    a = makeMonitor(),
    s = makeDropTarget({ typeKey: t, defaultDropEffect: r })
  function l(e) {
    null == o || o(e), s.dispatchEvent(e), a.dispatchEvent(e), null == i || i(e)
  }
  function c(e) {
    var t = e.event,
      n = e.dragType
    lifecycle.start({
      event: t,
      dragType: n,
      getDropTargetsOver: s.getIsOver,
      dispatchEvent: l
    })
  }
  function d() {
    function e() {
      var e = { canStart: lifecycle.canStart, start: c }
      return n(e)
    }
    return __name(e, 'mountAdapter'), register({ typeKey: t, mount: e })
  }
  return (
    __name(l, 'dispatchEvent'),
    __name(c, 'start'),
    __name(d, 'registerUsage'),
    {
      registerUsage: d,
      dropTarget: s.dropTargetForConsumers,
      monitor: a.monitorForConsumers
    }
  )
}
__name(registerUsage, 'registerUsage'),
  __name(register, 'register'),
  __name(combine, 'combine'),
  __name(addAttribute, 'addAttribute'),
  __name(ownKeys$8, 'ownKeys$8'),
  __name(_objectSpread$8, '_objectSpread$8'),
  __name(_createForOfIteratorHelper$2, '_createForOfIteratorHelper$2'),
  __name(_unsupportedIterableToArray$5, '_unsupportedIterableToArray$5'),
  __name(_arrayLikeToArray$5, '_arrayLikeToArray$5'),
  __name(copyReverse, 'copyReverse'),
  __name(makeDropTarget, 'makeDropTarget'),
  __name(_createForOfIteratorHelper$1, '_createForOfIteratorHelper$1'),
  __name(_unsupportedIterableToArray$4, '_unsupportedIterableToArray$4'),
  __name(_arrayLikeToArray$4, '_arrayLikeToArray$4'),
  __name(ownKeys$7, 'ownKeys$7'),
  __name(_objectSpread$7, '_objectSpread$7'),
  __name(makeMonitor, 'makeMonitor'),
  __name(makeAdapter, 'makeAdapter')
var isAndroid = once(
    __name(function () {
      return navigator.userAgent.toLocaleLowerCase().includes('android')
    }, 'isAndroid')
  ),
  androidFallbackText = 'pdnd:android-fallback',
  textMediaType = 'text/plain',
  URLMediaType = 'text/uri-list',
  elementAdapterNativeDataKey = 'application/vnd.pdnd',
  draggableRegistry = new WeakMap()
function addToRegistry(e) {
  return (
    draggableRegistry.set(e.element, e),
    __name(function () {
      draggableRegistry.delete(e.element)
    }, 'cleanup')
  )
}
__name(addToRegistry, 'addToRegistry')
var honeyPotFix = makeHoneyPotFix(),
  adapter = makeAdapter({
    typeKey: 'element',
    defaultDropEffect: 'move',
    mount: __name(function (e) {
      return combine(
        honeyPotFix.bindEvents(),
        dist.bind(document, {
          type: 'dragstart',
          listener: __name(function (t) {
            var n, o, i, r, a, s
            if (e.canStart(t) && !t.defaultPrevented && t.dataTransfer) {
              var l = t.target
              if (!(l instanceof HTMLElement)) return null
              var c = draggableRegistry.get(l)
              if (!c) return null
              var d = getInput(t),
                u = {
                  element: c.element,
                  dragHandle:
                    null !== (n = c.dragHandle) && void 0 !== n ? n : null,
                  input: d
                }
              if (c.canDrag && !c.canDrag(u)) return t.preventDefault(), null
              if (c.dragHandle) {
                var p = getElementFromPointWithoutHoneypot({
                  x: d.clientX,
                  y: d.clientY
                })
                if (!c.dragHandle.contains(p)) return t.preventDefault(), null
              }
              var h =
                null !==
                  (o =
                    null === (i = c.getInitialDataForExternal) || void 0 === i
                      ? void 0
                      : i.call(c, u)) && void 0 !== o
                  ? o
                  : null
              if (h)
                for (var m = 0, f = Object.entries(h); m < f.length; m++) {
                  var _ = _slicedToArray$1(f[m], 2),
                    g = _[0],
                    v = _[1]
                  t.dataTransfer.setData(g, null != v ? v : '')
                }
              !isAndroid() ||
                t.dataTransfer.types.includes(textMediaType) ||
                t.dataTransfer.types.includes(URLMediaType) ||
                t.dataTransfer.setData(textMediaType, androidFallbackText),
                t.dataTransfer.setData(elementAdapterNativeDataKey, '')
              var y = {
                type: 'element',
                payload: {
                  element: c.element,
                  dragHandle:
                    null !== (r = c.dragHandle) && void 0 !== r ? r : null,
                  data:
                    null !==
                      (a =
                        null === (s = c.getInitialData) || void 0 === s
                          ? void 0
                          : s.call(c, u)) && void 0 !== a
                      ? a
                      : {}
                },
                startedFrom: 'internal'
              }
              e.start({ event: t, dragType: y })
            }
          }, 'listener')
        })
      )
    }, 'mount'),
    dispatchEventToSource: __name(function (e) {
      var t,
        n,
        o = e.eventName,
        i = e.payload
      null === (t = draggableRegistry.get(i.source.element)) ||
        void 0 === t ||
        null === (n = t[o]) ||
        void 0 === n ||
        n.call(t, i)
    }, 'dispatchEventToSource'),
    onPostDispatch: honeyPotFix.getOnPostDispatch()
  }),
  dropTargetForElements = adapter.dropTarget,
  monitorForElements = adapter.monitor
function draggable(e) {
  return combine(
    adapter.registerUsage(),
    addToRegistry(e),
    addAttribute(e.element, { attribute: 'draggable', value: 'true' })
  )
}
function usePragmaticDroppable(e, t) {
  let n = __name(() => {}, 'cleanup')
  Vue.onMounted(() => {
    const o = 'function' == typeof e ? e() : e
    o && (n = dropTargetForElements({ element: o, ...t }))
  }),
    Vue.onBeforeUnmount(() => {
      n()
    })
}
function usePragmaticDraggable(e, t) {
  let n = __name(() => {}, 'cleanup')
  Vue.onMounted(() => {
    const o = 'function' == typeof e ? e() : e
    o && (n = draggable({ element: o, ...t }))
  }),
    Vue.onBeforeUnmount(() => {
      n()
    })
}
__name(draggable, 'draggable'),
  __name(usePragmaticDroppable, 'usePragmaticDroppable'),
  __name(usePragmaticDraggable, 'usePragmaticDraggable')
const _hoisted_1$r = { class: 'node-content' },
  _hoisted_2$g = { class: 'node-label' },
  _hoisted_3$a = { class: 'node-actions' },
  _sfc_main$q = Vue.defineComponent({
    __name: 'TreeExplorerTreeNode',
    props: { node: {} },
    emits: ['itemDropped', 'dragStart', 'dragEnd'],
    setup(e, { emit: t }) {
      const n = e,
        o = t,
        i = Vue.computed(() =>
          n.node.leaf
            ? ''
            : void 0 !== n.node.badgeText && null !== n.node.badgeText
              ? n.node.badgeText
              : n.node.totalLeaves.toString()
        ),
        r = Vue.computed(() => '' !== i.value),
        a = Vue.computed(() => !!n.node.handleRename),
        s = Vue.inject('renameEditingNode'),
        l = Vue.computed(() => a.value && s.value?.key === n.node.key),
        c = useErrorHandling().wrapWithErrorHandlingAsync(
          async (e) => {
            await n.node.handleRename(n.node, e)
          },
          n.node.handleError,
          () => {
            s.value = null
          }
        ),
        d = Vue.ref(null),
        u = Vue.ref(!1),
        p = __name(
          () => d.value?.closest('.p-tree-node-content'),
          'treeNodeElementGetter'
        )
      return (
        n.node.draggable &&
          usePragmaticDraggable(p, {
            getInitialData: __name(
              () => ({ type: 'tree-explorer-node', data: n.node }),
              'getInitialData'
            ),
            onDragStart: __name(() => o('dragStart', n.node), 'onDragStart'),
            onDrop: __name(() => o('dragEnd', n.node), 'onDrop')
          }),
        n.node.droppable &&
          usePragmaticDroppable(p, {
            onDrop: __name(async (e) => {
              const t = e.source.data
              'tree-explorer-node' === t.type &&
                (await n.node.handleDrop?.(n.node, t),
                (u.value = !1),
                o('itemDropped', n.node, t.data))
            }, 'onDrop'),
            onDragEnter: __name((e) => {
              'tree-explorer-node' === e.source.data.type && (u.value = !0)
            }, 'onDragEnter'),
            onDragLeave: __name(() => {
              u.value = !1
            }, 'onDragLeave')
          }),
        (e, t) => (
          Vue.openBlock(),
          Vue.createElementBlock(
            'div',
            {
              class: Vue.normalizeClass([
                'tree-node',
                {
                  'can-drop': u.value,
                  'tree-folder': !n.node.leaf,
                  'tree-leaf': n.node.leaf
                }
              ]),
              ref_key: 'container',
              ref: d
            },
            [
              Vue.createElementVNode('div', _hoisted_1$r, [
                Vue.createElementVNode('span', _hoisted_2$g, [
                  Vue.renderSlot(
                    e.$slots,
                    'before-label',
                    { node: n.node },
                    void 0,
                    !0
                  ),
                  Vue.createVNode(
                    EditableText,
                    {
                      modelValue: e.node.label,
                      isEditing: l.value,
                      onEdit: Vue.unref(c)
                    },
                    null,
                    8,
                    ['modelValue', 'isEditing', 'onEdit']
                  ),
                  Vue.renderSlot(
                    e.$slots,
                    'after-label',
                    { node: n.node },
                    void 0,
                    !0
                  )
                ]),
                r.value
                  ? (Vue.openBlock(),
                    Vue.createBlock(
                      Vue.unref(script$L),
                      {
                        key: 0,
                        value: i.value,
                        severity: 'secondary',
                        class: 'leaf-count-badge'
                      },
                      null,
                      8,
                      ['value']
                    ))
                  : Vue.createCommentVNode('', !0)
              ]),
              Vue.createElementVNode('div', _hoisted_3$a, [
                Vue.renderSlot(
                  e.$slots,
                  'actions',
                  { node: n.node },
                  void 0,
                  !0
                )
              ])
            ],
            2
          )
        )
      )
    }
  }),
  TreeExplorerTreeNode = _export_sfc(_sfc_main$q, [
    ['__scopeId', 'data-v-d8fc59be']
  ]),
  _sfc_main$p = Vue.defineComponent({
    __name: 'TreeExplorer',
    props: Vue.mergeModels(
      { roots: {}, class: {} },
      {
        expandedKeys: {},
        expandedKeysModifiers: {},
        selectionKeys: {},
        selectionKeysModifiers: {}
      }
    ),
    emits: Vue.mergeModels(
      ['nodeClick', 'nodeDelete', 'contextMenu'],
      ['update:expandedKeys', 'update:selectionKeys']
    ),
    setup(e, { expose: t, emit: n }) {
      const o = Vue.useModel(e, 'expandedKeys')
      Vue.provide('expandedKeys', o)
      const i = Vue.useModel(e, 'selectionKeys')
      Vue.provide('selectionKeys', i)
      const r = void 0 !== i.value,
        a = e,
        s = n,
        l = Vue.computed(() => a.roots.map(d)),
        c = __name((e) => {
          if (e.getIcon) {
            const t = e.getIcon(e)
            if (t) return t
          } else if (e.icon) return e.icon
          if (e.leaf) return 'pi pi-file'
          return o.value[e.key] ? 'pi pi-folder-open' : 'pi pi-folder'
        }, 'getTreeNodeIcon'),
        d = __name((e) => {
          const t = e.children?.map(d),
            n = e.leaf ? 1 : t.reduce((e, t) => e + t.totalLeaves, 0)
          return {
            ...e,
            icon: c(e),
            children: t,
            type: e.leaf ? 'node' : 'folder',
            totalLeaves: n,
            badgeText: e.getBadgeText ? e.getBadgeText(e) : null
          }
        }, 'fillNodeInfo'),
        u = __name(async (e, t) => {
          r || (i.value = {}),
            t.handleClick && (await t.handleClick(t, e)),
            s('nodeClick', t, e)
        }, 'onNodeContentClick'),
        p = Vue.ref(null),
        h = Vue.ref(null)
      Vue.provide('menuTargetNode', h)
      const m = Vue.computed(() =>
          h.value?.contextMenuItems
            ? 'function' == typeof h.value.contextMenuItems
              ? h.value.contextMenuItems(h.value)
              : h.value.contextMenuItems
            : []
        ),
        f = Vue.ref(null)
      Vue.provide('renameEditingNode', f)
      const { t: _ } = VueI18n.useI18n(),
        g = __name((e) => {
          f.value = e
        }, 'renameCommand'),
        v = __name(async (e) => {
          await e.handleDelete?.(e), s('nodeDelete', e)
        }, 'deleteCommand'),
        y = Vue.computed(() =>
          [
            {
              label: _('rename'),
              icon: 'pi pi-file-edit',
              command: __name(() => g(h.value), 'command'),
              visible: void 0 !== h.value?.handleRename
            },
            {
              label: _('delete'),
              icon: 'pi pi-trash',
              command: __name(() => v(h.value), 'command'),
              visible: void 0 !== h.value?.handleDelete,
              isAsync: !0
            },
            ...m.value
          ].map((e) => ({
            ...e,
            command: C(e.command, { isAsync: e.isAsync ?? !1 })
          }))
        ),
        b = __name((e, t) => {
          ;(h.value = e),
            s('contextMenu', e, t),
            y.value.filter((e) => e.visible).length > 0 && p.value?.show(t)
        }, 'handleContextMenu'),
        S = useErrorHandling(),
        C = __name(
          (e, { isAsync: t = !1 }) =>
            t
              ? S.wrapWithErrorHandlingAsync(e, h.value?.handleError)
              : S.wrapWithErrorHandling(e, h.value?.handleError),
          'wrapCommandWithErrorHandler'
        )
      return (
        t({ renameCommand: g, deleteCommand: v }),
        (e, t) => (
          Vue.openBlock(),
          Vue.createElementBlock(
            Vue.Fragment,
            null,
            [
              Vue.createVNode(
                Vue.unref(script$j),
                {
                  class: Vue.normalizeClass([
                    'tree-explorer py-0 px-2 2xl:px-4',
                    a.class
                  ]),
                  expandedKeys: o.value,
                  'onUpdate:expandedKeys':
                    t[0] || (t[0] = (e) => (o.value = e)),
                  selectionKeys: i.value,
                  'onUpdate:selectionKeys':
                    t[1] || (t[1] = (e) => (i.value = e)),
                  value: l.value,
                  selectionMode: 'single',
                  pt: {
                    nodeLabel: 'tree-explorer-node-label',
                    nodeContent: __name(
                      ({ props: e }) => ({
                        onClick: __name((t) => u(t, e.node), 'onClick'),
                        onContextmenu: __name(
                          (t) => b(e.node, t),
                          'onContextmenu'
                        )
                      }),
                      'nodeContent'
                    ),
                    nodeToggleButton: __name(
                      () => ({
                        onClick: __name((e) => {
                          e.stopImmediatePropagation()
                        }, 'onClick')
                      }),
                      'nodeToggleButton'
                    )
                  }
                },
                {
                  folder: Vue.withCtx(({ node: t }) => [
                    Vue.renderSlot(
                      e.$slots,
                      'folder',
                      { node: t },
                      () => [
                        Vue.createVNode(
                          TreeExplorerTreeNode,
                          { node: t },
                          null,
                          8,
                          ['node']
                        )
                      ],
                      !0
                    )
                  ]),
                  node: Vue.withCtx(({ node: t }) => [
                    Vue.renderSlot(
                      e.$slots,
                      'node',
                      { node: t },
                      () => [
                        Vue.createVNode(
                          TreeExplorerTreeNode,
                          { node: t },
                          null,
                          8,
                          ['node']
                        )
                      ],
                      !0
                    )
                  ]),
                  _: 3
                },
                8,
                ['class', 'expandedKeys', 'selectionKeys', 'value', 'pt']
              ),
              Vue.createVNode(
                Vue.unref(script$h),
                { ref_key: 'menu', ref: p, model: y.value },
                null,
                8,
                ['model']
              )
            ],
            64
          )
        )
      )
    }
  }),
  TreeExplorer = _export_sfc(_sfc_main$p, [['__scopeId', 'data-v-b7c3d32e']])
var theme$b = __name(function (e) {
    var t = e.dt
    return '\n.p-toolbar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    flex-wrap: wrap;\n    padding: '
      .concat(t('toolbar.padding'), ';\n    background: ')
      .concat(t('toolbar.background'), ';\n    border: 1px solid ')
      .concat(t('toolbar.border.color'), ';\n    color: ')
      .concat(t('toolbar.color'), ';\n    border-radius: ')
      .concat(t('toolbar.border.radius'), ';\n    gap: ')
      .concat(
        t('toolbar.gap'),
        ';\n}\n\n.p-toolbar-start,\n.p-toolbar-center,\n.p-toolbar-end {\n    display: flex;\n    align-items: center;\n}\n'
      )
  }, 'theme'),
  classes$b = {
    root: 'p-toolbar p-component',
    start: 'p-toolbar-start',
    center: 'p-toolbar-center',
    end: 'p-toolbar-end'
  },
  ToolbarStyle = BaseStyle.extend({
    name: 'toolbar',
    theme: theme$b,
    classes: classes$b
  }),
  script$1$a = {
    name: 'BaseToolbar',
    extends: script$Y,
    props: { ariaLabelledby: { type: String, default: null } },
    style: ToolbarStyle,
    provide: __name(function () {
      return { $pcToolbar: this, $parentInstance: this }
    }, 'provide')
  },
  script$g = { name: 'Toolbar', extends: script$1$a, inheritAttrs: !1 },
  _hoisted_1$q = ['aria-labelledby']
function render$f(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps(
        {
          class: e.cx('root'),
          role: 'toolbar',
          'aria-labelledby': e.ariaLabelledby
        },
        e.ptmi('root')
      ),
      [
        Vue.createElementVNode(
          'div',
          Vue.mergeProps({ class: e.cx('start') }, e.ptm('start')),
          [Vue.renderSlot(e.$slots, 'start')],
          16
        ),
        Vue.createElementVNode(
          'div',
          Vue.mergeProps({ class: e.cx('center') }, e.ptm('center')),
          [Vue.renderSlot(e.$slots, 'center')],
          16
        ),
        Vue.createElementVNode(
          'div',
          Vue.mergeProps({ class: e.cx('end') }, e.ptm('end')),
          [Vue.renderSlot(e.$slots, 'end')],
          16
        )
      ],
      16,
      _hoisted_1$q
    )
  )
}
__name(render$f, 'render$f'), (script$g.render = render$f)
const _hoisted_1$p = { class: 'comfy-vue-side-bar-header' },
  _hoisted_2$f = { class: 'text-sm' },
  _sfc_main$o = Vue.defineComponent({
    __name: 'SidebarTabTemplate',
    props: { title: {}, class: {} },
    setup(e) {
      const t = e
      return (e, n) => (
        Vue.openBlock(),
        Vue.createElementBlock(
          'div',
          {
            class: Vue.normalizeClass([
              'comfy-vue-side-bar-container flex flex-col h-full',
              t.class
            ])
          },
          [
            Vue.createElementVNode('div', _hoisted_1$p, [
              Vue.createVNode(
                Vue.unref(script$g),
                {
                  class:
                    'flex-shrink-0 border-x-0 border-t-0 rounded-none px-2 py-1 min-h-8'
                },
                {
                  start: Vue.withCtx(() => [
                    Vue.createElementVNode(
                      'span',
                      _hoisted_2$f,
                      Vue.toDisplayString(t.title.toUpperCase()),
                      1
                    )
                  ]),
                  end: Vue.withCtx(() => [
                    Vue.renderSlot(e.$slots, 'tool-buttons', {}, void 0, !0)
                  ]),
                  _: 3
                }
              ),
              Vue.renderSlot(e.$slots, 'header', {}, void 0, !0)
            ]),
            Vue.createVNode(
              Vue.unref(script$F),
              { class: 'comfy-vue-side-bar-body flex-grow h-0' },
              {
                default: Vue.withCtx(() => [
                  Vue.renderSlot(e.$slots, 'body', {}, void 0, !0)
                ]),
                _: 3
              }
            )
          ],
          2
        )
      )
    }
  }),
  SidebarTabTemplate = _export_sfc(_sfc_main$o, [
    ['__scopeId', 'data-v-100ab5c6']
  ]),
  _hoisted_1$o = { class: 'model_preview' },
  _hoisted_2$e = { class: 'model_preview_title' },
  _hoisted_3$9 = { class: 'model_preview_top_container' },
  _hoisted_4$6 = { class: 'model_preview_filename' },
  _hoisted_5$5 = { key: 0, class: 'model_preview_architecture' },
  _hoisted_6$3 = { key: 1, class: 'model_preview_author' },
  _hoisted_7$2 = { key: 0, class: 'model_preview_image' },
  _hoisted_8$1 = ['src'],
  _hoisted_9$1 = { key: 1, class: 'model_preview_usage_hint' },
  _hoisted_10$1 = { key: 2, class: 'model_preview_trigger_phrase' },
  _hoisted_11$1 = { key: 3, class: 'model_preview_description' },
  _sfc_main$n = Vue.defineComponent({
    __name: 'ModelPreview',
    props: { modelDef: { type: ComfyModelDef, required: !0 } },
    setup(e) {
      const t = e.modelDef
      return (e, n) => (
        Vue.openBlock(),
        Vue.createElementBlock('div', _hoisted_1$o, [
          Vue.createElementVNode(
            'div',
            _hoisted_2$e,
            Vue.toDisplayString(Vue.unref(t).title),
            1
          ),
          Vue.createElementVNode('div', _hoisted_3$9, [
            Vue.createElementVNode(
              'div',
              _hoisted_4$6,
              Vue.toDisplayString(Vue.unref(t).file_name),
              1
            ),
            Vue.unref(t).architecture_id
              ? (Vue.openBlock(),
                Vue.createElementBlock('div', _hoisted_5$5, [
                  n[0] ||
                    (n[0] = Vue.createElementVNode(
                      'span',
                      { class: 'model_preview_prefix' },
                      'Architecture: ',
                      -1
                    )),
                  Vue.createTextVNode(
                    ' ' + Vue.toDisplayString(Vue.unref(t).architecture_id),
                    1
                  )
                ]))
              : Vue.createCommentVNode('', !0),
            Vue.unref(t).author
              ? (Vue.openBlock(),
                Vue.createElementBlock('div', _hoisted_6$3, [
                  n[1] ||
                    (n[1] = Vue.createElementVNode(
                      'span',
                      { class: 'model_preview_prefix' },
                      'Author: ',
                      -1
                    )),
                  Vue.createTextVNode(
                    ' ' + Vue.toDisplayString(Vue.unref(t).author),
                    1
                  )
                ]))
              : Vue.createCommentVNode('', !0)
          ]),
          Vue.unref(t).image
            ? (Vue.openBlock(),
              Vue.createElementBlock('div', _hoisted_7$2, [
                Vue.createElementVNode(
                  'img',
                  { src: Vue.unref(t).image },
                  null,
                  8,
                  _hoisted_8$1
                )
              ]))
            : Vue.createCommentVNode('', !0),
          Vue.unref(t).usage_hint
            ? (Vue.openBlock(),
              Vue.createElementBlock('div', _hoisted_9$1, [
                n[2] ||
                  (n[2] = Vue.createElementVNode(
                    'span',
                    { class: 'model_preview_prefix' },
                    'Usage hint: ',
                    -1
                  )),
                Vue.createTextVNode(
                  ' ' + Vue.toDisplayString(Vue.unref(t).usage_hint),
                  1
                )
              ]))
            : Vue.createCommentVNode('', !0),
          Vue.unref(t).trigger_phrase
            ? (Vue.openBlock(),
              Vue.createElementBlock('div', _hoisted_10$1, [
                n[3] ||
                  (n[3] = Vue.createElementVNode(
                    'span',
                    { class: 'model_preview_prefix' },
                    'Trigger phrase: ',
                    -1
                  )),
                Vue.createTextVNode(
                  ' ' + Vue.toDisplayString(Vue.unref(t).trigger_phrase),
                  1
                )
              ]))
            : Vue.createCommentVNode('', !0),
          Vue.unref(t).description
            ? (Vue.openBlock(),
              Vue.createElementBlock('div', _hoisted_11$1, [
                n[4] ||
                  (n[4] = Vue.createElementVNode(
                    'span',
                    { class: 'model_preview_prefix' },
                    'Description: ',
                    -1
                  )),
                Vue.createTextVNode(
                  ' ' + Vue.toDisplayString(Vue.unref(t).description),
                  1
                )
              ]))
            : Vue.createCommentVNode('', !0)
        ])
      )
    }
  }),
  ModelPreview = _export_sfc(_sfc_main$n, [['__scopeId', 'data-v-32e6c4d9']]),
  _hoisted_1$n = { key: 0, class: 'model-lib-model-icon-container' },
  _sfc_main$m = Vue.defineComponent({
    __name: 'ModelTreeLeaf',
    props: { node: {} },
    setup(e) {
      const t = e,
        n = Vue.computed(() => t.node.data),
        o = Vue.ref(null),
        i = Vue.ref({ position: 'absolute', top: '0px', left: '0px' }),
        r = useSettingStore(),
        a = Vue.computed(() => r.get('Comfy.Sidebar.Location')),
        s = __name(async () => {
          const e = c.value.getBoundingClientRect(),
            t = o.value?.$el.offsetHeight || 0,
            r = window.innerHeight - e.bottom
          ;(i.value.top =
            t > r
              ? `${Math.max(0, e.top - (t - r) - 20)}px`
              : e.top - 40 + 'px'),
            'left' === a.value
              ? (i.value.left = `${e.right}px`)
              : (i.value.left = e.left - 400 + 'px'),
            n.value.load()
        }, 'handleModelHover'),
        l = Vue.ref(null),
        c = Vue.ref(null),
        d = Vue.ref(!1),
        u = Vue.computed(
          () =>
            d.value &&
            n.value &&
            n.value.has_loaded_metadata &&
            (n.value.author ||
              n.value.simplified_file_name != n.value.title ||
              n.value.description ||
              n.value.usage_hint ||
              n.value.trigger_phrase ||
              n.value.image)
        ),
        p = __name(async () => {
          ;(d.value = !0), await Vue.nextTick(), s()
        }, 'handleMouseEnter'),
        h = __name(() => {
          d.value = !1
        }, 'handleMouseLeave')
      return (
        Vue.onMounted(() => {
          ;(c.value = l.value?.closest('.p-tree-node-content')),
            c.value?.addEventListener('mouseenter', p),
            c.value?.addEventListener('mouseleave', h),
            n.value.load()
        }),
        Vue.onUnmounted(() => {
          c.value?.removeEventListener('mouseenter', p),
            c.value?.removeEventListener('mouseleave', h)
        }),
        (e, t) => (
          Vue.openBlock(),
          Vue.createElementBlock(
            'div',
            {
              ref_key: 'container',
              ref: l,
              class: 'model-lib-node-container h-full w-full'
            },
            [
              Vue.createVNode(
                TreeExplorerTreeNode,
                { node: e.node },
                {
                  'before-label': Vue.withCtx(() => [
                    n.value && n.value.image
                      ? (Vue.openBlock(),
                        Vue.createElementBlock('span', _hoisted_1$n, [
                          Vue.createElementVNode(
                            'span',
                            {
                              class: 'model-lib-model-icon',
                              style: Vue.normalizeStyle({
                                backgroundImage: `url(${n.value.image})`
                              })
                            },
                            null,
                            4
                          )
                        ]))
                      : Vue.createCommentVNode('', !0)
                  ]),
                  _: 1
                },
                8,
                ['node']
              ),
              u.value
                ? (Vue.openBlock(),
                  Vue.createBlock(
                    Vue.Teleport,
                    { key: 0, to: '#model-library-model-preview-container' },
                    [
                      Vue.createElementVNode(
                        'div',
                        {
                          class: 'model-lib-model-preview',
                          style: Vue.normalizeStyle(i.value)
                        },
                        [
                          Vue.createVNode(
                            ModelPreview,
                            {
                              ref_key: 'previewRef',
                              ref: o,
                              modelDef: n.value
                            },
                            null,
                            8,
                            ['modelDef']
                          )
                        ],
                        4
                      )
                    ]
                  ))
                : Vue.createCommentVNode('', !0)
            ],
            512
          )
        )
      )
    }
  }),
  ModelTreeLeaf = _export_sfc(_sfc_main$m, [['__scopeId', 'data-v-be871f15']])
var theme$a = __name(function (e) {
    var t = e.dt
    return '\n.p-progressbar {\n    position: relative;\n    overflow: hidden;\n    height: '
      .concat(t('progressbar.height'), ';\n    background: ')
      .concat(t('progressbar.background'), ';\n    border-radius: ')
      .concat(
        t('progressbar.border.radius'),
        ';\n}\n\n.p-progressbar-value {\n    margin: 0;\n    background: '
      )
      .concat(
        t('progressbar.value.background'),
        ';\n}\n\n.p-progressbar-label {\n    color: '
      )
      .concat(t('progressbar.label.color'), ';\n    font-size: ')
      .concat(t('progressbar.label.font.size'), ';\n    font-weight: ')
      .concat(
        t('progressbar.label.font.weight'),
        ';\n}\n\n.p-progressbar-determinate .p-progressbar-value {\n    height: 100%;\n    width: 0%;\n    position: absolute;\n    display: none;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    transition: width 1s ease-in-out;\n}\n\n.p-progressbar-determinate .p-progressbar-label {\n    display: inline-flex;\n}\n\n.p-progressbar-indeterminate .p-progressbar-value::before {\n    content: "";\n    position: absolute;\n    background: inherit;\n    inset-block-start: 0;\n    inset-inline-start: 0;\n    inset-block-end: 0;\n    will-change: inset-inline-start, inset-inline-end;\n    animation: p-progressbar-indeterminate-anim 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;\n}\n\n.p-progressbar-indeterminate .p-progressbar-value::after {\n    content: "";\n    position: absolute;\n    background: inherit;\n    inset-block-start: 0;\n    inset-inline-start: 0;\n    inset-block-end: 0;\n    will-change: inset-inline-start, inset-inline-end;\n    animation: p-progressbar-indeterminate-anim-short 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) infinite;\n    animation-delay: 1.15s;\n}\n\n@keyframes p-progressbar-indeterminate-anim {\n    0% {\n        inset-inline-start: -35%;\n        inset-inline-end: 100%;\n    }\n    60% {\n        inset-inline-start: 100%;\n        inset-inline-end: -90%;\n    }\n    100% {\n        inset-inline-start: 100%;\n        inset-inline-end: -90%;\n    }\n}\n@-webkit-keyframes p-progressbar-indeterminate-anim {\n    0% {\n        inset-inline-start: -35%;\n        inset-inline-end: 100%;\n    }\n    60% {\n        inset-inline-start: 100%;\n        inset-inline-end: -90%;\n    }\n    100% {\n        inset-inline-start: 100%;\n        inset-inline-end: -90%;\n    }\n}\n\n@keyframes p-progressbar-indeterminate-anim-short {\n    0% {\n        inset-inline-start: -200%;\n        inset-inline-end: 100%;\n    }\n    60% {\n        inset-inline-start: 107%;\n        inset-inline-end: -8%;\n    }\n    100% {\n        inset-inline-start: 107%;\n        inset-inline-end: -8%;\n    }\n}\n@-webkit-keyframes p-progressbar-indeterminate-anim-short {\n    0% {\n        inset-inline-start: -200%;\n        inset-inline-end: 100%;\n    }\n    60% {\n        inset-inline-start: 107%;\n        inset-inline-end: -8%;\n    }\n    100% {\n        inset-inline-start: 107%;\n        inset-inline-end: -8%;\n    }\n}\n'
      )
  }, 'theme'),
  classes$a = {
    root: __name(function (e) {
      var t = e.instance
      return [
        'p-progressbar p-component',
        {
          'p-progressbar-determinate': t.determinate,
          'p-progressbar-indeterminate': t.indeterminate
        }
      ]
    }, 'root'),
    value: 'p-progressbar-value',
    label: 'p-progressbar-label'
  },
  ProgressBarStyle = BaseStyle.extend({
    name: 'progressbar',
    theme: theme$a,
    classes: classes$a
  }),
  script$1$9 = {
    name: 'BaseProgressBar',
    extends: script$Y,
    props: {
      value: { type: Number, default: null },
      mode: { type: String, default: 'determinate' },
      showValue: { type: Boolean, default: !0 }
    },
    style: ProgressBarStyle,
    provide: __name(function () {
      return { $pcProgressBar: this, $parentInstance: this }
    }, 'provide')
  },
  script$f = {
    name: 'ProgressBar',
    extends: script$1$9,
    inheritAttrs: !1,
    computed: {
      progressStyle: __name(function () {
        return { width: this.value + '%', display: 'flex' }
      }, 'progressStyle'),
      indeterminate: __name(function () {
        return 'indeterminate' === this.mode
      }, 'indeterminate'),
      determinate: __name(function () {
        return 'determinate' === this.mode
      }, 'determinate')
    }
  },
  _hoisted_1$m = ['aria-valuenow']
function render$e(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps(
        {
          role: 'progressbar',
          class: e.cx('root'),
          'aria-valuemin': '0',
          'aria-valuenow': e.value,
          'aria-valuemax': '100'
        },
        e.ptmi('root')
      ),
      [
        r.determinate
          ? (Vue.openBlock(),
            Vue.createElementBlock(
              'div',
              Vue.mergeProps(
                { key: 0, class: e.cx('value'), style: r.progressStyle },
                e.ptm('value')
              ),
              [
                null != e.value && 0 !== e.value && e.showValue
                  ? (Vue.openBlock(),
                    Vue.createElementBlock(
                      'div',
                      Vue.mergeProps(
                        { key: 0, class: e.cx('label') },
                        e.ptm('label')
                      ),
                      [
                        Vue.renderSlot(e.$slots, 'default', {}, function () {
                          return [
                            Vue.createTextVNode(
                              Vue.toDisplayString(e.value + '%'),
                              1
                            )
                          ]
                        })
                      ],
                      16
                    ))
                  : Vue.createCommentVNode('', !0)
              ],
              16
            ))
          : r.indeterminate
            ? (Vue.openBlock(),
              Vue.createElementBlock(
                'div',
                Vue.mergeProps(
                  { key: 1, class: e.cx('value') },
                  e.ptm('value')
                ),
                null,
                16
              ))
            : Vue.createCommentVNode('', !0)
      ],
      16,
      _hoisted_1$m
    )
  )
}
__name(render$e, 'render$e'), (script$f.render = render$e)
const IPC_CHANNELS = {
  LOADING_PROGRESS: 'loading-progress',
  IS_PACKAGED: 'is-packaged',
  RENDERER_READY: 'renderer-ready',
  RESTART_APP: 'restart-app',
  REINSTALL: 'reinstall',
  LOG_MESSAGE: 'log-message',
  OPEN_DIALOG: 'open-dialog',
  DOWNLOAD_PROGRESS: 'download-progress',
  START_DOWNLOAD: 'start-download',
  PAUSE_DOWNLOAD: 'pause-download',
  RESUME_DOWNLOAD: 'resume-download',
  CANCEL_DOWNLOAD: 'cancel-download',
  DELETE_MODEL: 'delete-model',
  GET_ALL_DOWNLOADS: 'get-all-downloads',
  GET_ELECTRON_VERSION: 'get-electron-version',
  SEND_ERROR_TO_SENTRY: 'send-error-to-sentry',
  GET_BASE_PATH: 'get-base-path',
  GET_MODEL_CONFIG_PATH: 'get-model-config-path',
  OPEN_PATH: 'open-path',
  OPEN_LOGS_PATH: 'open-logs-path',
  OPEN_DEV_TOOLS: 'open-dev-tools',
  TERMINAL_WRITE: 'execute-terminal-command',
  TERMINAL_RESIZE: 'resize-terminal',
  TERMINAL_RESTORE: 'restore-terminal',
  TERMINAL_ON_OUTPUT: 'terminal-output',
  IS_FIRST_TIME_SETUP: 'is-first-time-setup',
  GET_SYSTEM_PATHS: 'get-system-paths',
  VALIDATE_INSTALL_PATH: 'validate-install-path',
  VALIDATE_COMFYUI_SOURCE: 'validate-comfyui-source',
  SHOW_DIRECTORY_PICKER: 'show-directory-picker',
  INSTALL_COMFYUI: 'install-comfyui'
}
var ProgressStatus = ((e) => (
  (e.INITIAL_STATE = 'initial-state'),
  (e.PYTHON_SETUP = 'python-setup'),
  (e.STARTING_SERVER = 'starting-server'),
  (e.READY = 'ready'),
  (e.ERROR = 'error'),
  e
))(ProgressStatus || {})
const ProgressMessages = {
    'initial-state': 'Loading...',
    'python-setup': 'Setting up Python Environment...',
    'starting-server': 'Starting ComfyUI server...',
    ready: 'Finishing...',
    error:
      'Was not able to start ComfyUI. Please check the logs for more details. You can open it from the Help menu. Please report issues to: https://forum.comfy.org'
  },
  ELECTRON_BRIDGE_API = 'electronAPI',
  SENTRY_URL_ENDPOINT =
    'https://942cadba58d247c9cab96f45221aa813@o4507954455314432.ingest.us.sentry.io/4508007940685824',
  MigrationItems = [
    {
      id: 'user_files',
      label: 'User Files',
      description: 'Settings and user-created workflows'
    },
    {
      id: 'models',
      label: 'Models',
      description:
        'Reference model files from existing ComfyUI installations. (No copy)'
    }
  ],
  DEFAULT_SERVER_ARGS = { host: '127.0.0.1', port: 8e3, extraServerArgs: {} }
var DownloadStatus = ((e) => (
  (e.PENDING = 'pending'),
  (e.IN_PROGRESS = 'in_progress'),
  (e.COMPLETED = 'completed'),
  (e.PAUSED = 'paused'),
  (e.ERROR = 'error'),
  (e.CANCELLED = 'cancelled'),
  e
))(DownloadStatus || {})
const useElectronDownloadStore = defineStore('downloads', () => {
    const e = Vue.ref([]),
      { DownloadManager: t } = electronAPI(),
      n = __name((t) => e.value.find((e) => t === e.url), 'findByUrl'),
      o = __name(async () => {
        if (isElectron()) {
          const o = await t.getAllDownloads()
          for (const t of o) e.value.push(t)
          t.onDownloadProgress((t) => {
            n(t.url) || e.value.push(t)
            const o = n(t.url)
            o &&
              ((o.progress = t.progress),
              (o.status = t.status),
              (o.filename = t.filename),
              (o.savePath = t.savePath))
          })
        }
      }, 'initialize')
    o()
    return {
      downloads: e,
      start: __name(
        ({ url: e, savePath: n, filename: o }) => t.startDownload(e, n, o),
        'start'
      ),
      pause: __name((e) => t.pauseDownload(e), 'pause'),
      resume: __name((e) => t.resumeDownload(e), 'resume'),
      cancel: __name((e) => t.cancelDownload(e), 'cancel'),
      findByUrl: n,
      initialize: o,
      inProgressDownloads: Vue.computed(() =>
        e.value.filter(({ status: e }) => e !== DownloadStatus.COMPLETED)
      )
    }
  }),
  _hoisted_1$l = { class: 'flex flex-col' },
  _hoisted_2$d = { key: 0 },
  _hoisted_3$8 = { key: 1, class: 'mt-2 flex flex-row items-center gap-2' },
  _sfc_main$l = Vue.defineComponent({
    __name: 'DownloadItem',
    props: { download: {} },
    setup(e) {
      const { t: t } = VueI18n.useI18n(),
        n = useElectronDownloadStore(),
        o = e,
        i = __name((e) => {
          let t = (e ?? '').split('/')
          t = 1 === t.length ? t[0].split('\\') : t
          const n = t.pop()
          return `${t.pop()}/${n}`
        }, 'getDownloadLabel'),
        r = __name(() => n.cancel(o.download.url), 'triggerCancelDownload'),
        a = __name(() => n.pause(o.download.url), 'triggerPauseDownload'),
        s = __name(() => n.resume(o.download.url), 'triggerResumeDownload'),
        l = __name(() => {
          n.$patch((e) => {
            e.downloads = e.downloads.filter(
              ({ url: e }) => e !== o.download.url
            )
          })
        }, 'handleRemoveDownload')
      return (e, n) => {
        const o = Vue.resolveDirective('tooltip')
        return (
          Vue.openBlock(),
          Vue.createElementBlock('div', _hoisted_1$l, [
            Vue.createElementVNode(
              'div',
              null,
              Vue.toDisplayString(i(e.download.savePath)),
              1
            ),
            ['cancelled', 'error'].includes(e.download.status)
              ? (Vue.openBlock(),
                Vue.createElementBlock('div', _hoisted_2$d, [
                  Vue.createVNode(
                    Vue.unref(script$D),
                    {
                      class: 'h-6 text-sm font-light bg-red-700 mt-2',
                      removable: '',
                      onRemove: l
                    },
                    {
                      default: Vue.withCtx(() => [
                        Vue.createTextVNode(
                          Vue.toDisplayString(
                            Vue.unref(t)('electronFileDownload.cancelled')
                          ),
                          1
                        )
                      ]),
                      _: 1
                    }
                  )
                ]))
              : Vue.createCommentVNode('', !0),
            ['in_progress', 'paused', 'completed'].includes(e.download.status)
              ? (Vue.openBlock(),
                Vue.createElementBlock('div', _hoisted_3$8, [
                  Vue.createVNode(
                    Vue.unref(script$f),
                    {
                      class: 'flex-1',
                      value: Number((100 * e.download.progress).toFixed(1)),
                      'show-value': e.download.progress > 0.1
                    },
                    null,
                    8,
                    ['value', 'show-value']
                  ),
                  'in_progress' === e.download.status
                    ? Vue.withDirectives(
                        (Vue.openBlock(),
                        Vue.createBlock(
                          Vue.unref(script$K),
                          {
                            key: 0,
                            class: 'file-action-button w-[22px] h-[22px]',
                            size: 'small',
                            rounded: '',
                            onClick: a,
                            icon: 'pi pi-pause'
                          },
                          null,
                          512
                        )),
                        [
                          [
                            o,
                            Vue.unref(t)('electronFileDownload.pause'),
                            void 0,
                            { top: !0 }
                          ]
                        ]
                      )
                    : Vue.createCommentVNode('', !0),
                  'paused' === e.download.status
                    ? Vue.withDirectives(
                        (Vue.openBlock(),
                        Vue.createBlock(
                          Vue.unref(script$K),
                          {
                            key: 1,
                            class: 'file-action-button w-[22px] h-[22px]',
                            size: 'small',
                            rounded: '',
                            onClick: s,
                            icon: 'pi pi-play'
                          },
                          null,
                          512
                        )),
                        [
                          [
                            o,
                            Vue.unref(t)('electronFileDownload.resume'),
                            void 0,
                            { top: !0 }
                          ]
                        ]
                      )
                    : Vue.createCommentVNode('', !0),
                  ['in_progress', 'paused'].includes(e.download.status)
                    ? Vue.withDirectives(
                        (Vue.openBlock(),
                        Vue.createBlock(
                          Vue.unref(script$K),
                          {
                            key: 2,
                            class: 'file-action-button w-[22px] h-[22px] p-red',
                            size: 'small',
                            rounded: '',
                            severity: 'danger',
                            onClick: r,
                            icon: 'pi pi-times-circle'
                          },
                          null,
                          512
                        )),
                        [
                          [
                            o,
                            Vue.unref(t)('electronFileDownload.cancel'),
                            void 0,
                            { top: !0 }
                          ]
                        ]
                      )
                    : Vue.createCommentVNode('', !0)
                ]))
              : Vue.createCommentVNode('', !0)
          ])
        )
      }
    }
  }),
  _hoisted_1$k = { key: 0, class: 'mx-6 mb-4' },
  _hoisted_2$c = { class: 'text-lg my-4' },
  _sfc_main$k = Vue.defineComponent({
    __name: 'ElectronDownloadItems',
    setup(e) {
      const t = useElectronDownloadStore(),
        { inProgressDownloads: n } = storeToRefs(t)
      return (e, t) =>
        Vue.unref(n).length > 0
          ? (Vue.openBlock(),
            Vue.createElementBlock('div', _hoisted_1$k, [
              Vue.createElementVNode(
                'div',
                _hoisted_2$c,
                Vue.toDisplayString(e.$t('electronFileDownload.inProgress')),
                1
              ),
              (Vue.openBlock(!0),
              Vue.createElementBlock(
                Vue.Fragment,
                null,
                Vue.renderList(
                  Vue.unref(n),
                  (e) => (
                    Vue.openBlock(),
                    Vue.createBlock(
                      _sfc_main$l,
                      { key: e.url, download: e },
                      null,
                      8,
                      ['download']
                    )
                  )
                ),
                128
              ))
            ]))
          : Vue.createCommentVNode('', !0)
    }
  })
class ModelNodeProvider {
  static {
    __name(this, 'ModelNodeProvider')
  }
  nodeDef
  key
  constructor(e, t) {
    ;(this.nodeDef = e), (this.key = t)
  }
}
const useModelToNodeStore = defineStore('modelToNode', () => {
  const e = Vue.ref({}),
    t = useNodeDefStore(),
    n = Vue.ref(!1)
  function o(t) {
    return s(), e.value[t]?.[0]
  }
  function i(t) {
    return s(), e.value[t] ?? []
  }
  function r(t, n) {
    s(), e.value[t] || (e.value[t] = []), e.value[t].push(n)
  }
  function a(e, n, o) {
    r(e, new ModelNodeProvider(t.nodeDefsByName[n], o))
  }
  function s() {
    n.value ||
      (0 !== Object.keys(t.nodeDefsByName).length &&
        ((n.value = !0),
        a('checkpoints', 'CheckpointLoaderSimple', 'ckpt_name'),
        a('checkpoints', 'ImageOnlyCheckpointLoader', 'ckpt_name'),
        a('loras', 'LoraLoader', 'lora_name'),
        a('loras', 'LoraLoaderModelOnly', 'lora_name'),
        a('vae', 'VAELoader', 'vae_name'),
        a('controlnet', 'ControlNetLoader', 'control_net_name')))
  }
  return (
    __name(o, 'getNodeProvider'),
    __name(i, 'getAllNodeProviders'),
    __name(r, 'registerNodeProvider'),
    __name(a, 'quickRegister'),
    __name(s, 'registerDefaults'),
    {
      modelToNodeMap: e,
      getNodeProvider: o,
      getAllNodeProviders: i,
      registerNodeProvider: r,
      quickRegister: a,
      registerDefaults: s
    }
  )
})
function useTreeExpansion(e) {
  const t = __name((t) => {
      t.key &&
        'string' == typeof t.key &&
        (t.key in e.value ? delete e.value[t.key] : (e.value[t.key] = !0))
    }, 'toggleNode'),
    n = __name((t) => {
      t.key && 'string' == typeof t.key && (t.key in e.value ? i(t) : o(t))
    }, 'toggleNodeRecursive'),
    o = __name((t) => {
      if (
        t.key &&
        'string' == typeof t.key &&
        t.children &&
        t.children.length
      ) {
        e.value[t.key] = !0
        for (const e of t.children) o(e)
      }
    }, 'expandNode'),
    i = __name((t) => {
      if (
        t.key &&
        'string' == typeof t.key &&
        t.children &&
        t.children.length
      ) {
        delete e.value[t.key]
        for (const e of t.children) i(e)
      }
    }, 'collapseNode'),
    r = __name((e, o) => {
      e.ctrlKey ? n(o) : t(o)
    }, 'toggleNodeOnEvent')
  return {
    toggleNode: t,
    toggleNodeRecursive: n,
    expandNode: o,
    collapseNode: i,
    toggleNodeOnEvent: r
  }
}
__name(useTreeExpansion, 'useTreeExpansion')
const _sfc_main$j = Vue.defineComponent({
    __name: 'ModelLibrarySidebarTab',
    setup(e) {
      const t = useModelStore(),
        n = useModelToNodeStore(),
        o = useSettingStore(),
        i = Vue.ref(''),
        r = Vue.ref({}),
        { expandNode: a, toggleNodeOnEvent: s } = useTreeExpansion(r),
        l = Vue.ref([]),
        c = __name(async (e) => {
          if (!e) return (l.value = []), void (r.value = {})
          await t.loadModels()
          const n = e.toLocaleLowerCase()
          ;(l.value = t.models.filter((e) => e.searchable.includes(n))),
            Vue.nextTick(() => {
              a(d.value)
            })
        }, 'handleSearch'),
        d = Vue.computed(() =>
          buildTree(i.value ? l.value : [...t.modelFolders, ...t.models], (e) =>
            e.key.split('/')
          )
        ),
        u = Vue.computed(() => {
          const e = o.get('Comfy.ModelLibrary.NameFormat'),
            t = __name((o) => {
              const i = o.children?.map(t),
                r = o.leaf && o.data ? o.data : null,
                a = !o.leaf && o.data ? o.data : null
              return {
                key: o.key,
                label: r
                  ? 'title' === e
                    ? r.title
                    : r.simplified_file_name
                  : o.label,
                leaf: o.leaf,
                data: o.data,
                getIcon: __name(
                  () =>
                    r
                      ? r.image
                        ? 'pi pi-image'
                        : 'pi pi-file'
                      : a && a.state === ResourceState.Loading
                        ? 'pi pi-spin pi-spinner'
                        : 'pi pi-folder',
                  'getIcon'
                ),
                getBadgeText: __name(
                  () =>
                    a ? (a.state === ResourceState.Loaded ? null : '') : null,
                  'getBadgeText'
                ),
                children: i,
                draggable: o.leaf,
                handleClick: __name((e, t) => {
                  if (e.leaf) {
                    const e = n.getNodeProvider(r.directory)
                    if (e) {
                      const t = app$1
                        .addNodeOnGraph(e.nodeDef, {
                          pos: app$1.getCanvasCenter()
                        })
                        .widgets.find((t) => t.name === e.key)
                      t && (t.value = r.file_name)
                    }
                  } else s(t, e)
                }, 'handleClick')
              }
            }, 'fillNodeInfo')
          return t(d.value)
        })
      return (
        Vue.watch(
          Vue.toRef(r, 'value'),
          (e) => {
            Object.entries(e).forEach(([e, n]) => {
              if (n) {
                const n = e.split('/').slice(1).join('/')
                n && !n.includes('/') && t.getLoadedModelFolder(n)
              }
            })
          },
          { deep: !0 }
        ),
        Vue.onMounted(async () => {
          o.get('Comfy.ModelLibrary.AutoLoadAll') && (await t.loadModels())
        }),
        (e, n) => {
          const o = Vue.resolveDirective('tooltip')
          return (
            Vue.openBlock(),
            Vue.createElementBlock(
              Vue.Fragment,
              null,
              [
                Vue.createVNode(
                  SidebarTabTemplate,
                  {
                    title: e.$t('sideToolbar.modelLibrary'),
                    class: 'bg-[var(--p-tree-background)]'
                  },
                  {
                    'tool-buttons': Vue.withCtx(() => [
                      Vue.withDirectives(
                        Vue.createVNode(
                          Vue.unref(script$K),
                          {
                            icon: 'pi pi-refresh',
                            onClick: Vue.unref(t).loadModelFolders,
                            severity: 'secondary',
                            text: ''
                          },
                          null,
                          8,
                          ['onClick']
                        ),
                        [[o, e.$t('refresh'), void 0, { bottom: !0 }]]
                      ),
                      Vue.withDirectives(
                        Vue.createVNode(
                          Vue.unref(script$K),
                          {
                            icon: 'pi pi-cloud-download',
                            onClick: Vue.unref(t).loadModels,
                            severity: 'secondary',
                            text: ''
                          },
                          null,
                          8,
                          ['onClick']
                        ),
                        [[o, e.$t('loadAllFolders'), void 0, { bottom: !0 }]]
                      )
                    ]),
                    header: Vue.withCtx(() => [
                      Vue.createVNode(
                        SearchBox,
                        {
                          class: 'model-lib-search-box p-2 2xl:p-4',
                          modelValue: i.value,
                          'onUpdate:modelValue':
                            n[0] || (n[0] = (e) => (i.value = e)),
                          placeholder: e.$t('searchModels') + '...',
                          onSearch: c
                        },
                        null,
                        8,
                        ['modelValue', 'placeholder']
                      )
                    ]),
                    body: Vue.withCtx(() => [
                      Vue.unref(isElectron)()
                        ? (Vue.openBlock(),
                          Vue.createBlock(_sfc_main$k, { key: 0 }))
                        : Vue.createCommentVNode('', !0),
                      Vue.createVNode(
                        TreeExplorer,
                        {
                          class: 'model-lib-tree-explorer',
                          roots: u.value.children,
                          expandedKeys: r.value,
                          'onUpdate:expandedKeys':
                            n[1] || (n[1] = (e) => (r.value = e))
                        },
                        {
                          node: Vue.withCtx(({ node: e }) => [
                            Vue.createVNode(
                              ModelTreeLeaf,
                              { node: e },
                              null,
                              8,
                              ['node']
                            )
                          ]),
                          _: 1
                        },
                        8,
                        ['roots', 'expandedKeys']
                      )
                    ]),
                    _: 1
                  },
                  8,
                  ['title']
                ),
                n[2] ||
                  (n[2] = Vue.createElementVNode(
                    'div',
                    { id: 'model-library-model-preview-container' },
                    null,
                    -1
                  ))
              ],
              64
            )
          )
        }
      )
    }
  }),
  ModelLibrarySidebarTab = _export_sfc(_sfc_main$j, [
    ['__scopeId', 'data-v-827f7782']
  ]),
  useModelLibrarySidebarTab = __name(() => {
    const { t: e } = VueI18n.useI18n()
    return {
      id: 'model-library',
      icon: 'pi pi-box',
      title: e('sideToolbar.modelLibrary'),
      tooltip: e('sideToolbar.modelLibrary'),
      component: Vue.markRaw(ModelLibrarySidebarTab),
      type: 'vue',
      iconBadge: __name(() => {
        if (isElectron()) {
          const e = useElectronDownloadStore()
          if (e.inProgressDownloads.length > 0)
            return e.inProgressDownloads.length.toString()
        }
        return null
      }, 'iconBadge')
    }
  }, 'useModelLibrarySidebarTab')
var FocusTrapStyle = BaseStyle.extend({ name: 'focustrap-directive' }),
  BaseFocusTrap = BaseDirective.extend({ style: FocusTrapStyle })
function _typeof$6(e) {
  return (_typeof$6 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$6(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$6(Object(n), !0).forEach(function (t) {
          _defineProperty$6(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$6(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$6(e, t, n) {
  return (
    (t = _toPropertyKey$6(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$6(e) {
  var t = _toPrimitive$6(e, 'string')
  return 'symbol' == _typeof$6(t) ? t : t + ''
}
function _toPrimitive$6(e, t) {
  if ('object' != _typeof$6(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$6(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$6, '_typeof$6'),
  __name(ownKeys$6, 'ownKeys$6'),
  __name(_objectSpread$6, '_objectSpread$6'),
  __name(_defineProperty$6, '_defineProperty$6'),
  __name(_toPropertyKey$6, '_toPropertyKey$6'),
  __name(_toPrimitive$6, '_toPrimitive$6')
var FocusTrap = BaseFocusTrap.extend('focustrap', {
    mounted: __name(function (e, t) {
      ;(t.value || {}).disabled ||
        (this.createHiddenFocusableElements(e, t),
        this.bind(e, t),
        this.autoElementFocus(e, t)),
        e.setAttribute('data-pd-focustrap', !0),
        (this.$el = e)
    }, 'mounted'),
    updated: __name(function (e, t) {
      ;(t.value || {}).disabled && this.unbind(e)
    }, 'updated'),
    unmounted: __name(function (e) {
      this.unbind(e)
    }, 'unmounted'),
    methods: {
      getComputedSelector: __name(function (e) {
        return ':not(.p-hidden-focusable):not([data-p-hidden-focusable="true"])'.concat(
          null != e ? e : ''
        )
      }, 'getComputedSelector'),
      bind: __name(function (e, t) {
        var n = this,
          o = t.value || {},
          i = o.onFocusIn,
          r = o.onFocusOut
        ;(e.$_pfocustrap_mutationobserver = new MutationObserver(function (t) {
          t.forEach(function (t) {
            if ('childList' === t.type && !e.contains(document.activeElement)) {
              var o = __name(function (t) {
                var i = isFocusableElement(t)
                  ? isFocusableElement(
                      t,
                      n.getComputedSelector(e.$_pfocustrap_focusableselector)
                    )
                    ? t
                    : getFirstFocusableElement(
                        e,
                        n.getComputedSelector(e.$_pfocustrap_focusableselector)
                      )
                  : getFirstFocusableElement(t)
                return isNotEmpty(i) ? i : t.nextSibling && o(t.nextSibling)
              }, 'findNextFocusableElement')
              focus(o(t.nextSibling))
            }
          })
        })),
          e.$_pfocustrap_mutationobserver.disconnect(),
          e.$_pfocustrap_mutationobserver.observe(e, { childList: !0 }),
          (e.$_pfocustrap_focusinlistener = function (e) {
            return i && i(e)
          }),
          (e.$_pfocustrap_focusoutlistener = function (e) {
            return r && r(e)
          }),
          e.addEventListener('focusin', e.$_pfocustrap_focusinlistener),
          e.addEventListener('focusout', e.$_pfocustrap_focusoutlistener)
      }, 'bind'),
      unbind: __name(function (e) {
        e.$_pfocustrap_mutationobserver &&
          e.$_pfocustrap_mutationobserver.disconnect(),
          e.$_pfocustrap_focusinlistener &&
            e.removeEventListener('focusin', e.$_pfocustrap_focusinlistener) &&
            (e.$_pfocustrap_focusinlistener = null),
          e.$_pfocustrap_focusoutlistener &&
            e.removeEventListener(
              'focusout',
              e.$_pfocustrap_focusoutlistener
            ) &&
            (e.$_pfocustrap_focusoutlistener = null)
      }, 'unbind'),
      autoFocus: __name(function (e) {
        this.autoElementFocus(this.$el, {
          value: _objectSpread$6(_objectSpread$6({}, e), {}, { autoFocus: !0 })
        })
      }, 'autoFocus'),
      autoElementFocus: __name(function (e, t) {
        var n = t.value || {},
          o = n.autoFocusSelector,
          i = void 0 === o ? '' : o,
          r = n.firstFocusableSelector,
          a = void 0 === r ? '' : r,
          s = n.autoFocus,
          l = void 0 !== s && s,
          c = getFirstFocusableElement(
            e,
            '[autofocus]'.concat(this.getComputedSelector(i))
          )
        l &&
          !c &&
          (c = getFirstFocusableElement(e, this.getComputedSelector(a))),
          focus(c)
      }, 'autoElementFocus'),
      onFirstHiddenElementFocus: __name(function (e) {
        var t,
          n = e.currentTarget,
          o = e.relatedTarget
        focus(
          o !== n.$_pfocustrap_lasthiddenfocusableelement &&
            null !== (t = this.$el) &&
            void 0 !== t &&
            t.contains(o)
            ? n.$_pfocustrap_lasthiddenfocusableelement
            : getFirstFocusableElement(
                n.parentElement,
                this.getComputedSelector(n.$_pfocustrap_focusableselector)
              )
        )
      }, 'onFirstHiddenElementFocus'),
      onLastHiddenElementFocus: __name(function (e) {
        var t,
          n = e.currentTarget,
          o = e.relatedTarget
        focus(
          o !== n.$_pfocustrap_firsthiddenfocusableelement &&
            null !== (t = this.$el) &&
            void 0 !== t &&
            t.contains(o)
            ? n.$_pfocustrap_firsthiddenfocusableelement
            : getLastFocusableElement(
                n.parentElement,
                this.getComputedSelector(n.$_pfocustrap_focusableselector)
              )
        )
      }, 'onLastHiddenElementFocus'),
      createHiddenFocusableElements: __name(function (e, t) {
        var n = this,
          o = t.value || {},
          i = o.tabIndex,
          r = void 0 === i ? 0 : i,
          a = o.firstFocusableSelector,
          s = void 0 === a ? '' : a,
          l = o.lastFocusableSelector,
          c = void 0 === l ? '' : l,
          d = __name(function (e) {
            return createElement('span', {
              class: 'p-hidden-accessible p-hidden-focusable',
              tabIndex: r,
              role: 'presentation',
              'aria-hidden': !0,
              'data-p-hidden-accessible': !0,
              'data-p-hidden-focusable': !0,
              onFocus: null == e ? void 0 : e.bind(n)
            })
          }, 'createFocusableElement'),
          u = d(this.onFirstHiddenElementFocus),
          p = d(this.onLastHiddenElementFocus)
        ;(u.$_pfocustrap_lasthiddenfocusableelement = p),
          (u.$_pfocustrap_focusableselector = s),
          u.setAttribute('data-pc-section', 'firstfocusableelement'),
          (p.$_pfocustrap_firsthiddenfocusableelement = u),
          (p.$_pfocustrap_focusableselector = c),
          p.setAttribute('data-pc-section', 'lastfocusableelement'),
          e.prepend(u),
          e.append(p)
      }, 'createHiddenFocusableElements')
    }
  }),
  theme$9 = __name(function (e) {
    var t = e.dt
    return '\n.p-popover {\n    margin-block-start: '
      .concat(t('popover.gutter'), ';\n    background: ')
      .concat(t('popover.background'), ';\n    color: ')
      .concat(t('popover.color'), ';\n    border: 1px solid ')
      .concat(t('popover.border.color'), ';\n    border-radius: ')
      .concat(t('popover.border.radius'), ';\n    box-shadow: ')
      .concat(
        t('popover.shadow'),
        ';\n}\n\n.p-popover-content {\n    padding: '
      )
      .concat(
        t('popover.content.padding'),
        ';\n}\n\n.p-popover-flipped {\n    margin-block-start: calc('
      )
      .concat(t('popover.gutter'), ' * -1);\n    margin-block-end: ')
      .concat(
        t('popover.gutter'),
        ';\n}\n\n.p-popover-enter-from {\n    opacity: 0;\n    transform: scaleY(0.8);\n}\n\n.p-popover-leave-to {\n    opacity: 0;\n}\n\n.p-popover-enter-active {\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1), opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-popover-leave-active {\n    transition: opacity 0.1s linear;\n}\n\n.p-popover:after,\n.p-popover:before {\n    bottom: 100%;\n    left: calc('
      )
      .concat(t('popover.arrow.offset'), ' + ')
      .concat(
        t('popover.arrow.left'),
        ');\n    content: " ";\n    height: 0;\n    width: 0;\n    position: absolute;\n    pointer-events: none;\n}\n\n.p-popover:after {\n    border-width: calc('
      )
      .concat(t('popover.gutter'), ' - 2px);\n    margin-left: calc(-1 * (')
      .concat(
        t('popover.gutter'),
        ' - 2px));\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: '
      )
      .concat(
        t('popover.background'),
        ';\n}\n\n.p-popover:before {\n    border-width: '
      )
      .concat(t('popover.gutter'), ';\n    margin-left: calc(-1 * ')
      .concat(
        t('popover.gutter'),
        ');\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: '
      )
      .concat(
        t('popover.border.color'),
        ';\n}\n\n.p-popover-flipped:after,\n.p-popover-flipped:before {\n    bottom: auto;\n    top: 100%;\n}\n\n.p-popover.p-popover-flipped:after {\n    border-bottom-color: transparent;\n    border-top-color: '
      )
      .concat(
        t('popover.background'),
        ';\n}\n\n.p-popover.p-popover-flipped:before {\n    border-bottom-color: transparent;\n    border-top-color: '
      )
      .concat(t('popover.border.color'), ';\n}\n')
  }, 'theme'),
  classes$9 = { root: 'p-popover p-component', content: 'p-popover-content' },
  PopoverStyle = BaseStyle.extend({
    name: 'popover',
    theme: theme$9,
    classes: classes$9
  }),
  script$1$8 = {
    name: 'BasePopover',
    extends: script$Y,
    props: {
      dismissable: { type: Boolean, default: !0 },
      appendTo: { type: [String, Object], default: 'body' },
      baseZIndex: { type: Number, default: 0 },
      autoZIndex: { type: Boolean, default: !0 },
      breakpoints: { type: Object, default: null },
      closeOnEscape: { type: Boolean, default: !0 }
    },
    style: PopoverStyle,
    provide: __name(function () {
      return { $pcPopover: this, $parentInstance: this }
    }, 'provide')
  },
  script$e = {
    name: 'Popover',
    extends: script$1$8,
    inheritAttrs: !1,
    emits: ['show', 'hide'],
    data: __name(function () {
      return { visible: !1 }
    }, 'data'),
    watch: {
      dismissable: {
        immediate: !0,
        handler: __name(function (e) {
          e
            ? this.bindOutsideClickListener()
            : this.unbindOutsideClickListener()
        }, 'handler')
      }
    },
    selfClick: !1,
    target: null,
    eventTarget: null,
    outsideClickListener: null,
    scrollHandler: null,
    resizeListener: null,
    container: null,
    styleElement: null,
    overlayEventListener: null,
    documentKeydownListener: null,
    beforeUnmount: __name(function () {
      this.dismissable && this.unbindOutsideClickListener(),
        this.scrollHandler &&
          (this.scrollHandler.destroy(), (this.scrollHandler = null)),
        this.destroyStyle(),
        this.unbindResizeListener(),
        (this.target = null),
        this.container && this.autoZIndex && ZIndex.clear(this.container),
        this.overlayEventListener &&
          (OverlayEventBus.off('overlay-click', this.overlayEventListener),
          (this.overlayEventListener = null)),
        (this.container = null)
    }, 'beforeUnmount'),
    mounted: __name(function () {
      this.breakpoints && this.createStyle()
    }, 'mounted'),
    methods: {
      toggle: __name(function (e, t) {
        this.visible ? this.hide() : this.show(e, t)
      }, 'toggle'),
      show: __name(function (e, t) {
        ;(this.visible = !0),
          (this.eventTarget = e.currentTarget),
          (this.target = t || e.currentTarget)
      }, 'show'),
      hide: __name(function () {
        this.visible = !1
      }, 'hide'),
      onContentClick: __name(function () {
        this.selfClick = !0
      }, 'onContentClick'),
      onEnter: __name(function (e) {
        var t = this
        addStyle(e, { position: 'absolute', top: '0', left: '0' }),
          this.alignOverlay(),
          this.dismissable && this.bindOutsideClickListener(),
          this.bindScrollListener(),
          this.bindResizeListener(),
          this.autoZIndex &&
            ZIndex.set(
              'overlay',
              e,
              this.baseZIndex + this.$primevue.config.zIndex.overlay
            ),
          (this.overlayEventListener = function (e) {
            t.container.contains(e.target) && (t.selfClick = !0)
          }),
          this.focus(),
          OverlayEventBus.on('overlay-click', this.overlayEventListener),
          this.$emit('show'),
          this.closeOnEscape && this.bindDocumentKeyDownListener()
      }, 'onEnter'),
      onLeave: __name(function () {
        this.unbindOutsideClickListener(),
          this.unbindScrollListener(),
          this.unbindResizeListener(),
          this.unbindDocumentKeyDownListener(),
          OverlayEventBus.off('overlay-click', this.overlayEventListener),
          (this.overlayEventListener = null),
          this.$emit('hide')
      }, 'onLeave'),
      onAfterLeave: __name(function (e) {
        this.autoZIndex && ZIndex.clear(e)
      }, 'onAfterLeave'),
      alignOverlay: __name(function () {
        absolutePosition(this.container, this.target, !1)
        var e = getOffset(this.container),
          t = getOffset(this.target),
          n = 0
        e.left < t.left && (n = t.left - e.left),
          this.container.style.setProperty(
            $dt('popover.arrow.left').name,
            ''.concat(n, 'px')
          ),
          e.top < t.top &&
            (this.container.setAttribute('data-p-popover-flipped', 'true'),
            !this.isUnstyled && addClass(this.container, 'p-popover-flipped'))
      }, 'alignOverlay'),
      onContentKeydown: __name(function (e) {
        'Escape' === e.code &&
          this.closeOnEscape &&
          (this.hide(), focus(this.target))
      }, 'onContentKeydown'),
      onButtonKeydown: __name(function (e) {
        switch (e.code) {
          case 'ArrowDown':
          case 'ArrowUp':
          case 'ArrowLeft':
          case 'ArrowRight':
            e.preventDefault()
        }
      }, 'onButtonKeydown'),
      focus: __name(function () {
        var e = this.container.querySelector('[autofocus]')
        e && e.focus()
      }, 'focus'),
      onKeyDown: __name(function (e) {
        'Escape' === e.code && this.closeOnEscape && (this.visible = !1)
      }, 'onKeyDown'),
      bindDocumentKeyDownListener: __name(function () {
        this.documentKeydownListener ||
          ((this.documentKeydownListener = this.onKeyDown.bind(this)),
          window.document.addEventListener(
            'keydown',
            this.documentKeydownListener
          ))
      }, 'bindDocumentKeyDownListener'),
      unbindDocumentKeyDownListener: __name(function () {
        this.documentKeydownListener &&
          (window.document.removeEventListener(
            'keydown',
            this.documentKeydownListener
          ),
          (this.documentKeydownListener = null))
      }, 'unbindDocumentKeyDownListener'),
      bindOutsideClickListener: __name(function () {
        var e = this
        !this.outsideClickListener &&
          isClient$1() &&
          ((this.outsideClickListener = function (t) {
            !e.visible ||
              e.selfClick ||
              e.isTargetClicked(t) ||
              (e.visible = !1),
              (e.selfClick = !1)
          }),
          document.addEventListener('click', this.outsideClickListener))
      }, 'bindOutsideClickListener'),
      unbindOutsideClickListener: __name(function () {
        this.outsideClickListener &&
          (document.removeEventListener('click', this.outsideClickListener),
          (this.outsideClickListener = null),
          (this.selfClick = !1))
      }, 'unbindOutsideClickListener'),
      bindScrollListener: __name(function () {
        var e = this
        this.scrollHandler ||
          (this.scrollHandler = new ConnectedOverlayScrollHandler(
            this.target,
            function () {
              e.visible && (e.visible = !1)
            }
          )),
          this.scrollHandler.bindScrollListener()
      }, 'bindScrollListener'),
      unbindScrollListener: __name(function () {
        this.scrollHandler && this.scrollHandler.unbindScrollListener()
      }, 'unbindScrollListener'),
      bindResizeListener: __name(function () {
        var e = this
        this.resizeListener ||
          ((this.resizeListener = function () {
            e.visible && !isTouchDevice() && (e.visible = !1)
          }),
          window.addEventListener('resize', this.resizeListener))
      }, 'bindResizeListener'),
      unbindResizeListener: __name(function () {
        this.resizeListener &&
          (window.removeEventListener('resize', this.resizeListener),
          (this.resizeListener = null))
      }, 'unbindResizeListener'),
      isTargetClicked: __name(function (e) {
        return (
          this.eventTarget &&
          (this.eventTarget === e.target || this.eventTarget.contains(e.target))
        )
      }, 'isTargetClicked'),
      containerRef: __name(function (e) {
        this.container = e
      }, 'containerRef'),
      createStyle: __name(function () {
        if (!this.styleElement && !this.isUnstyled) {
          var e
          ;(this.styleElement = document.createElement('style')),
            (this.styleElement.type = 'text/css'),
            setAttribute(
              this.styleElement,
              'nonce',
              null === (e = this.$primevue) ||
                void 0 === e ||
                null === (e = e.config) ||
                void 0 === e ||
                null === (e = e.csp) ||
                void 0 === e
                ? void 0
                : e.nonce
            ),
            document.head.appendChild(this.styleElement)
          var t = ''
          for (var n in this.breakpoints)
            t += '\n                        @media screen and (max-width: '
              .concat(n, ') {\n                            .p-popover[')
              .concat(
                this.$attrSelector,
                '] {\n                                width: '
              )
              .concat(
                this.breakpoints[n],
                ' !important;\n                            }\n                        }\n                    '
              )
          this.styleElement.innerHTML = t
        }
      }, 'createStyle'),
      destroyStyle: __name(function () {
        this.styleElement &&
          (document.head.removeChild(this.styleElement),
          (this.styleElement = null))
      }, 'destroyStyle'),
      onOverlayClick: __name(function (e) {
        OverlayEventBus.emit('overlay-click', {
          originalEvent: e,
          target: this.target
        })
      }, 'onOverlayClick')
    },
    directives: { focustrap: FocusTrap, ripple: Ripple },
    components: { Portal: script$w }
  },
  _hoisted_1$j = ['aria-modal']
function render$d(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('Portal'),
    s = Vue.resolveDirective('focustrap')
  return (
    Vue.openBlock(),
    Vue.createBlock(
      a,
      { appendTo: e.appendTo },
      {
        default: Vue.withCtx(function () {
          return [
            Vue.createVNode(
              Vue.Transition,
              Vue.mergeProps(
                {
                  name: 'p-popover',
                  onEnter: r.onEnter,
                  onLeave: r.onLeave,
                  onAfterLeave: r.onAfterLeave
                },
                e.ptm('transition')
              ),
              {
                default: Vue.withCtx(function () {
                  return [
                    i.visible
                      ? Vue.withDirectives(
                          (Vue.openBlock(),
                          Vue.createElementBlock(
                            'div',
                            Vue.mergeProps(
                              {
                                key: 0,
                                ref: r.containerRef,
                                role: 'dialog',
                                'aria-modal': i.visible,
                                onClick:
                                  t[3] ||
                                  (t[3] = function () {
                                    return (
                                      r.onOverlayClick &&
                                      r.onOverlayClick.apply(r, arguments)
                                    )
                                  }),
                                class: e.cx('root')
                              },
                              e.ptmi('root')
                            ),
                            [
                              e.$slots.container
                                ? Vue.renderSlot(e.$slots, 'container', {
                                    key: 0,
                                    closeCallback: r.hide,
                                    keydownCallback: __name(function (e) {
                                      return r.onButtonKeydown(e)
                                    }, 'keydownCallback')
                                  })
                                : (Vue.openBlock(),
                                  Vue.createElementBlock(
                                    'div',
                                    Vue.mergeProps(
                                      {
                                        key: 1,
                                        class: e.cx('content'),
                                        onClick:
                                          t[0] ||
                                          (t[0] = function () {
                                            return (
                                              r.onContentClick &&
                                              r.onContentClick.apply(
                                                r,
                                                arguments
                                              )
                                            )
                                          }),
                                        onMousedown:
                                          t[1] ||
                                          (t[1] = function () {
                                            return (
                                              r.onContentClick &&
                                              r.onContentClick.apply(
                                                r,
                                                arguments
                                              )
                                            )
                                          }),
                                        onKeydown:
                                          t[2] ||
                                          (t[2] = function () {
                                            return (
                                              r.onContentKeydown &&
                                              r.onContentKeydown.apply(
                                                r,
                                                arguments
                                              )
                                            )
                                          })
                                      },
                                      e.ptm('content')
                                    ),
                                    [Vue.renderSlot(e.$slots, 'default')],
                                    16
                                  ))
                            ],
                            16,
                            _hoisted_1$j
                          )),
                          [[s]]
                        )
                      : Vue.createCommentVNode('', !0)
                  ]
                }),
                _: 3
              },
              16,
              ['onEnter', 'onLeave', 'onAfterLeave']
            )
          ]
        }),
        _: 3
      },
      8,
      ['appendTo']
    )
  )
}
__name(render$d, 'render$d'), (script$e.render = render$d)
const colorPalettes = {
    dark: {
      id: 'dark',
      name: 'Dark (Default)',
      colors: {
        node_slot: {
          CLIP: '#FFD500',
          CLIP_VISION: '#A8DADC',
          CLIP_VISION_OUTPUT: '#ad7452',
          CONDITIONING: '#FFA931',
          CONTROL_NET: '#6EE7B7',
          IMAGE: '#64B5F6',
          LATENT: '#FF9CF9',
          MASK: '#81C784',
          MODEL: '#B39DDB',
          STYLE_MODEL: '#C2FFAE',
          VAE: '#FF6E6E',
          NOISE: '#B0B0B0',
          GUIDER: '#66FFFF',
          SAMPLER: '#ECB4B4',
          SIGMAS: '#CDFFCD',
          TAESD: '#DCC274'
        },
        litegraph_base: {
          BACKGROUND_IMAGE:
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=',
          CLEAR_BACKGROUND_COLOR: '#222',
          NODE_TITLE_COLOR: '#999',
          NODE_SELECTED_TITLE_COLOR: '#FFF',
          NODE_TEXT_SIZE: 14,
          NODE_TEXT_COLOR: '#AAA',
          NODE_SUBTEXT_SIZE: 12,
          NODE_DEFAULT_COLOR: '#333',
          NODE_DEFAULT_BGCOLOR: '#353535',
          NODE_DEFAULT_BOXCOLOR: '#666',
          NODE_DEFAULT_SHAPE: 'box',
          NODE_BOX_OUTLINE_COLOR: '#FFF',
          NODE_BYPASS_BGCOLOR: '#FF00FF',
          NODE_ERROR_COLOUR: '#E00',
          DEFAULT_SHADOW_COLOR: 'rgba(0,0,0,0.5)',
          DEFAULT_GROUP_FONT: 24,
          WIDGET_BGCOLOR: '#222',
          WIDGET_OUTLINE_COLOR: '#666',
          WIDGET_TEXT_COLOR: '#DDD',
          WIDGET_SECONDARY_TEXT_COLOR: '#999',
          LINK_COLOR: '#9A9',
          EVENT_LINK_COLOR: '#A86',
          CONNECTING_LINK_COLOR: '#AFA',
          BADGE_FG_COLOR: '#FFF',
          BADGE_BG_COLOR: '#0F1F0F'
        },
        comfy_base: {
          'fg-color': '#fff',
          'bg-color': '#202020',
          'comfy-menu-bg': '#353535',
          'comfy-input-bg': '#222',
          'input-text': '#ddd',
          'descrip-text': '#999',
          'drag-text': '#ccc',
          'error-text': '#ff4444',
          'border-color': '#4e4e4e',
          'tr-even-bg-color': '#222',
          'tr-odd-bg-color': '#353535',
          'content-bg': '#4e4e4e',
          'content-fg': '#fff',
          'content-hover-bg': '#222',
          'content-hover-fg': '#fff'
        }
      }
    },
    light: {
      id: 'light',
      name: 'Light',
      colors: {
        node_slot: {
          CLIP: '#FFA726',
          CLIP_VISION: '#5C6BC0',
          CLIP_VISION_OUTPUT: '#8D6E63',
          CONDITIONING: '#EF5350',
          CONTROL_NET: '#66BB6A',
          IMAGE: '#42A5F5',
          LATENT: '#AB47BC',
          MASK: '#9CCC65',
          MODEL: '#7E57C2',
          STYLE_MODEL: '#D4E157',
          VAE: '#FF7043'
        },
        litegraph_base: {
          BACKGROUND_IMAGE:
            'data:image/gif;base64,R0lGODlhZABkALMAAAAAAP///+vr6+rq6ujo6Ofn5+bm5uXl5d3d3f///wAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAkALAAAAABkAGQAAAT/UMhJq7046827HkcoHkYxjgZhnGG6si5LqnIM0/fL4qwwIMAg0CAsEovBIxKhRDaNy2GUOX0KfVFrssrNdpdaqTeKBX+dZ+jYvEaTf+y4W66mC8PUdrE879f9d2mBeoNLfH+IhYBbhIx2jkiHiomQlGKPl4uZe3CaeZifnnijgkESBqipqqusra6vsLGys62SlZO4t7qbuby7CLa+wqGWxL3Gv3jByMOkjc2lw8vOoNSi0czAncXW3Njdx9Pf48/Z4Kbbx+fQ5evZ4u3k1fKR6cn03vHlp7T9/v8A/8Gbp4+gwXoFryXMB2qgwoMMHyKEqA5fxX322FG8tzBcRnMW/zlulPbRncmQGidKjMjyYsOSKEF2FBlJQMCbOHP6c9iSZs+UnGYCdbnSo1CZI5F64kn0p1KnTH02nSoV3dGTV7FFHVqVq1dtWcMmVQZTbNGu72zqXMuW7danVL+6e4t1bEy6MeueBYLXrNO5Ze36jQtWsOG97wIj1vt3St/DjTEORss4nNq2mDP3e7w4r1bFkSET5hy6s2TRlD2/mSxXtSHQhCunXo26NevCpmvD/UU6tuullzULH76q92zdZG/Ltv1a+W+osI/nRmyc+fRi1Xdbh+68+0vv10dH3+77KD/i6IdnX669/frn5Zsjh4/2PXju8+8bzc9/6fj27LFnX11/+IUnXWl7BJfegm79FyB9JOl3oHgSklefgxAC+FmFGpqHIYcCfkhgfCohSKKJVo044YUMttggiBkmp6KFXw1oII24oYhjiDByaKOOHcp3Y5BD/njikSkO+eBREQAAOw==',
          CLEAR_BACKGROUND_COLOR: 'lightgray',
          NODE_TITLE_COLOR: '#222',
          NODE_SELECTED_TITLE_COLOR: '#000',
          NODE_TEXT_SIZE: 14,
          NODE_TEXT_COLOR: '#444',
          NODE_SUBTEXT_SIZE: 12,
          NODE_DEFAULT_COLOR: '#F7F7F7',
          NODE_DEFAULT_BGCOLOR: '#F5F5F5',
          NODE_DEFAULT_BOXCOLOR: '#CCC',
          NODE_DEFAULT_SHAPE: 'box',
          NODE_BOX_OUTLINE_COLOR: '#000',
          NODE_BYPASS_BGCOLOR: '#FF00FF',
          NODE_ERROR_COLOUR: '#E00',
          DEFAULT_SHADOW_COLOR: 'rgba(0,0,0,0.1)',
          DEFAULT_GROUP_FONT: 24,
          WIDGET_BGCOLOR: '#D4D4D4',
          WIDGET_OUTLINE_COLOR: '#999',
          WIDGET_TEXT_COLOR: '#222',
          WIDGET_SECONDARY_TEXT_COLOR: '#555',
          LINK_COLOR: '#4CAF50',
          EVENT_LINK_COLOR: '#FF9800',
          CONNECTING_LINK_COLOR: '#2196F3',
          BADGE_FG_COLOR: '#000',
          BADGE_BG_COLOR: '#FFF'
        },
        comfy_base: {
          'fg-color': '#222',
          'bg-color': '#DDD',
          'comfy-menu-bg': '#F5F5F5',
          'comfy-input-bg': '#C9C9C9',
          'input-text': '#222',
          'descrip-text': '#444',
          'drag-text': '#555',
          'error-text': '#F44336',
          'border-color': '#888',
          'tr-even-bg-color': '#f9f9f9',
          'tr-odd-bg-color': '#fff',
          'content-bg': '#e0e0e0',
          'content-fg': '#222',
          'content-hover-bg': '#adadad',
          'content-hover-fg': '#222'
        }
      }
    },
    solarized: {
      id: 'solarized',
      name: 'Solarized',
      colors: {
        node_slot: {
          CLIP: '#2AB7CA',
          CLIP_VISION: '#6c71c4',
          CLIP_VISION_OUTPUT: '#859900',
          CONDITIONING: '#d33682',
          CONTROL_NET: '#d1ffd7',
          IMAGE: '#5940bb',
          LATENT: '#268bd2',
          MASK: '#CCC9E7',
          MODEL: '#dc322f',
          STYLE_MODEL: '#1a998a',
          UPSCALE_MODEL: '#054A29',
          VAE: '#facfad'
        },
        litegraph_base: {
          NODE_TITLE_COLOR: '#fdf6e3',
          NODE_SELECTED_TITLE_COLOR: '#A9D400',
          NODE_TEXT_SIZE: 14,
          NODE_TEXT_COLOR: '#657b83',
          NODE_SUBTEXT_SIZE: 12,
          NODE_DEFAULT_COLOR: '#094656',
          NODE_DEFAULT_BGCOLOR: '#073642',
          NODE_DEFAULT_BOXCOLOR: '#839496',
          NODE_DEFAULT_SHAPE: 'box',
          NODE_BOX_OUTLINE_COLOR: '#fdf6e3',
          NODE_BYPASS_BGCOLOR: '#FF00FF',
          NODE_ERROR_COLOUR: '#E00',
          DEFAULT_SHADOW_COLOR: 'rgba(0,0,0,0.5)',
          DEFAULT_GROUP_FONT: 24,
          WIDGET_BGCOLOR: '#002b36',
          WIDGET_OUTLINE_COLOR: '#839496',
          WIDGET_TEXT_COLOR: '#fdf6e3',
          WIDGET_SECONDARY_TEXT_COLOR: '#93a1a1',
          LINK_COLOR: '#2aa198',
          EVENT_LINK_COLOR: '#268bd2',
          CONNECTING_LINK_COLOR: '#859900'
        },
        comfy_base: {
          'fg-color': '#fdf6e3',
          'bg-color': '#002b36',
          'comfy-menu-bg': '#073642',
          'comfy-input-bg': '#002b36',
          'input-text': '#93a1a1',
          'descrip-text': '#586e75',
          'drag-text': '#839496',
          'error-text': '#dc322f',
          'border-color': '#657b83',
          'tr-even-bg-color': '#002b36',
          'tr-odd-bg-color': '#073642',
          'content-bg': '#657b83',
          'content-fg': '#fdf6e3',
          'content-hover-bg': '#002b36',
          'content-hover-fg': '#fdf6e3'
        }
      }
    },
    arc: {
      id: 'arc',
      name: 'Arc',
      colors: {
        node_slot: {
          BOOLEAN: '',
          CLIP: '#eacb8b',
          CLIP_VISION: '#A8DADC',
          CLIP_VISION_OUTPUT: '#ad7452',
          CONDITIONING: '#cf876f',
          CONTROL_NET: '#00d78d',
          CONTROL_NET_WEIGHTS: '',
          FLOAT: '',
          GLIGEN: '',
          IMAGE: '#80a1c0',
          IMAGEUPLOAD: '',
          INT: '',
          LATENT: '#b38ead',
          LATENT_KEYFRAME: '',
          MASK: '#a3bd8d',
          MODEL: '#8978a7',
          SAMPLER: '',
          SIGMAS: '',
          STRING: '',
          STYLE_MODEL: '#C2FFAE',
          T2I_ADAPTER_WEIGHTS: '',
          TAESD: '#DCC274',
          TIMESTEP_KEYFRAME: '',
          UPSCALE_MODEL: '',
          VAE: '#be616b'
        },
        litegraph_base: {
          BACKGROUND_IMAGE:
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcklEQVR4nO3YMUoDARgF4RfxBqZI6/0vZqFn0MYtrLIQMFN8U6V4LAtD+Jm9XG/v30OGl2e/AP7yevz4+vx45nvgF/+QGITEICQGITEIiUFIjNNC3q43u3/YnRJyPOzeQ+0e220nhRzReC8e7R7bbdvl+Jal1Bs46jEIiUFIDEJiEBKDkBhKPbZT6qHdptRTu02p53DUYxASg5AYhMQgJAYhMZR6bKfUQ7tNqad2m1LP4ajHICQGITEIiUFIDEJiKPXYTqmHdptST+02pZ7DUY9BSAxCYhASg5AYhMRQ6rGdUg/tNqWe2m1KPYejHoOQGITEICQGITEIiaHUYzulHtptSj2125R6Dkc9BiExCIlBSAxCYhASQ6nHdko9tNuUemq3KfUcjnoMQmIQEoOQGITEICSGUo/tlHpotyn11G5T6jkc9RiExCAkBiExCIlBSAylHtsp9dBuU+qp3abUczjqMQiJQUgMQmIQEoOQGITE+AHFISNQrFTGuwAAAABJRU5ErkJggg==',
          CLEAR_BACKGROUND_COLOR: '#2b2f38',
          NODE_TITLE_COLOR: '#b2b7bd',
          NODE_SELECTED_TITLE_COLOR: '#FFF',
          NODE_TEXT_SIZE: 14,
          NODE_TEXT_COLOR: '#AAA',
          NODE_SUBTEXT_SIZE: 12,
          NODE_DEFAULT_COLOR: '#2b2f38',
          NODE_DEFAULT_BGCOLOR: '#242730',
          NODE_DEFAULT_BOXCOLOR: '#6e7581',
          NODE_DEFAULT_SHAPE: 'box',
          NODE_BOX_OUTLINE_COLOR: '#FFF',
          NODE_BYPASS_BGCOLOR: '#FF00FF',
          NODE_ERROR_COLOUR: '#E00',
          DEFAULT_SHADOW_COLOR: 'rgba(0,0,0,0.5)',
          DEFAULT_GROUP_FONT: 22,
          WIDGET_BGCOLOR: '#2b2f38',
          WIDGET_OUTLINE_COLOR: '#6e7581',
          WIDGET_TEXT_COLOR: '#DDD',
          WIDGET_SECONDARY_TEXT_COLOR: '#b2b7bd',
          LINK_COLOR: '#9A9',
          EVENT_LINK_COLOR: '#A86',
          CONNECTING_LINK_COLOR: '#AFA'
        },
        comfy_base: {
          'fg-color': '#fff',
          'bg-color': '#2b2f38',
          'comfy-menu-bg': '#242730',
          'comfy-input-bg': '#2b2f38',
          'input-text': '#ddd',
          'descrip-text': '#b2b7bd',
          'drag-text': '#ccc',
          'error-text': '#ff4444',
          'border-color': '#6e7581',
          'tr-even-bg-color': '#2b2f38',
          'tr-odd-bg-color': '#242730',
          'content-bg': '#6e7581',
          'content-fg': '#fff',
          'content-hover-bg': '#2b2f38',
          'content-hover-fg': '#fff'
        }
      }
    },
    nord: {
      id: 'nord',
      name: 'Nord',
      colors: {
        node_slot: {
          BOOLEAN: '',
          CLIP: '#eacb8b',
          CLIP_VISION: '#A8DADC',
          CLIP_VISION_OUTPUT: '#ad7452',
          CONDITIONING: '#cf876f',
          CONTROL_NET: '#00d78d',
          CONTROL_NET_WEIGHTS: '',
          FLOAT: '',
          GLIGEN: '',
          IMAGE: '#80a1c0',
          IMAGEUPLOAD: '',
          INT: '',
          LATENT: '#b38ead',
          LATENT_KEYFRAME: '',
          MASK: '#a3bd8d',
          MODEL: '#8978a7',
          SAMPLER: '',
          SIGMAS: '',
          STRING: '',
          STYLE_MODEL: '#C2FFAE',
          T2I_ADAPTER_WEIGHTS: '',
          TAESD: '#DCC274',
          TIMESTEP_KEYFRAME: '',
          UPSCALE_MODEL: '',
          VAE: '#be616b'
        },
        litegraph_base: {
          BACKGROUND_IMAGE:
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFu2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyMy0xMS0xM1QwMDoxODowMiswMTowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjMtMTEtMTVUMDE6MjA6NDUrMDE6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjMtMTEtMTVUMDE6MjA6NDUrMDE6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjUwNDFhMmZjLTEzNzQtMTk0ZC1hZWY4LTYxMzM1MTVmNjUwMCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyMzFiMTBiMC1iNGZiLTAyNGUtYjEyZS0zMDUzMDNjZDA3YzgiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoyMzFiMTBiMC1iNGZiLTAyNGUtYjEyZS0zMDUzMDNjZDA3YzgiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjIzMWIxMGIwLWI0ZmItMDI0ZS1iMTJlLTMwNTMwM2NkMDdjOCIgc3RFdnQ6d2hlbj0iMjAyMy0xMS0xM1QwMDoxODowMiswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo1MDQxYTJmYy0xMzc0LTE5NGQtYWVmOC02MTMzNTE1ZjY1MDAiIHN0RXZ0OndoZW49IjIwMjMtMTEtMTVUMDE6MjA6NDUrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNS4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz73jWg/AAAAyUlEQVR42u3WKwoAIBRFQRdiMb1idv9Lsxn9gEFw4Dbb8JCTojbbXEJwjJVL2HKwYMGCBQuWLbDmjr+9zrBGjHl1WVcvy2DBggULFizTWQpewSt4HzwsgwULFiwFr7MUvMtS8D54WLBgGSxYCl7BK3iXZbBgwYIFC5bpLAWv4BW8Dx6WwYIFC5aC11kK3mUpeB88LFiwDBYsBa/gFbzLMliwYMGCBct0loJX8AreBw/LYMGCBUvB6ywF77IUvA8eFixYBgsWrNfWAZPltufdad+1AAAAAElFTkSuQmCC',
          CLEAR_BACKGROUND_COLOR: '#212732',
          NODE_TITLE_COLOR: '#999',
          NODE_SELECTED_TITLE_COLOR: '#e5eaf0',
          NODE_TEXT_SIZE: 14,
          NODE_TEXT_COLOR: '#bcc2c8',
          NODE_SUBTEXT_SIZE: 12,
          NODE_DEFAULT_COLOR: '#2e3440',
          NODE_DEFAULT_BGCOLOR: '#161b22',
          NODE_DEFAULT_BOXCOLOR: '#545d70',
          NODE_DEFAULT_SHAPE: 'box',
          NODE_BOX_OUTLINE_COLOR: '#e5eaf0',
          NODE_BYPASS_BGCOLOR: '#FF00FF',
          NODE_ERROR_COLOUR: '#E00',
          DEFAULT_SHADOW_COLOR: 'rgba(0,0,0,0.5)',
          DEFAULT_GROUP_FONT: 24,
          WIDGET_BGCOLOR: '#2e3440',
          WIDGET_OUTLINE_COLOR: '#545d70',
          WIDGET_TEXT_COLOR: '#bcc2c8',
          WIDGET_SECONDARY_TEXT_COLOR: '#999',
          LINK_COLOR: '#9A9',
          EVENT_LINK_COLOR: '#A86',
          CONNECTING_LINK_COLOR: '#AFA'
        },
        comfy_base: {
          'fg-color': '#e5eaf0',
          'bg-color': '#2e3440',
          'comfy-menu-bg': '#161b22',
          'comfy-input-bg': '#2e3440',
          'input-text': '#bcc2c8',
          'descrip-text': '#999',
          'drag-text': '#ccc',
          'error-text': '#ff4444',
          'border-color': '#545d70',
          'tr-even-bg-color': '#2e3440',
          'tr-odd-bg-color': '#161b22',
          'content-bg': '#545d70',
          'content-fg': '#e5eaf0',
          'content-hover-bg': '#2e3440',
          'content-hover-fg': '#e5eaf0'
        }
      }
    },
    github: {
      id: 'github',
      name: 'Github',
      colors: {
        node_slot: {
          BOOLEAN: '',
          CLIP: '#eacb8b',
          CLIP_VISION: '#A8DADC',
          CLIP_VISION_OUTPUT: '#ad7452',
          CONDITIONING: '#cf876f',
          CONTROL_NET: '#00d78d',
          CONTROL_NET_WEIGHTS: '',
          FLOAT: '',
          GLIGEN: '',
          IMAGE: '#80a1c0',
          IMAGEUPLOAD: '',
          INT: '',
          LATENT: '#b38ead',
          LATENT_KEYFRAME: '',
          MASK: '#a3bd8d',
          MODEL: '#8978a7',
          SAMPLER: '',
          SIGMAS: '',
          STRING: '',
          STYLE_MODEL: '#C2FFAE',
          T2I_ADAPTER_WEIGHTS: '',
          TAESD: '#DCC274',
          TIMESTEP_KEYFRAME: '',
          UPSCALE_MODEL: '',
          VAE: '#be616b'
        },
        litegraph_base: {
          BACKGROUND_IMAGE:
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGlmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyMy0xMS0xM1QwMDoxODowMiswMTowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjMtMTEtMTVUMDI6MDQ6NTkrMDE6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjMtMTEtMTVUMDI6MDQ6NTkrMDE6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmIyYzRhNjA5LWJmYTctYTg0MC1iOGFlLTk3MzE2ZjM1ZGIyNyIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjk0ZmNlZGU4LTE1MTctZmQ0MC04ZGU3LWYzOTgxM2E3ODk5ZiIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjIzMWIxMGIwLWI0ZmItMDI0ZS1iMTJlLTMwNTMwM2NkMDdjOCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MjMxYjEwYjAtYjRmYi0wMjRlLWIxMmUtMzA1MzAzY2QwN2M4IiBzdEV2dDp3aGVuPSIyMDIzLTExLTEzVDAwOjE4OjAyKzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjUuMSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ4OWY1NzlmLTJkNjUtZWQ0Zi04OTg0LTA4NGE2MGE1ZTMzNSIgc3RFdnQ6d2hlbj0iMjAyMy0xMS0xNVQwMjowNDo1OSswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiMmM0YTYwOS1iZmE3LWE4NDAtYjhhZS05NzMxNmYzNWRiMjciIHN0RXZ0OndoZW49IjIwMjMtMTEtMTVUMDI6MDQ6NTkrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNS4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4OTe6GAAAAx0lEQVR42u3WMQoAIQxFwRzJys77X8vSLiRgITif7bYbgrwYc/mKXyBoY4VVBgsWLFiwYFmOlTv+9jfDOjHmr8u6eVkGCxYsWLBgmc5S8ApewXvgYRksWLBgKXidpeBdloL3wMOCBctgwVLwCl7BuyyDBQsWLFiwTGcpeAWv4D3wsAwWLFiwFLzOUvAuS8F74GHBgmWwYCl4Ba/gXZbBggULFixYprMUvIJX8B54WAYLFixYCl5nKXiXpeA98LBgwTJYsGC9tg1o8f4TTtqzNQAAAABJRU5ErkJggg==',
          CLEAR_BACKGROUND_COLOR: '#040506',
          NODE_TITLE_COLOR: '#999',
          NODE_SELECTED_TITLE_COLOR: '#e5eaf0',
          NODE_TEXT_SIZE: 14,
          NODE_TEXT_COLOR: '#bcc2c8',
          NODE_SUBTEXT_SIZE: 12,
          NODE_DEFAULT_COLOR: '#161b22',
          NODE_DEFAULT_BGCOLOR: '#13171d',
          NODE_DEFAULT_BOXCOLOR: '#30363d',
          NODE_DEFAULT_SHAPE: 'box',
          NODE_BOX_OUTLINE_COLOR: '#e5eaf0',
          NODE_BYPASS_BGCOLOR: '#FF00FF',
          NODE_ERROR_COLOUR: '#E00',
          DEFAULT_SHADOW_COLOR: 'rgba(0,0,0,0.5)',
          DEFAULT_GROUP_FONT: 24,
          WIDGET_BGCOLOR: '#161b22',
          WIDGET_OUTLINE_COLOR: '#30363d',
          WIDGET_TEXT_COLOR: '#bcc2c8',
          WIDGET_SECONDARY_TEXT_COLOR: '#999',
          LINK_COLOR: '#9A9',
          EVENT_LINK_COLOR: '#A86',
          CONNECTING_LINK_COLOR: '#AFA'
        },
        comfy_base: {
          'fg-color': '#e5eaf0',
          'bg-color': '#161b22',
          'comfy-menu-bg': '#13171d',
          'comfy-input-bg': '#161b22',
          'input-text': '#bcc2c8',
          'descrip-text': '#999',
          'drag-text': '#ccc',
          'error-text': '#ff4444',
          'border-color': '#30363d',
          'tr-even-bg-color': '#161b22',
          'tr-odd-bg-color': '#13171d',
          'content-bg': '#30363d',
          'content-fg': '#e5eaf0',
          'content-hover-bg': '#161b22',
          'content-hover-fg': '#e5eaf0'
        }
      }
    }
  },
  id = 'Comfy.ColorPalette',
  idCustomColorPalettes = 'Comfy.CustomColorPalettes',
  defaultColorPaletteId = 'dark',
  els = { select: null },
  getCustomColorPalettes = __name(
    () => app$1.ui.settings.getSettingValue(idCustomColorPalettes, {}),
    'getCustomColorPalettes'
  ),
  setCustomColorPalettes = __name(
    (e) => app$1.ui.settings.setSettingValue(idCustomColorPalettes, e),
    'setCustomColorPalettes'
  ),
  defaultColorPalette = colorPalettes[defaultColorPaletteId],
  getColorPalette = __name((e) => {
    if (
      (e || (e = app$1.ui.settings.getSettingValue(id, defaultColorPaletteId)),
      e.startsWith('custom_'))
    ) {
      e = e.substr(7)
      let t = getCustomColorPalettes()
      if (t[e]) return t[e]
    }
    return colorPalettes[e]
  }, 'getColorPalette'),
  setColorPalette = __name((e) => {
    app$1.ui.settings.setSettingValue(id, e)
  }, 'setColorPalette')
app$1.registerExtension({
  name: id,
  init() {
    LGraphCanvas.prototype.updateBackground = function (e, t) {
      ;(this._bg_img = new Image()),
        (this._bg_img.name = e),
        (this._bg_img.src = e),
        (this._bg_img.onload = () => {
          this.draw(!0, !0)
        }),
        (this.background_image = e),
        (this.clear_background = !0),
        (this.clear_background_color = t),
        (this._pattern = null)
    }
  },
  addCustomNodeDefs(e) {
    const t = __name(
      (e) =>
        Object.keys(e)
          .sort()
          .reduce((t, n) => ((t[n] = e[n]), t), {}),
      'sortObjectKeys'
    )
    function n() {
      var t = []
      const n = e
      for (const e in n) {
        const i = n[e]
        var o = i.input.required
        void 0 !== i.input.optional &&
          (o = Object.assign({}, i.input.required, i.input.optional))
        for (const e in o) {
          const n = o[e][0]
          Array.isArray(n) || t.push(n)
        }
        for (const e in i.output) {
          const n = i.output[e]
          t.push(n)
        }
      }
      return t
    }
    function o(e) {
      var o = n()
      for (const t of o) e.colors.node_slot[t] || (e.colors.node_slot[t] = '')
      return (e.colors.node_slot = t(e.colors.node_slot)), e
    }
    __name(n, 'getSlotTypes'), __name(o, 'completeColorPalette')
    const i = __name(async () => {
        let e = {
          id: 'my_color_palette_unique_id',
          name: 'My Color Palette',
          colors: { node_slot: {}, litegraph_base: {}, comfy_base: {} }
        }
        const t = colorPalettes[defaultColorPaletteId]
        for (const n in t.colors.litegraph_base)
          e.colors.litegraph_base[n] || (e.colors.litegraph_base[n] = '')
        for (const n in t.colors.comfy_base)
          e.colors.comfy_base[n] || (e.colors.comfy_base[n] = '')
        return o(e)
      }, 'getColorPaletteTemplate'),
      r = __name(async (e) => {
        if ('object' != typeof e)
          return void useToastStore().addAlert('Invalid color palette.')
        if (!e.id)
          return void useToastStore().addAlert('Color palette missing id.')
        if (!e.name)
          return void useToastStore().addAlert('Color palette missing name.')
        if (!e.colors)
          return void useToastStore().addAlert('Color palette missing colors.')
        if (e.colors.node_slot && 'object' != typeof e.colors.node_slot)
          return void useToastStore().addAlert(
            'Invalid color palette colors.node_slot.'
          )
        const t = getCustomColorPalettes()
        ;(t[e.id] = e), setCustomColorPalettes(t)
        for (const n of els.select.childNodes)
          n.value === 'custom_' + e.id && els.select.removeChild(n)
        els.select.append(
          $el('option', {
            textContent: e.name + ' (custom)',
            value: 'custom_' + e.id,
            selected: !0
          })
        ),
          setColorPalette('custom_' + e.id),
          await s(e)
      }, 'addCustomColorPalette'),
      a = __name(async (e) => {
        const t = getCustomColorPalettes()
        delete t[e], setCustomColorPalettes(t)
        for (const n of els.select.childNodes) {
          const t = n
          t.value === defaultColorPaletteId && (t.selected = !0),
            t.value === 'custom_' + e && els.select.removeChild(t)
        }
        setColorPalette(defaultColorPaletteId), await s(getColorPalette())
      }, 'deleteCustomColorPalette'),
      s = __name(async (e) => {
        if ((e = await o(e)).colors) {
          if (
            (e.colors.node_slot &&
              (Object.assign(
                app$1.canvas.default_connection_color_byType,
                e.colors.node_slot
              ),
              Object.assign(LGraphCanvas.link_type_colors, e.colors.node_slot)),
            e.colors.litegraph_base)
          ) {
            ;(app$1.canvas.node_title_color =
              e.colors.litegraph_base.NODE_TITLE_COLOR),
              (app$1.canvas.default_link_color =
                e.colors.litegraph_base.LINK_COLOR)
            for (const t in e.colors.litegraph_base)
              e.colors.litegraph_base.hasOwnProperty(t) &&
                LiteGraph.hasOwnProperty(t) &&
                (LiteGraph[t] = e.colors.litegraph_base[t])
          }
          if (e.colors.comfy_base) {
            const t = document.documentElement.style
            for (const n in e.colors.comfy_base)
              t.setProperty('--' + n, e.colors.comfy_base[n])
          }
          e.colors.litegraph_base.NODE_BYPASS_BGCOLOR &&
            (app$1.bypassBgColor = e.colors.litegraph_base.NODE_BYPASS_BGCOLOR),
            app$1.canvas.draw(!0, !0)
        }
      }, 'loadColorPalette'),
      l = $el('input', {
        type: 'file',
        accept: '.json',
        style: { display: 'none' },
        parent: document.body,
        onchange: __name(() => {
          const e = l.files[0]
          if ('application/json' === e.type || e.name.endsWith('.json')) {
            const t = new FileReader()
            ;(t.onload = async () => {
              await r(JSON.parse(t.result))
            }),
              t.readAsText(e)
          }
        }, 'onchange')
      })
    app$1.ui.settings.addSetting({
      id: id,
      category: ['Appearance', 'ColorPalette'],
      name: 'Color Palette',
      type: __name((e, t, n) => {
        const r = [
          ...Object.values(colorPalettes).map((e) =>
            $el('option', {
              textContent: e.name,
              value: e.id,
              selected: e.id === n
            })
          ),
          ...Object.values(getCustomColorPalettes()).map((e) =>
            $el('option', {
              textContent: `${e.name} (custom)`,
              value: `custom_${e.id}`,
              selected: `custom_${e.id}` === n
            })
          )
        ]
        return (
          (els.select = $el(
            'select',
            {
              style: { marginBottom: '0.15rem', width: '100%' },
              onchange: __name((e) => {
                t(e.target.value)
              }, 'onchange')
            },
            r
          )),
          $el('tr', [
            $el('td', [
              els.select,
              $el(
                'div',
                {
                  style: { display: 'grid', gap: '4px', gridAutoFlow: 'column' }
                },
                [
                  $el('input', {
                    type: 'button',
                    value: 'Export',
                    onclick: __name(async () => {
                      const e = app$1.ui.settings.getSettingValue(
                          id,
                          defaultColorPaletteId
                        ),
                        t = await o(getColorPalette(e)),
                        n = JSON.stringify(t, null, 2),
                        i = new Blob([n], { type: 'application/json' }),
                        r = URL.createObjectURL(i),
                        a = $el('a', {
                          href: r,
                          download: e + '.json',
                          style: { display: 'none' },
                          parent: document.body
                        })
                      a.click(),
                        setTimeout(function () {
                          a.remove(), window.URL.revokeObjectURL(r)
                        }, 0)
                    }, 'onclick')
                  }),
                  $el('input', {
                    type: 'button',
                    value: 'Import',
                    onclick: __name(() => {
                      l.click()
                    }, 'onclick')
                  }),
                  $el('input', {
                    type: 'button',
                    value: 'Template',
                    onclick: __name(async () => {
                      const e = await i(),
                        t = JSON.stringify(e, null, 2),
                        n = new Blob([t], { type: 'application/json' }),
                        o = URL.createObjectURL(n),
                        r = $el('a', {
                          href: o,
                          download: 'color_palette.json',
                          style: { display: 'none' },
                          parent: document.body
                        })
                      r.click(),
                        setTimeout(function () {
                          r.remove(), window.URL.revokeObjectURL(o)
                        }, 0)
                    }, 'onclick')
                  }),
                  $el('input', {
                    type: 'button',
                    value: 'Delete',
                    onclick: __name(async () => {
                      let e = app$1.ui.settings.getSettingValue(
                        id,
                        defaultColorPaletteId
                      )
                      colorPalettes[e]
                        ? useToastStore().addAlert(
                            'You cannot delete a built-in color palette.'
                          )
                        : (e.startsWith('custom_') && (e = e.substr(7)),
                          await a(e))
                    }, 'onclick')
                  })
                ]
              )
            ])
          ])
        )
      }, 'type'),
      defaultValue: defaultColorPaletteId,
      async onChange(e) {
        if (!e) return
        let t = colorPalettes[e]
        if (t) await s(t)
        else if (e.startsWith('custom_')) {
          e = e.substr(7)
          let n = getCustomColorPalettes()
          n[e] && ((t = n[e]), await s(n[e]))
        }
        let { BACKGROUND_IMAGE: n, CLEAR_BACKGROUND_COLOR: o } =
          t.colors.litegraph_base
        if (void 0 === n || void 0 === o) {
          const e = colorPalettes.dark.colors.litegraph_base
          ;(n = e.BACKGROUND_IMAGE), (o = e.CLEAR_BACKGROUND_COLOR)
        }
        app$1.canvas.updateBackground(n, o)
      }
    })
  }
}),
  (window.comfyAPI = window.comfyAPI || {}),
  (window.comfyAPI.colorPalette = window.comfyAPI.colorPalette || {}),
  (window.comfyAPI.colorPalette.defaultColorPalette = defaultColorPalette),
  (window.comfyAPI.colorPalette.getColorPalette = getColorPalette)
const _hoisted_1$i = { class: '_sb_node_preview' },
  _hoisted_2$b = { class: '_sb_table' },
  _hoisted_3$7 = { class: '_sb_col' },
  _hoisted_4$5 = { class: '_sb_col' },
  _hoisted_5$4 = { class: '_sb_col' },
  _sfc_main$i = Vue.defineComponent({
    __name: 'NodePreview',
    props: { nodeDef: { type: ComfyNodeDefImpl, required: !0 } },
    setup(e) {
      const t = e,
        n = getColorPalette()?.colors?.litegraph_base,
        o = n ?? defaultColorPalette.colors.litegraph_base,
        i = useWidgetStore(),
        r = t.nodeDef,
        a = r.inputs.all,
        s = r.outputs.all,
        l = a.filter((e) => !i.inputIsWidget(e)),
        c = a.filter((e) => i.inputIsWidget(e)),
        d = __name((e, t = 32) => {
          let n
          return (
            (n =
              ('object' == typeof e && null !== e) || Array.isArray(e)
                ? JSON.stringify(e)
                : 'string' == typeof e
                  ? e
                  : String(e)),
            _.truncate(n, { length: t })
          )
        }, 'truncateDefaultValue')
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock('div', _hoisted_1$i, [
          Vue.createElementVNode('div', _hoisted_2$b, [
            Vue.createElementVNode(
              'div',
              {
                class: 'node_header',
                style: Vue.normalizeStyle({
                  backgroundColor: Vue.unref(o).NODE_DEFAULT_COLOR,
                  color: Vue.unref(o).NODE_TITLE_COLOR
                })
              },
              [
                t[0] ||
                  (t[0] = Vue.createElementVNode(
                    'div',
                    { class: '_sb_dot headdot' },
                    null,
                    -1
                  )),
                Vue.createTextVNode(
                  ' ' + Vue.toDisplayString(Vue.unref(r).display_name),
                  1
                )
              ],
              4
            ),
            t[5] ||
              (t[5] = Vue.createElementVNode(
                'div',
                { class: '_sb_preview_badge' },
                'PREVIEW',
                -1
              )),
            (Vue.openBlock(!0),
            Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(
                Vue.unref(_).zip(Vue.unref(l), Vue.unref(s)),
                ([e, n]) => (
                  Vue.openBlock(),
                  Vue.createElementBlock(
                    'div',
                    {
                      class: '_sb_row slot_row',
                      key: (e?.name || '') + (n?.index.toString() || '')
                    },
                    [
                      Vue.createElementVNode('div', _hoisted_3$7, [
                        e
                          ? (Vue.openBlock(),
                            Vue.createElementBlock(
                              'div',
                              {
                                key: 0,
                                class: Vue.normalizeClass(['_sb_dot', e.type])
                              },
                              null,
                              2
                            ))
                          : Vue.createCommentVNode('', !0)
                      ]),
                      Vue.createElementVNode(
                        'div',
                        _hoisted_4$5,
                        Vue.toDisplayString(e ? e.name : ''),
                        1
                      ),
                      t[1] ||
                        (t[1] = Vue.createElementVNode(
                          'div',
                          { class: '_sb_col middle-column' },
                          null,
                          -1
                        )),
                      Vue.createElementVNode(
                        'div',
                        {
                          class: '_sb_col _sb_inherit',
                          style: Vue.normalizeStyle({
                            color: Vue.unref(o).NODE_TEXT_COLOR
                          })
                        },
                        Vue.toDisplayString(n ? n.name : ''),
                        5
                      ),
                      Vue.createElementVNode('div', _hoisted_5$4, [
                        n
                          ? (Vue.openBlock(),
                            Vue.createElementBlock(
                              'div',
                              {
                                key: 0,
                                class: Vue.normalizeClass(['_sb_dot', n.type])
                              },
                              null,
                              2
                            ))
                          : Vue.createCommentVNode('', !0)
                      ])
                    ]
                  )
                )
              ),
              128
            )),
            (Vue.openBlock(!0),
            Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(
                Vue.unref(c),
                (e) => (
                  Vue.openBlock(),
                  Vue.createElementBlock(
                    'div',
                    { class: '_sb_row _long_field', key: e.name },
                    [
                      t[2] ||
                        (t[2] = Vue.createElementVNode(
                          'div',
                          { class: '_sb_col _sb_arrow' },
                          '◀',
                          -1
                        )),
                      Vue.createElementVNode(
                        'div',
                        {
                          class: '_sb_col',
                          style: Vue.normalizeStyle({
                            color: Vue.unref(o).WIDGET_SECONDARY_TEXT_COLOR
                          })
                        },
                        Vue.toDisplayString(e.name),
                        5
                      ),
                      t[3] ||
                        (t[3] = Vue.createElementVNode(
                          'div',
                          { class: '_sb_col middle-column' },
                          null,
                          -1
                        )),
                      Vue.createElementVNode(
                        'div',
                        {
                          class: '_sb_col _sb_inherit',
                          style: Vue.normalizeStyle({
                            color: Vue.unref(o).WIDGET_TEXT_COLOR
                          })
                        },
                        Vue.toDisplayString(d(e.default)),
                        5
                      ),
                      t[4] ||
                        (t[4] = Vue.createElementVNode(
                          'div',
                          { class: '_sb_col _sb_arrow' },
                          '▶',
                          -1
                        ))
                    ]
                  )
                )
              ),
              128
            ))
          ]),
          Vue.unref(r).description
            ? (Vue.openBlock(),
              Vue.createElementBlock(
                'div',
                {
                  key: 0,
                  class: '_sb_description',
                  style: Vue.normalizeStyle({
                    color: Vue.unref(o).WIDGET_SECONDARY_TEXT_COLOR,
                    backgroundColor: Vue.unref(o).WIDGET_BGCOLOR
                  })
                },
                Vue.toDisplayString(Vue.unref(r).description),
                5
              ))
            : Vue.createCommentVNode('', !0)
        ])
      )
    }
  }),
  NodePreview = _export_sfc(_sfc_main$i, [['__scopeId', 'data-v-e86c3783']]),
  BOOKMARK_SETTING_ID = 'Comfy.NodeLibrary.Bookmarks.V2',
  useNodeBookmarkStore = defineStore('nodeBookmark', () => {
    const e = useSettingStore(),
      t = useNodeDefStore(),
      n = Vue.computed(() => e.get(BOOKMARK_SETTING_ID)),
      o = Vue.computed(() => new Set(n.value)),
      i = Vue.computed(() => s(n.value)),
      r = __name(
        (e) => o.value.has(e.nodePath) || o.value.has(e.name),
        'isBookmarked'
      ),
      a = __name((e) => {
        r(e) ? (c(e.nodePath), c(e.name)) : l(e.name)
      }, 'toggleBookmark'),
      s = __name(
        (e) =>
          buildNodeDefTree(
            e
              .map((e) => {
                if (e.endsWith('/')) return createDummyFolderNodeDef(e)
                const n = e.split('/'),
                  o = n.pop() ?? '',
                  i = n.join('/'),
                  r = t.nodeDefsByName[o]
                if (!r) return null
                const a = _.clone(r)
                return (a.category = i), a
              })
              .filter((e) => null !== e)
          ),
        'buildBookmarkTree'
      ),
      l = __name((t) => {
        e.set(BOOKMARK_SETTING_ID, [...n.value, t])
      }, 'addBookmark'),
      c = __name((t) => {
        e.set(
          BOOKMARK_SETTING_ID,
          n.value.filter((e) => e !== t)
        )
      }, 'deleteBookmark'),
      d = __name((e) => {
        const t = e ? e.nodePath : ''
        let o = t + 'New Folder/',
          i = 1
        for (; n.value.some((e) => e.startsWith(o)); )
          (o = t + `New Folder ${i}/`), i++
        return l(o), o
      }, 'addNewBookmarkFolder'),
      u = __name((t, o) => {
        if (!t.isDummyFolder) throw new Error('Cannot rename non-folder node')
        if (o.includes('/')) throw new Error('Folder name cannot contain "/"')
        const i = t.category.split('/').slice(0, -1).concat(o).join('/') + '/'
        if (i !== t.nodePath) {
          if (n.value.some((e) => e.startsWith(i)))
            throw new Error(`Folder name "${i}" already exists`)
          e.set(
            BOOKMARK_SETTING_ID,
            n.value.map((e) =>
              e.startsWith(t.nodePath) ? e.replace(t.nodePath, i) : e
            )
          ),
            g(t.nodePath, i)
        }
      }, 'renameBookmarkFolder'),
      p = __name((t) => {
        if (!t.isDummyFolder) throw new Error('Cannot delete non-folder node')
        e.set(
          BOOKMARK_SETTING_ID,
          n.value.filter((e) => e !== t.nodePath && !e.startsWith(t.nodePath))
        ),
          f(t.nodePath)
      }, 'deleteBookmarkFolder'),
      h = Vue.computed(() => e.get('Comfy.NodeLibrary.BookmarksCustomization')),
      m = __name((t, n) => {
        const o = { ...(h.value[t] || {}), ...n }
        o.icon === v && delete o.icon,
          o.color === y && delete o.color,
          0 === Object.keys(o).length
            ? f(t)
            : e.set('Comfy.NodeLibrary.BookmarksCustomization', {
                ...h.value,
                [t]: o
              })
      }, 'updateBookmarkCustomization'),
      f = __name((t) => {
        e.set('Comfy.NodeLibrary.BookmarksCustomization', {
          ...h.value,
          [t]: void 0
        })
      }, 'deleteBookmarkCustomization'),
      g = __name((t, n) => {
        const o = { ...h.value }
        o[t] && ((o[n] = o[t]), delete o[t]),
          e.set('Comfy.NodeLibrary.BookmarksCustomization', o)
      }, 'renameBookmarkCustomization'),
      v = 'pi-bookmark-fill',
      y = '#a1a1aa'
    return {
      bookmarks: n,
      bookmarkedRoot: i,
      isBookmarked: r,
      toggleBookmark: a,
      addBookmark: l,
      addNewBookmarkFolder: d,
      renameBookmarkFolder: u,
      deleteBookmarkFolder: p,
      bookmarksCustomization: h,
      updateBookmarkCustomization: m,
      deleteBookmarkCustomization: f,
      renameBookmarkCustomization: g,
      defaultBookmarkIcon: v,
      defaultBookmarkColor: y
    }
  }),
  _sfc_main$h = Vue.defineComponent({
    __name: 'NodeTreeLeaf',
    props: { node: {} },
    emits: ['toggle-bookmark'],
    setup(e, { emit: t }) {
      const n = e,
        o = Vue.computed(() => n.node.data),
        i = useNodeBookmarkStore(),
        r = Vue.computed(() => i.isBookmarked(o.value)),
        a = useSettingStore(),
        s = Vue.computed(() => a.get('Comfy.Sidebar.Location')),
        l = __name(() => {
          i.toggleBookmark(o.value)
        }, 'toggleBookmark'),
        c = Vue.ref(null),
        d = Vue.ref({ position: 'absolute', top: '0px', left: '0px' }),
        u = __name(async () => {
          const e = h.value.getBoundingClientRect(),
            t = c.value?.$el.offsetHeight || 0,
            n = window.innerHeight - e.bottom
          ;(d.value.top =
            t > n
              ? `${Math.max(0, e.top - (t - n) - 20)}px`
              : e.top - 40 + 'px'),
            'left' === s.value
              ? (d.value.left = `${e.right}px`)
              : (d.value.left = e.left - 400 + 'px')
        }, 'handleNodeHover'),
        p = Vue.ref(null),
        h = Vue.ref(null),
        m = Vue.ref(!1),
        f = __name(async () => {
          ;(m.value = !0), await Vue.nextTick(), u()
        }, 'handleMouseEnter'),
        _ = __name(() => {
          m.value = !1
        }, 'handleMouseLeave')
      return (
        Vue.onMounted(() => {
          ;(h.value = p.value?.closest('.p-tree-node-content')),
            h.value?.addEventListener('mouseenter', f),
            h.value?.addEventListener('mouseleave', _)
        }),
        Vue.onUnmounted(() => {
          h.value?.removeEventListener('mouseenter', f),
            h.value?.removeEventListener('mouseleave', _)
        }),
        (e, t) => (
          Vue.openBlock(),
          Vue.createElementBlock(
            'div',
            { ref_key: 'container', ref: p, class: 'node-lib-node-container' },
            [
              Vue.createVNode(
                TreeExplorerTreeNode,
                { node: e.node },
                {
                  'before-label': Vue.withCtx(() => [
                    o.value.experimental
                      ? (Vue.openBlock(),
                        Vue.createBlock(
                          Vue.unref(script$C),
                          {
                            key: 0,
                            value: e.$t('experimental'),
                            severity: 'primary'
                          },
                          null,
                          8,
                          ['value']
                        ))
                      : Vue.createCommentVNode('', !0),
                    o.value.deprecated
                      ? (Vue.openBlock(),
                        Vue.createBlock(
                          Vue.unref(script$C),
                          {
                            key: 1,
                            value: e.$t('deprecated'),
                            severity: 'danger'
                          },
                          null,
                          8,
                          ['value']
                        ))
                      : Vue.createCommentVNode('', !0)
                  ]),
                  actions: Vue.withCtx(() => [
                    Vue.createVNode(
                      Vue.unref(script$K),
                      {
                        class: 'bookmark-button',
                        size: 'small',
                        icon: r.value
                          ? 'pi pi-bookmark-fill'
                          : 'pi pi-bookmark',
                        text: '',
                        severity: 'secondary',
                        onClick: Vue.withModifiers(l, ['stop'])
                      },
                      null,
                      8,
                      ['icon']
                    )
                  ]),
                  _: 1
                },
                8,
                ['node']
              ),
              m.value
                ? (Vue.openBlock(),
                  Vue.createBlock(
                    Vue.Teleport,
                    { key: 0, to: '#node-library-node-preview-container' },
                    [
                      Vue.createElementVNode(
                        'div',
                        {
                          class: 'node-lib-node-preview',
                          style: Vue.normalizeStyle(d.value)
                        },
                        [
                          Vue.createVNode(
                            NodePreview,
                            { ref_key: 'previewRef', ref: c, nodeDef: o.value },
                            null,
                            8,
                            ['nodeDef']
                          )
                        ],
                        4
                      )
                    ]
                  ))
                : Vue.createCommentVNode('', !0)
            ],
            512
          )
        )
      )
    }
  }),
  NodeTreeLeaf = _export_sfc(_sfc_main$h, [['__scopeId', 'data-v-90dfee08']]),
  _sfc_main$g = Vue.defineComponent({
    __name: 'NodeTreeFolder',
    props: { node: {} },
    setup(e) {
      const t = e,
        n = useNodeBookmarkStore(),
        o = Vue.computed(() => n.bookmarksCustomization[t.node.data.nodePath]),
        i = Vue.ref(null),
        r = Vue.ref(null)
      let a = null
      const s = Vue.ref(null)
      Vue.onMounted(() => {
        ;(i.value = s.value?.closest('.p-tree-node-content')),
          (r.value = i.value.querySelector(':scope > .p-tree-node-icon')),
          l(),
          (a = Vue.watch(o, l, { deep: !0 }))
      })
      const l = __name(() => {
        r.value && o.value && (r.value.style.color = o.value.color)
      }, 'updateIconColor')
      Vue.onUnmounted(() => {
        a && a()
      })
      const c = Vue.inject('expandedKeys'),
        d = __name((e) => {
          c.value[e.key] = !0
        }, 'handleItemDrop')
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock(
          'div',
          { ref_key: 'container', ref: s, class: 'node-lib-node-container' },
          [
            Vue.createVNode(
              TreeExplorerTreeNode,
              { node: e.node, onItemDropped: d },
              null,
              8,
              ['node']
            )
          ],
          512
        )
      )
    }
  })
var script$d = { name: 'WindowMaximizeIcon', extends: script$X }
function render$c(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              'fill-rule': 'evenodd',
              'clip-rule': 'evenodd',
              d: 'M7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14ZM9.77805 7.42192C9.89013 7.534 10.0415 7.59788 10.2 7.59995C10.3585 7.59788 10.5099 7.534 10.622 7.42192C10.7341 7.30985 10.798 7.15844 10.8 6.99995V3.94242C10.8066 3.90505 10.8096 3.86689 10.8089 3.82843C10.8079 3.77159 10.7988 3.7157 10.7824 3.6623C10.756 3.55552 10.701 3.45698 10.622 3.37798C10.5099 3.2659 10.3585 3.20202 10.2 3.19995H7.00002C6.84089 3.19995 6.68828 3.26317 6.57576 3.37569C6.46324 3.48821 6.40002 3.64082 6.40002 3.79995C6.40002 3.95908 6.46324 4.11169 6.57576 4.22422C6.68828 4.33674 6.84089 4.39995 7.00002 4.39995H8.80006L6.19997 7.00005C6.10158 7.11005 6.04718 7.25246 6.04718 7.40005C6.04718 7.54763 6.10158 7.69004 6.19997 7.80005C6.30202 7.91645 6.44561 7.98824 6.59997 8.00005C6.75432 7.98824 6.89791 7.91645 6.99997 7.80005L9.60002 5.26841V6.99995C9.6021 7.15844 9.66598 7.30985 9.77805 7.42192ZM1.4 14H3.8C4.17066 13.9979 4.52553 13.8498 4.78763 13.5877C5.04973 13.3256 5.1979 12.9707 5.2 12.6V10.2C5.1979 9.82939 5.04973 9.47452 4.78763 9.21242C4.52553 8.95032 4.17066 8.80215 3.8 8.80005H1.4C1.02934 8.80215 0.674468 8.95032 0.412371 9.21242C0.150274 9.47452 0.00210008 9.82939 0 10.2V12.6C0.00210008 12.9707 0.150274 13.3256 0.412371 13.5877C0.674468 13.8498 1.02934 13.9979 1.4 14ZM1.25858 10.0586C1.29609 10.0211 1.34696 10 1.4 10H3.8C3.85304 10 3.90391 10.0211 3.94142 10.0586C3.97893 10.0961 4 10.147 4 10.2V12.6C4 12.6531 3.97893 12.704 3.94142 12.7415C3.90391 12.779 3.85304 12.8 3.8 12.8H1.4C1.34696 12.8 1.29609 12.779 1.25858 12.7415C1.22107 12.704 1.2 12.6531 1.2 12.6V10.2C1.2 10.147 1.22107 10.0961 1.25858 10.0586Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$c, 'render$c'), (script$d.render = render$c)
var script$c = { name: 'WindowMinimizeIcon', extends: script$X }
function render$b(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              'fill-rule': 'evenodd',
              'clip-rule': 'evenodd',
              d: 'M11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0ZM6.368 7.952C6.44137 7.98326 6.52025 7.99958 6.6 8H9.8C9.95913 8 10.1117 7.93678 10.2243 7.82426C10.3368 7.71174 10.4 7.55913 10.4 7.4C10.4 7.24087 10.3368 7.08826 10.2243 6.97574C10.1117 6.86321 9.95913 6.8 9.8 6.8H8.048L10.624 4.224C10.73 4.11026 10.7877 3.95982 10.7849 3.80438C10.7822 3.64894 10.7192 3.50063 10.6093 3.3907C10.4994 3.28077 10.3511 3.2178 10.1956 3.21506C10.0402 3.21232 9.88974 3.27002 9.776 3.376L7.2 5.952V4.2C7.2 4.04087 7.13679 3.88826 7.02426 3.77574C6.91174 3.66321 6.75913 3.6 6.6 3.6C6.44087 3.6 6.28826 3.66321 6.17574 3.77574C6.06321 3.88826 6 4.04087 6 4.2V7.4C6.00042 7.47975 6.01674 7.55862 6.048 7.632C6.07656 7.70442 6.11971 7.7702 6.17475 7.82524C6.2298 7.88029 6.29558 7.92344 6.368 7.952ZM1.4 8.80005H3.8C4.17066 8.80215 4.52553 8.95032 4.78763 9.21242C5.04973 9.47452 5.1979 9.82939 5.2 10.2V12.6C5.1979 12.9707 5.04973 13.3256 4.78763 13.5877C4.52553 13.8498 4.17066 13.9979 3.8 14H1.4C1.02934 13.9979 0.674468 13.8498 0.412371 13.5877C0.150274 13.3256 0.00210008 12.9707 0 12.6V10.2C0.00210008 9.82939 0.150274 9.47452 0.412371 9.21242C0.674468 8.95032 1.02934 8.80215 1.4 8.80005ZM3.94142 12.7415C3.97893 12.704 4 12.6531 4 12.6V10.2C4 10.147 3.97893 10.0961 3.94142 10.0586C3.90391 10.0211 3.85304 10 3.8 10H1.4C1.34696 10 1.29609 10.0211 1.25858 10.0586C1.22107 10.0961 1.2 10.147 1.2 10.2V12.6C1.2 12.6531 1.22107 12.704 1.25858 12.7415C1.29609 12.779 1.34696 12.8 1.4 12.8H3.8C3.85304 12.8 3.90391 12.779 3.94142 12.7415Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$b, 'render$b'), (script$c.render = render$b)
var theme$8 = __name(function (e) {
    var t = e.dt
    return '\n.p-dialog {\n    max-height: 90%;\n    transform: scale(1);\n    border-radius: '
      .concat(t('dialog.border.radius'), ';\n    box-shadow: ')
      .concat(t('dialog.shadow'), ';\n    background: ')
      .concat(t('dialog.background'), ';\n    border: 1px solid ')
      .concat(t('dialog.border.color'), ';\n    color: ')
      .concat(
        t('dialog.color'),
        ';\n}\n\n.p-dialog-content {\n    overflow-y: auto;\n    padding: '
      )
      .concat(
        t('dialog.content.padding'),
        ';\n}\n\n.p-dialog-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    flex-shrink: 0;\n    padding: '
      )
      .concat(
        t('dialog.header.padding'),
        ';\n}\n\n.p-dialog-title {\n    font-weight: '
      )
      .concat(t('dialog.title.font.weight'), ';\n    font-size: ')
      .concat(
        t('dialog.title.font.size'),
        ';\n}\n\n.p-dialog-footer {\n    flex-shrink: 0;\n    padding: '
      )
      .concat(
        t('dialog.footer.padding'),
        ';\n    display: flex;\n    justify-content: flex-end;\n    gap: '
      )
      .concat(
        t('dialog.footer.gap'),
        ';\n}\n\n.p-dialog-header-actions {\n    display: flex;\n    align-items: center;\n    gap: '
      )
      .concat(
        t('dialog.header.gap'),
        ';\n}\n\n.p-dialog-enter-active {\n    transition: all 150ms cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-dialog-leave-active {\n    transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.p-dialog-enter-from,\n.p-dialog-leave-to {\n    opacity: 0;\n    transform: scale(0.7);\n}\n\n.p-dialog-top .p-dialog,\n.p-dialog-bottom .p-dialog,\n.p-dialog-left .p-dialog,\n.p-dialog-right .p-dialog,\n.p-dialog-topleft .p-dialog,\n.p-dialog-topright .p-dialog,\n.p-dialog-bottomleft .p-dialog,\n.p-dialog-bottomright .p-dialog {\n    margin: 0.75rem;\n    transform: translate3d(0px, 0px, 0px);\n}\n\n.p-dialog-top .p-dialog-enter-active,\n.p-dialog-top .p-dialog-leave-active,\n.p-dialog-bottom .p-dialog-enter-active,\n.p-dialog-bottom .p-dialog-leave-active,\n.p-dialog-left .p-dialog-enter-active,\n.p-dialog-left .p-dialog-leave-active,\n.p-dialog-right .p-dialog-enter-active,\n.p-dialog-right .p-dialog-leave-active,\n.p-dialog-topleft .p-dialog-enter-active,\n.p-dialog-topleft .p-dialog-leave-active,\n.p-dialog-topright .p-dialog-enter-active,\n.p-dialog-topright .p-dialog-leave-active,\n.p-dialog-bottomleft .p-dialog-enter-active,\n.p-dialog-bottomleft .p-dialog-leave-active,\n.p-dialog-bottomright .p-dialog-enter-active,\n.p-dialog-bottomright .p-dialog-leave-active {\n    transition: all 0.3s ease-out;\n}\n\n.p-dialog-top .p-dialog-enter-from,\n.p-dialog-top .p-dialog-leave-to {\n    transform: translate3d(0px, -100%, 0px);\n}\n\n.p-dialog-bottom .p-dialog-enter-from,\n.p-dialog-bottom .p-dialog-leave-to {\n    transform: translate3d(0px, 100%, 0px);\n}\n\n.p-dialog-left .p-dialog-enter-from,\n.p-dialog-left .p-dialog-leave-to,\n.p-dialog-topleft .p-dialog-enter-from,\n.p-dialog-topleft .p-dialog-leave-to,\n.p-dialog-bottomleft .p-dialog-enter-from,\n.p-dialog-bottomleft .p-dialog-leave-to {\n    transform: translate3d(-100%, 0px, 0px);\n}\n\n.p-dialog-right .p-dialog-enter-from,\n.p-dialog-right .p-dialog-leave-to,\n.p-dialog-topright .p-dialog-enter-from,\n.p-dialog-topright .p-dialog-leave-to,\n.p-dialog-bottomright .p-dialog-enter-from,\n.p-dialog-bottomright .p-dialog-leave-to {\n    transform: translate3d(100%, 0px, 0px);\n}\n\n.p-dialog-left:dir(rtl) .p-dialog-enter-from,\n.p-dialog-left:dir(rtl) .p-dialog-leave-to,\n.p-dialog-topleft:dir(rtl) .p-dialog-enter-from,\n.p-dialog-topleft:dir(rtl) .p-dialog-leave-to,\n.p-dialog-bottomleft:dir(rtl) .p-dialog-enter-from,\n.p-dialog-bottomleft:dir(rtl) .p-dialog-leave-to {\n    transform: translate3d(100%, 0px, 0px);\n}\n\n.p-dialog-right:dir(rtl) .p-dialog-enter-from,\n.p-dialog-right:dir(rtl) .p-dialog-leave-to,\n.p-dialog-topright:dir(rtl) .p-dialog-enter-from,\n.p-dialog-topright:dir(rtl) .p-dialog-leave-to,\n.p-dialog-bottomright:dir(rtl) .p-dialog-enter-from,\n.p-dialog-bottomright:dir(rtl) .p-dialog-leave-to {\n    transform: translate3d(-100%, 0px, 0px);\n}\n\n.p-dialog-maximized {\n    width: 100vw !important;\n    height: 100vh !important;\n    top: 0px !important;\n    left: 0px !important;\n    max-height: 100%;\n    height: 100%;\n    border-radius: 0;\n}\n\n.p-dialog-maximized .p-dialog-content {\n    flex-grow: 1;\n}\n'
      )
  }, 'theme'),
  inlineStyles = {
    mask: __name(function (e) {
      var t = e.position
      return {
        position: 'fixed',
        height: '100%',
        width: '100%',
        left: 0,
        top: 0,
        display: 'flex',
        justifyContent:
          'left' === t || 'topleft' === t || 'bottomleft' === t
            ? 'flex-start'
            : 'right' === t || 'topright' === t || 'bottomright' === t
              ? 'flex-end'
              : 'center',
        alignItems:
          'top' === t || 'topleft' === t || 'topright' === t
            ? 'flex-start'
            : 'bottom' === t || 'bottomleft' === t || 'bottomright' === t
              ? 'flex-end'
              : 'center',
        pointerEvents: e.modal ? 'auto' : 'none'
      }
    }, 'mask'),
    root: { display: 'flex', flexDirection: 'column', pointerEvents: 'auto' }
  },
  classes$8 = {
    mask: __name(function (e) {
      var t = e.props,
        n = [
          'left',
          'right',
          'top',
          'topleft',
          'topright',
          'bottom',
          'bottomleft',
          'bottomright'
        ].find(function (e) {
          return e === t.position
        })
      return [
        'p-dialog-mask',
        { 'p-overlay-mask p-overlay-mask-enter': t.modal },
        n ? 'p-dialog-'.concat(n) : ''
      ]
    }, 'mask'),
    root: __name(function (e) {
      var t = e.props,
        n = e.instance
      return [
        'p-dialog p-component',
        { 'p-dialog-maximized': t.maximizable && n.maximized }
      ]
    }, 'root'),
    header: 'p-dialog-header',
    title: 'p-dialog-title',
    headerActions: 'p-dialog-header-actions',
    pcMaximizeButton: 'p-dialog-maximize-button',
    pcCloseButton: 'p-dialog-close-button',
    content: 'p-dialog-content',
    footer: 'p-dialog-footer'
  },
  DialogStyle = BaseStyle.extend({
    name: 'dialog',
    theme: theme$8,
    classes: classes$8,
    inlineStyles: inlineStyles
  }),
  script$1$7 = {
    name: 'BaseDialog',
    extends: script$Y,
    props: {
      header: { type: null, default: null },
      footer: { type: null, default: null },
      visible: { type: Boolean, default: !1 },
      modal: { type: Boolean, default: null },
      contentStyle: { type: null, default: null },
      contentClass: { type: String, default: null },
      contentProps: { type: null, default: null },
      maximizable: { type: Boolean, default: !1 },
      dismissableMask: { type: Boolean, default: !1 },
      closable: { type: Boolean, default: !0 },
      closeOnEscape: { type: Boolean, default: !0 },
      showHeader: { type: Boolean, default: !0 },
      blockScroll: { type: Boolean, default: !1 },
      baseZIndex: { type: Number, default: 0 },
      autoZIndex: { type: Boolean, default: !0 },
      position: { type: String, default: 'center' },
      breakpoints: { type: Object, default: null },
      draggable: { type: Boolean, default: !0 },
      keepInViewport: { type: Boolean, default: !0 },
      minX: { type: Number, default: 0 },
      minY: { type: Number, default: 0 },
      appendTo: { type: [String, Object], default: 'body' },
      closeIcon: { type: String, default: void 0 },
      maximizeIcon: { type: String, default: void 0 },
      minimizeIcon: { type: String, default: void 0 },
      closeButtonProps: {
        type: Object,
        default: __name(function () {
          return { severity: 'secondary', text: !0, rounded: !0 }
        }, '_default')
      },
      maximizeButtonProps: {
        type: Object,
        default: __name(function () {
          return { severity: 'secondary', text: !0, rounded: !0 }
        }, '_default')
      },
      _instance: null
    },
    style: DialogStyle,
    provide: __name(function () {
      return { $pcDialog: this, $parentInstance: this }
    }, 'provide')
  },
  script$b = {
    name: 'Dialog',
    extends: script$1$7,
    inheritAttrs: !1,
    emits: [
      'update:visible',
      'show',
      'hide',
      'after-hide',
      'maximize',
      'unmaximize',
      'dragstart',
      'dragend'
    ],
    provide: __name(function () {
      var e = this
      return {
        dialogRef: Vue.computed(function () {
          return e._instance
        })
      }
    }, 'provide'),
    data: __name(function () {
      return {
        id: this.$attrs.id,
        containerVisible: this.visible,
        maximized: !1,
        focusableMax: null,
        focusableClose: null,
        target: null
      }
    }, 'data'),
    watch: {
      '$attrs.id': __name(function (e) {
        this.id = e || UniqueComponentId()
      }, '$attrsId')
    },
    documentKeydownListener: null,
    container: null,
    mask: null,
    content: null,
    headerContainer: null,
    footerContainer: null,
    maximizableButton: null,
    closeButton: null,
    styleElement: null,
    dragging: null,
    documentDragListener: null,
    documentDragEndListener: null,
    lastPageX: null,
    lastPageY: null,
    maskMouseDownTarget: null,
    updated: __name(function () {
      this.visible && (this.containerVisible = this.visible)
    }, 'updated'),
    beforeUnmount: __name(function () {
      this.unbindDocumentState(),
        this.unbindGlobalListeners(),
        this.destroyStyle(),
        this.mask && this.autoZIndex && ZIndex.clear(this.mask),
        (this.container = null),
        (this.mask = null)
    }, 'beforeUnmount'),
    mounted: __name(function () {
      ;(this.id = this.id || UniqueComponentId()),
        this.breakpoints && this.createStyle()
    }, 'mounted'),
    methods: {
      close: __name(function () {
        this.$emit('update:visible', !1)
      }, 'close'),
      onEnter: __name(function () {
        this.$emit('show'),
          (this.target = document.activeElement),
          this.enableDocumentSettings(),
          this.bindGlobalListeners(),
          this.autoZIndex &&
            ZIndex.set(
              'modal',
              this.mask,
              this.baseZIndex + this.$primevue.config.zIndex.modal
            )
      }, 'onEnter'),
      onAfterEnter: __name(function () {
        this.focus()
      }, 'onAfterEnter'),
      onBeforeLeave: __name(function () {
        this.modal &&
          !this.isUnstyled &&
          addClass(this.mask, 'p-overlay-mask-leave'),
          this.dragging &&
            this.documentDragEndListener &&
            this.documentDragEndListener()
      }, 'onBeforeLeave'),
      onLeave: __name(function () {
        this.$emit('hide'),
          focus(this.target),
          (this.target = null),
          (this.focusableClose = null),
          (this.focusableMax = null)
      }, 'onLeave'),
      onAfterLeave: __name(function () {
        this.autoZIndex && ZIndex.clear(this.mask),
          (this.containerVisible = !1),
          this.unbindDocumentState(),
          this.unbindGlobalListeners(),
          this.$emit('after-hide')
      }, 'onAfterLeave'),
      onMaskMouseDown: __name(function (e) {
        this.maskMouseDownTarget = e.target
      }, 'onMaskMouseDown'),
      onMaskMouseUp: __name(function () {
        this.dismissableMask &&
          this.modal &&
          this.mask === this.maskMouseDownTarget &&
          this.close()
      }, 'onMaskMouseUp'),
      focus: __name(function () {
        var e = __name(function (e) {
            return e && e.querySelector('[autofocus]')
          }, 'findFocusableElement'),
          t = this.$slots.footer && e(this.footerContainer)
        t ||
          (t = this.$slots.header && e(this.headerContainer)) ||
          (t = this.$slots.default && e(this.content)) ||
          (this.maximizable
            ? ((this.focusableMax = !0), (t = this.maximizableButton))
            : ((this.focusableClose = !0), (t = this.closeButton))),
          t && focus(t, { focusVisible: !0 })
      }, 'focus$1'),
      maximize: __name(function (e) {
        this.maximized
          ? ((this.maximized = !1), this.$emit('unmaximize', e))
          : ((this.maximized = !0), this.$emit('maximize', e)),
          this.modal ||
            (this.maximized ? blockBodyScroll() : unblockBodyScroll())
      }, 'maximize'),
      enableDocumentSettings: __name(function () {
        ;(this.modal ||
          (!this.modal && this.blockScroll) ||
          (this.maximizable && this.maximized)) &&
          blockBodyScroll()
      }, 'enableDocumentSettings'),
      unbindDocumentState: __name(function () {
        ;(this.modal ||
          (!this.modal && this.blockScroll) ||
          (this.maximizable && this.maximized)) &&
          unblockBodyScroll()
      }, 'unbindDocumentState'),
      onKeyDown: __name(function (e) {
        'Escape' === e.code && this.closeOnEscape && this.close()
      }, 'onKeyDown'),
      bindDocumentKeyDownListener: __name(function () {
        this.documentKeydownListener ||
          ((this.documentKeydownListener = this.onKeyDown.bind(this)),
          window.document.addEventListener(
            'keydown',
            this.documentKeydownListener
          ))
      }, 'bindDocumentKeyDownListener'),
      unbindDocumentKeyDownListener: __name(function () {
        this.documentKeydownListener &&
          (window.document.removeEventListener(
            'keydown',
            this.documentKeydownListener
          ),
          (this.documentKeydownListener = null))
      }, 'unbindDocumentKeyDownListener'),
      containerRef: __name(function (e) {
        this.container = e
      }, 'containerRef'),
      maskRef: __name(function (e) {
        this.mask = e
      }, 'maskRef'),
      contentRef: __name(function (e) {
        this.content = e
      }, 'contentRef'),
      headerContainerRef: __name(function (e) {
        this.headerContainer = e
      }, 'headerContainerRef'),
      footerContainerRef: __name(function (e) {
        this.footerContainer = e
      }, 'footerContainerRef'),
      maximizableRef: __name(function (e) {
        this.maximizableButton = e ? e.$el : void 0
      }, 'maximizableRef'),
      closeButtonRef: __name(function (e) {
        this.closeButton = e ? e.$el : void 0
      }, 'closeButtonRef'),
      createStyle: __name(function () {
        if (!this.styleElement && !this.isUnstyled) {
          var e
          ;(this.styleElement = document.createElement('style')),
            (this.styleElement.type = 'text/css'),
            setAttribute(
              this.styleElement,
              'nonce',
              null === (e = this.$primevue) ||
                void 0 === e ||
                null === (e = e.config) ||
                void 0 === e ||
                null === (e = e.csp) ||
                void 0 === e
                ? void 0
                : e.nonce
            ),
            document.head.appendChild(this.styleElement)
          var t = ''
          for (var n in this.breakpoints)
            t += '\n                        @media screen and (max-width: '
              .concat(n, ') {\n                            .p-dialog[')
              .concat(
                this.$attrSelector,
                '] {\n                                width: '
              )
              .concat(
                this.breakpoints[n],
                ' !important;\n                            }\n                        }\n                    '
              )
          this.styleElement.innerHTML = t
        }
      }, 'createStyle'),
      destroyStyle: __name(function () {
        this.styleElement &&
          (document.head.removeChild(this.styleElement),
          (this.styleElement = null))
      }, 'destroyStyle'),
      initDrag: __name(function (e) {
        'headeractions' !==
          e.target.closest('div').getAttribute('data-pc-section') &&
          this.draggable &&
          ((this.dragging = !0),
          (this.lastPageX = e.pageX),
          (this.lastPageY = e.pageY),
          (this.container.style.margin = '0'),
          document.body.setAttribute('data-p-unselectable-text', 'true'),
          !this.isUnstyled &&
            addStyle(document.body, { 'user-select': 'none' }),
          this.$emit('dragstart', e))
      }, 'initDrag'),
      bindGlobalListeners: __name(function () {
        this.draggable &&
          (this.bindDocumentDragListener(), this.bindDocumentDragEndListener()),
          this.closeOnEscape &&
            this.closable &&
            this.bindDocumentKeyDownListener()
      }, 'bindGlobalListeners'),
      unbindGlobalListeners: __name(function () {
        this.unbindDocumentDragListener(),
          this.unbindDocumentDragEndListener(),
          this.unbindDocumentKeyDownListener()
      }, 'unbindGlobalListeners'),
      bindDocumentDragListener: __name(function () {
        var e = this
        ;(this.documentDragListener = function (t) {
          if (e.dragging) {
            var n = getOuterWidth(e.container),
              o = getOuterHeight(e.container),
              i = t.pageX - e.lastPageX,
              r = t.pageY - e.lastPageY,
              a = e.container.getBoundingClientRect(),
              s = a.left + i,
              l = a.top + r,
              c = getViewport(),
              d = getComputedStyle(e.container),
              u = parseFloat(d.marginLeft),
              p = parseFloat(d.marginTop)
            ;(e.container.style.position = 'fixed'),
              e.keepInViewport
                ? (s >= e.minX &&
                    s + n < c.width &&
                    ((e.lastPageX = t.pageX),
                    (e.container.style.left = s - u + 'px')),
                  l >= e.minY &&
                    l + o < c.height &&
                    ((e.lastPageY = t.pageY),
                    (e.container.style.top = l - p + 'px')))
                : ((e.lastPageX = t.pageX),
                  (e.container.style.left = s - u + 'px'),
                  (e.lastPageY = t.pageY),
                  (e.container.style.top = l - p + 'px'))
          }
        }),
          window.document.addEventListener(
            'mousemove',
            this.documentDragListener
          )
      }, 'bindDocumentDragListener'),
      unbindDocumentDragListener: __name(function () {
        this.documentDragListener &&
          (window.document.removeEventListener(
            'mousemove',
            this.documentDragListener
          ),
          (this.documentDragListener = null))
      }, 'unbindDocumentDragListener'),
      bindDocumentDragEndListener: __name(function () {
        var e = this
        ;(this.documentDragEndListener = function (t) {
          e.dragging &&
            ((e.dragging = !1),
            document.body.removeAttribute('data-p-unselectable-text'),
            !e.isUnstyled && (document.body.style['user-select'] = ''),
            e.$emit('dragend', t))
        }),
          window.document.addEventListener(
            'mouseup',
            this.documentDragEndListener
          )
      }, 'bindDocumentDragEndListener'),
      unbindDocumentDragEndListener: __name(function () {
        this.documentDragEndListener &&
          (window.document.removeEventListener(
            'mouseup',
            this.documentDragEndListener
          ),
          (this.documentDragEndListener = null))
      }, 'unbindDocumentDragEndListener')
    },
    computed: {
      maximizeIconComponent: __name(function () {
        return this.maximized
          ? this.minimizeIcon
            ? 'span'
            : 'WindowMinimizeIcon'
          : this.maximizeIcon
            ? 'span'
            : 'WindowMaximizeIcon'
      }, 'maximizeIconComponent'),
      ariaLabelledById: __name(function () {
        return null != this.header || null !== this.$attrs['aria-labelledby']
          ? this.id + '_header'
          : null
      }, 'ariaLabelledById'),
      closeAriaLabel: __name(function () {
        return this.$primevue.config.locale.aria
          ? this.$primevue.config.locale.aria.close
          : void 0
      }, 'closeAriaLabel')
    },
    directives: { ripple: Ripple, focustrap: FocusTrap },
    components: {
      Button: script$K,
      Portal: script$w,
      WindowMinimizeIcon: script$c,
      WindowMaximizeIcon: script$d,
      TimesIcon: script$x
    }
  }
function _typeof$5(e) {
  return (_typeof$5 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$5(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$5(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$5(Object(n), !0).forEach(function (t) {
          _defineProperty$5(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$5(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$5(e, t, n) {
  return (
    (t = _toPropertyKey$5(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$5(e) {
  var t = _toPrimitive$5(e, 'string')
  return 'symbol' == _typeof$5(t) ? t : t + ''
}
function _toPrimitive$5(e, t) {
  if ('object' != _typeof$5(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$5(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$5, '_typeof$5'),
  __name(ownKeys$5, 'ownKeys$5'),
  __name(_objectSpread$5, '_objectSpread$5'),
  __name(_defineProperty$5, '_defineProperty$5'),
  __name(_toPropertyKey$5, '_toPropertyKey$5'),
  __name(_toPrimitive$5, '_toPrimitive$5')
var _hoisted_1$h = ['aria-labelledby', 'aria-modal'],
  _hoisted_2$a = ['id']
function render$a(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('Button'),
    s = Vue.resolveComponent('Portal'),
    l = Vue.resolveDirective('focustrap')
  return (
    Vue.openBlock(),
    Vue.createBlock(
      s,
      { appendTo: e.appendTo },
      {
        default: Vue.withCtx(function () {
          return [
            i.containerVisible
              ? (Vue.openBlock(),
                Vue.createElementBlock(
                  'div',
                  Vue.mergeProps(
                    {
                      key: 0,
                      ref: r.maskRef,
                      class: e.cx('mask'),
                      style: e.sx('mask', !0, {
                        position: e.position,
                        modal: e.modal
                      }),
                      onMousedown:
                        t[1] ||
                        (t[1] = function () {
                          return (
                            r.onMaskMouseDown &&
                            r.onMaskMouseDown.apply(r, arguments)
                          )
                        }),
                      onMouseup:
                        t[2] ||
                        (t[2] = function () {
                          return (
                            r.onMaskMouseUp &&
                            r.onMaskMouseUp.apply(r, arguments)
                          )
                        })
                    },
                    e.ptm('mask')
                  ),
                  [
                    Vue.createVNode(
                      Vue.Transition,
                      Vue.mergeProps(
                        {
                          name: 'p-dialog',
                          onEnter: r.onEnter,
                          onAfterEnter: r.onAfterEnter,
                          onBeforeLeave: r.onBeforeLeave,
                          onLeave: r.onLeave,
                          onAfterLeave: r.onAfterLeave,
                          appear: ''
                        },
                        e.ptm('transition')
                      ),
                      {
                        default: Vue.withCtx(function () {
                          return [
                            e.visible
                              ? Vue.withDirectives(
                                  (Vue.openBlock(),
                                  Vue.createElementBlock(
                                    'div',
                                    Vue.mergeProps(
                                      {
                                        key: 0,
                                        ref: r.containerRef,
                                        class: e.cx('root'),
                                        style: e.sx('root'),
                                        role: 'dialog',
                                        'aria-labelledby': r.ariaLabelledById,
                                        'aria-modal': e.modal
                                      },
                                      e.ptmi('root')
                                    ),
                                    [
                                      e.$slots.container
                                        ? Vue.renderSlot(
                                            e.$slots,
                                            'container',
                                            {
                                              key: 0,
                                              closeCallback: r.close,
                                              maximizeCallback: __name(
                                                function (e) {
                                                  return r.maximize(e)
                                                },
                                                'maximizeCallback'
                                              )
                                            }
                                          )
                                        : (Vue.openBlock(),
                                          Vue.createElementBlock(
                                            Vue.Fragment,
                                            { key: 1 },
                                            [
                                              e.showHeader
                                                ? (Vue.openBlock(),
                                                  Vue.createElementBlock(
                                                    'div',
                                                    Vue.mergeProps(
                                                      {
                                                        key: 0,
                                                        ref: r.headerContainerRef,
                                                        class: e.cx('header'),
                                                        onMousedown:
                                                          t[0] ||
                                                          (t[0] = function () {
                                                            return (
                                                              r.initDrag &&
                                                              r.initDrag.apply(
                                                                r,
                                                                arguments
                                                              )
                                                            )
                                                          })
                                                      },
                                                      e.ptm('header')
                                                    ),
                                                    [
                                                      Vue.renderSlot(
                                                        e.$slots,
                                                        'header',
                                                        {
                                                          class:
                                                            Vue.normalizeClass(
                                                              e.cx('title')
                                                            )
                                                        },
                                                        function () {
                                                          return [
                                                            e.header
                                                              ? (Vue.openBlock(),
                                                                Vue.createElementBlock(
                                                                  'span',
                                                                  Vue.mergeProps(
                                                                    {
                                                                      key: 0,
                                                                      id: r.ariaLabelledById,
                                                                      class:
                                                                        e.cx(
                                                                          'title'
                                                                        )
                                                                    },
                                                                    e.ptm(
                                                                      'title'
                                                                    )
                                                                  ),
                                                                  Vue.toDisplayString(
                                                                    e.header
                                                                  ),
                                                                  17,
                                                                  _hoisted_2$a
                                                                ))
                                                              : Vue.createCommentVNode(
                                                                  '',
                                                                  !0
                                                                )
                                                          ]
                                                        }
                                                      ),
                                                      Vue.createElementVNode(
                                                        'div',
                                                        Vue.mergeProps(
                                                          {
                                                            class:
                                                              e.cx(
                                                                'headerActions'
                                                              )
                                                          },
                                                          e.ptm('headerActions')
                                                        ),
                                                        [
                                                          e.maximizable
                                                            ? (Vue.openBlock(),
                                                              Vue.createBlock(
                                                                a,
                                                                Vue.mergeProps(
                                                                  {
                                                                    key: 0,
                                                                    ref: r.maximizableRef,
                                                                    autofocus:
                                                                      i.focusableMax,
                                                                    class:
                                                                      e.cx(
                                                                        'pcMaximizeButton'
                                                                      ),
                                                                    onClick:
                                                                      r.maximize,
                                                                    tabindex:
                                                                      e.maximizable
                                                                        ? '0'
                                                                        : '-1',
                                                                    unstyled:
                                                                      e.unstyled
                                                                  },
                                                                  e.maximizeButtonProps,
                                                                  {
                                                                    pt: e.ptm(
                                                                      'pcMaximizeButton'
                                                                    ),
                                                                    'data-pc-group-section':
                                                                      'headericon'
                                                                  }
                                                                ),
                                                                {
                                                                  icon: Vue.withCtx(
                                                                    function (
                                                                      t
                                                                    ) {
                                                                      return [
                                                                        Vue.renderSlot(
                                                                          e.$slots,
                                                                          'maximizeicon',
                                                                          {
                                                                            maximized:
                                                                              i.maximized
                                                                          },
                                                                          function () {
                                                                            return [
                                                                              (Vue.openBlock(),
                                                                              Vue.createBlock(
                                                                                Vue.resolveDynamicComponent(
                                                                                  r.maximizeIconComponent
                                                                                ),
                                                                                Vue.mergeProps(
                                                                                  {
                                                                                    class:
                                                                                      [
                                                                                        t.class,
                                                                                        i.maximized
                                                                                          ? e.minimizeIcon
                                                                                          : e.maximizeIcon
                                                                                      ]
                                                                                  },
                                                                                  e.ptm(
                                                                                    'pcMaximizeButton'
                                                                                  )
                                                                                    .icon
                                                                                ),
                                                                                null,
                                                                                16,
                                                                                [
                                                                                  'class'
                                                                                ]
                                                                              ))
                                                                            ]
                                                                          }
                                                                        )
                                                                      ]
                                                                    }
                                                                  ),
                                                                  _: 3
                                                                },
                                                                16,
                                                                [
                                                                  'autofocus',
                                                                  'class',
                                                                  'onClick',
                                                                  'tabindex',
                                                                  'unstyled',
                                                                  'pt'
                                                                ]
                                                              ))
                                                            : Vue.createCommentVNode(
                                                                '',
                                                                !0
                                                              ),
                                                          e.closable
                                                            ? (Vue.openBlock(),
                                                              Vue.createBlock(
                                                                a,
                                                                Vue.mergeProps(
                                                                  {
                                                                    key: 1,
                                                                    ref: r.closeButtonRef,
                                                                    autofocus:
                                                                      i.focusableClose,
                                                                    class:
                                                                      e.cx(
                                                                        'pcCloseButton'
                                                                      ),
                                                                    onClick:
                                                                      r.close,
                                                                    'aria-label':
                                                                      r.closeAriaLabel,
                                                                    unstyled:
                                                                      e.unstyled
                                                                  },
                                                                  e.closeButtonProps,
                                                                  {
                                                                    pt: e.ptm(
                                                                      'pcCloseButton'
                                                                    ),
                                                                    'data-pc-group-section':
                                                                      'headericon'
                                                                  }
                                                                ),
                                                                {
                                                                  icon: Vue.withCtx(
                                                                    function (
                                                                      t
                                                                    ) {
                                                                      return [
                                                                        Vue.renderSlot(
                                                                          e.$slots,
                                                                          'closeicon',
                                                                          {},
                                                                          function () {
                                                                            return [
                                                                              (Vue.openBlock(),
                                                                              Vue.createBlock(
                                                                                Vue.resolveDynamicComponent(
                                                                                  e.closeIcon
                                                                                    ? 'span'
                                                                                    : 'TimesIcon'
                                                                                ),
                                                                                Vue.mergeProps(
                                                                                  {
                                                                                    class:
                                                                                      [
                                                                                        e.closeIcon,
                                                                                        t.class
                                                                                      ]
                                                                                  },
                                                                                  e.ptm(
                                                                                    'pcCloseButton'
                                                                                  )
                                                                                    .icon
                                                                                ),
                                                                                null,
                                                                                16,
                                                                                [
                                                                                  'class'
                                                                                ]
                                                                              ))
                                                                            ]
                                                                          }
                                                                        )
                                                                      ]
                                                                    }
                                                                  ),
                                                                  _: 3
                                                                },
                                                                16,
                                                                [
                                                                  'autofocus',
                                                                  'class',
                                                                  'onClick',
                                                                  'aria-label',
                                                                  'unstyled',
                                                                  'pt'
                                                                ]
                                                              ))
                                                            : Vue.createCommentVNode(
                                                                '',
                                                                !0
                                                              )
                                                        ],
                                                        16
                                                      )
                                                    ],
                                                    16
                                                  ))
                                                : Vue.createCommentVNode(
                                                    '',
                                                    !0
                                                  ),
                                              Vue.createElementVNode(
                                                'div',
                                                Vue.mergeProps(
                                                  {
                                                    ref: r.contentRef,
                                                    class: [
                                                      e.cx('content'),
                                                      e.contentClass
                                                    ],
                                                    style: e.contentStyle
                                                  },
                                                  _objectSpread$5(
                                                    _objectSpread$5(
                                                      {},
                                                      e.contentProps
                                                    ),
                                                    e.ptm('content')
                                                  )
                                                ),
                                                [
                                                  Vue.renderSlot(
                                                    e.$slots,
                                                    'default'
                                                  )
                                                ],
                                                16
                                              ),
                                              e.footer || e.$slots.footer
                                                ? (Vue.openBlock(),
                                                  Vue.createElementBlock(
                                                    'div',
                                                    Vue.mergeProps(
                                                      {
                                                        key: 1,
                                                        ref: r.footerContainerRef,
                                                        class: e.cx('footer')
                                                      },
                                                      e.ptm('footer')
                                                    ),
                                                    [
                                                      Vue.renderSlot(
                                                        e.$slots,
                                                        'footer',
                                                        {},
                                                        function () {
                                                          return [
                                                            Vue.createTextVNode(
                                                              Vue.toDisplayString(
                                                                e.footer
                                                              ),
                                                              1
                                                            )
                                                          ]
                                                        }
                                                      )
                                                    ],
                                                    16
                                                  ))
                                                : Vue.createCommentVNode('', !0)
                                            ],
                                            64
                                          ))
                                    ],
                                    16,
                                    _hoisted_1$h
                                  )),
                                  [[l, { disabled: !e.modal }]]
                                )
                              : Vue.createCommentVNode('', !0)
                          ]
                        }),
                        _: 3
                      },
                      16,
                      [
                        'onEnter',
                        'onAfterEnter',
                        'onBeforeLeave',
                        'onLeave',
                        'onAfterLeave'
                      ]
                    )
                  ],
                  16
                ))
              : Vue.createCommentVNode('', !0)
          ]
        }),
        _: 3
      },
      8,
      ['appendTo']
    )
  )
}
__name(render$a, 'render$a'), (script$b.render = render$a)
var theme$7 = __name(function (e) {
    var t = e.dt
    return '\n.p-togglebutton {\n    display: inline-flex;\n    cursor: pointer;\n    user-select: none;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    color: '
      .concat(t('togglebutton.color'), ';\n    background: ')
      .concat(t('togglebutton.background'), ';\n    border: 1px solid ')
      .concat(t('togglebutton.border.color'), ';\n    padding: ')
      .concat(
        t('togglebutton.padding'),
        ';\n    font-size: 1rem;\n    font-family: inherit;\n    font-feature-settings: inherit;\n    transition: background '
      )
      .concat(t('togglebutton.transition.duration'), ', color ')
      .concat(t('togglebutton.transition.duration'), ', border-color ')
      .concat(
        t('togglebutton.transition.duration'),
        ',\n        outline-color '
      )
      .concat(t('togglebutton.transition.duration'), ', box-shadow ')
      .concat(t('togglebutton.transition.duration'), ';\n    border-radius: ')
      .concat(
        t('togglebutton.border.radius'),
        ';\n    outline-color: transparent;\n    font-weight: '
      )
      .concat(
        t('togglebutton.font.weight'),
        ';\n}\n\n.p-togglebutton-content {\n    position: relative;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    gap: '
      )
      .concat(
        t('togglebutton.gap'),
        ';\n}\n\n.p-togglebutton-label,\n.p-togglebutton-icon {\n    position: relative;\n    transition: none;\n}\n\n.p-togglebutton::before {\n    content: "";\n    background: transparent;\n    transition: background '
      )
      .concat(t('togglebutton.transition.duration'), ', color ')
      .concat(t('togglebutton.transition.duration'), ', border-color ')
      .concat(
        t('togglebutton.transition.duration'),
        ',\n            outline-color '
      )
      .concat(t('togglebutton.transition.duration'), ', box-shadow ')
      .concat(
        t('togglebutton.transition.duration'),
        ';\n    position: absolute;\n    inset-inline-start: '
      )
      .concat(t('togglebutton.content.left'), ';\n    inset-block-start: ')
      .concat(
        t('togglebutton.content.top'),
        ';\n    width: calc(100% - calc(2 * '
      )
      .concat(
        t('togglebutton.content.left'),
        '));\n    height: calc(100% - calc(2 * '
      )
      .concat(t('togglebutton.content.top'), '));\n    border-radius: ')
      .concat(
        t('togglebutton.border.radius'),
        ';\n}\n\n.p-togglebutton.p-togglebutton-checked::before {\n    background: '
      )
      .concat(
        t('togglebutton.content.checked.background'),
        ';\n    box-shadow: '
      )
      .concat(
        t('togglebutton.content.checked.shadow'),
        ';\n}\n\n.p-togglebutton:not(:disabled):not(.p-togglebutton-checked):hover {\n    background: '
      )
      .concat(t('togglebutton.hover.background'), ';\n    color: ')
      .concat(
        t('togglebutton.hover.color'),
        ';\n}\n\n.p-togglebutton.p-togglebutton-checked {\n    background: '
      )
      .concat(t('togglebutton.checked.background'), ';\n    border-color: ')
      .concat(t('togglebutton.checked.border.color'), ';\n    color: ')
      .concat(
        t('togglebutton.checked.color'),
        ';\n}\n\n.p-togglebutton:focus-visible {\n    box-shadow: '
      )
      .concat(t('togglebutton.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('togglebutton.focus.ring.width'), ' ')
      .concat(t('togglebutton.focus.ring.style'), ' ')
      .concat(t('togglebutton.focus.ring.color'), ';\n    outline-offset: ')
      .concat(
        t('togglebutton.focus.ring.offset'),
        ';\n}\n\n.p-togglebutton.p-invalid {\n    border-color: '
      )
      .concat(
        t('togglebutton.invalid.border.color'),
        ';\n}\n\n.p-togglebutton:disabled {\n    opacity: 1;\n    cursor: default;\n    background: '
      )
      .concat(t('togglebutton.disabled.background'), ';\n    border-color: ')
      .concat(t('togglebutton.disabled.border.color'), ';\n    color: ')
      .concat(
        t('togglebutton.disabled.color'),
        ';\n}\n\n.p-togglebutton-icon {\n    color: '
      )
      .concat(
        t('togglebutton.icon.color'),
        ';\n}\n\n.p-togglebutton:not(:disabled):not(.p-togglebutton-checked):hover .p-togglebutton-icon {\n    color: '
      )
      .concat(
        t('togglebutton.icon.hover.color'),
        ';\n}\n\n.p-togglebutton.p-togglebutton-checked .p-togglebutton-icon {\n    color: '
      )
      .concat(
        t('togglebutton.icon.checked.color'),
        ';\n}\n\n.p-togglebutton:disabled .p-togglebutton-icon {\n    color: '
      )
      .concat(
        t('togglebutton.icon.disabled.color'),
        ';\n}\n\n.p-togglebutton-sm {\n    padding: '
      )
      .concat(t('togglebutton.sm.padding'), ';\n    font-size: ')
      .concat(
        t('togglebutton.sm.font.size'),
        ';\n}\n\n.p-togglebutton-lg {\n    padding: '
      )
      .concat(t('togglebutton.lg.padding'), ';\n    font-size: ')
      .concat(t('togglebutton.lg.font.size'), ';\n}\n')
  }, 'theme'),
  classes$7 = {
    root: __name(function (e) {
      var t = e.instance,
        n = e.props
      return [
        'p-togglebutton p-component',
        {
          'p-togglebutton-checked': t.active,
          'p-invalid': t.$invalid,
          'p-togglebutton-sm p-inputfield-sm': 'small' === n.size,
          'p-togglebutton-lg p-inputfield-lg': 'large' === n.size
        }
      ]
    }, 'root'),
    content: 'p-togglebutton-content',
    icon: 'p-togglebutton-icon',
    label: 'p-togglebutton-label'
  },
  ToggleButtonStyle = BaseStyle.extend({
    name: 'togglebutton',
    theme: theme$7,
    classes: classes$7
  }),
  script$1$6 = {
    name: 'BaseToggleButton',
    extends: script$R,
    props: {
      onIcon: String,
      offIcon: String,
      onLabel: { type: String, default: 'Yes' },
      offLabel: { type: String, default: 'No' },
      iconPos: { type: String, default: 'left' },
      readonly: { type: Boolean, default: !1 },
      tabindex: { type: Number, default: null },
      ariaLabelledby: { type: String, default: null },
      ariaLabel: { type: String, default: null },
      size: { type: String, default: null }
    },
    style: ToggleButtonStyle,
    provide: __name(function () {
      return { $pcToggleButton: this, $parentInstance: this }
    }, 'provide')
  },
  script$a = {
    name: 'ToggleButton',
    extends: script$1$6,
    inheritAttrs: !1,
    emits: ['change'],
    methods: {
      getPTOptions: __name(function (e) {
        return ('root' === e ? this.ptmi : this.ptm)(e, {
          context: { active: this.active, disabled: this.disabled }
        })
      }, 'getPTOptions'),
      onChange: __name(function (e) {
        this.disabled ||
          this.readonly ||
          (this.writeValue(!this.d_value, e), this.$emit('change', e))
      }, 'onChange'),
      onBlur: __name(function (e) {
        var t, n
        null === (t = (n = this.formField).onBlur) ||
          void 0 === t ||
          t.call(n, e)
      }, 'onBlur')
    },
    computed: {
      active: __name(function () {
        return !0 === this.d_value
      }, 'active'),
      hasLabel: __name(function () {
        return isNotEmpty(this.onLabel) && isNotEmpty(this.offLabel)
      }, 'hasLabel'),
      label: __name(function () {
        return this.hasLabel
          ? this.d_value
            ? this.onLabel
            : this.offLabel
          : ' '
      }, 'label')
    },
    directives: { ripple: Ripple }
  },
  _hoisted_1$g = [
    'tabindex',
    'disabled',
    'aria-pressed',
    'aria-labelledby',
    'data-p-checked',
    'data-p-disabled'
  ]
function render$9(e, t, n, o, i, r) {
  var a = Vue.resolveDirective('ripple')
  return Vue.withDirectives(
    (Vue.openBlock(),
    Vue.createElementBlock(
      'button',
      Vue.mergeProps(
        {
          type: 'button',
          class: e.cx('root'),
          tabindex: e.tabindex,
          disabled: e.disabled,
          'aria-pressed': e.d_value,
          onClick:
            t[0] ||
            (t[0] = function () {
              return r.onChange && r.onChange.apply(r, arguments)
            }),
          onBlur:
            t[1] ||
            (t[1] = function () {
              return r.onBlur && r.onBlur.apply(r, arguments)
            })
        },
        r.getPTOptions('root'),
        {
          'aria-labelledby': e.ariaLabelledby,
          'data-p-checked': r.active,
          'data-p-disabled': e.disabled
        }
      ),
      [
        Vue.createElementVNode(
          'span',
          Vue.mergeProps({ class: e.cx('content') }, r.getPTOptions('content')),
          [
            Vue.renderSlot(e.$slots, 'default', {}, function () {
              return [
                Vue.renderSlot(
                  e.$slots,
                  'icon',
                  { value: e.d_value, class: Vue.normalizeClass(e.cx('icon')) },
                  function () {
                    return [
                      e.onIcon || e.offIcon
                        ? (Vue.openBlock(),
                          Vue.createElementBlock(
                            'span',
                            Vue.mergeProps(
                              {
                                key: 0,
                                class: [
                                  e.cx('icon'),
                                  e.d_value ? e.onIcon : e.offIcon
                                ]
                              },
                              r.getPTOptions('icon')
                            ),
                            null,
                            16
                          ))
                        : Vue.createCommentVNode('', !0)
                    ]
                  }
                ),
                Vue.createElementVNode(
                  'span',
                  Vue.mergeProps(
                    { class: e.cx('label') },
                    r.getPTOptions('label')
                  ),
                  Vue.toDisplayString(r.label),
                  17
                )
              ]
            })
          ],
          16
        )
      ],
      16,
      _hoisted_1$g
    )),
    [[a]]
  )
}
__name(render$9, 'render$9'), (script$a.render = render$9)
var theme$6 = __name(function (e) {
    var t = e.dt
    return '\n.p-selectbutton {\n    display: inline-flex;\n    user-select: none;\n    vertical-align: bottom;\n    outline-color: transparent;\n    border-radius: '
      .concat(
        t('selectbutton.border.radius'),
        ';\n}\n\n.p-selectbutton .p-togglebutton {\n    border-radius: 0;\n    border-width: 1px 1px 1px 0;\n}\n\n.p-selectbutton .p-togglebutton:focus-visible {\n    position: relative;\n    z-index: 1;\n}\n\n.p-selectbutton .p-togglebutton:first-child {\n    border-inline-start-width: 1px;\n    border-start-start-radius: '
      )
      .concat(
        t('selectbutton.border.radius'),
        ';\n    border-end-start-radius: '
      )
      .concat(
        t('selectbutton.border.radius'),
        ';\n}\n\n.p-selectbutton .p-togglebutton:last-child {\n    border-start-end-radius: '
      )
      .concat(t('selectbutton.border.radius'), ';\n    border-end-end-radius: ')
      .concat(
        t('selectbutton.border.radius'),
        ';\n}\n\n.p-selectbutton.p-invalid {\n    outline: 1px solid '
      )
      .concat(
        t('selectbutton.invalid.border.color'),
        ';\n    outline-offset: 0;\n}\n'
      )
  }, 'theme'),
  classes$6 = {
    root: __name(function (e) {
      return [
        'p-selectbutton p-component',
        { 'p-invalid': e.instance.$invalid }
      ]
    }, 'root')
  },
  SelectButtonStyle = BaseStyle.extend({
    name: 'selectbutton',
    theme: theme$6,
    classes: classes$6
  }),
  script$1$5 = {
    name: 'BaseSelectButton',
    extends: script$R,
    props: {
      options: Array,
      optionLabel: null,
      optionValue: null,
      optionDisabled: null,
      multiple: Boolean,
      allowEmpty: { type: Boolean, default: !0 },
      dataKey: null,
      ariaLabelledby: { type: String, default: null },
      size: { type: String, default: null }
    },
    style: SelectButtonStyle,
    provide: __name(function () {
      return { $pcSelectButton: this, $parentInstance: this }
    }, 'provide')
  }
function _createForOfIteratorHelper(e, t) {
  var n =
    ('undefined' != typeof Symbol && e[Symbol.iterator]) || e['@@iterator']
  if (!n) {
    if (Array.isArray(e) || (n = _unsupportedIterableToArray$3(e)) || t) {
      n && (e = n)
      var o = 0,
        i = __name(function () {}, 'F')
      return {
        s: i,
        n: __name(function () {
          return o >= e.length ? { done: !0 } : { done: !1, value: e[o++] }
        }, 'n'),
        e: __name(function (e) {
          throw e
        }, 'e'),
        f: i
      }
    }
    throw new TypeError(
      'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
    )
  }
  var r,
    a = !0,
    s = !1
  return {
    s: __name(function () {
      n = n.call(e)
    }, 's'),
    n: __name(function () {
      var e = n.next()
      return (a = e.done), e
    }, 'n'),
    e: __name(function (e) {
      ;(s = !0), (r = e)
    }, 'e'),
    f: __name(function () {
      try {
        a || null == n.return || n.return()
      } finally {
        if (s) throw r
      }
    }, 'f')
  }
}
function _toConsumableArray$2(e) {
  return (
    _arrayWithoutHoles$2(e) ||
    _iterableToArray$2(e) ||
    _unsupportedIterableToArray$3(e) ||
    _nonIterableSpread$2()
  )
}
function _nonIterableSpread$2() {
  throw new TypeError(
    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$3(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$3(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$3(e, t)
          : void 0
    )
  }
}
function _iterableToArray$2(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _arrayWithoutHoles$2(e) {
  if (Array.isArray(e)) return _arrayLikeToArray$3(e)
}
function _arrayLikeToArray$3(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
__name(_createForOfIteratorHelper, '_createForOfIteratorHelper'),
  __name(_toConsumableArray$2, '_toConsumableArray$2'),
  __name(_nonIterableSpread$2, '_nonIterableSpread$2'),
  __name(_unsupportedIterableToArray$3, '_unsupportedIterableToArray$3'),
  __name(_iterableToArray$2, '_iterableToArray$2'),
  __name(_arrayWithoutHoles$2, '_arrayWithoutHoles$2'),
  __name(_arrayLikeToArray$3, '_arrayLikeToArray$3')
var script$9 = {
    name: 'SelectButton',
    extends: script$1$5,
    inheritAttrs: !1,
    emits: ['change'],
    methods: {
      getOptionLabel: __name(function (e) {
        return this.optionLabel ? resolveFieldData(e, this.optionLabel) : e
      }, 'getOptionLabel'),
      getOptionValue: __name(function (e) {
        return this.optionValue ? resolveFieldData(e, this.optionValue) : e
      }, 'getOptionValue'),
      getOptionRenderKey: __name(function (e) {
        return this.dataKey
          ? resolveFieldData(e, this.dataKey)
          : this.getOptionLabel(e)
      }, 'getOptionRenderKey'),
      isOptionDisabled: __name(function (e) {
        return !!this.optionDisabled && resolveFieldData(e, this.optionDisabled)
      }, 'isOptionDisabled'),
      onOptionSelect: __name(function (e, t, n) {
        var o = this
        if (!this.disabled && !this.isOptionDisabled(t)) {
          var i = this.isSelected(t)
          if (!i || this.allowEmpty) {
            var r,
              a = this.getOptionValue(t)
            ;(r = this.multiple
              ? i
                ? this.d_value.filter(function (e) {
                    return !equals(e, a, o.equalityKey)
                  })
                : this.d_value
                  ? [].concat(_toConsumableArray$2(this.d_value), [a])
                  : [a]
              : i
                ? null
                : a),
              this.writeValue(r, e),
              this.$emit('change', { event: e, value: r })
          }
        }
      }, 'onOptionSelect'),
      isSelected: __name(function (e) {
        var t = !1,
          n = this.getOptionValue(e)
        if (this.multiple) {
          if (this.d_value) {
            var o,
              i = _createForOfIteratorHelper(this.d_value)
            try {
              for (i.s(); !(o = i.n()).done; ) {
                if (equals(o.value, n, this.equalityKey)) {
                  t = !0
                  break
                }
              }
            } catch (r) {
              i.e(r)
            } finally {
              i.f()
            }
          }
        } else t = equals(this.d_value, n, this.equalityKey)
        return t
      }, 'isSelected')
    },
    computed: {
      equalityKey: __name(function () {
        return this.optionValue ? null : this.dataKey
      }, 'equalityKey')
    },
    directives: { ripple: Ripple },
    components: { ToggleButton: script$a }
  },
  _hoisted_1$f = ['aria-labelledby']
function render$8(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('ToggleButton')
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps(
        {
          class: e.cx('root'),
          role: 'group',
          'aria-labelledby': e.ariaLabelledby
        },
        e.ptmi('root')
      ),
      [
        (Vue.openBlock(!0),
        Vue.createElementBlock(
          Vue.Fragment,
          null,
          Vue.renderList(e.options, function (t, n) {
            return (
              Vue.openBlock(),
              Vue.createBlock(
                a,
                {
                  key: r.getOptionRenderKey(t),
                  modelValue: r.isSelected(t),
                  onLabel: r.getOptionLabel(t),
                  offLabel: r.getOptionLabel(t),
                  disabled: e.disabled || r.isOptionDisabled(t),
                  unstyled: e.unstyled,
                  size: e.size,
                  onChange: __name(function (e) {
                    return r.onOptionSelect(e, t, n)
                  }, 'onChange'),
                  pt: e.ptm('pcToggleButton')
                },
                Vue.createSlots({ _: 2 }, [
                  e.$slots.option
                    ? {
                        name: 'default',
                        fn: Vue.withCtx(function () {
                          return [
                            Vue.renderSlot(
                              e.$slots,
                              'option',
                              { option: t, index: n },
                              function () {
                                return [
                                  Vue.createElementVNode(
                                    'span',
                                    Vue.mergeProps(
                                      { ref_for: !0 },
                                      e.ptm('pcToggleButton').label
                                    ),
                                    Vue.toDisplayString(r.getOptionLabel(t)),
                                    17
                                  )
                                ]
                              }
                            )
                          ]
                        }),
                        key: '0'
                      }
                    : void 0
                ]),
                1032,
                [
                  'modelValue',
                  'onLabel',
                  'offLabel',
                  'disabled',
                  'unstyled',
                  'size',
                  'onChange',
                  'pt'
                ]
              )
            )
          }),
          128
        ))
      ],
      16,
      _hoisted_1$f
    )
  )
}
__name(render$8, 'render$8'), (script$9.render = render$8)
var theme$5 = __name(function (e) {
    var t = e.dt
    return '\n.p-colorpicker {\n    display: inline-block;\n    position: relative;\n}\n\n.p-colorpicker-dragging {\n    cursor: pointer;\n}\n\n.p-colorpicker-preview {\n    width: '
      .concat(t('colorpicker.preview.width'), ';\n    height: ')
      .concat(
        t('colorpicker.preview.height'),
        ';\n    padding: 0;\n    border: 0 none;\n    border-radius: '
      )
      .concat(
        t('colorpicker.preview.border.radius'),
        ';\n    transition: background '
      )
      .concat(t('colorpicker.transition.duration'), ', color ')
      .concat(t('colorpicker.transition.duration'), ', border-color ')
      .concat(t('colorpicker.transition.duration'), ', outline-color ')
      .concat(t('colorpicker.transition.duration'), ', box-shadow ')
      .concat(
        t('colorpicker.transition.duration'),
        ';\n    outline-color: transparent;\n    cursor: pointer;\n}\n\n.p-colorpicker-preview:enabled:focus-visible {\n    border-color: '
      )
      .concat(
        t('colorpicker.preview.focus.border.color'),
        ';\n    box-shadow: '
      )
      .concat(t('colorpicker.preview.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('colorpicker.preview.focus.ring.width'), ' ')
      .concat(t('colorpicker.preview.focus.ring.style'), ' ')
      .concat(
        t('colorpicker.preview.focus.ring.color'),
        ';\n    outline-offset: '
      )
      .concat(
        t('colorpicker.preview.focus.ring.offset'),
        ';\n}\n\n.p-colorpicker-panel {\n    background: '
      )
      .concat(t('colorpicker.panel.background'), ';\n    border: 1px solid ')
      .concat(t('colorpicker.panel.border.color'), ';\n    border-radius: ')
      .concat(t('colorpicker.panel.border.radius'), ';\n    box-shadow: ')
      .concat(
        t('colorpicker.panel.shadow'),
        ';\n    width: 193px;\n    height: 166px;\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n\n.p-colorpicker-panel-inline {\n    box-shadow: none;\n    position: static;\n}\n\n.p-colorpicker-content {\n    position: relative;\n}\n\n.p-colorpicker-color-selector {\n    width: 150px;\n    height: 150px;\n    inset-block-start: 8px;\n    inset-inline-start: 8px;\n    position: absolute;\n}\n\n.p-colorpicker-color-background {\n    width: 100%;\n    height: 100%;\n    background: linear-gradient(to top, #000 0%, rgba(0, 0, 0, 0) 100%), linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);\n}\n\n.p-colorpicker-color-handle {\n    position: absolute;\n    inset-block-start: 0px;\n    inset-inline-start: 150px;\n    border-radius: 100%;\n    width: 10px;\n    height: 10px;\n    border-width: 1px;\n    border-style: solid;\n    margin: -5px 0 0 -5px;\n    cursor: pointer;\n    opacity: 0.85;\n    border-color: '
      )
      .concat(
        t('colorpicker.handle.color'),
        ';\n}\n\n.p-colorpicker-hue {\n    width: 17px;\n    height: 150px;\n    inset-block-start: 8px;\n    inset-inline-start: 167px;\n    position: absolute;\n    opacity: 0.85;\n    background: linear-gradient(0deg,\n        red 0,\n        #ff0 17%,\n        #0f0 33%,\n        #0ff 50%,\n        #00f 67%,\n        #f0f 83%,\n        red);\n}\n\n.p-colorpicker-hue-handle {\n    position: absolute;\n    inset-block-start: 150px;\n    inset-inline-start: 0px;\n    width: 21px;\n    margin-inline-start: -2px;\n    margin-block-start: -5px;\n    height: 10px;\n    border-width: 2px;\n    border-style: solid;\n    opacity: 0.85;\n    cursor: pointer;\n    border-color: '
      )
      .concat(t('colorpicker.handle.color'), ';\n}\n')
  }, 'theme'),
  classes$5 = {
    root: 'p-colorpicker p-component',
    preview: __name(function (e) {
      return ['p-colorpicker-preview', { 'p-disabled': e.props.disabled }]
    }, 'preview'),
    panel: __name(function (e) {
      var t = e.instance,
        n = e.props
      return [
        'p-colorpicker-panel',
        {
          'p-colorpicker-panel-inline': n.inline,
          'p-disabled': n.disabled,
          'p-invalid': t.$invalid
        }
      ]
    }, 'panel'),
    colorSelector: 'p-colorpicker-color-selector',
    colorBackground: 'p-colorpicker-color-background',
    colorHandle: 'p-colorpicker-color-handle',
    hue: 'p-colorpicker-hue',
    hueHandle: 'p-colorpicker-hue-handle'
  },
  ColorPickerStyle = BaseStyle.extend({
    name: 'colorpicker',
    theme: theme$5,
    classes: classes$5
  }),
  script$1$4 = {
    name: 'BaseColorPicker',
    extends: script$R,
    props: {
      defaultColor: { type: null, default: 'ff0000' },
      inline: { type: Boolean, default: !1 },
      format: { type: String, default: 'hex' },
      tabindex: { type: String, default: null },
      autoZIndex: { type: Boolean, default: !0 },
      baseZIndex: { type: Number, default: 0 },
      appendTo: { type: [String, Object], default: 'body' },
      inputId: { type: String, default: null },
      panelClass: null,
      overlayClass: null
    },
    style: ColorPickerStyle,
    provide: __name(function () {
      return { $pcColorPicker: this, $parentInstance: this }
    }, 'provide')
  },
  script$8 = {
    name: 'ColorPicker',
    extends: script$1$4,
    inheritAttrs: !1,
    emits: ['change', 'show', 'hide'],
    data: __name(function () {
      return { overlayVisible: !1 }
    }, 'data'),
    hsbValue: null,
    outsideClickListener: null,
    documentMouseMoveListener: null,
    documentMouseUpListener: null,
    scrollHandler: null,
    resizeListener: null,
    hueDragging: null,
    colorDragging: null,
    selfUpdate: null,
    picker: null,
    colorSelector: null,
    colorHandle: null,
    hueView: null,
    hueHandle: null,
    watch: {
      modelValue: {
        immediate: !0,
        handler: __name(function (e) {
          ;(this.hsbValue = this.toHSB(e)),
            this.selfUpdate ? (this.selfUpdate = !1) : this.updateUI()
        }, 'handler')
      }
    },
    beforeUnmount: __name(function () {
      this.unbindOutsideClickListener(),
        this.unbindDragListeners(),
        this.unbindResizeListener(),
        this.scrollHandler &&
          (this.scrollHandler.destroy(), (this.scrollHandler = null)),
        this.picker && this.autoZIndex && ZIndex.clear(this.picker),
        this.clearRefs()
    }, 'beforeUnmount'),
    mounted: __name(function () {
      this.updateUI()
    }, 'mounted'),
    methods: {
      pickColor: __name(function (e) {
        var t = this.colorSelector.getBoundingClientRect(),
          n =
            t.top +
            (window.pageYOffset ||
              document.documentElement.scrollTop ||
              document.body.scrollTop ||
              0),
          o = t.left + document.body.scrollLeft,
          i = Math.floor(
            (100 *
              Math.max(
                0,
                Math.min(150, (e.pageX || e.changedTouches[0].pageX) - o)
              )) /
              150
          ),
          r = Math.floor(
            (100 *
              (150 -
                Math.max(
                  0,
                  Math.min(150, (e.pageY || e.changedTouches[0].pageY) - n)
                ))) /
              150
          )
        ;(this.hsbValue = this.validateHSB({ h: this.hsbValue.h, s: i, b: r })),
          (this.selfUpdate = !0),
          this.updateColorHandle(),
          this.updateInput(),
          this.updateModel(e)
      }, 'pickColor'),
      pickHue: __name(function (e) {
        var t =
          this.hueView.getBoundingClientRect().top +
          (window.pageYOffset ||
            document.documentElement.scrollTop ||
            document.body.scrollTop ||
            0)
        ;(this.hsbValue = this.validateHSB({
          h: Math.floor(
            (360 *
              (150 -
                Math.max(
                  0,
                  Math.min(150, (e.pageY || e.changedTouches[0].pageY) - t)
                ))) /
              150
          ),
          s: 100,
          b: 100
        })),
          (this.selfUpdate = !0),
          this.updateColorSelector(),
          this.updateHue(),
          this.updateModel(e),
          this.updateInput()
      }, 'pickHue'),
      updateModel: __name(function (e) {
        var t = this.d_value
        switch (this.format) {
          case 'hex':
            t = this.HSBtoHEX(this.hsbValue)
            break
          case 'rgb':
            t = this.HSBtoRGB(this.hsbValue)
            break
          case 'hsb':
            t = this.hsbValue
        }
        this.writeValue(t, e), this.$emit('change', { event: e, value: t })
      }, 'updateModel'),
      updateColorSelector: __name(function () {
        if (this.colorSelector) {
          var e = this.validateHSB({ h: this.hsbValue.h, s: 100, b: 100 })
          this.colorSelector.style.backgroundColor = '#' + this.HSBtoHEX(e)
        }
      }, 'updateColorSelector'),
      updateColorHandle: __name(function () {
        this.colorHandle &&
          ((this.colorHandle.style.left =
            Math.floor((150 * this.hsbValue.s) / 100) + 'px'),
          (this.colorHandle.style.top =
            Math.floor((150 * (100 - this.hsbValue.b)) / 100) + 'px'))
      }, 'updateColorHandle'),
      updateHue: __name(function () {
        this.hueHandle &&
          (this.hueHandle.style.top =
            Math.floor(150 - (150 * this.hsbValue.h) / 360) + 'px')
      }, 'updateHue'),
      updateInput: __name(function () {
        this.$refs.input &&
          (this.$refs.input.style.backgroundColor =
            '#' + this.HSBtoHEX(this.hsbValue))
      }, 'updateInput'),
      updateUI: __name(function () {
        this.updateHue(),
          this.updateColorHandle(),
          this.updateInput(),
          this.updateColorSelector()
      }, 'updateUI'),
      validateHSB: __name(function (e) {
        return {
          h: Math.min(360, Math.max(0, e.h)),
          s: Math.min(100, Math.max(0, e.s)),
          b: Math.min(100, Math.max(0, e.b))
        }
      }, 'validateHSB'),
      validateRGB: __name(function (e) {
        return {
          r: Math.min(255, Math.max(0, e.r)),
          g: Math.min(255, Math.max(0, e.g)),
          b: Math.min(255, Math.max(0, e.b))
        }
      }, 'validateRGB'),
      validateHEX: __name(function (e) {
        var t = 6 - e.length
        if (t > 0) {
          for (var n = [], o = 0; o < t; o++) n.push('0')
          n.push(e), (e = n.join(''))
        }
        return e
      }, 'validateHEX'),
      HEXtoRGB: __name(function (e) {
        var t = parseInt(e.indexOf('#') > -1 ? e.substring(1) : e, 16)
        return { r: t >> 16, g: (65280 & t) >> 8, b: 255 & t }
      }, 'HEXtoRGB'),
      HEXtoHSB: __name(function (e) {
        return this.RGBtoHSB(this.HEXtoRGB(e))
      }, 'HEXtoHSB'),
      RGBtoHSB: __name(function (e) {
        var t = { h: 0, s: 0, b: 0 },
          n = Math.min(e.r, e.g, e.b),
          o = Math.max(e.r, e.g, e.b),
          i = o - n
        return (
          (t.b = o),
          (t.s = 0 !== o ? (255 * i) / o : 0),
          0 !== t.s
            ? e.r === o
              ? (t.h = (e.g - e.b) / i)
              : e.g === o
                ? (t.h = 2 + (e.b - e.r) / i)
                : (t.h = 4 + (e.r - e.g) / i)
            : (t.h = -1),
          (t.h *= 60),
          t.h < 0 && (t.h += 360),
          (t.s *= 100 / 255),
          (t.b *= 100 / 255),
          t
        )
      }, 'RGBtoHSB'),
      HSBtoRGB: __name(function (e) {
        var t = { r: null, g: null, b: null },
          n = Math.round(e.h),
          o = Math.round((255 * e.s) / 100),
          i = Math.round((255 * e.b) / 100)
        if (0 === o) t = { r: i, g: i, b: i }
        else {
          var r = i,
            a = ((255 - o) * i) / 255,
            s = ((n % 60) * (r - a)) / 60
          360 === n && (n = 0),
            n < 60
              ? ((t.r = r), (t.b = a), (t.g = a + s))
              : n < 120
                ? ((t.g = r), (t.b = a), (t.r = r - s))
                : n < 180
                  ? ((t.g = r), (t.r = a), (t.b = a + s))
                  : n < 240
                    ? ((t.b = r), (t.r = a), (t.g = r - s))
                    : n < 300
                      ? ((t.b = r), (t.g = a), (t.r = a + s))
                      : n < 360
                        ? ((t.r = r), (t.g = a), (t.b = r - s))
                        : ((t.r = 0), (t.g = 0), (t.b = 0))
        }
        return { r: Math.round(t.r), g: Math.round(t.g), b: Math.round(t.b) }
      }, 'HSBtoRGB'),
      RGBtoHEX: __name(function (e) {
        var t = [e.r.toString(16), e.g.toString(16), e.b.toString(16)]
        for (var n in t) 1 === t[n].length && (t[n] = '0' + t[n])
        return t.join('')
      }, 'RGBtoHEX'),
      HSBtoHEX: __name(function (e) {
        return this.RGBtoHEX(this.HSBtoRGB(e))
      }, 'HSBtoHEX'),
      toHSB: __name(function (e) {
        var t
        if (e)
          switch (this.format) {
            case 'hex':
              t = this.HEXtoHSB(e)
              break
            case 'rgb':
              t = this.RGBtoHSB(e)
              break
            case 'hsb':
              t = e
          }
        else t = this.HEXtoHSB(this.defaultColor)
        return t
      }, 'toHSB'),
      onOverlayEnter: __name(function (e) {
        this.updateUI(),
          this.alignOverlay(),
          this.bindOutsideClickListener(),
          this.bindScrollListener(),
          this.bindResizeListener(),
          this.autoZIndex &&
            ZIndex.set(
              'overlay',
              e,
              this.baseZIndex,
              this.$primevue.config.zIndex.overlay
            ),
          this.$emit('show')
      }, 'onOverlayEnter'),
      onOverlayLeave: __name(function () {
        this.unbindOutsideClickListener(),
          this.unbindScrollListener(),
          this.unbindResizeListener(),
          this.clearRefs(),
          this.$emit('hide')
      }, 'onOverlayLeave'),
      onOverlayAfterLeave: __name(function (e) {
        this.autoZIndex && ZIndex.clear(e)
      }, 'onOverlayAfterLeave'),
      alignOverlay: __name(function () {
        'self' === this.appendTo
          ? relativePosition(this.picker, this.$refs.input)
          : absolutePosition(this.picker, this.$refs.input)
      }, 'alignOverlay'),
      onInputClick: __name(function () {
        this.disabled || (this.overlayVisible = !this.overlayVisible)
      }, 'onInputClick'),
      onInputKeydown: __name(function (e) {
        switch (e.code) {
          case 'Space':
            ;(this.overlayVisible = !this.overlayVisible), e.preventDefault()
            break
          case 'Escape':
          case 'Tab':
            this.overlayVisible = !1
        }
      }, 'onInputKeydown'),
      onInputBlur: __name(function (e) {
        var t, n
        null === (t = (n = this.formField).onBlur) || void 0 === t || t.call(n)
      }, 'onInputBlur'),
      onColorMousedown: __name(function (e) {
        this.disabled || (this.bindDragListeners(), this.onColorDragStart(e))
      }, 'onColorMousedown'),
      onColorDragStart: __name(function (e) {
        this.disabled ||
          ((this.colorDragging = !0),
          this.pickColor(e),
          this.$el.setAttribute('p-colorpicker-dragging', 'true'),
          !this.isUnstyled && addClass(this.$el, 'p-colorpicker-dragging'),
          e.preventDefault())
      }, 'onColorDragStart'),
      onDrag: __name(function (e) {
        this.colorDragging && (this.pickColor(e), e.preventDefault()),
          this.hueDragging && (this.pickHue(e), e.preventDefault())
      }, 'onDrag'),
      onDragEnd: __name(function () {
        ;(this.colorDragging = !1),
          (this.hueDragging = !1),
          this.$el.setAttribute('p-colorpicker-dragging', 'false'),
          !this.isUnstyled && removeClass(this.$el, 'p-colorpicker-dragging'),
          this.unbindDragListeners()
      }, 'onDragEnd'),
      onHueMousedown: __name(function (e) {
        this.disabled || (this.bindDragListeners(), this.onHueDragStart(e))
      }, 'onHueMousedown'),
      onHueDragStart: __name(function (e) {
        this.disabled ||
          ((this.hueDragging = !0),
          this.pickHue(e),
          !this.isUnstyled && addClass(this.$el, 'p-colorpicker-dragging'))
      }, 'onHueDragStart'),
      isInputClicked: __name(function (e) {
        return this.$refs.input && this.$refs.input.isSameNode(e.target)
      }, 'isInputClicked'),
      bindDragListeners: __name(function () {
        this.bindDocumentMouseMoveListener(), this.bindDocumentMouseUpListener()
      }, 'bindDragListeners'),
      unbindDragListeners: __name(function () {
        this.unbindDocumentMouseMoveListener(),
          this.unbindDocumentMouseUpListener()
      }, 'unbindDragListeners'),
      bindOutsideClickListener: __name(function () {
        var e = this
        this.outsideClickListener ||
          ((this.outsideClickListener = function (t) {
            e.overlayVisible &&
              e.picker &&
              !e.picker.contains(t.target) &&
              !e.isInputClicked(t) &&
              (e.overlayVisible = !1)
          }),
          document.addEventListener('click', this.outsideClickListener))
      }, 'bindOutsideClickListener'),
      unbindOutsideClickListener: __name(function () {
        this.outsideClickListener &&
          (document.removeEventListener('click', this.outsideClickListener),
          (this.outsideClickListener = null))
      }, 'unbindOutsideClickListener'),
      bindScrollListener: __name(function () {
        var e = this
        this.scrollHandler ||
          (this.scrollHandler = new ConnectedOverlayScrollHandler(
            this.$refs.container,
            function () {
              e.overlayVisible && (e.overlayVisible = !1)
            }
          )),
          this.scrollHandler.bindScrollListener()
      }, 'bindScrollListener'),
      unbindScrollListener: __name(function () {
        this.scrollHandler && this.scrollHandler.unbindScrollListener()
      }, 'unbindScrollListener'),
      bindResizeListener: __name(function () {
        var e = this
        this.resizeListener ||
          ((this.resizeListener = function () {
            e.overlayVisible && !isTouchDevice() && (e.overlayVisible = !1)
          }),
          window.addEventListener('resize', this.resizeListener))
      }, 'bindResizeListener'),
      unbindResizeListener: __name(function () {
        this.resizeListener &&
          (window.removeEventListener('resize', this.resizeListener),
          (this.resizeListener = null))
      }, 'unbindResizeListener'),
      bindDocumentMouseMoveListener: __name(function () {
        this.documentMouseMoveListener ||
          ((this.documentMouseMoveListener = this.onDrag.bind(this)),
          document.addEventListener(
            'mousemove',
            this.documentMouseMoveListener
          ))
      }, 'bindDocumentMouseMoveListener'),
      unbindDocumentMouseMoveListener: __name(function () {
        this.documentMouseMoveListener &&
          (document.removeEventListener(
            'mousemove',
            this.documentMouseMoveListener
          ),
          (this.documentMouseMoveListener = null))
      }, 'unbindDocumentMouseMoveListener'),
      bindDocumentMouseUpListener: __name(function () {
        this.documentMouseUpListener ||
          ((this.documentMouseUpListener = this.onDragEnd.bind(this)),
          document.addEventListener('mouseup', this.documentMouseUpListener))
      }, 'bindDocumentMouseUpListener'),
      unbindDocumentMouseUpListener: __name(function () {
        this.documentMouseUpListener &&
          (document.removeEventListener(
            'mouseup',
            this.documentMouseUpListener
          ),
          (this.documentMouseUpListener = null))
      }, 'unbindDocumentMouseUpListener'),
      pickerRef: __name(function (e) {
        this.picker = e
      }, 'pickerRef'),
      colorSelectorRef: __name(function (e) {
        this.colorSelector = e
      }, 'colorSelectorRef'),
      colorHandleRef: __name(function (e) {
        this.colorHandle = e
      }, 'colorHandleRef'),
      hueViewRef: __name(function (e) {
        this.hueView = e
      }, 'hueViewRef'),
      hueHandleRef: __name(function (e) {
        this.hueHandle = e
      }, 'hueHandleRef'),
      clearRefs: __name(function () {
        ;(this.picker = null),
          (this.colorSelector = null),
          (this.colorHandle = null),
          (this.hueView = null),
          (this.hueHandle = null)
      }, 'clearRefs'),
      onOverlayClick: __name(function (e) {
        OverlayEventBus.emit('overlay-click', {
          originalEvent: e,
          target: this.$el
        })
      }, 'onOverlayClick')
    },
    components: { Portal: script$w }
  }
function _typeof$4(e) {
  return (_typeof$4 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$4(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$4(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$4(Object(n), !0).forEach(function (t) {
          _defineProperty$4(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$4(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$4(e, t, n) {
  return (
    (t = _toPropertyKey$4(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$4(e) {
  var t = _toPrimitive$4(e, 'string')
  return 'symbol' == _typeof$4(t) ? t : t + ''
}
function _toPrimitive$4(e, t) {
  if ('object' != _typeof$4(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$4(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$4, '_typeof$4'),
  __name(ownKeys$4, 'ownKeys$4'),
  __name(_objectSpread$4, '_objectSpread$4'),
  __name(_defineProperty$4, '_defineProperty$4'),
  __name(_toPropertyKey$4, '_toPropertyKey$4'),
  __name(_toPrimitive$4, '_toPrimitive$4')
var _hoisted_1$e = ['id', 'tabindex', 'disabled']
function render$7(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('Portal')
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps({ ref: 'container', class: e.cx('root') }, e.ptmi('root')),
      [
        e.inline
          ? Vue.createCommentVNode('', !0)
          : (Vue.openBlock(),
            Vue.createElementBlock(
              'input',
              Vue.mergeProps(
                {
                  key: 0,
                  ref: 'input',
                  id: e.inputId,
                  type: 'text',
                  class: e.cx('preview'),
                  readonly: '',
                  tabindex: e.tabindex,
                  disabled: e.disabled,
                  onClick:
                    t[0] ||
                    (t[0] = function () {
                      return (
                        r.onInputClick && r.onInputClick.apply(r, arguments)
                      )
                    }),
                  onKeydown:
                    t[1] ||
                    (t[1] = function () {
                      return (
                        r.onInputKeydown && r.onInputKeydown.apply(r, arguments)
                      )
                    }),
                  onBlur:
                    t[2] ||
                    (t[2] = function () {
                      return r.onInputBlur && r.onInputBlur.apply(r, arguments)
                    })
                },
                e.ptm('preview')
              ),
              null,
              16,
              _hoisted_1$e
            )),
        Vue.createVNode(
          a,
          { appendTo: e.appendTo, disabled: e.inline },
          {
            default: Vue.withCtx(function () {
              return [
                Vue.createVNode(
                  Vue.Transition,
                  Vue.mergeProps(
                    {
                      name: 'p-connected-overlay',
                      onEnter: r.onOverlayEnter,
                      onLeave: r.onOverlayLeave,
                      onAfterLeave: r.onOverlayAfterLeave
                    },
                    e.ptm('transition')
                  ),
                  {
                    default: Vue.withCtx(function () {
                      return [
                        e.inline || i.overlayVisible
                          ? (Vue.openBlock(),
                            Vue.createElementBlock(
                              'div',
                              Vue.mergeProps(
                                {
                                  key: 0,
                                  ref: r.pickerRef,
                                  class: [
                                    e.cx('panel'),
                                    e.panelClass,
                                    e.overlayClass
                                  ],
                                  onClick:
                                    t[11] ||
                                    (t[11] = function () {
                                      return (
                                        r.onOverlayClick &&
                                        r.onOverlayClick.apply(r, arguments)
                                      )
                                    })
                                },
                                _objectSpread$4(
                                  _objectSpread$4({}, e.ptm('panel')),
                                  e.ptm('overlay')
                                )
                              ),
                              [
                                Vue.createElementVNode(
                                  'div',
                                  Vue.mergeProps(
                                    { class: e.cx('content') },
                                    e.ptm('content')
                                  ),
                                  [
                                    Vue.createElementVNode(
                                      'div',
                                      Vue.mergeProps(
                                        {
                                          ref: r.colorSelectorRef,
                                          class: e.cx('colorSelector'),
                                          onMousedown:
                                            t[3] ||
                                            (t[3] = function (e) {
                                              return r.onColorMousedown(e)
                                            }),
                                          onTouchstart:
                                            t[4] ||
                                            (t[4] = function (e) {
                                              return r.onColorDragStart(e)
                                            }),
                                          onTouchmove:
                                            t[5] ||
                                            (t[5] = function (e) {
                                              return r.onDrag(e)
                                            }),
                                          onTouchend:
                                            t[6] ||
                                            (t[6] = function (e) {
                                              return r.onDragEnd()
                                            })
                                        },
                                        e.ptm('colorSelector')
                                      ),
                                      [
                                        Vue.createElementVNode(
                                          'div',
                                          Vue.mergeProps(
                                            { class: e.cx('colorBackground') },
                                            e.ptm('colorBackground')
                                          ),
                                          [
                                            Vue.createElementVNode(
                                              'div',
                                              Vue.mergeProps(
                                                {
                                                  ref: r.colorHandleRef,
                                                  class: e.cx('colorHandle')
                                                },
                                                e.ptm('colorHandle')
                                              ),
                                              null,
                                              16
                                            )
                                          ],
                                          16
                                        )
                                      ],
                                      16
                                    ),
                                    Vue.createElementVNode(
                                      'div',
                                      Vue.mergeProps(
                                        {
                                          ref: r.hueViewRef,
                                          class: e.cx('hue'),
                                          onMousedown:
                                            t[7] ||
                                            (t[7] = function (e) {
                                              return r.onHueMousedown(e)
                                            }),
                                          onTouchstart:
                                            t[8] ||
                                            (t[8] = function (e) {
                                              return r.onHueDragStart(e)
                                            }),
                                          onTouchmove:
                                            t[9] ||
                                            (t[9] = function (e) {
                                              return r.onDrag(e)
                                            }),
                                          onTouchend:
                                            t[10] ||
                                            (t[10] = function (e) {
                                              return r.onDragEnd()
                                            })
                                        },
                                        e.ptm('hue')
                                      ),
                                      [
                                        Vue.createElementVNode(
                                          'div',
                                          Vue.mergeProps(
                                            {
                                              ref: r.hueHandleRef,
                                              class: e.cx('hueHandle')
                                            },
                                            e.ptm('hueHandle')
                                          ),
                                          null,
                                          16
                                        )
                                      ],
                                      16
                                    )
                                  ],
                                  16
                                )
                              ],
                              16
                            ))
                          : Vue.createCommentVNode('', !0)
                      ]
                    }),
                    _: 1
                  },
                  16,
                  ['onEnter', 'onLeave', 'onAfterLeave']
                )
              ]
            }),
            _: 1
          },
          8,
          ['appendTo', 'disabled']
        )
      ],
      16
    )
  )
}
__name(render$7, 'render$7'), (script$8.render = render$7)
const _hoisted_1$d = { class: 'p-fluid' },
  _hoisted_2$9 = { class: 'field icon-field' },
  _hoisted_3$6 = { for: 'icon' },
  _hoisted_4$4 = { class: 'field color-field' },
  _hoisted_5$3 = { for: 'color' },
  _hoisted_6$2 = { class: 'color-picker-container' },
  _hoisted_7$1 = {
    key: 1,
    class: 'pi pi-palette',
    style: { fontSize: '1.2rem' }
  },
  _sfc_main$f = Vue.defineComponent({
    __name: 'CustomizationDialog',
    props: { modelValue: { type: Boolean }, initialIcon: {}, initialColor: {} },
    emits: ['update:modelValue', 'confirm'],
    setup(e, { emit: t }) {
      const { t: n } = VueI18n.useI18n(),
        o = e,
        i = t,
        r = Vue.computed({
          get: __name(() => o.modelValue, 'get'),
          set: __name((e) => i('update:modelValue', e), 'set')
        }),
        a = useNodeBookmarkStore(),
        s = [
          { name: n('bookmark'), value: a.defaultBookmarkIcon },
          { name: n('folder'), value: 'pi-folder' },
          { name: n('star'), value: 'pi-star' },
          { name: n('heart'), value: 'pi-heart' },
          { name: n('file'), value: 'pi-file' },
          { name: n('inbox'), value: 'pi-inbox' },
          { name: n('box'), value: 'pi-box' },
          { name: n('briefcase'), value: 'pi-briefcase' }
        ],
        l = [
          { name: n('default'), value: a.defaultBookmarkColor },
          { name: n('blue'), value: '#007bff' },
          { name: n('green'), value: '#28a745' },
          { name: n('red'), value: '#dc3545' },
          { name: n('pink'), value: '#e83e8c' },
          { name: n('yellow'), value: '#ffc107' },
          { name: n('custom'), value: 'custom' }
        ],
        c = s.find((e) => e.value === a.defaultBookmarkIcon),
        d = l.find((e) => e.value === a.defaultBookmarkColor),
        u = Vue.ref(c),
        p = Vue.ref(d),
        h = Vue.computed(() =>
          'custom' === p.value.value ? `#${m.value}` : p.value.value
        ),
        m = Vue.ref('000000'),
        f = __name(() => {
          r.value = !1
        }, 'closeDialog'),
        _ = __name(() => {
          i('confirm', u.value.value, h.value), f()
        }, 'confirmCustomization'),
        g = __name(() => {
          u.value = s.find((e) => e.value === o.initialIcon) || c
          const e = l.find((e) => e.value === o.initialColor)
          o.initialColor
            ? e
              ? (p.value = e)
              : ((m.value = o.initialColor.replace('#', '')),
                (p.value = { name: 'Custom', value: 'custom' }))
            : (p.value = d)
        }, 'resetCustomization')
      return (
        Vue.watch(
          () => o.modelValue,
          (e) => {
            e && g()
          },
          { immediate: !0 }
        ),
        (e, t) => {
          const n = Vue.resolveDirective('tooltip')
          return (
            Vue.openBlock(),
            Vue.createBlock(
              Vue.unref(script$b),
              {
                visible: r.value,
                'onUpdate:visible': t[3] || (t[3] = (e) => (r.value = e)),
                header: e.$t('customizeFolder')
              },
              {
                footer: Vue.withCtx(() => [
                  Vue.createVNode(
                    Vue.unref(script$K),
                    {
                      label: e.$t('reset'),
                      icon: 'pi pi-refresh',
                      onClick: g,
                      class: 'p-button-text'
                    },
                    null,
                    8,
                    ['label']
                  ),
                  Vue.createVNode(
                    Vue.unref(script$K),
                    {
                      label: e.$t('confirm'),
                      icon: 'pi pi-check',
                      onClick: _,
                      autofocus: ''
                    },
                    null,
                    8,
                    ['label']
                  )
                ]),
                default: Vue.withCtx(() => [
                  Vue.createElementVNode('div', _hoisted_1$d, [
                    Vue.createElementVNode('div', _hoisted_2$9, [
                      Vue.createElementVNode(
                        'label',
                        _hoisted_3$6,
                        Vue.toDisplayString(e.$t('icon')),
                        1
                      ),
                      Vue.createVNode(
                        Vue.unref(script$9),
                        {
                          modelValue: u.value,
                          'onUpdate:modelValue':
                            t[0] || (t[0] = (e) => (u.value = e)),
                          options: s,
                          optionLabel: 'name',
                          dataKey: 'value'
                        },
                        {
                          option: Vue.withCtx((e) => [
                            Vue.createElementVNode(
                              'i',
                              {
                                class: Vue.normalizeClass([
                                  'pi',
                                  e.option.value,
                                  'mr-2'
                                ]),
                                style: Vue.normalizeStyle({ color: h.value })
                              },
                              null,
                              6
                            )
                          ]),
                          _: 1
                        },
                        8,
                        ['modelValue']
                      )
                    ]),
                    Vue.createVNode(Vue.unref(script$G)),
                    Vue.createElementVNode('div', _hoisted_4$4, [
                      Vue.createElementVNode(
                        'label',
                        _hoisted_5$3,
                        Vue.toDisplayString(e.$t('color')),
                        1
                      ),
                      Vue.createElementVNode('div', _hoisted_6$2, [
                        Vue.createVNode(
                          Vue.unref(script$9),
                          {
                            modelValue: p.value,
                            'onUpdate:modelValue':
                              t[1] || (t[1] = (e) => (p.value = e)),
                            options: l,
                            optionLabel: 'name',
                            dataKey: 'value'
                          },
                          {
                            option: Vue.withCtx((t) => [
                              'custom' !== t.option.value
                                ? (Vue.openBlock(),
                                  Vue.createElementBlock(
                                    'div',
                                    {
                                      key: 0,
                                      style: Vue.normalizeStyle({
                                        width: '20px',
                                        height: '20px',
                                        backgroundColor: t.option.value,
                                        borderRadius: '50%'
                                      })
                                    },
                                    null,
                                    4
                                  ))
                                : Vue.withDirectives(
                                    (Vue.openBlock(),
                                    Vue.createElementBlock(
                                      'i',
                                      _hoisted_7$1,
                                      null,
                                      512
                                    )),
                                    [[n, e.$t('customColor')]]
                                  )
                            ]),
                            _: 1
                          },
                          8,
                          ['modelValue']
                        ),
                        'custom' === p.value.value
                          ? (Vue.openBlock(),
                            Vue.createBlock(
                              Vue.unref(script$8),
                              {
                                key: 0,
                                modelValue: m.value,
                                'onUpdate:modelValue':
                                  t[2] || (t[2] = (e) => (m.value = e))
                              },
                              null,
                              8,
                              ['modelValue']
                            ))
                          : Vue.createCommentVNode('', !0)
                      ])
                    ])
                  ])
                ]),
                _: 1
              },
              8,
              ['visible', 'header']
            )
          )
        }
      )
    }
  }),
  FolderCustomizationDialog = _export_sfc(_sfc_main$f, [
    ['__scopeId', 'data-v-91077f2a']
  ]),
  _sfc_main$e = Vue.defineComponent({
    __name: 'NodeBookmarkTreeExplorer',
    props: { filteredNodeDefs: {} },
    setup(e, { expose: t }) {
      const n = e,
        o = Vue.ref({}),
        { expandNode: i, toggleNodeOnEvent: r } = useTreeExpansion(o),
        a = useNodeBookmarkStore(),
        s = Vue.computed(() => {
          const e = __name((t) => {
            if (t.leaf)
              return n.filteredNodeDefs.some((e) => e.name === t.data.name)
                ? t
                : null
            const o = t.children?.map(e).filter((e) => null !== e)
            return o && o.length > 0 ? { ...t, children: o } : null
          }, 'filterTree')
          return n.filteredNodeDefs.length
            ? e(a.bookmarkedRoot) || {
                key: 'root',
                label: 'Root',
                children: []
              }
            : a.bookmarkedRoot
        })
      Vue.watch(
        () => n.filteredNodeDefs,
        (e) => {
          e.length && Vue.nextTick(() => i(s.value))
        }
      )
      const { t: l } = VueI18n.useI18n(),
        c = __name(
          (e) => [
            {
              label: l('newFolder'),
              icon: 'pi pi-folder-plus',
              command: __name(() => {
                p(e)
              }, 'command'),
              visible: !e?.leaf
            },
            {
              label: l('customize'),
              icon: 'pi pi-palette',
              command: __name(() => {
                const t = a.bookmarksCustomization[e.data.nodePath]
                ;(f.value = t?.icon || a.defaultBookmarkIcon),
                  (_.value = t?.color || a.defaultBookmarkColor),
                  (m.value = !0),
                  (g.value = e.data.nodePath)
              }, 'command'),
              visible: !e?.leaf
            }
          ],
          'extraMenuItems'
        ),
        d = Vue.computed(() => {
          const e = __name((t) => {
            const n = t.children?.map(e),
              o = n?.sort((e, t) =>
                e.leaf === t.leaf
                  ? e.label.localeCompare(t.label)
                  : e.leaf
                    ? 1
                    : -1
              )
            return {
              key: t.key,
              label: t.leaf ? t.data.display_name : t.label,
              leaf: t.leaf,
              data: t.data,
              getIcon: __name((e) => {
                if (e.leaf) return 'pi pi-circle-fill'
                const t = a.bookmarksCustomization[e.data?.nodePath]
                return t?.icon ? 'pi ' + t.icon : 'pi pi-bookmark-fill'
              }, 'getIcon'),
              children: o,
              draggable: t.leaf,
              droppable: !t.leaf,
              handleDrop: __name((e, t) => {
                const n = t.data.data
                a.isBookmarked(n) && a.toggleBookmark(n)
                const o = e.data.category + '/' + n.name
                a.addBookmark(o)
              }, 'handleDrop'),
              handleClick: __name((e, t) => {
                e.leaf
                  ? app$1.addNodeOnGraph(e.data, {
                      pos: app$1.getCanvasCenter()
                    })
                  : r(t, e)
              }, 'handleClick'),
              contextMenuItems: c,
              ...(t.leaf
                ? {}
                : {
                    handleRename: h,
                    handleDelete: __name((e) => {
                      a.deleteBookmarkFolder(e.data)
                    }, 'handleDelete')
                  })
            }
          }, 'fillNodeInfo')
          return e(s.value)
        }),
        u = Vue.ref(null),
        p = __name((e) => {
          const t = 'root/' + a.addNewBookmarkFolder(e?.data).slice(0, -1)
          Vue.nextTick(() => {
            u.value?.renameCommand(findNodeByKey(d.value, t)),
              e && (o.value[e.key] = !0)
          })
        }, 'addNewBookmarkFolder')
      t({ addNewBookmarkFolder: p })
      const h = __name((e, t) => {
          e.data && e.data.isDummyFolder && a.renameBookmarkFolder(e.data, t)
        }, 'handleRename'),
        m = Vue.ref(!1),
        f = Vue.ref(a.defaultBookmarkIcon),
        _ = Vue.ref(a.defaultBookmarkColor),
        g = Vue.ref(''),
        v = __name((e, t) => {
          g.value &&
            a.updateBookmarkCustomization(g.value, { icon: e, color: t })
        }, 'updateCustomization')
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock(
          Vue.Fragment,
          null,
          [
            Vue.createVNode(
              TreeExplorer,
              {
                class: 'node-lib-bookmark-tree-explorer',
                ref_key: 'treeExplorerRef',
                ref: u,
                roots: d.value.children,
                expandedKeys: o.value
              },
              {
                folder: Vue.withCtx(({ node: e }) => [
                  Vue.createVNode(_sfc_main$g, { node: e }, null, 8, ['node'])
                ]),
                node: Vue.withCtx(({ node: e }) => [
                  Vue.createVNode(NodeTreeLeaf, { node: e }, null, 8, ['node'])
                ]),
                _: 1
              },
              8,
              ['roots', 'expandedKeys']
            ),
            Vue.createVNode(
              FolderCustomizationDialog,
              {
                modelValue: m.value,
                'onUpdate:modelValue': t[0] || (t[0] = (e) => (m.value = e)),
                onConfirm: v,
                initialIcon: f.value,
                initialColor: _.value
              },
              null,
              8,
              ['modelValue', 'initialIcon', 'initialColor']
            )
          ],
          64
        )
      )
    }
  }),
  _hoisted_1$c = { class: '_content' },
  _hoisted_2$8 = { class: '_footer' },
  _sfc_main$d = Vue.defineComponent({
    __name: 'NodeSearchFilter',
    emits: ['addFilter'],
    setup(e, { emit: t }) {
      const n = Vue.computed(() => a.nodeSearchService.nodeFilters),
        o = Vue.ref(),
        i = Vue.computed(() => o.value?.fuseSearch.data ?? []),
        r = Vue.ref(''),
        a = useNodeDefStore()
      Vue.onMounted(() => {
        ;(o.value = a.nodeSearchService.nodeFilters[0]), l()
      })
      const s = t,
        l = __name(() => {
          i.value.includes(r.value) || (r.value = i.value[0])
        }, 'updateSelectedFilterValue'),
        c = __name(() => {
          s('addFilter', [o.value, r.value])
        }, 'submit')
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock(
          Vue.Fragment,
          null,
          [
            Vue.createElementVNode('div', _hoisted_1$c, [
              Vue.createVNode(
                Vue.unref(script$9),
                {
                  class: 'filter-type-select',
                  modelValue: o.value,
                  'onUpdate:modelValue': t[0] || (t[0] = (e) => (o.value = e)),
                  options: n.value,
                  allowEmpty: !1,
                  optionLabel: 'name',
                  onChange: l
                },
                null,
                8,
                ['modelValue', 'options']
              ),
              Vue.createVNode(
                Vue.unref(script$v),
                {
                  class: 'filter-value-select',
                  modelValue: r.value,
                  'onUpdate:modelValue': t[1] || (t[1] = (e) => (r.value = e)),
                  options: i.value,
                  filter: ''
                },
                null,
                8,
                ['modelValue', 'options']
              )
            ]),
            Vue.createElementVNode('div', _hoisted_2$8, [
              Vue.createVNode(
                Vue.unref(script$K),
                { type: 'button', label: e.$t('add'), onClick: c },
                null,
                8,
                ['label']
              )
            ])
          ],
          64
        )
      )
    }
  }),
  NodeSearchFilter = _export_sfc(_sfc_main$d, [
    ['__scopeId', 'data-v-e7b35fd9']
  ]),
  _sfc_main$c = Vue.defineComponent({
    __name: 'NodeLibrarySidebarTab',
    setup(e) {
      const t = useNodeDefStore(),
        n = useNodeBookmarkStore(),
        o = Vue.ref({}),
        { expandNode: i, toggleNodeOnEvent: r } = useTreeExpansion(o),
        a = Vue.ref(null),
        s = Vue.ref(null),
        l = Vue.ref(!1),
        c = Vue.ref(''),
        d = Vue.computed(() => {
          const e = h.value || t.nodeTree
          return l.value ? sortedTree(e, { groupLeaf: !0 }) : e
        }),
        u = Vue.computed(() => {
          const e = __name((t) => {
            const n = t.children?.map(e)
            return {
              key: t.key,
              label: t.leaf ? t.data.display_name : t.label,
              leaf: t.leaf,
              data: t.data,
              getIcon: __name((e) => {
                if (e.leaf) return 'pi pi-circle-fill'
              }, 'getIcon'),
              children: n,
              draggable: t.leaf,
              handleClick: __name((e, t) => {
                e.leaf
                  ? app$1.addNodeOnGraph(e.data, {
                      pos: app$1.getCanvasCenter()
                    })
                  : r(t, e)
              }, 'handleClick')
            }
          }, 'fillNodeInfo')
          return e(d.value)
        }),
        p = Vue.ref([]),
        h = Vue.computed(() =>
          p.value.length ? buildNodeDefTree(p.value) : null
        ),
        m = Vue.ref([]),
        f = __name((e) => {
          if (0 === e.length && !m.value.length)
            return (p.value = []), void (o.value = {})
          const n = m.value.map((e) => e.filter)
          ;(p.value = t.nodeSearchService.searchNode(
            e,
            n,
            { limit: 64 },
            { matchWildcards: !1 }
          )),
            Vue.nextTick(() => {
              i(h.value)
            })
        }, 'handleSearch'),
        _ = __name((e) => {
          m.value.push({
            filter: e,
            badge: e[0].invokeSequence.toUpperCase(),
            badgeClass: e[0].invokeSequence + '-badge',
            text: e[1],
            id: +new Date()
          }),
            f(c.value)
        }, 'onAddFilter'),
        g = __name((e) => {
          const t = m.value.findIndex((t) => t === e)
          ;-1 !== t && m.value.splice(t, 1), f(c.value)
        }, 'onRemoveFilter')
      return (e, t) => {
        const i = Vue.resolveDirective('tooltip')
        return (
          Vue.openBlock(),
          Vue.createElementBlock(
            Vue.Fragment,
            null,
            [
              Vue.createVNode(
                SidebarTabTemplate,
                {
                  title: e.$t('sideToolbar.nodeLibrary'),
                  class: 'bg-[var(--p-tree-background)]'
                },
                {
                  'tool-buttons': Vue.withCtx(() => [
                    Vue.withDirectives(
                      Vue.createVNode(
                        Vue.unref(script$K),
                        {
                          class: 'new-folder-button',
                          icon: 'pi pi-folder-plus',
                          text: '',
                          severity: 'secondary',
                          onClick:
                            t[0] ||
                            (t[0] = (e) => a.value?.addNewBookmarkFolder())
                        },
                        null,
                        512
                      ),
                      [[i, e.$t('newFolder'), void 0, { bottom: !0 }]]
                    ),
                    Vue.withDirectives(
                      Vue.createVNode(
                        Vue.unref(script$K),
                        {
                          class: 'sort-button',
                          icon: l.value
                            ? 'pi pi-sort-alpha-down'
                            : 'pi pi-sort-alt',
                          text: '',
                          severity: 'secondary',
                          onClick: t[1] || (t[1] = (e) => (l.value = !l.value))
                        },
                        null,
                        8,
                        ['icon']
                      ),
                      [
                        [
                          i,
                          e.$t('sideToolbar.nodeLibraryTab.sortOrder'),
                          void 0,
                          { bottom: !0 }
                        ]
                      ]
                    )
                  ]),
                  header: Vue.withCtx(() => [
                    Vue.createVNode(
                      SearchBox,
                      {
                        class: 'node-lib-search-box p-2 2xl:p-4',
                        modelValue: c.value,
                        'onUpdate:modelValue':
                          t[2] || (t[2] = (e) => (c.value = e)),
                        onSearch: f,
                        onShowFilter: t[3] || (t[3] = (e) => s.value.toggle(e)),
                        onRemoveFilter: g,
                        placeholder: e.$t('searchNodes') + '...',
                        'filter-icon': 'pi pi-filter',
                        filters: m.value
                      },
                      null,
                      8,
                      ['modelValue', 'placeholder', 'filters']
                    ),
                    Vue.createVNode(
                      Vue.unref(script$e),
                      { ref_key: 'searchFilter', ref: s, class: 'ml-[-13px]' },
                      {
                        default: Vue.withCtx(() => [
                          Vue.createVNode(NodeSearchFilter, { onAddFilter: _ })
                        ]),
                        _: 1
                      },
                      512
                    )
                  ]),
                  body: Vue.withCtx(() => [
                    Vue.createVNode(
                      _sfc_main$e,
                      {
                        ref_key: 'nodeBookmarkTreeExplorerRef',
                        ref: a,
                        'filtered-node-defs': p.value
                      },
                      null,
                      8,
                      ['filtered-node-defs']
                    ),
                    Vue.withDirectives(
                      Vue.createVNode(
                        Vue.unref(script$G),
                        { type: 'dashed', class: 'm-2' },
                        null,
                        512
                      ),
                      [[Vue.vShow, Vue.unref(n).bookmarks.length > 0]]
                    ),
                    Vue.createVNode(
                      TreeExplorer,
                      {
                        class: 'node-lib-tree-explorer',
                        roots: u.value.children,
                        expandedKeys: o.value,
                        'onUpdate:expandedKeys':
                          t[4] || (t[4] = (e) => (o.value = e))
                      },
                      {
                        node: Vue.withCtx(({ node: e }) => [
                          Vue.createVNode(NodeTreeLeaf, { node: e }, null, 8, [
                            'node'
                          ])
                        ]),
                        _: 1
                      },
                      8,
                      ['roots', 'expandedKeys']
                    )
                  ]),
                  _: 1
                },
                8,
                ['title']
              ),
              t[5] ||
                (t[5] = Vue.createElementVNode(
                  'div',
                  { id: 'node-library-node-preview-container' },
                  null,
                  -1
                ))
            ],
            64
          )
        )
      }
    }
  }),
  useNodeLibrarySidebarTab = __name(() => {
    const { t: e } = VueI18n.useI18n()
    return {
      id: 'node-library',
      icon: 'pi pi-book',
      title: e('sideToolbar.nodeLibrary'),
      tooltip: e('sideToolbar.nodeLibrary'),
      component: Vue.markRaw(_sfc_main$c),
      type: 'vue'
    }
  }, 'useNodeLibrarySidebarTab')
var PrimeVueConfirmSymbol = Symbol()
function useConfirm() {
  var e = Vue.inject(PrimeVueConfirmSymbol)
  if (!e) throw new Error('No PrimeVue Confirmation provided!')
  return e
}
__name(useConfirm, 'useConfirm')
var ConfirmationEventBus = EventBus(),
  theme$4 = __name(function (e) {
    var t = e.dt
    return '\n.p-confirmpopup {\n    position: absolute;\n    margin-top: '
      .concat(
        t('confirmpopup.gutter'),
        ';\n    top: 0;\n    left: 0;\n    background: '
      )
      .concat(t('confirmpopup.background'), ';\n    color: ')
      .concat(t('confirmpopup.color'), ';\n    border: 1px solid ')
      .concat(t('confirmpopup.border.color'), ';\n    border-radius: ')
      .concat(t('confirmpopup.border.radius'), ';\n    box-shadow: ')
      .concat(
        t('confirmpopup.shadow'),
        ';\n}\n\n.p-confirmpopup-content {\n    display: flex;\n    align-items: center;\n    padding: '
      )
      .concat(t('confirmpopup.content.padding'), ';\n    gap: ')
      .concat(
        t('confirmpopup.content.gap'),
        ';\n}\n\n.p-confirmpopup-icon {\n    font-size: '
      )
      .concat(t('confirmpopup.icon.size'), ';\n    width: ')
      .concat(t('confirmpopup.icon.size'), ';\n    height: ')
      .concat(t('confirmpopup.icon.size'), ';\n    color: ')
      .concat(
        t('confirmpopup.icon.color'),
        ';\n}\n\n.p-confirmpopup-footer {\n    display: flex;\n    justify-content: flex-end;\n    gap: '
      )
      .concat(t('confirmpopup.footer.gap'), ';\n    padding: ')
      .concat(
        t('confirmpopup.footer.padding'),
        ';\n}\n\n.p-confirmpopup-footer button {\n    width: auto;\n}\n\n.p-confirmpopup-footer button:last-child {\n    margin: 0;\n}\n\n.p-confirmpopup-flipped {\n    margin-block-start: calc('
      )
      .concat(t('confirmpopup.gutter'), ' * -1);\n    margin-block-end: ')
      .concat(
        t('confirmpopup.gutter'),
        ';\n}\n\n.p-confirmpopup-enter-from {\n    opacity: 0;\n    transform: scaleY(0.8);\n}\n\n.p-confirmpopup-leave-to {\n    opacity: 0;\n}\n\n.p-confirmpopup-enter-active {\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1), opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-confirmpopup-leave-active {\n    transition: opacity 0.1s linear;\n}\n\n.p-confirmpopup:after,\n.p-confirmpopup:before {\n    bottom: 100%;\n    left: calc('
      )
      .concat(t('confirmpopup.arrow.offset'), ' + ')
      .concat(
        t('confirmpopup.arrow.left'),
        ');\n    content: " ";\n    height: 0;\n    width: 0;\n    position: absolute;\n    pointer-events: none;\n}\n\n.p-confirmpopup:after {\n    border-width: calc('
      )
      .concat(
        t('confirmpopup.gutter'),
        ' - 2px);\n    margin-left: calc(-1 * ('
      )
      .concat(
        t('confirmpopup.gutter'),
        ' - 2px));\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: '
      )
      .concat(
        t('confirmpopup.background'),
        ';\n}\n\n.p-confirmpopup:before {\n    border-width: '
      )
      .concat(t('confirmpopup.gutter'), ';\n    margin-left: calc(-1 * ')
      .concat(
        t('confirmpopup.gutter'),
        ');\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: '
      )
      .concat(
        t('confirmpopup.border.color'),
        ';\n}\n\n.p-confirmpopup-flipped:after,\n.p-confirmpopup-flipped:before {\n    bottom: auto;\n    top: 100%;\n}\n\n.p-confirmpopup-flipped:after {\n    border-bottom-color: transparent;\n    border-top-color: '
      )
      .concat(
        t('confirmpopup.background'),
        ';\n}\n\n.p-confirmpopup-flipped:before {\n    border-bottom-color: transparent;\n    border-top-color: '
      )
      .concat(t('confirmpopup.border.color'), ';\n}\n')
  }, 'theme'),
  classes$4 = {
    root: 'p-confirmpopup p-component',
    content: 'p-confirmpopup-content',
    icon: 'p-confirmpopup-icon',
    message: 'p-confirmpopup-message',
    footer: 'p-confirmpopup-footer',
    pcRejectButton: 'p-confirmpopup-reject-button',
    pcAcceptButton: 'p-confirmpopup-accept-button'
  },
  ConfirmPopupStyle = BaseStyle.extend({
    name: 'confirmpopup',
    theme: theme$4,
    classes: classes$4
  }),
  script$1$3 = {
    name: 'BaseConfirmPopup',
    extends: script$Y,
    props: { group: String },
    style: ConfirmPopupStyle,
    provide: __name(function () {
      return { $pcConfirmPopup: this, $parentInstance: this }
    }, 'provide')
  },
  script$7 = {
    name: 'ConfirmPopup',
    extends: script$1$3,
    inheritAttrs: !1,
    data: __name(function () {
      return {
        visible: !1,
        confirmation: null,
        autoFocusAccept: null,
        autoFocusReject: null,
        target: null
      }
    }, 'data'),
    target: null,
    outsideClickListener: null,
    scrollHandler: null,
    resizeListener: null,
    container: null,
    confirmListener: null,
    closeListener: null,
    mounted: __name(function () {
      var e = this
      ;(this.confirmListener = function (t) {
        t &&
          t.group === e.group &&
          ((e.confirmation = t),
          (e.target = t.target),
          e.confirmation.onShow && e.confirmation.onShow(),
          (e.visible = !0))
      }),
        (this.closeListener = function () {
          ;(e.visible = !1), (e.confirmation = null)
        }),
        ConfirmationEventBus.on('confirm', this.confirmListener),
        ConfirmationEventBus.on('close', this.closeListener)
    }, 'mounted'),
    beforeUnmount: __name(function () {
      ConfirmationEventBus.off('confirm', this.confirmListener),
        ConfirmationEventBus.off('close', this.closeListener),
        this.unbindOutsideClickListener(),
        this.scrollHandler &&
          (this.scrollHandler.destroy(), (this.scrollHandler = null)),
        this.unbindResizeListener(),
        this.container &&
          (ZIndex.clear(this.container), (this.container = null)),
        (this.target = null),
        (this.confirmation = null)
    }, 'beforeUnmount'),
    methods: {
      accept: __name(function () {
        this.confirmation.accept && this.confirmation.accept(),
          (this.visible = !1)
      }, 'accept'),
      reject: __name(function () {
        this.confirmation.reject && this.confirmation.reject(),
          (this.visible = !1)
      }, 'reject'),
      onHide: __name(function () {
        this.confirmation.onHide && this.confirmation.onHide(),
          (this.visible = !1)
      }, 'onHide'),
      onAcceptKeydown: __name(function (e) {
        ;('Space' !== e.code &&
          'Enter' !== e.code &&
          'NumpadEnter' !== e.code) ||
          (this.accept(), focus(this.target), e.preventDefault())
      }, 'onAcceptKeydown'),
      onRejectKeydown: __name(function (e) {
        ;('Space' !== e.code &&
          'Enter' !== e.code &&
          'NumpadEnter' !== e.code) ||
          (this.reject(), focus(this.target), e.preventDefault())
      }, 'onRejectKeydown'),
      onEnter: __name(function (e) {
        ;(this.autoFocusAccept =
          void 0 === this.confirmation.defaultFocus ||
          'accept' === this.confirmation.defaultFocus),
          (this.autoFocusReject = 'reject' === this.confirmation.defaultFocus),
          (this.target = this.target || document.activeElement),
          this.bindOutsideClickListener(),
          this.bindScrollListener(),
          this.bindResizeListener(),
          ZIndex.set('overlay', e, this.$primevue.config.zIndex.overlay)
      }, 'onEnter'),
      onAfterEnter: __name(function () {
        this.focus()
      }, 'onAfterEnter'),
      onLeave: __name(function () {
        ;(this.autoFocusAccept = null),
          (this.autoFocusReject = null),
          focus(this.target),
          (this.target = null),
          this.unbindOutsideClickListener(),
          this.unbindScrollListener(),
          this.unbindResizeListener()
      }, 'onLeave'),
      onAfterLeave: __name(function (e) {
        ZIndex.clear(e)
      }, 'onAfterLeave'),
      alignOverlay: __name(function () {
        absolutePosition(this.container, this.target, !1)
        var e = getOffset(this.container),
          t = getOffset(this.target),
          n = 0
        e.left < t.left && (n = t.left - e.left),
          this.container.style.setProperty(
            $dt('confirmpopup.arrow.left').name,
            ''.concat(n, 'px')
          ),
          e.top < t.top &&
            (this.container.setAttribute('data-p-confirmpopup-flipped', 'true'),
            !this.isUnstyled &&
              addClass(this.container, 'p-confirmpopup-flipped'))
      }, 'alignOverlay'),
      bindOutsideClickListener: __name(function () {
        var e = this
        this.outsideClickListener ||
          ((this.outsideClickListener = function (t) {
            e.visible &&
            e.container &&
            !e.container.contains(t.target) &&
            !e.isTargetClicked(t)
              ? (e.confirmation.onHide && e.confirmation.onHide(),
                (e.visible = !1))
              : e.alignOverlay()
          }),
          document.addEventListener('click', this.outsideClickListener))
      }, 'bindOutsideClickListener'),
      unbindOutsideClickListener: __name(function () {
        this.outsideClickListener &&
          (document.removeEventListener('click', this.outsideClickListener),
          (this.outsideClickListener = null))
      }, 'unbindOutsideClickListener'),
      bindScrollListener: __name(function () {
        var e = this
        this.scrollHandler ||
          (this.scrollHandler = new ConnectedOverlayScrollHandler(
            this.target,
            function () {
              e.visible && (e.visible = !1)
            }
          )),
          this.scrollHandler.bindScrollListener()
      }, 'bindScrollListener'),
      unbindScrollListener: __name(function () {
        this.scrollHandler && this.scrollHandler.unbindScrollListener()
      }, 'unbindScrollListener'),
      bindResizeListener: __name(function () {
        var e = this
        this.resizeListener ||
          ((this.resizeListener = function () {
            e.visible && !isTouchDevice() && (e.visible = !1)
          }),
          window.addEventListener('resize', this.resizeListener))
      }, 'bindResizeListener'),
      unbindResizeListener: __name(function () {
        this.resizeListener &&
          (window.removeEventListener('resize', this.resizeListener),
          (this.resizeListener = null))
      }, 'unbindResizeListener'),
      focus: __name(function () {
        var e = this.container.querySelector('[autofocus]')
        e && e.focus({ preventScroll: !0 })
      }, 'focus'),
      isTargetClicked: __name(function (e) {
        return (
          this.target &&
          (this.target === e.target || this.target.contains(e.target))
        )
      }, 'isTargetClicked'),
      containerRef: __name(function (e) {
        this.container = e
      }, 'containerRef'),
      onOverlayClick: __name(function (e) {
        OverlayEventBus.emit('overlay-click', {
          originalEvent: e,
          target: this.target
        })
      }, 'onOverlayClick'),
      onOverlayKeydown: __name(function (e) {
        'Escape' === e.code &&
          (ConfirmationEventBus.emit('close', this.closeListener),
          focus(this.target))
      }, 'onOverlayKeydown')
    },
    computed: {
      message: __name(function () {
        return this.confirmation ? this.confirmation.message : null
      }, 'message'),
      acceptLabel: __name(function () {
        if (this.confirmation) {
          var e,
            t = this.confirmation
          return (
            t.acceptLabel ||
            (null === (e = t.acceptProps) || void 0 === e ? void 0 : e.label) ||
            this.$primevue.config.locale.accept
          )
        }
        return this.$primevue.config.locale.accept
      }, 'acceptLabel'),
      rejectLabel: __name(function () {
        if (this.confirmation) {
          var e,
            t = this.confirmation
          return (
            t.rejectLabel ||
            (null === (e = t.rejectProps) || void 0 === e ? void 0 : e.label) ||
            this.$primevue.config.locale.reject
          )
        }
        return this.$primevue.config.locale.reject
      }, 'rejectLabel'),
      acceptIcon: __name(function () {
        var e
        return this.confirmation
          ? this.confirmation.acceptIcon
          : null !== (e = this.confirmation) && void 0 !== e && e.acceptProps
            ? this.confirmation.acceptProps.icon
            : null
      }, 'acceptIcon'),
      rejectIcon: __name(function () {
        var e
        return this.confirmation
          ? this.confirmation.rejectIcon
          : null !== (e = this.confirmation) && void 0 !== e && e.rejectProps
            ? this.confirmation.rejectProps.icon
            : null
      }, 'rejectIcon')
    },
    components: { Button: script$K, Portal: script$w },
    directives: { focustrap: FocusTrap }
  },
  _hoisted_1$b = ['aria-modal']
function render$6(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('Button'),
    s = Vue.resolveComponent('Portal'),
    l = Vue.resolveDirective('focustrap')
  return (
    Vue.openBlock(),
    Vue.createBlock(s, null, {
      default: Vue.withCtx(function () {
        return [
          Vue.createVNode(
            Vue.Transition,
            Vue.mergeProps(
              {
                name: 'p-confirmpopup',
                onEnter: r.onEnter,
                onAfterEnter: r.onAfterEnter,
                onLeave: r.onLeave,
                onAfterLeave: r.onAfterLeave
              },
              e.ptm('transition')
            ),
            {
              default: Vue.withCtx(function () {
                var n, o, s
                return [
                  i.visible
                    ? Vue.withDirectives(
                        (Vue.openBlock(),
                        Vue.createElementBlock(
                          'div',
                          Vue.mergeProps(
                            {
                              key: 0,
                              ref: r.containerRef,
                              role: 'alertdialog',
                              class: e.cx('root'),
                              'aria-modal': i.visible,
                              onClick:
                                t[2] ||
                                (t[2] = function () {
                                  return (
                                    r.onOverlayClick &&
                                    r.onOverlayClick.apply(r, arguments)
                                  )
                                }),
                              onKeydown:
                                t[3] ||
                                (t[3] = function () {
                                  return (
                                    r.onOverlayKeydown &&
                                    r.onOverlayKeydown.apply(r, arguments)
                                  )
                                })
                            },
                            e.ptmi('root')
                          ),
                          [
                            e.$slots.container
                              ? Vue.renderSlot(e.$slots, 'container', {
                                  key: 0,
                                  message: i.confirmation,
                                  acceptCallback: r.accept,
                                  rejectCallback: r.reject
                                })
                              : (Vue.openBlock(),
                                Vue.createElementBlock(
                                  Vue.Fragment,
                                  { key: 1 },
                                  [
                                    e.$slots.message
                                      ? (Vue.openBlock(),
                                        Vue.createBlock(
                                          Vue.resolveDynamicComponent(
                                            e.$slots.message
                                          ),
                                          { key: 1, message: i.confirmation },
                                          null,
                                          8,
                                          ['message']
                                        ))
                                      : (Vue.openBlock(),
                                        Vue.createElementBlock(
                                          'div',
                                          Vue.mergeProps(
                                            { key: 0, class: e.cx('content') },
                                            e.ptm('content')
                                          ),
                                          [
                                            Vue.renderSlot(
                                              e.$slots,
                                              'icon',
                                              {},
                                              function () {
                                                return [
                                                  e.$slots.icon
                                                    ? (Vue.openBlock(),
                                                      Vue.createBlock(
                                                        Vue.resolveDynamicComponent(
                                                          e.$slots.icon
                                                        ),
                                                        {
                                                          key: 0,
                                                          class:
                                                            Vue.normalizeClass(
                                                              e.cx('icon')
                                                            )
                                                        },
                                                        null,
                                                        8,
                                                        ['class']
                                                      ))
                                                    : i.confirmation.icon
                                                      ? (Vue.openBlock(),
                                                        Vue.createElementBlock(
                                                          'span',
                                                          Vue.mergeProps(
                                                            {
                                                              key: 1,
                                                              class: [
                                                                i.confirmation
                                                                  .icon,
                                                                e.cx('icon')
                                                              ]
                                                            },
                                                            e.ptm('icon')
                                                          ),
                                                          null,
                                                          16
                                                        ))
                                                      : Vue.createCommentVNode(
                                                          '',
                                                          !0
                                                        )
                                                ]
                                              }
                                            ),
                                            Vue.createElementVNode(
                                              'span',
                                              Vue.mergeProps(
                                                { class: e.cx('message') },
                                                e.ptm('message')
                                              ),
                                              Vue.toDisplayString(
                                                i.confirmation.message
                                              ),
                                              17
                                            )
                                          ],
                                          16
                                        )),
                                    Vue.createElementVNode(
                                      'div',
                                      Vue.mergeProps(
                                        { class: e.cx('footer') },
                                        e.ptm('footer')
                                      ),
                                      [
                                        Vue.createVNode(
                                          a,
                                          Vue.mergeProps(
                                            {
                                              class: [
                                                e.cx('pcRejectButton'),
                                                i.confirmation.rejectClass
                                              ],
                                              autofocus: i.autoFocusReject,
                                              unstyled: e.unstyled,
                                              size:
                                                (null ===
                                                  (n =
                                                    i.confirmation
                                                      .rejectProps) ||
                                                void 0 === n
                                                  ? void 0
                                                  : n.size) || 'small',
                                              text:
                                                (null ===
                                                  (o =
                                                    i.confirmation
                                                      .rejectProps) ||
                                                void 0 === o
                                                  ? void 0
                                                  : o.text) || !1,
                                              onClick:
                                                t[0] ||
                                                (t[0] = function (e) {
                                                  return r.reject()
                                                }),
                                              onKeydown: r.onRejectKeydown
                                            },
                                            i.confirmation.rejectProps,
                                            {
                                              label: r.rejectLabel,
                                              pt: e.ptm('pcRejectButton')
                                            }
                                          ),
                                          Vue.createSlots({ _: 2 }, [
                                            r.rejectIcon || e.$slots.rejecticon
                                              ? {
                                                  name: 'icon',
                                                  fn: Vue.withCtx(function (t) {
                                                    return [
                                                      Vue.renderSlot(
                                                        e.$slots,
                                                        'rejecticon',
                                                        {},
                                                        function () {
                                                          return [
                                                            Vue.createElementVNode(
                                                              'span',
                                                              Vue.mergeProps(
                                                                {
                                                                  class: [
                                                                    r.rejectIcon,
                                                                    t.class
                                                                  ]
                                                                },
                                                                e.ptm(
                                                                  'pcRejectButton'
                                                                ).icon,
                                                                {
                                                                  'data-pc-section':
                                                                    'rejectbuttonicon'
                                                                }
                                                              ),
                                                              null,
                                                              16
                                                            )
                                                          ]
                                                        }
                                                      )
                                                    ]
                                                  }),
                                                  key: '0'
                                                }
                                              : void 0
                                          ]),
                                          1040,
                                          [
                                            'class',
                                            'autofocus',
                                            'unstyled',
                                            'size',
                                            'text',
                                            'onKeydown',
                                            'label',
                                            'pt'
                                          ]
                                        ),
                                        Vue.createVNode(
                                          a,
                                          Vue.mergeProps(
                                            {
                                              class: [
                                                e.cx('pcAcceptButton'),
                                                i.confirmation.acceptClass
                                              ],
                                              autofocus: i.autoFocusAccept,
                                              unstyled: e.unstyled,
                                              size:
                                                (null ===
                                                  (s =
                                                    i.confirmation
                                                      .acceptProps) ||
                                                void 0 === s
                                                  ? void 0
                                                  : s.size) || 'small',
                                              onClick:
                                                t[1] ||
                                                (t[1] = function (e) {
                                                  return r.accept()
                                                }),
                                              onKeydown: r.onAcceptKeydown
                                            },
                                            i.confirmation.acceptProps,
                                            {
                                              label: r.acceptLabel,
                                              pt: e.ptm('pcAcceptButton')
                                            }
                                          ),
                                          Vue.createSlots({ _: 2 }, [
                                            r.acceptIcon || e.$slots.accepticon
                                              ? {
                                                  name: 'icon',
                                                  fn: Vue.withCtx(function (t) {
                                                    return [
                                                      Vue.renderSlot(
                                                        e.$slots,
                                                        'accepticon',
                                                        {},
                                                        function () {
                                                          return [
                                                            Vue.createElementVNode(
                                                              'span',
                                                              Vue.mergeProps(
                                                                {
                                                                  class: [
                                                                    r.acceptIcon,
                                                                    t.class
                                                                  ]
                                                                },
                                                                e.ptm(
                                                                  'pcAcceptButton'
                                                                ).icon,
                                                                {
                                                                  'data-pc-section':
                                                                    'acceptbuttonicon'
                                                                }
                                                              ),
                                                              null,
                                                              16
                                                            )
                                                          ]
                                                        }
                                                      )
                                                    ]
                                                  }),
                                                  key: '0'
                                                }
                                              : void 0
                                          ]),
                                          1040,
                                          [
                                            'class',
                                            'autofocus',
                                            'unstyled',
                                            'size',
                                            'onKeydown',
                                            'label',
                                            'pt'
                                          ]
                                        )
                                      ],
                                      16
                                    )
                                  ],
                                  64
                                ))
                          ],
                          16,
                          _hoisted_1$b
                        )),
                        [[l]]
                      )
                    : Vue.createCommentVNode('', !0)
                ]
              }),
              _: 3
            },
            16,
            ['onEnter', 'onAfterEnter', 'onLeave', 'onAfterLeave']
          )
        ]
      }),
      _: 3
    })
  )
}
__name(render$6, 'render$6'), (script$7.render = render$6)
const _hoisted_1$a = ['src', 'data-test'],
  _hoisted_2$7 = ['src'],
  _hoisted_3$5 = { key: 1, class: 'broken-image-placeholder' },
  _sfc_main$b = Vue.defineComponent({
    __name: 'ComfyImage',
    props: { src: {}, class: {}, contain: { type: Boolean, default: !1 } },
    setup(e) {
      const t = e,
        n = Vue.ref(!1),
        o = __name((e) => {
          n.value = !0
        }, 'handleImageError'),
        i = Vue.computed(() =>
          Array.isArray(t.class)
            ? t.class
            : 'string' == typeof t.class
              ? t.class.split(' ')
              : 'object' == typeof t.class
                ? Object.keys(t.class).filter((e) => t.class[e])
                : []
        )
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock(
          Vue.Fragment,
          null,
          [
            n.value
              ? Vue.createCommentVNode('', !0)
              : (Vue.openBlock(),
                Vue.createElementBlock(
                  'span',
                  {
                    key: 0,
                    class: Vue.normalizeClass([
                      'comfy-image-wrap',
                      [{ contain: e.contain }]
                    ])
                  },
                  [
                    e.contain
                      ? (Vue.openBlock(),
                        Vue.createElementBlock(
                          'img',
                          {
                            key: 0,
                            src: e.src,
                            onError: o,
                            'data-test': e.src,
                            class: 'comfy-image-blur',
                            style: Vue.normalizeStyle({
                              'background-image': `url(${e.src})`
                            })
                          },
                          null,
                          44,
                          _hoisted_1$a
                        ))
                      : Vue.createCommentVNode('', !0),
                    Vue.createElementVNode(
                      'img',
                      {
                        src: e.src,
                        onError: o,
                        class: Vue.normalizeClass([
                          'comfy-image-main',
                          [...i.value]
                        ])
                      },
                      null,
                      42,
                      _hoisted_2$7
                    )
                  ],
                  2
                )),
            n.value
              ? (Vue.openBlock(),
                Vue.createElementBlock('div', _hoisted_3$5, [
                  t[0] ||
                    (t[0] = Vue.createElementVNode(
                      'i',
                      { class: 'pi pi-image' },
                      null,
                      -1
                    )),
                  Vue.createElementVNode(
                    'span',
                    null,
                    Vue.toDisplayString(e.$t('imageFailedToLoad')),
                    1
                  )
                ]))
              : Vue.createCommentVNode('', !0)
          ],
          64
        )
      )
    }
  }),
  ComfyImage = _export_sfc(_sfc_main$b, [['__scopeId', 'data-v-9bc23daf']]),
  _hoisted_1$9 = { controls: '', width: '100%', height: '100%' },
  _hoisted_2$6 = ['src', 'type'],
  _sfc_main$a = Vue.defineComponent({
    __name: 'ResultVideo',
    props: { result: {} },
    setup(e) {
      const t = e,
        n = useSettingStore(),
        o = Vue.computed(() => n.get('VHS.AdvancedPreviews')),
        i = Vue.computed(() =>
          o.value ? t.result.vhsAdvancedPreviewUrl : t.result.url
        ),
        r = Vue.computed(() =>
          o.value ? 'video/webm' : t.result.htmlVideoType
        )
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock('video', _hoisted_1$9, [
          Vue.createElementVNode(
            'source',
            { src: i.value, type: r.value },
            null,
            8,
            _hoisted_2$6
          ),
          Vue.createTextVNode(
            ' ' + Vue.toDisplayString(e.$t('videoFailedToLoad')),
            1
          )
        ])
      )
    }
  }),
  _hoisted_1$8 = { key: 2, class: 'task-result-preview' },
  _hoisted_2$5 = { key: 3, class: 'preview-mask' },
  _sfc_main$9 = Vue.defineComponent({
    __name: 'ResultItem',
    props: { result: {} },
    emits: ['preview'],
    setup(e, { emit: t }) {
      const n = e,
        o = t,
        i = Vue.ref(null),
        r = useSettingStore(),
        a = Vue.computed(() => r.get('Comfy.Queue.ImageFit'))
      return (
        Vue.onMounted(() => {
          'images' === n.result.mediaType &&
            i.value?.querySelectorAll('img').forEach((e) => {
              e.draggable = !0
            })
        }),
        (e, t) => (
          Vue.openBlock(),
          Vue.createElementBlock(
            'div',
            { class: 'result-container', ref_key: 'resultContainer', ref: i },
            [
              e.result.isImage
                ? (Vue.openBlock(),
                  Vue.createBlock(
                    ComfyImage,
                    {
                      key: 0,
                      src: e.result.url,
                      class: 'task-output-image',
                      contain: 'contain' === a.value
                    },
                    null,
                    8,
                    ['src', 'contain']
                  ))
                : e.result.isVideo
                  ? (Vue.openBlock(),
                    Vue.createBlock(
                      _sfc_main$a,
                      { key: 1, result: e.result },
                      null,
                      8,
                      ['result']
                    ))
                  : (Vue.openBlock(),
                    Vue.createElementBlock('div', _hoisted_1$8, [
                      t[1] ||
                        (t[1] = Vue.createElementVNode(
                          'i',
                          { class: 'pi pi-file' },
                          null,
                          -1
                        )),
                      Vue.createElementVNode(
                        'span',
                        null,
                        Vue.toDisplayString(e.result.mediaType),
                        1
                      )
                    ])),
              e.result.supportsPreview
                ? (Vue.openBlock(),
                  Vue.createElementBlock('div', _hoisted_2$5, [
                    Vue.createVNode(Vue.unref(script$K), {
                      icon: 'pi pi-eye',
                      severity: 'secondary',
                      onClick: t[0] || (t[0] = (t) => o('preview', e.result)),
                      rounded: ''
                    })
                  ]))
                : Vue.createCommentVNode('', !0)
            ],
            512
          )
        )
      )
    }
  }),
  ResultItem = _export_sfc(_sfc_main$9, [['__scopeId', 'data-v-62b7731e']]),
  _hoisted_1$7 = { class: 'task-result-preview' },
  _hoisted_2$4 = { key: 0, class: 'pi pi-spin pi-spinner' },
  _hoisted_3$4 = ['src'],
  _hoisted_4$3 = { key: 2 },
  _hoisted_5$2 = { key: 3, class: 'pi pi-exclamation-triangle' },
  _hoisted_6$1 = { key: 4, class: 'pi pi-exclamation-circle' },
  _hoisted_7 = { class: 'task-item-details' },
  _hoisted_8 = { class: 'tag-wrapper status-tag-group' },
  _hoisted_9 = ['innerHTML'],
  _hoisted_10 = { key: 0, class: 'task-time' },
  _hoisted_11 = { key: 1, class: 'task-prompt-id' },
  _hoisted_12 = { class: 'tag-wrapper' },
  _hoisted_13 = { style: { 'font-weight': 'bold' } },
  _sfc_main$8 = Vue.defineComponent({
    __name: 'TaskItem',
    props: { task: {}, isFlatTask: { type: Boolean } },
    emits: ['contextmenu', 'preview', 'task-output-length-clicked'],
    setup(e, { emit: t }) {
      const n = e,
        o = n.task.flatOutputs,
        i = o.length ? n.task.previewOutput || o[0] : null,
        r =
          o.length && n.task.workflow
            ? (n.task.workflow.nodes.find((e) => e.id == i.nodeId) ?? null)
            : null,
        a = Vue.ref(''),
        s = t
      Vue.onMounted(() => {
        api.addEventListener('b_preview', m)
      }),
        Vue.onUnmounted(() => {
          api.removeEventListener('b_preview', m)
        })
      const l = __name((e) => {
          s('contextmenu', { task: n.task, event: e, node: r })
        }, 'handleContextMenu'),
        c = __name(() => {
          s('preview', n.task)
        }, 'handlePreview'),
        d = __name(() => {
          s('task-output-length-clicked', n.task)
        }, 'handleOutputLengthClick'),
        u = __name((e) => {
          switch (e) {
            case TaskItemDisplayStatus.Pending:
              return 'secondary'
            case TaskItemDisplayStatus.Running:
              return 'info'
            case TaskItemDisplayStatus.Completed:
              return 'success'
            case TaskItemDisplayStatus.Failed:
              return 'danger'
            case TaskItemDisplayStatus.Cancelled:
              return 'warn'
          }
        }, 'taskTagSeverity'),
        p = __name((e) => {
          switch (e) {
            case TaskItemDisplayStatus.Pending:
              return 'Pending'
            case TaskItemDisplayStatus.Running:
              return '<i class="pi pi-spin pi-spinner" style="font-weight: bold"></i> Running'
            case TaskItemDisplayStatus.Completed:
              return '<i class="pi pi-check" style="font-weight: bold"></i>'
            case TaskItemDisplayStatus.Failed:
              return 'Failed'
            case TaskItemDisplayStatus.Cancelled:
              return 'Cancelled'
          }
        }, 'taskStatusText'),
        h = __name(
          (e) => (void 0 === e ? '' : `${e.toFixed(2)}s`),
          'formatTime'
        ),
        m = __name(async ({ detail: e }) => {
          n.task.displayStatus === TaskItemDisplayStatus.Running &&
            (a.value = URL.createObjectURL(e))
        }, 'onProgressPreviewReceived')
      return (e, t) => (
        Vue.openBlock(),
        Vue.createElementBlock(
          'div',
          { class: 'task-item', onContextmenu: l },
          [
            Vue.createElementVNode('div', _hoisted_1$7, [
              e.task.displayStatus ===
              Vue.unref(TaskItemDisplayStatus).Completed
                ? (Vue.openBlock(),
                  Vue.createElementBlock(
                    Vue.Fragment,
                    { key: 0 },
                    [
                      Vue.unref(o).length
                        ? (Vue.openBlock(),
                          Vue.createBlock(
                            ResultItem,
                            { key: 0, result: Vue.unref(i), onPreview: c },
                            null,
                            8,
                            ['result']
                          ))
                        : Vue.createCommentVNode('', !0)
                    ],
                    64
                  ))
                : Vue.createCommentVNode('', !0),
              e.task.displayStatus === Vue.unref(TaskItemDisplayStatus).Running
                ? (Vue.openBlock(),
                  Vue.createElementBlock(
                    Vue.Fragment,
                    { key: 1 },
                    [
                      a.value
                        ? (Vue.openBlock(),
                          Vue.createElementBlock(
                            'img',
                            {
                              key: 1,
                              src: a.value,
                              class: 'progress-preview-img'
                            },
                            null,
                            8,
                            _hoisted_3$4
                          ))
                        : (Vue.openBlock(),
                          Vue.createElementBlock('i', _hoisted_2$4))
                    ],
                    64
                  ))
                : e.task.displayStatus ===
                    Vue.unref(TaskItemDisplayStatus).Pending
                  ? (Vue.openBlock(),
                    Vue.createElementBlock('span', _hoisted_4$3, '...'))
                  : e.task.displayStatus ===
                      Vue.unref(TaskItemDisplayStatus).Cancelled
                    ? (Vue.openBlock(),
                      Vue.createElementBlock('i', _hoisted_5$2))
                    : e.task.displayStatus ===
                        Vue.unref(TaskItemDisplayStatus).Failed
                      ? (Vue.openBlock(),
                        Vue.createElementBlock('i', _hoisted_6$1))
                      : Vue.createCommentVNode('', !0)
            ]),
            Vue.createElementVNode('div', _hoisted_7, [
              Vue.createElementVNode('div', _hoisted_8, [
                e.isFlatTask && e.task.isHistory
                  ? (Vue.openBlock(),
                    Vue.createBlock(
                      Vue.unref(script$C),
                      { key: 0, class: 'node-name-tag' },
                      {
                        default: Vue.withCtx(() => [
                          Vue.createVNode(
                            Vue.unref(script$K),
                            {
                              class: 'task-node-link',
                              label: `${Vue.unref(r)?.type} (#${Vue.unref(r)?.id})`,
                              link: '',
                              size: 'small',
                              onClick:
                                t[0] ||
                                (t[0] = (e) =>
                                  Vue.unref(app$1).goToNode(Vue.unref(r)?.id))
                            },
                            null,
                            8,
                            ['label']
                          )
                        ]),
                        _: 1
                      }
                    ))
                  : Vue.createCommentVNode('', !0),
                Vue.createVNode(
                  Vue.unref(script$C),
                  { severity: u(e.task.displayStatus) },
                  {
                    default: Vue.withCtx(() => [
                      Vue.createElementVNode(
                        'span',
                        { innerHTML: p(e.task.displayStatus) },
                        null,
                        8,
                        _hoisted_9
                      ),
                      e.task.isHistory
                        ? (Vue.openBlock(),
                          Vue.createElementBlock(
                            'span',
                            _hoisted_10,
                            Vue.toDisplayString(
                              h(e.task.executionTimeInSeconds)
                            ),
                            1
                          ))
                        : Vue.createCommentVNode('', !0),
                      e.isFlatTask
                        ? (Vue.openBlock(),
                          Vue.createElementBlock(
                            'span',
                            _hoisted_11,
                            Vue.toDisplayString(e.task.promptId.split('-')[0]),
                            1
                          ))
                        : Vue.createCommentVNode('', !0)
                    ]),
                    _: 1
                  },
                  8,
                  ['severity']
                )
              ]),
              Vue.createElementVNode('div', _hoisted_12, [
                e.task.isHistory && Vue.unref(o).length > 1
                  ? (Vue.openBlock(),
                    Vue.createBlock(
                      Vue.unref(script$K),
                      { key: 0, outlined: '', onClick: d },
                      {
                        default: Vue.withCtx(() => [
                          Vue.createElementVNode(
                            'span',
                            _hoisted_13,
                            Vue.toDisplayString(Vue.unref(o).length),
                            1
                          )
                        ]),
                        _: 1
                      }
                    ))
                  : Vue.createCommentVNode('', !0)
              ])
            ])
          ],
          32
        )
      )
    }
  }),
  TaskItem = _export_sfc(_sfc_main$8, [['__scopeId', 'data-v-28bce53e']])
var theme$3 = __name(function (e) {
    var t = e.dt
    return '\n.p-galleria {\n    overflow: hidden;\n    border-style: solid;\n    border-width: '
      .concat(t('galleria.border.width'), ';\n    border-color: ')
      .concat(t('galleria.border.color'), ';\n    border-radius: ')
      .concat(
        t('galleria.border.radius'),
        ';\n}\n\n.p-galleria-content {\n    display: flex;\n    flex-direction: column;\n}\n\n.p-galleria-items-container {\n    display: flex;\n    flex-direction: column;\n    position: relative;\n}\n\n.p-galleria-items {\n    position: relative;\n    display: flex;\n    height: 100%;\n}\n\n.p-galleria-nav-button {\n    position: absolute !important;\n    top: 50%;\n    display: inline-flex;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    background: '
      )
      .concat(t('galleria.nav.button.background'), ';\n    color: ')
      .concat(t('galleria.nav.button.color'), ';\n    width: ')
      .concat(t('galleria.nav.button.size'), ';\n    height: ')
      .concat(t('galleria.nav.button.size'), ';\n    transition: background ')
      .concat(t('galleria.transition.duration'), ', color ')
      .concat(t('galleria.transition.duration'), ', outline-color ')
      .concat(t('galleria.transition.duration'), ', box-shadow ')
      .concat(
        t('galleria.transition.duration'),
        ';\n    margin: calc(-1 * calc('
      )
      .concat(t('galleria.nav.button.size'), ') / 2) ')
      .concat(t('galleria.nav.button.gutter'), ' 0 ')
      .concat(
        t('galleria.nav.button.gutter'),
        ';\n    padding: 0;\n    user-select: none;\n    border: 0 none;\n    cursor: pointer;\n    outline-color: transparent;\n}\n\n.p-galleria-nav-button:not(.p-disabled):hover {\n    background: '
      )
      .concat(t('galleria.nav.button.hover.background'), ';\n    color: ')
      .concat(
        t('galleria.nav.button.hover.color'),
        ';\n}\n\n.p-galleria-nav-button:not(.p-disabled):focus-visible {\n    box-shadow: '
      )
      .concat(t('galleria.nav.button.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('galleria.nav.button.focus.ring.width'), ' ')
      .concat(t('galleria.nav.button.focus.ring.style'), ' ')
      .concat(
        t('galleria.nav.button.focus.ring.color'),
        ';\n    outline-offset: '
      )
      .concat(
        t('galleria.nav.button.focus.ring.offset'),
        ';\n}\n\n.p-galleria-next-icon,\n.p-galleria-prev-icon {\n    font-size: '
      )
      .concat(t('galleria.nav.icon.size'), ';\n    width: ')
      .concat(t('galleria.nav.icon.size'), ';\n    height: ')
      .concat(
        t('galleria.nav.icon.size'),
        ';\n}\n\n.p-galleria-prev-button {\n    border-radius: '
      )
      .concat(
        t('galleria.nav.button.prev.border.radius'),
        ';\n    left: 0;\n}\n\n.p-galleria-next-button {\n    border-radius: '
      )
      .concat(
        t('galleria.nav.button.next.border.radius'),
        ';\n    right: 0;\n}\n\n.p-galleria-prev-button:dir(rtl) {\n    left: auto;\n    right: 0;\n    transform: rotate(180deg);\n}\n\n.p-galleria-next-button:dir(rtl) {\n    right: auto;\n    left: 0;\n    transform: rotate(180deg);\n}\n\n.p-galleria-item {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 100%;\n    width: 100%;\n}\n\n.p-galleria-hover-navigators .p-galleria-nav-button {\n    pointer-events: none;\n    opacity: 0;\n    transition: opacity '
      )
      .concat(
        t('galleria.transition.duration'),
        ' ease-in-out;\n}\n\n.p-galleria-hover-navigators .p-galleria-items-container:hover .p-galleria-nav-button {\n    pointer-events: all;\n    opacity: 1;\n}\n\n.p-galleria-hover-navigators .p-galleria-items-container:hover .p-galleria-nav-button.p-disabled {\n    pointer-events: none;\n}\n\n.p-galleria-caption {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    width: 100%;\n    background: '
      )
      .concat(t('galleria.caption.background'), ';\n    color: ')
      .concat(t('galleria.caption.color'), ';\n    padding: ')
      .concat(
        t('galleria.caption.padding'),
        ';\n}\n\n.p-galleria-thumbnails {\n    display: flex;\n    flex-direction: column;\n    overflow: auto;\n    flex-shrink: 0;\n}\n\n.p-galleria-thumbnail-nav-button {\n    align-self: center;\n    flex: 0 0 auto;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    position: relative;\n    margin: 0 '
      )
      .concat(
        t('galleria.thumbnail.nav.button.gutter'),
        ';\n    padding: 0;\n    border: none;\n    user-select: none;\n    cursor: pointer;\n    background: transparent;\n    color: '
      )
      .concat(t('galleria.thumbnail.nav.button.color'), ';\n    width: ')
      .concat(t('galleria.thumbnail.nav.button.size'), ';\n    height: ')
      .concat(
        t('galleria.thumbnail.nav.button.size'),
        ';\n    transition: background '
      )
      .concat(t('galleria.transition.duration'), ', color ')
      .concat(t('galleria.transition.duration'), ', outline-color ')
      .concat(
        t('galleria.transition.duration'),
        ';\n    outline-color: transparent;\n    border-radius: '
      )
      .concat(
        t('galleria.thumbnail.nav.button.border.radius'),
        ';\n}\n\n.p-galleria-thumbnail-nav-button:hover {\n    background: '
      )
      .concat(
        t('galleria.thumbnail.nav.button.hover.background'),
        ';\n    color: '
      )
      .concat(
        t('galleria.thumbnail.nav.button.hover.color'),
        ';\n}\n\n.p-galleria-thumbnail-nav-button:focus-visible {\n    box-shadow: '
      )
      .concat(
        t('galleria.thumbnail.nav.button.focus.ring.shadow'),
        ';\n    outline: '
      )
      .concat(t('galleria.thumbnail.nav.button.focus.ring.width'), ' ')
      .concat(t('galleria.thumbnail.nav.button.focus.ring.style'), ' ')
      .concat(
        t('galleria.thumbnail.nav.button.focus.ring.color'),
        ';\n    outline-offset: '
      )
      .concat(
        t('galleria.thumbnail.nav.button.focus.ring.offset'),
        ';\n}\n\n.p-galleria-thumbnail-nav-button .p-galleria-thumbnail-next-icon,\n.p-galleria-thumbnail-nav-button .p-galleria-thumbnail-prev-icon {\n    font-size: '
      )
      .concat(t('galleria.thumbnail.nav.button.icon.size'), ';\n    width: ')
      .concat(t('galleria.thumbnail.nav.button.icon.size'), ';\n    height: ')
      .concat(
        t('galleria.thumbnail.nav.button.icon.size'),
        ';\n}\n\n.p-galleria-thumbnails-content {\n    display: flex;\n    flex-direction: row;\n    background: '
      )
      .concat(t('galleria.thumbnails.content.background'), ';\n    padding: ')
      .concat(
        t('galleria.thumbnails.content.padding'),
        ';\n}\n\n.p-galleria-thumbnails-viewport {\n    overflow: hidden;\n    width: 100%;\n}\n\n.p-galleria:not(.p-galleria-thumbnails-right):not(.p-galleria-thumbnails-left) .p-galleria-thumbnail-prev-button:dir(rtl),\n.p-galleria:not(.p-galleria-thumbnails-right):not(.p-galleria-thumbnails-left) .p-galleria-thumbnail-next-button:dir(rtl) {\n    transform: rotate(180deg);\n}\n\n.p-galleria-thumbnail-items {\n    display: flex;\n}\n\n.p-galleria-thumbnail-item {\n    overflow: auto;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    opacity: 0.5;\n}\n\n.p-galleria-thumbnail {\n    outline-color: transparent;\n}\n\n.p-galleria-thumbnail-item:hover {\n    opacity: 1;\n    transition: opacity 0.3s;\n}\n\n.p-galleria-thumbnail-item-current {\n    opacity: 1;\n}\n\n.p-galleria-thumbnails-left .p-galleria-content,\n.p-galleria-thumbnails-right .p-galleria-content {\n    flex-direction: row;\n}\n\n.p-galleria-thumbnails-left .p-galleria-items-container,\n.p-galleria-thumbnails-right .p-galleria-items-container {\n    flex-direction: row;\n}\n\n.p-galleria-thumbnails-left .p-galleria-items-container,\n.p-galleria-thumbnails-top .p-galleria-items-container {\n    order: 2;\n}\n\n.p-galleria-thumbnails-left .p-galleria-thumbnails,\n.p-galleria-thumbnails-top .p-galleria-thumbnails {\n    order: 1;\n}\n\n.p-galleria-thumbnails-left .p-galleria-thumbnails-content,\n.p-galleria-thumbnails-right .p-galleria-thumbnails-content {\n    flex-direction: column;\n    flex-grow: 1;\n}\n\n.p-galleria-thumbnails-left .p-galleria-thumbnail-items,\n.p-galleria-thumbnails-right .p-galleria-thumbnail-items {\n    flex-direction: column;\n    height: 100%;\n}\n\n.p-galleria-indicator-list {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: '
      )
      .concat(t('galleria.indicator.list.padding'), ';\n    gap: ')
      .concat(
        t('galleria.indicator.list.gap'),
        ';\n    margin: 0;\n    list-style: none;\n}\n\n.p-galleria-indicator-button {\n    display: inline-flex;\n    align-items: center;\n    background: '
      )
      .concat(t('galleria.indicator.button.background'), ';\n    width: ')
      .concat(t('galleria.indicator.button.width'), ';\n    height: ')
      .concat(
        t('galleria.indicator.button.height'),
        ';\n    transition: background '
      )
      .concat(t('galleria.transition.duration'), ', color ')
      .concat(t('galleria.transition.duration'), ', outline-color ')
      .concat(t('galleria.transition.duration'), ', box-shadow ')
      .concat(
        t('galleria.transition.duration'),
        ';\n    outline-color: transparent;\n    border-radius: '
      )
      .concat(
        t('galleria.indicator.button.border.radius'),
        ';\n    margin: 0;\n    padding: 0;\n    border: none;\n    user-select: none;\n    cursor: pointer;\n}\n\n.p-galleria-indicator-button:hover {\n    background: '
      )
      .concat(
        t('galleria.indicator.button.hover.background'),
        ';\n}\n\n.p-galleria-indicator-button:focus-visible {\n    box-shadow: '
      )
      .concat(
        t('galleria.indicator.button.focus.ring.shadow'),
        ';\n    outline: '
      )
      .concat(t('galleria.indicator.button.focus.ring.width'), ' ')
      .concat(t('galleria.indicator.button.focus.ring.style'), ' ')
      .concat(
        t('galleria.indicator.button.focus.ring.color'),
        ';\n    outline-offset: '
      )
      .concat(
        t('galleria.indicator.button.focus.ring.offset'),
        ';\n}\n\n.p-galleria-indicator-active .p-galleria-indicator-button {\n    background: '
      )
      .concat(
        t('galleria.indicator.button.active.background'),
        ';\n}\n\n.p-galleria-indicators-left .p-galleria-items-container,\n.p-galleria-indicators-right .p-galleria-items-container {\n    flex-direction: row;\n    align-items: center;\n}\n\n.p-galleria-indicators-left .p-galleria-items,\n.p-galleria-indicators-top .p-galleria-items {\n    order: 2;\n}\n\n.p-galleria-indicators-left .p-galleria-indicator-list,\n.p-galleria-indicators-top .p-galleria-indicator-list {\n    order: 1;\n}\n\n.p-galleria-indicators-left .p-galleria-indicator-list,\n.p-galleria-indicators-right .p-galleria-indicator-list {\n    flex-direction: column;\n}\n\n.p-galleria-inset-indicators .p-galleria-indicator-list {\n    position: absolute;\n    display: flex;\n    z-index: 1;\n    background: '
      )
      .concat(
        t('galleria.inset.indicator.list.background'),
        ';\n}\n\n.p-galleria-inset-indicators .p-galleria-indicator-button {\n    background: '
      )
      .concat(
        t('galleria.inset.indicator.button.background'),
        ';\n}\n\n.p-galleria-inset-indicators .p-galleria-indicator-button:hover {\n    background: '
      )
      .concat(
        t('galleria.inset.indicator.button.hover.background'),
        ';\n}\n\n.p-galleria-inset-indicators .p-galleria-indicator-active .p-galleria-indicator-button {\n    background: '
      )
      .concat(
        t('galleria.inset.indicator.button.active.background'),
        ';\n}\n\n.p-galleria-inset-indicators.p-galleria-indicators-top .p-galleria-indicator-list {\n    top: 0;\n    left: 0;\n    width: 100%;\n    align-items: flex-start;\n}\n\n.p-galleria-inset-indicators.p-galleria-indicators-right .p-galleria-indicator-list {\n    right: 0;\n    top: 0;\n    height: 100%;\n    align-items: flex-end;\n}\n\n.p-galleria-inset-indicators.p-galleria-indicators-bottom .p-galleria-indicator-list {\n    bottom: 0;\n    left: 0;\n    width: 100%;\n    align-items: flex-end;\n}\n\n.p-galleria-inset-indicators.p-galleria-indicators-left .p-galleria-indicator-list {\n    left: 0;\n    top: 0;\n    height: 100%;\n    align-items: flex-start;\n}\n\n.p-galleria-mask {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-galleria-close-button {\n    position: absolute !important;\n    top: 0;\n    right: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    margin: '
      )
      .concat(t('galleria.close.button.gutter'), ';\n    background: ')
      .concat(t('galleria.close.button.background'), ';\n    color: ')
      .concat(t('galleria.close.button.color'), ';\n    width: ')
      .concat(t('galleria.close.button.size'), ';\n    height: ')
      .concat(
        t('galleria.close.button.size'),
        ';\n    padding: 0;\n    border: none;\n    user-select: none;\n    cursor: pointer;\n    border-radius: '
      )
      .concat(
        t('galleria.close.button.border.radius'),
        ';\n    outline-color: transparent;\n    transition: background '
      )
      .concat(t('galleria.transition.duration'), ', color ')
      .concat(t('galleria.transition.duration'), ', outline-color ')
      .concat(
        t('galleria.transition.duration'),
        ';\n}\n\n.p-galleria-close-icon {\n    font-size: '
      )
      .concat(t('galleria.close.button.icon.size'), ';\n    width: ')
      .concat(t('galleria.close.button.icon.size'), ';\n    height: ')
      .concat(
        t('galleria.close.button.icon.size'),
        ';\n}\n\n.p-galleria-close-button:hover {\n    background: '
      )
      .concat(t('galleria.close.button.hover.background'), ';\n    color: ')
      .concat(
        t('galleria.close.button.hover.color'),
        ';\n}\n\n.p-galleria-close-button:focus-visible {\n    box-shadow: '
      )
      .concat(t('galleria.close.button.focus.ring.shadow'), ';\n    outline: ')
      .concat(t('galleria.close.button.focus.ring.width'), ' ')
      .concat(t('galleria.close.button.focus.ring.style'), ' ')
      .concat(
        t('galleria.close.button.focus.ring.color'),
        ';\n    outline-offset: '
      )
      .concat(
        t('galleria.close.button.focus.ring.offset'),
        ';\n}\n\n.p-galleria-mask .p-galleria-nav-button {\n    position: fixed;\n    top: 50%;\n}\n\n.p-galleria-enter-active {\n    transition: all 150ms cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-galleria-leave-active {\n    transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.p-galleria-enter-from,\n.p-galleria-leave-to {\n    opacity: 0;\n    transform: scale(0.7);\n}\n\n.p-galleria-enter-active .p-galleria-nav-button {\n    opacity: 0;\n}\n\n.p-items-hidden .p-galleria-thumbnail-item {\n    visibility: hidden;\n}\n\n.p-items-hidden .p-galleria-thumbnail-item.p-galleria-thumbnail-item-active {\n    visibility: visible;\n}\n'
      )
  }, 'theme'),
  classes$3 = {
    mask: 'p-galleria-mask p-overlay-mask p-overlay-mask-enter',
    root: __name(function (e) {
      var t = e.instance,
        n =
          t.$attrs.showThumbnails &&
          t.getPositionClass(
            'p-galleria-thumbnails',
            t.$attrs.thumbnailsPosition
          ),
        o =
          t.$attrs.showIndicators &&
          t.getPositionClass(
            'p-galleria-indicators',
            t.$attrs.indicatorsPosition
          )
      return [
        'p-galleria p-component',
        {
          'p-galleria-fullscreen': t.$attrs.fullScreen,
          'p-galleria-inset-indicators': t.$attrs.showIndicatorsOnItem,
          'p-galleria-hover-navigators':
            t.$attrs.showItemNavigatorsOnHover && !t.$attrs.fullScreen
        },
        n,
        o
      ]
    }, 'root'),
    closeButton: 'p-galleria-close-button',
    closeIcon: 'p-galleria-close-icon',
    header: 'p-galleria-header',
    content: 'p-galleria-content',
    footer: 'p-galleria-footer',
    itemsContainer: 'p-galleria-items-container',
    items: 'p-galleria-items',
    prevButton: __name(function (e) {
      return [
        'p-galleria-prev-button p-galleria-nav-button',
        { 'p-disabled': e.instance.isNavBackwardDisabled() }
      ]
    }, 'prevButton'),
    prevIcon: 'p-galleria-prev-icon',
    item: 'p-galleria-item',
    nextButton: __name(function (e) {
      return [
        'p-galleria-next-button p-galleria-nav-button',
        { 'p-disabled': e.instance.isNavForwardDisabled() }
      ]
    }, 'nextButton'),
    nextIcon: 'p-galleria-next-icon',
    caption: 'p-galleria-caption',
    indicatorList: 'p-galleria-indicator-list',
    indicator: __name(function (e) {
      var t = e.instance,
        n = e.index
      return [
        'p-galleria-indicator',
        { 'p-galleria-indicator-active': t.isIndicatorItemActive(n) }
      ]
    }, 'indicator'),
    indicatorButton: 'p-galleria-indicator-button',
    thumbnails: 'p-galleria-thumbnails',
    thumbnailContent: 'p-galleria-thumbnails-content',
    thumbnailPrevButton: __name(function (e) {
      return [
        'p-galleria-thumbnail-prev-button p-galleria-thumbnail-nav-button',
        { 'p-disabled': e.instance.isNavBackwardDisabled() }
      ]
    }, 'thumbnailPrevButton'),
    thumbnailPrevIcon: 'p-galleria-thumbnail-prev-icon',
    thumbnailsViewport: 'p-galleria-thumbnails-viewport',
    thumbnailItems: 'p-galleria-thumbnail-items',
    thumbnailItem: __name(function (e) {
      var t = e.instance,
        n = e.index
      return [
        'p-galleria-thumbnail-item',
        {
          'p-galleria-thumbnail-item-current': e.activeIndex === n,
          'p-galleria-thumbnail-item-active': t.isItemActive(n),
          'p-galleria-thumbnail-item-start': t.firstItemAciveIndex() === n,
          'p-galleria-thumbnail-item-end': t.lastItemActiveIndex() === n
        }
      ]
    }, 'thumbnailItem'),
    thumbnail: 'p-galleria-thumbnail',
    thumbnailNextButton: __name(function (e) {
      return [
        'p-galleria-thumbnail-next-button p-galleria-thumbnail-nav-button',
        { 'p-disabled': e.instance.isNavForwardDisabled() }
      ]
    }, 'thumbnailNextButton'),
    thumbnailNextIcon: 'p-galleria-thumbnail-next-icon'
  },
  GalleriaStyle = BaseStyle.extend({
    name: 'galleria',
    theme: theme$3,
    classes: classes$3
  }),
  script$6 = { name: 'ChevronUpIcon', extends: script$X }
function render$5(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'svg',
      Vue.mergeProps(
        {
          width: '14',
          height: '14',
          viewBox: '0 0 14 14',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        e.pti()
      ),
      t[0] ||
        (t[0] = [
          Vue.createElementVNode(
            'path',
            {
              d: 'M12.2097 10.4113C12.1057 10.4118 12.0027 10.3915 11.9067 10.3516C11.8107 10.3118 11.7237 10.2532 11.6506 10.1792L6.93602 5.46461L2.22139 10.1476C2.07272 10.244 1.89599 10.2877 1.71953 10.2717C1.54307 10.2556 1.3771 10.1808 1.24822 10.0593C1.11933 9.93766 1.035 9.77633 1.00874 9.6011C0.982477 9.42587 1.0158 9.2469 1.10338 9.09287L6.37701 3.81923C6.52533 3.6711 6.72639 3.58789 6.93602 3.58789C7.14565 3.58789 7.3467 3.6711 7.49502 3.81923L12.7687 9.09287C12.9168 9.24119 13 9.44225 13 9.65187C13 9.8615 12.9168 10.0626 12.7687 10.2109C12.616 10.3487 12.4151 10.4207 12.2097 10.4113Z',
              fill: 'currentColor'
            },
            null,
            -1
          )
        ]),
      16
    )
  )
}
__name(render$5, 'render$5'), (script$6.render = render$5)
var script$4 = {
  name: 'BaseGalleria',
  extends: script$Y,
  props: {
    id: { type: String, default: null },
    value: { type: Array, default: null },
    activeIndex: { type: Number, default: 0 },
    fullScreen: { type: Boolean, default: !1 },
    visible: { type: Boolean, default: !1 },
    numVisible: { type: Number, default: 3 },
    responsiveOptions: { type: Array, default: null },
    showItemNavigators: { type: Boolean, default: !1 },
    showThumbnailNavigators: { type: Boolean, default: !0 },
    showItemNavigatorsOnHover: { type: Boolean, default: !1 },
    changeItemOnIndicatorHover: { type: Boolean, default: !1 },
    circular: { type: Boolean, default: !1 },
    autoPlay: { type: Boolean, default: !1 },
    transitionInterval: { type: Number, default: 4e3 },
    showThumbnails: { type: Boolean, default: !0 },
    thumbnailsPosition: { type: String, default: 'bottom' },
    verticalThumbnailViewPortHeight: { type: String, default: '300px' },
    showIndicators: { type: Boolean, default: !1 },
    showIndicatorsOnItem: { type: Boolean, default: !1 },
    indicatorsPosition: { type: String, default: 'bottom' },
    baseZIndex: { type: Number, default: 0 },
    maskClass: { type: String, default: null },
    containerStyle: { type: null, default: null },
    containerClass: { type: null, default: null },
    containerProps: { type: null, default: null },
    prevButtonProps: { type: null, default: null },
    nextButtonProps: { type: null, default: null },
    ariaLabel: { type: String, default: null },
    ariaRoledescription: { type: String, default: null }
  },
  style: GalleriaStyle,
  provide: __name(function () {
    return { $pcGalleria: this, $parentInstance: this }
  }, 'provide')
}
function _toConsumableArray$1(e) {
  return (
    _arrayWithoutHoles$1(e) ||
    _iterableToArray$1(e) ||
    _unsupportedIterableToArray$1(e) ||
    _nonIterableSpread$1()
  )
}
function _nonIterableSpread$1() {
  throw new TypeError(
    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$1(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$1(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$1(e, t)
          : void 0
    )
  }
}
function _iterableToArray$1(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _arrayWithoutHoles$1(e) {
  if (Array.isArray(e)) return _arrayLikeToArray$1(e)
}
function _arrayLikeToArray$1(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
__name(_toConsumableArray$1, '_toConsumableArray$1'),
  __name(_nonIterableSpread$1, '_nonIterableSpread$1'),
  __name(_unsupportedIterableToArray$1, '_unsupportedIterableToArray$1'),
  __name(_iterableToArray$1, '_iterableToArray$1'),
  __name(_arrayWithoutHoles$1, '_arrayWithoutHoles$1'),
  __name(_arrayLikeToArray$1, '_arrayLikeToArray$1')
var script$3 = {
    name: 'GalleriaItem',
    hostName: 'Galleria',
    extends: script$Y,
    emits: ['start-slideshow', 'stop-slideshow', 'update:activeIndex'],
    props: {
      circular: { type: Boolean, default: !1 },
      activeIndex: { type: Number, default: 0 },
      value: { type: Array, default: null },
      showItemNavigators: { type: Boolean, default: !0 },
      showIndicators: { type: Boolean, default: !0 },
      slideShowActive: { type: Boolean, default: !0 },
      changeItemOnIndicatorHover: { type: Boolean, default: !0 },
      autoPlay: { type: Boolean, default: !1 },
      templates: { type: null, default: null },
      id: { type: String, default: null }
    },
    mounted: __name(function () {
      this.autoPlay && this.$emit('start-slideshow')
    }, 'mounted'),
    methods: {
      getIndicatorPTOptions: __name(function (e) {
        return { context: { highlighted: this.activeIndex === e } }
      }, 'getIndicatorPTOptions'),
      next: __name(function () {
        var e = this.activeIndex + 1,
          t =
            this.circular && this.value.length - 1 === this.activeIndex ? 0 : e
        this.$emit('update:activeIndex', t)
      }, 'next'),
      prev: __name(function () {
        var e = 0 !== this.activeIndex ? this.activeIndex - 1 : 0,
          t =
            this.circular && 0 === this.activeIndex ? this.value.length - 1 : e
        this.$emit('update:activeIndex', t)
      }, 'prev'),
      stopSlideShow: __name(function () {
        this.slideShowActive &&
          this.stopSlideShow &&
          this.$emit('stop-slideshow')
      }, 'stopSlideShow'),
      navBackward: __name(function (e) {
        this.stopSlideShow(),
          this.prev(),
          e && e.cancelable && e.preventDefault()
      }, 'navBackward'),
      navForward: __name(function (e) {
        this.stopSlideShow(),
          this.next(),
          e && e.cancelable && e.preventDefault()
      }, 'navForward'),
      onIndicatorClick: __name(function (e) {
        this.stopSlideShow(), this.$emit('update:activeIndex', e)
      }, 'onIndicatorClick'),
      onIndicatorMouseEnter: __name(function (e) {
        this.changeItemOnIndicatorHover &&
          (this.stopSlideShow(), this.$emit('update:activeIndex', e))
      }, 'onIndicatorMouseEnter'),
      onIndicatorKeyDown: __name(function (e, t) {
        switch (e.code) {
          case 'Enter':
          case 'NumpadEnter':
          case 'Space':
            this.stopSlideShow(),
              this.$emit('update:activeIndex', t),
              e.preventDefault()
            break
          case 'ArrowRight':
            this.onRightKey()
            break
          case 'ArrowLeft':
            this.onLeftKey()
            break
          case 'Home':
            this.onHomeKey(), e.preventDefault()
            break
          case 'End':
            this.onEndKey(), e.preventDefault()
            break
          case 'Tab':
            this.onTabKey()
            break
          case 'ArrowDown':
          case 'ArrowUp':
          case 'PageUp':
          case 'PageDown':
            e.preventDefault()
        }
      }, 'onIndicatorKeyDown'),
      onRightKey: __name(function () {
        var e = _toConsumableArray$1(
            find(this.$refs.indicatorContent, '[data-pc-section="indicator"]')
          ),
          t = this.findFocusedIndicatorIndex()
        this.changedFocusedIndicator(
          t,
          t + 1 === e.length ? e.length - 1 : t + 1
        )
      }, 'onRightKey'),
      onLeftKey: __name(function () {
        var e = this.findFocusedIndicatorIndex()
        this.changedFocusedIndicator(e, e - 1 <= 0 ? 0 : e - 1)
      }, 'onLeftKey'),
      onHomeKey: __name(function () {
        var e = this.findFocusedIndicatorIndex()
        this.changedFocusedIndicator(e, 0)
      }, 'onHomeKey'),
      onEndKey: __name(function () {
        var e = _toConsumableArray$1(
            find(this.$refs.indicatorContent, '[data-pc-section="indicator"]')
          ),
          t = this.findFocusedIndicatorIndex()
        this.changedFocusedIndicator(t, e.length - 1)
      }, 'onEndKey'),
      onTabKey: __name(function () {
        var e = _toConsumableArray$1(
            find(this.$refs.indicatorContent, '[data-pc-section="indicator"]')
          ),
          t = e.findIndex(function (e) {
            return !0 === getAttribute(e, 'data-p-active')
          }),
          n = findSingle(
            this.$refs.indicatorContent,
            '[data-pc-section="indicator"] > button[tabindex="0"]'
          ),
          o = e.findIndex(function (e) {
            return e === n.parentElement
          })
        ;(e[o].children[0].tabIndex = '-1'), (e[t].children[0].tabIndex = '0')
      }, 'onTabKey'),
      findFocusedIndicatorIndex: __name(function () {
        var e = _toConsumableArray$1(
            find(this.$refs.indicatorContent, '[data-pc-section="indicator"]')
          ),
          t = findSingle(
            this.$refs.indicatorContent,
            '[data-pc-section="indicator"] > button[tabindex="0"]'
          )
        return e.findIndex(function (e) {
          return e === t.parentElement
        })
      }, 'findFocusedIndicatorIndex'),
      changedFocusedIndicator: __name(function (e, t) {
        var n = _toConsumableArray$1(
          find(this.$refs.indicatorContent, '[data-pc-section="indicator"]')
        )
        ;(n[e].children[0].tabIndex = '-1'),
          (n[t].children[0].tabIndex = '0'),
          n[t].children[0].focus()
      }, 'changedFocusedIndicator'),
      isIndicatorItemActive: __name(function (e) {
        return this.activeIndex === e
      }, 'isIndicatorItemActive'),
      isNavBackwardDisabled: __name(function () {
        return !this.circular && 0 === this.activeIndex
      }, 'isNavBackwardDisabled'),
      isNavForwardDisabled: __name(function () {
        return !this.circular && this.activeIndex === this.value.length - 1
      }, 'isNavForwardDisabled'),
      ariaSlideNumber: __name(function (e) {
        return this.$primevue.config.locale.aria
          ? this.$primevue.config.locale.aria.slideNumber.replace(
              /{slideNumber}/g,
              e
            )
          : void 0
      }, 'ariaSlideNumber'),
      ariaPageLabel: __name(function (e) {
        return this.$primevue.config.locale.aria
          ? this.$primevue.config.locale.aria.pageLabel.replace(/{page}/g, e)
          : void 0
      }, 'ariaPageLabel')
    },
    computed: {
      activeItem: __name(function () {
        return this.value[this.activeIndex]
      }, 'activeItem'),
      ariaSlideLabel: __name(function () {
        return this.$primevue.config.locale.aria
          ? this.$primevue.config.locale.aria.slide
          : void 0
      }, 'ariaSlideLabel')
    },
    components: { ChevronLeftIcon: script$q, ChevronRightIcon: script$p },
    directives: { ripple: Ripple }
  },
  _hoisted_1$3$1 = ['disabled'],
  _hoisted_2$2$1 = ['id', 'aria-label', 'aria-roledescription'],
  _hoisted_3$2 = ['disabled'],
  _hoisted_4$1 = [
    'aria-label',
    'aria-selected',
    'aria-controls',
    'onClick',
    'onMouseenter',
    'onKeydown',
    'data-p-active'
  ],
  _hoisted_5$1 = ['tabindex']
function render$3(e, t, n, o, i, r) {
  var a = Vue.resolveDirective('ripple')
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps(
        { class: e.cx('itemsContainer') },
        e.ptm('itemsContainer')
      ),
      [
        Vue.createElementVNode(
          'div',
          Vue.mergeProps({ class: e.cx('items') }, e.ptm('items')),
          [
            n.showItemNavigators
              ? Vue.withDirectives(
                  (Vue.openBlock(),
                  Vue.createElementBlock(
                    'button',
                    Vue.mergeProps(
                      {
                        key: 0,
                        type: 'button',
                        class: e.cx('prevButton'),
                        onClick:
                          t[0] ||
                          (t[0] = function (e) {
                            return r.navBackward(e)
                          }),
                        disabled: r.isNavBackwardDisabled()
                      },
                      e.ptm('prevButton'),
                      { 'data-pc-group-section': 'itemnavigator' }
                    ),
                    [
                      (Vue.openBlock(),
                      Vue.createBlock(
                        Vue.resolveDynamicComponent(
                          n.templates.previousitemicon || 'ChevronLeftIcon'
                        ),
                        Vue.mergeProps(
                          { class: e.cx('prevIcon') },
                          e.ptm('prevIcon')
                        ),
                        null,
                        16,
                        ['class']
                      ))
                    ],
                    16,
                    _hoisted_1$3$1
                  )),
                  [[a]]
                )
              : Vue.createCommentVNode('', !0),
            Vue.createElementVNode(
              'div',
              Vue.mergeProps(
                {
                  id: n.id + '_item_' + n.activeIndex,
                  class: e.cx('item'),
                  role: 'group',
                  'aria-label': r.ariaSlideNumber(n.activeIndex + 1),
                  'aria-roledescription': r.ariaSlideLabel
                },
                e.ptm('item')
              ),
              [
                n.templates.item
                  ? (Vue.openBlock(),
                    Vue.createBlock(
                      Vue.resolveDynamicComponent(n.templates.item),
                      { key: 0, item: r.activeItem },
                      null,
                      8,
                      ['item']
                    ))
                  : Vue.createCommentVNode('', !0)
              ],
              16,
              _hoisted_2$2$1
            ),
            n.showItemNavigators
              ? Vue.withDirectives(
                  (Vue.openBlock(),
                  Vue.createElementBlock(
                    'button',
                    Vue.mergeProps(
                      {
                        key: 1,
                        type: 'button',
                        class: e.cx('nextButton'),
                        onClick:
                          t[1] ||
                          (t[1] = function (e) {
                            return r.navForward(e)
                          }),
                        disabled: r.isNavForwardDisabled()
                      },
                      e.ptm('nextButton'),
                      { 'data-pc-group-section': 'itemnavigator' }
                    ),
                    [
                      (Vue.openBlock(),
                      Vue.createBlock(
                        Vue.resolveDynamicComponent(
                          n.templates.nextitemicon || 'ChevronRightIcon'
                        ),
                        Vue.mergeProps(
                          { class: e.cx('nextIcon') },
                          e.ptm('nextIcon')
                        ),
                        null,
                        16,
                        ['class']
                      ))
                    ],
                    16,
                    _hoisted_3$2
                  )),
                  [[a]]
                )
              : Vue.createCommentVNode('', !0),
            n.templates.caption
              ? (Vue.openBlock(),
                Vue.createElementBlock(
                  'div',
                  Vue.mergeProps(
                    { key: 2, class: e.cx('caption') },
                    e.ptm('caption')
                  ),
                  [
                    n.templates.caption
                      ? (Vue.openBlock(),
                        Vue.createBlock(
                          Vue.resolveDynamicComponent(n.templates.caption),
                          { key: 0, item: r.activeItem },
                          null,
                          8,
                          ['item']
                        ))
                      : Vue.createCommentVNode('', !0)
                  ],
                  16
                ))
              : Vue.createCommentVNode('', !0)
          ],
          16
        ),
        n.showIndicators
          ? (Vue.openBlock(),
            Vue.createElementBlock(
              'ul',
              Vue.mergeProps(
                {
                  key: 0,
                  ref: 'indicatorContent',
                  class: e.cx('indicatorList')
                },
                e.ptm('indicatorList')
              ),
              [
                (Vue.openBlock(!0),
                Vue.createElementBlock(
                  Vue.Fragment,
                  null,
                  Vue.renderList(n.value, function (t, o) {
                    return (
                      Vue.openBlock(),
                      Vue.createElementBlock(
                        'li',
                        Vue.mergeProps(
                          {
                            key: 'p-galleria-indicator-'.concat(o),
                            class: e.cx('indicator', { index: o }),
                            'aria-label': r.ariaPageLabel(o + 1),
                            'aria-selected': n.activeIndex === o,
                            'aria-controls': n.id + '_item_' + o,
                            onClick: __name(function (e) {
                              return r.onIndicatorClick(o)
                            }, 'onClick'),
                            onMouseenter: __name(function (e) {
                              return r.onIndicatorMouseEnter(o)
                            }, 'onMouseenter'),
                            onKeydown: __name(function (e) {
                              return r.onIndicatorKeyDown(e, o)
                            }, 'onKeydown'),
                            ref_for: !0
                          },
                          e.ptm('indicator', r.getIndicatorPTOptions(o)),
                          { 'data-p-active': r.isIndicatorItemActive(o) }
                        ),
                        [
                          n.templates.indicator
                            ? Vue.createCommentVNode('', !0)
                            : (Vue.openBlock(),
                              Vue.createElementBlock(
                                'button',
                                Vue.mergeProps(
                                  {
                                    key: 0,
                                    type: 'button',
                                    tabindex: n.activeIndex === o ? '0' : '-1',
                                    class: e.cx('indicatorButton'),
                                    ref_for: !0
                                  },
                                  e.ptm(
                                    'indicatorButton',
                                    r.getIndicatorPTOptions(o)
                                  )
                                ),
                                null,
                                16,
                                _hoisted_5$1
                              )),
                          n.templates.indicator
                            ? (Vue.openBlock(),
                              Vue.createBlock(
                                Vue.resolveDynamicComponent(
                                  n.templates.indicator
                                ),
                                { key: 1, index: o },
                                null,
                                8,
                                ['index']
                              ))
                            : Vue.createCommentVNode('', !0)
                        ],
                        16,
                        _hoisted_4$1
                      )
                    )
                  }),
                  128
                ))
              ],
              16
            ))
          : Vue.createCommentVNode('', !0)
      ],
      16
    )
  )
}
function _toConsumableArray(e) {
  return (
    _arrayWithoutHoles(e) ||
    _iterableToArray(e) ||
    _unsupportedIterableToArray$2(e) ||
    _nonIterableSpread()
  )
}
function _nonIterableSpread() {
  throw new TypeError(
    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray$2(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray$2(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray$2(e, t)
          : void 0
    )
  }
}
function _iterableToArray(e) {
  if (
    ('undefined' != typeof Symbol && null != e[Symbol.iterator]) ||
    null != e['@@iterator']
  )
    return Array.from(e)
}
function _arrayWithoutHoles(e) {
  if (Array.isArray(e)) return _arrayLikeToArray$2(e)
}
function _arrayLikeToArray$2(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
__name(render$3, 'render$3'),
  (script$3.render = render$3),
  __name(_toConsumableArray, '_toConsumableArray'),
  __name(_nonIterableSpread, '_nonIterableSpread'),
  __name(_unsupportedIterableToArray$2, '_unsupportedIterableToArray$2'),
  __name(_iterableToArray, '_iterableToArray'),
  __name(_arrayWithoutHoles, '_arrayWithoutHoles'),
  __name(_arrayLikeToArray$2, '_arrayLikeToArray$2')
var script$2$1 = {
  name: 'GalleriaThumbnails',
  hostName: 'Galleria',
  extends: script$Y,
  emits: ['stop-slideshow', 'update:activeIndex'],
  props: {
    containerId: { type: String, default: null },
    value: { type: Array, default: null },
    numVisible: { type: Number, default: 3 },
    activeIndex: { type: Number, default: 0 },
    isVertical: { type: Boolean, default: !1 },
    slideShowActive: { type: Boolean, default: !1 },
    circular: { type: Boolean, default: !1 },
    responsiveOptions: { type: Array, default: null },
    contentHeight: { type: String, default: '300px' },
    showThumbnailNavigators: { type: Boolean, default: !0 },
    templates: { type: null, default: null },
    prevButtonProps: { type: null, default: null },
    nextButtonProps: { type: null, default: null }
  },
  startPos: null,
  thumbnailsStyle: null,
  sortedResponsiveOptions: null,
  data: __name(function () {
    return {
      d_numVisible: this.numVisible,
      d_oldNumVisible: this.numVisible,
      d_activeIndex: this.activeIndex,
      d_oldActiveItemIndex: this.activeIndex,
      totalShiftedItems: 0,
      page: 0
    }
  }, 'data'),
  watch: {
    numVisible: __name(function (e, t) {
      ;(this.d_numVisible = e), (this.d_oldNumVisible = t)
    }, 'numVisible'),
    activeIndex: __name(function (e, t) {
      ;(this.d_activeIndex = e), (this.d_oldActiveItemIndex = t)
    }, 'activeIndex')
  },
  mounted: __name(function () {
    this.createStyle(),
      this.calculatePosition(),
      this.responsiveOptions && this.bindDocumentListeners()
  }, 'mounted'),
  updated: __name(function () {
    var e = this.totalShiftedItems
    ;(this.d_oldNumVisible === this.d_numVisible &&
      this.d_oldActiveItemIndex === this.d_activeIndex) ||
      ((e =
        this.d_activeIndex <= this.getMedianItemIndex()
          ? 0
          : this.value.length - this.d_numVisible + this.getMedianItemIndex() <
              this.d_activeIndex
            ? this.d_numVisible - this.value.length
            : this.value.length - this.d_numVisible < this.d_activeIndex &&
                this.d_numVisible % 2 == 0
              ? -1 * this.d_activeIndex + this.getMedianItemIndex() + 1
              : -1 * this.d_activeIndex + this.getMedianItemIndex()) !==
        this.totalShiftedItems && (this.totalShiftedItems = e),
      (this.$refs.itemsContainer.style.transform = this.isVertical
        ? 'translate3d(0, '.concat(e * (100 / this.d_numVisible), '%, 0)')
        : 'translate3d('.concat(e * (100 / this.d_numVisible), '%, 0, 0)')),
      this.d_oldActiveItemIndex !== this.d_activeIndex &&
        (document.body.setAttribute('data-p-items-hidden', 'false'),
        !this.isUnstyled &&
          removeClass(this.$refs.itemsContainer, 'p-items-hidden'),
        (this.$refs.itemsContainer.style.transition =
          'transform 500ms ease 0s')),
      (this.d_oldActiveItemIndex = this.d_activeIndex),
      (this.d_oldNumVisible = this.d_numVisible))
  }, 'updated'),
  beforeUnmount: __name(function () {
    this.responsiveOptions && this.unbindDocumentListeners(),
      this.thumbnailsStyle &&
        this.thumbnailsStyle.parentNode.removeChild(this.thumbnailsStyle)
  }, 'beforeUnmount'),
  methods: {
    step: __name(function (e) {
      var t = this.totalShiftedItems + e
      e < 0 && -1 * t + this.d_numVisible > this.value.length - 1
        ? (t = this.d_numVisible - this.value.length)
        : e > 0 && t > 0 && (t = 0),
        this.circular &&
          (e < 0 && this.value.length - 1 === this.d_activeIndex
            ? (t = 0)
            : e > 0 &&
              0 === this.d_activeIndex &&
              (t = this.d_numVisible - this.value.length)),
        this.$refs.itemsContainer &&
          (document.body.setAttribute('data-p-items-hidden', 'false'),
          !this.isUnstyled &&
            removeClass(this.$refs.itemsContainer, 'p-items-hidden'),
          (this.$refs.itemsContainer.style.transform = this.isVertical
            ? 'translate3d(0, '.concat(t * (100 / this.d_numVisible), '%, 0)')
            : 'translate3d('.concat(t * (100 / this.d_numVisible), '%, 0, 0)')),
          (this.$refs.itemsContainer.style.transition =
            'transform 500ms ease 0s')),
        (this.totalShiftedItems = t)
    }, 'step'),
    stopSlideShow: __name(function () {
      this.slideShowActive && this.stopSlideShow && this.$emit('stop-slideshow')
    }, 'stopSlideShow'),
    getMedianItemIndex: __name(function () {
      var e = Math.floor(this.d_numVisible / 2)
      return this.d_numVisible % 2 ? e : e - 1
    }, 'getMedianItemIndex'),
    navBackward: __name(function (e) {
      this.stopSlideShow()
      var t = 0 !== this.d_activeIndex ? this.d_activeIndex - 1 : 0,
        n = t + this.totalShiftedItems
      this.d_numVisible - n - 1 > this.getMedianItemIndex() &&
        (-1 * this.totalShiftedItems != 0 || this.circular) &&
        this.step(1)
      var o =
        this.circular && 0 === this.d_activeIndex ? this.value.length - 1 : t
      this.$emit('update:activeIndex', o), e.cancelable && e.preventDefault()
    }, 'navBackward'),
    navForward: __name(function (e) {
      this.stopSlideShow()
      var t =
        this.d_activeIndex === this.value.length - 1
          ? this.value.length - 1
          : this.d_activeIndex + 1
      t + this.totalShiftedItems > this.getMedianItemIndex() &&
        (-1 * this.totalShiftedItems < this.getTotalPageNumber() - 1 ||
          this.circular) &&
        this.step(-1)
      var n =
        this.circular && this.value.length - 1 === this.d_activeIndex ? 0 : t
      this.$emit('update:activeIndex', n), e.cancelable && e.preventDefault()
    }, 'navForward'),
    onItemClick: __name(function (e) {
      this.stopSlideShow()
      var t = e
      if (t !== this.d_activeIndex) {
        var n = t + this.totalShiftedItems,
          o = 0
        t < this.d_activeIndex
          ? (o = this.d_numVisible - n - 1 - this.getMedianItemIndex()) > 0 &&
            -1 * this.totalShiftedItems != 0 &&
            this.step(o)
          : (o = this.getMedianItemIndex() - n) < 0 &&
            -1 * this.totalShiftedItems < this.getTotalPageNumber() - 1 &&
            this.step(o),
          this.$emit('update:activeIndex', t)
      }
    }, 'onItemClick'),
    onThumbnailKeydown: __name(function (e, t) {
      switch (
        (('Enter' !== e.code &&
          'NumpadEnter' !== e.code &&
          'Space' !== e.code) ||
          (this.onItemClick(t), e.preventDefault()),
        e.code)
      ) {
        case 'ArrowRight':
          this.onRightKey()
          break
        case 'ArrowLeft':
          this.onLeftKey()
          break
        case 'Home':
          this.onHomeKey(), e.preventDefault()
          break
        case 'End':
          this.onEndKey(), e.preventDefault()
          break
        case 'ArrowUp':
        case 'ArrowDown':
          e.preventDefault()
          break
        case 'Tab':
          this.onTabKey()
      }
    }, 'onThumbnailKeydown'),
    onRightKey: __name(function () {
      var e = find(
          this.$refs.itemsContainer,
          '[data-pc-section="thumbnailitem"]'
        ),
        t = this.findFocusedIndicatorIndex()
      this.changedFocusedIndicator(t, t + 1 === e.length ? e.length - 1 : t + 1)
    }, 'onRightKey'),
    onLeftKey: __name(function () {
      var e = this.findFocusedIndicatorIndex()
      this.changedFocusedIndicator(e, e - 1 <= 0 ? 0 : e - 1)
    }, 'onLeftKey'),
    onHomeKey: __name(function () {
      var e = this.findFocusedIndicatorIndex()
      this.changedFocusedIndicator(e, 0)
    }, 'onHomeKey'),
    onEndKey: __name(function () {
      var e = find(
          this.$refs.itemsContainer,
          '[data-pc-section="thumbnailitem"]'
        ),
        t = this.findFocusedIndicatorIndex()
      this.changedFocusedIndicator(t, e.length - 1)
    }, 'onEndKey'),
    onTabKey: __name(function () {
      var e = _toConsumableArray(
          find(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"]')
        ),
        t = e.findIndex(function (e) {
          return !0 === getAttribute(e, 'data-p-active')
        }),
        n = findSingle(this.$refs.itemsContainer, '[tabindex="0"]'),
        o = e.findIndex(function (e) {
          return e === n.parentElement
        })
      ;(e[o].children[0].tabIndex = '-1'), (e[t].children[0].tabIndex = '0')
    }, 'onTabKey'),
    findFocusedIndicatorIndex: __name(function () {
      var e = _toConsumableArray(
          find(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"]')
        ),
        t = findSingle(
          this.$refs.itemsContainer,
          '[data-pc-section="thumbnailitem"] > [tabindex="0"]'
        )
      return e.findIndex(function (e) {
        return e === t.parentElement
      })
    }, 'findFocusedIndicatorIndex'),
    changedFocusedIndicator: __name(function (e, t) {
      var n = find(
        this.$refs.itemsContainer,
        '[data-pc-section="thumbnailitem"]'
      )
      ;(n[e].children[0].tabIndex = '-1'),
        (n[t].children[0].tabIndex = '0'),
        n[t].children[0].focus()
    }, 'changedFocusedIndicator'),
    onTransitionEnd: __name(function (e) {
      this.$refs.itemsContainer &&
        'transform' === e.propertyName &&
        (document.body.setAttribute('data-p-items-hidden', 'true'),
        !this.isUnstyled &&
          addClass(this.$refs.itemsContainer, 'p-items-hidden'),
        (this.$refs.itemsContainer.style.transition = ''))
    }, 'onTransitionEnd'),
    onTouchStart: __name(function (e) {
      var t = e.changedTouches[0]
      this.startPos = { x: t.pageX, y: t.pageY }
    }, 'onTouchStart'),
    onTouchMove: __name(function (e) {
      e.cancelable && e.preventDefault()
    }, 'onTouchMove'),
    onTouchEnd: __name(function (e) {
      var t = e.changedTouches[0]
      this.isVertical
        ? this.changePageOnTouch(e, t.pageY - this.startPos.y)
        : this.changePageOnTouch(e, t.pageX - this.startPos.x)
    }, 'onTouchEnd'),
    changePageOnTouch: __name(function (e, t) {
      t < 0 ? this.navForward(e) : this.navBackward(e)
    }, 'changePageOnTouch'),
    getTotalPageNumber: __name(function () {
      return this.value.length > this.d_numVisible
        ? this.value.length - this.d_numVisible + 1
        : 0
    }, 'getTotalPageNumber'),
    createStyle: __name(function () {
      var e
      this.thumbnailsStyle ||
        ((this.thumbnailsStyle = document.createElement('style')),
        (this.thumbnailsStyle.type = 'text/css'),
        setAttribute(
          this.thumbnailsStyle,
          'nonce',
          null === (e = this.$primevue) ||
            void 0 === e ||
            null === (e = e.config) ||
            void 0 === e ||
            null === (e = e.csp) ||
            void 0 === e
            ? void 0
            : e.nonce
        ),
        document.body.appendChild(this.thumbnailsStyle))
      var t = '\n                #'
        .concat(
          this.containerId,
          ' [data-pc-section="thumbnailitem"] {\n                    flex: 1 0 '
        )
        .concat(100 / this.d_numVisible, '%\n                }\n            ')
      if (this.responsiveOptions && !this.isUnstyled) {
        this.sortedResponsiveOptions = _toConsumableArray(
          this.responsiveOptions
        )
        var n = localeComparator()
        this.sortedResponsiveOptions.sort(function (e, t) {
          return sort(e.breakpoint, t.breakpoint, -1, n)
        })
        for (var o = 0; o < this.sortedResponsiveOptions.length; o++) {
          var i = this.sortedResponsiveOptions[o]
          t += '\n                        @media screen and (max-width: '
            .concat(i.breakpoint, ') {\n                            #')
            .concat(
              this.containerId,
              ' .p-galleria-thumbnail-item {\n                                flex: 1 0 '
            )
            .concat(
              100 / i.numVisible,
              '%\n                            }\n                        }\n                    '
            )
        }
      }
      this.thumbnailsStyle.innerHTML = t
    }, 'createStyle'),
    calculatePosition: __name(function () {
      if (this.$refs.itemsContainer && this.sortedResponsiveOptions) {
        for (
          var e = window.innerWidth, t = { numVisible: this.numVisible }, n = 0;
          n < this.sortedResponsiveOptions.length;
          n++
        ) {
          var o = this.sortedResponsiveOptions[n]
          parseInt(o.breakpoint, 10) >= e && (t = o)
        }
        this.d_numVisible !== t.numVisible && (this.d_numVisible = t.numVisible)
      }
    }, 'calculatePosition'),
    bindDocumentListeners: __name(function () {
      var e = this
      this.documentResizeListener ||
        ((this.documentResizeListener = function () {
          e.calculatePosition()
        }),
        window.addEventListener('resize', this.documentResizeListener))
    }, 'bindDocumentListeners'),
    unbindDocumentListeners: __name(function () {
      this.documentResizeListener &&
        (window.removeEventListener('resize', this.documentResizeListener),
        (this.documentResizeListener = null))
    }, 'unbindDocumentListeners'),
    isNavBackwardDisabled: __name(function () {
      return (
        (!this.circular && 0 === this.d_activeIndex) ||
        this.value.length <= this.d_numVisible
      )
    }, 'isNavBackwardDisabled'),
    isNavForwardDisabled: __name(function () {
      return (
        (!this.circular && this.d_activeIndex === this.value.length - 1) ||
        this.value.length <= this.d_numVisible
      )
    }, 'isNavForwardDisabled'),
    firstItemAciveIndex: __name(function () {
      return -1 * this.totalShiftedItems
    }, 'firstItemAciveIndex'),
    lastItemActiveIndex: __name(function () {
      return this.firstItemAciveIndex() + this.d_numVisible - 1
    }, 'lastItemActiveIndex'),
    isItemActive: __name(function (e) {
      return this.firstItemAciveIndex() <= e && this.lastItemActiveIndex() >= e
    }, 'isItemActive'),
    ariaPageLabel: __name(function (e) {
      return this.$primevue.config.locale.aria
        ? this.$primevue.config.locale.aria.pageLabel.replace(/{page}/g, e)
        : void 0
    }, 'ariaPageLabel')
  },
  computed: {
    ariaPrevButtonLabel: __name(function () {
      return this.$primevue.config.locale.aria
        ? this.$primevue.config.locale.aria.prevPageLabel
        : void 0
    }, 'ariaPrevButtonLabel'),
    ariaNextButtonLabel: __name(function () {
      return this.$primevue.config.locale.aria
        ? this.$primevue.config.locale.aria.nextPageLabel
        : void 0
    }, 'ariaNextButtonLabel')
  },
  components: {
    ChevronLeftIcon: script$q,
    ChevronRightIcon: script$p,
    ChevronUpIcon: script$6,
    ChevronDownIcon: script$y
  },
  directives: { ripple: Ripple }
}
function _typeof$2$1(e) {
  return (_typeof$2$1 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$2(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$2(Object(n), !0).forEach(function (t) {
          _defineProperty$2$1(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$2(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$2$1(e, t, n) {
  return (
    (t = _toPropertyKey$2$1(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$2$1(e) {
  var t = _toPrimitive$2$1(e, 'string')
  return 'symbol' == _typeof$2$1(t) ? t : t + ''
}
function _toPrimitive$2$1(e, t) {
  if ('object' != _typeof$2$1(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$2$1(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$2$1, '_typeof$2$1'),
  __name(ownKeys$2, 'ownKeys$2'),
  __name(_objectSpread$2, '_objectSpread$2'),
  __name(_defineProperty$2$1, '_defineProperty$2$1'),
  __name(_toPropertyKey$2$1, '_toPropertyKey$2$1'),
  __name(_toPrimitive$2$1, '_toPrimitive$2$1')
var _hoisted_1$2$1 = ['disabled', 'aria-label'],
  _hoisted_2$1$1 = [
    'data-p-active',
    'aria-selected',
    'aria-controls',
    'onKeydown',
    'data-p-galleria-thumbnail-item-current',
    'data-p-galleria-thumbnail-item-active',
    'data-p-galleria-thumbnail-item-start',
    'data-p-galleria-thumbnail-item-end'
  ],
  _hoisted_3$1$1 = ['tabindex', 'aria-label', 'aria-current', 'onClick'],
  _hoisted_4$2 = ['disabled', 'aria-label']
function render$2(e, t, n, o, i, r) {
  var a = Vue.resolveDirective('ripple')
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps({ class: e.cx('thumbnails') }, e.ptm('thumbnails')),
      [
        Vue.createElementVNode(
          'div',
          Vue.mergeProps(
            { class: e.cx('thumbnailContent') },
            e.ptm('thumbnailContent')
          ),
          [
            n.showThumbnailNavigators
              ? Vue.withDirectives(
                  (Vue.openBlock(),
                  Vue.createElementBlock(
                    'button',
                    Vue.mergeProps(
                      {
                        key: 0,
                        class: e.cx('thumbnailPrevButton'),
                        disabled: r.isNavBackwardDisabled(),
                        type: 'button',
                        'aria-label': r.ariaPrevButtonLabel,
                        onClick:
                          t[0] ||
                          (t[0] = function (e) {
                            return r.navBackward(e)
                          })
                      },
                      _objectSpread$2(
                        _objectSpread$2({}, n.prevButtonProps),
                        e.ptm('thumbnailPrevButton')
                      ),
                      { 'data-pc-group-section': 'thumbnailnavigator' }
                    ),
                    [
                      (Vue.openBlock(),
                      Vue.createBlock(
                        Vue.resolveDynamicComponent(
                          n.templates.previousthumbnailicon ||
                            (n.isVertical ? 'ChevronUpIcon' : 'ChevronLeftIcon')
                        ),
                        Vue.mergeProps(
                          { class: e.cx('thumbnailPrevIcon') },
                          e.ptm('thumbnailPrevIcon')
                        ),
                        null,
                        16,
                        ['class']
                      ))
                    ],
                    16,
                    _hoisted_1$2$1
                  )),
                  [[a]]
                )
              : Vue.createCommentVNode('', !0),
            Vue.createElementVNode(
              'div',
              Vue.mergeProps(
                {
                  class: e.cx('thumbnailsViewport'),
                  style: { height: n.isVertical ? n.contentHeight : '' }
                },
                e.ptm('thumbnailsViewport')
              ),
              [
                Vue.createElementVNode(
                  'div',
                  Vue.mergeProps(
                    {
                      ref: 'itemsContainer',
                      class: e.cx('thumbnailItems'),
                      role: 'tablist',
                      onTransitionend:
                        t[1] ||
                        (t[1] = function (e) {
                          return r.onTransitionEnd(e)
                        }),
                      onTouchstart:
                        t[2] ||
                        (t[2] = function (e) {
                          return r.onTouchStart(e)
                        }),
                      onTouchmove:
                        t[3] ||
                        (t[3] = function (e) {
                          return r.onTouchMove(e)
                        }),
                      onTouchend:
                        t[4] ||
                        (t[4] = function (e) {
                          return r.onTouchEnd(e)
                        })
                    },
                    e.ptm('thumbnailItems')
                  ),
                  [
                    (Vue.openBlock(!0),
                    Vue.createElementBlock(
                      Vue.Fragment,
                      null,
                      Vue.renderList(n.value, function (t, o) {
                        return (
                          Vue.openBlock(),
                          Vue.createElementBlock(
                            'div',
                            Vue.mergeProps(
                              {
                                key: 'p-galleria-thumbnail-item-'.concat(o),
                                class: e.cx('thumbnailItem', {
                                  index: o,
                                  activeIndex: n.activeIndex
                                }),
                                role: 'tab',
                                'data-p-active': n.activeIndex === o,
                                'aria-selected': n.activeIndex === o,
                                'aria-controls': n.containerId + '_item_' + o,
                                onKeydown: __name(function (e) {
                                  return r.onThumbnailKeydown(e, o)
                                }, 'onKeydown'),
                                ref_for: !0
                              },
                              e.ptm('thumbnailItem'),
                              {
                                'data-p-galleria-thumbnail-item-current':
                                  n.activeIndex === o,
                                'data-p-galleria-thumbnail-item-active':
                                  r.isItemActive(o),
                                'data-p-galleria-thumbnail-item-start':
                                  r.firstItemAciveIndex() === o,
                                'data-p-galleria-thumbnail-item-end':
                                  r.lastItemActiveIndex() === o
                              }
                            ),
                            [
                              Vue.createElementVNode(
                                'div',
                                Vue.mergeProps(
                                  {
                                    class: e.cx('thumbnail'),
                                    tabindex: n.activeIndex === o ? '0' : '-1',
                                    'aria-label': r.ariaPageLabel(o + 1),
                                    'aria-current':
                                      n.activeIndex === o ? 'page' : void 0,
                                    onClick: __name(function (e) {
                                      return r.onItemClick(o)
                                    }, 'onClick'),
                                    ref_for: !0
                                  },
                                  e.ptm('thumbnail')
                                ),
                                [
                                  n.templates.thumbnail
                                    ? (Vue.openBlock(),
                                      Vue.createBlock(
                                        Vue.resolveDynamicComponent(
                                          n.templates.thumbnail
                                        ),
                                        { key: 0, item: t },
                                        null,
                                        8,
                                        ['item']
                                      ))
                                    : Vue.createCommentVNode('', !0)
                                ],
                                16,
                                _hoisted_3$1$1
                              )
                            ],
                            16,
                            _hoisted_2$1$1
                          )
                        )
                      }),
                      128
                    ))
                  ],
                  16
                )
              ],
              16
            ),
            n.showThumbnailNavigators
              ? Vue.withDirectives(
                  (Vue.openBlock(),
                  Vue.createElementBlock(
                    'button',
                    Vue.mergeProps(
                      {
                        key: 1,
                        class: e.cx('thumbnailNextButton'),
                        disabled: r.isNavForwardDisabled(),
                        type: 'button',
                        'aria-label': r.ariaNextButtonLabel,
                        onClick:
                          t[5] ||
                          (t[5] = function (e) {
                            return r.navForward(e)
                          })
                      },
                      _objectSpread$2(
                        _objectSpread$2({}, n.nextButtonProps),
                        e.ptm('thumbnailNextButton')
                      ),
                      { 'data-pc-group-section': 'thumbnailnavigator' }
                    ),
                    [
                      (Vue.openBlock(),
                      Vue.createBlock(
                        Vue.resolveDynamicComponent(
                          n.templates.nextthumbnailicon ||
                            (n.isVertical
                              ? 'ChevronDownIcon'
                              : 'ChevronRightIcon')
                        ),
                        Vue.mergeProps(
                          { class: e.cx('thumbnailNextIcon') },
                          e.ptm('thumbnailNextIcon')
                        ),
                        null,
                        16,
                        ['class']
                      ))
                    ],
                    16,
                    _hoisted_4$2
                  )),
                  [[a]]
                )
              : Vue.createCommentVNode('', !0)
          ],
          16
        )
      ],
      16
    )
  )
}
function _typeof$1$1(e) {
  return (_typeof$1$1 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$1$1(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$1$1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$1$1(Object(n), !0).forEach(function (t) {
          _defineProperty$1$1(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$1$1(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$1$1(e, t, n) {
  return (
    (t = _toPropertyKey$1$1(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$1$1(e) {
  var t = _toPrimitive$1$1(e, 'string')
  return 'symbol' == _typeof$1$1(t) ? t : t + ''
}
function _toPrimitive$1$1(e, t) {
  if ('object' != _typeof$1$1(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$1$1(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(render$2, 'render$2'),
  (script$2$1.render = render$2),
  __name(_typeof$1$1, '_typeof$1$1'),
  __name(ownKeys$1$1, 'ownKeys$1$1'),
  __name(_objectSpread$1$1, '_objectSpread$1$1'),
  __name(_defineProperty$1$1, '_defineProperty$1$1'),
  __name(_toPropertyKey$1$1, '_toPropertyKey$1$1'),
  __name(_toPrimitive$1$1, '_toPrimitive$1$1')
var script$1$2 = {
  name: 'GalleriaContent',
  hostName: 'Galleria',
  extends: script$Y,
  inheritAttrs: !1,
  interval: null,
  emits: ['activeitem-change', 'mask-hide'],
  data: __name(function () {
    return {
      id: this.$attrs.id || UniqueComponentId(),
      activeIndex: this.$attrs.activeIndex,
      numVisible: this.$attrs.numVisible,
      slideShowActive: !1
    }
  }, 'data'),
  watch: {
    '$attrs.id': __name(function (e) {
      this.id = e || UniqueComponentId()
    }, '$attrsId'),
    '$attrs.value': __name(function (e) {
      e && e.length < this.numVisible && (this.numVisible = e.length)
    }, '$attrsValue'),
    '$attrs.activeIndex': __name(function (e) {
      this.activeIndex = e
    }, '$attrsActiveIndex'),
    '$attrs.numVisible': __name(function (e) {
      this.numVisible = e
    }, '$attrsNumVisible'),
    '$attrs.autoPlay': __name(function (e) {
      e ? this.startSlideShow() : this.stopSlideShow()
    }, '$attrsAutoPlay')
  },
  mounted: __name(function () {
    this.id = this.id || UniqueComponentId()
  }, 'mounted'),
  updated: __name(function () {
    this.$emit('activeitem-change', this.activeIndex)
  }, 'updated'),
  beforeUnmount: __name(function () {
    this.slideShowActive && this.stopSlideShow()
  }, 'beforeUnmount'),
  methods: {
    getPTOptions: __name(function (e) {
      return this.ptm(e, {
        props: _objectSpread$1$1(
          _objectSpread$1$1({}, this.$attrs),
          {},
          { pt: this.pt, unstyled: this.unstyled }
        )
      })
    }, 'getPTOptions'),
    isAutoPlayActive: __name(function () {
      return this.slideShowActive
    }, 'isAutoPlayActive'),
    startSlideShow: __name(function () {
      var e = this
      ;(this.interval = setInterval(function () {
        var t =
          e.$attrs.circular && e.$attrs.value.length - 1 === e.activeIndex
            ? 0
            : e.activeIndex + 1
        e.activeIndex = t
      }, this.$attrs.transitionInterval)),
        (this.slideShowActive = !0)
    }, 'startSlideShow'),
    stopSlideShow: __name(function () {
      this.interval && clearInterval(this.interval), (this.slideShowActive = !1)
    }, 'stopSlideShow'),
    getPositionClass: __name(function (e, t) {
      var n = ['top', 'left', 'bottom', 'right'].find(function (e) {
        return e === t
      })
      return n ? ''.concat(e, '-').concat(n) : ''
    }, 'getPositionClass'),
    isVertical: __name(function () {
      return (
        'left' === this.$attrs.thumbnailsPosition ||
        'right' === this.$attrs.thumbnailsPosition
      )
    }, 'isVertical')
  },
  computed: {
    closeAriaLabel: __name(function () {
      return this.$primevue.config.locale.aria
        ? this.$primevue.config.locale.aria.close
        : void 0
    }, 'closeAriaLabel')
  },
  components: {
    GalleriaItem: script$3,
    GalleriaThumbnails: script$2$1,
    TimesIcon: script$x
  },
  directives: { ripple: Ripple }
}
function _typeof$3(e) {
  return (_typeof$3 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$3(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$3(Object(n), !0).forEach(function (t) {
          _defineProperty$3(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$3(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$3(e, t, n) {
  return (
    (t = _toPropertyKey$3(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$3(e) {
  var t = _toPrimitive$3(e, 'string')
  return 'symbol' == _typeof$3(t) ? t : t + ''
}
function _toPrimitive$3(e, t) {
  if ('object' != _typeof$3(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$3(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$3, '_typeof$3'),
  __name(ownKeys$3, 'ownKeys$3'),
  __name(_objectSpread$3, '_objectSpread$3'),
  __name(_defineProperty$3, '_defineProperty$3'),
  __name(_toPropertyKey$3, '_toPropertyKey$3'),
  __name(_toPrimitive$3, '_toPrimitive$3')
var _hoisted_1$1$1 = ['id', 'aria-label', 'aria-roledescription'],
  _hoisted_2$3 = ['aria-label'],
  _hoisted_3$3 = ['aria-live']
function render$1$1(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('GalleriaItem'),
    s = Vue.resolveComponent('GalleriaThumbnails'),
    l = Vue.resolveDirective('ripple')
  return e.$attrs.value && e.$attrs.value.length > 0
    ? (Vue.openBlock(),
      Vue.createElementBlock(
        'div',
        Vue.mergeProps(
          {
            key: 0,
            id: i.id,
            role: 'region',
            class: [e.cx('root'), e.$attrs.containerClass],
            style: e.$attrs.containerStyle,
            'aria-label': e.$attrs.ariaLabel,
            'aria-roledescription': e.$attrs.ariaRoledescription
          },
          _objectSpread$3(
            _objectSpread$3({}, e.$attrs.containerProps),
            r.getPTOptions('root')
          )
        ),
        [
          e.$attrs.fullScreen
            ? Vue.withDirectives(
                (Vue.openBlock(),
                Vue.createElementBlock(
                  'button',
                  Vue.mergeProps(
                    {
                      key: 0,
                      autofocus: '',
                      type: 'button',
                      class: e.cx('closeButton'),
                      'aria-label': r.closeAriaLabel,
                      onClick:
                        t[0] ||
                        (t[0] = function (t) {
                          return e.$emit('mask-hide')
                        })
                    },
                    r.getPTOptions('closeButton')
                  ),
                  [
                    (Vue.openBlock(),
                    Vue.createBlock(
                      Vue.resolveDynamicComponent(
                        e.$attrs.templates.closeicon || 'TimesIcon'
                      ),
                      Vue.mergeProps(
                        { class: e.cx('closeIcon') },
                        r.getPTOptions('closeIcon')
                      ),
                      null,
                      16,
                      ['class']
                    ))
                  ],
                  16,
                  _hoisted_2$3
                )),
                [[l]]
              )
            : Vue.createCommentVNode('', !0),
          e.$attrs.templates && e.$attrs.templates.header
            ? (Vue.openBlock(),
              Vue.createElementBlock(
                'div',
                Vue.mergeProps(
                  { key: 1, class: e.cx('header') },
                  r.getPTOptions('header')
                ),
                [
                  (Vue.openBlock(),
                  Vue.createBlock(
                    Vue.resolveDynamicComponent(e.$attrs.templates.header)
                  ))
                ],
                16
              ))
            : Vue.createCommentVNode('', !0),
          Vue.createElementVNode(
            'div',
            Vue.mergeProps(
              {
                class: e.cx('content'),
                'aria-live': e.$attrs.autoPlay ? 'polite' : 'off'
              },
              r.getPTOptions('content')
            ),
            [
              Vue.createVNode(
                a,
                {
                  id: i.id,
                  activeIndex: i.activeIndex,
                  'onUpdate:activeIndex':
                    t[1] ||
                    (t[1] = function (e) {
                      return (i.activeIndex = e)
                    }),
                  slideShowActive: i.slideShowActive,
                  'onUpdate:slideShowActive':
                    t[2] ||
                    (t[2] = function (e) {
                      return (i.slideShowActive = e)
                    }),
                  value: e.$attrs.value,
                  circular: e.$attrs.circular,
                  templates: e.$attrs.templates,
                  showIndicators: e.$attrs.showIndicators,
                  changeItemOnIndicatorHover:
                    e.$attrs.changeItemOnIndicatorHover,
                  showItemNavigators: e.$attrs.showItemNavigators,
                  autoPlay: e.$attrs.autoPlay,
                  onStartSlideshow: r.startSlideShow,
                  onStopSlideshow: r.stopSlideShow,
                  pt: e.pt,
                  unstyled: e.unstyled
                },
                null,
                8,
                [
                  'id',
                  'activeIndex',
                  'slideShowActive',
                  'value',
                  'circular',
                  'templates',
                  'showIndicators',
                  'changeItemOnIndicatorHover',
                  'showItemNavigators',
                  'autoPlay',
                  'onStartSlideshow',
                  'onStopSlideshow',
                  'pt',
                  'unstyled'
                ]
              ),
              e.$attrs.showThumbnails
                ? (Vue.openBlock(),
                  Vue.createBlock(
                    s,
                    {
                      key: 0,
                      activeIndex: i.activeIndex,
                      'onUpdate:activeIndex':
                        t[3] ||
                        (t[3] = function (e) {
                          return (i.activeIndex = e)
                        }),
                      slideShowActive: i.slideShowActive,
                      'onUpdate:slideShowActive':
                        t[4] ||
                        (t[4] = function (e) {
                          return (i.slideShowActive = e)
                        }),
                      containerId: i.id,
                      value: e.$attrs.value,
                      templates: e.$attrs.templates,
                      numVisible: i.numVisible,
                      responsiveOptions: e.$attrs.responsiveOptions,
                      circular: e.$attrs.circular,
                      isVertical: r.isVertical(),
                      contentHeight: e.$attrs.verticalThumbnailViewPortHeight,
                      showThumbnailNavigators: e.$attrs.showThumbnailNavigators,
                      prevButtonProps: e.$attrs.prevButtonProps,
                      nextButtonProps: e.$attrs.nextButtonProps,
                      onStopSlideshow: r.stopSlideShow,
                      pt: e.pt,
                      unstyled: e.unstyled
                    },
                    null,
                    8,
                    [
                      'activeIndex',
                      'slideShowActive',
                      'containerId',
                      'value',
                      'templates',
                      'numVisible',
                      'responsiveOptions',
                      'circular',
                      'isVertical',
                      'contentHeight',
                      'showThumbnailNavigators',
                      'prevButtonProps',
                      'nextButtonProps',
                      'onStopSlideshow',
                      'pt',
                      'unstyled'
                    ]
                  ))
                : Vue.createCommentVNode('', !0)
            ],
            16,
            _hoisted_3$3
          ),
          e.$attrs.templates && e.$attrs.templates.footer
            ? (Vue.openBlock(),
              Vue.createElementBlock(
                'div',
                Vue.mergeProps(
                  { key: 2, class: e.cx('footer') },
                  r.getPTOptions('footer')
                ),
                [
                  (Vue.openBlock(),
                  Vue.createBlock(
                    Vue.resolveDynamicComponent(e.$attrs.templates.footer)
                  ))
                ],
                16
              ))
            : Vue.createCommentVNode('', !0)
        ],
        16,
        _hoisted_1$1$1
      ))
    : Vue.createCommentVNode('', !0)
}
__name(render$1$1, 'render$1$1'), (script$1$2.render = render$1$1)
var script$5 = {
    name: 'Galleria',
    extends: script$4,
    inheritAttrs: !1,
    emits: ['update:activeIndex', 'update:visible'],
    container: null,
    mask: null,
    data: __name(function () {
      return { containerVisible: this.visible }
    }, 'data'),
    updated: __name(function () {
      this.fullScreen && this.visible && (this.containerVisible = this.visible)
    }, 'updated'),
    beforeUnmount: __name(function () {
      this.fullScreen && unblockBodyScroll(),
        (this.mask = null),
        this.container &&
          (ZIndex.clear(this.container), (this.container = null))
    }, 'beforeUnmount'),
    methods: {
      onBeforeEnter: __name(function (e) {
        ZIndex.set(
          'modal',
          e,
          this.baseZIndex || this.$primevue.config.zIndex.modal
        )
      }, 'onBeforeEnter'),
      onEnter: __name(function (e) {
        ;(this.mask.style.zIndex = String(parseInt(e.style.zIndex, 10) - 1)),
          blockBodyScroll(),
          this.focus()
      }, 'onEnter'),
      onBeforeLeave: __name(function () {
        !this.isUnstyled && addClass(this.mask, 'p-overlay-mask-leave')
      }, 'onBeforeLeave'),
      onAfterLeave: __name(function (e) {
        ZIndex.clear(e), (this.containerVisible = !1), unblockBodyScroll()
      }, 'onAfterLeave'),
      onActiveItemChange: __name(function (e) {
        this.activeIndex !== e && this.$emit('update:activeIndex', e)
      }, 'onActiveItemChange'),
      maskHide: __name(function () {
        this.$emit('update:visible', !1)
      }, 'maskHide'),
      containerRef: __name(function (e) {
        this.container = e
      }, 'containerRef'),
      maskRef: __name(function (e) {
        this.mask = e
      }, 'maskRef'),
      focus: __name(function () {
        var e = this.container.$el.querySelector('[autofocus]')
        e && e.focus()
      }, 'focus')
    },
    components: { GalleriaContent: script$1$2, Portal: script$w },
    directives: { focustrap: FocusTrap }
  },
  _hoisted_1$6 = ['aria-modal']
function render$4(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('GalleriaContent'),
    s = Vue.resolveComponent('Portal'),
    l = Vue.resolveDirective('focustrap')
  return e.fullScreen
    ? (Vue.openBlock(),
      Vue.createBlock(
        s,
        { key: 0 },
        {
          default: Vue.withCtx(function () {
            return [
              i.containerVisible
                ? (Vue.openBlock(),
                  Vue.createElementBlock(
                    'div',
                    Vue.mergeProps(
                      {
                        key: 0,
                        ref: r.maskRef,
                        class: [e.cx('mask'), e.maskClass],
                        role: 'dialog',
                        'aria-modal': e.fullScreen ? 'true' : void 0
                      },
                      e.ptm('mask')
                    ),
                    [
                      Vue.createVNode(
                        Vue.Transition,
                        Vue.mergeProps(
                          {
                            name: 'p-galleria',
                            onBeforeEnter: r.onBeforeEnter,
                            onEnter: r.onEnter,
                            onBeforeLeave: r.onBeforeLeave,
                            onAfterLeave: r.onAfterLeave,
                            appear: ''
                          },
                          e.ptm('transition')
                        ),
                        {
                          default: Vue.withCtx(function () {
                            return [
                              e.visible
                                ? Vue.withDirectives(
                                    (Vue.openBlock(),
                                    Vue.createBlock(
                                      a,
                                      Vue.mergeProps(
                                        {
                                          key: 0,
                                          ref: r.containerRef,
                                          onMaskHide: r.maskHide,
                                          templates: e.$slots,
                                          onActiveitemChange:
                                            r.onActiveItemChange,
                                          pt: e.pt,
                                          unstyled: e.unstyled
                                        },
                                        e.$props
                                      ),
                                      null,
                                      16,
                                      [
                                        'onMaskHide',
                                        'templates',
                                        'onActiveitemChange',
                                        'pt',
                                        'unstyled'
                                      ]
                                    )),
                                    [[l]]
                                  )
                                : Vue.createCommentVNode('', !0)
                            ]
                          }),
                          _: 1
                        },
                        16,
                        [
                          'onBeforeEnter',
                          'onEnter',
                          'onBeforeLeave',
                          'onAfterLeave'
                        ]
                      )
                    ],
                    16,
                    _hoisted_1$6
                  ))
                : Vue.createCommentVNode('', !0)
            ]
          }),
          _: 1
        }
      ))
    : (Vue.openBlock(),
      Vue.createBlock(
        a,
        Vue.mergeProps(
          {
            key: 1,
            templates: e.$slots,
            onActiveitemChange: r.onActiveItemChange,
            pt: e.pt,
            unstyled: e.unstyled
          },
          e.$props
        ),
        null,
        16,
        ['templates', 'onActiveitemChange', 'pt', 'unstyled']
      ))
}
__name(render$4, 'render$4'), (script$5.render = render$4)
const _sfc_main$7 = Vue.defineComponent({
    __name: 'ResultGallery',
    props: { allGalleryItems: {}, activeIndex: {} },
    emits: ['update:activeIndex'],
    setup(e, { emit: t }) {
      const n = Vue.ref(!1),
        o = t,
        i = e
      let r = null
      const a = __name((e) => {
          r = e.target
        }, 'onMaskMouseDown'),
        s = __name((e) => {
          const t = document.querySelector('[data-mask]')
          n.value && r === e.target && r === t && ((n.value = !1), l(!1))
        }, 'onMaskMouseUp')
      Vue.watch(
        () => i.activeIndex,
        (e) => {
          ;-1 !== e && (n.value = !0)
        }
      )
      const l = __name((e) => {
          e || o('update:activeIndex', -1)
        }, 'handleVisibilityChange'),
        c = __name((e) => {
          o('update:activeIndex', e)
        }, 'handleActiveIndexChange'),
        d = __name((e) => {
          if (n.value)
            switch (e.key) {
              case 'ArrowLeft':
                u(-1)
                break
              case 'ArrowRight':
                u(1)
                break
              case 'Escape':
                ;(n.value = !1), l(!1)
            }
        }, 'handleKeyDown'),
        u = __name((e) => {
          const t =
            (i.activeIndex + e + i.allGalleryItems.length) %
            i.allGalleryItems.length
          o('update:activeIndex', t)
        }, 'navigateImage')
      return (
        Vue.onMounted(() => {
          window.addEventListener('keydown', d)
        }),
        Vue.onUnmounted(() => {
          window.removeEventListener('keydown', d)
        }),
        (e, t) => (
          Vue.openBlock(),
          Vue.createBlock(
            Vue.unref(script$5),
            {
              visible: n.value,
              'onUpdate:visible': [t[0] || (t[0] = (e) => (n.value = e)), l],
              activeIndex: e.activeIndex,
              'onUpdate:activeIndex': c,
              value: e.allGalleryItems,
              showIndicators: !1,
              changeItemOnIndicatorHover: '',
              showItemNavigators: '',
              fullScreen: '',
              circular: '',
              showThumbnails: !1,
              pt: { mask: { onMousedown: a, onMouseup: s, 'data-mask': !0 } }
            },
            {
              item: Vue.withCtx(({ item: e }) => [
                e.isImage
                  ? (Vue.openBlock(),
                    Vue.createBlock(
                      ComfyImage,
                      {
                        key: e.url,
                        src: e.url,
                        contain: !1,
                        class: 'galleria-image'
                      },
                      null,
                      8,
                      ['src']
                    ))
                  : e.isVideo
                    ? (Vue.openBlock(),
                      Vue.createBlock(
                        _sfc_main$a,
                        { key: 1, result: e },
                        null,
                        8,
                        ['result']
                      ))
                    : Vue.createCommentVNode('', !0)
              ]),
              _: 1
            },
            8,
            ['visible', 'activeIndex', 'value', 'pt']
          )
        )
      )
    }
  }),
  _hoisted_1$5 = { class: 'queue-grid' },
  _hoisted_2$2 = { key: 1 },
  _hoisted_3$1 = { key: 2 },
  IMAGE_FIT = 'Comfy.Queue.ImageFit',
  ITEMS_PER_PAGE = 8,
  SCROLL_THRESHOLD = 100,
  _sfc_main$6 = Vue.defineComponent({
    __name: 'QueueSidebarTab',
    setup(e) {
      const t = useConfirm(),
        n = useToast(),
        o = useQueueStore(),
        i = useSettingStore(),
        r = useCommandStore(),
        { t: a } = VueI18n.useI18n(),
        s = Vue.ref(!1),
        l = Vue.ref([]),
        c = Vue.ref(null),
        d = Vue.ref(null),
        u = Vue.ref(-1),
        p = Vue.ref(null),
        h = Vue.computed(() => null !== p.value),
        m = Vue.computed(() => i.get(IMAGE_FIT)),
        f = Vue.computed(() =>
          h.value
            ? p.value
              ? p.value.flatten()
              : []
            : s.value
              ? o.flatTasks
              : o.tasks
        ),
        _ = Vue.computed(() =>
          f.value.flatMap((e) => {
            const t = e.previewOutput
            return t ? [t] : []
          })
        ),
        g = __name(() => {
          const e = l.value.length,
            t = f.value.slice(e, e + ITEMS_PER_PAGE)
          l.value.push(...t)
        }, 'loadMoreItems'),
        v = __name(() => {
          if (!c.value) return
          const { scrollHeight: e, scrollTop: t, clientHeight: n } = c.value
          e - t - n < SCROLL_THRESHOLD && g()
        }, 'checkAndLoadMore')
      useInfiniteScroll(
        c,
        () => {
          l.value.length < f.value.length && g()
        },
        { distance: SCROLL_THRESHOLD }
      ),
        useResizeObserver(c, () => {
          Vue.nextTick(() => {
            v()
          })
        })
      const y = __name(() => {
          l.value = f.value.slice(0, ITEMS_PER_PAGE)
        }, 'updateVisibleTasks'),
        b = __name(() => {
          ;(s.value = !s.value), y()
        }, 'toggleExpanded'),
        S = __name((e) => {
          e.isRunning && api.interrupt(), o.delete(e)
        }, 'removeTask'),
        C = __name(async () => {
          await o.clear()
        }, 'removeAllTasks'),
        w = __name((e) => {
          t.require({
            target: e.currentTarget,
            message: 'Do you want to delete all tasks?',
            icon: 'pi pi-info-circle',
            rejectProps: {
              label: 'Cancel',
              severity: 'secondary',
              outlined: !0
            },
            acceptProps: { label: 'Delete', severity: 'danger' },
            accept: __name(async () => {
              await C(),
                n.add({
                  severity: 'info',
                  summary: 'Confirmed',
                  detail: 'Tasks deleted',
                  life: 3e3
                })
            }, 'accept')
          })
        }, 'confirmRemoveAll'),
        k = __name(async () => {
          await o.update(), y()
        }, 'onStatus'),
        x = Vue.ref(null),
        E = Vue.ref(null),
        I = Vue.ref(null),
        T = Vue.computed(() => [
          {
            label: a('delete'),
            icon: 'pi pi-trash',
            command: __name(() => E.value && S(E.value), 'command'),
            disabled: s.value || h.value
          },
          {
            label: a('loadWorkflow'),
            icon: 'pi pi-file-export',
            command: __name(() => E.value?.loadWorkflow(app$1), 'command'),
            disabled: !E.value?.workflow
          },
          {
            label: a('goToNode'),
            icon: 'pi pi-arrow-circle-right',
            command: __name(() => app$1.goToNode(I.value?.id), 'command'),
            visible: !!I.value
          }
        ]),
        $ = __name(({ task: e, event: t, node: n }) => {
          ;(E.value = e), (I.value = n), x.value?.show(t)
        }, 'handleContextMenu'),
        L = __name((e) => {
          u.value = _.value.findIndex((t) => t.url === e.previewOutput?.url)
        }, 'handlePreview'),
        A = __name((e) => {
          ;(p.value = e), y()
        }, 'enterFolderView'),
        O = __name(() => {
          ;(p.value = null), y()
        }, 'exitFolderView'),
        P = __name(() => {
          i.set(IMAGE_FIT, 'cover' === m.value ? 'contain' : 'cover')
        }, 'toggleImageFit')
      return (
        Vue.onMounted(() => {
          api.addEventListener('status', k), o.update()
        }),
        Vue.onUnmounted(() => {
          api.removeEventListener('status', k)
        }),
        Vue.watch(
          f,
          (e) => {
            ;(0 === l.value.length || l.value.length > e.length) && y(),
              Vue.nextTick(() => {
                v()
              })
          },
          { immediate: !0 }
        ),
        (e, t) => {
          const n = Vue.resolveDirective('tooltip')
          return (
            Vue.openBlock(),
            Vue.createElementBlock(
              Vue.Fragment,
              null,
              [
                Vue.createVNode(
                  SidebarTabTemplate,
                  { title: e.$t('sideToolbar.queue') },
                  {
                    'tool-buttons': Vue.withCtx(() => [
                      Vue.withDirectives(
                        Vue.createVNode(
                          Vue.unref(script$K),
                          {
                            icon:
                              'cover' === m.value
                                ? 'pi pi-arrow-down-left-and-arrow-up-right-to-center'
                                : 'pi pi-arrow-up-right-and-arrow-down-left-from-center',
                            text: '',
                            severity: 'secondary',
                            onClick: P,
                            class: 'toggle-expanded-button'
                          },
                          null,
                          8,
                          ['icon']
                        ),
                        [
                          [
                            n,
                            e.$t(`sideToolbar.queueTab.${m.value}ImagePreview`),
                            void 0,
                            { bottom: !0 }
                          ]
                        ]
                      ),
                      h.value
                        ? Vue.withDirectives(
                            (Vue.openBlock(),
                            Vue.createBlock(
                              Vue.unref(script$K),
                              {
                                key: 0,
                                icon: 'pi pi-arrow-left',
                                text: '',
                                severity: 'secondary',
                                onClick: O,
                                class: 'back-button'
                              },
                              null,
                              512
                            )),
                            [
                              [
                                n,
                                e.$t('sideToolbar.queueTab.backToAllTasks'),
                                void 0,
                                { bottom: !0 }
                              ]
                            ]
                          )
                        : (Vue.openBlock(),
                          Vue.createElementBlock(
                            Vue.Fragment,
                            { key: 1 },
                            [
                              Vue.withDirectives(
                                Vue.createVNode(
                                  Vue.unref(script$K),
                                  {
                                    icon: s.value
                                      ? 'pi pi-images'
                                      : 'pi pi-image',
                                    text: '',
                                    severity: 'secondary',
                                    onClick: b,
                                    class: 'toggle-expanded-button'
                                  },
                                  null,
                                  8,
                                  ['icon']
                                ),
                                [[n, e.$t('sideToolbar.queueTab.showFlatList')]]
                              ),
                              Vue.unref(o).hasPendingTasks
                                ? Vue.withDirectives(
                                    (Vue.openBlock(),
                                    Vue.createBlock(
                                      Vue.unref(script$K),
                                      {
                                        key: 0,
                                        icon: 'pi pi-stop',
                                        severity: 'danger',
                                        text: '',
                                        onClick:
                                          t[0] ||
                                          (t[0] = () =>
                                            Vue.unref(r).execute(
                                              'Comfy.ClearPendingTasks'
                                            ))
                                      },
                                      null,
                                      512
                                    )),
                                    [
                                      [
                                        n,
                                        e.$t(
                                          'sideToolbar.queueTab.clearPendingTasks'
                                        ),
                                        void 0,
                                        { bottom: !0 }
                                      ]
                                    ]
                                  )
                                : Vue.createCommentVNode('', !0),
                              Vue.createVNode(Vue.unref(script$K), {
                                icon: 'pi pi-trash',
                                text: '',
                                severity: 'primary',
                                onClick: t[1] || (t[1] = (e) => w(e)),
                                class: 'clear-all-button'
                              })
                            ],
                            64
                          ))
                    ]),
                    body: Vue.withCtx(() => [
                      l.value.length > 0
                        ? (Vue.openBlock(),
                          Vue.createElementBlock(
                            'div',
                            {
                              key: 0,
                              ref_key: 'scrollContainer',
                              ref: c,
                              class: 'scroll-container'
                            },
                            [
                              Vue.createElementVNode('div', _hoisted_1$5, [
                                (Vue.openBlock(!0),
                                Vue.createElementBlock(
                                  Vue.Fragment,
                                  null,
                                  Vue.renderList(
                                    l.value,
                                    (e) => (
                                      Vue.openBlock(),
                                      Vue.createBlock(
                                        TaskItem,
                                        {
                                          key: e.key,
                                          task: e,
                                          isFlatTask: s.value || h.value,
                                          onContextmenu: $,
                                          onPreview: L,
                                          onTaskOutputLengthClicked:
                                            t[2] || (t[2] = (e) => A(e))
                                        },
                                        null,
                                        8,
                                        ['task', 'isFlatTask']
                                      )
                                    )
                                  ),
                                  128
                                ))
                              ]),
                              Vue.createElementVNode(
                                'div',
                                {
                                  ref_key: 'loadMoreTrigger',
                                  ref: d,
                                  style: { height: '1px' }
                                },
                                null,
                                512
                              )
                            ],
                            512
                          ))
                        : Vue.unref(o).isLoading
                          ? (Vue.openBlock(),
                            Vue.createElementBlock('div', _hoisted_2$2, [
                              Vue.createVNode(Vue.unref(script$r), {
                                style: {
                                  width: '50px',
                                  left: '50%',
                                  transform: 'translateX(-50%)'
                                }
                              })
                            ]))
                          : (Vue.openBlock(),
                            Vue.createElementBlock('div', _hoisted_3$1, [
                              Vue.createVNode(
                                NoResultsPlaceholder,
                                {
                                  icon: 'pi pi-info-circle',
                                  title: e.$t('noTasksFound'),
                                  message: e.$t('noTasksFoundMessage')
                                },
                                null,
                                8,
                                ['title', 'message']
                              )
                            ]))
                    ]),
                    _: 1
                  },
                  8,
                  ['title']
                ),
                Vue.createVNode(Vue.unref(script$7)),
                Vue.createVNode(
                  Vue.unref(script$h),
                  { ref_key: 'menu', ref: x, model: T.value },
                  null,
                  8,
                  ['model']
                ),
                Vue.createVNode(
                  _sfc_main$7,
                  {
                    activeIndex: u.value,
                    'onUpdate:activeIndex':
                      t[3] || (t[3] = (e) => (u.value = e)),
                    allGalleryItems: _.value
                  },
                  null,
                  8,
                  ['activeIndex', 'allGalleryItems']
                )
              ],
              64
            )
          )
        }
      )
    }
  }),
  QueueSidebarTab = _export_sfc(_sfc_main$6, [
    ['__scopeId', 'data-v-93f5af09']
  ]),
  useQueueSidebarTab = __name(() => {
    const { t: e } = VueI18n.useI18n(),
      t = useQueuePendingTaskCountStore()
    return {
      id: 'queue',
      icon: 'pi pi-history',
      iconBadge: __name(() => {
        const e = t.count.toString()
        return '0' === e ? null : e
      }, 'iconBadge'),
      title: e('sideToolbar.queue'),
      tooltip: e('sideToolbar.queue'),
      component: Vue.markRaw(QueueSidebarTab),
      type: 'vue'
    }
  }, 'useQueueSidebarTab'),
  _sfc_main$5 = Vue.defineComponent({
    __name: 'WorkflowTreeLeaf',
    props: { node: {} },
    setup(e) {
      const t = e,
        n = useWorkflowBookmarkStore(),
        o = Vue.computed(() => n.isBookmarked(t.node.data.path))
      return (e, t) => (
        Vue.openBlock(),
        Vue.createBlock(
          TreeExplorerTreeNode,
          { node: e.node },
          {
            actions: Vue.withCtx(({ node: e }) => [
              Vue.createVNode(
                Vue.unref(script$K),
                {
                  icon: o.value ? 'pi pi-bookmark-fill' : 'pi pi-bookmark',
                  text: '',
                  severity: 'secondary',
                  size: 'small',
                  onClick: Vue.withModifiers(
                    (t) => Vue.unref(n).toggleBookmarked(e.data.path),
                    ['stop']
                  )
                },
                null,
                8,
                ['icon', 'onClick']
              )
            ]),
            _: 1
          },
          8,
          ['node']
        )
      )
    }
  }),
  _hoisted_1$4 = { key: 0, class: 'mr-2 shrink-0' },
  _hoisted_2$1 = { key: 1, class: 'ml-2 shrink-0' },
  _sfc_main$4 = Vue.defineComponent({
    __name: 'TextDivider',
    props: {
      text: {},
      class: {},
      position: { default: 'left' },
      align: { default: 'center' },
      type: { default: 'solid' },
      layout: { default: 'horizontal' }
    },
    setup(e) {
      const t = e
      return (e, n) => (
        Vue.openBlock(),
        Vue.createElementBlock(
          'div',
          { class: Vue.normalizeClass(['flex items-center', t.class]) },
          [
            'left' === e.position
              ? (Vue.openBlock(),
                Vue.createElementBlock(
                  'span',
                  _hoisted_1$4,
                  Vue.toDisplayString(e.text),
                  1
                ))
              : Vue.createCommentVNode('', !0),
            Vue.createVNode(
              Vue.unref(script$G),
              {
                align: e.align,
                type: e.type,
                layout: e.layout,
                class: 'flex-grow'
              },
              null,
              8,
              ['align', 'type', 'layout']
            ),
            'right' === e.position
              ? (Vue.openBlock(),
                Vue.createElementBlock(
                  'span',
                  _hoisted_2$1,
                  Vue.toDisplayString(e.text),
                  1
                ))
              : Vue.createCommentVNode('', !0)
          ],
          2
        )
      )
    }
  })
var theme$2 = __name(function (e) {
    var t = e.dt
    return '\n.p-confirmdialog .p-dialog-content {\n    display: flex;\n    align-items: center;\n    gap:  '
      .concat(
        t('confirmdialog.content.gap'),
        ';\n}\n\n.p-confirmdialog-icon {\n    color: '
      )
      .concat(t('confirmdialog.icon.color'), ';\n    font-size: ')
      .concat(t('confirmdialog.icon.size'), ';\n    width: ')
      .concat(t('confirmdialog.icon.size'), ';\n    height: ')
      .concat(t('confirmdialog.icon.size'), ';\n}\n')
  }, 'theme'),
  classes$2 = {
    root: 'p-confirmdialog',
    icon: 'p-confirmdialog-icon',
    message: 'p-confirmdialog-message',
    pcRejectButton: 'p-confirmdialog-reject-button',
    pcAcceptButton: 'p-confirmdialog-accept-button'
  },
  ConfirmDialogStyle = BaseStyle.extend({
    name: 'confirmdialog',
    theme: theme$2,
    classes: classes$2
  }),
  script$1$1 = {
    name: 'BaseConfirmDialog',
    extends: script$Y,
    props: {
      group: String,
      breakpoints: { type: Object, default: null },
      draggable: { type: Boolean, default: !0 }
    },
    style: ConfirmDialogStyle,
    provide: __name(function () {
      return { $pcConfirmDialog: this, $parentInstance: this }
    }, 'provide')
  },
  script$2 = {
    name: 'ConfirmDialog',
    extends: script$1$1,
    confirmListener: null,
    closeListener: null,
    data: __name(function () {
      return { visible: !1, confirmation: null }
    }, 'data'),
    mounted: __name(function () {
      var e = this
      ;(this.confirmListener = function (t) {
        t &&
          t.group === e.group &&
          ((e.confirmation = t),
          e.confirmation.onShow && e.confirmation.onShow(),
          (e.visible = !0))
      }),
        (this.closeListener = function () {
          ;(e.visible = !1), (e.confirmation = null)
        }),
        ConfirmationEventBus.on('confirm', this.confirmListener),
        ConfirmationEventBus.on('close', this.closeListener)
    }, 'mounted'),
    beforeUnmount: __name(function () {
      ConfirmationEventBus.off('confirm', this.confirmListener),
        ConfirmationEventBus.off('close', this.closeListener)
    }, 'beforeUnmount'),
    methods: {
      accept: __name(function () {
        this.confirmation.accept && this.confirmation.accept(),
          (this.visible = !1)
      }, 'accept'),
      reject: __name(function () {
        this.confirmation.reject && this.confirmation.reject(),
          (this.visible = !1)
      }, 'reject'),
      onHide: __name(function () {
        this.confirmation.onHide && this.confirmation.onHide(),
          (this.visible = !1)
      }, 'onHide')
    },
    computed: {
      appendTo: __name(function () {
        return this.confirmation ? this.confirmation.appendTo : 'body'
      }, 'appendTo'),
      target: __name(function () {
        return this.confirmation ? this.confirmation.target : null
      }, 'target'),
      modal: __name(function () {
        return (
          !this.confirmation ||
          null == this.confirmation.modal ||
          this.confirmation.modal
        )
      }, 'modal'),
      header: __name(function () {
        return this.confirmation ? this.confirmation.header : null
      }, 'header'),
      message: __name(function () {
        return this.confirmation ? this.confirmation.message : null
      }, 'message'),
      blockScroll: __name(function () {
        return !this.confirmation || this.confirmation.blockScroll
      }, 'blockScroll'),
      position: __name(function () {
        return this.confirmation ? this.confirmation.position : null
      }, 'position'),
      acceptLabel: __name(function () {
        if (this.confirmation) {
          var e,
            t = this.confirmation
          return (
            t.acceptLabel ||
            (null === (e = t.acceptProps) || void 0 === e ? void 0 : e.label) ||
            this.$primevue.config.locale.accept
          )
        }
        return this.$primevue.config.locale.accept
      }, 'acceptLabel'),
      rejectLabel: __name(function () {
        if (this.confirmation) {
          var e,
            t = this.confirmation
          return (
            t.rejectLabel ||
            (null === (e = t.rejectProps) || void 0 === e ? void 0 : e.label) ||
            this.$primevue.config.locale.reject
          )
        }
        return this.$primevue.config.locale.reject
      }, 'rejectLabel'),
      acceptIcon: __name(function () {
        var e
        return this.confirmation
          ? this.confirmation.acceptIcon
          : null !== (e = this.confirmation) && void 0 !== e && e.acceptProps
            ? this.confirmation.acceptProps.icon
            : null
      }, 'acceptIcon'),
      rejectIcon: __name(function () {
        var e
        return this.confirmation
          ? this.confirmation.rejectIcon
          : null !== (e = this.confirmation) && void 0 !== e && e.rejectProps
            ? this.confirmation.rejectProps.icon
            : null
      }, 'rejectIcon'),
      autoFocusAccept: __name(function () {
        return (
          void 0 === this.confirmation.defaultFocus ||
          'accept' === this.confirmation.defaultFocus
        )
      }, 'autoFocusAccept'),
      autoFocusReject: __name(function () {
        return 'reject' === this.confirmation.defaultFocus
      }, 'autoFocusReject'),
      closeOnEscape: __name(function () {
        return !this.confirmation || this.confirmation.closeOnEscape
      }, 'closeOnEscape')
    },
    components: { Dialog: script$b, Button: script$K }
  }
function render$1(e, t, n, o, i, r) {
  var a = Vue.resolveComponent('Button'),
    s = Vue.resolveComponent('Dialog')
  return (
    Vue.openBlock(),
    Vue.createBlock(
      s,
      {
        visible: i.visible,
        'onUpdate:visible': [
          t[2] ||
            (t[2] = function (e) {
              return (i.visible = e)
            }),
          r.onHide
        ],
        role: 'alertdialog',
        class: Vue.normalizeClass(e.cx('root')),
        modal: r.modal,
        header: r.header,
        blockScroll: r.blockScroll,
        appendTo: r.appendTo,
        position: r.position,
        breakpoints: e.breakpoints,
        closeOnEscape: r.closeOnEscape,
        draggable: e.draggable,
        pt: e.pt,
        unstyled: e.unstyled
      },
      Vue.createSlots(
        {
          default: Vue.withCtx(function () {
            return [
              e.$slots.container
                ? Vue.createCommentVNode('', !0)
                : (Vue.openBlock(),
                  Vue.createElementBlock(
                    Vue.Fragment,
                    { key: 0 },
                    [
                      e.$slots.message
                        ? (Vue.openBlock(),
                          Vue.createBlock(
                            Vue.resolveDynamicComponent(e.$slots.message),
                            { key: 1, message: i.confirmation },
                            null,
                            8,
                            ['message']
                          ))
                        : (Vue.openBlock(),
                          Vue.createElementBlock(
                            Vue.Fragment,
                            { key: 0 },
                            [
                              Vue.renderSlot(e.$slots, 'icon', {}, function () {
                                return [
                                  e.$slots.icon
                                    ? (Vue.openBlock(),
                                      Vue.createBlock(
                                        Vue.resolveDynamicComponent(
                                          e.$slots.icon
                                        ),
                                        {
                                          key: 0,
                                          class: Vue.normalizeClass(
                                            e.cx('icon')
                                          )
                                        },
                                        null,
                                        8,
                                        ['class']
                                      ))
                                    : i.confirmation.icon
                                      ? (Vue.openBlock(),
                                        Vue.createElementBlock(
                                          'span',
                                          Vue.mergeProps(
                                            {
                                              key: 1,
                                              class: [
                                                i.confirmation.icon,
                                                e.cx('icon')
                                              ]
                                            },
                                            e.ptm('icon')
                                          ),
                                          null,
                                          16
                                        ))
                                      : Vue.createCommentVNode('', !0)
                                ]
                              }),
                              Vue.createElementVNode(
                                'span',
                                Vue.mergeProps(
                                  { class: e.cx('message') },
                                  e.ptm('message')
                                ),
                                Vue.toDisplayString(r.message),
                                17
                              )
                            ],
                            64
                          ))
                    ],
                    64
                  ))
            ]
          }),
          _: 2
        },
        [
          e.$slots.container
            ? {
                name: 'container',
                fn: Vue.withCtx(function (t) {
                  return [
                    Vue.renderSlot(e.$slots, 'container', {
                      message: i.confirmation,
                      closeCallback: t.onclose,
                      acceptCallback: r.accept,
                      rejectCallback: r.reject
                    })
                  ]
                }),
                key: '0'
              }
            : void 0,
          e.$slots.container
            ? void 0
            : {
                name: 'footer',
                fn: Vue.withCtx(function () {
                  var n
                  return [
                    Vue.createVNode(
                      a,
                      Vue.mergeProps(
                        {
                          class: [
                            e.cx('pcRejectButton'),
                            i.confirmation.rejectClass
                          ],
                          autofocus: r.autoFocusReject,
                          unstyled: e.unstyled,
                          text:
                            (null === (n = i.confirmation.rejectProps) ||
                            void 0 === n
                              ? void 0
                              : n.text) || !1,
                          onClick:
                            t[0] ||
                            (t[0] = function (e) {
                              return r.reject()
                            })
                        },
                        i.confirmation.rejectProps,
                        { label: r.rejectLabel, pt: e.ptm('pcRejectButton') }
                      ),
                      Vue.createSlots({ _: 2 }, [
                        r.rejectIcon || e.$slots.rejecticon
                          ? {
                              name: 'icon',
                              fn: Vue.withCtx(function (t) {
                                return [
                                  Vue.renderSlot(
                                    e.$slots,
                                    'rejecticon',
                                    {},
                                    function () {
                                      return [
                                        Vue.createElementVNode(
                                          'span',
                                          Vue.mergeProps(
                                            { class: [r.rejectIcon, t.class] },
                                            e.ptm('pcRejectButton').icon,
                                            {
                                              'data-pc-section':
                                                'rejectbuttonicon'
                                            }
                                          ),
                                          null,
                                          16
                                        )
                                      ]
                                    }
                                  )
                                ]
                              }),
                              key: '0'
                            }
                          : void 0
                      ]),
                      1040,
                      ['class', 'autofocus', 'unstyled', 'text', 'label', 'pt']
                    ),
                    Vue.createVNode(
                      a,
                      Vue.mergeProps(
                        {
                          label: r.acceptLabel,
                          class: [
                            e.cx('pcAcceptButton'),
                            i.confirmation.acceptClass
                          ],
                          autofocus: r.autoFocusAccept,
                          unstyled: e.unstyled,
                          onClick:
                            t[1] ||
                            (t[1] = function (e) {
                              return r.accept()
                            })
                        },
                        i.confirmation.acceptProps,
                        { pt: e.ptm('pcAcceptButton') }
                      ),
                      Vue.createSlots({ _: 2 }, [
                        r.acceptIcon || e.$slots.accepticon
                          ? {
                              name: 'icon',
                              fn: Vue.withCtx(function (t) {
                                return [
                                  Vue.renderSlot(
                                    e.$slots,
                                    'accepticon',
                                    {},
                                    function () {
                                      return [
                                        Vue.createElementVNode(
                                          'span',
                                          Vue.mergeProps(
                                            { class: [r.acceptIcon, t.class] },
                                            e.ptm('pcAcceptButton').icon,
                                            {
                                              'data-pc-section':
                                                'acceptbuttonicon'
                                            }
                                          ),
                                          null,
                                          16
                                        )
                                      ]
                                    }
                                  )
                                ]
                              }),
                              key: '0'
                            }
                          : void 0
                      ]),
                      1040,
                      ['label', 'class', 'autofocus', 'unstyled', 'pt']
                    )
                  ]
                }),
                key: '1'
              }
        ]
      ),
      1032,
      [
        'visible',
        'class',
        'modal',
        'header',
        'blockScroll',
        'appendTo',
        'position',
        'breakpoints',
        'closeOnEscape',
        'draggable',
        'onUpdate:visible',
        'pt',
        'unstyled'
      ]
    )
  )
}
__name(render$1, 'render$1'), (script$2.render = render$1)
const _hoisted_1$3 = { key: 0, class: 'comfyui-workflows-panel' },
  _hoisted_2 = { key: 0, class: 'comfyui-workflows-open' },
  _hoisted_3 = { key: 0 },
  _hoisted_4 = { class: 'comfyui-workflows-bookmarks' },
  _hoisted_5 = { class: 'comfyui-workflows-browse' },
  _hoisted_6 = { key: 1, class: 'comfyui-workflows-search-panel' }
var WorkflowTreeType = ((e) => (
  (e.Open = 'Open'), (e.Bookmarks = 'Bookmarks'), (e.Browse = 'Browse'), e
))(WorkflowTreeType || {})
const _sfc_main$3 = Vue.defineComponent({
    __name: 'WorkflowsSidebarTab',
    setup(e) {
      const t = useSettingStore(),
        n = Vue.computed(() => t.get('Comfy.Workflow.WorkflowTabsPosition')),
        o = Vue.ref(''),
        i = Vue.computed(() => o.value.length > 0),
        r = Vue.ref([]),
        a = Vue.computed(() => _(r.value)),
        s = __name((e) => {
          if (0 === e.length) return (r.value = []), void (p.value = {})
          const t = e.toLocaleLowerCase()
          ;(r.value = c.workflows.filter((e) =>
            e.path.toLocaleLowerCase().includes(t)
          )),
            Vue.nextTick(() => {
              h(a.value)
            })
        }, 'handleSearch'),
        l = useCommandStore(),
        c = useWorkflowStore(),
        d = useWorkspaceStore(),
        { t: u } = VueI18n.useI18n(),
        p = Vue.ref({}),
        { expandNode: h, toggleNodeOnEvent: m } = useTreeExpansion(p),
        f = __name((e) => {
          e && workflowService.closeWorkflow(e, { warnIfUnsaved: !d.shiftDown })
        }, 'handleCloseWorkflow'),
        _ = __name(
          (e) => buildTree(e, (e) => e.key.split('/')),
          'buildWorkflowTree'
        ),
        g = Vue.computed(() =>
          sortedTree(_(c.persistedWorkflows), { groupLeaf: !0 })
        ),
        v = Vue.computed(() =>
          buildTree(c.bookmarkedWorkflows, (e) => [e.key])
        ),
        y = Vue.computed(() => buildTree(c.openWorkflows, (e) => [e.key])),
        b =
          (useConfirm(),
          useToast(),
          __name((e, t) => {
            const n = e.children?.map((e) => b(e, t)),
              o = e.data,
              i = __name((e, t) => {
                e.leaf ? workflowService.openWorkflow(o) : m(t, e)
              }, 'handleClick'),
              r = e.leaf
                ? {
                    handleClick: i,
                    handleRename: __name(async (e, n) => {
                      const i =
                        'Browse' === t
                          ? o.directory + '/' + appendJsonExt(n)
                          : ComfyWorkflow.basePath + appendJsonExt(n)
                      await workflowService.renameWorkflow(o, i)
                    }, 'handleRename'),
                    handleDelete: o.isTemporary
                      ? void 0
                      : async () => {
                          await workflowService.deleteWorkflow(o)
                        },
                    contextMenuItems: __name(
                      (e) => [
                        {
                          label: u('insert'),
                          icon: 'pi pi-file-export',
                          command: __name(() => {
                            const t = e.data
                            workflowService.insertWorkflow(t)
                          }, 'command')
                        }
                      ],
                      'contextMenuItems'
                    )
                  }
                : { handleClick: i }
            return {
              key: e.key,
              label: e.label,
              leaf: e.leaf,
              data: e.data,
              children: n,
              ...r
            }
          }, 'renderTreeNode')),
        S = Vue.computed(() => ({ [`root/${c.activeWorkflow?.key}`]: !0 })),
        C = useWorkflowBookmarkStore()
      return (
        Vue.onMounted(async () => {
          await C.loadBookmarks()
        }),
        (e, t) => {
          const r = Vue.resolveDirective('tooltip')
          return (
            Vue.openBlock(),
            Vue.createElementBlock(
              Vue.Fragment,
              null,
              [
                Vue.createVNode(
                  SidebarTabTemplate,
                  {
                    title: e.$t('sideToolbar.workflows'),
                    class: 'bg-[var(--p-tree-background)]'
                  },
                  {
                    'tool-buttons': Vue.withCtx(() => [
                      Vue.withDirectives(
                        Vue.createVNode(
                          Vue.unref(script$K),
                          {
                            class: 'browse-templates-button',
                            icon: 'pi pi-th-large',
                            text: '',
                            onClick:
                              t[0] ||
                              (t[0] = () =>
                                Vue.unref(l).execute('Comfy.BrowseTemplates'))
                          },
                          null,
                          512
                        ),
                        [
                          [
                            r,
                            e.$t('sideToolbar.browseTemplates'),
                            void 0,
                            { bottom: !0 }
                          ]
                        ]
                      ),
                      Vue.withDirectives(
                        Vue.createVNode(
                          Vue.unref(script$K),
                          {
                            class: 'open-workflow-button',
                            icon: 'pi pi-folder-open',
                            text: '',
                            onClick:
                              t[1] ||
                              (t[1] = () =>
                                Vue.unref(l).execute('Comfy.OpenWorkflow'))
                          },
                          null,
                          512
                        ),
                        [
                          [
                            r,
                            e.$t('sideToolbar.openWorkflow'),
                            void 0,
                            { bottom: !0 }
                          ]
                        ]
                      ),
                      Vue.withDirectives(
                        Vue.createVNode(
                          Vue.unref(script$K),
                          {
                            class: 'new-blank-workflow-button',
                            icon: 'pi pi-plus',
                            onClick:
                              t[2] ||
                              (t[2] = () =>
                                Vue.unref(l).execute('Comfy.NewBlankWorkflow')),
                            text: ''
                          },
                          null,
                          512
                        ),
                        [
                          [
                            r,
                            e.$t('sideToolbar.newBlankWorkflow'),
                            void 0,
                            { bottom: !0 }
                          ]
                        ]
                      )
                    ]),
                    header: Vue.withCtx(() => [
                      Vue.createVNode(
                        SearchBox,
                        {
                          class: 'workflows-search-box p-2 2xl:p-4',
                          modelValue: o.value,
                          'onUpdate:modelValue':
                            t[3] || (t[3] = (e) => (o.value = e)),
                          onSearch: s,
                          placeholder: e.$t('searchWorkflows') + '...'
                        },
                        null,
                        8,
                        ['modelValue', 'placeholder']
                      )
                    ]),
                    body: Vue.withCtx(() => [
                      i.value
                        ? (Vue.openBlock(),
                          Vue.createElementBlock('div', _hoisted_6, [
                            Vue.createVNode(
                              TreeExplorer,
                              {
                                roots: b(a.value, 'Browse').children,
                                expandedKeys: p.value,
                                'onUpdate:expandedKeys':
                                  t[5] || (t[5] = (e) => (p.value = e))
                              },
                              {
                                node: Vue.withCtx(({ node: e }) => [
                                  Vue.createVNode(
                                    _sfc_main$5,
                                    { node: e },
                                    null,
                                    8,
                                    ['node']
                                  )
                                ]),
                                _: 1
                              },
                              8,
                              ['roots', 'expandedKeys']
                            )
                          ]))
                        : (Vue.openBlock(),
                          Vue.createElementBlock('div', _hoisted_1$3, [
                            'Sidebar' === n.value
                              ? (Vue.openBlock(),
                                Vue.createElementBlock('div', _hoisted_2, [
                                  Vue.createVNode(_sfc_main$4, {
                                    text: 'Open',
                                    type: 'dashed',
                                    class: 'ml-2'
                                  }),
                                  Vue.createVNode(
                                    TreeExplorer,
                                    {
                                      roots: b(y.value, 'Open').children,
                                      selectionKeys: S.value
                                    },
                                    {
                                      node: Vue.withCtx(({ node: e }) => [
                                        Vue.createVNode(
                                          TreeExplorerTreeNode,
                                          { node: e },
                                          {
                                            'before-label': Vue.withCtx(
                                              ({ node: e }) => [
                                                e.data.isModified ||
                                                !e.data.isPersisted
                                                  ? (Vue.openBlock(),
                                                    Vue.createElementBlock(
                                                      'span',
                                                      _hoisted_3,
                                                      '*'
                                                    ))
                                                  : Vue.createCommentVNode(
                                                      '',
                                                      !0
                                                    )
                                              ]
                                            ),
                                            actions: Vue.withCtx(
                                              ({ node: e }) => [
                                                Vue.createVNode(
                                                  Vue.unref(script$K),
                                                  {
                                                    class:
                                                      'close-workflow-button',
                                                    icon: 'pi pi-times',
                                                    text: '',
                                                    severity: Vue.unref(d)
                                                      .shiftDown
                                                      ? 'danger'
                                                      : 'secondary',
                                                    size: 'small',
                                                    onClick: Vue.withModifiers(
                                                      (t) => f(e.data),
                                                      ['stop']
                                                    )
                                                  },
                                                  null,
                                                  8,
                                                  ['severity', 'onClick']
                                                )
                                              ]
                                            ),
                                            _: 2
                                          },
                                          1032,
                                          ['node']
                                        )
                                      ]),
                                      _: 1
                                    },
                                    8,
                                    ['roots', 'selectionKeys']
                                  )
                                ]))
                              : Vue.createCommentVNode('', !0),
                            Vue.withDirectives(
                              Vue.createElementVNode(
                                'div',
                                _hoisted_4,
                                [
                                  Vue.createVNode(_sfc_main$4, {
                                    text: 'Bookmarks',
                                    type: 'dashed',
                                    class: 'ml-2'
                                  }),
                                  Vue.createVNode(
                                    TreeExplorer,
                                    { roots: b(v.value, 'Bookmarks').children },
                                    {
                                      node: Vue.withCtx(({ node: e }) => [
                                        Vue.createVNode(
                                          _sfc_main$5,
                                          { node: e },
                                          null,
                                          8,
                                          ['node']
                                        )
                                      ]),
                                      _: 1
                                    },
                                    8,
                                    ['roots']
                                  )
                                ],
                                512
                              ),
                              [
                                [
                                  Vue.vShow,
                                  Vue.unref(c).bookmarkedWorkflows.length > 0
                                ]
                              ]
                            ),
                            Vue.createElementVNode('div', _hoisted_5, [
                              Vue.createVNode(_sfc_main$4, {
                                text: 'Browse',
                                type: 'dashed',
                                class: 'ml-2'
                              }),
                              Vue.unref(c).persistedWorkflows.length > 0
                                ? (Vue.openBlock(),
                                  Vue.createBlock(
                                    TreeExplorer,
                                    {
                                      key: 0,
                                      roots: b(g.value, 'Browse').children,
                                      expandedKeys: p.value,
                                      'onUpdate:expandedKeys':
                                        t[4] || (t[4] = (e) => (p.value = e))
                                    },
                                    {
                                      node: Vue.withCtx(({ node: e }) => [
                                        Vue.createVNode(
                                          _sfc_main$5,
                                          { node: e },
                                          null,
                                          8,
                                          ['node']
                                        )
                                      ]),
                                      _: 1
                                    },
                                    8,
                                    ['roots', 'expandedKeys']
                                  ))
                                : (Vue.openBlock(),
                                  Vue.createBlock(
                                    NoResultsPlaceholder,
                                    {
                                      key: 1,
                                      icon: 'pi pi-folder',
                                      title: e.$t('empty'),
                                      message: e.$t('noWorkflowsFound')
                                    },
                                    null,
                                    8,
                                    ['title', 'message']
                                  ))
                            ])
                          ]))
                    ]),
                    _: 1
                  },
                  8,
                  ['title']
                ),
                Vue.createVNode(Vue.unref(script$2))
              ],
              64
            )
          )
        }
      )
    }
  }),
  useWorkflowsSidebarTab = __name(() => {
    const { t: e } = VueI18n.useI18n(),
      t = useSettingStore(),
      n = useWorkflowStore()
    return {
      id: 'workflows',
      icon: 'pi pi-folder-open',
      iconBadge: __name(() => {
        if ('Sidebar' !== t.get('Comfy.Workflow.WorkflowTabsPosition'))
          return null
        const e = n.openWorkflows.length.toString()
        return '0' === e ? null : e
      }, 'iconBadge'),
      title: e('sideToolbar.workflows'),
      tooltip: e('sideToolbar.workflows'),
      component: Vue.markRaw(_sfc_main$3),
      type: 'vue'
    }
  }, 'useWorkflowsSidebarTab'),
  useSidebarTabStore = defineStore('sidebarTab', () => {
    const e = Vue.ref([]),
      t = Vue.ref(null),
      n = Vue.computed(() => e.value.find((e) => e.id === t.value) ?? null),
      o = __name((e) => {
        t.value = t.value === e ? null : e
      }, 'toggleSidebarTab'),
      i = __name((t) => {
        ;(e.value = [...e.value, t]),
          useCommandStore().registerCommand({
            id: `Workspace.ToggleSidebarTab.${t.id}`,
            icon: t.icon,
            label: t.tooltip,
            tooltip: t.tooltip,
            versionAdded: '1.3.9',
            function: __name(() => {
              o(t.id)
            }, 'function')
          })
      }, 'registerSidebarTab'),
      r = __name((t) => {
        const n = e.value.findIndex((e) => e.id === t)
        if (-1 !== n) {
          const t = e.value[n]
          'custom' === t.type && t.destroy && t.destroy()
          const o = [...e.value]
          o.splice(n, 1), (e.value = o)
        }
      }, 'unregisterSidebarTab'),
      a = __name(() => {
        i(useQueueSidebarTab()),
          i(useNodeLibrarySidebarTab()),
          i(useModelLibrarySidebarTab()),
          i(useWorkflowsSidebarTab())
      }, 'registerCoreSidebarTabs')
    return {
      sidebarTabs: e,
      activeSidebarTabId: t,
      activeSidebarTab: n,
      toggleSidebarTab: o,
      registerSidebarTab: i,
      unregisterSidebarTab: r,
      registerCoreSidebarTabs: a
    }
  }),
  useWorkspaceStore = defineStore('workspace', () => {
    const e = Vue.ref(!1),
      t = Vue.ref(!1),
      n = Vue.ref(!1),
      o = Vue.computed(() => useToastStore()),
      i = Vue.computed(() => useQueueSettingsStore()),
      r = Vue.computed(() => ({
        commands: useCommandStore().commands,
        execute: useCommandStore().execute
      })),
      a = Vue.computed(() => useSidebarTabStore()),
      s = Vue.computed(() => ({
        settings: useSettingStore().settings,
        get: useSettingStore().get,
        set: useSettingStore().set
      })),
      l = Vue.computed(() => useWorkflowStore())
    function c(e) {
      a.value.registerSidebarTab(e)
    }
    function d(e) {
      a.value.unregisterSidebarTab(e)
    }
    function u() {
      return a.value.sidebarTabs
    }
    return (
      __name(c, 'registerSidebarTab'),
      __name(d, 'unregisterSidebarTab'),
      __name(u, 'getSidebarTabs'),
      {
        spinner: e,
        shiftDown: t,
        focusMode: n,
        toggleFocusMode: __name(() => {
          n.value = !n.value
        }, 'toggleFocusMode'),
        toast: o,
        queueSettings: i,
        command: r,
        sidebarTab: a,
        setting: s,
        workflow: l,
        registerSidebarTab: c,
        unregisterSidebarTab: d,
        getSidebarTabs: u
      }
    )
  })
var theme$1 = __name(function (e) {
    var t = e.dt
    return '\n.p-blockui {\n    position: relative;\n}\n\n.p-blockui-mask {\n    border-radius: '.concat(
      t('blockui.border.radius'),
      ';\n}\n\n.p-blockui-mask.p-overlay-mask {\n    position: absolute;\n}\n\n.p-blockui-mask-document.p-overlay-mask {\n    position: fixed;\n}\n'
    )
  }, 'theme'),
  classes$1 = { root: 'p-blockui' },
  BlockUIStyle = BaseStyle.extend({
    name: 'blockui',
    theme: theme$1,
    classes: classes$1
  }),
  script$1 = {
    name: 'BaseBlockUI',
    extends: script$Y,
    props: {
      blocked: { type: Boolean, default: !1 },
      fullScreen: { type: Boolean, default: !1 },
      baseZIndex: { type: Number, default: 0 },
      autoZIndex: { type: Boolean, default: !0 }
    },
    style: BlockUIStyle,
    provide: __name(function () {
      return { $pcBlockUI: this, $parentInstance: this }
    }, 'provide')
  },
  script = {
    name: 'BlockUI',
    extends: script$1,
    inheritAttrs: !1,
    emits: ['block', 'unblock'],
    mask: null,
    data: __name(function () {
      return { isBlocked: !1 }
    }, 'data'),
    watch: {
      blocked: __name(function (e) {
        !0 === e ? this.block() : this.unblock()
      }, 'blocked')
    },
    mounted: __name(function () {
      this.blocked && this.block()
    }, 'mounted'),
    methods: {
      block: __name(function () {
        var e = 'p-blockui-mask p-overlay-mask p-overlay-mask-enter'
        this.fullScreen
          ? ((e += ' p-blockui-mask-document'),
            (this.mask = createElement('div', {
              style: {
                position: 'fixed',
                top: '0',
                left: '0',
                width: '100%',
                height: '100%'
              },
              class: !this.isUnstyled && e,
              'p-bind': this.ptm('mask')
            })),
            document.body.appendChild(this.mask),
            blockBodyScroll(),
            document.activeElement.blur())
          : ((this.mask = createElement('div', {
              style: {
                position: 'absolute',
                top: '0',
                left: '0',
                width: '100%',
                height: '100%'
              },
              class: !this.isUnstyled && e,
              'p-bind': this.ptm('mask')
            })),
            this.$refs.container.appendChild(this.mask)),
          this.autoZIndex &&
            ZIndex.set(
              'modal',
              this.mask,
              this.baseZIndex + this.$primevue.config.zIndex.modal
            ),
          (this.isBlocked = !0),
          this.$emit('block')
      }, 'block'),
      unblock: __name(function () {
        var e = this
        !this.isUnstyled && addClass(this.mask, 'p-overlay-mask-leave'),
          hasCSSAnimation(this.mask) > 0
            ? this.mask.addEventListener('animationend', function () {
                e.removeMask()
              })
            : this.removeMask()
      }, 'unblock'),
      removeMask: __name(function () {
        var e
        ;(ZIndex.clear(this.mask), this.fullScreen)
          ? (document.body.removeChild(this.mask), unblockBodyScroll())
          : null === (e = this.$refs.container) ||
            void 0 === e ||
            e.removeChild(this.mask)
        ;(this.isBlocked = !1), this.$emit('unblock')
      }, 'removeMask')
    }
  },
  _hoisted_1$2 = ['aria-busy']
function render(e, t, n, o, i, r) {
  return (
    Vue.openBlock(),
    Vue.createElementBlock(
      'div',
      Vue.mergeProps(
        { ref: 'container', class: e.cx('root'), 'aria-busy': i.isBlocked },
        e.ptmi('root')
      ),
      [Vue.renderSlot(e.$slots, 'default')],
      16,
      _hoisted_1$2
    )
  )
}
__name(render, 'render'), (script.render = render)
var BaseComponentStyle = BaseStyle.extend({ name: 'common' })
function _typeof$2(e) {
  return (_typeof$2 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys$1(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread$1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys$1(Object(n), !0).forEach(function (t) {
          _defineProperty$2(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys$1(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$2(e, t, n) {
  return (
    (t = _toPropertyKey$2(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$2(e) {
  var t = _toPrimitive$2(e, 'string')
  return 'symbol' == _typeof$2(t) ? t : t + ''
}
function _toPrimitive$2(e, t) {
  if ('object' != _typeof$2(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$2(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$2, '_typeof$2'),
  __name(ownKeys$1, 'ownKeys$1'),
  __name(_objectSpread$1, '_objectSpread$1'),
  __name(_defineProperty$2, '_defineProperty$2'),
  __name(_toPropertyKey$2, '_toPropertyKey$2'),
  __name(_toPrimitive$2, '_toPrimitive$2')
var defaultOptions = {
    ripple: !1,
    inputStyle: null,
    inputVariant: null,
    locale: {
      startsWith: 'Starts with',
      contains: 'Contains',
      notContains: 'Not contains',
      endsWith: 'Ends with',
      equals: 'Equals',
      notEquals: 'Not equals',
      noFilter: 'No Filter',
      lt: 'Less than',
      lte: 'Less than or equal to',
      gt: 'Greater than',
      gte: 'Greater than or equal to',
      dateIs: 'Date is',
      dateIsNot: 'Date is not',
      dateBefore: 'Date is before',
      dateAfter: 'Date is after',
      clear: 'Clear',
      apply: 'Apply',
      matchAll: 'Match All',
      matchAny: 'Match Any',
      addRule: 'Add Rule',
      removeRule: 'Remove Rule',
      accept: 'Yes',
      reject: 'No',
      choose: 'Choose',
      upload: 'Upload',
      cancel: 'Cancel',
      completed: 'Completed',
      pending: 'Pending',
      fileSizeTypes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
      dayNames: [
        'Sunday',
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday'
      ],
      dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
      monthNames: [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December'
      ],
      monthNamesShort: [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
      ],
      chooseYear: 'Choose Year',
      chooseMonth: 'Choose Month',
      chooseDate: 'Choose Date',
      prevDecade: 'Previous Decade',
      nextDecade: 'Next Decade',
      prevYear: 'Previous Year',
      nextYear: 'Next Year',
      prevMonth: 'Previous Month',
      nextMonth: 'Next Month',
      prevHour: 'Previous Hour',
      nextHour: 'Next Hour',
      prevMinute: 'Previous Minute',
      nextMinute: 'Next Minute',
      prevSecond: 'Previous Second',
      nextSecond: 'Next Second',
      am: 'am',
      pm: 'pm',
      today: 'Today',
      weekHeader: 'Wk',
      firstDayOfWeek: 0,
      showMonthAfterYear: !1,
      dateFormat: 'mm/dd/yy',
      weak: 'Weak',
      medium: 'Medium',
      strong: 'Strong',
      passwordPrompt: 'Enter a password',
      emptyFilterMessage: 'No results found',
      searchMessage: '{0} results are available',
      selectionMessage: '{0} items selected',
      emptySelectionMessage: 'No selected item',
      emptySearchMessage: 'No results found',
      fileChosenMessage: '{0} files',
      noFileChosenMessage: 'No file chosen',
      emptyMessage: 'No available options',
      aria: {
        trueLabel: 'True',
        falseLabel: 'False',
        nullLabel: 'Not Selected',
        star: '1 star',
        stars: '{star} stars',
        selectAll: 'All items selected',
        unselectAll: 'All items unselected',
        close: 'Close',
        previous: 'Previous',
        next: 'Next',
        navigation: 'Navigation',
        scrollTop: 'Scroll Top',
        moveTop: 'Move Top',
        moveUp: 'Move Up',
        moveDown: 'Move Down',
        moveBottom: 'Move Bottom',
        moveToTarget: 'Move to Target',
        moveToSource: 'Move to Source',
        moveAllToTarget: 'Move All to Target',
        moveAllToSource: 'Move All to Source',
        pageLabel: 'Page {page}',
        firstPageLabel: 'First Page',
        lastPageLabel: 'Last Page',
        nextPageLabel: 'Next Page',
        prevPageLabel: 'Previous Page',
        rowsPerPageLabel: 'Rows per page',
        jumpToPageDropdownLabel: 'Jump to Page Dropdown',
        jumpToPageInputLabel: 'Jump to Page Input',
        selectRow: 'Row Selected',
        unselectRow: 'Row Unselected',
        expandRow: 'Row Expanded',
        collapseRow: 'Row Collapsed',
        showFilterMenu: 'Show Filter Menu',
        hideFilterMenu: 'Hide Filter Menu',
        filterOperator: 'Filter Operator',
        filterConstraint: 'Filter Constraint',
        editRow: 'Row Edit',
        saveEdit: 'Save Edit',
        cancelEdit: 'Cancel Edit',
        listView: 'List View',
        gridView: 'Grid View',
        slide: 'Slide',
        slideNumber: '{slideNumber}',
        zoomImage: 'Zoom Image',
        zoomIn: 'Zoom In',
        zoomOut: 'Zoom Out',
        rotateRight: 'Rotate Right',
        rotateLeft: 'Rotate Left',
        listLabel: 'Option List'
      }
    },
    filterMatchModeOptions: {
      text: [
        FilterMatchMode.STARTS_WITH,
        FilterMatchMode.CONTAINS,
        FilterMatchMode.NOT_CONTAINS,
        FilterMatchMode.ENDS_WITH,
        FilterMatchMode.EQUALS,
        FilterMatchMode.NOT_EQUALS
      ],
      numeric: [
        FilterMatchMode.EQUALS,
        FilterMatchMode.NOT_EQUALS,
        FilterMatchMode.LESS_THAN,
        FilterMatchMode.LESS_THAN_OR_EQUAL_TO,
        FilterMatchMode.GREATER_THAN,
        FilterMatchMode.GREATER_THAN_OR_EQUAL_TO
      ],
      date: [
        FilterMatchMode.DATE_IS,
        FilterMatchMode.DATE_IS_NOT,
        FilterMatchMode.DATE_BEFORE,
        FilterMatchMode.DATE_AFTER
      ]
    },
    zIndex: { modal: 1100, overlay: 1e3, menu: 1e3, tooltip: 1100 },
    theme: void 0,
    unstyled: !1,
    pt: void 0,
    ptOptions: { mergeSections: !0, mergeProps: !1 },
    csp: { nonce: void 0 }
  },
  PrimeVueSymbol = Symbol()
function usePrimeVue() {
  var e = Vue.inject(PrimeVueSymbol)
  if (!e) throw new Error('PrimeVue is not installed!')
  return e
}
function setup(e, t) {
  var n = { config: Vue.reactive(t) }
  return (
    (e.config.globalProperties.$primevue = n),
    e.provide(PrimeVueSymbol, n),
    clearConfig(),
    setupConfig(e, n),
    n
  )
}
__name(usePrimeVue, 'usePrimeVue'), __name(setup, 'setup')
var stopWatchers = []
function clearConfig() {
  service_default.clear(),
    stopWatchers.forEach(function (e) {
      return null == e ? void 0 : e()
    }),
    (stopWatchers = [])
}
function setupConfig(e, t) {
  var n = Vue.ref(!1),
    o = __name(function () {
      var e
      if (
        'none' !==
          (null === (e = t.config) || void 0 === e ? void 0 : e.theme) &&
        !config_default.isStyleNameLoaded('common')
      ) {
        var n,
          o,
          i =
            (null === (n = BaseStyle.getCommonTheme) || void 0 === n
              ? void 0
              : n.call(BaseStyle)) || {},
          r = i.primitive,
          a = i.semantic,
          s = i.global,
          l = i.style,
          c = {
            nonce:
              null === (o = t.config) ||
              void 0 === o ||
              null === (o = o.csp) ||
              void 0 === o
                ? void 0
                : o.nonce
          }
        BaseStyle.load(
          null == r ? void 0 : r.css,
          _objectSpread$1({ name: 'primitive-variables' }, c)
        ),
          BaseStyle.load(
            null == a ? void 0 : a.css,
            _objectSpread$1({ name: 'semantic-variables' }, c)
          ),
          BaseStyle.load(
            null == s ? void 0 : s.css,
            _objectSpread$1({ name: 'global-variables' }, c)
          ),
          BaseStyle.loadTheme(_objectSpread$1({ name: 'global-style' }, c), l),
          config_default.setLoadedStyleName('common')
      }
    }, 'loadCommonTheme')
  service_default.on('theme:change', function (t) {
    n.value ||
      ((e.config.globalProperties.$primevue.config.theme = t), (n.value = !0))
  })
  var i = Vue.watch(
      t.config,
      function (e, t) {
        PrimeVueService.emit('config:change', { newValue: e, oldValue: t })
      },
      { immediate: !0, deep: !0 }
    ),
    r = Vue.watch(
      function () {
        return t.config.ripple
      },
      function (e, t) {
        PrimeVueService.emit('config:ripple:change', {
          newValue: e,
          oldValue: t
        })
      },
      { immediate: !0, deep: !0 }
    ),
    a = Vue.watch(
      function () {
        return t.config.theme
      },
      function (e, i) {
        n.value || config_default.setTheme(e),
          t.config.unstyled || o(),
          (n.value = !1),
          PrimeVueService.emit('config:theme:change', {
            newValue: e,
            oldValue: i
          })
      },
      { immediate: !0, deep: !1 }
    ),
    s = Vue.watch(
      function () {
        return t.config.unstyled
      },
      function (e, n) {
        !e && t.config.theme && o(),
          PrimeVueService.emit('config:unstyled:change', {
            newValue: e,
            oldValue: n
          })
      },
      { immediate: !0, deep: !0 }
    )
  stopWatchers.push(i),
    stopWatchers.push(r),
    stopWatchers.push(a),
    stopWatchers.push(s)
}
__name(clearConfig, 'clearConfig'), __name(setupConfig, 'setupConfig')
var PrimeVue = {
  install: __name(function (e, t) {
    setup(e, mergeKeys(defaultOptions, t))
  }, 'install')
}
const _hoisted_1$1 = ['id'],
  _sfc_main$2 = Vue.defineComponent({
    __name: 'GlobalDialog',
    setup(e) {
      const t = useDialogStore(),
        n = usePrimeVue(),
        o = Vue.computed(() => n?.config?.zIndex?.modal ?? 1100)
      return (
        Vue.onMounted(() => {
          const e = document.createElement('div')
          ZIndex.set('model', e, o.value)
        }),
        (e, n) => (
          Vue.openBlock(!0),
          Vue.createElementBlock(
            Vue.Fragment,
            null,
            Vue.renderList(
              Vue.unref(t).dialogStack,
              (e, t) => (
                Vue.openBlock(),
                Vue.createBlock(
                  Vue.unref(script$b),
                  Vue.mergeProps(
                    {
                      key: e.key,
                      visible: e.visible,
                      'onUpdate:visible': __name(
                        (t) => (e.visible = t),
                        'onUpdate:visible'
                      ),
                      class: 'global-dialog',
                      ref_for: !0
                    },
                    e.dialogComponentProps,
                    {
                      'auto-z-index': !1,
                      'pt:mask:style': { zIndex: o.value + t + 1 },
                      'aria-labelledby': e.key
                    }
                  ),
                  {
                    header: Vue.withCtx(() => [
                      e.headerComponent
                        ? (Vue.openBlock(),
                          Vue.createBlock(
                            Vue.resolveDynamicComponent(e.headerComponent),
                            { key: 0, id: e.key },
                            null,
                            8,
                            ['id']
                          ))
                        : (Vue.openBlock(),
                          Vue.createElementBlock(
                            'h3',
                            { key: 1, id: e.key },
                            Vue.toDisplayString(e.title || ' '),
                            9,
                            _hoisted_1$1
                          ))
                    ]),
                    default: Vue.withCtx(() => [
                      (Vue.openBlock(),
                      Vue.createBlock(
                        Vue.resolveDynamicComponent(e.component),
                        Vue.mergeProps({ ref_for: !0 }, e.contentProps, {
                          maximized: e.dialogComponentProps.maximized
                        }),
                        null,
                        16,
                        ['maximized']
                      ))
                    ]),
                    _: 2
                  },
                  1040,
                  [
                    'visible',
                    'onUpdate:visible',
                    'pt:mask:style',
                    'aria-labelledby'
                  ]
                )
              )
            ),
            128
          )
        )
      )
    }
  }),
  _sfc_main$1 = Vue.defineComponent({
    __name: 'App',
    setup(e) {
      const t = useWorkspaceStore(),
        n = Vue.computed(() => t.spinner),
        o = __name((e) => {
          t.shiftDown = e.shiftKey
        }, 'handleKey')
      return (
        useEventListener(window, 'keydown', o),
        useEventListener(window, 'keyup', o),
        Vue.onMounted(() => {
          ;(window.__COMFYUI_FRONTEND_VERSION__ = config.app_version),
            console.log('ComfyUI Front-end version:', config.app_version)
        }),
        (e, t) => {
          const o = Vue.resolveComponent('router-view')
          return (
            Vue.openBlock(),
            Vue.createElementBlock(
              Vue.Fragment,
              null,
              [
                Vue.createVNode(o),
                n.value
                  ? (Vue.openBlock(),
                    Vue.createBlock(Vue.unref(script$r), {
                      key: 0,
                      class:
                        'absolute inset-0 flex justify-center items-center h-screen'
                    }))
                  : Vue.createCommentVNode('', !0),
                Vue.createVNode(_sfc_main$2),
                Vue.createVNode(
                  Vue.unref(script),
                  { 'full-screen': '', blocked: n.value },
                  null,
                  8,
                  ['blocked']
                )
              ],
              64
            )
          )
        }
      )
    }
  }),
  _sfc_main = {},
  _hoisted_1 = { class: 'w-full min-h-screen overflow-hidden relative' }
function _sfc_render(e, t) {
  const n = Vue.resolveComponent('router-view')
  return (
    Vue.openBlock(),
    Vue.createElementBlock('main', _hoisted_1, [Vue.createVNode(n)])
  )
}
__name(_sfc_render, '_sfc_render')
const LayoutDefault = _export_sfc(_sfc_main, [['render', _sfc_render]]),
  isFileProtocol = 'file:' === window.location.protocol,
  basePath = isElectron() ? '/' : window.location.pathname,
  guardElectronAccess = __name((e, t, n) => {
    isElectron() ? n() : n('/')
  }, 'guardElectronAccess'),
  router = VueRouter.createRouter({
    history: isFileProtocol
      ? VueRouter.createWebHashHistory()
      : VueRouter.createWebHistory(basePath),
    routes: [
      {
        path: '/',
        component: LayoutDefault,
        children: [
          {
            path: '',
            name: 'GraphView',
            component: __name(
              () =>
                __vitePreload(
                  () => import('./GraphView-Cbaje2Ve.js'),
                  __vite__mapDeps([10, 2, 6, 11]),
                  import.meta.url
                ),
              'component'
            ),
            beforeEnter: __name(async (e, t, n) => {
              const o = useUserStore()
              await o.initialize(), o.needsLogin ? n('/user-select') : n()
            }, 'beforeEnter')
          },
          {
            path: 'user-select',
            name: 'UserSelectView',
            component: __name(
              () =>
                __vitePreload(
                  () => import('./UserSelectView-DIGIq3dh.js'),
                  [],
                  import.meta.url
                ),
              'component'
            )
          },
          {
            path: 'server-start',
            name: 'ServerStartView',
            component: __name(
              () =>
                __vitePreload(
                  () => import('./ServerStartView-COVLDBH3.js'),
                  __vite__mapDeps([12, 13]),
                  import.meta.url
                ),
              'component'
            ),
            beforeEnter: guardElectronAccess
          },
          {
            path: 'install',
            name: 'InstallView',
            component: __name(
              () =>
                __vitePreload(
                  () => import('./InstallView-CBV93Gts.js'),
                  __vite__mapDeps([14, 15]),
                  import.meta.url
                ),
              'component'
            ),
            beforeEnter: guardElectronAccess
          },
          {
            path: 'welcome',
            name: 'WelcomeView',
            component: __name(
              () =>
                __vitePreload(
                  () => import('./WelcomeView-chN3jxAd.js'),
                  __vite__mapDeps([16, 17]),
                  import.meta.url
                ),
              'component'
            ),
            beforeEnter: guardElectronAccess
          },
          {
            path: 'not-supported',
            name: 'NotSupportedView',
            component: __name(
              () =>
                __vitePreload(
                  () => import('./NotSupportedView-DfSRUzch.js'),
                  [],
                  import.meta.url
                ),
              'component'
            ),
            beforeEnter: guardElectronAccess
          },
          {
            path: 'download-git',
            name: 'DownloadGitView',
            component: __name(
              () =>
                __vitePreload(
                  () => import('./DownloadGitView-C7XDy6NJ.js'),
                  [],
                  import.meta.url
                ),
              'component'
            ),
            beforeEnter: guardElectronAccess
          }
        ]
      }
    ],
    scrollBehavior: (e, t, n) => n || { top: 0 }
  })
var index$1p = {
    root: { transitionDuration: '{transition.duration}' },
    panel: { borderWidth: '0 0 1px 0', borderColor: '{content.border.color}' },
    header: {
      color: '{text.muted.color}',
      hoverColor: '{text.color}',
      activeColor: '{text.color}',
      padding: '1.125rem',
      fontWeight: '600',
      borderRadius: '0',
      borderWidth: '0',
      borderColor: '{content.border.color}',
      background: '{content.background}',
      hoverBackground: '{content.background}',
      activeBackground: '{content.background}',
      activeHoverBackground: '{content.background}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '-1px',
        shadow: '{focus.ring.shadow}'
      },
      toggleIcon: {
        color: '{text.muted.color}',
        hoverColor: '{text.color}',
        activeColor: '{text.color}',
        activeHoverColor: '{text.color}'
      },
      first: { topBorderRadius: '{content.border.radius}', borderWidth: '0' },
      last: {
        bottomBorderRadius: '{content.border.radius}',
        activeBottomBorderRadius: '0'
      }
    },
    content: {
      borderWidth: '0',
      borderColor: '{content.border.color}',
      background: '{content.background}',
      color: '{text.color}',
      padding: '0 1.125rem 1.125rem 1.125rem'
    }
  },
  index$1o = {
    root: {
      background: '{form.field.background}',
      disabledBackground: '{form.field.disabled.background}',
      filledBackground: '{form.field.filled.background}',
      filledHoverBackground: '{form.field.filled.hover.background}',
      filledFocusBackground: '{form.field.filled.focus.background}',
      borderColor: '{form.field.border.color}',
      hoverBorderColor: '{form.field.hover.border.color}',
      focusBorderColor: '{form.field.focus.border.color}',
      invalidBorderColor: '{form.field.invalid.border.color}',
      color: '{form.field.color}',
      disabledColor: '{form.field.disabled.color}',
      placeholderColor: '{form.field.placeholder.color}',
      invalidPlaceholderColor: '{form.field.invalid.placeholder.color}',
      shadow: '{form.field.shadow}',
      paddingX: '{form.field.padding.x}',
      paddingY: '{form.field.padding.y}',
      borderRadius: '{form.field.border.radius}',
      focusRing: {
        width: '{form.field.focus.ring.width}',
        style: '{form.field.focus.ring.style}',
        color: '{form.field.focus.ring.color}',
        offset: '{form.field.focus.ring.offset}',
        shadow: '{form.field.focus.ring.shadow}'
      },
      transitionDuration: '{form.field.transition.duration}'
    },
    overlay: {
      background: '{overlay.select.background}',
      borderColor: '{overlay.select.border.color}',
      borderRadius: '{overlay.select.border.radius}',
      color: '{overlay.select.color}',
      shadow: '{overlay.select.shadow}'
    },
    list: { padding: '{list.padding}', gap: '{list.gap}' },
    option: {
      focusBackground: '{list.option.focus.background}',
      selectedBackground: '{list.option.selected.background}',
      selectedFocusBackground: '{list.option.selected.focus.background}',
      color: '{list.option.color}',
      focusColor: '{list.option.focus.color}',
      selectedColor: '{list.option.selected.color}',
      selectedFocusColor: '{list.option.selected.focus.color}',
      padding: '{list.option.padding}',
      borderRadius: '{list.option.border.radius}'
    },
    optionGroup: {
      background: '{list.option.group.background}',
      color: '{list.option.group.color}',
      fontWeight: '{list.option.group.font.weight}',
      padding: '{list.option.group.padding}'
    },
    dropdown: {
      width: '2.5rem',
      sm: { width: '2rem' },
      lg: { width: '3rem' },
      borderColor: '{form.field.border.color}',
      hoverBorderColor: '{form.field.border.color}',
      activeBorderColor: '{form.field.border.color}',
      borderRadius: '{form.field.border.radius}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    chip: { borderRadius: '{border.radius.sm}' },
    emptyMessage: { padding: '{list.option.padding}' },
    colorScheme: {
      light: {
        chip: { focusBackground: '{surface.200}', focusColor: '{surface.800}' },
        dropdown: {
          background: '{surface.100}',
          hoverBackground: '{surface.200}',
          activeBackground: '{surface.300}',
          color: '{surface.600}',
          hoverColor: '{surface.700}',
          activeColor: '{surface.800}'
        }
      },
      dark: {
        chip: { focusBackground: '{surface.700}', focusColor: '{surface.0}' },
        dropdown: {
          background: '{surface.800}',
          hoverBackground: '{surface.700}',
          activeBackground: '{surface.600}',
          color: '{surface.300}',
          hoverColor: '{surface.200}',
          activeColor: '{surface.100}'
        }
      }
    }
  },
  index$1n = {
    root: {
      width: '2rem',
      height: '2rem',
      fontSize: '1rem',
      background: '{content.border.color}',
      color: '{content.color}',
      borderRadius: '{content.border.radius}'
    },
    icon: { size: '1rem' },
    group: { borderColor: '{content.background}', offset: '-0.75rem' },
    lg: {
      width: '3rem',
      height: '3rem',
      fontSize: '1.5rem',
      icon: { size: '1.5rem' },
      group: { offset: '-1rem' }
    },
    xl: {
      width: '4rem',
      height: '4rem',
      fontSize: '2rem',
      icon: { size: '2rem' },
      group: { offset: '-1.5rem' }
    }
  },
  index$1m = {
    root: {
      borderRadius: '{border.radius.md}',
      padding: '0 0.5rem',
      fontSize: '0.75rem',
      fontWeight: '700',
      minWidth: '1.5rem',
      height: '1.5rem'
    },
    dot: { size: '0.5rem' },
    sm: { fontSize: '0.625rem', minWidth: '1.25rem', height: '1.25rem' },
    lg: { fontSize: '0.875rem', minWidth: '1.75rem', height: '1.75rem' },
    xl: { fontSize: '1rem', minWidth: '2rem', height: '2rem' },
    colorScheme: {
      light: {
        primary: {
          background: '{primary.color}',
          color: '{primary.contrast.color}'
        },
        secondary: { background: '{surface.100}', color: '{surface.600}' },
        success: { background: '{green.500}', color: '{surface.0}' },
        info: { background: '{sky.500}', color: '{surface.0}' },
        warn: { background: '{orange.500}', color: '{surface.0}' },
        danger: { background: '{red.500}', color: '{surface.0}' },
        contrast: { background: '{surface.950}', color: '{surface.0}' }
      },
      dark: {
        primary: {
          background: '{primary.color}',
          color: '{primary.contrast.color}'
        },
        secondary: { background: '{surface.800}', color: '{surface.300}' },
        success: { background: '{green.400}', color: '{green.950}' },
        info: { background: '{sky.400}', color: '{sky.950}' },
        warn: { background: '{orange.400}', color: '{orange.950}' },
        danger: { background: '{red.400}', color: '{red.950}' },
        contrast: { background: '{surface.0}', color: '{surface.950}' }
      }
    }
  },
  index$1l = {
    primitive: {
      borderRadius: {
        none: '0',
        xs: '2px',
        sm: '4px',
        md: '6px',
        lg: '8px',
        xl: '12px'
      },
      emerald: {
        50: '#ecfdf5',
        100: '#d1fae5',
        200: '#a7f3d0',
        300: '#6ee7b7',
        400: '#34d399',
        500: '#10b981',
        600: '#059669',
        700: '#047857',
        800: '#065f46',
        900: '#064e3b',
        950: '#022c22'
      },
      green: {
        50: '#f0fdf4',
        100: '#dcfce7',
        200: '#bbf7d0',
        300: '#86efac',
        400: '#4ade80',
        500: '#22c55e',
        600: '#16a34a',
        700: '#15803d',
        800: '#166534',
        900: '#14532d',
        950: '#052e16'
      },
      lime: {
        50: '#f7fee7',
        100: '#ecfccb',
        200: '#d9f99d',
        300: '#bef264',
        400: '#a3e635',
        500: '#84cc16',
        600: '#65a30d',
        700: '#4d7c0f',
        800: '#3f6212',
        900: '#365314',
        950: '#1a2e05'
      },
      red: {
        50: '#fef2f2',
        100: '#fee2e2',
        200: '#fecaca',
        300: '#fca5a5',
        400: '#f87171',
        500: '#ef4444',
        600: '#dc2626',
        700: '#b91c1c',
        800: '#991b1b',
        900: '#7f1d1d',
        950: '#450a0a'
      },
      orange: {
        50: '#fff7ed',
        100: '#ffedd5',
        200: '#fed7aa',
        300: '#fdba74',
        400: '#fb923c',
        500: '#f97316',
        600: '#ea580c',
        700: '#c2410c',
        800: '#9a3412',
        900: '#7c2d12',
        950: '#431407'
      },
      amber: {
        50: '#fffbeb',
        100: '#fef3c7',
        200: '#fde68a',
        300: '#fcd34d',
        400: '#fbbf24',
        500: '#f59e0b',
        600: '#d97706',
        700: '#b45309',
        800: '#92400e',
        900: '#78350f',
        950: '#451a03'
      },
      yellow: {
        50: '#fefce8',
        100: '#fef9c3',
        200: '#fef08a',
        300: '#fde047',
        400: '#facc15',
        500: '#eab308',
        600: '#ca8a04',
        700: '#a16207',
        800: '#854d0e',
        900: '#713f12',
        950: '#422006'
      },
      teal: {
        50: '#f0fdfa',
        100: '#ccfbf1',
        200: '#99f6e4',
        300: '#5eead4',
        400: '#2dd4bf',
        500: '#14b8a6',
        600: '#0d9488',
        700: '#0f766e',
        800: '#115e59',
        900: '#134e4a',
        950: '#042f2e'
      },
      cyan: {
        50: '#ecfeff',
        100: '#cffafe',
        200: '#a5f3fc',
        300: '#67e8f9',
        400: '#22d3ee',
        500: '#06b6d4',
        600: '#0891b2',
        700: '#0e7490',
        800: '#155e75',
        900: '#164e63',
        950: '#083344'
      },
      sky: {
        50: '#f0f9ff',
        100: '#e0f2fe',
        200: '#bae6fd',
        300: '#7dd3fc',
        400: '#38bdf8',
        500: '#0ea5e9',
        600: '#0284c7',
        700: '#0369a1',
        800: '#075985',
        900: '#0c4a6e',
        950: '#082f49'
      },
      blue: {
        50: '#eff6ff',
        100: '#dbeafe',
        200: '#bfdbfe',
        300: '#93c5fd',
        400: '#60a5fa',
        500: '#3b82f6',
        600: '#2563eb',
        700: '#1d4ed8',
        800: '#1e40af',
        900: '#1e3a8a',
        950: '#172554'
      },
      indigo: {
        50: '#eef2ff',
        100: '#e0e7ff',
        200: '#c7d2fe',
        300: '#a5b4fc',
        400: '#818cf8',
        500: '#6366f1',
        600: '#4f46e5',
        700: '#4338ca',
        800: '#3730a3',
        900: '#312e81',
        950: '#1e1b4b'
      },
      violet: {
        50: '#f5f3ff',
        100: '#ede9fe',
        200: '#ddd6fe',
        300: '#c4b5fd',
        400: '#a78bfa',
        500: '#8b5cf6',
        600: '#7c3aed',
        700: '#6d28d9',
        800: '#5b21b6',
        900: '#4c1d95',
        950: '#2e1065'
      },
      purple: {
        50: '#faf5ff',
        100: '#f3e8ff',
        200: '#e9d5ff',
        300: '#d8b4fe',
        400: '#c084fc',
        500: '#a855f7',
        600: '#9333ea',
        700: '#7e22ce',
        800: '#6b21a8',
        900: '#581c87',
        950: '#3b0764'
      },
      fuchsia: {
        50: '#fdf4ff',
        100: '#fae8ff',
        200: '#f5d0fe',
        300: '#f0abfc',
        400: '#e879f9',
        500: '#d946ef',
        600: '#c026d3',
        700: '#a21caf',
        800: '#86198f',
        900: '#701a75',
        950: '#4a044e'
      },
      pink: {
        50: '#fdf2f8',
        100: '#fce7f3',
        200: '#fbcfe8',
        300: '#f9a8d4',
        400: '#f472b6',
        500: '#ec4899',
        600: '#db2777',
        700: '#be185d',
        800: '#9d174d',
        900: '#831843',
        950: '#500724'
      },
      rose: {
        50: '#fff1f2',
        100: '#ffe4e6',
        200: '#fecdd3',
        300: '#fda4af',
        400: '#fb7185',
        500: '#f43f5e',
        600: '#e11d48',
        700: '#be123c',
        800: '#9f1239',
        900: '#881337',
        950: '#4c0519'
      },
      slate: {
        50: '#f8fafc',
        100: '#f1f5f9',
        200: '#e2e8f0',
        300: '#cbd5e1',
        400: '#94a3b8',
        500: '#64748b',
        600: '#475569',
        700: '#334155',
        800: '#1e293b',
        900: '#0f172a',
        950: '#020617'
      },
      gray: {
        50: '#f9fafb',
        100: '#f3f4f6',
        200: '#e5e7eb',
        300: '#d1d5db',
        400: '#9ca3af',
        500: '#6b7280',
        600: '#4b5563',
        700: '#374151',
        800: '#1f2937',
        900: '#111827',
        950: '#030712'
      },
      zinc: {
        50: '#fafafa',
        100: '#f4f4f5',
        200: '#e4e4e7',
        300: '#d4d4d8',
        400: '#a1a1aa',
        500: '#71717a',
        600: '#52525b',
        700: '#3f3f46',
        800: '#27272a',
        900: '#18181b',
        950: '#09090b'
      },
      neutral: {
        50: '#fafafa',
        100: '#f5f5f5',
        200: '#e5e5e5',
        300: '#d4d4d4',
        400: '#a3a3a3',
        500: '#737373',
        600: '#525252',
        700: '#404040',
        800: '#262626',
        900: '#171717',
        950: '#0a0a0a'
      },
      stone: {
        50: '#fafaf9',
        100: '#f5f5f4',
        200: '#e7e5e4',
        300: '#d6d3d1',
        400: '#a8a29e',
        500: '#78716c',
        600: '#57534e',
        700: '#44403c',
        800: '#292524',
        900: '#1c1917',
        950: '#0c0a09'
      }
    },
    semantic: {
      transitionDuration: '0.2s',
      focusRing: {
        width: '1px',
        style: 'solid',
        color: '{primary.color}',
        offset: '2px',
        shadow: 'none'
      },
      disabledOpacity: '0.6',
      iconSize: '1rem',
      anchorGutter: '2px',
      primary: {
        50: '{emerald.50}',
        100: '{emerald.100}',
        200: '{emerald.200}',
        300: '{emerald.300}',
        400: '{emerald.400}',
        500: '{emerald.500}',
        600: '{emerald.600}',
        700: '{emerald.700}',
        800: '{emerald.800}',
        900: '{emerald.900}',
        950: '{emerald.950}'
      },
      formField: {
        paddingX: '0.75rem',
        paddingY: '0.5rem',
        sm: {
          fontSize: '0.875rem',
          paddingX: '0.625rem',
          paddingY: '0.375rem'
        },
        lg: {
          fontSize: '1.125rem',
          paddingX: '0.875rem',
          paddingY: '0.625rem'
        },
        borderRadius: '{border.radius.md}',
        focusRing: {
          width: '0',
          style: 'none',
          color: 'transparent',
          offset: '0',
          shadow: 'none'
        },
        transitionDuration: '{transition.duration}'
      },
      list: {
        padding: '0.25rem 0.25rem',
        gap: '2px',
        header: { padding: '0.5rem 1rem 0.25rem 1rem' },
        option: {
          padding: '0.5rem 0.75rem',
          borderRadius: '{border.radius.sm}'
        },
        optionGroup: { padding: '0.5rem 0.75rem', fontWeight: '600' }
      },
      content: { borderRadius: '{border.radius.md}' },
      mask: { transitionDuration: '0.15s' },
      navigation: {
        list: { padding: '0.25rem 0.25rem', gap: '2px' },
        item: {
          padding: '0.5rem 0.75rem',
          borderRadius: '{border.radius.sm}',
          gap: '0.5rem'
        },
        submenuLabel: { padding: '0.5rem 0.75rem', fontWeight: '600' },
        submenuIcon: { size: '0.875rem' }
      },
      overlay: {
        select: {
          borderRadius: '{border.radius.md}',
          shadow:
            '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)'
        },
        popover: {
          borderRadius: '{border.radius.md}',
          padding: '0.75rem',
          shadow:
            '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)'
        },
        modal: {
          borderRadius: '{border.radius.xl}',
          padding: '1.25rem',
          shadow:
            '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1)'
        },
        navigation: {
          shadow:
            '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)'
        }
      },
      colorScheme: {
        light: {
          surface: {
            0: '#ffffff',
            50: '{slate.50}',
            100: '{slate.100}',
            200: '{slate.200}',
            300: '{slate.300}',
            400: '{slate.400}',
            500: '{slate.500}',
            600: '{slate.600}',
            700: '{slate.700}',
            800: '{slate.800}',
            900: '{slate.900}',
            950: '{slate.950}'
          },
          primary: {
            color: '{primary.500}',
            contrastColor: '#ffffff',
            hoverColor: '{primary.600}',
            activeColor: '{primary.700}'
          },
          highlight: {
            background: '{primary.50}',
            focusBackground: '{primary.100}',
            color: '{primary.700}',
            focusColor: '{primary.800}'
          },
          mask: { background: 'rgba(0,0,0,0.4)', color: '{surface.200}' },
          formField: {
            background: '{surface.0}',
            disabledBackground: '{surface.200}',
            filledBackground: '{surface.50}',
            filledHoverBackground: '{surface.50}',
            filledFocusBackground: '{surface.50}',
            borderColor: '{surface.300}',
            hoverBorderColor: '{surface.400}',
            focusBorderColor: '{primary.color}',
            invalidBorderColor: '{red.400}',
            color: '{surface.700}',
            disabledColor: '{surface.500}',
            placeholderColor: '{surface.500}',
            invalidPlaceholderColor: '{red.600}',
            floatLabelColor: '{surface.500}',
            floatLabelFocusColor: '{primary.600}',
            floatLabelActiveColor: '{surface.500}',
            floatLabelInvalidColor: '{form.field.invalid.placeholder.color}',
            iconColor: '{surface.400}',
            shadow: '0 0 #0000, 0 0 #0000, 0 1px 2px 0 rgba(18, 18, 23, 0.05)'
          },
          text: {
            color: '{surface.700}',
            hoverColor: '{surface.800}',
            mutedColor: '{surface.500}',
            hoverMutedColor: '{surface.600}'
          },
          content: {
            background: '{surface.0}',
            hoverBackground: '{surface.100}',
            borderColor: '{surface.200}',
            color: '{text.color}',
            hoverColor: '{text.hover.color}'
          },
          overlay: {
            select: {
              background: '{surface.0}',
              borderColor: '{surface.200}',
              color: '{text.color}'
            },
            popover: {
              background: '{surface.0}',
              borderColor: '{surface.200}',
              color: '{text.color}'
            },
            modal: {
              background: '{surface.0}',
              borderColor: '{surface.200}',
              color: '{text.color}'
            }
          },
          list: {
            option: {
              focusBackground: '{surface.100}',
              selectedBackground: '{highlight.background}',
              selectedFocusBackground: '{highlight.focus.background}',
              color: '{text.color}',
              focusColor: '{text.hover.color}',
              selectedColor: '{highlight.color}',
              selectedFocusColor: '{highlight.focus.color}',
              icon: { color: '{surface.400}', focusColor: '{surface.500}' }
            },
            optionGroup: {
              background: 'transparent',
              color: '{text.muted.color}'
            }
          },
          navigation: {
            item: {
              focusBackground: '{surface.100}',
              activeBackground: '{surface.100}',
              color: '{text.color}',
              focusColor: '{text.hover.color}',
              activeColor: '{text.hover.color}',
              icon: {
                color: '{surface.400}',
                focusColor: '{surface.500}',
                activeColor: '{surface.500}'
              }
            },
            submenuLabel: {
              background: 'transparent',
              color: '{text.muted.color}'
            },
            submenuIcon: {
              color: '{surface.400}',
              focusColor: '{surface.500}',
              activeColor: '{surface.500}'
            }
          }
        },
        dark: {
          surface: {
            0: '#ffffff',
            50: '{zinc.50}',
            100: '{zinc.100}',
            200: '{zinc.200}',
            300: '{zinc.300}',
            400: '{zinc.400}',
            500: '{zinc.500}',
            600: '{zinc.600}',
            700: '{zinc.700}',
            800: '{zinc.800}',
            900: '{zinc.900}',
            950: '{zinc.950}'
          },
          primary: {
            color: '{primary.400}',
            contrastColor: '{surface.900}',
            hoverColor: '{primary.300}',
            activeColor: '{primary.200}'
          },
          highlight: {
            background: 'color-mix(in srgb, {primary.400}, transparent 84%)',
            focusBackground:
              'color-mix(in srgb, {primary.400}, transparent 76%)',
            color: 'rgba(255,255,255,.87)',
            focusColor: 'rgba(255,255,255,.87)'
          },
          mask: { background: 'rgba(0,0,0,0.6)', color: '{surface.200}' },
          formField: {
            background: '{surface.950}',
            disabledBackground: '{surface.700}',
            filledBackground: '{surface.800}',
            filledHoverBackground: '{surface.800}',
            filledFocusBackground: '{surface.800}',
            borderColor: '{surface.600}',
            hoverBorderColor: '{surface.500}',
            focusBorderColor: '{primary.color}',
            invalidBorderColor: '{red.300}',
            color: '{surface.0}',
            disabledColor: '{surface.400}',
            placeholderColor: '{surface.400}',
            invalidPlaceholderColor: '{red.400}',
            floatLabelColor: '{surface.400}',
            floatLabelFocusColor: '{primary.color}',
            floatLabelActiveColor: '{surface.400}',
            floatLabelInvalidColor: '{form.field.invalid.placeholder.color}',
            iconColor: '{surface.400}',
            shadow: '0 0 #0000, 0 0 #0000, 0 1px 2px 0 rgba(18, 18, 23, 0.05)'
          },
          text: {
            color: '{surface.0}',
            hoverColor: '{surface.0}',
            mutedColor: '{surface.400}',
            hoverMutedColor: '{surface.300}'
          },
          content: {
            background: '{surface.900}',
            hoverBackground: '{surface.800}',
            borderColor: '{surface.700}',
            color: '{text.color}',
            hoverColor: '{text.hover.color}'
          },
          overlay: {
            select: {
              background: '{surface.900}',
              borderColor: '{surface.700}',
              color: '{text.color}'
            },
            popover: {
              background: '{surface.900}',
              borderColor: '{surface.700}',
              color: '{text.color}'
            },
            modal: {
              background: '{surface.900}',
              borderColor: '{surface.700}',
              color: '{text.color}'
            }
          },
          list: {
            option: {
              focusBackground: '{surface.800}',
              selectedBackground: '{highlight.background}',
              selectedFocusBackground: '{highlight.focus.background}',
              color: '{text.color}',
              focusColor: '{text.hover.color}',
              selectedColor: '{highlight.color}',
              selectedFocusColor: '{highlight.focus.color}',
              icon: { color: '{surface.500}', focusColor: '{surface.400}' }
            },
            optionGroup: {
              background: 'transparent',
              color: '{text.muted.color}'
            }
          },
          navigation: {
            item: {
              focusBackground: '{surface.800}',
              activeBackground: '{surface.800}',
              color: '{text.color}',
              focusColor: '{text.hover.color}',
              activeColor: '{text.hover.color}',
              icon: {
                color: '{surface.500}',
                focusColor: '{surface.400}',
                activeColor: '{surface.400}'
              }
            },
            submenuLabel: {
              background: 'transparent',
              color: '{text.muted.color}'
            },
            submenuIcon: {
              color: '{surface.500}',
              focusColor: '{surface.400}',
              activeColor: '{surface.400}'
            }
          }
        }
      }
    }
  },
  index$1k = { root: { borderRadius: '{content.border.radius}' } },
  index$1j = {
    root: {
      padding: '1rem',
      background: '{content.background}',
      gap: '0.5rem',
      transitionDuration: '{transition.duration}'
    },
    item: {
      color: '{text.muted.color}',
      hoverColor: '{text.color}',
      borderRadius: '{content.border.radius}',
      gap: '{navigation.item.gap}',
      icon: {
        color: '{navigation.item.icon.color}',
        hoverColor: '{navigation.item.icon.focus.color}'
      },
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    separator: { color: '{navigation.item.icon.color}' }
  },
  index$1i = {
    root: {
      borderRadius: '{form.field.border.radius}',
      roundedBorderRadius: '2rem',
      gap: '0.5rem',
      paddingX: '{form.field.padding.x}',
      paddingY: '{form.field.padding.y}',
      iconOnlyWidth: '2.5rem',
      sm: {
        fontSize: '{form.field.sm.font.size}',
        paddingX: '{form.field.sm.padding.x}',
        paddingY: '{form.field.sm.padding.y}'
      },
      lg: {
        fontSize: '{form.field.lg.font.size}',
        paddingX: '{form.field.lg.padding.x}',
        paddingY: '{form.field.lg.padding.y}'
      },
      label: { fontWeight: '500' },
      raisedShadow:
        '0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        offset: '{focus.ring.offset}'
      },
      badgeSize: '1rem',
      transitionDuration: '{form.field.transition.duration}'
    },
    colorScheme: {
      light: {
        root: {
          primary: {
            background: '{primary.color}',
            hoverBackground: '{primary.hover.color}',
            activeBackground: '{primary.active.color}',
            borderColor: '{primary.color}',
            hoverBorderColor: '{primary.hover.color}',
            activeBorderColor: '{primary.active.color}',
            color: '{primary.contrast.color}',
            hoverColor: '{primary.contrast.color}',
            activeColor: '{primary.contrast.color}',
            focusRing: { color: '{primary.color}', shadow: 'none' }
          },
          secondary: {
            background: '{surface.100}',
            hoverBackground: '{surface.200}',
            activeBackground: '{surface.300}',
            borderColor: '{surface.100}',
            hoverBorderColor: '{surface.200}',
            activeBorderColor: '{surface.300}',
            color: '{surface.600}',
            hoverColor: '{surface.700}',
            activeColor: '{surface.800}',
            focusRing: { color: '{surface.600}', shadow: 'none' }
          },
          info: {
            background: '{sky.500}',
            hoverBackground: '{sky.600}',
            activeBackground: '{sky.700}',
            borderColor: '{sky.500}',
            hoverBorderColor: '{sky.600}',
            activeBorderColor: '{sky.700}',
            color: '#ffffff',
            hoverColor: '#ffffff',
            activeColor: '#ffffff',
            focusRing: { color: '{sky.500}', shadow: 'none' }
          },
          success: {
            background: '{green.500}',
            hoverBackground: '{green.600}',
            activeBackground: '{green.700}',
            borderColor: '{green.500}',
            hoverBorderColor: '{green.600}',
            activeBorderColor: '{green.700}',
            color: '#ffffff',
            hoverColor: '#ffffff',
            activeColor: '#ffffff',
            focusRing: { color: '{green.500}', shadow: 'none' }
          },
          warn: {
            background: '{orange.500}',
            hoverBackground: '{orange.600}',
            activeBackground: '{orange.700}',
            borderColor: '{orange.500}',
            hoverBorderColor: '{orange.600}',
            activeBorderColor: '{orange.700}',
            color: '#ffffff',
            hoverColor: '#ffffff',
            activeColor: '#ffffff',
            focusRing: { color: '{orange.500}', shadow: 'none' }
          },
          help: {
            background: '{purple.500}',
            hoverBackground: '{purple.600}',
            activeBackground: '{purple.700}',
            borderColor: '{purple.500}',
            hoverBorderColor: '{purple.600}',
            activeBorderColor: '{purple.700}',
            color: '#ffffff',
            hoverColor: '#ffffff',
            activeColor: '#ffffff',
            focusRing: { color: '{purple.500}', shadow: 'none' }
          },
          danger: {
            background: '{red.500}',
            hoverBackground: '{red.600}',
            activeBackground: '{red.700}',
            borderColor: '{red.500}',
            hoverBorderColor: '{red.600}',
            activeBorderColor: '{red.700}',
            color: '#ffffff',
            hoverColor: '#ffffff',
            activeColor: '#ffffff',
            focusRing: { color: '{red.500}', shadow: 'none' }
          },
          contrast: {
            background: '{surface.950}',
            hoverBackground: '{surface.900}',
            activeBackground: '{surface.800}',
            borderColor: '{surface.950}',
            hoverBorderColor: '{surface.900}',
            activeBorderColor: '{surface.800}',
            color: '{surface.0}',
            hoverColor: '{surface.0}',
            activeColor: '{surface.0}',
            focusRing: { color: '{surface.950}', shadow: 'none' }
          }
        },
        outlined: {
          primary: {
            hoverBackground: '{primary.50}',
            activeBackground: '{primary.100}',
            borderColor: '{primary.200}',
            color: '{primary.color}'
          },
          secondary: {
            hoverBackground: '{surface.50}',
            activeBackground: '{surface.100}',
            borderColor: '{surface.200}',
            color: '{surface.500}'
          },
          success: {
            hoverBackground: '{green.50}',
            activeBackground: '{green.100}',
            borderColor: '{green.200}',
            color: '{green.500}'
          },
          info: {
            hoverBackground: '{sky.50}',
            activeBackground: '{sky.100}',
            borderColor: '{sky.200}',
            color: '{sky.500}'
          },
          warn: {
            hoverBackground: '{orange.50}',
            activeBackground: '{orange.100}',
            borderColor: '{orange.200}',
            color: '{orange.500}'
          },
          help: {
            hoverBackground: '{purple.50}',
            activeBackground: '{purple.100}',
            borderColor: '{purple.200}',
            color: '{purple.500}'
          },
          danger: {
            hoverBackground: '{red.50}',
            activeBackground: '{red.100}',
            borderColor: '{red.200}',
            color: '{red.500}'
          },
          contrast: {
            hoverBackground: '{surface.50}',
            activeBackground: '{surface.100}',
            borderColor: '{surface.700}',
            color: '{surface.950}'
          },
          plain: {
            hoverBackground: '{surface.50}',
            activeBackground: '{surface.100}',
            borderColor: '{surface.200}',
            color: '{surface.700}'
          }
        },
        text: {
          primary: {
            hoverBackground: '{primary.50}',
            activeBackground: '{primary.100}',
            color: '{primary.color}'
          },
          secondary: {
            hoverBackground: '{surface.50}',
            activeBackground: '{surface.100}',
            color: '{surface.500}'
          },
          success: {
            hoverBackground: '{green.50}',
            activeBackground: '{green.100}',
            color: '{green.500}'
          },
          info: {
            hoverBackground: '{sky.50}',
            activeBackground: '{sky.100}',
            color: '{sky.500}'
          },
          warn: {
            hoverBackground: '{orange.50}',
            activeBackground: '{orange.100}',
            color: '{orange.500}'
          },
          help: {
            hoverBackground: '{purple.50}',
            activeBackground: '{purple.100}',
            color: '{purple.500}'
          },
          danger: {
            hoverBackground: '{red.50}',
            activeBackground: '{red.100}',
            color: '{red.500}'
          },
          contrast: {
            hoverBackground: '{surface.50}',
            activeBackground: '{surface.100}',
            color: '{surface.950}'
          },
          plain: {
            hoverBackground: '{surface.50}',
            activeBackground: '{surface.100}',
            color: '{surface.700}'
          }
        },
        link: {
          color: '{primary.color}',
          hoverColor: '{primary.color}',
          activeColor: '{primary.color}'
        }
      },
      dark: {
        root: {
          primary: {
            background: '{primary.color}',
            hoverBackground: '{primary.hover.color}',
            activeBackground: '{primary.active.color}',
            borderColor: '{primary.color}',
            hoverBorderColor: '{primary.hover.color}',
            activeBorderColor: '{primary.active.color}',
            color: '{primary.contrast.color}',
            hoverColor: '{primary.contrast.color}',
            activeColor: '{primary.contrast.color}',
            focusRing: { color: '{primary.color}', shadow: 'none' }
          },
          secondary: {
            background: '{surface.800}',
            hoverBackground: '{surface.700}',
            activeBackground: '{surface.600}',
            borderColor: '{surface.800}',
            hoverBorderColor: '{surface.700}',
            activeBorderColor: '{surface.600}',
            color: '{surface.300}',
            hoverColor: '{surface.200}',
            activeColor: '{surface.100}',
            focusRing: { color: '{surface.300}', shadow: 'none' }
          },
          info: {
            background: '{sky.400}',
            hoverBackground: '{sky.300}',
            activeBackground: '{sky.200}',
            borderColor: '{sky.400}',
            hoverBorderColor: '{sky.300}',
            activeBorderColor: '{sky.200}',
            color: '{sky.950}',
            hoverColor: '{sky.950}',
            activeColor: '{sky.950}',
            focusRing: { color: '{sky.400}', shadow: 'none' }
          },
          success: {
            background: '{green.400}',
            hoverBackground: '{green.300}',
            activeBackground: '{green.200}',
            borderColor: '{green.400}',
            hoverBorderColor: '{green.300}',
            activeBorderColor: '{green.200}',
            color: '{green.950}',
            hoverColor: '{green.950}',
            activeColor: '{green.950}',
            focusRing: { color: '{green.400}', shadow: 'none' }
          },
          warn: {
            background: '{orange.400}',
            hoverBackground: '{orange.300}',
            activeBackground: '{orange.200}',
            borderColor: '{orange.400}',
            hoverBorderColor: '{orange.300}',
            activeBorderColor: '{orange.200}',
            color: '{orange.950}',
            hoverColor: '{orange.950}',
            activeColor: '{orange.950}',
            focusRing: { color: '{orange.400}', shadow: 'none' }
          },
          help: {
            background: '{purple.400}',
            hoverBackground: '{purple.300}',
            activeBackground: '{purple.200}',
            borderColor: '{purple.400}',
            hoverBorderColor: '{purple.300}',
            activeBorderColor: '{purple.200}',
            color: '{purple.950}',
            hoverColor: '{purple.950}',
            activeColor: '{purple.950}',
            focusRing: { color: '{purple.400}', shadow: 'none' }
          },
          danger: {
            background: '{red.400}',
            hoverBackground: '{red.300}',
            activeBackground: '{red.200}',
            borderColor: '{red.400}',
            hoverBorderColor: '{red.300}',
            activeBorderColor: '{red.200}',
            color: '{red.950}',
            hoverColor: '{red.950}',
            activeColor: '{red.950}',
            focusRing: { color: '{red.400}', shadow: 'none' }
          },
          contrast: {
            background: '{surface.0}',
            hoverBackground: '{surface.100}',
            activeBackground: '{surface.200}',
            borderColor: '{surface.0}',
            hoverBorderColor: '{surface.100}',
            activeBorderColor: '{surface.200}',
            color: '{surface.950}',
            hoverColor: '{surface.950}',
            activeColor: '{surface.950}',
            focusRing: { color: '{surface.0}', shadow: 'none' }
          }
        },
        outlined: {
          primary: {
            hoverBackground:
              'color-mix(in srgb, {primary.color}, transparent 96%)',
            activeBackground:
              'color-mix(in srgb, {primary.color}, transparent 84%)',
            borderColor: '{primary.700}',
            color: '{primary.color}'
          },
          secondary: {
            hoverBackground: 'rgba(255,255,255,0.04)',
            activeBackground: 'rgba(255,255,255,0.16)',
            borderColor: '{surface.700}',
            color: '{surface.400}'
          },
          success: {
            hoverBackground: 'color-mix(in srgb, {green.400}, transparent 96%)',
            activeBackground:
              'color-mix(in srgb, {green.400}, transparent 84%)',
            borderColor: '{green.700}',
            color: '{green.400}'
          },
          info: {
            hoverBackground: 'color-mix(in srgb, {sky.400}, transparent 96%)',
            activeBackground: 'color-mix(in srgb, {sky.400}, transparent 84%)',
            borderColor: '{sky.700}',
            color: '{sky.400}'
          },
          warn: {
            hoverBackground:
              'color-mix(in srgb, {orange.400}, transparent 96%)',
            activeBackground:
              'color-mix(in srgb, {orange.400}, transparent 84%)',
            borderColor: '{orange.700}',
            color: '{orange.400}'
          },
          help: {
            hoverBackground:
              'color-mix(in srgb, {purple.400}, transparent 96%)',
            activeBackground:
              'color-mix(in srgb, {purple.400}, transparent 84%)',
            borderColor: '{purple.700}',
            color: '{purple.400}'
          },
          danger: {
            hoverBackground: 'color-mix(in srgb, {red.400}, transparent 96%)',
            activeBackground: 'color-mix(in srgb, {red.400}, transparent 84%)',
            borderColor: '{red.700}',
            color: '{red.400}'
          },
          contrast: {
            hoverBackground: '{surface.800}',
            activeBackground: '{surface.700}',
            borderColor: '{surface.500}',
            color: '{surface.0}'
          },
          plain: {
            hoverBackground: '{surface.800}',
            activeBackground: '{surface.700}',
            borderColor: '{surface.600}',
            color: '{surface.0}'
          }
        },
        text: {
          primary: {
            hoverBackground:
              'color-mix(in srgb, {primary.color}, transparent 96%)',
            activeBackground:
              'color-mix(in srgb, {primary.color}, transparent 84%)',
            color: '{primary.color}'
          },
          secondary: {
            hoverBackground: '{surface.800}',
            activeBackground: '{surface.700}',
            color: '{surface.400}'
          },
          success: {
            hoverBackground: 'color-mix(in srgb, {green.400}, transparent 96%)',
            activeBackground:
              'color-mix(in srgb, {green.400}, transparent 84%)',
            color: '{green.400}'
          },
          info: {
            hoverBackground: 'color-mix(in srgb, {sky.400}, transparent 96%)',
            activeBackground: 'color-mix(in srgb, {sky.400}, transparent 84%)',
            color: '{sky.400}'
          },
          warn: {
            hoverBackground:
              'color-mix(in srgb, {orange.400}, transparent 96%)',
            activeBackground:
              'color-mix(in srgb, {orange.400}, transparent 84%)',
            color: '{orange.400}'
          },
          help: {
            hoverBackground:
              'color-mix(in srgb, {purple.400}, transparent 96%)',
            activeBackground:
              'color-mix(in srgb, {purple.400}, transparent 84%)',
            color: '{purple.400}'
          },
          danger: {
            hoverBackground: 'color-mix(in srgb, {red.400}, transparent 96%)',
            activeBackground: 'color-mix(in srgb, {red.400}, transparent 84%)',
            color: '{red.400}'
          },
          contrast: {
            hoverBackground: '{surface.800}',
            activeBackground: '{surface.700}',
            color: '{surface.0}'
          },
          plain: {
            hoverBackground: '{surface.800}',
            activeBackground: '{surface.700}',
            color: '{surface.0}'
          }
        },
        link: {
          color: '{primary.color}',
          hoverColor: '{primary.color}',
          activeColor: '{primary.color}'
        }
      }
    }
  },
  index$1h = {
    root: {
      background: '{content.background}',
      borderRadius: '{border.radius.xl}',
      color: '{content.color}',
      shadow:
        '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1)'
    },
    body: { padding: '1.25rem', gap: '0.5rem' },
    caption: { gap: '0.5rem' },
    title: { fontSize: '1.25rem', fontWeight: '500' },
    subtitle: { color: '{text.muted.color}' }
  },
  index$1g = {
    root: { transitionDuration: '{transition.duration}' },
    content: { gap: '0.25rem' },
    indicatorList: { padding: '1rem', gap: '0.5rem' },
    indicator: {
      width: '2rem',
      height: '0.5rem',
      borderRadius: '{content.border.radius}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    colorScheme: {
      light: {
        indicator: {
          background: '{surface.200}',
          hoverBackground: '{surface.300}',
          activeBackground: '{primary.color}'
        }
      },
      dark: {
        indicator: {
          background: '{surface.700}',
          hoverBackground: '{surface.600}',
          activeBackground: '{primary.color}'
        }
      }
    }
  },
  index$1f = {
    root: {
      background: '{form.field.background}',
      disabledBackground: '{form.field.disabled.background}',
      filledBackground: '{form.field.filled.background}',
      filledHoverBackground: '{form.field.filled.hover.background}',
      filledFocusBackground: '{form.field.filled.focus.background}',
      borderColor: '{form.field.border.color}',
      hoverBorderColor: '{form.field.hover.border.color}',
      focusBorderColor: '{form.field.focus.border.color}',
      invalidBorderColor: '{form.field.invalid.border.color}',
      color: '{form.field.color}',
      disabledColor: '{form.field.disabled.color}',
      placeholderColor: '{form.field.placeholder.color}',
      invalidPlaceholderColor: '{form.field.invalid.placeholder.color}',
      shadow: '{form.field.shadow}',
      paddingX: '{form.field.padding.x}',
      paddingY: '{form.field.padding.y}',
      borderRadius: '{form.field.border.radius}',
      focusRing: {
        width: '{form.field.focus.ring.width}',
        style: '{form.field.focus.ring.style}',
        color: '{form.field.focus.ring.color}',
        offset: '{form.field.focus.ring.offset}',
        shadow: '{form.field.focus.ring.shadow}'
      },
      transitionDuration: '{form.field.transition.duration}',
      sm: {
        fontSize: '{form.field.sm.font.size}',
        paddingX: '{form.field.sm.padding.x}',
        paddingY: '{form.field.sm.padding.y}'
      },
      lg: {
        fontSize: '{form.field.lg.font.size}',
        paddingX: '{form.field.lg.padding.x}',
        paddingY: '{form.field.lg.padding.y}'
      }
    },
    dropdown: { width: '2.5rem', color: '{form.field.icon.color}' },
    overlay: {
      background: '{overlay.select.background}',
      borderColor: '{overlay.select.border.color}',
      borderRadius: '{overlay.select.border.radius}',
      color: '{overlay.select.color}',
      shadow: '{overlay.select.shadow}'
    },
    list: {
      padding: '{list.padding}',
      gap: '{list.gap}',
      mobileIndent: '1rem'
    },
    option: {
      focusBackground: '{list.option.focus.background}',
      selectedBackground: '{list.option.selected.background}',
      selectedFocusBackground: '{list.option.selected.focus.background}',
      color: '{list.option.color}',
      focusColor: '{list.option.focus.color}',
      selectedColor: '{list.option.selected.color}',
      selectedFocusColor: '{list.option.selected.focus.color}',
      padding: '{list.option.padding}',
      borderRadius: '{list.option.border.radius}',
      icon: {
        color: '{list.option.icon.color}',
        focusColor: '{list.option.icon.focus.color}',
        size: '0.875rem'
      }
    },
    clearIcon: { color: '{form.field.icon.color}' }
  },
  index$1e = {
    root: {
      borderRadius: '{border.radius.sm}',
      width: '1.25rem',
      height: '1.25rem',
      background: '{form.field.background}',
      checkedBackground: '{primary.color}',
      checkedHoverBackground: '{primary.hover.color}',
      disabledBackground: '{form.field.disabled.background}',
      filledBackground: '{form.field.filled.background}',
      borderColor: '{form.field.border.color}',
      hoverBorderColor: '{form.field.hover.border.color}',
      focusBorderColor: '{form.field.border.color}',
      checkedBorderColor: '{primary.color}',
      checkedHoverBorderColor: '{primary.hover.color}',
      checkedFocusBorderColor: '{primary.color}',
      checkedDisabledBorderColor: '{form.field.border.color}',
      invalidBorderColor: '{form.field.invalid.border.color}',
      shadow: '{form.field.shadow}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      },
      transitionDuration: '{form.field.transition.duration}',
      sm: { width: '1rem', height: '1rem' },
      lg: { width: '1.5rem', height: '1.5rem' }
    },
    icon: {
      size: '0.875rem',
      color: '{form.field.color}',
      checkedColor: '{primary.contrast.color}',
      checkedHoverColor: '{primary.contrast.color}',
      disabledColor: '{form.field.disabled.color}',
      sm: { size: '0.75rem' },
      lg: { size: '1rem' }
    }
  },
  index$1d = {
    root: {
      borderRadius: '16px',
      paddingX: '0.75rem',
      paddingY: '0.5rem',
      gap: '0.5rem',
      transitionDuration: '{transition.duration}'
    },
    image: { width: '2rem', height: '2rem' },
    icon: { size: '1rem' },
    removeIcon: {
      size: '1rem',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{form.field.focus.ring.shadow}'
      }
    },
    colorScheme: {
      light: {
        root: { background: '{surface.100}', color: '{surface.800}' },
        icon: { color: '{surface.800}' },
        removeIcon: { color: '{surface.800}' }
      },
      dark: {
        root: { background: '{surface.800}', color: '{surface.0}' },
        icon: { color: '{surface.0}' },
        removeIcon: { color: '{surface.0}' }
      }
    }
  },
  index$1c = {
    root: { transitionDuration: '{transition.duration}' },
    preview: {
      width: '1.5rem',
      height: '1.5rem',
      borderRadius: '{form.field.border.radius}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    panel: {
      shadow: '{overlay.popover.shadow}',
      borderRadius: '{overlay.popover.borderRadius}'
    },
    colorScheme: {
      light: {
        panel: { background: '{surface.800}', borderColor: '{surface.900}' },
        handle: { color: '{surface.0}' }
      },
      dark: {
        panel: { background: '{surface.900}', borderColor: '{surface.700}' },
        handle: { color: '{surface.0}' }
      }
    }
  },
  index$1b = {
    icon: { size: '2rem', color: '{overlay.modal.color}' },
    content: { gap: '1rem' }
  },
  index$1a = {
    root: {
      background: '{overlay.popover.background}',
      borderColor: '{overlay.popover.border.color}',
      color: '{overlay.popover.color}',
      borderRadius: '{overlay.popover.border.radius}',
      shadow: '{overlay.popover.shadow}',
      gutter: '10px',
      arrowOffset: '1.25rem'
    },
    content: { padding: '{overlay.popover.padding}', gap: '1rem' },
    icon: { size: '1.5rem', color: '{overlay.popover.color}' },
    footer: {
      gap: '0.5rem',
      padding:
        '0 {overlay.popover.padding} {overlay.popover.padding} {overlay.popover.padding}'
    }
  },
  index$19 = {
    root: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      color: '{content.color}',
      borderRadius: '{content.border.radius}',
      shadow: '{overlay.navigation.shadow}',
      transitionDuration: '{transition.duration}'
    },
    list: {
      padding: '{navigation.list.padding}',
      gap: '{navigation.list.gap}'
    },
    item: {
      focusBackground: '{navigation.item.focus.background}',
      activeBackground: '{navigation.item.active.background}',
      color: '{navigation.item.color}',
      focusColor: '{navigation.item.focus.color}',
      activeColor: '{navigation.item.active.color}',
      padding: '{navigation.item.padding}',
      borderRadius: '{navigation.item.border.radius}',
      gap: '{navigation.item.gap}',
      icon: {
        color: '{navigation.item.icon.color}',
        focusColor: '{navigation.item.icon.focus.color}',
        activeColor: '{navigation.item.icon.active.color}'
      }
    },
    submenu: { mobileIndent: '1rem' },
    submenuIcon: {
      size: '{navigation.submenu.icon.size}',
      color: '{navigation.submenu.icon.color}',
      focusColor: '{navigation.submenu.icon.focus.color}',
      activeColor: '{navigation.submenu.icon.active.color}'
    },
    separator: { borderColor: '{content.border.color}' }
  },
  index$18 = {
    root: { transitionDuration: '{transition.duration}' },
    header: {
      background: '{content.background}',
      borderColor: '{datatable.border.color}',
      color: '{content.color}',
      borderWidth: '0 0 1px 0',
      padding: '0.75rem 1rem'
    },
    headerCell: {
      background: '{content.background}',
      hoverBackground: '{content.hover.background}',
      selectedBackground: '{highlight.background}',
      borderColor: '{datatable.border.color}',
      color: '{content.color}',
      hoverColor: '{content.hover.color}',
      selectedColor: '{highlight.color}',
      gap: '0.5rem',
      padding: '0.75rem 1rem',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '-1px',
        shadow: '{focus.ring.shadow}'
      }
    },
    columnTitle: { fontWeight: '600' },
    row: {
      background: '{content.background}',
      hoverBackground: '{content.hover.background}',
      selectedBackground: '{highlight.background}',
      color: '{content.color}',
      hoverColor: '{content.hover.color}',
      selectedColor: '{highlight.color}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '-1px',
        shadow: '{focus.ring.shadow}'
      }
    },
    bodyCell: {
      borderColor: '{datatable.border.color}',
      padding: '0.75rem 1rem'
    },
    footerCell: {
      background: '{content.background}',
      borderColor: '{datatable.border.color}',
      color: '{content.color}',
      padding: '0.75rem 1rem'
    },
    columnFooter: { fontWeight: '600' },
    footer: {
      background: '{content.background}',
      borderColor: '{datatable.border.color}',
      color: '{content.color}',
      borderWidth: '0 0 1px 0',
      padding: '0.75rem 1rem'
    },
    dropPoint: { color: '{primary.color}' },
    columnResizerWidth: '0.5rem',
    resizeIndicator: { width: '1px', color: '{primary.color}' },
    sortIcon: {
      color: '{text.muted.color}',
      hoverColor: '{text.hover.muted.color}',
      size: '0.875rem'
    },
    loadingIcon: { size: '2rem' },
    rowToggleButton: {
      hoverBackground: '{content.hover.background}',
      selectedHoverBackground: '{content.background}',
      color: '{text.muted.color}',
      hoverColor: '{text.color}',
      selectedHoverColor: '{primary.color}',
      size: '1.75rem',
      borderRadius: '50%',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    filter: {
      inlineGap: '0.5rem',
      overlaySelect: {
        background: '{overlay.select.background}',
        borderColor: '{overlay.select.border.color}',
        borderRadius: '{overlay.select.border.radius}',
        color: '{overlay.select.color}',
        shadow: '{overlay.select.shadow}'
      },
      overlayPopover: {
        background: '{overlay.popover.background}',
        borderColor: '{overlay.popover.border.color}',
        borderRadius: '{overlay.popover.border.radius}',
        color: '{overlay.popover.color}',
        shadow: '{overlay.popover.shadow}',
        padding: '{overlay.popover.padding}',
        gap: '0.5rem'
      },
      rule: { borderColor: '{content.border.color}' },
      constraintList: { padding: '{list.padding}', gap: '{list.gap}' },
      constraint: {
        focusBackground: '{list.option.focus.background}',
        selectedBackground: '{list.option.selected.background}',
        selectedFocusBackground: '{list.option.selected.focus.background}',
        color: '{list.option.color}',
        focusColor: '{list.option.focus.color}',
        selectedColor: '{list.option.selected.color}',
        selectedFocusColor: '{list.option.selected.focus.color}',
        separator: { borderColor: '{content.border.color}' },
        padding: '{list.option.padding}',
        borderRadius: '{list.option.border.radius}'
      }
    },
    paginatorTop: {
      borderColor: '{datatable.border.color}',
      borderWidth: '0 0 1px 0'
    },
    paginatorBottom: {
      borderColor: '{datatable.border.color}',
      borderWidth: '0 0 1px 0'
    },
    colorScheme: {
      light: {
        root: { borderColor: '{content.border.color}' },
        row: { stripedBackground: '{surface.50}' },
        bodyCell: { selectedBorderColor: '{primary.100}' }
      },
      dark: {
        root: { borderColor: '{surface.800}' },
        row: { stripedBackground: '{surface.950}' },
        bodyCell: { selectedBorderColor: '{primary.900}' }
      }
    }
  },
  index$17 = {
    root: {
      borderColor: 'transparent',
      borderWidth: '0',
      borderRadius: '0',
      padding: '0'
    },
    header: {
      background: '{content.background}',
      color: '{content.color}',
      borderColor: '{content.border.color}',
      borderWidth: '0 0 1px 0',
      padding: '0.75rem 1rem',
      borderRadius: '0'
    },
    content: {
      background: '{content.background}',
      color: '{content.color}',
      borderColor: 'transparent',
      borderWidth: '0',
      padding: '0',
      borderRadius: '0'
    },
    footer: {
      background: '{content.background}',
      color: '{content.color}',
      borderColor: '{content.border.color}',
      borderWidth: '1px 0 0 0',
      padding: '0.75rem 1rem',
      borderRadius: '0'
    },
    paginatorTop: {
      borderColor: '{content.border.color}',
      borderWidth: '0 0 1px 0'
    },
    paginatorBottom: {
      borderColor: '{content.border.color}',
      borderWidth: '1px 0 0 0'
    }
  },
  index$16 = {
    root: { transitionDuration: '{transition.duration}' },
    panel: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      color: '{content.color}',
      borderRadius: '{content.border.radius}',
      shadow: '{overlay.popover.shadow}',
      padding: '{overlay.popover.padding}'
    },
    header: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      color: '{content.color}',
      padding: '0 0 0.5rem 0'
    },
    title: { gap: '0.5rem', fontWeight: '500' },
    dropdown: {
      width: '2.5rem',
      sm: { width: '2rem' },
      lg: { width: '3rem' },
      borderColor: '{form.field.border.color}',
      hoverBorderColor: '{form.field.border.color}',
      activeBorderColor: '{form.field.border.color}',
      borderRadius: '{form.field.border.radius}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    inputIcon: { color: '{form.field.icon.color}' },
    selectMonth: {
      hoverBackground: '{content.hover.background}',
      color: '{content.color}',
      hoverColor: '{content.hover.color}',
      padding: '0.25rem 0.5rem',
      borderRadius: '{content.border.radius}'
    },
    selectYear: {
      hoverBackground: '{content.hover.background}',
      color: '{content.color}',
      hoverColor: '{content.hover.color}',
      padding: '0.25rem 0.5rem',
      borderRadius: '{content.border.radius}'
    },
    group: {
      borderColor: '{content.border.color}',
      gap: '{overlay.popover.padding}'
    },
    dayView: { margin: '0.5rem 0 0 0' },
    weekDay: {
      padding: '0.25rem',
      fontWeight: '500',
      color: '{content.color}'
    },
    date: {
      hoverBackground: '{content.hover.background}',
      selectedBackground: '{primary.color}',
      rangeSelectedBackground: '{highlight.background}',
      color: '{content.color}',
      hoverColor: '{content.hover.color}',
      selectedColor: '{primary.contrast.color}',
      rangeSelectedColor: '{highlight.color}',
      width: '2rem',
      height: '2rem',
      borderRadius: '50%',
      padding: '0.25rem',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    monthView: { margin: '0.5rem 0 0 0' },
    month: { padding: '0.375rem', borderRadius: '{content.border.radius}' },
    yearView: { margin: '0.5rem 0 0 0' },
    year: { padding: '0.375rem', borderRadius: '{content.border.radius}' },
    buttonbar: {
      padding: '0.5rem 0 0 0',
      borderColor: '{content.border.color}'
    },
    timePicker: {
      padding: '0.5rem 0 0 0',
      borderColor: '{content.border.color}',
      gap: '0.5rem',
      buttonGap: '0.25rem'
    },
    colorScheme: {
      light: {
        dropdown: {
          background: '{surface.100}',
          hoverBackground: '{surface.200}',
          activeBackground: '{surface.300}',
          color: '{surface.600}',
          hoverColor: '{surface.700}',
          activeColor: '{surface.800}'
        },
        today: { background: '{surface.200}', color: '{surface.900}' }
      },
      dark: {
        dropdown: {
          background: '{surface.800}',
          hoverBackground: '{surface.700}',
          activeBackground: '{surface.600}',
          color: '{surface.300}',
          hoverColor: '{surface.200}',
          activeColor: '{surface.100}'
        },
        today: { background: '{surface.700}', color: '{surface.0}' }
      }
    }
  },
  index$15 = {
    root: {
      background: '{overlay.modal.background}',
      borderColor: '{overlay.modal.border.color}',
      color: '{overlay.modal.color}',
      borderRadius: '{overlay.modal.border.radius}',
      shadow: '{overlay.modal.shadow}'
    },
    header: { padding: '{overlay.modal.padding}', gap: '0.5rem' },
    title: { fontSize: '1.25rem', fontWeight: '600' },
    content: {
      padding:
        '0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}'
    },
    footer: {
      padding:
        '0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}',
      gap: '0.5rem'
    }
  },
  index$14 = {
    root: { borderColor: '{content.border.color}' },
    content: { background: '{content.background}', color: '{text.color}' },
    horizontal: {
      margin: '1rem 0',
      padding: '0 1rem',
      content: { padding: '0 0.5rem' }
    },
    vertical: {
      margin: '0 1rem',
      padding: '0.5rem 0',
      content: { padding: '0.5rem 0' }
    }
  },
  index$13 = {
    root: {
      background: 'rgba(255, 255, 255, 0.1)',
      borderColor: 'rgba(255, 255, 255, 0.2)',
      padding: '0.5rem',
      borderRadius: '{border.radius.xl}'
    },
    item: {
      borderRadius: '{content.border.radius}',
      padding: '0.5rem',
      size: '3rem',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    }
  },
  index$12 = {
    root: {
      background: '{overlay.modal.background}',
      borderColor: '{overlay.modal.border.color}',
      color: '{overlay.modal.color}',
      shadow: '{overlay.modal.shadow}'
    },
    header: { padding: '{overlay.modal.padding}' },
    title: { fontSize: '1.5rem', fontWeight: '600' },
    content: {
      padding:
        '0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}'
    },
    footer: { padding: '{overlay.modal.padding}' }
  },
  index$11 = {
    toolbar: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      borderRadius: '{content.border.radius}'
    },
    toolbarItem: {
      color: '{text.muted.color}',
      hoverColor: '{text.color}',
      activeColor: '{primary.color}'
    },
    overlay: {
      background: '{overlay.select.background}',
      borderColor: '{overlay.select.border.color}',
      borderRadius: '{overlay.select.border.radius}',
      color: '{overlay.select.color}',
      shadow: '{overlay.select.shadow}',
      padding: '{list.padding}'
    },
    overlayOption: {
      focusBackground: '{list.option.focus.background}',
      color: '{list.option.color}',
      focusColor: '{list.option.focus.color}',
      padding: '{list.option.padding}',
      borderRadius: '{list.option.border.radius}'
    },
    content: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      color: '{content.color}',
      borderRadius: '{content.border.radius}'
    }
  },
  index$10 = {
    root: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      borderRadius: '{content.border.radius}',
      color: '{content.color}',
      padding: '0 1.125rem 1.125rem 1.125rem',
      transitionDuration: '{transition.duration}'
    },
    legend: {
      background: '{content.background}',
      hoverBackground: '{content.hover.background}',
      color: '{content.color}',
      hoverColor: '{content.hover.color}',
      borderRadius: '{content.border.radius}',
      borderWidth: '1px',
      borderColor: 'transparent',
      padding: '0.5rem 0.75rem',
      gap: '0.5rem',
      fontWeight: '600',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    toggleIcon: {
      color: '{text.muted.color}',
      hoverColor: '{text.hover.muted.color}'
    },
    content: { padding: '0' }
  },
  index$$ = {
    root: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      color: '{content.color}',
      borderRadius: '{content.border.radius}',
      transitionDuration: '{transition.duration}'
    },
    header: {
      background: 'transparent',
      color: '{text.color}',
      padding: '1.125rem',
      borderColor: 'unset',
      borderWidth: '0',
      borderRadius: '0',
      gap: '0.5rem'
    },
    content: {
      highlightBorderColor: '{primary.color}',
      padding: '0 1.125rem 1.125rem 1.125rem',
      gap: '1rem'
    },
    file: {
      padding: '1rem',
      gap: '1rem',
      borderColor: '{content.border.color}',
      info: { gap: '0.5rem' }
    },
    fileList: { gap: '0.5rem' },
    progressbar: { height: '0.25rem' },
    basic: { gap: '0.5rem' }
  },
  index$_ = {
    root: {
      color: '{form.field.float.label.color}',
      focusColor: '{form.field.float.label.focus.color}',
      activeColor: '{form.field.float.label.active.color}',
      invalidColor: '{form.field.float.label.invalid.color}',
      transitionDuration: '0.2s',
      positionX: '{form.field.padding.x}',
      positionY: '{form.field.padding.y}',
      fontWeight: '500',
      active: { fontSize: '0.75rem', fontWeight: '400' }
    },
    over: { active: { top: '-1.25rem' } },
    in: {
      input: { paddingTop: '1.5rem', paddingBottom: '{form.field.padding.y}' },
      active: { top: '{form.field.padding.y}' }
    },
    on: {
      borderRadius: '{border.radius.xs}',
      active: { background: '{form.field.background}', padding: '0 0.125rem' }
    }
  },
  index$Z = {
    root: {
      borderWidth: '1px',
      borderColor: '{content.border.color}',
      borderRadius: '{content.border.radius}',
      transitionDuration: '{transition.duration}'
    },
    navButton: {
      background: 'rgba(255, 255, 255, 0.1)',
      hoverBackground: 'rgba(255, 255, 255, 0.2)',
      color: '{surface.100}',
      hoverColor: '{surface.0}',
      size: '3rem',
      gutter: '0.5rem',
      prev: { borderRadius: '50%' },
      next: { borderRadius: '50%' },
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    navIcon: { size: '1.5rem' },
    thumbnailsContent: {
      background: '{content.background}',
      padding: '1rem 0.25rem'
    },
    thumbnailNavButton: {
      size: '2rem',
      borderRadius: '{content.border.radius}',
      gutter: '0.5rem',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    thumbnailNavButtonIcon: { size: '1rem' },
    caption: {
      background: 'rgba(0, 0, 0, 0.5)',
      color: '{surface.100}',
      padding: '1rem'
    },
    indicatorList: { gap: '0.5rem', padding: '1rem' },
    indicatorButton: {
      width: '1rem',
      height: '1rem',
      activeBackground: '{primary.color}',
      borderRadius: '50%',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    insetIndicatorList: { background: 'rgba(0, 0, 0, 0.5)' },
    insetIndicatorButton: {
      background: 'rgba(255, 255, 255, 0.4)',
      hoverBackground: 'rgba(255, 255, 255, 0.6)',
      activeBackground: 'rgba(255, 255, 255, 0.9)'
    },
    closeButton: {
      size: '3rem',
      gutter: '0.5rem',
      background: 'rgba(255, 255, 255, 0.1)',
      hoverBackground: 'rgba(255, 255, 255, 0.2)',
      color: '{surface.50}',
      hoverColor: '{surface.0}',
      borderRadius: '50%',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    closeButtonIcon: { size: '1.5rem' },
    colorScheme: {
      light: {
        thumbnailNavButton: {
          hoverBackground: '{surface.100}',
          color: '{surface.600}',
          hoverColor: '{surface.700}'
        },
        indicatorButton: {
          background: '{surface.200}',
          hoverBackground: '{surface.300}'
        }
      },
      dark: {
        thumbnailNavButton: {
          hoverBackground: '{surface.700}',
          color: '{surface.400}',
          hoverColor: '{surface.0}'
        },
        indicatorButton: {
          background: '{surface.700}',
          hoverBackground: '{surface.600}'
        }
      }
    }
  },
  index$Y = { icon: { color: '{form.field.icon.color}' } },
  index$X = {
    root: {
      color: '{form.field.float.label.color}',
      focusColor: '{form.field.float.label.focus.color}',
      invalidColor: '{form.field.float.label.invalid.color}',
      transitionDuration: '0.2s',
      positionX: '{form.field.padding.x}',
      top: '{form.field.padding.y}',
      fontSize: '0.75rem',
      fontWeight: '400'
    },
    input: { paddingTop: '1.5rem', paddingBottom: '{form.field.padding.y}' }
  },
  index$W = {
    root: { transitionDuration: '{transition.duration}' },
    preview: {
      icon: { size: '1.5rem' },
      mask: { background: '{mask.background}', color: '{mask.color}' }
    },
    toolbar: {
      position: { left: 'auto', right: '1rem', top: '1rem', bottom: 'auto' },
      blur: '8px',
      background: 'rgba(255,255,255,0.1)',
      borderColor: 'rgba(255,255,255,0.2)',
      borderWidth: '1px',
      borderRadius: '30px',
      padding: '.5rem',
      gap: '0.5rem'
    },
    action: {
      hoverBackground: 'rgba(255,255,255,0.1)',
      color: '{surface.50}',
      hoverColor: '{surface.0}',
      size: '3rem',
      iconSize: '1.5rem',
      borderRadius: '50%',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    }
  },
  index$V = {
    handle: {
      size: '15px',
      hoverSize: '30px',
      background: 'rgba(255,255,255,0.3)',
      hoverBackground: 'rgba(255,255,255,0.3)',
      borderColor: 'unset',
      hoverBorderColor: 'unset',
      borderWidth: '0',
      borderRadius: '50%',
      transitionDuration: '{transition.duration}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: 'rgba(255,255,255,0.3)',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    }
  },
  index$U = {
    root: {
      padding: '{form.field.padding.y} {form.field.padding.x}',
      borderRadius: '{content.border.radius}',
      gap: '0.5rem'
    },
    text: { fontWeight: '500' },
    icon: { size: '1rem' },
    colorScheme: {
      light: {
        info: {
          background: 'color-mix(in srgb, {blue.50}, transparent 5%)',
          borderColor: '{blue.200}',
          color: '{blue.600}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)'
        },
        success: {
          background: 'color-mix(in srgb, {green.50}, transparent 5%)',
          borderColor: '{green.200}',
          color: '{green.600}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)'
        },
        warn: {
          background: 'color-mix(in srgb,{yellow.50}, transparent 5%)',
          borderColor: '{yellow.200}',
          color: '{yellow.600}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)'
        },
        error: {
          background: 'color-mix(in srgb, {red.50}, transparent 5%)',
          borderColor: '{red.200}',
          color: '{red.600}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)'
        },
        secondary: {
          background: '{surface.100}',
          borderColor: '{surface.200}',
          color: '{surface.600}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)'
        },
        contrast: {
          background: '{surface.900}',
          borderColor: '{surface.950}',
          color: '{surface.50}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)'
        }
      },
      dark: {
        info: {
          background: 'color-mix(in srgb, {blue.500}, transparent 84%)',
          borderColor: 'color-mix(in srgb, {blue.700}, transparent 64%)',
          color: '{blue.500}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)'
        },
        success: {
          background: 'color-mix(in srgb, {green.500}, transparent 84%)',
          borderColor: 'color-mix(in srgb, {green.700}, transparent 64%)',
          color: '{green.500}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)'
        },
        warn: {
          background: 'color-mix(in srgb, {yellow.500}, transparent 84%)',
          borderColor: 'color-mix(in srgb, {yellow.700}, transparent 64%)',
          color: '{yellow.500}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)'
        },
        error: {
          background: 'color-mix(in srgb, {red.500}, transparent 84%)',
          borderColor: 'color-mix(in srgb, {red.700}, transparent 64%)',
          color: '{red.500}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)'
        },
        secondary: {
          background: '{surface.800}',
          borderColor: '{surface.700}',
          color: '{surface.300}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)'
        },
        contrast: {
          background: '{surface.0}',
          borderColor: '{surface.100}',
          color: '{surface.950}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)'
        }
      }
    }
  },
  index$T = {
    root: {
      padding: '{form.field.padding.y} {form.field.padding.x}',
      borderRadius: '{content.border.radius}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      },
      transitionDuration: '{transition.duration}'
    },
    display: {
      hoverBackground: '{content.hover.background}',
      hoverColor: '{content.hover.color}'
    }
  },
  index$S = {
    root: {
      background: '{form.field.background}',
      disabledBackground: '{form.field.disabled.background}',
      filledBackground: '{form.field.filled.background}',
      filledFocusBackground: '{form.field.filled.focus.background}',
      borderColor: '{form.field.border.color}',
      hoverBorderColor: '{form.field.hover.border.color}',
      focusBorderColor: '{form.field.focus.border.color}',
      invalidBorderColor: '{form.field.invalid.border.color}',
      color: '{form.field.color}',
      disabledColor: '{form.field.disabled.color}',
      placeholderColor: '{form.field.placeholder.color}',
      shadow: '{form.field.shadow}',
      paddingX: '{form.field.padding.x}',
      paddingY: '{form.field.padding.y}',
      borderRadius: '{form.field.border.radius}',
      focusRing: {
        width: '{form.field.focus.ring.width}',
        style: '{form.field.focus.ring.style}',
        color: '{form.field.focus.ring.color}',
        offset: '{form.field.focus.ring.offset}',
        shadow: '{form.field.focus.ring.shadow}'
      },
      transitionDuration: '{form.field.transition.duration}'
    },
    chip: { borderRadius: '{border.radius.sm}' },
    colorScheme: {
      light: {
        chip: { focusBackground: '{surface.200}', color: '{surface.800}' }
      },
      dark: { chip: { focusBackground: '{surface.700}', color: '{surface.0}' } }
    }
  },
  index$R = {
    addon: {
      background: '{form.field.background}',
      borderColor: '{form.field.border.color}',
      color: '{form.field.icon.color}',
      borderRadius: '{form.field.border.radius}',
      padding: '0.5rem',
      minWidth: '2.5rem'
    }
  },
  index$Q = {
    root: { transitionDuration: '{transition.duration}' },
    button: {
      width: '2.5rem',
      borderRadius: '{form.field.border.radius}',
      verticalPadding: '{form.field.padding.y}'
    },
    colorScheme: {
      light: {
        button: {
          background: 'transparent',
          hoverBackground: '{surface.100}',
          activeBackground: '{surface.200}',
          borderColor: '{form.field.border.color}',
          hoverBorderColor: '{form.field.border.color}',
          activeBorderColor: '{form.field.border.color}',
          color: '{surface.400}',
          hoverColor: '{surface.500}',
          activeColor: '{surface.600}'
        }
      },
      dark: {
        button: {
          background: 'transparent',
          hoverBackground: '{surface.800}',
          activeBackground: '{surface.700}',
          borderColor: '{form.field.border.color}',
          hoverBorderColor: '{form.field.border.color}',
          activeBorderColor: '{form.field.border.color}',
          color: '{surface.400}',
          hoverColor: '{surface.300}',
          activeColor: '{surface.200}'
        }
      }
    }
  },
  index$P = {
    root: { gap: '0.5rem' },
    input: { width: '2.5rem', sm: { width: '2rem' }, lg: { width: '3rem' } }
  },
  index$O = {
    root: {
      background: '{form.field.background}',
      disabledBackground: '{form.field.disabled.background}',
      filledBackground: '{form.field.filled.background}',
      filledHoverBackground: '{form.field.filled.hover.background}',
      filledFocusBackground: '{form.field.filled.focus.background}',
      borderColor: '{form.field.border.color}',
      hoverBorderColor: '{form.field.hover.border.color}',
      focusBorderColor: '{form.field.focus.border.color}',
      invalidBorderColor: '{form.field.invalid.border.color}',
      color: '{form.field.color}',
      disabledColor: '{form.field.disabled.color}',
      placeholderColor: '{form.field.placeholder.color}',
      invalidPlaceholderColor: '{form.field.invalid.placeholder.color}',
      shadow: '{form.field.shadow}',
      paddingX: '{form.field.padding.x}',
      paddingY: '{form.field.padding.y}',
      borderRadius: '{form.field.border.radius}',
      focusRing: {
        width: '{form.field.focus.ring.width}',
        style: '{form.field.focus.ring.style}',
        color: '{form.field.focus.ring.color}',
        offset: '{form.field.focus.ring.offset}',
        shadow: '{form.field.focus.ring.shadow}'
      },
      transitionDuration: '{form.field.transition.duration}',
      sm: {
        fontSize: '{form.field.sm.font.size}',
        paddingX: '{form.field.sm.padding.x}',
        paddingY: '{form.field.sm.padding.y}'
      },
      lg: {
        fontSize: '{form.field.lg.font.size}',
        paddingX: '{form.field.lg.padding.x}',
        paddingY: '{form.field.lg.padding.y}'
      }
    }
  },
  index$N = {
    root: {
      transitionDuration: '{transition.duration}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    value: { background: '{primary.color}' },
    range: { background: '{content.border.color}' },
    text: { color: '{text.muted.color}' }
  },
  index$M = {
    root: {
      background: '{form.field.background}',
      disabledBackground: '{form.field.disabled.background}',
      borderColor: '{form.field.border.color}',
      invalidBorderColor: '{form.field.invalid.border.color}',
      color: '{form.field.color}',
      disabledColor: '{form.field.disabled.color}',
      shadow: '{form.field.shadow}',
      borderRadius: '{form.field.border.radius}',
      transitionDuration: '{form.field.transition.duration}'
    },
    list: {
      padding: '{list.padding}',
      gap: '{list.gap}',
      header: { padding: '{list.header.padding}' }
    },
    option: {
      focusBackground: '{list.option.focus.background}',
      selectedBackground: '{list.option.selected.background}',
      selectedFocusBackground: '{list.option.selected.focus.background}',
      color: '{list.option.color}',
      focusColor: '{list.option.focus.color}',
      selectedColor: '{list.option.selected.color}',
      selectedFocusColor: '{list.option.selected.focus.color}',
      padding: '{list.option.padding}',
      borderRadius: '{list.option.border.radius}'
    },
    optionGroup: {
      background: '{list.option.group.background}',
      color: '{list.option.group.color}',
      fontWeight: '{list.option.group.font.weight}',
      padding: '{list.option.group.padding}'
    },
    checkmark: {
      color: '{list.option.color}',
      gutterStart: '-0.375rem',
      gutterEnd: '0.375rem'
    },
    emptyMessage: { padding: '{list.option.padding}' },
    colorScheme: {
      light: { option: { stripedBackground: '{surface.50}' } },
      dark: { option: { stripedBackground: '{surface.900}' } }
    }
  },
  index$L = {
    root: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      borderRadius: '{content.border.radius}',
      color: '{content.color}',
      gap: '0.5rem',
      verticalOrientation: {
        padding: '{navigation.list.padding}',
        gap: '{navigation.list.gap}'
      },
      horizontalOrientation: { padding: '0.5rem 0.75rem', gap: '0.5rem' },
      transitionDuration: '{transition.duration}'
    },
    baseItem: {
      borderRadius: '{content.border.radius}',
      padding: '{navigation.item.padding}'
    },
    item: {
      focusBackground: '{navigation.item.focus.background}',
      activeBackground: '{navigation.item.active.background}',
      color: '{navigation.item.color}',
      focusColor: '{navigation.item.focus.color}',
      activeColor: '{navigation.item.active.color}',
      padding: '{navigation.item.padding}',
      borderRadius: '{navigation.item.border.radius}',
      gap: '{navigation.item.gap}',
      icon: {
        color: '{navigation.item.icon.color}',
        focusColor: '{navigation.item.icon.focus.color}',
        activeColor: '{navigation.item.icon.active.color}'
      }
    },
    overlay: {
      padding: '0',
      background: '{content.background}',
      borderColor: '{content.border.color}',
      borderRadius: '{content.border.radius}',
      color: '{content.color}',
      shadow: '{overlay.navigation.shadow}',
      gap: '0.5rem'
    },
    submenu: {
      padding: '{navigation.list.padding}',
      gap: '{navigation.list.gap}'
    },
    submenuLabel: {
      padding: '{navigation.submenu.label.padding}',
      fontWeight: '{navigation.submenu.label.font.weight}',
      background: '{navigation.submenu.label.background.}',
      color: '{navigation.submenu.label.color}'
    },
    submenuIcon: {
      size: '{navigation.submenu.icon.size}',
      color: '{navigation.submenu.icon.color}',
      focusColor: '{navigation.submenu.icon.focus.color}',
      activeColor: '{navigation.submenu.icon.active.color}'
    },
    separator: { borderColor: '{content.border.color}' },
    mobileButton: {
      borderRadius: '50%',
      size: '1.75rem',
      color: '{text.muted.color}',
      hoverColor: '{text.hover.muted.color}',
      hoverBackground: '{content.hover.background}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    }
  },
  index$K = {
    root: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      color: '{content.color}',
      borderRadius: '{content.border.radius}',
      shadow: '{overlay.navigation.shadow}',
      transitionDuration: '{transition.duration}'
    },
    list: {
      padding: '{navigation.list.padding}',
      gap: '{navigation.list.gap}'
    },
    item: {
      focusBackground: '{navigation.item.focus.background}',
      color: '{navigation.item.color}',
      focusColor: '{navigation.item.focus.color}',
      padding: '{navigation.item.padding}',
      borderRadius: '{navigation.item.border.radius}',
      gap: '{navigation.item.gap}',
      icon: {
        color: '{navigation.item.icon.color}',
        focusColor: '{navigation.item.icon.focus.color}'
      }
    },
    submenuLabel: {
      padding: '{navigation.submenu.label.padding}',
      fontWeight: '{navigation.submenu.label.font.weight}',
      background: '{navigation.submenu.label.background}',
      color: '{navigation.submenu.label.color}'
    },
    separator: { borderColor: '{content.border.color}' }
  },
  index$J = {
    root: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      borderRadius: '{content.border.radius}',
      color: '{content.color}',
      gap: '0.5rem',
      padding: '0.5rem 0.75rem',
      transitionDuration: '{transition.duration}'
    },
    baseItem: {
      borderRadius: '{content.border.radius}',
      padding: '{navigation.item.padding}'
    },
    item: {
      focusBackground: '{navigation.item.focus.background}',
      activeBackground: '{navigation.item.active.background}',
      color: '{navigation.item.color}',
      focusColor: '{navigation.item.focus.color}',
      activeColor: '{navigation.item.active.color}',
      padding: '{navigation.item.padding}',
      borderRadius: '{navigation.item.border.radius}',
      gap: '{navigation.item.gap}',
      icon: {
        color: '{navigation.item.icon.color}',
        focusColor: '{navigation.item.icon.focus.color}',
        activeColor: '{navigation.item.icon.active.color}'
      }
    },
    submenu: {
      padding: '{navigation.list.padding}',
      gap: '{navigation.list.gap}',
      background: '{content.background}',
      borderColor: '{content.border.color}',
      borderRadius: '{content.border.radius}',
      shadow: '{overlay.navigation.shadow}',
      mobileIndent: '1rem',
      icon: {
        size: '{navigation.submenu.icon.size}',
        color: '{navigation.submenu.icon.color}',
        focusColor: '{navigation.submenu.icon.focus.color}',
        activeColor: '{navigation.submenu.icon.active.color}'
      }
    },
    separator: { borderColor: '{content.border.color}' },
    mobileButton: {
      borderRadius: '50%',
      size: '1.75rem',
      color: '{text.muted.color}',
      hoverColor: '{text.hover.muted.color}',
      hoverBackground: '{content.hover.background}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    }
  },
  index$I = {
    root: {
      borderRadius: '{content.border.radius}',
      borderWidth: '1px',
      transitionDuration: '{transition.duration}'
    },
    content: {
      padding: '0.5rem 0.75rem',
      gap: '0.5rem',
      sm: { padding: '0.375rem 0.625rem' },
      lg: { padding: '0.625rem 0.875rem' }
    },
    text: {
      fontSize: '1rem',
      fontWeight: '500',
      sm: { fontSize: '0.875rem' },
      lg: { fontSize: '1.125rem' }
    },
    icon: { size: '1.125rem', sm: { size: '1rem' }, lg: { size: '1.25rem' } },
    closeButton: {
      width: '1.75rem',
      height: '1.75rem',
      borderRadius: '50%',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        offset: '{focus.ring.offset}'
      }
    },
    closeIcon: {
      size: '1rem',
      sm: { size: '0.875rem' },
      lg: { size: '1.125rem' }
    },
    outlined: { root: { borderWidth: '1px' } },
    simple: { content: { padding: '0' } },
    colorScheme: {
      light: {
        info: {
          background: 'color-mix(in srgb, {blue.50}, transparent 5%)',
          borderColor: '{blue.200}',
          color: '{blue.600}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)',
          closeButton: {
            hoverBackground: '{blue.100}',
            focusRing: { color: '{blue.600}', shadow: 'none' }
          },
          outlined: { color: '{blue.600}', borderColor: '{blue.600}' },
          simple: { color: '{blue.600}' }
        },
        success: {
          background: 'color-mix(in srgb, {green.50}, transparent 5%)',
          borderColor: '{green.200}',
          color: '{green.600}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)',
          closeButton: {
            hoverBackground: '{green.100}',
            focusRing: { color: '{green.600}', shadow: 'none' }
          },
          outlined: { color: '{green.600}', borderColor: '{green.600}' },
          simple: { color: '{green.600}' }
        },
        warn: {
          background: 'color-mix(in srgb,{yellow.50}, transparent 5%)',
          borderColor: '{yellow.200}',
          color: '{yellow.600}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)',
          closeButton: {
            hoverBackground: '{yellow.100}',
            focusRing: { color: '{yellow.600}', shadow: 'none' }
          },
          outlined: { color: '{yellow.600}', borderColor: '{yellow.600}' },
          simple: { color: '{yellow.600}' }
        },
        error: {
          background: 'color-mix(in srgb, {red.50}, transparent 5%)',
          borderColor: '{red.200}',
          color: '{red.600}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)',
          closeButton: {
            hoverBackground: '{red.100}',
            focusRing: { color: '{red.600}', shadow: 'none' }
          },
          outlined: { color: '{red.600}', borderColor: '{red.600}' },
          simple: { color: '{red.600}' }
        },
        secondary: {
          background: '{surface.100}',
          borderColor: '{surface.200}',
          color: '{surface.600}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)',
          closeButton: {
            hoverBackground: '{surface.200}',
            focusRing: { color: '{surface.600}', shadow: 'none' }
          },
          outlined: { color: '{surface.500}', borderColor: '{surface.500}' },
          simple: { color: '{surface.500}' }
        },
        contrast: {
          background: '{surface.900}',
          borderColor: '{surface.950}',
          color: '{surface.50}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)',
          closeButton: {
            hoverBackground: '{surface.800}',
            focusRing: { color: '{surface.50}', shadow: 'none' }
          },
          outlined: { color: '{surface.950}', borderColor: '{surface.950}' },
          simple: { color: '{surface.950}' }
        }
      },
      dark: {
        info: {
          background: 'color-mix(in srgb, {blue.500}, transparent 84%)',
          borderColor: 'color-mix(in srgb, {blue.700}, transparent 64%)',
          color: '{blue.500}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)',
          closeButton: {
            hoverBackground: 'rgba(255, 255, 255, 0.05)',
            focusRing: { color: '{blue.500}', shadow: 'none' }
          },
          outlined: { color: '{blue.500}', borderColor: '{blue.500}' },
          simple: { color: '{blue.500}' }
        },
        success: {
          background: 'color-mix(in srgb, {green.500}, transparent 84%)',
          borderColor: 'color-mix(in srgb, {green.700}, transparent 64%)',
          color: '{green.500}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)',
          closeButton: {
            hoverBackground: 'rgba(255, 255, 255, 0.05)',
            focusRing: { color: '{green.500}', shadow: 'none' }
          },
          outlined: { color: '{green.500}', borderColor: '{green.500}' },
          simple: { color: '{green.500}' }
        },
        warn: {
          background: 'color-mix(in srgb, {yellow.500}, transparent 84%)',
          borderColor: 'color-mix(in srgb, {yellow.700}, transparent 64%)',
          color: '{yellow.500}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)',
          closeButton: {
            hoverBackground: 'rgba(255, 255, 255, 0.05)',
            focusRing: { color: '{yellow.500}', shadow: 'none' }
          },
          outlined: { color: '{yellow.500}', borderColor: '{yellow.500}' },
          simple: { color: '{yellow.500}' }
        },
        error: {
          background: 'color-mix(in srgb, {red.500}, transparent 84%)',
          borderColor: 'color-mix(in srgb, {red.700}, transparent 64%)',
          color: '{red.500}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)',
          closeButton: {
            hoverBackground: 'rgba(255, 255, 255, 0.05)',
            focusRing: { color: '{red.500}', shadow: 'none' }
          },
          outlined: { color: '{red.500}', borderColor: '{red.500}' },
          simple: { color: '{red.500}' }
        },
        secondary: {
          background: '{surface.800}',
          borderColor: '{surface.700}',
          color: '{surface.300}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)',
          closeButton: {
            hoverBackground: '{surface.700}',
            focusRing: { color: '{surface.300}', shadow: 'none' }
          },
          outlined: { color: '{surface.400}', borderColor: '{surface.400}' },
          simple: { color: '{surface.400}' }
        },
        contrast: {
          background: '{surface.0}',
          borderColor: '{surface.100}',
          color: '{surface.950}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)',
          closeButton: {
            hoverBackground: '{surface.100}',
            focusRing: { color: '{surface.950}', shadow: 'none' }
          },
          outlined: { color: '{surface.0}', borderColor: '{surface.0}' },
          simple: { color: '{surface.0}' }
        }
      }
    }
  },
  index$H = {
    root: { borderRadius: '{content.border.radius}', gap: '1rem' },
    meters: { background: '{content.border.color}', size: '0.5rem' },
    label: { gap: '0.5rem' },
    labelMarker: { size: '0.5rem' },
    labelIcon: { size: '1rem' },
    labelList: { verticalGap: '0.5rem', horizontalGap: '1rem' }
  },
  index$G = {
    root: {
      background: '{form.field.background}',
      disabledBackground: '{form.field.disabled.background}',
      filledBackground: '{form.field.filled.background}',
      filledHoverBackground: '{form.field.filled.hover.background}',
      filledFocusBackground: '{form.field.filled.focus.background}',
      borderColor: '{form.field.border.color}',
      hoverBorderColor: '{form.field.hover.border.color}',
      focusBorderColor: '{form.field.focus.border.color}',
      invalidBorderColor: '{form.field.invalid.border.color}',
      color: '{form.field.color}',
      disabledColor: '{form.field.disabled.color}',
      placeholderColor: '{form.field.placeholder.color}',
      invalidPlaceholderColor: '{form.field.invalid.placeholder.color}',
      shadow: '{form.field.shadow}',
      paddingX: '{form.field.padding.x}',
      paddingY: '{form.field.padding.y}',
      borderRadius: '{form.field.border.radius}',
      focusRing: {
        width: '{form.field.focus.ring.width}',
        style: '{form.field.focus.ring.style}',
        color: '{form.field.focus.ring.color}',
        offset: '{form.field.focus.ring.offset}',
        shadow: '{form.field.focus.ring.shadow}'
      },
      transitionDuration: '{form.field.transition.duration}',
      sm: {
        fontSize: '{form.field.sm.font.size}',
        paddingX: '{form.field.sm.padding.x}',
        paddingY: '{form.field.sm.padding.y}'
      },
      lg: {
        fontSize: '{form.field.lg.font.size}',
        paddingX: '{form.field.lg.padding.x}',
        paddingY: '{form.field.lg.padding.y}'
      }
    },
    dropdown: { width: '2.5rem', color: '{form.field.icon.color}' },
    overlay: {
      background: '{overlay.select.background}',
      borderColor: '{overlay.select.border.color}',
      borderRadius: '{overlay.select.border.radius}',
      color: '{overlay.select.color}',
      shadow: '{overlay.select.shadow}'
    },
    list: {
      padding: '{list.padding}',
      gap: '{list.gap}',
      header: { padding: '{list.header.padding}' }
    },
    option: {
      focusBackground: '{list.option.focus.background}',
      selectedBackground: '{list.option.selected.background}',
      selectedFocusBackground: '{list.option.selected.focus.background}',
      color: '{list.option.color}',
      focusColor: '{list.option.focus.color}',
      selectedColor: '{list.option.selected.color}',
      selectedFocusColor: '{list.option.selected.focus.color}',
      padding: '{list.option.padding}',
      borderRadius: '{list.option.border.radius}',
      gap: '0.5rem'
    },
    optionGroup: {
      background: '{list.option.group.background}',
      color: '{list.option.group.color}',
      fontWeight: '{list.option.group.font.weight}',
      padding: '{list.option.group.padding}'
    },
    clearIcon: { color: '{form.field.icon.color}' },
    chip: { borderRadius: '{border.radius.sm}' },
    emptyMessage: { padding: '{list.option.padding}' }
  },
  index$F = { root: { gap: '1.125rem' }, controls: { gap: '0.5rem' } },
  index$E = {
    root: { gutter: '0.75rem', transitionDuration: '{transition.duration}' },
    node: {
      background: '{content.background}',
      hoverBackground: '{content.hover.background}',
      selectedBackground: '{highlight.background}',
      borderColor: '{content.border.color}',
      color: '{content.color}',
      selectedColor: '{highlight.color}',
      hoverColor: '{content.hover.color}',
      padding: '0.75rem 1rem',
      toggleablePadding: '0.75rem 1rem 1.25rem 1rem',
      borderRadius: '{content.border.radius}'
    },
    nodeToggleButton: {
      background: '{content.background}',
      hoverBackground: '{content.hover.background}',
      borderColor: '{content.border.color}',
      color: '{text.muted.color}',
      hoverColor: '{text.color}',
      size: '1.5rem',
      borderRadius: '50%',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    connector: {
      color: '{content.border.color}',
      borderRadius: '{content.border.radius}',
      height: '24px'
    }
  },
  index$D = {
    root: { outline: { width: '2px', color: '{content.background}' } }
  },
  index$C = {
    root: {
      padding: '0.5rem 1rem',
      gap: '0.25rem',
      borderRadius: '{content.border.radius}',
      background: '{content.background}',
      color: '{content.color}',
      transitionDuration: '{transition.duration}'
    },
    navButton: {
      background: 'transparent',
      hoverBackground: '{content.hover.background}',
      selectedBackground: '{highlight.background}',
      color: '{text.muted.color}',
      hoverColor: '{text.hover.muted.color}',
      selectedColor: '{highlight.color}',
      width: '2.5rem',
      height: '2.5rem',
      borderRadius: '50%',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    currentPageReport: { color: '{text.muted.color}' },
    jumpToPageInput: { maxWidth: '2.5rem' }
  },
  index$B = {
    root: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      color: '{content.color}',
      borderRadius: '{content.border.radius}'
    },
    header: {
      background: 'transparent',
      color: '{text.color}',
      padding: '1.125rem',
      borderColor: '{content.border.color}',
      borderWidth: '0',
      borderRadius: '0'
    },
    toggleableHeader: { padding: '0.375rem 1.125rem' },
    title: { fontWeight: '600' },
    content: { padding: '0 1.125rem 1.125rem 1.125rem' },
    footer: { padding: '0 1.125rem 1.125rem 1.125rem' }
  },
  index$A = {
    root: { gap: '0.5rem', transitionDuration: '{transition.duration}' },
    panel: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      borderWidth: '1px',
      color: '{content.color}',
      padding: '0.25rem 0.25rem',
      borderRadius: '{content.border.radius}',
      first: { borderWidth: '1px', topBorderRadius: '{content.border.radius}' },
      last: {
        borderWidth: '1px',
        bottomBorderRadius: '{content.border.radius}'
      }
    },
    item: {
      focusBackground: '{navigation.item.focus.background}',
      color: '{navigation.item.color}',
      focusColor: '{navigation.item.focus.color}',
      gap: '0.5rem',
      padding: '{navigation.item.padding}',
      borderRadius: '{content.border.radius}',
      icon: {
        color: '{navigation.item.icon.color}',
        focusColor: '{navigation.item.icon.focus.color}'
      }
    },
    submenu: { indent: '1rem' },
    submenuIcon: {
      color: '{navigation.submenu.icon.color}',
      focusColor: '{navigation.submenu.icon.focus.color}'
    }
  },
  index$z = {
    meter: {
      background: '{content.border.color}',
      borderRadius: '{content.border.radius}',
      height: '.75rem'
    },
    icon: { color: '{form.field.icon.color}' },
    overlay: {
      background: '{overlay.popover.background}',
      borderColor: '{overlay.popover.border.color}',
      borderRadius: '{overlay.popover.border.radius}',
      color: '{overlay.popover.color}',
      padding: '{overlay.popover.padding}',
      shadow: '{overlay.popover.shadow}'
    },
    content: { gap: '0.5rem' },
    colorScheme: {
      light: {
        strength: {
          weakBackground: '{red.500}',
          mediumBackground: '{amber.500}',
          strongBackground: '{green.500}'
        }
      },
      dark: {
        strength: {
          weakBackground: '{red.400}',
          mediumBackground: '{amber.400}',
          strongBackground: '{green.400}'
        }
      }
    }
  },
  index$y = { root: { gap: '1.125rem' }, controls: { gap: '0.5rem' } },
  index$x = {
    root: {
      background: '{overlay.popover.background}',
      borderColor: '{overlay.popover.border.color}',
      color: '{overlay.popover.color}',
      borderRadius: '{overlay.popover.border.radius}',
      shadow: '{overlay.popover.shadow}',
      gutter: '10px',
      arrowOffset: '1.25rem'
    },
    content: { padding: '{overlay.popover.padding}' }
  },
  index$w = {
    root: {
      background: '{content.border.color}',
      borderRadius: '{content.border.radius}',
      height: '1.25rem'
    },
    value: { background: '{primary.color}' },
    label: {
      color: '{primary.contrast.color}',
      fontSize: '0.75rem',
      fontWeight: '600'
    }
  },
  index$v = {
    colorScheme: {
      light: {
        root: {
          'color.1': '{red.500}',
          'color.2': '{blue.500}',
          'color.3': '{green.500}',
          'color.4': '{yellow.500}'
        }
      },
      dark: {
        root: {
          'color.1': '{red.400}',
          'color.2': '{blue.400}',
          'color.3': '{green.400}',
          'color.4': '{yellow.400}'
        }
      }
    }
  },
  index$u = {
    root: {
      width: '1.25rem',
      height: '1.25rem',
      background: '{form.field.background}',
      checkedBackground: '{primary.color}',
      checkedHoverBackground: '{primary.hover.color}',
      disabledBackground: '{form.field.disabled.background}',
      filledBackground: '{form.field.filled.background}',
      borderColor: '{form.field.border.color}',
      hoverBorderColor: '{form.field.hover.border.color}',
      focusBorderColor: '{form.field.border.color}',
      checkedBorderColor: '{primary.color}',
      checkedHoverBorderColor: '{primary.hover.color}',
      checkedFocusBorderColor: '{primary.color}',
      checkedDisabledBorderColor: '{form.field.border.color}',
      invalidBorderColor: '{form.field.invalid.border.color}',
      shadow: '{form.field.shadow}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      },
      transitionDuration: '{form.field.transition.duration}',
      sm: { width: '1rem', height: '1rem' },
      lg: { width: '1.5rem', height: '1.5rem' }
    },
    icon: {
      size: '0.75rem',
      checkedColor: '{primary.contrast.color}',
      checkedHoverColor: '{primary.contrast.color}',
      disabledColor: '{form.field.disabled.color}',
      sm: { size: '0.5rem' },
      lg: { size: '1rem' }
    }
  },
  index$t = {
    root: {
      gap: '0.25rem',
      transitionDuration: '{transition.duration}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    icon: {
      size: '1rem',
      color: '{text.muted.color}',
      hoverColor: '{primary.color}',
      activeColor: '{primary.color}'
    }
  },
  index$s = {
    colorScheme: {
      light: { root: { background: 'rgba(0,0,0,0.1)' } },
      dark: { root: { background: 'rgba(255,255,255,0.3)' } }
    }
  },
  index$r = {
    root: { transitionDuration: '{transition.duration}' },
    bar: {
      size: '9px',
      borderRadius: '{border.radius.sm}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    colorScheme: {
      light: { bar: { background: '{surface.100}' } },
      dark: { bar: { background: '{surface.800}' } }
    }
  },
  index$q = {
    root: {
      background: '{form.field.background}',
      disabledBackground: '{form.field.disabled.background}',
      filledBackground: '{form.field.filled.background}',
      filledHoverBackground: '{form.field.filled.hover.background}',
      filledFocusBackground: '{form.field.filled.focus.background}',
      borderColor: '{form.field.border.color}',
      hoverBorderColor: '{form.field.hover.border.color}',
      focusBorderColor: '{form.field.focus.border.color}',
      invalidBorderColor: '{form.field.invalid.border.color}',
      color: '{form.field.color}',
      disabledColor: '{form.field.disabled.color}',
      placeholderColor: '{form.field.placeholder.color}',
      invalidPlaceholderColor: '{form.field.invalid.placeholder.color}',
      shadow: '{form.field.shadow}',
      paddingX: '{form.field.padding.x}',
      paddingY: '{form.field.padding.y}',
      borderRadius: '{form.field.border.radius}',
      focusRing: {
        width: '{form.field.focus.ring.width}',
        style: '{form.field.focus.ring.style}',
        color: '{form.field.focus.ring.color}',
        offset: '{form.field.focus.ring.offset}',
        shadow: '{form.field.focus.ring.shadow}'
      },
      transitionDuration: '{form.field.transition.duration}',
      sm: {
        fontSize: '{form.field.sm.font.size}',
        paddingX: '{form.field.sm.padding.x}',
        paddingY: '{form.field.sm.padding.y}'
      },
      lg: {
        fontSize: '{form.field.lg.font.size}',
        paddingX: '{form.field.lg.padding.x}',
        paddingY: '{form.field.lg.padding.y}'
      }
    },
    dropdown: { width: '2.5rem', color: '{form.field.icon.color}' },
    overlay: {
      background: '{overlay.select.background}',
      borderColor: '{overlay.select.border.color}',
      borderRadius: '{overlay.select.border.radius}',
      color: '{overlay.select.color}',
      shadow: '{overlay.select.shadow}'
    },
    list: {
      padding: '{list.padding}',
      gap: '{list.gap}',
      header: { padding: '{list.header.padding}' }
    },
    option: {
      focusBackground: '{list.option.focus.background}',
      selectedBackground: '{list.option.selected.background}',
      selectedFocusBackground: '{list.option.selected.focus.background}',
      color: '{list.option.color}',
      focusColor: '{list.option.focus.color}',
      selectedColor: '{list.option.selected.color}',
      selectedFocusColor: '{list.option.selected.focus.color}',
      padding: '{list.option.padding}',
      borderRadius: '{list.option.border.radius}'
    },
    optionGroup: {
      background: '{list.option.group.background}',
      color: '{list.option.group.color}',
      fontWeight: '{list.option.group.font.weight}',
      padding: '{list.option.group.padding}'
    },
    clearIcon: { color: '{form.field.icon.color}' },
    checkmark: {
      color: '{list.option.color}',
      gutterStart: '-0.375rem',
      gutterEnd: '0.375rem'
    },
    emptyMessage: { padding: '{list.option.padding}' }
  },
  index$p = {
    root: { borderRadius: '{form.field.border.radius}' },
    colorScheme: {
      light: {
        root: { invalidBorderColor: '{form.field.invalid.border.color}' }
      },
      dark: {
        root: { invalidBorderColor: '{form.field.invalid.border.color}' }
      }
    }
  },
  index$o = {
    root: { borderRadius: '{content.border.radius}' },
    colorScheme: {
      light: {
        root: {
          background: '{surface.200}',
          animationBackground: 'rgba(255,255,255,0.4)'
        }
      },
      dark: {
        root: {
          background: 'rgba(255, 255, 255, 0.06)',
          animationBackground: 'rgba(255, 255, 255, 0.04)'
        }
      }
    }
  },
  index$n = {
    root: { transitionDuration: '{transition.duration}' },
    track: {
      background: '{content.border.color}',
      borderRadius: '{content.border.radius}',
      size: '3px'
    },
    range: { background: '{primary.color}' },
    handle: {
      width: '20px',
      height: '20px',
      borderRadius: '50%',
      background: '{content.border.color}',
      hoverBackground: '{content.border.color}',
      content: {
        borderRadius: '50%',
        hoverBackground: '{content.background}',
        width: '16px',
        height: '16px',
        shadow:
          '0px 0.5px 0px 0px rgba(0, 0, 0, 0.08), 0px 1px 1px 0px rgba(0, 0, 0, 0.14)'
      },
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    colorScheme: {
      light: { handle: { contentBackground: '{surface.0}' } },
      dark: { handle: { contentBackground: '{surface.950}' } }
    }
  },
  index$m = {
    root: { gap: '0.5rem', transitionDuration: '{transition.duration}' }
  },
  index$l = {
    root: {
      borderRadius: '{form.field.border.radius}',
      roundedBorderRadius: '2rem',
      raisedShadow:
        '0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)'
    }
  },
  index$k = {
    root: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      color: '{content.color}',
      transitionDuration: '{transition.duration}'
    },
    gutter: { background: '{content.border.color}' },
    handle: {
      size: '24px',
      background: 'transparent',
      borderRadius: '{content.border.radius}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    }
  },
  index$j = {
    root: { transitionDuration: '{transition.duration}' },
    separator: {
      background: '{content.border.color}',
      activeBackground: '{primary.color}',
      margin: '0 0 0 1.625rem',
      size: '2px'
    },
    step: { padding: '0.5rem', gap: '1rem' },
    stepHeader: {
      padding: '0',
      borderRadius: '{content.border.radius}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      },
      gap: '0.5rem'
    },
    stepTitle: {
      color: '{text.muted.color}',
      activeColor: '{primary.color}',
      fontWeight: '500'
    },
    stepNumber: {
      background: '{content.background}',
      activeBackground: '{content.background}',
      borderColor: '{content.border.color}',
      activeBorderColor: '{content.border.color}',
      color: '{text.muted.color}',
      activeColor: '{primary.color}',
      size: '2rem',
      fontSize: '1.143rem',
      fontWeight: '500',
      borderRadius: '50%',
      shadow:
        '0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)'
    },
    steppanels: { padding: '0.875rem 0.5rem 1.125rem 0.5rem' },
    steppanel: {
      background: '{content.background}',
      color: '{content.color}',
      padding: '0',
      indent: '1rem'
    }
  },
  index$i = {
    root: { transitionDuration: '{transition.duration}' },
    separator: { background: '{content.border.color}' },
    itemLink: {
      borderRadius: '{content.border.radius}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      },
      gap: '0.5rem'
    },
    itemLabel: {
      color: '{text.muted.color}',
      activeColor: '{primary.color}',
      fontWeight: '500'
    },
    itemNumber: {
      background: '{content.background}',
      activeBackground: '{content.background}',
      borderColor: '{content.border.color}',
      activeBorderColor: '{content.border.color}',
      color: '{text.muted.color}',
      activeColor: '{primary.color}',
      size: '2rem',
      fontSize: '1.143rem',
      fontWeight: '500',
      borderRadius: '50%',
      shadow:
        '0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)'
    }
  },
  index$h = {
    root: { transitionDuration: '{transition.duration}' },
    tablist: {
      borderWidth: '0 0 1px 0',
      background: '{content.background}',
      borderColor: '{content.border.color}'
    },
    item: {
      background: 'transparent',
      hoverBackground: 'transparent',
      activeBackground: 'transparent',
      borderWidth: '0 0 1px 0',
      borderColor: '{content.border.color}',
      hoverBorderColor: '{content.border.color}',
      activeBorderColor: '{primary.color}',
      color: '{text.muted.color}',
      hoverColor: '{text.color}',
      activeColor: '{primary.color}',
      padding: '1rem 1.125rem',
      fontWeight: '600',
      margin: '0 0 -1px 0',
      gap: '0.5rem',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    itemIcon: {
      color: '{text.muted.color}',
      hoverColor: '{text.color}',
      activeColor: '{primary.color}'
    },
    activeBar: { height: '1px', bottom: '-1px', background: '{primary.color}' }
  },
  index$g = {
    root: { transitionDuration: '{transition.duration}' },
    tablist: {
      borderWidth: '0 0 1px 0',
      background: '{content.background}',
      borderColor: '{content.border.color}'
    },
    tab: {
      background: 'transparent',
      hoverBackground: 'transparent',
      activeBackground: 'transparent',
      borderWidth: '0 0 1px 0',
      borderColor: '{content.border.color}',
      hoverBorderColor: '{content.border.color}',
      activeBorderColor: '{primary.color}',
      color: '{text.muted.color}',
      hoverColor: '{text.color}',
      activeColor: '{primary.color}',
      padding: '1rem 1.125rem',
      fontWeight: '600',
      margin: '0 0 -1px 0',
      gap: '0.5rem',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '-1px',
        shadow: '{focus.ring.shadow}'
      }
    },
    tabpanel: {
      background: '{content.background}',
      color: '{content.color}',
      padding: '0.875rem 1.125rem 1.125rem 1.125rem',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: 'inset {focus.ring.shadow}'
      }
    },
    navButton: {
      background: '{content.background}',
      color: '{text.muted.color}',
      hoverColor: '{text.color}',
      width: '2.5rem',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '-1px',
        shadow: '{focus.ring.shadow}'
      }
    },
    activeBar: { height: '1px', bottom: '-1px', background: '{primary.color}' },
    colorScheme: {
      light: {
        navButton: { shadow: '0px 0px 10px 50px rgba(255, 255, 255, 0.6)' }
      },
      dark: {
        navButton: {
          shadow:
            '0px 0px 10px 50px color-mix(in srgb, {content.background}, transparent 50%)'
        }
      }
    }
  },
  index$f = {
    root: { transitionDuration: '{transition.duration}' },
    tabList: {
      background: '{content.background}',
      borderColor: '{content.border.color}'
    },
    tab: {
      borderColor: '{content.border.color}',
      activeBorderColor: '{primary.color}',
      color: '{text.muted.color}',
      hoverColor: '{text.color}',
      activeColor: '{primary.color}'
    },
    tabPanel: { background: '{content.background}', color: '{content.color}' },
    navButton: {
      background: '{content.background}',
      color: '{text.muted.color}',
      hoverColor: '{text.color}'
    },
    colorScheme: {
      light: {
        navButton: { shadow: '0px 0px 10px 50px rgba(255, 255, 255, 0.6)' }
      },
      dark: {
        navButton: {
          shadow:
            '0px 0px 10px 50px color-mix(in srgb, {content.background}, transparent 50%)'
        }
      }
    }
  },
  index$e = {
    root: {
      fontSize: '0.875rem',
      fontWeight: '700',
      padding: '0.25rem 0.5rem',
      gap: '0.25rem',
      borderRadius: '{content.border.radius}',
      roundedBorderRadius: '{border.radius.xl}'
    },
    icon: { size: '0.75rem' },
    colorScheme: {
      light: {
        primary: { background: '{primary.100}', color: '{primary.700}' },
        secondary: { background: '{surface.100}', color: '{surface.600}' },
        success: { background: '{green.100}', color: '{green.700}' },
        info: { background: '{sky.100}', color: '{sky.700}' },
        warn: { background: '{orange.100}', color: '{orange.700}' },
        danger: { background: '{red.100}', color: '{red.700}' },
        contrast: { background: '{surface.950}', color: '{surface.0}' }
      },
      dark: {
        primary: {
          background: 'color-mix(in srgb, {primary.500}, transparent 84%)',
          color: '{primary.300}'
        },
        secondary: { background: '{surface.800}', color: '{surface.300}' },
        success: {
          background: 'color-mix(in srgb, {green.500}, transparent 84%)',
          color: '{green.300}'
        },
        info: {
          background: 'color-mix(in srgb, {sky.500}, transparent 84%)',
          color: '{sky.300}'
        },
        warn: {
          background: 'color-mix(in srgb, {orange.500}, transparent 84%)',
          color: '{orange.300}'
        },
        danger: {
          background: 'color-mix(in srgb, {red.500}, transparent 84%)',
          color: '{red.300}'
        },
        contrast: { background: '{surface.0}', color: '{surface.950}' }
      }
    }
  },
  index$d = {
    root: {
      background: '{form.field.background}',
      borderColor: '{form.field.border.color}',
      color: '{form.field.color}',
      height: '18rem',
      padding: '{form.field.padding.y} {form.field.padding.x}',
      borderRadius: '{form.field.border.radius}'
    },
    prompt: { gap: '0.25rem' },
    commandResponse: { margin: '2px 0' }
  },
  index$c = {
    root: {
      background: '{form.field.background}',
      disabledBackground: '{form.field.disabled.background}',
      filledBackground: '{form.field.filled.background}',
      filledFocusBackground: '{form.field.filled.focus.background}',
      borderColor: '{form.field.border.color}',
      hoverBorderColor: '{form.field.hover.border.color}',
      focusBorderColor: '{form.field.focus.border.color}',
      invalidBorderColor: '{form.field.invalid.border.color}',
      color: '{form.field.color}',
      disabledColor: '{form.field.disabled.color}',
      placeholderColor: '{form.field.placeholder.color}',
      invalidPlaceholderColor: '{form.field.invalid.placeholder.color}',
      shadow: '{form.field.shadow}',
      paddingX: '{form.field.padding.x}',
      paddingY: '{form.field.padding.y}',
      borderRadius: '{form.field.border.radius}',
      focusRing: {
        width: '{form.field.focus.ring.width}',
        style: '{form.field.focus.ring.style}',
        color: '{form.field.focus.ring.color}',
        offset: '{form.field.focus.ring.offset}',
        shadow: '{form.field.focus.ring.shadow}'
      },
      transitionDuration: '{form.field.transition.duration}',
      sm: {
        fontSize: '{form.field.sm.font.size}',
        paddingX: '{form.field.sm.padding.x}',
        paddingY: '{form.field.sm.padding.y}'
      },
      lg: {
        fontSize: '{form.field.lg.font.size}',
        paddingX: '{form.field.lg.padding.x}',
        paddingY: '{form.field.lg.padding.y}'
      }
    }
  },
  index$b = {
    root: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      color: '{content.color}',
      borderRadius: '{content.border.radius}',
      shadow: '{overlay.navigation.shadow}',
      transitionDuration: '{transition.duration}'
    },
    list: {
      padding: '{navigation.list.padding}',
      gap: '{navigation.list.gap}'
    },
    item: {
      focusBackground: '{navigation.item.focus.background}',
      activeBackground: '{navigation.item.active.background}',
      color: '{navigation.item.color}',
      focusColor: '{navigation.item.focus.color}',
      activeColor: '{navigation.item.active.color}',
      padding: '{navigation.item.padding}',
      borderRadius: '{navigation.item.border.radius}',
      gap: '{navigation.item.gap}',
      icon: {
        color: '{navigation.item.icon.color}',
        focusColor: '{navigation.item.icon.focus.color}',
        activeColor: '{navigation.item.icon.active.color}'
      }
    },
    submenu: { mobileIndent: '1rem' },
    submenuIcon: {
      size: '{navigation.submenu.icon.size}',
      color: '{navigation.submenu.icon.color}',
      focusColor: '{navigation.submenu.icon.focus.color}',
      activeColor: '{navigation.submenu.icon.active.color}'
    },
    separator: { borderColor: '{content.border.color}' }
  },
  index$a = {
    event: { minHeight: '5rem' },
    horizontal: { eventContent: { padding: '1rem 0' } },
    vertical: { eventContent: { padding: '0 1rem' } },
    eventMarker: {
      size: '1.125rem',
      borderRadius: '50%',
      borderWidth: '2px',
      background: '{content.background}',
      borderColor: '{content.border.color}',
      content: {
        borderRadius: '50%',
        size: '0.375rem',
        background: '{primary.color}',
        insetShadow:
          '0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)'
      }
    },
    eventConnector: { color: '{content.border.color}', size: '2px' }
  },
  index$9 = {
    root: {
      width: '25rem',
      borderRadius: '{content.border.radius}',
      borderWidth: '1px',
      transitionDuration: '{transition.duration}'
    },
    icon: { size: '1.125rem' },
    content: { padding: '{overlay.popover.padding}', gap: '0.5rem' },
    text: { gap: '0.5rem' },
    summary: { fontWeight: '500', fontSize: '1rem' },
    detail: { fontWeight: '500', fontSize: '0.875rem' },
    closeButton: {
      width: '1.75rem',
      height: '1.75rem',
      borderRadius: '50%',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        offset: '{focus.ring.offset}'
      }
    },
    closeIcon: { size: '1rem' },
    colorScheme: {
      light: {
        blur: '1.5px',
        info: {
          background: 'color-mix(in srgb, {blue.50}, transparent 5%)',
          borderColor: '{blue.200}',
          color: '{blue.600}',
          detailColor: '{surface.700}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)',
          closeButton: {
            hoverBackground: '{blue.100}',
            focusRing: { color: '{blue.600}', shadow: 'none' }
          }
        },
        success: {
          background: 'color-mix(in srgb, {green.50}, transparent 5%)',
          borderColor: '{green.200}',
          color: '{green.600}',
          detailColor: '{surface.700}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)',
          closeButton: {
            hoverBackground: '{green.100}',
            focusRing: { color: '{green.600}', shadow: 'none' }
          }
        },
        warn: {
          background: 'color-mix(in srgb,{yellow.50}, transparent 5%)',
          borderColor: '{yellow.200}',
          color: '{yellow.600}',
          detailColor: '{surface.700}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)',
          closeButton: {
            hoverBackground: '{yellow.100}',
            focusRing: { color: '{yellow.600}', shadow: 'none' }
          }
        },
        error: {
          background: 'color-mix(in srgb, {red.50}, transparent 5%)',
          borderColor: '{red.200}',
          color: '{red.600}',
          detailColor: '{surface.700}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)',
          closeButton: {
            hoverBackground: '{red.100}',
            focusRing: { color: '{red.600}', shadow: 'none' }
          }
        },
        secondary: {
          background: '{surface.100}',
          borderColor: '{surface.200}',
          color: '{surface.600}',
          detailColor: '{surface.700}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)',
          closeButton: {
            hoverBackground: '{surface.200}',
            focusRing: { color: '{surface.600}', shadow: 'none' }
          }
        },
        contrast: {
          background: '{surface.900}',
          borderColor: '{surface.950}',
          color: '{surface.50}',
          detailColor: '{surface.0}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)',
          closeButton: {
            hoverBackground: '{surface.800}',
            focusRing: { color: '{surface.50}', shadow: 'none' }
          }
        }
      },
      dark: {
        blur: '10px',
        info: {
          background: 'color-mix(in srgb, {blue.500}, transparent 84%)',
          borderColor: 'color-mix(in srgb, {blue.700}, transparent 64%)',
          color: '{blue.500}',
          detailColor: '{surface.0}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)',
          closeButton: {
            hoverBackground: 'rgba(255, 255, 255, 0.05)',
            focusRing: { color: '{blue.500}', shadow: 'none' }
          }
        },
        success: {
          background: 'color-mix(in srgb, {green.500}, transparent 84%)',
          borderColor: 'color-mix(in srgb, {green.700}, transparent 64%)',
          color: '{green.500}',
          detailColor: '{surface.0}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)',
          closeButton: {
            hoverBackground: 'rgba(255, 255, 255, 0.05)',
            focusRing: { color: '{green.500}', shadow: 'none' }
          }
        },
        warn: {
          background: 'color-mix(in srgb, {yellow.500}, transparent 84%)',
          borderColor: 'color-mix(in srgb, {yellow.700}, transparent 64%)',
          color: '{yellow.500}',
          detailColor: '{surface.0}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)',
          closeButton: {
            hoverBackground: 'rgba(255, 255, 255, 0.05)',
            focusRing: { color: '{yellow.500}', shadow: 'none' }
          }
        },
        error: {
          background: 'color-mix(in srgb, {red.500}, transparent 84%)',
          borderColor: 'color-mix(in srgb, {red.700}, transparent 64%)',
          color: '{red.500}',
          detailColor: '{surface.0}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)',
          closeButton: {
            hoverBackground: 'rgba(255, 255, 255, 0.05)',
            focusRing: { color: '{red.500}', shadow: 'none' }
          }
        },
        secondary: {
          background: '{surface.800}',
          borderColor: '{surface.700}',
          color: '{surface.300}',
          detailColor: '{surface.0}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)',
          closeButton: {
            hoverBackground: '{surface.700}',
            focusRing: { color: '{surface.300}', shadow: 'none' }
          }
        },
        contrast: {
          background: '{surface.0}',
          borderColor: '{surface.100}',
          color: '{surface.950}',
          detailColor: '{surface.950}',
          shadow:
            '0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)',
          closeButton: {
            hoverBackground: '{surface.100}',
            focusRing: { color: '{surface.950}', shadow: 'none' }
          }
        }
      }
    }
  },
  index$8 = {
    root: {
      padding: '0.5rem 1rem',
      borderRadius: '{content.border.radius}',
      gap: '0.5rem',
      fontWeight: '500',
      disabledBackground: '{form.field.disabled.background}',
      disabledBorderColor: '{form.field.disabled.background}',
      disabledColor: '{form.field.disabled.color}',
      invalidBorderColor: '{form.field.invalid.border.color}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      },
      transitionDuration: '{form.field.transition.duration}',
      sm: {
        fontSize: '{form.field.sm.font.size}',
        padding: '0.375rem 0.75rem'
      },
      lg: { fontSize: '{form.field.lg.font.size}', padding: '0.625rem 1.25rem' }
    },
    icon: { disabledColor: '{form.field.disabled.color}' },
    content: {
      left: '0.25rem',
      top: '0.25rem',
      checkedShadow:
        '0px 1px 2px 0px rgba(0, 0, 0, 0.02), 0px 1px 2px 0px rgba(0, 0, 0, 0.04)'
    },
    colorScheme: {
      light: {
        root: {
          background: '{surface.100}',
          checkedBackground: '{surface.100}',
          hoverBackground: '{surface.100}',
          borderColor: '{surface.100}',
          color: '{surface.500}',
          hoverColor: '{surface.700}',
          checkedColor: '{surface.900}',
          checkedBorderColor: '{surface.100}'
        },
        content: { checkedBackground: '{surface.0}' },
        icon: {
          color: '{surface.500}',
          hoverColor: '{surface.700}',
          checkedColor: '{surface.900}'
        }
      },
      dark: {
        root: {
          background: '{surface.950}',
          checkedBackground: '{surface.950}',
          hoverBackground: '{surface.950}',
          borderColor: '{surface.950}',
          color: '{surface.400}',
          hoverColor: '{surface.300}',
          checkedColor: '{surface.0}',
          checkedBorderColor: '{surface.950}'
        },
        content: { checkedBackground: '{surface.800}' },
        icon: {
          color: '{surface.400}',
          hoverColor: '{surface.300}',
          checkedColor: '{surface.0}'
        }
      }
    }
  },
  index$7 = {
    root: {
      width: '2.5rem',
      height: '1.5rem',
      borderRadius: '30px',
      gap: '0.25rem',
      shadow: '{form.field.shadow}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      },
      borderWidth: '1px',
      borderColor: 'transparent',
      hoverBorderColor: 'transparent',
      checkedBorderColor: 'transparent',
      checkedHoverBorderColor: 'transparent',
      invalidBorderColor: '{form.field.invalid.border.color}',
      transitionDuration: '{form.field.transition.duration}',
      slideDuration: '0.2s'
    },
    handle: { borderRadius: '50%', size: '1rem' },
    colorScheme: {
      light: {
        root: {
          background: '{surface.300}',
          disabledBackground: '{form.field.disabled.background}',
          hoverBackground: '{surface.400}',
          checkedBackground: '{primary.color}',
          checkedHoverBackground: '{primary.hover.color}'
        },
        handle: {
          background: '{surface.0}',
          disabledBackground: '{form.field.disabled.color}',
          hoverBackground: '{surface.0}',
          checkedBackground: '{surface.0}',
          checkedHoverBackground: '{surface.0}',
          color: '{text.muted.color}',
          hoverColor: '{text.color}',
          checkedColor: '{primary.color}',
          checkedHoverColor: '{primary.hover.color}'
        }
      },
      dark: {
        root: {
          background: '{surface.700}',
          disabledBackground: '{surface.600}',
          hoverBackground: '{surface.600}',
          checkedBackground: '{primary.color}',
          checkedHoverBackground: '{primary.hover.color}'
        },
        handle: {
          background: '{surface.400}',
          disabledBackground: '{surface.900}',
          hoverBackground: '{surface.300}',
          checkedBackground: '{surface.900}',
          checkedHoverBackground: '{surface.900}',
          color: '{surface.900}',
          hoverColor: '{surface.800}',
          checkedColor: '{primary.color}',
          checkedHoverColor: '{primary.hover.color}'
        }
      }
    }
  },
  index$6 = {
    root: {
      background: '{content.background}',
      borderColor: '{content.border.color}',
      borderRadius: '{content.border.radius}',
      color: '{content.color}',
      gap: '0.5rem',
      padding: '0.75rem'
    }
  },
  index$5 = {
    root: {
      maxWidth: '12.5rem',
      gutter: '0.25rem',
      shadow: '{overlay.popover.shadow}',
      padding: '0.5rem 0.75rem',
      borderRadius: '{overlay.popover.border.radius}'
    },
    colorScheme: {
      light: { root: { background: '{surface.700}', color: '{surface.0}' } },
      dark: { root: { background: '{surface.700}', color: '{surface.0}' } }
    }
  },
  index$4 = {
    root: {
      background: '{content.background}',
      color: '{content.color}',
      padding: '1rem',
      gap: '2px',
      indent: '1rem',
      transitionDuration: '{transition.duration}'
    },
    node: {
      padding: '0.25rem 0.5rem',
      borderRadius: '{content.border.radius}',
      hoverBackground: '{content.hover.background}',
      selectedBackground: '{highlight.background}',
      color: '{text.color}',
      hoverColor: '{text.hover.color}',
      selectedColor: '{highlight.color}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '-1px',
        shadow: '{focus.ring.shadow}'
      },
      gap: '0.25rem'
    },
    nodeIcon: {
      color: '{text.muted.color}',
      hoverColor: '{text.hover.muted.color}',
      selectedColor: '{highlight.color}'
    },
    nodeToggleButton: {
      borderRadius: '50%',
      size: '1.75rem',
      hoverBackground: '{content.hover.background}',
      selectedHoverBackground: '{content.background}',
      color: '{text.muted.color}',
      hoverColor: '{text.hover.muted.color}',
      selectedHoverColor: '{primary.color}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    loadingIcon: { size: '2rem' },
    filter: { margin: '0 0 0.5rem 0' }
  },
  index$3 = {
    root: {
      background: '{form.field.background}',
      disabledBackground: '{form.field.disabled.background}',
      filledBackground: '{form.field.filled.background}',
      filledHoverBackground: '{form.field.filled.hover.background}',
      filledFocusBackground: '{form.field.filled.focus.background}',
      borderColor: '{form.field.border.color}',
      hoverBorderColor: '{form.field.hover.border.color}',
      focusBorderColor: '{form.field.focus.border.color}',
      invalidBorderColor: '{form.field.invalid.border.color}',
      color: '{form.field.color}',
      disabledColor: '{form.field.disabled.color}',
      placeholderColor: '{form.field.placeholder.color}',
      invalidPlaceholderColor: '{form.field.invalid.placeholder.color}',
      shadow: '{form.field.shadow}',
      paddingX: '{form.field.padding.x}',
      paddingY: '{form.field.padding.y}',
      borderRadius: '{form.field.border.radius}',
      focusRing: {
        width: '{form.field.focus.ring.width}',
        style: '{form.field.focus.ring.style}',
        color: '{form.field.focus.ring.color}',
        offset: '{form.field.focus.ring.offset}',
        shadow: '{form.field.focus.ring.shadow}'
      },
      transitionDuration: '{form.field.transition.duration}',
      sm: {
        fontSize: '{form.field.sm.font.size}',
        paddingX: '{form.field.sm.padding.x}',
        paddingY: '{form.field.sm.padding.y}'
      },
      lg: {
        fontSize: '{form.field.lg.font.size}',
        paddingX: '{form.field.lg.padding.x}',
        paddingY: '{form.field.lg.padding.y}'
      }
    },
    dropdown: { width: '2.5rem', color: '{form.field.icon.color}' },
    overlay: {
      background: '{overlay.select.background}',
      borderColor: '{overlay.select.border.color}',
      borderRadius: '{overlay.select.border.radius}',
      color: '{overlay.select.color}',
      shadow: '{overlay.select.shadow}'
    },
    tree: { padding: '{list.padding}' },
    clearIcon: { color: '{form.field.icon.color}' },
    emptyMessage: { padding: '{list.option.padding}' },
    chip: { borderRadius: '{border.radius.sm}' }
  },
  index$2 = {
    root: { transitionDuration: '{transition.duration}' },
    header: {
      background: '{content.background}',
      borderColor: '{treetable.border.color}',
      color: '{content.color}',
      borderWidth: '0 0 1px 0',
      padding: '0.75rem 1rem'
    },
    headerCell: {
      background: '{content.background}',
      hoverBackground: '{content.hover.background}',
      selectedBackground: '{highlight.background}',
      borderColor: '{treetable.border.color}',
      color: '{content.color}',
      hoverColor: '{content.hover.color}',
      selectedColor: '{highlight.color}',
      gap: '0.5rem',
      padding: '0.75rem 1rem',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '-1px',
        shadow: '{focus.ring.shadow}'
      }
    },
    columnTitle: { fontWeight: '600' },
    row: {
      background: '{content.background}',
      hoverBackground: '{content.hover.background}',
      selectedBackground: '{highlight.background}',
      color: '{content.color}',
      hoverColor: '{content.hover.color}',
      selectedColor: '{highlight.color}',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '-1px',
        shadow: '{focus.ring.shadow}'
      }
    },
    bodyCell: {
      borderColor: '{treetable.border.color}',
      padding: '0.75rem 1rem',
      gap: '0.5rem'
    },
    footerCell: {
      background: '{content.background}',
      borderColor: '{treetable.border.color}',
      color: '{content.color}',
      padding: '0.75rem 1rem'
    },
    columnFooter: { fontWeight: '600' },
    footer: {
      background: '{content.background}',
      borderColor: '{treetable.border.color}',
      color: '{content.color}',
      borderWidth: '0 0 1px 0',
      padding: '0.75rem 1rem'
    },
    columnResizerWidth: '0.5rem',
    resizeIndicator: { width: '1px', color: '{primary.color}' },
    sortIcon: {
      color: '{text.muted.color}',
      hoverColor: '{text.hover.muted.color}',
      size: '0.875rem'
    },
    loadingIcon: { size: '2rem' },
    nodeToggleButton: {
      hoverBackground: '{content.hover.background}',
      selectedHoverBackground: '{content.background}',
      color: '{text.muted.color}',
      hoverColor: '{text.color}',
      selectedHoverColor: '{primary.color}',
      size: '1.75rem',
      borderRadius: '50%',
      focusRing: {
        width: '{focus.ring.width}',
        style: '{focus.ring.style}',
        color: '{focus.ring.color}',
        offset: '{focus.ring.offset}',
        shadow: '{focus.ring.shadow}'
      }
    },
    paginatorTop: {
      borderColor: '{content.border.color}',
      borderWidth: '0 0 1px 0'
    },
    paginatorBottom: {
      borderColor: '{content.border.color}',
      borderWidth: '0 0 1px 0'
    },
    colorScheme: {
      light: {
        root: { borderColor: '{content.border.color}' },
        bodyCell: { selectedBorderColor: '{primary.100}' }
      },
      dark: {
        root: { borderColor: '{surface.800}' },
        bodyCell: { selectedBorderColor: '{primary.900}' }
      }
    }
  },
  index$1 = {
    loader: {
      mask: { background: '{content.background}', color: '{text.muted.color}' },
      icon: { size: '2rem' }
    }
  }
function _typeof$1(e) {
  return (_typeof$1 =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
function ownKeys(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    t &&
      (o = o.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })),
      n.push.apply(n, o)
  }
  return n
}
function _objectSpread(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {}
    t % 2
      ? ownKeys(Object(n), !0).forEach(function (t) {
          _defineProperty$1(e, t, n[t])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ownKeys(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          })
  }
  return e
}
function _defineProperty$1(e, t, n) {
  return (
    (t = _toPropertyKey$1(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey$1(e) {
  var t = _toPrimitive$1(e, 'string')
  return 'symbol' == _typeof$1(t) ? t : t + ''
}
function _toPrimitive$1(e, t) {
  if ('object' != _typeof$1(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof$1(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
__name(_typeof$1, '_typeof$1'),
  __name(ownKeys, 'ownKeys'),
  __name(_objectSpread, '_objectSpread'),
  __name(_defineProperty$1, '_defineProperty$1'),
  __name(_toPropertyKey$1, '_toPropertyKey$1'),
  __name(_toPrimitive$1, '_toPrimitive$1')
var index = _objectSpread(
    _objectSpread({}, index$1l),
    {},
    {
      components: {
        accordion: index$1p,
        autocomplete: index$1o,
        avatar: index$1n,
        badge: index$1m,
        blockui: index$1k,
        breadcrumb: index$1j,
        button: index$1i,
        datepicker: index$16,
        card: index$1h,
        carousel: index$1g,
        cascadeselect: index$1f,
        checkbox: index$1e,
        chip: index$1d,
        colorpicker: index$1c,
        confirmdialog: index$1b,
        confirmpopup: index$1a,
        contextmenu: index$19,
        dataview: index$17,
        datatable: index$18,
        dialog: index$15,
        divider: index$14,
        dock: index$13,
        drawer: index$12,
        editor: index$11,
        fieldset: index$10,
        fileupload: index$$,
        iftalabel: index$X,
        floatlabel: index$_,
        galleria: index$Z,
        iconfield: index$Y,
        image: index$W,
        imagecompare: index$V,
        inlinemessage: index$U,
        inplace: index$T,
        inputchips: index$S,
        inputgroup: index$R,
        inputnumber: index$Q,
        inputotp: index$P,
        inputtext: index$O,
        knob: index$N,
        listbox: index$M,
        megamenu: index$L,
        menu: index$K,
        menubar: index$J,
        message: index$I,
        metergroup: index$H,
        multiselect: index$G,
        orderlist: index$F,
        organizationchart: index$E,
        overlaybadge: index$D,
        popover: index$x,
        paginator: index$C,
        password: index$z,
        panel: index$B,
        panelmenu: index$A,
        picklist: index$y,
        progressbar: index$w,
        progressspinner: index$v,
        radiobutton: index$u,
        rating: index$t,
        scrollpanel: index$r,
        select: index$q,
        selectbutton: index$p,
        skeleton: index$o,
        slider: index$n,
        speeddial: index$m,
        splitter: index$k,
        splitbutton: index$l,
        stepper: index$j,
        steps: index$i,
        tabmenu: index$h,
        tabs: index$g,
        tabview: index$f,
        textarea: index$c,
        tieredmenu: index$b,
        tag: index$e,
        terminal: index$d,
        timeline: index$a,
        togglebutton: index$8,
        toggleswitch: index$7,
        tree: index$4,
        treeselect: index$3,
        treetable: index$2,
        toast: index$9,
        toolbar: index$6,
        virtualscroller: index$1
      },
      directives: { tooltip: index$5, ripple: index$s }
    }
  ),
  ConfirmationService = {
    install: __name(function (e) {
      var t = {
        require: __name(function (e) {
          ConfirmationEventBus.emit('confirm', e)
        }, 'require'),
        close: __name(function () {
          ConfirmationEventBus.emit('close')
        }, 'close')
      }
      ;(e.config.globalProperties.$confirm = t),
        e.provide(PrimeVueConfirmSymbol, t)
    }, 'install')
  },
  ToastEventBus = EventBus(),
  ToastService = {
    install: __name(function (e) {
      var t = {
        add: __name(function (e) {
          ToastEventBus.emit('add', e)
        }, 'add'),
        remove: __name(function (e) {
          ToastEventBus.emit('remove', e)
        }, 'remove'),
        removeGroup: __name(function (e) {
          ToastEventBus.emit('remove-group', e)
        }, 'removeGroup'),
        removeAllGroups: __name(function () {
          ToastEventBus.emit('remove-all-groups')
        }, 'removeAllGroups')
      }
      ;(e.config.globalProperties.$toast = t), e.provide(PrimeVueToastSymbol, t)
    }, 'install')
  },
  theme = __name(function (e) {
    var t = e.dt
    return '\n.p-tooltip {\n    position: absolute;\n    display: none;\n    max-width: '
      .concat(
        t('tooltip.max.width'),
        ';\n}\n\n.p-tooltip-right,\n.p-tooltip-left {\n    padding: 0 '
      )
      .concat(
        t('tooltip.gutter'),
        ';\n}\n\n.p-tooltip-top,\n.p-tooltip-bottom {\n    padding: '
      )
      .concat(
        t('tooltip.gutter'),
        ' 0;\n}\n\n.p-tooltip-text {\n    white-space: pre-line;\n    word-break: break-word;\n    background: '
      )
      .concat(t('tooltip.background'), ';\n    color: ')
      .concat(t('tooltip.color'), ';\n    padding: ')
      .concat(t('tooltip.padding'), ';\n    box-shadow: ')
      .concat(t('tooltip.shadow'), ';\n    border-radius: ')
      .concat(
        t('tooltip.border.radius'),
        ';\n}\n\n.p-tooltip-arrow {\n    position: absolute;\n    width: 0;\n    height: 0;\n    border-color: transparent;\n    border-style: solid;\n}\n\n.p-tooltip-right .p-tooltip-arrow {\n    margin-top: calc(-1 * '
      )
      .concat(t('tooltip.gutter'), ');\n    border-width: ')
      .concat(t('tooltip.gutter'), ' ')
      .concat(t('tooltip.gutter'), ' ')
      .concat(t('tooltip.gutter'), ' 0;\n    border-right-color: ')
      .concat(
        t('tooltip.background'),
        ';\n}\n\n.p-tooltip-left .p-tooltip-arrow {\n    margin-top: calc(-1 * '
      )
      .concat(t('tooltip.gutter'), ');\n    border-width: ')
      .concat(t('tooltip.gutter'), ' 0 ')
      .concat(t('tooltip.gutter'), ' ')
      .concat(t('tooltip.gutter'), ';\n    border-left-color: ')
      .concat(
        t('tooltip.background'),
        ';\n}\n\n.p-tooltip-top .p-tooltip-arrow {\n    margin-left: calc(-1 * '
      )
      .concat(t('tooltip.gutter'), ');\n    border-width: ')
      .concat(t('tooltip.gutter'), ' ')
      .concat(t('tooltip.gutter'), ' 0 ')
      .concat(t('tooltip.gutter'), ';\n    border-top-color: ')
      .concat(t('tooltip.background'), ';\n    border-bottom-color: ')
      .concat(
        t('tooltip.background'),
        ';\n}\n\n.p-tooltip-bottom .p-tooltip-arrow {\n    margin-left: calc(-1 * '
      )
      .concat(t('tooltip.gutter'), ');\n    border-width: 0 ')
      .concat(t('tooltip.gutter'), ' ')
      .concat(t('tooltip.gutter'), ' ')
      .concat(t('tooltip.gutter'), ';\n    border-top-color: ')
      .concat(t('tooltip.background'), ';\n    border-bottom-color: ')
      .concat(t('tooltip.background'), ';\n}\n')
  }, 'theme'),
  classes = {
    root: 'p-tooltip p-component',
    arrow: 'p-tooltip-arrow',
    text: 'p-tooltip-text'
  },
  TooltipStyle = BaseStyle.extend({
    name: 'tooltip-directive',
    theme: theme,
    classes: classes
  }),
  BaseTooltip = BaseDirective.extend({ style: TooltipStyle })
function _slicedToArray(e, t) {
  return (
    _arrayWithHoles(e) ||
    _iterableToArrayLimit(e, t) ||
    _unsupportedIterableToArray(e, t) ||
    _nonIterableRest()
  )
}
function _nonIterableRest() {
  throw new TypeError(
    'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray(e, t) {
  if (e) {
    if ('string' == typeof e) return _arrayLikeToArray(e, t)
    var n = {}.toString.call(e).slice(8, -1)
    return (
      'Object' === n && e.constructor && (n = e.constructor.name),
      'Map' === n || 'Set' === n
        ? Array.from(e)
        : 'Arguments' === n ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? _arrayLikeToArray(e, t)
          : void 0
    )
  }
}
function _arrayLikeToArray(e, t) {
  ;(null == t || t > e.length) && (t = e.length)
  for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n]
  return o
}
function _iterableToArrayLimit(e, t) {
  var n =
    null == e
      ? null
      : ('undefined' != typeof Symbol && e[Symbol.iterator]) || e['@@iterator']
  if (null != n) {
    var o,
      i,
      r,
      a,
      s = [],
      l = !0,
      c = !1
    try {
      if (((r = (n = n.call(e)).next), 0 === t));
      else
        for (
          ;
          !(l = (o = r.call(n)).done) && (s.push(o.value), s.length !== t);
          l = !0
        );
    } catch (d) {
      ;(c = !0), (i = d)
    } finally {
      try {
        if (!l && null != n.return && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (c) throw i
      }
    }
    return s
  }
}
function _arrayWithHoles(e) {
  if (Array.isArray(e)) return e
}
function _defineProperty(e, t, n) {
  return (
    (t = _toPropertyKey(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _toPropertyKey(e) {
  var t = _toPrimitive(e, 'string')
  return 'symbol' == _typeof(t) ? t : t + ''
}
function _toPrimitive(e, t) {
  if ('object' != _typeof(e) || !e) return e
  var n = e[Symbol.toPrimitive]
  if (void 0 !== n) {
    var o = n.call(e, t || 'default')
    if ('object' != _typeof(o)) return o
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === t ? String : Number)(e)
}
function _typeof(e) {
  return (_typeof =
    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
          return typeof e
        }
      : function (e) {
          return e &&
            'function' == typeof Symbol &&
            e.constructor === Symbol &&
            e !== Symbol.prototype
            ? 'symbol'
            : typeof e
        })(e)
}
__name(_slicedToArray, '_slicedToArray'),
  __name(_nonIterableRest, '_nonIterableRest'),
  __name(_unsupportedIterableToArray, '_unsupportedIterableToArray'),
  __name(_arrayLikeToArray, '_arrayLikeToArray'),
  __name(_iterableToArrayLimit, '_iterableToArrayLimit'),
  __name(_arrayWithHoles, '_arrayWithHoles'),
  __name(_defineProperty, '_defineProperty'),
  __name(_toPropertyKey, '_toPropertyKey'),
  __name(_toPrimitive, '_toPrimitive'),
  __name(_typeof, '_typeof')
var Tooltip = BaseTooltip.extend('tooltip', {
  beforeMount: __name(function (e, t) {
    var n,
      o = this.getTarget(e)
    if (((o.$_ptooltipModifiers = this.getModifiers(t)), t.value)) {
      if ('string' == typeof t.value)
        (o.$_ptooltipValue = t.value),
          (o.$_ptooltipDisabled = !1),
          (o.$_ptooltipEscape = !0),
          (o.$_ptooltipClass = null),
          (o.$_ptooltipFitContent = !0),
          (o.$_ptooltipIdAttr = UniqueComponentId() + '_tooltip'),
          (o.$_ptooltipShowDelay = 0),
          (o.$_ptooltipHideDelay = 0),
          (o.$_ptooltipAutoHide = !0)
      else if ('object' === _typeof(t.value) && t.value) {
        if (isEmpty(t.value.value) || '' === t.value.value.trim()) return
        ;(o.$_ptooltipValue = t.value.value),
          (o.$_ptooltipDisabled =
            !!t.value.disabled === t.value.disabled && t.value.disabled),
          (o.$_ptooltipEscape =
            !!t.value.escape !== t.value.escape || t.value.escape),
          (o.$_ptooltipClass = t.value.class || ''),
          (o.$_ptooltipFitContent =
            !!t.value.fitContent !== t.value.fitContent || t.value.fitContent),
          (o.$_ptooltipIdAttr = t.value.id || UniqueComponentId() + '_tooltip'),
          (o.$_ptooltipShowDelay = t.value.showDelay || 0),
          (o.$_ptooltipHideDelay = t.value.hideDelay || 0),
          (o.$_ptooltipAutoHide =
            !!t.value.autoHide !== t.value.autoHide || t.value.autoHide)
      }
      ;(o.$_ptooltipZIndex =
        null === (n = t.instance.$primevue) ||
        void 0 === n ||
        null === (n = n.config) ||
        void 0 === n ||
        null === (n = n.zIndex) ||
        void 0 === n
          ? void 0
          : n.tooltip),
        this.bindEvents(o, t),
        e.setAttribute('data-pd-tooltip', !0)
    }
  }, 'beforeMount'),
  updated: __name(function (e, t) {
    var n = this.getTarget(e)
    if (
      ((n.$_ptooltipModifiers = this.getModifiers(t)),
      this.unbindEvents(n),
      t.value)
    )
      if ('string' == typeof t.value)
        (n.$_ptooltipValue = t.value),
          (n.$_ptooltipDisabled = !1),
          (n.$_ptooltipEscape = !0),
          (n.$_ptooltipClass = null),
          (n.$_ptooltipIdAttr =
            n.$_ptooltipIdAttr || UniqueComponentId() + '_tooltip'),
          (n.$_ptooltipShowDelay = 0),
          (n.$_ptooltipHideDelay = 0),
          (n.$_ptooltipAutoHide = !0),
          this.bindEvents(n, t)
      else if ('object' === _typeof(t.value) && t.value) {
        if (isEmpty(t.value.value) || '' === t.value.value.trim())
          return void this.unbindEvents(n, t)
        ;(n.$_ptooltipValue = t.value.value),
          (n.$_ptooltipDisabled =
            !!t.value.disabled === t.value.disabled && t.value.disabled),
          (n.$_ptooltipEscape =
            !!t.value.escape !== t.value.escape || t.value.escape),
          (n.$_ptooltipClass = t.value.class || ''),
          (n.$_ptooltipFitContent =
            !!t.value.fitContent !== t.value.fitContent || t.value.fitContent),
          (n.$_ptooltipIdAttr =
            t.value.id ||
            n.$_ptooltipIdAttr ||
            UniqueComponentId() + '_tooltip'),
          (n.$_ptooltipShowDelay = t.value.showDelay || 0),
          (n.$_ptooltipHideDelay = t.value.hideDelay || 0),
          (n.$_ptooltipAutoHide =
            !!t.value.autoHide !== t.value.autoHide || t.value.autoHide),
          this.bindEvents(n, t)
      }
  }, 'updated'),
  unmounted: __name(function (e, t) {
    var n = this.getTarget(e)
    this.remove(n),
      this.unbindEvents(n, t),
      n.$_ptooltipScrollHandler &&
        (n.$_ptooltipScrollHandler.destroy(),
        (n.$_ptooltipScrollHandler = null))
  }, 'unmounted'),
  timer: void 0,
  methods: {
    bindEvents: __name(function (e, t) {
      var n = this
      e.$_ptooltipModifiers.focus
        ? ((e.$_focusevent = function (e) {
            return n.onFocus(e, t)
          }),
          e.addEventListener('focus', e.$_focusevent),
          e.addEventListener('blur', this.onBlur.bind(this)))
        : ((e.$_mouseenterevent = function (e) {
            return n.onMouseEnter(e, t)
          }),
          e.addEventListener('mouseenter', e.$_mouseenterevent),
          e.addEventListener('mouseleave', this.onMouseLeave.bind(this)),
          e.addEventListener('click', this.onClick.bind(this))),
        e.addEventListener('keydown', this.onKeydown.bind(this))
    }, 'bindEvents'),
    unbindEvents: __name(function (e) {
      e.$_ptooltipModifiers.focus
        ? (e.removeEventListener('focus', e.$_focusevent),
          (e.$_focusevent = null),
          e.removeEventListener('blur', this.onBlur.bind(this)))
        : (e.removeEventListener('mouseenter', e.$_mouseenterevent),
          (e.$_mouseenterevent = null),
          e.removeEventListener('mouseleave', this.onMouseLeave.bind(this)),
          e.removeEventListener('click', this.onClick.bind(this))),
        e.removeEventListener('keydown', this.onKeydown.bind(this))
    }, 'unbindEvents'),
    bindScrollListener: __name(function (e) {
      var t = this
      e.$_ptooltipScrollHandler ||
        (e.$_ptooltipScrollHandler = new ConnectedOverlayScrollHandler(
          e,
          function () {
            t.hide(e)
          }
        )),
        e.$_ptooltipScrollHandler.bindScrollListener()
    }, 'bindScrollListener'),
    unbindScrollListener: __name(function (e) {
      e.$_ptooltipScrollHandler &&
        e.$_ptooltipScrollHandler.unbindScrollListener()
    }, 'unbindScrollListener'),
    onMouseEnter: __name(function (e, t) {
      var n = e.currentTarget,
        o = n.$_ptooltipShowDelay
      this.show(n, t, o)
    }, 'onMouseEnter'),
    onMouseLeave: __name(function (e) {
      var t = e.currentTarget,
        n = t.$_ptooltipHideDelay
      t.$_ptooltipAutoHide
        ? this.hide(t, n)
        : !(
            'tooltip' === getAttribute(e.target, 'data-pc-name') ||
            'arrow' === getAttribute(e.target, 'data-pc-section') ||
            'text' === getAttribute(e.target, 'data-pc-section') ||
            'tooltip' === getAttribute(e.relatedTarget, 'data-pc-name') ||
            'arrow' === getAttribute(e.relatedTarget, 'data-pc-section') ||
            'text' === getAttribute(e.relatedTarget, 'data-pc-section')
          ) && this.hide(t, n)
    }, 'onMouseLeave'),
    onFocus: __name(function (e, t) {
      var n = e.currentTarget,
        o = n.$_ptooltipShowDelay
      this.show(n, t, o)
    }, 'onFocus'),
    onBlur: __name(function (e) {
      var t = e.currentTarget,
        n = t.$_ptooltipHideDelay
      this.hide(t, n)
    }, 'onBlur'),
    onClick: __name(function (e) {
      var t = e.currentTarget,
        n = t.$_ptooltipHideDelay
      this.hide(t, n)
    }, 'onClick'),
    onKeydown: __name(function (e) {
      var t = e.currentTarget.$_ptooltipHideDelay
      'Escape' === e.code && this.hide(e.currentTarget, t)
    }, 'onKeydown'),
    tooltipActions: __name(function (e, t) {
      if (!e.$_ptooltipDisabled && isExist(e)) {
        var n = this.create(e, t)
        this.align(e), !this.isUnstyled() && fadeIn(n, 250)
        var o = this
        window.addEventListener(
          'resize',
          __name(function t() {
            isTouchDevice() || o.hide(e),
              window.removeEventListener('resize', t)
          }, 'onWindowResize')
        ),
          n.addEventListener(
            'mouseleave',
            __name(function t() {
              o.hide(e),
                n.removeEventListener('mouseleave', t),
                e.removeEventListener('mouseenter', e.$_mouseenterevent),
                setTimeout(function () {
                  return e.addEventListener('mouseenter', e.$_mouseenterevent)
                }, 50)
            }, 'onTooltipLeave')
          ),
          this.bindScrollListener(e),
          ZIndex.set('tooltip', n, e.$_ptooltipZIndex)
      }
    }, 'tooltipActions'),
    show: __name(function (e, t, n) {
      var o = this
      void 0 !== n
        ? (this.timer = setTimeout(function () {
            return o.tooltipActions(e, t)
          }, n))
        : this.tooltipActions(e, t)
    }, 'show'),
    tooltipRemoval: __name(function (e) {
      this.remove(e), this.unbindScrollListener(e)
    }, 'tooltipRemoval'),
    hide: __name(function (e, t) {
      var n = this
      clearTimeout(this.timer),
        void 0 !== t
          ? setTimeout(function () {
              return n.tooltipRemoval(e)
            }, t)
          : this.tooltipRemoval(e)
    }, 'hide'),
    getTooltipElement: __name(function (e) {
      return document.getElementById(e.$_ptooltipId)
    }, 'getTooltipElement'),
    create: __name(function (e) {
      var t = e.$_ptooltipModifiers,
        n = createElement('div', {
          class: !this.isUnstyled() && this.cx('arrow'),
          'p-bind': this.ptm('arrow', { context: t })
        }),
        o = createElement('div', {
          class: !this.isUnstyled() && this.cx('text'),
          'p-bind': this.ptm('text', { context: t })
        })
      e.$_ptooltipEscape
        ? ((o.innerHTML = ''),
          o.appendChild(document.createTextNode(e.$_ptooltipValue)))
        : (o.innerHTML = e.$_ptooltipValue)
      var i = createElement(
        'div',
        _defineProperty(
          _defineProperty(
            {
              id: e.$_ptooltipIdAttr,
              role: 'tooltip',
              style: {
                display: 'inline-block',
                width: e.$_ptooltipFitContent ? 'fit-content' : void 0,
                pointerEvents:
                  !this.isUnstyled() && e.$_ptooltipAutoHide && 'none'
              },
              class: [!this.isUnstyled() && this.cx('root'), e.$_ptooltipClass]
            },
            this.$attrSelector,
            ''
          ),
          'p-bind',
          this.ptm('root', { context: t })
        ),
        n,
        o
      )
      return (
        document.body.appendChild(i), (e.$_ptooltipId = i.id), (this.$el = i), i
      )
    }, 'create'),
    remove: __name(function (e) {
      if (e) {
        var t = this.getTooltipElement(e)
        t && t.parentElement && (ZIndex.clear(t), document.body.removeChild(t)),
          (e.$_ptooltipId = null)
      }
    }, 'remove'),
    align: __name(function (e) {
      var t = e.$_ptooltipModifiers
      t.top
        ? (this.alignTop(e),
          this.isOutOfBounds(e) &&
            (this.alignBottom(e), this.isOutOfBounds(e) && this.alignTop(e)))
        : t.left
          ? (this.alignLeft(e),
            this.isOutOfBounds(e) &&
              (this.alignRight(e),
              this.isOutOfBounds(e) &&
                (this.alignTop(e),
                this.isOutOfBounds(e) &&
                  (this.alignBottom(e),
                  this.isOutOfBounds(e) && this.alignLeft(e)))))
          : t.bottom
            ? (this.alignBottom(e),
              this.isOutOfBounds(e) &&
                (this.alignTop(e),
                this.isOutOfBounds(e) && this.alignBottom(e)))
            : (this.alignRight(e),
              this.isOutOfBounds(e) &&
                (this.alignLeft(e),
                this.isOutOfBounds(e) &&
                  (this.alignTop(e),
                  this.isOutOfBounds(e) &&
                    (this.alignBottom(e),
                    this.isOutOfBounds(e) && this.alignRight(e)))))
    }, 'align'),
    getHostOffset: __name(function (e) {
      var t = e.getBoundingClientRect()
      return {
        left: t.left + getWindowScrollLeft(),
        top: t.top + getWindowScrollTop()
      }
    }, 'getHostOffset'),
    alignRight: __name(function (e) {
      this.preAlign(e, 'right')
      var t = this.getTooltipElement(e),
        n = this.getHostOffset(e),
        o = n.left + getOuterWidth(e),
        i = n.top + (getOuterHeight(e) - getOuterHeight(t)) / 2
      ;(t.style.left = o + 'px'), (t.style.top = i + 'px')
    }, 'alignRight'),
    alignLeft: __name(function (e) {
      this.preAlign(e, 'left')
      var t = this.getTooltipElement(e),
        n = this.getHostOffset(e),
        o = n.left - getOuterWidth(t),
        i = n.top + (getOuterHeight(e) - getOuterHeight(t)) / 2
      ;(t.style.left = o + 'px'), (t.style.top = i + 'px')
    }, 'alignLeft'),
    alignTop: __name(function (e) {
      this.preAlign(e, 'top')
      var t = this.getTooltipElement(e),
        n = this.getHostOffset(e),
        o = n.left + (getOuterWidth(e) - getOuterWidth(t)) / 2,
        i = n.top - getOuterHeight(t)
      ;(t.style.left = o + 'px'), (t.style.top = i + 'px')
    }, 'alignTop'),
    alignBottom: __name(function (e) {
      this.preAlign(e, 'bottom')
      var t = this.getTooltipElement(e),
        n = this.getHostOffset(e),
        o = n.left + (getOuterWidth(e) - getOuterWidth(t)) / 2,
        i = n.top + getOuterHeight(e)
      ;(t.style.left = o + 'px'), (t.style.top = i + 'px')
    }, 'alignBottom'),
    preAlign: __name(function (e, t) {
      var n = this.getTooltipElement(e)
      ;(n.style.left = '-999px'),
        (n.style.top = '-999px'),
        removeClass(n, 'p-tooltip-'.concat(n.$_ptooltipPosition)),
        !this.isUnstyled() && addClass(n, 'p-tooltip-'.concat(t)),
        (n.$_ptooltipPosition = t),
        n.setAttribute('data-p-position', t)
      var o = findSingle(n, '[data-pc-section="arrow"]')
      ;(o.style.top =
        'bottom' === t
          ? '0'
          : 'right' === t ||
              'left' === t ||
              ('right' !== t && 'left' !== t && 'top' !== t && 'bottom' !== t)
            ? '50%'
            : null),
        (o.style.bottom = 'top' === t ? '0' : null),
        (o.style.left =
          'right' === t ||
          ('right' !== t && 'left' !== t && 'top' !== t && 'bottom' !== t)
            ? '0'
            : 'top' === t || 'bottom' === t
              ? '50%'
              : null),
        (o.style.right = 'left' === t ? '0' : null)
    }, 'preAlign'),
    isOutOfBounds: __name(function (e) {
      var t = this.getTooltipElement(e),
        n = t.getBoundingClientRect(),
        o = n.top,
        i = n.left,
        r = getOuterWidth(t),
        a = getOuterHeight(t),
        s = getViewport()
      return i + r > s.width || i < 0 || o < 0 || o + a > s.height
    }, 'isOutOfBounds'),
    getTarget: __name(function (e) {
      var t
      return hasClass(e, 'p-inputwrapper') &&
        null !== (t = findSingle(e, 'input')) &&
        void 0 !== t
        ? t
        : e
    }, 'getTarget'),
    getModifiers: __name(function (e) {
      return e.modifiers && Object.keys(e.modifiers).length
        ? e.modifiers
        : e.arg && 'object' === _typeof(e.arg)
          ? Object.entries(e.arg).reduce(function (e, t) {
              var n = _slicedToArray(t, 2),
                o = n[0],
                i = n[1]
              return ('event' !== o && 'position' !== o) || (e[i] = !0), e
            }, {})
          : {}
    }, 'getModifiers')
  }
})
const ComfyUIPreset = definePreset(index, {
    semantic: { primary: index.primitive.blue }
  }),
  app = Vue.createApp(_sfc_main$1),
  pinia = createPinia()
app.directive('tooltip', Tooltip),
  app
    .use(router)
    .use(PrimeVue, {
      theme: {
        preset: ComfyUIPreset,
        options: {
          prefix: 'p',
          cssLayer: { name: 'primevue', order: 'primevue, tailwind-utilities' },
          darkModeSelector: '.dark-theme, :root:has(.dark-theme)'
        }
      }
    })
    .use(ConfirmationService)
    .use(ToastService)
    .use(pinia)
    .use(i18n)
    .mount('#vue-app')
export {
  script$y as $,
  useBottomPanelStore as A,
  BaseStyle as B,
  script$I as C,
  getVNodeProp as D,
  EditableText as E,
  isArray$1 as F,
  useSidebarTabStore as G,
  isNotEmpty as H,
  script$Q as I,
  resolveFieldData as J,
  isEmpty as K,
  LGraphGroup as L,
  addStyle as M,
  relativePosition as N,
  OverlayEventBus as O,
  absolutePosition as P,
  ConnectedOverlayScrollHandler as Q,
  Ripple as R,
  SettingDialogHeader as S,
  isTouchDevice as T,
  UniqueComponentId as U,
  findLastIndex as V,
  script$P as W,
  script$N as X,
  script$w as Y,
  ZIndex as Z,
  _export_sfc as _,
  app$1 as a,
  useEventBus as a$,
  script$O as a0,
  script$D as a1,
  useNodeFrequencyStore as a2,
  useNodeBookmarkStore as a3,
  highlightQuery as a4,
  script$C as a5,
  formatNumberWithSuffix as a6,
  NodeSourceType as a7,
  useNodeDefStore as a8,
  NodePreview as a9,
  script$X as aA,
  script$V as aB,
  script$E as aC,
  script$x as aD,
  ToastEventBus as aE,
  setAttribute as aF,
  useToast as aG,
  useToastStore as aH,
  useExecutionStore as aI,
  useTitle as aJ,
  script$9 as aK,
  script$h as aL,
  resolve as aM,
  script$i as aN,
  script$B as aO,
  isPrintableCharacter as aP,
  useMenuItemStore as aQ,
  normalizeI18nKey as aR,
  script$l as aS,
  nestedPosition as aT,
  useQueueSettingsStore as aU,
  script$z as aV,
  useQueuePendingTaskCountStore as aW,
  useLocalStorage as aX,
  useDraggable as aY,
  watchDebounced as aZ,
  useElementBounding as a_,
  script$b as aa,
  NodeSearchFilter as ab,
  SearchFilterChip as ac,
  storeToRefs as ad,
  useEventListener as ae,
  LinkReleaseTriggerAction as af,
  getColorPalette as ag,
  BadgePosition as ah,
  LGraphBadge as ai,
  defaultColorPalette as aj,
  NodeBadgeMode as ak,
  useModelToNodeStore as al,
  CanvasPointer as am,
  useWorkflowStore as an,
  setStorageValue as ao,
  api as ap,
  usePragmaticDroppable as aq,
  ComfyNodeDefImpl as ar,
  ComfyModelDef as as,
  LGraph$1 as at,
  LLink as au,
  DragAndScale as av,
  LGraphCanvas as aw,
  ContextMenu as ax,
  ChangeTracker as ay,
  workflowService as az,
  LGraphNode as b,
  script$G as b0,
  LGraphEventMode as b1,
  useQueueStore as b2,
  showTemplateWorkflowsDialog as b3,
  showSettingsDialog as b4,
  i18n as b5,
  useModelStore as b6,
  script$v as b7,
  script$n as b8,
  ProgressStatus as b9,
  invokeElementMethod as bA,
  getNextElementSibling as bB,
  getPreviousElementSibling as bC,
  _default as bD,
  FilterOperator as bE,
  FocusTrap as bF,
  getIndex as bG,
  isClickable as bH,
  clearSelection as bI,
  localeComparator as bJ,
  sort as bK,
  FilterService as bL,
  exportCSV as bM,
  getHiddenElementOuterWidth as bN,
  getHiddenElementOuterHeight as bO,
  reorderArray as bP,
  removeClass as bQ,
  addClass as bR,
  useCopyToClipboard as bS,
  FormItem as bT,
  BaseTerminal as ba,
  electronAPI as bb,
  findIndexInList as bc,
  find as bd,
  script$T as be,
  script$S as bf,
  MigrationItems as bg,
  script$k as bh,
  script$u as bi,
  ComfyDialog as bj,
  $el as bk,
  ComfyApp as bl,
  DraggableList as bm,
  serialise as bn,
  deserialiseAndCreate as bo,
  KeyComboImpl as bp,
  ComfyWidgets as bq,
  applyTextReplacements as br,
  isElectron as bs,
  addValueControlWidgets as bt,
  FilterMatchMode as bu,
  _sfc_main$I as bv,
  SearchBox as bw,
  KeybindingImpl as bx,
  useExtensionStore as by,
  getFirstFocusableElement as bz,
  LiteGraph as c,
  defineStore as d,
  script$K as e,
  useCommandStore as f,
  useDialogStore as g,
  SettingDialogContent as h,
  useUserStore as i,
  useWorkspaceStore as j,
  useKeybindingStore as k,
  script$Y as l,
  getWidth as m,
  isRTL as n,
  findSingle as o,
  getOuterHeight as p,
  getOffset as q,
  getOuterWidth as r,
  script$L as s,
  getHeight as t,
  useSettingStore as u,
  script$q as v,
  script$p as w,
  getAttribute as x,
  focus as y,
  equals as z
}
